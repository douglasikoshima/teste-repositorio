// Pessoa.cpp: implementation of the CPessoa class.
//
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw/tuxfw.h>
#include <Defines/Defines.h>
#include <Pessoa/Pessoa.hpp>
#include <Util/Util.hpp>
#include <cstring>

using namespace std;


EXEC SQL INCLUDE SQLCA;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPessoa::CPessoa()
{  	
	m_oEndereco = NULL;
	m_oRelac = NULL;
	m_oEmail = NULL;
    m_iIdPessoa = -1; 
	m_iIdPessoaLinha = -1;
	m_iIdUsuarioAlteracao = -1;
	m_iIdTipoRelacionamento = -1;
	m_iTipoComunicacao = -1;
	strcpy( this->m_cNmPessoa, "" );
	strcpy( this->m_cDsContato, "" );
	strcpy( this->m_cDtUltimaAlteracao, "" );
	
	strcpy( this->m_dtHabilitacao, "" );
	strcpy( this->m_dtAlteracaoStatus, "" );

	this->m_nrLinha = -1;
	this->m_cdAreaRegistro -1;
}


CPessoa::~CPessoa() {
	if(NULL != this->m_oEndereco){
       delete this->m_oEndereco;
    }
	if(NULL != this->m_oRelac){
		delete this->m_oRelac;
	}
	if(NULL != this->m_oEmail){
		delete this->m_oEmail;
	}
}

CPessoa* CPessoa::createInstance(){
       return new CPessoa();
}


/*

  GETs

*/

long CPessoa::getIdPessoa() {
	return this->m_iIdPessoa;
}

char * CPessoa::get_dtHabilitacao() 
{
	return this->m_dtHabilitacao;
}

char * CPessoa::get_dtAlteracaoStatus() 
{
	return this->m_dtAlteracaoStatus;
}

int CPessoa::getIdPessoaDePara() {
	return this->m_iIdPessoaDePara;
}

int CPessoa::getIdConta(){
	return this->m_iIdConta;
}

char * CPessoa::getIdLinhaSistemaOrigem(){
	return this->m_cIdLinhaSistemaOrigem;
}

char * CPessoa::getIdContaSistemaOrigem(){
	return this->m_cIdContaSistemaOrigem;
}


char * CPessoa::getNmPessoa() {
	return this->m_cNmPessoa;
}

char * CPessoa::getNmNome() {
	return this->m_cNmNome;
}

char * CPessoa::getSgSexo() {
	return this->m_cSgSexo;
}

char * CPessoa::getDtNascimento() {
	return this->m_cDtNascimento;
}

char * CPessoa::getNomeUsuario() {
	return this->m_cNomeUsuario;
}

char * CPessoa::getNomeCliente() {
	return this->m_cNomeCliente;
}
char * CPessoa::getDsContato() {
	return this->m_cDsContato;
}

int CPessoa::getIdUsuarioAlteracao() {
	return this->m_iIdUsuarioAlteracao;
}

char * CPessoa::getDtUltimaAlteracao() {
	return this->m_cDtUltimaAlteracao;
}

CEndereco * CPessoa::getEndereco() {
	if(this->m_oEndereco == NULL)
		this->m_oEndereco = new CEndereco();
	return this->m_oEndereco;
}

CRelacionamento * CPessoa::getRel() {
	if(this->m_oRelac == NULL)
		this->m_oRelac = new CRelacionamento();
	return this->m_oRelac;
}

CEmail * CPessoa::getEmail(){
	if (this->m_oEmail == NULL)
		this->m_oEmail = new CEmail();
	return this->m_oEmail;
}


int CPessoa::getIdTipoRelacionamento(){
	return m_iIdTipoRelacionamento;
}


char* CPessoa::getSgTipoRelacionamento(){
	return m_cSgTipoRelacionamento;
}



char* CPessoa::getCpf(){
	return m_cCpf;
}

long CPessoa::getIdPessoaLinha(){
	return this->m_iIdPessoaLinha;
}

int CPessoa::getIdTipoPessoa(){
	return m_iIdTipoPessoa;
}

int CPessoa::getIdTipoCarteira(){
	return m_iIdTipoCarteira;
}

long CPessoa::getIdPessoaCliente(){
	return this->m_iIdPessoaCliente;
}

CSenha& CPessoa::getSenha()
{
	return this->m_oSenha;
}

int CPessoa::getTipoComunicacao()
{
	return m_iTipoComunicacao;
}

int CPessoa::getIdTipoCliente()
{
	return m_iIdTipoCliente;	
	
}

int CPessoa::getIdTipoUsuario ()
{
	return m_iIdTipoUsuario;
}

char* CPessoa::getNrDocumento()
{
	return m_cNrDocumento;

}

char* CPessoa::getDsTipoDocumento()
{
	return m_cDsTipoDocumento;

}


list <CEndereco> &CPessoa::getListaEnderecos()
{
	return this->listaEnderecos;
}
list <CEmail> &CPessoa::getListaEmails()
{
	return this->listaEmails;
}
/*
 
   SETs

*/

void CPessoa::setIdPessoa(long value) {
	this->m_iIdPessoa = value;
}

void CPessoa::set_dtHabilitacao(char * value )
{
	strcpy( this->m_dtHabilitacao, value );
}



void CPessoa::set_dtAlteracaoStatus(char * value )
{
	strcpy( this->m_dtAlteracaoStatus, value );
}



void CPessoa::setIdPessoaDePara(int value) {
	this->m_iIdPessoaDePara = value;
}

void CPessoa::setNmPessoa(char *value) {
	strcpy( this->m_cNmPessoa, value );
}

void CPessoa::setNmNome(char *value) {
	strcpy( this->m_cNmNome, value );
}

void CPessoa::setSgSexo(char *value) {
	strcpy( this->m_cSgSexo, value );
}

void CPessoa::setDtNascimento(char *value) {
	strcpy( this->m_cDtNascimento, value );
}

void CPessoa::setNomeUsuario(char *value) {
	strcpy( this->m_cNomeUsuario, value );
//	memcpy(this->m_cNomeUsuario, value, strlen(value));
}

void CPessoa::setIdConta(int value){
	this->m_iIdConta = value;
}

void CPessoa::setIdLinhaSistemaOrigem(char *value){
	strcpy(this->m_cIdLinhaSistemaOrigem, value);
}


void CPessoa::setIdContaSistemaOrigem(char *value){
	strcpy(this->m_cIdContaSistemaOrigem, value);
}


void CPessoa::setNomeCliente(char *value) {
	strcpy( this->m_cNomeCliente, value );
//	memcpy(this->m_cNomeCliente, value, strlen(value));
}
void CPessoa::setDsContato(char *value) {
	strcpy( this->m_cDsContato, value );
}


void CPessoa::setIdUsuarioAlteracao(int value) {
	this->m_iIdUsuarioAlteracao = value;
}

void CPessoa::setDtUltimaAlteracao(char *value) {
	strcpy( this->m_cDtUltimaAlteracao, value );
}

void CPessoa::setEndereco( const CEndereco & value ) {
	if( NULL != this->m_oEndereco )
		delete this->m_oEndereco;

	this->m_oEndereco = new CEndereco( value );
}

void CPessoa::setIdTipoRelacionamento(int value){
	this->m_iIdTipoRelacionamento = value ;

	 }
void CPessoa::setCpf(char *value){
		strcpy( this->m_cCpf, value );
}

void CPessoa::setSgTipoRelacionamento(char *value){
		strcpy( this->m_cSgTipoRelacionamento, value );
}

void CPessoa::setIdPessoaLinha( long value){
		this->m_iIdPessoaLinha = value;
}

void CPessoa::setIdTipoPessoa(int value){
	this->m_iIdTipoPessoa = value;
}

void CPessoa::setIdTipoCarteira(int value){
	this->m_iIdTipoCarteira = value;
}

void CPessoa::setIdPessoaCliente(long value){
	this->m_iIdPessoaCliente = value;

}

void CPessoa::setTipoComunicacao(int value)
{
	m_iTipoComunicacao = value;
}

void CPessoa::setIdTipoCliente(int value)
{
	m_iIdTipoCliente = value;
}

void CPessoa:: setIdTipoUsuario (int value)
{
	m_iIdTipoUsuario = value;
}


void CPessoa::setNrDocumento(char* value)
{
	strcpy(m_cNrDocumento, value);

}

void CPessoa::setDsTipoDocumento(char* value)
{

	strcpy(m_cDsTipoDocumento, value);

}

//Metodos de Negocio da Interface da Classe CPessoa:

void CPessoa::consultarNome() {
	 this->consultarNmPessoaDB();
}

void CPessoa::consultarNomeUsuario(int iArea, int iNro){
	this->consultarNomeUsuarioDB(iArea, iNro);
}

void CPessoa::consultarNomeCliente(int iArea, int iNro){
	this->consultarNomeClienteDB(iArea, iNro);
}

void CPessoa::consultarEMail(void) {
	 this->consultarDsContatoDB();
}

void CPessoa::alterarEMail(void) {
 	this->alterarDsContatoDB();
}

void CPessoa::inserirEMail(void) {
 	this->inserirDsContatoDB();
}

int CPessoa::getNrLinha()
{
	return this->m_nrLinha;
}
int CPessoa::getCdAreaRegistro()
{
	return this->m_cdAreaRegistro;
}

void CPessoa::setNrLinha(int nrLinha)
{
	this->m_nrLinha = nrLinha;
}
void CPessoa::setCdAreaRegistro(int cdAreaRegistro)
{
	this->m_cdAreaRegistro = cdAreaRegistro;
}

void CPessoa::obterDadosPessoaSessao(int area, int nro, char* senha)
{
	this->consultarDadosSessaoDB(area, nro, senha);
}

void CPessoa::obterDadosPessoaSessaoSemSenha( int area, int nro )
{
    tuxfw_getlogger()->debug( ">>> CPessoa::obterDadosPessoaSessaoSemSenha()" );

	this->consultarDadosSessaoSemSenhaDB( area, nro );
}

void CPessoa::obterIdPessoa(int codArea, int nroLinha){
	this->consultarIdPessoaDB(codArea, nroLinha);
}

void CPessoa::obterIdPessoaLinha(int cdAreaRegistro, int nrLinha)
{
	this->consultarIdPessoaLinhaDB(cdAreaRegistro, nrLinha);
}

//Metodos que acionanam CRelacionamento

void CPessoa::consultarHistQtdRelac(  list< CRelacionamento > & listaRelac,
												char * cQtRelac,
												char * cIdCanal){

	this->getRel()->setCanalPesquisa(cIdCanal);
	this->getRel()->setQtdRelac(atoi(cQtRelac));
	this->getRel()->consultarUltimosRelacionamentos( (this->getIdPessoa()) , listaRelac );
}

void CPessoa::consultarHistQtdRelacCanal(  list< CRelacionamento > & listaRelac,
 												int  iQtRelac,
 												int  iIdCanal){
 
 	this->getRel()->setIdCanal(iIdCanal);
 	this->getRel()->setQtdRelac(iQtRelac);
 	this->getRel()->consultarUltimosRelacionamentosCanal( (this->getIdPessoa()) , listaRelac );
}

void CPessoa::consultarHistRangeDate(	list< CRelacionamento > & listaRelac,  
												char * cDtInicio,
												char * cDtFinal,
												char * cIdCanal){

	this->getRel()->setDtRelacionamentoInicio(cDtInicio);
	this->getRel()->setDtRelacionamentoFinal(cDtFinal);
	if (cIdCanal != NULL) 
		this->getRel()->setCanalPesquisa(cIdCanal);
	this->getRel()->consultarRelacionamentosPeriodo( (this->getIdPessoa()) , listaRelac );
}
	
// Metodos que acionam a interface de m_oProcesso (CProcesso)

void CPessoa::consultarRangeDateProcessos(  list< CProcesso > & lstOProc,
 												char *  cDataInicio,
 												char * cDataFinal){
 
 	this->m_oProc.setDtProcessoFinal(cDataFinal);
 	this->m_oProc.setDtProcessoInicio(cDataInicio);
 	this->m_oProc.consultarRangeDateProcessos( this->getIdPessoa() , lstOProc );
}

void CPessoa::consultarUltimosProcessos( list< CProcesso > & listaOProc,  char * cQtProc ){

	this->m_oProc.setQtdProcessos( atoi(cQtProc) );
	this->m_oProc.consultarUltimosProcessos( (this->getIdPessoa()) , listaOProc );
}

// Metodos que acionam a interface de m_oSenha (CSenha)
/*
char* CPessoa::consultarLembreteFraseSecreta(void){

    // Delega para CSenha a Execução da Consulta.
    return this->m_oSenha.consultarLembreteFraseSecreta(this->m_iIdPessoaLinha);
};


char* CPessoa::consultarFraseSecreta(void){
    
    // Delega para CSenha a Execução da Consulta.
   return this->m_oSenha.consultarFraseSecreta(this->m_iIdPessoaLinha);
};



void CPessoa::inserirFraseSecreta(char * dsFraseSecreta, char * dsLembreteFraseSecreta){
	 // Delega para CSenha a Execução da Consulta.
  this->m_oSenha.setIdPessoa(this->getIdPessoa());
  this->m_oSenha.inserirFraseSecreta(this->getIdPessoaLinha(), dsFraseSecreta, dsLembreteFraseSecreta);
}
*/

char * CPessoa::getSenhaData( ){
	return this->m_oSenha.getDsLembreteSenha();
}

/*
void CPessoa::alterarFraseSecreta(char* dsFraseSecreta, char* dsLembreteFraseSecreta)
{
    
	// Delega para CSenha a Execução da Alteração.	
	this->m_oSenha.setDsFraseSecreta(dsFraseSecreta);
	this->m_oSenha.setDsLembreteFraseSecreta(dsLembreteFraseSecreta);
    this->m_oSenha.alterarFraseSecreta(this->getIdPessoa(), this->getIdPessoaLinha(), this->getIdTipoRelacionamento());
};          
*/

// Metodos que acionam a interface de m_oEndereco (CEndereco)

void CPessoa::alterarEndereco() {
	if( NULL == this->m_oEndereco )
		return; // deveria lancar uma excecao (na verdade, uma assertiva) ???

	this->m_oEndereco->alterarEndereco( this->m_iIdPessoa );
}

void CPessoa::inserirEndereco() {
	if( NULL == this->m_oEndereco )
		return; // deveria lancar uma excecao (na verdade, uma assertiva) ???

	this->m_oEndereco->inserirEndereco( this->m_iIdPessoa );
}

void CPessoa::consultarEnderecos() {

	this->consultarEnderecosDB();

	/*
	if( NULL == this->m_oEndereco )
		return; 

	this->m_oEndereco->consultarEndereco( this->m_iIdPessoa ); */
}

void CPessoa::consultarEnderecoCobranca() {
	if( NULL == this->m_oEndereco )
		return; 

	this->m_oEndereco->consultarEnderecoCobranca( this->m_iIdPessoa );
}

long CPessoa::getIdPessoaByCpf(void){
	return (this->getIdPessoaByCpfDB());

}

void CPessoa::consultarDispComunicacao()
{
	this->consultarDispComunicacaoDB();
}

void CPessoa::consultarEmails(){
	this->consultarEmailsDB();
}


// METODOS PRIVATE

// Métodos de acesso a banco de dados

long CPessoa::getIdPessoaByCpfDB(void){
	/*select
	  a.idPessoa, 
	  a.nmPessoa, 
	  c.cdCpfCnpjControle
	  from
	  customer.PessoaG00 a,
	  customer.PessoaDocumentoG00 b,
	  customer.DocumentoG00 c
where a.idpessoa (+) = b.IDPESSOA and
b.IDDOCUMENTO = c.IDDOCUMENTO
and  a.NMPESSOA = 'Pessoa Desenvolvimento 11'
and c.CDCPFCNPJCONTROLE = '78'*/

	
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	char cCpf[11+1];
	char cNmPessoa[256];
	long idPessoa;
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    strcpy(cCpf, this->getCpf());
	strcpy(cNmPessoa, this->getNomeCliente());

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL SELECT
		a.idPessoa
	INTO
		:idPessoa
	FROM
	  customer.Pessoa a,
	  customer.PessoaDocumento b,
	  customer.Documento c
	WHERE 
		a.idpessoa = b.IDPESSOA and
		b.IDDOCUMENTO = c.IDDOCUMENTO
		and  a.NMPESSOA = :cNmPessoa
		and c.NRDOCUMENTO = :cCpf
		and rownum = 1;
 
	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		return 0;
	}
 
    this->setIdPessoa(idPessoa);
    
	return 1;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
		return -1;
}
void CPessoa::consultarNmPessoaDB(void) {

    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	long  iIdPessoa;
	char cNmPessoa[256];
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iIdPessoa = this->getIdPessoa();

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL SELECT
		nmPessoa
	INTO
		:cNmPessoa
	FROM
		customer.Pessoa
	WHERE
		idPessoa = :iIdPessoa; 
 
	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw TuxBasicOraException(sqlca.sqlcode);
	}
 
    this->setNmPessoa(CUtil::trim(cNmPessoa));
    
	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}


void CPessoa::consultarNomeUsuarioDB(int area, int nro) {
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	char cNmPessoa[256];
	int iArea;
	int iNro;
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iArea = area;
	iNro = nro;

	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     /*select * from customer.pessoaLINHAB01 
	where   idtiporelacionamento = 2 and sgtiporelacionamento = 'U'
	and nrlinha = 12345678 and cdarearegistro = 11*/
	EXEC SQL 
	SELECT
			NVL(G.nmPessoa, ' ')
	INTO
			:cNmPessoa
	FROM
			LINHA.LINHATELEFONICA A,
			LINHA.LINHABASE B,
			APOIO.AREAREGISTRO B1,
			CUSTOMER.PESSOALINHA C, 
			CUSTOMER.PESSOADEPARA D,
			CUSTOMER.TIPORELACIONAMENTO E,
			CUSTOMER.PESSOA G
	WHERE 	A.IDLINHABASE             = B.IDLINHABASE AND
			B.IDAREAREGISTRO          = B1.IDAREAREGISTRO AND
			C.IDLINHATELEFONICA       = A.IDLINHATELEFONICA AND
			C.IDPESSOADEPARA          = D.IDPESSOADEPARA AND
			C.IDTIPORELACIONAMENTO    = E.IDTIPORELACIONAMENTO AND    
			D.idPessoa                = G.idPessoa AND			
			E.SGTIPORELACIONAMENTO	  ='U'		AND	
			B1.CdAreaRegistro		  = :iArea  AND
			B.NRLINHA				  = :iNro   AND
			C.idTipoRelacionamento    = 1;
	

 
	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw TuxBasicOraException(sqlca.sqlcode);
	}
 
    this->setNomeUsuario(CUtil::trim(cNmPessoa));
    
	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}


void CPessoa::consultarNomeClienteDB(int area, int nro) {

    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	
	char cNmPessoa[256];
	char cNmNome[256];
	char cDtNascimento[256];
	char cSgSexo[256];
	int iArea;
	int iNro;
	
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iArea = area;
	iNro = nro;

	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     /*select * from customer.pessoaLINHAB01 
	where   idtiporelacionamento = 2 and sgtiporelacionamento = 'U'
	and nrlinha = 12345678 and cdarearegistro = 11*/
	EXEC SQL
	 	SELECT
		NVL(G.nmPessoa, ' '), -- NOME COMPLETO
		NVL(G.NMNOME, ' '), -- NOME COMPLETO
		TO_CHAR(F.DTNASCIMENTO,'DD/MM/YYYY'), --DATA NASCIMENTO
		H.SGSEXO

		INTO
			:cNmPessoa, :cNmNome, :cDtNascimento, :cSgSexo
		FROM
			LINHA.LINHATELEFONICA A,
			LINHA.LINHABASE B,
			APOIO.AREAREGISTRO B1,
			CUSTOMER.PESSOALINHA C, 
			CUSTOMER.PESSOADEPARA D,
			CUSTOMER.TIPORELACIONAMENTO E,
			CUSTOMER.PESSOA G,
      CUSTOMER.PESSOAFISICA F,
      APOIO.SEXO H
      
		WHERE 	
			A.IDLINHABASE             = B.IDLINHABASE AND
			B.IDAREAREGISTRO          = B1.IDAREAREGISTRO AND
			C.IDLINHATELEFONICA       = A.IDLINHATELEFONICA AND
			C.IDPESSOADEPARA          = D.IDPESSOADEPARA AND
			C.IDTIPORELACIONAMENTO    = E.IDTIPORELACIONAMENTO AND    
			D.idPessoa                = G.idPessoa AND			
      G.IDPESSOA                = F.IDPESSOA AND
      F.IDSEXO(+)                  = H.IDSEXO AND
			E.SGTIPORELACIONAMENTO	  = 'C'		   AND	
			B1.CdAreaRegistro		  = :iArea	   AND
			B.NRLINHA				  = :iNro      AND
			C.idTipoRelacionamento    =  2;


	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw TuxBasicOraException(sqlca.sqlcode);
	}
 
    this->setNomeCliente(CUtil::trim(cNmPessoa));
	this->setNmNome(CUtil::trim(cNmNome));
	this->setDtNascimento(CUtil::trim(cDtNascimento));
	this->setSgSexo(CUtil::trim(cSgSexo));
    
	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}


void CPessoa::consultarDsContatoDB(void) {

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	long  iIdPessoa;
	char cDsContato[256];
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iIdPessoa = this->getIdPessoa();
/*o rownum foi colocado devido haver mais de um registro na base
depois de garantida a integridade dos dados deve-se retirar
	*/
	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL
	SELECT
		 NVL(dsContato, ' ')
	INTO
		:cDsContato	
	FROM 	
		CUSTOMER.PESSOACOMUNICACAO a,
		APOIO.TIPOCOMUNICACAO	   b
		WHERE a.idPessoa	=:iIdPessoa AND
	  	a.idtipocomunicacao = b.idtipocomunicacao AND
		b.SGTIPOCOMUNICACAO = 'EM PART'
		AND dtExpiracao IS NULL
		AND ROWNUM = 1;

	// ID não existe. Seta o Contato para ""
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw TuxBasicOraException(sqlca.sqlcode);
	}
    
    this->setDsContato(CUtil::trim(cDsContato));

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}


void CPessoa::consultarIdPessoaDB(int codArea, int nroLinha){

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	long  iIdPessoa;
	int iCodArea;
	int iNroLinha;
	long iIdPessoaLinha;
	int iIdPessoaDePara;
	int iIdTipoRelacionamento;
 	EXEC SQL END DECLARE SECTION;

	iCodArea = codArea;
	iNroLinha = nroLinha;
	iIdTipoRelacionamento = this->getIdTipoRelacionamento();

	//REVER TODAS AS CHAMADAS PARA ESTE MÉTODO, DEVERÁ SEMPRE INVOCAR O getIdTipoRelacionamento(), antes não estava sendo setado este atribudo, por isto ainda possui a condição baixo!!.
	if (iIdTipoRelacionamento <= 0){
		iIdTipoRelacionamento = PESSOA_USUARIO;
	}
	//----------------------------------------------------------

    // Seta a Chave da Consulta:
	//iCodArea = codArea;
	//iNroLinha = nroLinha;
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL
		 SELECT
		  g.idPessoa, c.IDPESSOALINHA,d. idPessoaDePara	
		INTO
			:iIdPessoa, :iIdPessoaLinha, :iIdPessoaDePara
		FROM
			LINHA.LINHATELEFONICA A,
			LINHA.LINHABASE B,
			APOIO.AREAREGISTRO B1,
			CUSTOMER.PESSOALINHA C, 
			CUSTOMER.PESSOADEPARA D,
			CUSTOMER.TIPORELACIONAMENTO E,
			CUSTOMER.PESSOA G
		WHERE 	
			A.IDLINHABASE             = B.IDLINHABASE AND
			B.IDAREAREGISTRO          = B1.IDAREAREGISTRO AND
			C.IDLINHATELEFONICA       = A.IDLINHATELEFONICA AND
			C.IDPESSOADEPARA          = D.IDPESSOADEPARA AND
			C.IDTIPORELACIONAMENTO    = E.IDTIPORELACIONAMENTO AND    
			D.idPessoa                = G.idPessoa AND		
			B1.CdAreaRegistro		  =  :iCodArea 	   AND
			B.NRLINHA				  =  :iNroLinha     AND
			C.idTipoRelacionamento    =  :iIdTipoRelacionamento;
	
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		
		EXEC SQL
		SELECT
			  g.idPessoa, c.IDPESSOALINHA,d. idPessoaDePara	
		INTO
			:iIdPessoa, :iIdPessoaLinha, :iIdPessoaDePara
		FROM
			LINHA.LINHATELEFONICA A,
			LINHA.LINHABASE B,
			APOIO.AREAREGISTRO B1,
			CUSTOMER.PESSOALINHA C, 
			CUSTOMER.PESSOADEPARA D,
			CUSTOMER.TIPORELACIONAMENTO E,
			CUSTOMER.PESSOA G
		WHERE 	
			A.IDLINHABASE             = B.IDLINHABASE AND
			B.IDAREAREGISTRO          = B1.IDAREAREGISTRO AND
			C.IDLINHATELEFONICA       = A.IDLINHATELEFONICA AND
			C.IDPESSOADEPARA          = D.IDPESSOADEPARA AND
			C.IDTIPORELACIONAMENTO    = E.IDTIPORELACIONAMENTO AND    
			D.idPessoa                = G.idPessoa  AND		
			B1.CdAreaRegistro		  = :iCodArea   AND
			B.NRLINHA				  = :iNroLinha  AND
			E.sgtiporelacionamento    = 'C';
	
    }

	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	this->setIdPessoa(iIdPessoa);
	this->setIdPessoaLinha(iIdPessoaLinha);
	this->setIdPessoaDePara(iIdPessoaDePara);

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CPessoa::consultarIdPessoaLinhaDB(int cdAreaRegistro, int nrLinha)
{

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	long iIdPessoaLinha;
	int iCdAreaRegistro;
	int iNrLinha;
	int iIdTipoRelacionamento;
 	EXEC SQL END DECLARE SECTION;

	// Seta a Chave da Consulta
	iCdAreaRegistro = cdAreaRegistro;
	iNrLinha = nrLinha;
	iIdTipoRelacionamento = this->getIdTipoRelacionamento();
		
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL 
		
		SELECT
			idPessoaLinha
		INTO
			:iIdPessoaLinha
		FROM
			customer.PessoaLinhaB01 	
		WHERE
			cdAreaRegistro		 = :iCdAreaRegistro 
		AND 
			nrLinha				 = :iNrLinha 
		AND 
			idTipoRelacionamento = :iIdTipoRelacionamento;

	if(sqlca.sqlcode)
		throw TuxBasicOraException(sqlca.sqlcode);

	this->setIdPessoaLinha(iIdPessoaLinha);

	return;

	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);

}

void CPessoa::consultarDadosSessaoDB(int iArea, int iMobNro, char* senha){

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	long iIdPessoa;
 	int  iIdTipoRelacionamento;
	int  iCodArea;
	int  iNroLinha;
	int  iIdTpCart;
	int  iIdConta;
	int  iIdContaAnterior;
	int  iIdTpPessoa;
	long idPessoaCliente;
	int  iInPagadora;
	char cIdLinhaSistemaOrigem [255+1];
	char cIdContaSistemaOrigem [255+1];
	char cSgTipoRelacionamento[2];
	char cCdSenha[256];
	char cLembSenha[256];
	int  iLinhaSemUsuario = 0;
 	EXEC SQL END DECLARE SECTION;

	memset(cIdLinhaSistemaOrigem,' ' , sizeof(cIdLinhaSistemaOrigem));
	memset(cIdContaSistemaOrigem,' ' , sizeof(cIdContaSistemaOrigem));
	memset(cLembSenha,' ' , sizeof(cLembSenha));
	iInPagadora = 0;

	iCodArea = iArea;
	iNroLinha = iMobNro;
	iIdTipoRelacionamento = this->getIdTipoRelacionamento();

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
	if(iIdTipoRelacionamento <= 0)
	{
		if(senha != NULL)
			strcpy(cCdSenha, senha);
		else
			strcpy(cCdSenha, "");

		

		EXEC SQL
		SELECT 
			COUNT(1)
		INTO 
			:iLinhaSemUsuario
		FROM 
			LINHA.LINHATELEFONICA LINHATELEFONICA,
			LINHA.LINHABASE LINHABASE,
			APOIO.AREAREGISTRO AREAREGISTRO
		WHERE
			LINHABASE.NRLINHA = :iNroLinha AND
			LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO AND
			AREAREGISTRO.CDAREAREGISTRO = :iCodArea AND
			LINHABASE.IDLINHABASE = LINHATELEFONICA.IDLINHABASE AND
			LINHATELEFONICA.CDSENHAPREATIVA = :cCdSenha;

			iIdTipoRelacionamento = PESSOA_USUARIO;

		if(!iLinhaSemUsuario) /*linha  possui usuario cadastrado*/
		{
	
		// primeiro vamos tentar validar o cliente
		iIdTipoRelacionamento = PESSOA_CLIENTE;

		EXEC SQL 
			
			SELECT
				NVL(F.DSLEMBRETESENHA, ' ')
			INTO
				:cLembSenha
			FROM
				LINHA.LINHATELEFONICA A,
				LINHA.LINHABASE B,
				APOIO.AREAREGISTRO B1,
				CUSTOMER.PESSOALINHA C, 
				CUSTOMER.PESSOADEPARA D,
				CUSTOMER.TIPORELACIONAMENTO E,
				CUSTOMER.SENHA F,
				CUSTOMER.PESSOA G
			WHERE
				A.IDLINHABASE			= B.IDLINHABASE AND
				B.IDAREAREGISTRO		= B1.IDAREAREGISTRO AND
				C.IDLINHATELEFONICA		= A.IDLINHATELEFONICA AND
				C.IDPESSOADEPARA		= D.IDPESSOADEPARA AND
				C.IDTIPORELACIONAMENTO	= E.IDTIPORELACIONAMENTO AND    
				D.idPessoa				= F.idPessoa and
				D.idPessoa				= G.idPessoa AND
				B1.CdAreaRegistro		= :iCodArea AND
				B.NRLINHA				= :iNroLinha AND
				F.CdSenha				= :cCdSenha AND
				C.idTipoRelacionamento  = :iIdTipoRelacionamento AND
				D.idPessoa				= D.idPessoaOrigem AND
				rownum					= 1;

		if(sqlca.sqlcode == NO_DATA_FOUND)
		{ 
			// vamos tentar com o usuario
			iIdTipoRelacionamento = PESSOA_USUARIO;

			EXEC SQL 
				
				SELECT
					NVL(F.DSLEMBRETESENHA, ' ')
				INTO
					:cLembSenha
				FROM
					LINHA.LINHATELEFONICA A,
					LINHA.LINHABASE B,
					APOIO.AREAREGISTRO B1,
					CUSTOMER.PESSOALINHA C, 
					CUSTOMER.PESSOADEPARA D,
					CUSTOMER.TIPORELACIONAMENTO E,
					CUSTOMER.SENHA F,
					CUSTOMER.PESSOA G
				WHERE
					A.IDLINHABASE             = B.IDLINHABASE AND
					B.IDAREAREGISTRO          = B1.IDAREAREGISTRO AND
					C.IDLINHATELEFONICA       = A.IDLINHATELEFONICA AND
					C.IDPESSOADEPARA          = D.IDPESSOADEPARA AND
					C.IDTIPORELACIONAMENTO    = E.IDTIPORELACIONAMENTO AND    
					C.idPessoaLinha           = F.idPessoaLinha and
					D.idPessoa                = G.idPessoa AND				
					B1.CdAreaRegistro		  = :iCodArea AND
					B.NRLINHA				  = :iNroLinha AND
					F.CdSenha				  = :cCdSenha AND
					C.idTipoRelacionamento    = :iIdTipoRelacionamento AND
					D.idPessoa				  = D.idPessoaOrigem AND
					rownum					  = 1;
				
			if(sqlca.sqlcode)
			{
				throw TuxBasicOraException(sqlca.sqlcode);
			}

		}
		else if(sqlca.sqlcode)
		{
			throw TuxBasicOraException(sqlca.sqlcode);
		}
		}
	}

	EXEC SQL SELECT
	    D.IDPESSOA, E.SGTIPORELACIONAMENTO, G.idTipoCarteira, G.idTipoPessoa
	INTO
		:iIdPessoa, :cSgTipoRelacionamento, :iIdTpCart, :iIdTpPessoa
	FROM
		LINHA.LINHATELEFONICA A,
		LINHA.LINHABASE B,
		APOIO.AREAREGISTRO B1,
		CUSTOMER.PESSOALINHA C, 
		CUSTOMER.PESSOADEPARA D,
		CUSTOMER.TIPORELACIONAMENTO E,
		CUSTOMER.PESSOA G
    WHERE
		A.IDLINHABASE			= B.IDLINHABASE AND
		B.IDAREAREGISTRO		= B1.IDAREAREGISTRO AND
		C.IDLINHATELEFONICA		= A.IDLINHATELEFONICA AND
		C.IDPESSOADEPARA		= D.IDPESSOADEPARA AND
		C.IDTIPORELACIONAMENTO	= E.IDTIPORELACIONAMENTO AND
		D.idPessoa				= G.idPessoa AND
		B1.CdAreaRegistro		= :iCodArea AND
		B.NRLINHA				= :iNroLinha AND
		C.idTipoRelacionamento  = :iIdTipoRelacionamento AND
		D.idPessoa				= D.idPessoaOrigem;

	if(sqlca.sqlcode)
	{ 
		throw TuxBasicOraException(sqlca.sqlcode);
	}


	//O idContaSistemaOrigem poderá vir a não ter, nesse caso as demais colunas devem retornar valor!.
	EXEC SQL 
		Select 
			   NVL(idContaSistemaOrigem, ' '),NVL(c.idlinhasistemaorigem,' '), NVL(d.idConta,0), NVL(e.INPAGADORA,0) AS INPAGADORA
		Into
			   :cIdContaSistemaOrigem, :cIdLinhaSistemaOrigem, :iIdConta,:iInPagadora
		From
			   apoio.AreaRegistro	a,
			   linha.LinhaBase		b,
			   linha.LinhaTelefonica c,
			   customer.LinhaConta	d,
			   customer.Conta		e
		Where	  
			   a.idAreaRegistro 		= b.idAreaRegistro
		And	   b.idLinhaBase			= c.idLinhaBase
		And	   c.idLinhaTelefonica		= d.idLinhaTelefonica
		And	   d.idConta				= e.idConta
		And	   a.cdAreaRegistro			= :iCodArea
		And	   b.nrLinha				= :iNroLinha
		And	   d.idTipoRelacionamento	= 2
		And	   rownum 					= 1;



	if (sqlca.sqlcode == NO_DATA_FOUND)
	{ 
		strcpy(cIdLinhaSistemaOrigem, " ");
		iIdConta = 0;
	}
	else
	{
		while(iInPagadora == 0)
		{
			memset(&cIdLinhaSistemaOrigem,0,sizeof(cIdLinhaSistemaOrigem));
			iInPagadora = 0;
			iIdContaAnterior = iIdConta;
			iIdConta = 0;
			EXEC SQL
			SELECT 
				NVL(CONTA.IDCONTA,0),
				NVL(CONTA.IDCONTASISTEMAORIGEM,' '),
				NVL(CONTA.INPAGADORA,0) AS INPAGADORA
			INTO	:iIdConta,:cIdContaSistemaOrigem,:iInPagadora
			FROM
				CUSTOMER.CONTA CONTA,
				CUSTOMER.CONTAHIERARQUIA CONTAHIERARQUIA
			WHERE
				CONTA.IDCONTA = CONTAHIERARQUIA.IDCONTAPAI
				AND CONTAHIERARQUIA.IDCONTA = :iIdContaAnterior;
			
			if(sqlca.sqlcode == NO_DATA_FOUND)
			{
				strcpy(cIdContaSistemaOrigem, " ");
				iIdConta = 0;
				break;
			}
		}
	}

	EXEC SQL 
	SELECT 
		p.idpessoa
	into
		:idPessoaCliente
	FROM
		linha.linhabase lb,
		linha.linhatelefonica lt,
		customer.pessoalinha pl,
		customer.pessoadepara pdp,
		customer.pessoa p,
		apoio.arearegistro a
	WHERE a.cdarearegistro =:iCodArea
		AND lb.nrlinha =	:iNroLinha
		AND pl.idtiporelacionamento = 2
		AND lb.idarearegistro = a.idarearegistro
		AND lb.idlinhabase = lt.idlinhabase
		AND pl.idlinhatelefonica = lt.idlinhatelefonica
		AND pdp.idpessoadepara = pl.idpessoadepara
		AND p.idpessoa = pdp.idpessoa;
	

	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		idPessoaCliente = 0;
	}

    this->setIdPessoa(iIdPessoa);
	this->setIdTipoRelacionamento(iIdTipoRelacionamento);
	this->setSgTipoRelacionamento(cSgTipoRelacionamento);
	this->m_oSenha.setDsLembreteSenha(CUtil::trim(cLembSenha));
	this->setIdLinhaSistemaOrigem(CUtil::trim(cIdLinhaSistemaOrigem));
	this->setIdContaSistemaOrigem(CUtil::trim(cIdContaSistemaOrigem));


	this->setIdTipoCarteira(iIdTpCart);
	this->setIdTipoPessoa(iIdTpPessoa);
	this->setIdConta(iIdConta);
	this->setIdPessoaCliente(idPessoaCliente);
	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}



void CPessoa::consultarDadosSessaoSemSenhaDB( int iArea, int iMobNro )
{
    tuxfw_getlogger()->debug( ">>> CPessoa::consultarDadosSessaoSemSenhaDB()" );

	struct sqlca sqlca;

	char buf[2048];
	
	EXEC SQL BEGIN DECLARE SECTION;
		long iIdPessoa;
		short i_iIdPessoa = -1;
		
		int iIdTipoRelacionamento;
		int iCodArea;
		int iNroLinha;
		
		int iIdTpCart;
		short i_iIdTpCart = -1;
		
		int iIdConta;
		short i_iIdConta = -1;
		
		int iIdContaAnterior;
		short i_iIdContaAnterior = -1;
		
		int iIdTpPessoa;
		short i_iIdTpPessoa = -1;
		
		long idPessoaCliente;
		short i_idPessoaCliente = -1;
		
		int iInPagadora;
		short i_iInPagadora = -1;
		
		char cIdLinhaSistemaOrigem [255+1];
		short i_cIdLinhaSistemaOrigem = -1;
		
		char cIdContaSistemaOrigem [255+1];
		short i_cIdContaSistemaOrigem = -1;
		
		char dtHabilitacao[256];
		short i_dtHabilitacao = -1;
		
		char dtAlteracaoStatus[256];
		short i_dtAlteracaoStatus = -1;
		
		char cSgTipoRelacionamento[2];
		short i_cSgTipoRelacionamento = -1;
		
		char cCdSenha[256];
		char cLembSenha[256];
		int  iLinhaSemUsuario = 0;
 	EXEC SQL END DECLARE SECTION;

	memset( dtHabilitacao    , 0x0, sizeof(dtHabilitacao) );
	memset( dtAlteracaoStatus, 0x0, sizeof(dtAlteracaoStatus) );
	
	memset(cIdLinhaSistemaOrigem,' ' , sizeof(cIdLinhaSistemaOrigem));
	memset(cIdContaSistemaOrigem,' ' , sizeof(cIdContaSistemaOrigem));
	memset(cLembSenha,' ' , sizeof(cLembSenha));
	iInPagadora = 0;

	iCodArea = iArea;
	iNroLinha = iMobNro;
	iIdTipoRelacionamento = this->getIdTipoRelacionamento();
	sprintf(buf,"iCodArea (%d) - iNroLinha (%d) - iIdTipoRelacionamento (%d)\n",iCodArea,iNroLinha,iIdTipoRelacionamento );
	tuxfw_getlogger()->debug( buf );

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
	if(iIdTipoRelacionamento <= 0)
	{

		tuxfw_getlogger()->debug( ">>> Passou 1" );
		
		EXEC SQL
		SELECT 
			COUNT(1)
		INTO 
			:iLinhaSemUsuario
		FROM 
			LINHA.LINHATELEFONICA LINHATELEFONICA,
			LINHA.LINHABASE LINHABASE,
			APOIO.AREAREGISTRO AREAREGISTRO
		WHERE
			LINHABASE.NRLINHA = :iNroLinha AND
			LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO AND
			AREAREGISTRO.CDAREAREGISTRO = :iCodArea AND
			LINHABASE.IDLINHABASE = LINHATELEFONICA.IDLINHABASE ;
			/* LINHATELEFONICA.CDSENHAPREATIVA = :cCdSenha; */

			iIdTipoRelacionamento = PESSOA_USUARIO;
	
      tuxfw_getlogger()->debug( "*** iLinhaSemUsuario [%d]\n", iLinhaSemUsuario );

    sprintf(buf,"*** Valor de iLinhaSemUsuario [%d]\n", iLinhaSemUsuario );
    tuxfw_getlogger()->debug( buf );

		if(!iLinhaSemUsuario) /*linha  possui usuario cadastrado*/
		{
	
		// primeiro vamos tentar validar o cliente
		iIdTipoRelacionamento = PESSOA_CLIENTE;

		}
	}

    sprintf(buf,"*** Pesquisa 1 - Chave iCodArea [%d] - iNroLinha [%d] - iIdTipoRelacionamento [%d]\n", iCodArea, iNroLinha, iIdTipoRelacionamento );
    tuxfw_getlogger()->debug( buf );

	EXEC SQL 
	SELECT
	    D.IDPESSOA, 
	    TO_CHAR( A.DTHABILITACAO, 'DD/MM/YYYY HH24:MI:SS' ), 
	    TO_CHAR( A.DTULTIMAALTERACAO, 'DD/MM/YYYY HH24:MI:SS' ), 
	    E.SGTIPORELACIONAMENTO, 
	    G.idTipoCarteira, 
	    G.idTipoPessoa
	INTO
		:iIdPessoa:i_iIdPessoa, 
		:dtHabilitacao:i_dtHabilitacao, 
		:dtAlteracaoStatus:i_dtAlteracaoStatus, 
		:cSgTipoRelacionamento:i_cSgTipoRelacionamento, 
		:iIdTpCart:i_iIdTpCart, 
		:iIdTpPessoa:i_iIdTpPessoa
	FROM
		LINHA.LINHATELEFONICA A,
		LINHA.LINHABASE B,
		APOIO.AREAREGISTRO B1,
		CUSTOMER.PESSOALINHA C, 
		CUSTOMER.PESSOADEPARA D,
		CUSTOMER.TIPORELACIONAMENTO E,
		CUSTOMER.PESSOA G
    WHERE
		A.IDLINHABASE			= B.IDLINHABASE AND
		B.IDAREAREGISTRO		= B1.IDAREAREGISTRO AND
		C.IDLINHATELEFONICA		= A.IDLINHATELEFONICA AND
		C.IDPESSOADEPARA		= D.IDPESSOADEPARA AND
		C.IDTIPORELACIONAMENTO	= E.IDTIPORELACIONAMENTO AND
		D.idPessoa				= G.idPessoa AND
		B1.CdAreaRegistro		= :iCodArea AND
		B.NRLINHA				= :iNroLinha AND
		C.idTipoRelacionamento  = :iIdTipoRelacionamento AND
        rownum < 2;
		//D.idPessoa				= D.idPessoaOrigem;

	tuxfw_getlogger()->debug( ">>> Passou 2" );

	if(sqlca.sqlcode)
	{ 
		tuxfw_getlogger()->debug( ">>> Passou 3" );
		throw TuxBasicOraException(sqlca.sqlcode);
	}


	tuxfw_getlogger()->debug( ">>> Passou 4" );
	//O idContaSistemaOrigem poderá vir a não ter, nesse caso as demais colunas devem retornar valor!.
	EXEC SQL 
	Select 
		   NVL(idContaSistemaOrigem, ' '),
		   NVL(c.idlinhasistemaorigem,' '), 
		   NVL(d.idConta,0), 
		   NVL(e.INPAGADORA,0) AS INPAGADORA
	Into
		   :cIdContaSistemaOrigem:i_cIdContaSistemaOrigem, 
		   :cIdLinhaSistemaOrigem:i_cIdLinhaSistemaOrigem, 
		   :iIdConta:i_iIdConta,
		   :iInPagadora:i_iInPagadora
	From
		   apoio.AreaRegistro	a,
		   linha.LinhaBase		b,
		   linha.LinhaTelefonica c,
		   customer.LinhaConta	d,
		   customer.Conta		e
	Where	  
		   a.idAreaRegistro 		= b.idAreaRegistro
	And	   b.idLinhaBase			= c.idLinhaBase
	And	   c.idLinhaTelefonica		= d.idLinhaTelefonica
	And	   d.idConta				= e.idConta
	And	   a.cdAreaRegistro			= :iCodArea
	And	   b.nrLinha				= :iNroLinha
	And	   d.idTipoRelacionamento	= 2
	And	   rownum 					= 1;

	tuxfw_getlogger()->debug( ">>> Passou 5" );
	if ( sqlca.sqlcode == NO_DATA_FOUND )
	{ 
		tuxfw_getlogger()->debug( ">>> Passou 6" );
		strcpy(cIdLinhaSistemaOrigem, " ");
		iIdConta = 0;
	}
	else
	{
		tuxfw_getlogger()->debug( ">>> Passou 7" );
		while( iInPagadora == 0 )
		{
			memset( &cIdLinhaSistemaOrigem, 0, sizeof(cIdLinhaSistemaOrigem) );
			iInPagadora = 0;
			iIdContaAnterior = iIdConta;
			iIdConta = 0;
			EXEC SQL
			SELECT 
				NVL(CONTA.IDCONTA,0),
				NVL(CONTA.IDCONTASISTEMAORIGEM,' '),
				NVL(CONTA.INPAGADORA,0) AS INPAGADORA
			INTO	
			   :iIdConta:i_iIdConta ,
			   :cIdContaSistemaOrigem:i_cIdContaSistemaOrigem ,
			   :iInPagadora:i_iInPagadora
			FROM
				CUSTOMER.CONTA CONTA,
				CUSTOMER.CONTAHIERARQUIA CONTAHIERARQUIA
			WHERE
				CONTA.IDCONTA = CONTAHIERARQUIA.IDCONTAPAI
				AND CONTAHIERARQUIA.IDCONTA = :iIdContaAnterior;
			
			if(sqlca.sqlcode == NO_DATA_FOUND)
			{
				strcpy(cIdContaSistemaOrigem, " ");
				iIdConta = 0;
				break;
			}
		}
	}

	tuxfw_getlogger()->debug( ">>> Passou 8" );
	EXEC SQL 
	SELECT 
		p.idpessoa
	into
		:idPessoaCliente:i_idPessoaCliente
	FROM
		linha.linhabase lb,
		linha.linhatelefonica lt,
		customer.pessoalinha pl,
		customer.pessoadepara pdp,
		customer.pessoa p,
		apoio.arearegistro a
	WHERE a.cdarearegistro =:iCodArea
		AND lb.nrlinha =	:iNroLinha
		AND pl.idtiporelacionamento = 2
		AND lb.idarearegistro = a.idarearegistro
		AND lb.idlinhabase = lt.idlinhabase
		AND pl.idlinhatelefonica = lt.idlinhatelefonica
		AND pdp.idpessoadepara = pl.idpessoadepara
		AND p.idpessoa = pdp.idpessoa;
	

	if (sqlca.sqlcode == NO_DATA_FOUND)
	{ 
		idPessoaCliente = 0;
	}

  this->setIdPessoa(iIdPessoa);
  
  this->set_dtHabilitacao(CUtil::trim(dtHabilitacao));
  this->set_dtAlteracaoStatus(CUtil::trim(dtAlteracaoStatus));
  
	this->setIdTipoRelacionamento(iIdTipoRelacionamento);
	this->setSgTipoRelacionamento(cSgTipoRelacionamento);
	this->m_oSenha.setDsLembreteSenha(CUtil::trim(cLembSenha));
	this->setIdLinhaSistemaOrigem(CUtil::trim(cIdLinhaSistemaOrigem));
	this->setIdContaSistemaOrigem(CUtil::trim(cIdContaSistemaOrigem));


	this->setIdTipoCarteira(iIdTpCart);
	this->setIdTipoPessoa(iIdTpPessoa);
	this->setIdConta(iIdConta);
	this->setIdPessoaCliente(idPessoaCliente);
	return;
 
	sqlErrorConstrutor:
	    tuxfw_getlogger()->debug( "@@@ SAINDO COM ERRO ORACLE [%d]", sqlca.sqlcode );
		throw TuxBasicOraException(sqlca.sqlcode);
}



void CPessoa::alterarDsContatoDB(void) {

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	long  iIdPessoa;
	char cDsContato[ 256 ];
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iIdPessoa = this->getIdPessoa();
	strcpy(cDsContato , this->getDsContato());

	// verifica se ja tem e-mail cadastrado se nao tiver inseri
	try {
		this->consultarDsContatoDB();
	}
	catch ( ... ) {
		try {
			this->inserirEMail();
		}
		catch ( ... ) {
			throw TuxBasicOraException(1403);
		}
		return;
	}

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL UPDATE
		customer.PessoaComunicacao
	SET
		dsContato = :cDsContato
		, dtUltimaAlteracao = SYSDATE
	WHERE
		idPessoa = :iIdPessoa
		AND idTipoComunicacao = 6
		AND dtExpiracao is NULL;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CPessoa::inserirDsContatoDB(void) {

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	long  iIdPessoa;
	char cDsContato[ 256 ];
	char cDataAtual[ 19+1 ];
	char cDataExp[ 19+1 ];
	int  iIdUsuarioAlteracao;
	int iIdAux;
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iIdPessoa = this->getIdPessoa();
	strcpy(cDsContato , this->getDsContato());
	iIdUsuarioAlteracao = this->getIdUsuarioAlteracao();

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL SELECT customer.PessoaComunicacaoSQ.NEXTVAL INTO :iIdAux FROM DUAL;

	EXEC SQL SELECT 
				to_char(SYSDATE, 'dd/mm/YYYY hh24:mi:ss'), 
				to_char(add_months(SYSDATE, 24), 'dd/mm/YYYY hh24:mi:ss') 
				INTO: 
					cDataAtual, cDataExp 
				FROM DUAL;
     
	EXEC SQL INSERT INTO
		customer.PessoaComunicacao 
		(
		IDPESSOACOMUNICACAO, 
		IDPESSOA, 
		IDTIPOCOMUNICACAO, 
		NRSEQUENCIA, 
		DSCONTATO, 
		TSSINCRONISMO, 
		SQSINCRONISMO, 
		DTCADASTRO, 
		IDCOMUNICACAOSISTEMAORIGEM, 
		IDSISTEMAORIGEM, 
		INCOMUNICACAOPREFERENCIAL, 
		IDUSUARIOALTERACAO, 
		DTULTIMAALTERACAO )
		VALUES ( 
			:iIdAux,
			:iIdPessoa,
			'6',
			'0',
			:cDsContato,
			'0',
			'0',
			to_date( :cDataAtual , 'dd/mm/YYYY hh24:mi:ss'),
			'0',
			'9',
			'1',
			:iIdUsuarioAlteracao,
			to_date( :cDataAtual , 'dd/mm/YYYY hh24:mi:ss') );
	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);

}

void CPessoa::consultarDispComunicacaoDB()
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	long  iIdPessoa;
	int  iEnvioSMS;
	int  iEnvioEmail;
	EXEC SQL END DECLARE SECTION;

	iIdPessoa = this->getIdPessoa();
	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL WHENEVER NOT FOUND GOTO sqlErrorConstrutor;

	if(this->getTipoComunicacao() == ID_TP_COM_SMS)
	{

		EXEC SQL 
			
			SELECT 
				NVL(inEnvioSMS, 0)
			INTO
				:iEnvioSMS
			FROM
				customer.pessoaComunicacao   a,
				apoio.TipoComunicacao        b,
				contatoADM.FormaRetorno      c  
			WHERE
			    a.idTipoComunicacao = b.idTipoComunicacao 
			AND
				b.idFormaRetorno = c.idFormaRetorno  
			AND
				b.sgTipoComunicacao   = 'CELULAR'   
			AND
				a.idPessoa = :iIdPessoa
			AND
				ROWNUM = 1;

		if(!iEnvioSMS)
			throw TuxBasicSvcException("11E0001","ENVIO POR SMS NAO CADASTRADO");
			
	}
	else
	{
		EXEC SQL 
			
			SELECT 
				NVL(inEnvioEMAIL, 0)
			INTO
				:iEnvioEmail
			FROm
				customer.pessoaComunicacao   a,
				apoio.TipoComunicacao        b, 
				contatoADM.FormaRetorno      c  
			WHERE
				a.idTipoComunicacao = b.idTipoComunicacao
			AND
				b.idFormaRetorno = c.idFormaRetorno  
			AND
				b.sgTipoComunicacao   = 'EM PART'
			AND
				a.idPessoa = :iIdPessoa
			AND
				ROWNUM = 1;

			if(!iEnvioEmail)
				throw TuxBasicSvcException("11E0001","ENVIO POR EMAIL NAO CADASTRADO");
	}

	return;
 
	sqlErrorConstrutor:	
		throw TuxBasicOraException(sqlca.sqlcode);

}


bool CPessoa::consultarEnderecoPremio()
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	long  iIdPessoa;
	int  iEnderecoPremio;
	EXEC SQL END DECLARE SECTION;

	iIdPessoa = this->getIdPessoa();

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL
	SELECT
		COUNT(1)
	INTO
		:iEnderecoPremio
	FROM 
		customer.consultarEndContaLinhaV01
	WHERE
		idPessoa	= :iIdPessoa AND
		IDTIPOENDERECO	= 4;


	if (iEnderecoPremio)
		return true;
	else
		return false;
		
sqlErrorConstrutor:	
		throw TuxBasicOraException(sqlca.sqlcode);

}

void CPessoa::consultarEnderecosDB()
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	long  iIdPessoa;
	long  iIdPessoaEndereco;
	int  iIdTipoEndereco;
	char cDsTipoEndereco[256];
	int  iIdTipoEnderecoCobranca;
	char cNmTipoLogradouro[256];
	char cNmTituloLogradouro[256];
	char cNmLogradouro[256];
	char cNrEndereco[256];
	char cDsEnderecoComplemento[256];
	char cNmBairro[256];
	char cNrCep[256];
	char cNmMunicipio[256];
	int  iIdUf;
	int  iIdSistemaOrigemEndereco;
	int  iIdConta;
	int  iIdTipoConta;
	char cCdConta[101];
	int  iIdSistemaOrigemConta;
	int  iIdSistemaOrigemLinha;
	int  iNrLinha;
	int  iCdAreaRegistro;	
	EXEC SQL END DECLARE SECTION;

	char        cLinha[12];
	
	char buffer[256];
	
	char        cLinhaAnterior[12];
	
	CConta      oConta;
	CEndereco   oEndereco;

	bool bSQL_OK = false;
	long  iIdPessoaEndAnterior    = -1;
	int  iIdContaAnterior        = -1;

	memset(cLinhaAnterior, 0, sizeof(cLinhaAnterior));	
	
	iIdPessoa = this->getIdPessoa();
	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	sprintf( buffer, "iIdPessoa [%ld]", iIdPessoa );
	tuxfw_getlogger()->debug( buffer );

	EXEC SQL DECLARE CONSULTARENDCONTALINHAV01 CURSOR FOR
	
	SELECT 
		*
	FROM 
	(
		SELECT
			idPessoaEndereco,
			idTipoEndereco,
			dsTipoEndereco,
			idTipoEnderecoCobranca,
			nmTipoLogradouro,
			nmTituloLogradouro,
			nmLogradouro,
			nrEndereco,
			dsEnderecoComplemento,
			nmBairro,
			nrCep,
			nmMunicipio,
			idUF,
			idSistemaOrigemEndereco,
			idConta,
			idTipoConta,
			cdConta,
			idSistemaOrigemConta,
			idSistemaOrigemLinha,
			nrLinha,
			cdAreaRegistro
		FROM 
			customer.consultarEndContaLinhaV01
		WHERE
			idPessoa = :iIdPessoa		
		UNION
		SELECT
			idPessoaEndereco,
			idTipoEndereco,
			dsTipoEndereco,
			idTipoEnderecoCobranca,
			nmTipoLogradouro,
			nmTituloLogradouro,
			nmLogradouro,
			nrEndereco,
			dsEnderecoComplemento,
			nmBairro,
			nrCep,
			nmMunicipio,
			idUF,
			idSistemaOrigemEndereco,
			idConta,
			idTipoConta,
			cdConta,
			idSistemaOrigemConta,
			idSistemaOrigemLinha,
			nrLinha,
			cdAreaRegistro
		FROM 
			customer.consultarEndContaLinhaV02
		WHERE
			idPessoa = :iIdPessoa		
	)
	ORDER BY
		idTipoEndereco, idTipoEnderecoCobranca, idPessoaEndereco;


	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	EXEC SQL OPEN CONSULTARENDCONTALINHAV01;

	for(;;) 
	{
                tuxfw_getlogger()->debug( "Encontrou registros...\n" );
                
		bSQL_OK = true;

		// varre todos os registros para criar a lista com os servicos
		EXEC SQL FETCH CONSULTARENDCONTALINHAV01 INTO
			:iIdPessoaEndereco,
			:iIdTipoEndereco,
			:cDsTipoEndereco,
			:iIdTipoEnderecoCobranca,
			:cNmTipoLogradouro,
			:cNmTituloLogradouro,
			:cNmLogradouro,
			:cNrEndereco, 
			:cDsEnderecoComplemento, 
			:cNmBairro, 
			:cNrCep, 
			:cNmMunicipio,
			:iIdUf,
			:iIdSistemaOrigemEndereco,
			:iIdConta,
			:iIdTipoConta,
			:cCdConta,
			:iIdSistemaOrigemConta,
			:iIdSistemaOrigemLinha,
			:iNrLinha,
			:iCdAreaRegistro;	

		sprintf(cLinha, "%0.2d%d", iCdAreaRegistro, iNrLinha);
		
		sprintf( buffer,"Pesquisando a linha [%s]\n", cLinha );

                tuxfw_getlogger()->debug( buffer );

		CStr linha(cLinha);
 
		if(iIdContaAnterior != iIdConta)
		{
			if(iIdContaAnterior >= 0)
			{
				if(oConta.getIdConta() > 0)
					oEndereco.getListaContas().push_back(oConta);

				//apagando as listas existentes
				oConta.getListaLinhas().clear();
			}

			iIdContaAnterior = iIdConta;

			oConta.setIdConta(iIdConta);
			oConta.setIdTipoConta(iIdTipoConta);
			oConta.setIdSistemaOrigem(iIdSistemaOrigemConta);
			oConta.setIdTipoEnderecoCobranca(iIdTipoEnderecoCobranca);
			oConta.setCdConta(CUtil::trim(cCdConta));
						
		}

		if(!strcmp(cLinha, cLinhaAnterior) && 
			iIdPessoaEndAnterior == iIdPessoaEndereco &&
			strlen(cLinha) == 10 &&
			strlen(cLinhaAnterior) == 10)
			tuxfw_getlogger()->debug("CPessoa: linha %s com tipo cobrança repetido!", cLinha);
		else
			oConta.getListaLinhas().push_back(linha);
				
		if(!strcmp(cLinha, cLinhaAnterior) && 
			iIdPessoaEndAnterior == iIdPessoaEndereco &&
			strlen(cLinha) == 11 &&
			strlen(cLinhaAnterior) == 11)
			tuxfw_getlogger()->debug("CPessoa: linha %s com tipo cobrança repetido!", cLinha);
		else
			oConta.getListaLinhas().push_back(linha);

		strcpy(cLinhaAnterior, cLinha);

		if(iIdPessoaEndAnterior != iIdPessoaEndereco)
		{
			if(iIdPessoaEndAnterior >= 0)
			{
				this->getListaEnderecos().push_back(oEndereco);
			
				//apagando as listas existentes
				oEndereco.getListaContas().clear();
			}

			iIdPessoaEndAnterior = iIdPessoaEndereco;

			oEndereco.setIdPessoaEndereco(iIdPessoaEndAnterior);
			oEndereco.setIdSistemaOrigem(iIdSistemaOrigemEndereco);
			oEndereco.setIdTipoEndereco(iIdTipoEndereco);
			this->getEndereco()->incQuantTipo(iIdTipoEndereco);
			oEndereco.setDsTipoEndereco(CUtil::trim(cDsTipoEndereco));
			oEndereco.setIdTipoEnderecoCobranca(iIdTipoEnderecoCobranca);
			oEndereco.setNmTipoLogradouro(CUtil::trim(cNmTipoLogradouro));
			oEndereco.setNmTituloLogradouro(CUtil::trim(cNmTituloLogradouro));
			oEndereco.setNmLogradouro(CUtil::trim(cNmLogradouro));
			oEndereco.setNrEndereco(CUtil::trim(cNrEndereco));
			oEndereco.setDsEnderecoComplemento(CUtil::trim(cDsEnderecoComplemento));
			oEndereco.setNmBairro(CUtil::trim(cNmBairro));
			oEndereco.setNrCep(CUtil::trim(cNrCep));
			oEndereco.setNmMunicipio(CUtil::trim(cNmMunicipio));
			oEndereco.setIdUf(iIdUf);
			
		}

	}

	if(bSQL_OK)
	{
		if(oConta.getIdConta() > 0)
			oEndereco.getListaContas().push_back(oConta);

		this->getListaEnderecos().push_back(oEndereco);
	}

	EXEC SQL CLOSE CONSULTARENDCONTALINHAV01;

	return;
 
	sprintf( buffer,"Retorno Oracle [%d]\n", sqlca.sqlcode );

        tuxfw_getlogger()->debug( buffer );
        
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}


void CPessoa::consultarEmailsDB()
{
	char buf[256];
	struct sqlca sqlca;
	string stmt;
	char buffer[256];
	EXEC SQL BEGIN DECLARE SECTION;
	char * query;
	long  iIdPessoaDB;
	int  iIdEmailDB;
	int  iIdTipoEmailDB;
	char cDsTipoEmailDB[256];
	char cDsEmailDB[256];
	char cSgClassificacaoEmail[256]="";
	EXEC SQL END DECLARE SECTION;

	strcpy(cSgClassificacaoEmail, SGCLASSIFICACAO_EMAIL);
	memset(&buffer,0,sizeof(buffer));
	memset(&buf,0,sizeof(buf));
	CEmail   oEmail;

	// garante que a lista esta vazia
	this->getListaEnderecos().clear();

	iIdPessoaDB = this->getIdPessoa();
	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	stmt = "SELECT IDPESSOACOMUNICACAO,"
			"   IDTIPOCOMUNICACAO,"
			"   DSTIPOCOMUNICACAO,"
			"   DSCONTATO"
		 " FROM (SELECT A.IDPESSOACOMUNICACAO,"
					  " A.IDTIPOCOMUNICACAO,"
					  " B.DSTIPOCOMUNICACAO,"
					  " NVL (A.DSCONTATO, ' ') AS DSCONTATO,"
					  " RANK () OVER (PARTITION BY A.DSCONTATO ORDER BY IDPESSOACOMUNICACAO) CONTATO"
				 " FROM CUSTOMER.PESSOACOMUNICACAO A, APOIO.TIPOCOMUNICACAO B"
				" WHERE     A.IDTIPOCOMUNICACAO = B.IDTIPOCOMUNICACAO";
		 sprintf(buffer	," AND B.SGCLASSIFICACAO = '%s' AND A.IDPESSOA = %d ) WHERE CONTATO = 1 ",cSgClassificacaoEmail,iIdPessoaDB);
		stmt += buffer;
		
	memset(&buf,0,sizeof(buf));
	sprintf(buf,"QUERY COM RANK %s",(char *)stmt.c_str());
	tuxfw_getlogger()->debug( buf );	
		
	query = (char *)stmt.c_str();
	EXEC SQL PREPARE CONSULTAREMAILS FROM :query;
    EXEC SQL DECLARE cCONSULTAREMAILS CURSOR FOR CONSULTAREMAILS;
	EXEC SQL OPEN cCONSULTAREMAILS;
	for(;;) 
	{

		// varre todos os registros para criar a lista com os servicos
		EXEC SQL FETCH cCONSULTAREMAILS INTO
			:iIdEmailDB,
			:iIdTipoEmailDB,
			:cDsTipoEmailDB,
			:cDsEmailDB;
			
		oEmail.setIdEmail(iIdEmailDB);
		oEmail.setIdTipoEmail(iIdTipoEmailDB);
		oEmail.setDsTipoEmail(CUtil::trim(cDsTipoEmailDB));
		oEmail.setDsEmail(CUtil::trim(cDsEmailDB));

		this->getListaEmails().push_back(oEmail);			

	}

	EXEC SQL CLOSE cCONSULTAREMAILS;

	return;
 
	sqlErrorConstrutor:
		memset(&buf,0,sizeof(buf));
		sprintf(buf,"ERRO NA CONSULTA DE EMAIL %d",sqlca.sqlcode);
		tuxfw_getlogger()->debug( buf );
		throw TuxBasicOraException(sqlca.sqlcode);

}
void CPessoa::consultaTbDocumento(char *chrCpf, int *intIdDocumento)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	long  iIdPessoaSQL;
	char   chrCpfSQL[256];
	int	 iIdDocumentoSQL;
	EXEC SQL END DECLARE SECTION;

	strcpy(chrCpfSQL,"");
	iIdDocumentoSQL = -1;
	iIdPessoaSQL = this->getIdPessoa();

	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	EXEC SQL
	SELECT
		d.nrdocumento, 
		d.iddocumento
	INTO
		:chrCpfSQL,
		:iIdDocumentoSQL
	FROM
		customer.PessoaDocumento pd,
		customer.Documento d
	WHERE 
		pd.idpessoa = :iIdPessoaSQL and
		pd.IDDOCUMENTO = d.IDDOCUMENTO and
		d.idtipodocumento = 1;		
	
	strcpy(chrCpfSQL, CUtil::trim(chrCpfSQL));	
	strcpy(chrCpf, chrCpfSQL);			
	*intIdDocumento = iIdDocumentoSQL;

	return;

	OraNoDataFound:
	OraException:	
		throw TuxBasicOraException(sqlca.sqlcode);	

}

void CPessoa::consultarTipoPessoa(int nrLinha, int cdAreaRegistro, int intTipoRelacionamento)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int iTipoRelacionamento;
	int iCdAreaRegistro;
	int iNrLinha;
	int idTipoPessoa;
	EXEC SQL END DECLARE SECTION;

	idTipoPessoa = -1;
	iCdAreaRegistro = cdAreaRegistro;
	iNrLinha = nrLinha;
	iTipoRelacionamento = intTipoRelacionamento;


	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	EXEC SQL 
	SELECT
		Pessoa.IDTIPOPESSOA
	INTO 
		:idTipoPessoa
	FROM
		linha.LinhaTelefonica	 	LinhaTelefonica,
		linha.LinhaBase			LinhaBase,
		apoio.EstadoLinha       	EstadoLinha,
		customer.pessoalinha		PessoaLinha,
		customer.pessoadepara		PessoaDePara,
		customer.pessoa			Pessoa,
		apoio.tipopessoa		TipoPessoa,
		apoio.AreaRegistro		AreaRegistro
	WHERE
		LinhaBase.nrLinha = :iNrLinha 
		AND LinhaBase.idAreaRegistro = AreaRegistro.idAreaRegistro
		AND AreaRegistro.cdAreaRegistro = :iCdAreaRegistro
		AND  LinhaBase.idEstadoLinha = EstadoLinha.idEstadoLinha
		AND LinhaBase.IDLINHABASE = LinhaTelefonica.IDLINHABASE
		AND LinhaTelefonica.IDLINHATELEFONICA = PessoaLinha.IDLINHATELEFONICA
		AND PessoaDePara.IDPESSOADEPARA = PessoaLinha.IDPESSOADEPARA
		AND PessoaDePara.IDPESSOA = Pessoa.IDPESSOA
		AND Pessoa.IDTIPOPESSOA = TipoPessoa.idtipopessoa
      AND LinhaTelefonica.dtexpiracao is null
		AND PessoaLinha.IDTIPORELACIONAMENTO = :iTipoRelacionamento;

	if (iTipoRelacionamento == 1)
		this->setIdTipoUsuario(idTipoPessoa);	
	else if (iTipoRelacionamento = 2)
		this->setIdTipoCliente(idTipoPessoa);
	
	return;
	
	OraException:	
		throw TuxBasicOraException(sqlca.sqlcode);	

	OraNoDataFound:
		this->setIdPessoa(0); /*não tem pessoa cadastrada para linha*/
		

}


void CPessoa::consultaDadosPessoaPP(char* cNrDocumento, int iIdTipoDocumento, XMLGen* xml_g)
{

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	char cNrDocumentoSQL[255]="";
	int iIdTipoDocumentoSQL = 0;
	long  iIdPessoa = 0;
	char cNmPessoa[255]="";
	char cDtNascimento[255]="";	
	long iIdPessoaEndereco = 0;
	char cNmTipoLogradouro[255]= "";
	char cNmTituloLogradouro[255] = "";
	char cNmLogradouro[255] = "";
	char cNrEndereco[255]= "";
	char cNmBairro[255] = "";
	char cNrCep[255] = "";
	char cMunicipio[255] = "";
	char cDsTipoEndereco[255]="";
	int  iIdUF = 0;
	int iIdSistemaOrigem = 0;
	char cDsEnderecoComplemento[255]="";
	int  iIdSexo = 0;
	int  iIdTipoEndereco = 0;


	EXEC SQL END DECLARE SECTION;

	iIdTipoDocumentoSQL =  iIdTipoDocumento;
	strcpy(cNrDocumentoSQL, cNrDocumento);

	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;
	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	EXEC SQL
	SELECT
		PESSOA.IDPESSOA,
		PESSOA.NMPESSOA,
		TO_CHAR(PESSOAFISICA.DTNASCIMENTO, 'dd/mm/yyyy'),
		SEXO.IDSEXO,
		PESSOAENDERECO.IDPESSOAENDERECO,
		TIPOENDERECO.DSTIPOENDERECO,
		DECODE(PESSOAENDERECO.NMTIPOLOGRADOURO, NULL, 'RUA', PESSOAENDERECO.NMTIPOLOGRADOURO),
		NVL(PESSOAENDERECO.NMTITULOLOGRADOURO, ' '), 
		PESSOAENDERECO.NMLOGRADOURO,
		PESSOAENDERECO.NRENDERECO,
		NVL(PESSOAENDERECO.DSENDERECOCOMPLEMENTO, ' '),
		PESSOAENDERECO.NMBAIRRO,
		PESSOAENDERECO.NRCEP,
		PESSOAENDERECO.NMMUNICIPIO,
		PESSOAENDERECO.IDUF,
		PESSOAENDERECO.IDSISTEMAORIGEM,
		TIPOENDERECO.IDTIPOENDERECO
	INTO
		:iIdPessoa,
		:cNmPessoa,
		:cDtNascimento,		
		:iIdSexo,
		:iIdPessoaEndereco,
		:cDsTipoEndereco,
		:cNmTipoLogradouro,
		:cNmTituloLogradouro,
		:cNmLogradouro,
		:cNrEndereco,
		:cDsEnderecoComplemento,
		:cNmBairro,
		:cNrCep,
		:cMunicipio,
		:iIdUF,
		:iIdSistemaOrigem,
		:iIdTipoEndereco
	FROM
		CUSTOMER.PESSOAENDERECO PESSOAENDERECO,
		CUSTOMER.PESSOA  PESSOA,
		CUSTOMER.PESSOAFISICA PESSOAFISICA,
		APOIO.SEXO SEXO,
		APOIO.TIPOENDERECO TIPOENDERECO
	WHERE
		PESSOAENDERECO.IDPESSOA =  PESSOA.IDPESSOA AND
		PESSOAFISICA.IDPESSOA 		=  PESSOA.IDPESSOA AND
		PESSOAFISICA.IDPESSOA         =  PESSOA.IDPESSOA AND
		PESSOAFISICA.IDSEXO              =  SEXO.IDSEXO AND 
		PESSOAENDERECO.IDTIPOENDERECO = TIPOENDERECO.IDTIPOENDERECO AND  
		IDPESSOAENDERECO = (
			 SELECT IDPESSOAENDERECO FROM (		
				SELECT
					PESSOAENDERECO.IDPESSOAENDERECO
				FROM
					CUSTOMER.PESSOAENDERECO PESSOAENDERECO,						
					CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
					CUSTOMER.DOCUMENTO DOCUMENTO,
					CUSTOMER.PESSOA PESSOA,
					APOIO.TIPODOCUMENTO TIPODOCUMENTO,						
					CUSTOMER.PESSOADEPARA PESSOADEPARA,
					CUSTOMER.PESSOALINHA PESSOALINHA,
					LINHA.LINHATELEFONICA LINHATELEFONICA,
					LINHA.LINHABASE LINHABASE,
					APOIO.ESTADOLINHA ESTADOLINHA ,
					CUSTOMER.LINHACONTA LINHACONTA,
					CUSTOMER.CONTAENDERECO CONTAENDERECO
				WHERE
					PESSOADOCUMENTO.IDDOCUMENTO  = DOCUMENTO.IDDOCUMENTO AND
					(DOCUMENTO.NRDOCUMENTO  = REPLACE(REPLACE( :cNrDocumentoSQL, '.', ''), '-', '') OR 
					DOCUMENTO.NRDOCUMENTO = :cNrDocumentoSQL)  AND
					DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO  AND
					TIPODOCUMENTO.SGCLASSIFICACAO IN (SELECT  SgClassificacao FROM APOIO.TIPODOCUMENTO WHERE IDTIPODOCUMENTO = :iIdTipoDocumentoSQL) AND
					PESSOA.IDPESSOA = PESSOADOCUMENTO.IDPESSOA AND
					PESSOA.IDTIPOPESSOA = 1 AND						
					PESSOADEPARA.IDPESSOA = PESSOADOCUMENTO.IDPESSOA  AND
					PESSOAENDERECO.IDPESSOA = PESSOADEPARA.IDPESSOA AND
					PESSOALINHA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA AND
					PESSOALINHA.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA AND
					LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE AND
					LINHABASE.IDESTADOLINHA = ESTADOLINHA.IDESTADOLINHA AND 
					((LINHATELEFONICA.IDTIPOLINHA  IN(1,5) AND ESTADOLINHA.SGCLASSIFICACAO = 'A' ) OR
					(LINHATELEFONICA.IDTIPOLINHA  IN(4,7)  AND  (ESTADOLINHA.SGCLASSIFICACAO = 'B'  OR ESTADOLINHA.SGCLASSIFICACAO = 'A'))) AND
					LINHACONTA.IDLINHATELEFONICA =  LINHATELEFONICA.IDLINHATELEFONICA AND
					LINHACONTA.IDCONTA = CONTAENDERECO.IDCONTA AND
					CONTAENDERECO.IDPESSOAENDERECO = PESSOAENDERECO.IDPESSOAENDERECO 
				ORDER BY PESSOALINHA.DTPESSOALINHA
				 DESC		)
			WHERE  ROWNUM = 1);

		xml_g->createTag("ENDERECOPREVO");

		xml_g->addProp("xmlns", "dados.vol.vivo.com.br/vo");

		xml_g->addItem("idPessoa", iIdPessoa);
				
		xml_g->addItem("nmPessoa", CUtil::trim(cNmPessoa));

		xml_g->addItem("dtNascimento", CUtil::trim(cDtNascimento));

		xml_g->addItem("idSexo", iIdSexo);

			xml_g->createTag("endereco");

				xml_g->addItem("idEndereco", iIdPessoaEndereco);

				xml_g->addItem("dsTipoEndereco", CUtil::trim(cDsTipoEndereco));

				xml_g->addItem("idTipoEndereco", iIdTipoEndereco);

				xml_g->addItem("nmTipoLogradouro", CUtil::trim(cNmTipoLogradouro));
				
				xml_g->addItem("nmTituloLogradouro", CUtil::trim(cNmTituloLogradouro));		

				xml_g->addItem("nmLogradouro", CUtil::trim(cNmLogradouro));

				xml_g->addItem("nrEndereco", CUtil::trim(cNrEndereco));
				
				xml_g->addItem("dsEnderecoComplemento", CUtil::trim(cDsEnderecoComplemento));

				xml_g->addItem("nmBairro", CUtil::trim(cNmBairro));

				xml_g->addItem("nmBairro", CUtil::trim(cNmBairro));

				xml_g->addItem("nrCep", CUtil::trim(cNrCep));

				xml_g->addItem("nmMunicipio", CUtil::trim(cMunicipio));

				xml_g->addItem("idUF", iIdUF);
				
				xml_g->addItem("idSistemaOrigem", iIdSistemaOrigem);

			xml_g->closeTag();

		xml_g->closeTag();

OraNoDataFound:
		return;


OraException:	

		tuxfw_getlogger()->debug("OraException = %d\r\n", sqlca.sqlcode);	
		throw TuxBasicOraException(sqlca.sqlcode);	

}

void CPessoa::consultaSiglasCadastro( XMLGen* xml_g)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int iIdSexo = 0;
	char cDsSexo[255] = "";
	int iIdTipoDocumento = 0;
	char cDsTipoDocumento[255] = "";
	int  iIdUF = 0;
	char cSgUF[255]="";
	int  iIdTpEnd = 0;
	char cSgTpEnd[255]= "";
	char cDsTpEnd[255] = "";

	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR  GOTO OraException;
	
	EXEC SQL DECLARE LSTDSSEXO CURSOR FOR	
	SELECT
		IDSEXO,
		DSSEXO		
	 FROM
		APOIO.SEXO
	 WHERE 
	        IDSEXO = 1 OR IDSEXO = 2;
	
	EXEC SQL WHENEVER NOT FOUND DO BREAK;	
	EXEC SQL OPEN LSTDSSEXO;

	xml_g->createTag("SiglasCadPPVO");

		xml_g->addProp("xmlns", "dados.vol.vivo.com.br/vo");
	
	for(;;) 
	{
		// varre todos os registros para criar a lista com os servicos
		EXEC SQL FETCH LSTDSSEXO INTO
			:iIdSexo,
			:cDsSexo;
			
		xml_g->createTag("ListaTipoSexo");
			xml_g->addItem("idSexo", iIdSexo);
			xml_g->addItem("dsSexo", CUtil::trim(cDsSexo));
		xml_g->closeTag();
	}

	EXEC SQL CLOSE LSTDSSEXO;


	EXEC SQL DECLARE LSTDSDOCUMENTO CURSOR FOR	
	SELECT
		IDTIPODOCUMENTO,
		DSTIPODOCUMENTO		
	 FROM
		APOIO.TIPODOCUMENTO
	WHERE 
		SGTIPODOCUMENTO IN ('CPF', 'RG', 'PAS');

	
	
	EXEC SQL WHENEVER NOT FOUND DO BREAK;	
	EXEC SQL OPEN LSTDSDOCUMENTO;

	for(;;) 
	{
		// varre todos os registros para criar a lista com os servicos
		EXEC SQL FETCH LSTDSDOCUMENTO INTO
			:iIdTipoDocumento,
			:cDsTipoDocumento;

			
		xml_g->createTag("ListaTipoDocumento");
			xml_g->addItem("idTipoDocumento", iIdTipoDocumento);
			xml_g->addItem("dsTipoDocumento", CUtil::trim(cDsTipoDocumento));
		xml_g->closeTag();
	
	}

	
	EXEC SQL CLOSE LSTDSDOCUMENTO;

	EXEC SQL DECLARE LSTSGUF CURSOR FOR	
	SELECT 
		IDUF,
		SGUF
	FROM
		APOIO.UF
	WHERE 
		IDUF BETWEEN 1 AND 30;

	EXEC SQL WHENEVER NOT FOUND DO BREAK;	
	EXEC SQL OPEN LSTSGUF;

	for(;;) 
	{
		// varre todos os registros para criar a lista com os servicos
		EXEC SQL FETCH LSTSGUF INTO
			:iIdUF,
			:cSgUF;

			
		xml_g->createTag("ListaUF");
			xml_g->addItem("idUF", iIdUF);
			xml_g->addItem("sgUF", CUtil::trim(cSgUF));
		xml_g->closeTag();
	
	}

	EXEC SQL CLOSE LSTSGUF;

	EXEC SQL DECLARE LSTDSENDERECO CURSOR FOR
	SELECT
		idTipoEndereco,
		sgTipoEndereco,
		dsTipoEndereco
	FROM
		apoio.TipoEndereco
	WHERE
		idTipoEndereco != 0
	ORDER BY
		idTipoEndereco;

	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	
	EXEC SQL OPEN LSTDSENDERECO;

	
	for( ;; ) {
	// varre todos os registros para criar a lista com os Relacionamentos
		EXEC SQL FETCH LSTDSENDERECO INTO
			  :iIdTpEnd,
			  :cSgTpEnd,
			  :cDsTpEnd;

		xml_g->createTag("ListaTipoEndereco");

			xml_g->addItem("idTipoEndereco", iIdTpEnd);
			xml_g->addItem("sgTipoEndereco", CUtil::trim(cSgTpEnd));
			xml_g->addItem("dsTipoEndereco", CUtil::trim(cDsTpEnd));
			
		xml_g->closeTag(); //tipoEndereco
			
	}


	EXEC SQL CLOSE LSTDSENDERECO;

	xml_g->closeTag();

	return;

	OraException:	
		throw TuxBasicOraException(sqlca.sqlcode);	

} 

void CPessoa::consultarDocumento()
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	char  cDsTipoDocumento[255] = "";
	char  cNrDocumento[255] = "";
	long  iIdPessoa = 0;
	EXEC SQL END DECLARE SECTION;

	iIdPessoa = this->getIdPessoa();


	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR  GOTO OraException;

	EXEC SQL 
	SELECT 
		DSTIPODOCUMENTO,
		NRDOCUMENTO
	INTO
		:cDsTipoDocumento,
		:cNrDocumento		
	FROM(
		SELECT 
			NRDOCUMENTO, 
			SGCLASSIFICACAO, 
			A.IDDOCUMENTO,
			DSTIPODOCUMENTO
		FROM 
   			CUSTOMER.DOCUMENTO		A, 
   			APOIO.TIPODOCUMENTO 		B, 
			CUSTOMER.PESSOADOCUMENTO	C 
		WHERE  
			A.IDTIPODOCUMENTO = B.IDTIPODOCUMENTO
		   AND  B.SGCLASSIFICACAO IN ('CPF', 'PAS', 'RG')	
		   AND  C.IDDOCUMENTO   = A.IDDOCUMENTO		
		   AND  C.IDPESSOA  = :iIdPessoa
		   AND  C.DTEXPIRACAO IS NULL
	       ORDER BY B.NRPRIORIDADE
	     )
	  WHERE 
		ROWNUM = 1;


	this->setDsTipoDocumento(CUtil::trim(cDsTipoDocumento));
	this->setNrDocumento(CUtil::trim(cNrDocumento));

	return;

	OraException:	
		throw TuxBasicOraException(sqlca.sqlcode);	

}