// Banco.cpp: implementation of the CBanco class.
//
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw/tuxfw.h>
#include <Defines/Defines.h>
#include <Util/Util.hpp>
#include <Banco/Banco.hpp>

EXEC SQL INCLUDE SQLCA;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBanco::CBanco()
{  	   
    this->setIdBanco(-1);
    this->setIdTipoBanco(-1);
	this->setNmBanco("");
	this->setDsURLBanco("");
}

CBanco::~CBanco()
{

}

/*

  GETs

*/

int CBanco::getIdBanco() 
{
	return this->m_iIdBanco;
}

int CBanco::getIdTipoBanco() 
{
	return this->m_iIdTipoBanco;
}

char * CBanco::getNmBanco() 
{
	return this->m_cNmBanco;
}

char * CBanco::getDsURLBanco() 
{
	return this->m_cDsURLBanco;
}

/*

   SETs

*/

void CBanco::setIdBanco(int value) 
{
	this->m_iIdBanco = value;
}

void CBanco::setIdTipoBanco(int value) 
{
	this->m_iIdTipoBanco = value;
}

void CBanco::setNmBanco(char *value) 
{
	strcpy(this->m_cNmBanco, value);
}

void CBanco::setDsURLBanco(char *value) 
{
	strcpy(this->m_cDsURLBanco, value);
}

//Metodos de Negocio da Interface da Classe CBanco:

void CBanco::consultarBancos(int iIdTipoBanco,
							 list<CBanco> & listaBanco, int iCdAreaRegistro)
{
	CBanco::carregarBancosDB(iIdTipoBanco, listaBanco, iCdAreaRegistro);
}

void CBanco::setInSiteaSite(int value)
{
	this->m_inSiteaSite = value;
}
int CBanco::getInSiteaSite()
{
	return this->m_inSiteaSite;
}

// Métodos de acesso a banco de dados
void CBanco::carregarBancosDB(int iIdTipoBanco,
							  list<CBanco> & listaBanco, int iCdAreaRegistro)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;	
	int  iIdTipoBancoDB;
	int  iCdAreaRegistroDB;
	int	 iIdUFDB;

	int  iInSiteaSite;
	int  iIdBanco;
	char cNmBanco[256];
	char cDsURLBanco[256];
	EXEC SQL END DECLARE SECTION;

	CBanco     oBanco;

	// valores das chaves da consulta SQL
	iIdTipoBancoDB = iIdTipoBanco;
	iCdAreaRegistroDB = iCdAreaRegistro;

	// garante que a lista esta vazia
	listaBanco.clear();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL
		SELECT 
			   b.idUF
		INTO
			   :iIdUFDB	
		FROM 
			   apoio.AreaRegistro  	a,
			   customer.UFOperadora	b
		WHERE 
			   a.idUFOperadora = b.idUFOperadora
		AND	   a.cdAreaRegistro = :iCdAreaRegistroDB;


	EXEC SQL DECLARE LSTBANCOS CURSOR FOR

		SELECT
			a.idBanco,
			NVL(b.nmBanco, ' ') AS nmBanco,
			NVL(b.dsURLBanco, ' ') AS dsURLBanco,
			b.INSITEASITE
		FROM
			vol.TipoBancoUF  a,
			apoio.Banco		b
		WHERE
            a.idBanco		= b.idBanco 			
        AND a.idTipoBanco	= :iIdTipoBancoDB
		AND a.idUF			= :iIdUFDB;

	EXEC SQL WHENEVER NOT FOUND DO break;

	EXEC SQL OPEN LSTBANCOS;

	for( ;; ) {

		// varre todos os registros para criar a lista com os bancos

		EXEC SQL FETCH LSTBANCOS INTO
			:iIdBanco,
			:cNmBanco,
			:cDsURLBanco,
			:iInSiteaSite;

		oBanco.setIdBanco(iIdBanco);
		oBanco.setIdTipoBanco(iIdTipoBanco);
		oBanco.setNmBanco(CUtil::trim(cNmBanco));
		oBanco.setDsURLBanco(CUtil::trim(cDsURLBanco));
		oBanco.setInSiteaSite(iInSiteaSite);

		listaBanco.push_back(oBanco);

	}

	EXEC SQL CLOSE LSTBANCOS;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);

}

// Operação de Negócio para inserir nova chave de acesso para pagamento de boleto
void CBanco::setTransacaoBanco(char*chave,char*codigoBarras)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;	
		char *pChave = chave;
		char *pCodigoBarras = codigoBarras;
	EXEC SQL END DECLARE SECTION;

	// marca ponto de controle de erro
	EXEC SQL WHENEVER NOT FOUND GOTO sqlErrorConstrutor;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL
	INSERT INTO VOL.TRANSACAOBANCO (IDTRANSACAOBANCO,IDCODIGODEBARRAS) VALUES
	(:pChave,:pCodigoBarras);

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}

// Operação para recuperar a chave de transação do banco
void CBanco::getCodigoBarras(char*chave,char *codigoBarras)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;	
		char *pChave = chave;
		VARCHAR pCodigoBarras[49];
	EXEC SQL END DECLARE SECTION;
	memset(&pCodigoBarras,0,sizeof(pCodigoBarras));

	// marca ponto de controle de erro
	EXEC SQL WHENEVER NOT FOUND GOTO sqlErrorConstrutor;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
	EXEC SQL
	SELECT NVL(IDCODIGODEBARRAS,' ') INTO :pCodigoBarras FROM VOL.TRANSACAOBANCO WHERE IDTRANSACAOBANCO = :pChave;

	sprintf(codigoBarras,(char*)pCodigoBarras.arr);

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}

// Operacao para remover a chave de transação do banco
void CBanco::removeTransacaoBanco(char*chave)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;	
		char *pChave = chave;
	EXEC SQL END DECLARE SECTION;

	// marca ponto de controle de erro
	EXEC SQL WHENEVER NOT FOUND GOTO sqlErrorConstrutor;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
	EXEC SQL
	DELETE FROM VOL.TRANSACAOBANCO WHERE IDTRANSACAOBANCO = :pChave;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}