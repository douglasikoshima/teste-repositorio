#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw/tuxfw.h>
#include <Defines/Defines.h>
#include <Email/Email.hpp>

EXEC SQL INCLUDE SQLCA;

CEmail::CEmail(){
	this->setIdEmail(0);
	this->setIdTipoEmail(0);
	this->setDsTipoEmail("");
	this->setDsEmail("");
}

CEmail::~CEmail(){
}


// Getters
int	CEmail::getIdEmail(){
	return m_iIdEmail;
}
int CEmail::getIdTipoEmail(){
	return m_iIdTipoEmail;
}
char *CEmail::getDsTipoEmail(){
	return this->m_cDsTipoEmail;
}
char *CEmail::getDsEmail(){
	return this->m_cDsEmail;
}


// Setters
void CEmail::setIdEmail(int value){
	this->m_iIdEmail = value;
}
void CEmail::setIdTipoEmail(int value){
	this->m_iIdTipoEmail = value;
}
void CEmail::setDsTipoEmail(char *value){
	strcpy(this->m_cDsTipoEmail, value);
}
void CEmail::setDsEmail(char *value){
	strcpy(this->m_cDsEmail, value);
}


//Métodos de negócio
void CEmail::consultarTiposEmail(list< CEmail > & lstEmail){
	this->consultarTiposEmailDB(lstEmail);
}
void CEmail::incluirEmail(long iIdPessoa){
	CEmail::incluirEmailDB(iIdPessoa);
}
void CEmail::alterarEmail(){
	CEmail::alterarEmailDB();
}
void CEmail::excluirEmail(){
	CEmail::excluirEmailDB();
}
bool CEmail::verificarEmail(long iIdPessoa){
	return CEmail::verificarEmailDB(iIdPessoa);
}
bool CEmail::verificarTipoEmail(){
	return CEmail::verificarTipoEmailDB();
}


//Métodos de acesso ao DB
void CEmail::incluirEmailDB(long iIdPessoa){
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	long  iIdPessoaDB=0;
	int  iIdTipoEmailDB=0;
	char cDsEmailDB[256]="";

	long  iIdPessoaComunicacaoDB=0;
	int  iNrSequenciaDB=0;
	char cSgClassificacaoDB[256]="";
	int	 iIdSistemaOrigemFO=0;
	EXEC SQL END DECLARE SECTION;

	iIdPessoaDB = iIdPessoa;
	iIdTipoEmailDB = this->getIdTipoEmail();
	strcpy(cDsEmailDB, this->getDsEmail());
	strcpy(cSgClassificacaoDB, SGCLASSIFICACAO_EMAIL);
	iIdSistemaOrigemFO = ID_SISTEMA_ORIGEM_FO;

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL
		SELECT
			customer.PessoaComunicacaoSQ.nextval
		INTO
			:iIdPessoaComunicacaoDB
		FROM
			Dual;
	
	EXEC SQL
		SELECT
			NVL(Max(a.nrSequencia),0) + 1
		INTO
			:iNrSequenciaDB
		FROM 
			customer.PessoaComunicacao	a,
			apoio.TipoComunicacao		b
		WHERE
			a.idTipoComunicacao = b.idTipoComunicacao
		AND	a.idPessoa			= :iIdPessoaDB
		AND b.sgClassificacao	= :cSgClassificacaoDB;

	EXEC SQL
		INSERT INTO
			customer.PessoaComunicacao
			(IDPESSOACOMUNICACAO, 
			IDPESSOA, 
			IDTIPOCOMUNICACAO, 
			NRSEQUENCIA, 
			DSCONTATO, 
			DTCADASTRO, 
			DTULTIMAALTERACAO,
			IDCOMUNICACAOSISTEMAORIGEM, 
			IDSISTEMAORIGEM)
		VALUES
			(:iIdPessoaComunicacaoDB,
			:iIdPessoaDB,
			:iIdTipoEmailDB,
			:iNrSequenciaDB,
			:cDsEmailDB,
			sysdate,
			sysdate,
			:iIdPessoaComunicacaoDB,
			:iIdSistemaOrigemFO);


	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}
void CEmail::alterarEmailDB(){
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int  iIdEmailDB=0;
	int  iIdTipoEmailDB=0;
	char cDsEmailDB[256]="";
	EXEC SQL END DECLARE SECTION;

	iIdEmailDB = this->getIdEmail();
	iIdTipoEmailDB = this->getIdTipoEmail();
	strcpy(cDsEmailDB, this->getDsEmail());

	// marca ponto de controle de erro
	EXEC SQL WHENEVER NOT FOUND GOTO sqlErrorConstrutor;

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL
		UPDATE
			customer.PessoaComunicacao
		SET	
			IDTIPOCOMUNICACAO = :iIdTipoEmailDB, 
			DSCONTATO = :cDsEmailDB, 
			DTULTIMAALTERACAO = sysdate
		Where
			IDPESSOACOMUNICACAO = :iIdEmailDB;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}
void CEmail::excluirEmailDB(){
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int  iIdEmailDB=0;
	EXEC SQL END DECLARE SECTION;

	iIdEmailDB = this->getIdEmail();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER NOT FOUND GOTO sqlErrorConstrutor;

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL
		DELETE
			customer.PessoaComunicacao
		Where
			IDPESSOACOMUNICACAO = :iIdEmailDB;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}
bool CEmail::verificarEmailDB(long iIdPessoa){
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int  iIdEmailDB=0;  //utilizado caso não seja passado o idPessoa.
	long  iIdPessoaDB=0;
	int  iIdTipoComunicacao = 0;
	char cDsEmailDB[256]="";

	char cSgClassificacaoDB[256]="";
	int	 iPossuiEmail=0;
	EXEC SQL END DECLARE SECTION;

	iIdPessoaDB = iIdPessoa;
	if (iIdPessoaDB <= 0) iIdEmailDB = this->getIdEmail(); //utilizado caso não seja passado o idPessoa.
	strcpy(cDsEmailDB, this->getDsEmail());
	strcpy(cSgClassificacaoDB, SGCLASSIFICACAO_EMAIL);

	iIdTipoComunicacao = this->getIdTipoEmail();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	if (iIdPessoaDB <= 0){
		EXEC SQL
			SELECT
				idPessoa
			INTO
				:iIdPessoaDB
			FROM 
				customer.PessoaComunicacao
			WHERE
				idPessoaComunicacao = :iIdEmailDB;
	}

	EXEC SQL
		SELECT
			NVL(Count(a.idPessoaComunicacao),0)
		INTO
			:iPossuiEmail
		FROM 
			customer.PessoaComunicacao	a,
			apoio.TipoComunicacao		b
		WHERE
			a.idTipoComunicacao = b.idTipoComunicacao
		AND	a.idPessoa			= :iIdPessoaDB
		AND a.dsContato			= :cDsEmailDB		
		AND b.sgClassificacao	= :cSgClassificacaoDB
		AND b.idTipoComunicacao = :iIdTipoComunicacao;

	//Caso o e-mail já exista, retorna false.
	if (iPossuiEmail >= 1)
		return false;
	else
		return true;

	return false;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}
bool CEmail::verificarTipoEmailDB(){
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int  iIdTipoEmailDB=0;
	char cSgClassificacaoDB[256]="";
	int	 iExisteTipoEmail=0;
	EXEC SQL END DECLARE SECTION;

	iIdTipoEmailDB = this->getIdTipoEmail();
	strcpy(cSgClassificacaoDB, SGCLASSIFICACAO_EMAIL);

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL
		SELECT
			NVL(Count(idTipoComunicacao),0)
		INTO
			:iExisteTipoEmail
		FROM 
			apoio.TipoComunicacao		
		WHERE
			idTipoComunicacao	= :iIdTipoEmailDB
		AND	sgClassificacao		= :cSgClassificacaoDB;

	//Caso o Tipo do e-mail não exista, retorna false.
	if (iExisteTipoEmail <= 0)
		return false;
	else
		return true;

	return false;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}
void CEmail::consultarTiposEmailDB(list< CEmail > & lstEmail){
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	   int  iIdTipoComunicacao=0; 
	   char cDsTipoComunicacao[256]="";  
	   char cSgClassificacaoEmail[256]="";
	EXEC SQL END DECLARE SECTION;

	strcpy(cSgClassificacaoEmail, SGCLASSIFICACAO_EMAIL);

	CEmail oEmail;

	// garante que a lista esta vazia
	lstEmail.clear();
	

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
	
	EXEC SQL DECLARE LSTCONSULTARTIPOSEMAIL CURSOR FOR

		SELECT 
			   idTipoComunicacao, 
			   dsTipoComunicacao  
		FROM 
			   apoio.TipoComunicacao
		WHERE 
			   sgClassificacao = :cSgClassificacaoEmail;

	EXEC SQL WHENEVER NOT FOUND DO break;

	EXEC SQL OPEN LSTCONSULTARTIPOSEMAIL;

	for( ;; ) {
		// varre todos os registros para criar a lista com os Relacionamentos
		EXEC SQL FETCH LSTCONSULTARTIPOSEMAIL INTO
			:iIdTipoComunicacao,
			:cDsTipoComunicacao;

		oEmail.setIdTipoEmail(iIdTipoComunicacao);
		oEmail.setDsTipoEmail(CUtil::trim(cDsTipoComunicacao));

		lstEmail.push_back( oEmail );
	}

	EXEC SQL CLOSE LSTCONSULTARTIPOSEMAIL;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CEmail::getEmail(XMLGen*gen,char* linha,char* ddd)
{
	tuxfw_getlogger()->debug("Email::getEmail");
	tuxfw_getlogger()->debug("linha=%s",linha);
	tuxfw_getlogger()->debug("ddd=%s",ddd);

	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct param{
			VARCHAR dsContato[256];
			VARCHAR idTipoLinha[21+1];
			VARCHAR idPessoa[21+1];						
		}m_param;
		struct iparam{
			short dsContato;
			short idTipoLinha;
			short idPessoa;
		}m_iparam;
		char*clinha = linha;
		char*cddd = ddd;
		int fraseSecreta = 0;
	EXEC SQL END DECLARE SECTION;
	sqlca.sqlcode = 0;
	memset(&m_param,0,sizeof(m_param));
	memset(&m_iparam,0,sizeof(m_iparam));

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;	
	EXEC SQL SELECT
			  PESSOA.IDPESSOA,
			  LINHATELEFONICA.IDTIPOLINHA
		INTO
			 :m_param.idPessoa:m_iparam.idPessoa,
			 :m_param.idTipoLinha:m_iparam.idTipoLinha
		FROM
			LINHA.LINHABASE LINHABASE,
			LINHA.LINHATELEFONICA LINHATELEFONICA,
			APOIO.AREAREGISTRO AREAREGISTRO,
			CUSTOMER.PESSOALINHA PESSOALINHA,
			CUSTOMER.PESSOA PESSOA,
			CUSTOMER.PESSOADEPARA PESSOADEPARA,
			CUSTOMER.TIPORELACIONAMENTO			
		WHERE
			 LINHABASE.NRLINHA = TO_NUMBER(:clinha) AND
			 LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO AND
			 AREAREGISTRO.CDAREAREGISTRO = TO_NUMBER(:cddd) AND
			 LINHABASE.IDLINHABASE = LINHATELEFONICA.IDLINHABASE AND
			 LINHATELEFONICA.IDLINHATELEFONICA = PESSOALINHA.IDLINHATELEFONICA AND
			 PESSOA.IDPESSOA = PESSOADEPARA.IDPESSOA AND
			 PESSOADEPARA.IDPESSOADEPARA = PESSOALINHA.IDPESSOADEPARA AND
			 PESSOALINHA.IDTIPORELACIONAMENTO = TIPORELACIONAMENTO.IDTIPORELACIONAMENTO AND
			 TIPORELACIONAMENTO.SGTIPORELACIONAMENTO = 'C' AND ROWNUM = 1;

	if(sqlca.sqlcode == 1403)
	{
		return ERRO_LINHA_NAO_ENCONTRADA;
	}// linha pós
	else if(!strcmp((char*)m_param.idTipoLinha.arr,"1")||
	!strcmp((char*)m_param.idTipoLinha.arr,"5"))
	{
		return ERRO_LINHA_POSPAGA;
	}
	sqlca.sqlcode = 0;


	EXEC SQL WHENEVER SQLERROR GOTO Error;
    EXEC SQL WHENEVER NOT FOUND do break;	
	EXEC SQL DECLARE CursorEmail CURSOR FOR
		SELECT
			  NVL(PESSOACOMUNICACAO.DSCONTATO,' ')
		FROM
			CUSTOMER.PESSOACOMUNICACAO PESSOACOMUNICACAO,
			APOIO.TIPOCOMUNICACAO TIPOCOMUNICACAO	
		WHERE
			 PESSOACOMUNICACAO.IDTIPOCOMUNICACAO = TIPOCOMUNICACAO.IDTIPOCOMUNICACAO AND
			 TIPOCOMUNICACAO.SGCLASSIFICACAO = 'E-MAIL' AND
			 PESSOACOMUNICACAO.IDPESSOA = :m_param.idPessoa
		ORDER BY
			  PESSOACOMUNICACAO.DTULTIMAALTERACAO DESC;
	EXEC SQL OPEN CursorEmail;
	for(;;)
	{
		memset(&m_param.dsContato,0,sizeof(m_param.dsContato));
		memset(&m_iparam.dsContato,0,sizeof(m_iparam.dsContato));
		EXEC SQL FETCH CursorEmail INTO :m_param.dsContato:m_iparam.dsContato;
		gen->addItem("email",(char*)m_param.dsContato.arr);
		break;
	}
	EXEC SQL CLOSE CursorEmail;
		
		
	if(!strcmp((char*)m_param.dsContato.arr,"") || sqlca.sqlcode == 1403)
	{
		return ERRO_EMAIL_NAO_ENCONTRADO;
	}

	sqlca.sqlcode = 0;

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;	
	EXEC SQL
		SELECT COUNT(1) 
		INTO :fraseSecreta
		FROM CUSTOMER.SENHA
		WHERE
		IDPESSOA = :m_param.idPessoa AND
		DSFRASESECRETA IS NOT NULL;

	if(fraseSecreta)
		gen->addItem("fraseSecreta","S");
	else
		gen->addItem("fraseSecreta","N");



	return 1;
Error:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CEmail::consultarIdPessoa(int iCdAreaRegistro, int iNrLinha)
{

struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		int iNrLinhaSQL = 0;
		int iCdAreaRegistroSQL = 0;
		int iIdPessoa = 0;

	EXEC SQL END DECLARE SECTION;

	iNrLinhaSQL = iNrLinha;
	iCdAreaRegistroSQL = iCdAreaRegistro;

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
	
	EXEC SQL
		SELECT 
			IDPESSOA
		INTO
			:iIdPessoa
		FROM 
			LINHA.LINHABASE LINHABASE,
			LINHA.LINHATELEFONICA LINHATELEFONICA,
			APOIO.AREAREGISTRO AREAREGISTRO,
			CUSTOMER.PESSOALINHA PESSOALINHA,
			CUSTOMER.PESSOADEPARA PESSOADEPARA
		WHERE 
			LINHABASE.NRLINHA = :iNrLinhaSQL AND
			LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO AND
			AREAREGISTRO.CDAREAREGISTRO = :iCdAreaRegistroSQL AND
			LINHABASE.IDLINHABASE = LINHATELEFONICA.IDLINHABASE AND
			LINHATELEFONICA.IDLINHATELEFONICA = PESSOALINHA.IDLINHATELEFONICA AND
			PESSOALINHA.IDTIPORELACIONAMENTO = 1 AND
			PESSOALINHA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA;

	return iIdPessoa;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);

}