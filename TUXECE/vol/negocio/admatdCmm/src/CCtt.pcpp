/**
 * @modulo  ADM
 * @usecase ADM
 * @author  
 * @version $Revision: 1.1.6.3 $
 * @CVS     $Author: a5114878 $ - $Date: 2012/08/27 19:27:27 $
 **/

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CCtt.h"

#define CONVIND(O,I) \
{ \
	if (I == -1) { \
		##O.arr[0]=0; \
	} else { \
		##O.arr[##O.len]=0; \
	} \
}

CContato::CContato()
{
	memset( pzcPath, 0, sizeof( pzcPath ) );
}

CContato::~CContato()
{
}

void CContato::strDateToYYYYMMDD( char* pzcDestino, char* pzcDate )
{
	//Esperamos que em pzcDestino haja espaco para isto
	if( strlennull( pzcDate ) >= 10 ) //DD/MM/YYYY
	{
		strncpy( pzcDestino, &pzcDate[6], 4 );
		strncat( pzcDestino, &pzcDate[3], 2 );
		strncat( pzcDestino, &pzcDate[0], 2 );
	}
}	

int CContato::Insert( char* cidContatoPai,
			          char* cidNomeContato,
					  char* cnmContato,
			          char* cinDisponibilidade,
					  char* cinFolha,
					  char* cidUser,
                      char* cidTipoArvore )
{

    ULOG_START("CContato::Insert()");

	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR stidNomeContato[21+1];
		VARCHAR stidContato[21+1];
		VARCHAR stinDisponibilidade[21+1];
		VARCHAR stidTipoArvore[2+1];
		char* cAuxnmContato = cnmContato;
		char* cAuxidContatoPai = cidContatoPai;
		char* cAuxinDisponibilidade = cinDisponibilidade;
		char* cAuxinFolha = cinFolha;
		char* cAuxidUser = cidUser;
        char* cAuxidTipoArvore = cidTipoArvore;
		int   iCont=0;
		char* cDisponivel = "1";
		char* cNaoDisponivel = "0";
		char* cStringVazia = "";
        short i_stidTipoArvore;
	EXEC SQL END DECLARE SECTION;
	
	ZeraContato();
	
	memset( &stidContato, 0, sizeof( stidContato ) );
	memset( &stidNomeContato, 0, sizeof( stidNomeContato ) );
	memset( &stinDisponibilidade, 0, sizeof( stinDisponibilidade ) );
	memset( &stidTipoArvore, 0, sizeof( stidTipoArvore ) );
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
	sqlca.sqlcode = 0;
	
	//Para evitar problemas na comparacao
	if( strlennull( cinFolha ) <= 0 )
		cinFolha = cStringVazia;
	
	if( strlennull( cidNomeContato ) <= 0 )
	{
		if( strlennull( cAuxnmContato ) <= 0 )
		{
			SetErro( "Nome de contato e idNomeContato estão nulos" );
			ULOG_END("CContato::Insert() return 1");
			return 1;//Erro
		}
		//Procura por um nome
		EXEC SQL
			SELECT
				IDNOMECONTATO
			INTO
				:stidNomeContato
			FROM
				CONTATOADM.NOMECONTATO
			WHERE
				UPPER(NMCONTATO) = TRIM(UPPER(:cAuxnmContato))
			AND
				ROWNUM <= 1;

		//Se nao achou o nome, entao insere
		if( stidNomeContato.len <= 0 )
		{
			//Recupera um ID unica e sequencial
			EXEC SQL 
				SELECT 
					CONTATOADM.NOMECONTATOSQ.NEXTVAL
				INTO 
					:stidNomeContato
				FROM 
					DUAL;

			if(sqlca.sqlcode)
			{
				SetErro( "Erro ao tentar recuperar a seqüência CONTATOADM.NOMECONTATOSQ.NEXTVAL" );
				ULOG_END("CContato::Insert() return 1");
				return 1;//Erro
			}
			
			//Insere um nome de contato
			EXEC SQL 
				INSERT INTO CONTATOADM.NOMECONTATO
					( IDNOMECONTATO
					 ,NMCONTATO
					 ,IDUSUARIOALTERACAO
					 ,DTULTIMAALTERACAO )
					VALUES 
					( :stidNomeContato
					 ,TRIM(SUBSTR(:cAuxnmContato,1,255))
					 ,:cAuxidUser
					 ,SYSDATE );

			if(sqlca.sqlcode)
			{
				SetErro( "Erro na inserção em CONTATOADM.NOMECONTATO" );
				ULOG_END("CContato::Insert() return 1");
				return 1;
			}
		}//if( stidNomeContato <= 0 )
		else
		{
			cidNomeContato = (char*)stidNomeContato.arr;
		}//if( stidNomeContato.len <= 0 )
	}//if( strlennull( cidNomeContato ) <= 0 )
	else
	{
		strcpy( (char*)stidNomeContato.arr, cidNomeContato );
		stidNomeContato.len = strlen( cidNomeContato );
	}

	//Verifica se existe algum nome neste nivel da arvore 
	//(uma pasta pode ser igual a uma folha, mas nao igual a outra pasta, o mesmo vale para folha)
	if( TemNomeIgualNoMesmoNivel( cAuxidContatoPai, (char*)stidNomeContato.arr, cAuxinFolha ) > 0 )
	{
		SetErro( "Não pode haver dois nomes iguais no mesmo nível com o mesmo pai" );
		ULOG_END("CContato::Insert() return 2");
		return 2;//Warning
	}

    // Obtém o id do tipo da árvore de contatos
    EXEC SQL
        SELECT
            IDTIPOARVORE
        INTO
            :stidTipoArvore 
        FROM
            APOIO.TIPOARVORE
        WHERE
            DSTIPOARVORE = 'ÁRVORE DE CONTATOS';

    // Se o tipo da árvore não for informado, assume árvore de contatos.

    if ( cidTipoArvore == 0 || *cidTipoArvore == 0 )
    {
        cAuxidTipoArvore = (char*)stidTipoArvore.arr;
    }

	//Soh recupera a inDisponibilidade do pai se for pasta, folha eh sempre desabilitada
    if ( strcmp(cAuxidTipoArvore,(char*)stidTipoArvore.arr) == 0 )
    { // aplica regra de disponibilidade se o tipo da árvore é de contato
	    if( strcmp( cinFolha, "1" ) != 0 )
	    {
		    EXEC SQL
			    SELECT
				    INDISPONIBILIDADE
			    INTO
				    :stinDisponibilidade
			    FROM
				    CONTATOADM.CONTATO
	            WHERE
	                IDCONTATO = :cAuxidContatoPai;
	    }
	    else
        {
		    cAuxinDisponibilidade = cNaoDisponivel;//Se eh folha, desabilita
        }

	    //Soh verifica se retornou algo ou se eh folha ( no caso de folha o select acima nao eh executado, 
	    //fica sempre zerado, e a disponibilidade desativada)
	    if( stinDisponibilidade.len > 0 )
	    {
		    //Se o pai estiver indisponivel, tambem cria a folha indisponivel
		    if( strcmp( (char*)stinDisponibilidade.arr, "1" ) != 0 )
			    cAuxinDisponibilidade = cNaoDisponivel;
	    }
    }
	else
    {
		cAuxinDisponibilidade = cDisponivel;  // Nós nascem disponíveis para outras árvores...
    }

	//Recupera um ID unico
	EXEC SQL 
		SELECT CONTATOADM.CONTATOSQ.NEXTVAL
		  INTO :stidContato
		  FROM DUAL;

	if(sqlca.sqlcode)
	{
		SetErro( "Erro ao tentar recuperar a seqüência CONTATOADM.CONTATOSQ.NEXTVAL" );
		ULOG_END("CContato::Insert() return 1");
		return 1;
	}

	//Insere um item na arvore
	EXEC SQL 
		INSERT INTO CONTATOADM.CONTATO
			( IDCONTATO
			 ,IDNOMECONTATO
			 ,INDISPONIBILIDADE
             ,IDTIPOARVORE
			 ,IDUSUARIOALTERACAO
			 ,DTULTIMAALTERACAO )
			VALUES 
			( :stidContato
			 ,:stidNomeContato
			 ,:cAuxinDisponibilidade
             ,:cAuxidTipoArvore
			 ,:cAuxidUser
			 ,SYSDATE );

	//Insere primeiro, depois atualiza o path
	atualizaPath( (char*)stidContato.arr );

	if(sqlca.sqlcode)
	{
		SetErro( "Falha na inserção em CONTATOADM.CONTATO" );
		ULOG_END("CContato::Insert() return 1");
		return 1;
	}
	//Insere a hierarquia		  
	EXEC SQL
		INSERT INTO CONTATOADM.CONTATOHIERARQUIA
			( IDCONTATO
			 ,IDCONTATOPAI
			 ,IDUSUARIOALTERACAO
			 ,DTULTIMAALTERACAO )
		VALUES
			( :stidContato
			 ,:cAuxidContatoPai
			 ,:cAuxidUser
			 ,SYSDATE );

	Add((char*)stidContato.arr,
		cAuxidContatoPai,
		"",
		"",
		"",
		getPath(),
		0,
		0,
        "");
		
	ULOG_END("CContato::Insert()");
			
	if(sqlca.sqlcode)
	{
		SetErro( "Falha na inserção em CONTATOADM.CONTATOHIERARQUIA" );
		return 1; //Erro
	}
	else
		return 0;//Sucesso
	
GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CContato::InsertCopia( char* cidContatoPai,
			               char* cidNomeContato,
			               char* cinDisponibilidade,
					       char* cidUser,
                           char* cidTipoArvore,
                           char* cdsTipoProcesso )
{
    ULOG_START("CContato::InsertCopia()");

	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR stidNomeContato[21+1];
		VARCHAR stnmContato[255+1];
		VARCHAR stidContato[21+1];
		VARCHAR stinDisponibilidade[21+1];
		VARCHAR stidTipoArvore[2+1];
		VARCHAR stdsTipoArvore[255+1];
		char* cAuxidContatoPai = cidContatoPai;
		char* cAuxidNomeContato = cidNomeContato;
		char* cAuxinDisponibilidade = "0";
        char* cAuxidTipoArvore= cidTipoArvore;
		char* cAuxidUser = cidUser;
	EXEC SQL END DECLARE SECTION;
	
	ZeraContato();
	
	memset( &stidContato, 0, sizeof( stidContato ) );
	memset( &stidNomeContato, 0, sizeof( stidNomeContato ) );
	memset( &stnmContato, 0, sizeof( stnmContato ) );
	memset( &stinDisponibilidade, 0, sizeof( stinDisponibilidade ) );
	memset( &stidTipoArvore, 0, sizeof( stidTipoArvore ) );
	memset( &stdsTipoArvore, 0, sizeof( stdsTipoArvore ) );
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsertCopia;
	sqlca.sqlcode = 0;
	
	if( strlennull( cidNomeContato ) <= 0 )
	{
		SetErro( "idNomeContato está nulo" );
		return 1;//Erro
	}

	//Procura pelo nome e cria um novo
	EXEC SQL
	    SELECT
		    NMCONTATO
	    INTO
		    :stnmContato
	    FROM
		    CONTATOADM.NOMECONTATO
	    WHERE
		    IDNOMECONTATO = :cAuxidNomeContato;

	if( stnmContato.len <= 0 )
	{
		SetErro( "idNomeContato não existe na tabela de nome" );
		ULOG_END("CContato::InsertCopia()");
		return 1;//Erro
	}

	//Recupera um ID unica e sequencial
	EXEC SQL 
	    SELECT 
		    CONTATOADM.NOMECONTATOSQ.NEXTVAL
	    INTO 
		    :stidNomeContato
	    FROM 
		    DUAL;
			
	//Insere o novo nome para a copia
	EXEC SQL 
	    INSERT INTO CONTATOADM.NOMECONTATO
		    ( IDNOMECONTATO
		     ,NMCONTATO
		     ,IDUSUARIOALTERACAO
		     ,DTULTIMAALTERACAO )
		    VALUES 
		    ( :stidNomeContato
		     ,TRIM(SUBSTR(:stnmContato,1,225)) || ' [Copia - ' || TO_CHAR(:stidNomeContato) || ']'
		     ,:cAuxidUser
		     ,SYSDATE );

	//Recupera um ID unica e sequencial
	EXEC SQL 
	    SELECT CONTATOADM.CONTATOSQ.NEXTVAL
	      INTO :stidContato
	      FROM DUAL;

	if(sqlca.sqlcode)
	{
		SetErro( "Erro ao tentar recuperar a seqüência CONTATOADM.CONTATOSQ.NEXTVAL" );
		ULOG_END("CContato::InsertCopia()");
		return 1;
	}

    // Se o tipo da árvore não for informado, assume árvore de contatos.
    if ( cidTipoArvore == 0 || *cidTipoArvore == 0 )
    {
        // Obtém o id do tipo da árvore de contatos
        EXEC SQL
            SELECT
                IDTIPOARVORE
            INTO
                :stidTipoArvore 
            FROM
                APOIO.TIPOARVORE
            WHERE
                DSTIPOARVORE = 'ÁRVORE DE CONTATOS';

        cAuxidTipoArvore = (char*)stidTipoArvore.arr;
    }

    // Descrição do tipo da árvore
    EXEC SQL
        SELECT
            DSTIPOARVORE
        INTO
            :stdsTipoArvore 
        FROM
            APOIO.TIPOARVORE
        WHERE
            IDTIPOARVORE = :cAuxidTipoArvore;

    // Se contato não pertencer a arvore de contatos ou se for contato de portabilidade
    // já deve nascer ativo pois não tem variáveis para associar.
    if ( stricmp((char*)stdsTipoArvore.arr,"ÁRVORE DE CONTATOS")
        || strcmp(cdsTipoProcesso,"PORTOUT") == 0 )
    {
        cAuxinDisponibilidade = "1";
    }

    ULOG("idContato=%s",(char*)stidContato.arr);
    ULOG("idTipoArvore=%s",cAuxidTipoArvore);
    ULOG("dsTipoArvore=%s",(char*)stdsTipoArvore.arr);
    ULOG("dsTipoProcesso='%s'",cdsTipoProcesso);

	//Insere um item na arvore
	EXEC SQL 
	    INSERT INTO CONTATOADM.CONTATO
		    ( IDCONTATO
		     ,IDNOMECONTATO
		     ,INDISPONIBILIDADE
             ,IDTIPOARVORE
		     ,IDUSUARIOALTERACAO
		     ,DTULTIMAALTERACAO )
		    VALUES 
		    ( :stidContato
		     ,:stidNomeContato
		     ,:cAuxinDisponibilidade
             ,:cAuxidTipoArvore
		     ,:cAuxidUser
		     ,SYSDATE );

	//Insere a hierarquia		  
	EXEC SQL
	    INSERT INTO CONTATOADM.CONTATOHIERARQUIA
		    ( IDCONTATO
		     ,IDCONTATOPAI
		     ,IDUSUARIOALTERACAO
		     ,DTULTIMAALTERACAO )
	    VALUES
		    ( :stidContato
		     ,:cAuxidContatoPai
		     ,:cAuxidUser
		     ,SYSDATE );

	//Insere primeiro, depois atualiza o path
	atualizaPath( (char*)stidContato.arr );

	Add((char*)stidContato.arr,
		cAuxidContatoPai,
		"",
		"",
		"",
		getPath(),
		0,
		0,
        "");
			
	ULOG_END("CContato::InsertCopia()");
	return 0;//Sucesso
	
GotoInsertCopia:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CContato::Update( char* cidContato,
			          char* cidNomeContato,
					  char* cnmContato,
			          char* cinDisponibilidade,
					  char* cinFolha,
					  char* cidUser )
{
    ULOG_START("CContato::Update()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR stidNomeContato[21+1];
		VARCHAR stidContatoPai[21+1];
		char* cDisponivel = "1";
		char* cNaoDisponivel = "0";
		char* cAuxidNomeContato = cidNomeContato;
		char* cAuxidContato = cidContato;
		char* cAuxnmContato = cnmContato;
		//char* cAuxinDisponibilidade = cDisponivel;//Incialmente disponivel
		char* cAuxidUser = cidUser;
		int iContagem = 0;
		int iCont = 0;
	EXEC SQL END DECLARE SECTION;
	
	ZeraContato();
	
	memset( &stidNomeContato, 0, sizeof( stidNomeContato ) );
	memset( &stidContatoPai, 0, sizeof( stidContatoPai ) );

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
	sqlca.sqlcode = 0;
	
	if( strlennull( cidNomeContato ) <= 0 )
	{
		if( strlennull( cAuxnmContato ) <= 0 )
		{
			SetErro( "Nome de contato e idNomeContato estão nulos" );
			ULOG_START("CContato::Update()");
			return 1;//Erro
		}
		//Procura por um nome
		EXEC SQL
			SELECT
				IDNOMECONTATO
			INTO
				:stidNomeContato
			FROM
				CONTATOADM.NOMECONTATO
			WHERE
				UPPER(NMCONTATO) = UPPER(:cAuxnmContato)
			AND
				ROWNUM <= 1;

		//Se nao achou o nome, entao insere
		if( stidNomeContato.len <= 0 )
		{
			//Recupera um ID unica e sequencial
			EXEC SQL 
				SELECT 
					CONTATOADM.NOMECONTATOSQ.NEXTVAL
				INTO 
					:stidNomeContato
				FROM 
					DUAL;

			if(sqlca.sqlcode)
			{
				SetErro( "Erro ao tentar recuperar a seqüência CONTATOADM.NOMECONTATOSQ.NEXTVAL" );
				ULOG_END("CContato::Update()");
				return 1;//Erro
			}
			
			//Insere um nome de contato
			EXEC SQL 
				INSERT INTO CONTATOADM.NOMECONTATO
					( IDNOMECONTATO
					 ,NMCONTATO
					 ,IDUSUARIOALTERACAO
					 ,DTULTIMAALTERACAO )
					VALUES 
					( :stidNomeContato
					 ,TRIM(SUBSTR(:cAuxnmContato,1,255))
					 ,:cAuxidUser
					 ,SYSDATE );

			if(sqlca.sqlcode)
			{
				SetErro( "Erro na inserção em CONTATOADM.NOMECONTATO" );
				ULOG_END("CContato::Update()");
				return 1;
			}
		}//if( stidNomeContato <= 0 )
		else
		{
			cidNomeContato = (char*)stidNomeContato.arr;
		}
	}//if( strlennull( cidNomeContato ) <= 0 )
	else
	{
		strcpy( (char*)stidNomeContato.arr, cidNomeContato );
		stidNomeContato.len = strlen( cidNomeContato );
	}

	//Busca o pai
	EXEC SQL
		SELECT 
			CONTATOHIERARQUIA.IDCONTATOPAI 
		INTO
			:stidContatoPai
		FROM 
			CONTATOADM.CONTATOHIERARQUIA  CONTATOHIERARQUIA
		WHERE 
			IDCONTATO = :cAuxidContato
		AND
			ROWNUM <= 1;
		
	//Verifica se existe algum nome neste nivel da arvore 
	//(uma pasta pode ser igual a uma folha, mas nao igual a outra pasta, o mesmo vale para folha)
	if(TemNomeIgualNoMesmoNivel((char*)stidContatoPai.arr, cAuxidContato, (char*)stidNomeContato.arr, cinFolha ) > 0 )
	{
		SetErro( "Não pode haver dois nomes iguais no mesmo nível" );
		ULOG_END("CContato::Update()");
		return 2;//Warning
	}

	//Altera um item da arvore
	EXEC SQL 
		UPDATE CONTATOADM.CONTATO
		   SET IDNOMECONTATO = :stidNomeContato
			  ,IDUSUARIOALTERACAO = :cAuxidUser
			  ,DTULTIMAALTERACAO = SYSDATE
		 WHERE IDCONTATO = :cAuxidContato;

	//Recupera o path depois do update, para, se houver modificacao de nome, poder
	//refletir na path
	atualizaPath( cAuxidContato );

	if(sqlca.sqlcode)
	{
		SetErro( "Falha na alteração de CONTATOADM.CONTATO" );
		ULOG_END("CContato::Update()");
		return 1;
	} 
	
    ULOG_END("CContato::Update()");
	return 0;//Sucesso
	
GotoUpdate:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}


int CContato::Delete( char* cidContato
                     ,char* cidUser )
{
	ULOG_START("CContato::Delete()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;	
		char* cAuxidContato = cidContato;
		int   iCont = 0;
	EXEC SQL END DECLARE SECTION;
	
	ZeraContato();
	
	if( strlennull( cidContato ) <= 0 )
	{
	    ULOG_END("CContato::Delete()");
		return 1;//idContato esta nulo
	}

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
	sqlca.sqlcode=0;

	//
	// idContato associado a canais.
	//
	EXEC SQL
		SELECT 
			COUNT(IDCONTATO)
		INTO
			:iCont
		FROM
			CONTATOADM.CONTATOFUNCIONALIDADE
        WHERE
            IDCONTATO = :cAuxidContato;

	if( iCont > 0 )
	{
	    ULOG_END("CContato::Delete()");
		return 4;
	}

	iCont = 0;

	//Verifica se tem algum filho
	EXEC SQL
		SELECT 
			COUNT(IDCONTATOPAI)
		INTO
			:iCont
		FROM
			CONTATOADM.CONTATOHIERARQUIA
        WHERE
            IDCONTATOPAI = :cAuxidContato;

	if( iCont > 0 )
	{
	    ULOG_END("CContato::Delete()");
		return 2;//Este item tem filhos, nao pode ser apagado
	}

	//Tenta apagar os grupos de resposta ao cliente
	EXEC SQL
		DELETE FROM
			CONTATOADM.CONTATOGRUPORC
		WHERE
			IDCONTATO = :cAuxidContato;

	//Tenta apagar os indicadores anatel
	EXEC SQL
		DELETE FROM
			CONTATOADM.INDICADORCONTATOFOLHA
		WHERE
			IDCONTATO = :cAuxidContato;

	//Tenta apagar a mensagem de aviso
	EXEC SQL
		DELETE FROM
			CONTATOADM.CONTATOFOLHAMENSAGEMAVISO
		WHERE
			IDCONTATO = :cAuxidContato;

	
	//Tenta apagar a segmentacao de fase grupo fechamento
	EXEC SQL
	DELETE FROM 
		CONTATOADM.FECHAMENTOSEGMENTACAO
	WHERE 
		IDFASEGRUPOFECHAMENTO IN 
		(
			SELECT 
				IDFASEGRUPOFECHAMENTO 
			FROM 
				CONTATOADM.FASEGRUPOFECHAMENTO 
			WHERE 
				IDCONTATO = :cAuxidContato
		);
	//Tenta apagar a tipo de linha de fase grupo fechamento
	EXEC SQL
	DELETE FROM 
		CONTATOADM.FECHAMENTOTIPOLINHA
	WHERE 
		IDFASEGRUPOFECHAMENTO IN 
		(
			SELECT 
				IDFASEGRUPOFECHAMENTO 
			FROM 
				CONTATOADM.FASEGRUPOFECHAMENTO 
			WHERE 
				IDCONTATO = :cAuxidContato
		);
	//Tenta apagar a tipo de pessoa de fase grupo fechamento
	EXEC SQL
	DELETE FROM 
		CONTATOADM.FECHAMENTOTIPOPESSOA
	WHERE 
		IDFASEGRUPOFECHAMENTO IN 
		(
			SELECT 
				IDFASEGRUPOFECHAMENTO 
			FROM 
				CONTATOADM.FASEGRUPOFECHAMENTO 
			WHERE 
				IDCONTATO = :cAuxidContato
		);
	//Tenta apagar a tipo de carteira de fase grupo fechamento
	EXEC SQL
	DELETE FROM 
		CONTATOADM.FECHAMENTOTPCARTEIRA
	WHERE 
		IDFASEGRUPOFECHAMENTO IN 
		(
			SELECT 
				IDFASEGRUPOFECHAMENTO 
			FROM 
				CONTATOADM.FASEGRUPOFECHAMENTO 
			WHERE 
				IDCONTATO = :cAuxidContato
		);
	//Tenta apagar a tipo relacionamento de fase grupo fechamento
	EXEC SQL
	DELETE FROM 
		CONTATOADM.FECHAMENTOTPRELACIONAMENTO
	WHERE 
		IDFASEGRUPOFECHAMENTO IN 
		(
			SELECT 
				IDFASEGRUPOFECHAMENTO 
			FROM 
				CONTATOADM.FASEGRUPOFECHAMENTO 
			WHERE 
				IDCONTATO = :cAuxidContato
		);
	
	//Tenta apagar a fase grupo fechamento
	EXEC SQL
		DELETE FROM
			CONTATOADM.FASEGRUPOFECHAMENTO
		WHERE
			IDCONTATO = :cAuxidContato;

	//Tenta apagar a folha
	EXEC SQL
		DELETE FROM
			CONTATOADM.CONTATOFOLHA
		WHERE
			IDCONTATO = :cAuxidContato;

	//Apaga da hieraquia
	EXEC SQL 
		DELETE FROM
			CONTATOADM.CONTATOHIERARQUIA
		WHERE 
			IDCONTATO = :cAuxidContato;
	//apaga a arvore
	EXEC SQL 
		DELETE FROM 
			CONTATOADM.CONTATO
		WHERE 
			IDCONTATO = :cAuxidContato;
			
	ULOG_END("CContato::Delete()");
	return 0;
	
GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if(sqlca.sqlcode == -2292)
		return 3;//Item nao pode ser apagafo, pois contem dependencia
	else
		throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CContato::ListContato( char* cidContato )
{
    ULOG_START("CContato::ListContato()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
		//VARCHAR stidContatoRaiz[21+1];
		//short iidContatoRaiz;
		struct
		{
			VARCHAR stidContato[21+1];
			VARCHAR stidContatoPai[21+1];
			VARCHAR stidNomeContato[21+1];
			VARCHAR stnmContato[255+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stnmPath[2000+1];
			int     iLevel;
			int     iFolha;
            VARCHAR dsTipoProcesso[256];
		} stContatoRegistro;
		struct
		{
			short iidContato;
			short iidContatoPai;
			short iidNomeContato;
			short inmContato;
			short iinDisponibilidade;
			short inmPath;
			short iLevel;
			short iFolha;
            short idsTipoProcesso;
		} stContatoIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraContato();

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListContato;

	sqlca.sqlcode=0;

	//memset( &stidContatoRaiz, 0, sizeof(stidContatoRaiz) );
    //
    // Remoção de views bzeroum - Cassio - Abril/2007
    // (contatoraiz não é usado neste ponto)
	//Recupera a raiz da arvore
	// EXEC SQL
	//	SELECT CONTATO.IDCONTATO
	//	  INTO :stidContatoRaiz:iidContatoRaiz
	//	  FROM CONTATOADM.CONTATObzeroum CONTATO
	//	 WHERE CONTATO.IDCONTATO NOT IN
	//		   (SELECT IDCONTATO
	//			  FROM CONTATOADM.CONTATOHIERARQUIA
	//			 WHERE CONTATOHIERARQUIA.IDCONTATO > 0)
	//	   AND ROWNUM <= 1;

	memset( &stContatoRegistro, 0, sizeof(stContatoRegistro) );
	memset( &stContatoIndicator, -1, sizeof(stContatoIndicator) );

	//Recupera a raiz em questao, nao necessariamente a raiz do sistema
   	EXEC SQL 
	    SELECT 
			CONTATO.IDCONTATO
	       ,CONTATOHIERARQUIA.IDCONTATOPAI
	       ,CONTATO.IDNOMECONTATO
	       ,NOMECONTATO.NMCONTATO
	       ,CONTATO.INDISPONIBILIDADE
		   ,CONTATO.NMPATH
	       ,0 AS NIVEL
	       ,0 AS FOLHA
           ,TIPOPROCESSO.DSTIPOPROCESSO
	    INTO 
			:stContatoRegistro:stContatoIndicator
		FROM 
			CONTATOADM.CONTATO CONTATO
           ,CONTATOADM.CONTATOFOLHA CONTATOFOLHA
		   ,CONTATOADM.CONTATOHIERARQUIA CONTATOHIERARQUIA
		   ,CONTATOADM.NOMECONTATO NOMECONTATO
           ,WORKFLOW.TIPOPROCESSO TIPOPROCESSO
		WHERE 
			CONTATO.IDCONTATO = :cAuxidContato
		AND CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO
		AND CONTATO.IDCONTATO = CONTATOHIERARQUIA.IDCONTATO (+)
        AND CONTATO.IDCONTATO = CONTATOFOLHA.IDCONTATO (+)
        AND CONTATOFOLHA.IDTIPOPROCESSO = TIPOPROCESSO.IDTIPOPROCESSO (+)
		AND ROWNUM < 2;

	if( strlennull( (char*)stContatoRegistro.stidContato.arr ) <= 0 )
	{
		SetErro( "ID de contato não foi encontrado na base de dados" );
		ULOG_END("CContato::ListContato()");
		return 0;
	}
	else
	{
		Add((char*)stContatoRegistro.stidContato.arr,
		    (char*)stContatoRegistro.stidContatoPai.arr,
			(char*)stContatoRegistro.stidNomeContato.arr,
			(char*)stContatoRegistro.stnmContato.arr,
			(char*)stContatoRegistro.stinDisponibilidade.arr,
			(char*)stContatoRegistro.stnmPath.arr,
			stContatoRegistro.iLevel,
			stContatoRegistro.iFolha,
            (char*)stContatoRegistro.dsTipoProcesso.arr);
		iCont++;

	}
	ULOG_END("CContato::ListContato()");
	return iCont;

GotoListContato:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}


int CContato::ListId( char* cidContato,char* cidTipoArvore )
{
	return	ListId( cidContato, "", cidTipoArvore );
}

int CContato::ListId( char* cidContato,char* cLevel,char* cidTipoArvore )
{
    ULOG_START("CContato::ListId()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
        char* cAuxidTipoArvore = cidTipoArvore;
		char  cAuxLevel[21+1];
		struct
		{
			VARCHAR stidContato[21+1];
			VARCHAR stidContatoPai[21+1];
			VARCHAR stidNomeContato[21+1];
			VARCHAR stnmContato[255+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stnmPath[2000+1];
			int     iLevel;
			int     iFolha;
		} stContatoRegistro;
		struct
		{
			short iidContato;
			short iidContatoPai;
			short iidNomeContato;
			short inmContato;
			short iinDisponibilidade;
			short inmPath;
			short iLevel;
			short iFolha;
		} stContatoIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraContato();

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
	sqlca.sqlcode=0;

	memset( &stContatoRegistro, 0, sizeof(stContatoRegistro) );
	memset( &stContatoIndicator, -1, sizeof(stContatoIndicator) );

	memset( &cAuxLevel, 0, sizeof( cAuxLevel ) );
	if( strlennull( cLevel ) <= 0 )
		strcpy( cAuxLevel, "-1" );
	else
		strcpy( cAuxLevel, cLevel );
	//Recupera a raiz em questao, nao necessariamente a raiz do sistema
    /* remoção de views bzeroum -- cassio -- jun/2007
   	EXEC SQL 
	    SELECT CONTATO.IDCONTATO
	          ,0 IDCONTATOPAI
	          ,CONTATO.IDNOMECONTATO
	          ,CONTATO.NMCONTATO
	          ,CONTATO.INDISPONIBILIDADE
			  ,CONTATO.NMPATH
	          ,0 NIVEL
	          ,0 FOLHA
	    INTO :stContatoRegistro:stContatoIndicator
		FROM CONTATOADM.CONTATObzeroum CONTATO
		WHERE IDCONTATO = :cAuxidContato;
    */

	EXEC SQL 
		SELECT
			CONTATO.IDCONTATO,
			0 AS IDCONTATOPAI,
			CONTATO.IDNOMECONTATO,
			NOMECONTATO.NMCONTATO,
			CONTATO.INDISPONIBILIDADE,
			CONTATO.NMPATH,
			0 AS NIVEL,
			0 AS FOLHA
		INTO
			:stContatoRegistro:stContatoIndicator
		FROM
			CONTATOADM.CONTATO CONTATO,
			CONTATOADM.NOMECONTATO NOMECONTATO
		WHERE
			CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO
		AND CONTATO.IDCONTATO = :cAuxidContato;

	if( strlennull( (char*)stContatoRegistro.stidContato.arr ) <= 0 )
	{
		SetErro( "ID de contato não foi encontrado na base de dados" );
		ULOG_END("CContato::ListId()");
		return 0;
	}
	else
	{
		Add((char*)stContatoRegistro.stidContato.arr,
		    (char*)stContatoRegistro.stidContatoPai.arr,
			(char*)stContatoRegistro.stidNomeContato.arr,
			(char*)stContatoRegistro.stnmContato.arr,
			(char*)stContatoRegistro.stinDisponibilidade.arr,
			(char*)stContatoRegistro.stnmPath.arr,
			stContatoRegistro.iLevel,
			stContatoRegistro.iFolha,
            "");
		iCont++;

	}
	EXEC SQL WHENEVER NOT FOUND DO break;
	//Recupera todos os itens de uma raiz
   	EXEC SQL 
   		DECLARE CursorContatoListId CURSOR FOR 
		    SELECT IDCONTATO
		          ,IDCONTATOPAI
		          ,IDNOMECONTATO
		          ,NMCONTATO
		          ,INDISPONIBILIDADE
				  ,NMPATH
		          ,NIVEL
		          ,IDCONTATOFOLHA
		    FROM (
					SELECT HIERARQUIA.IDCONTATO
				          ,HIERARQUIA.IDCONTATOPAI
				          ,HIERARQUIA.IDNOMECONTATO
				          ,HIERARQUIA.NMCONTATO
				          ,HIERARQUIA.INDISPONIBILIDADE
				          ,LEVEL NIVEL
				          ,DECODE(IDCONTATOFOLHA, NULL, 0, 1 ) IDCONTATOFOLHA
						  ,HIERARQUIA.NMPATH
				      FROM CONTATOADM.CONTATOHIERARQUIAV01 HIERARQUIA,
					  	   CONTATOADM.CONTATO CONTATO
					  WHERE HIERARQUIA.IDCONTATO = CONTATO.IDCONTATO
                      AND CONTATO.IDTIPOARVORE = :cAuxidTipoArvore
				START WITH HIERARQUIA.IDCONTATOPAI = :cAuxidContato
				CONNECT BY HIERARQUIA.IDCONTATOPAI = PRIOR HIERARQUIA.IDCONTATO
			      )
			WHERE
				NIVEL = :cAuxLevel OR :cAuxLevel = '-1';
				
	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL OPEN CursorContatoListId;

	if(sqlca.sqlcode)
	{
		SetErro( "Erro ao tentar abrir o cursor CursorContatoListId" );
		ULOG_END("CContato::ListId()");
		return 0;
	}
	else
	{
		for(;;)
		{
			memset( &stContatoRegistro, 0, sizeof(stContatoRegistro) );
			memset( &stContatoIndicator, -1, sizeof(stContatoIndicator) );

			EXEC SQL FETCH CursorContatoListId INTO :stContatoRegistro:stContatoIndicator;
			Add((char*)stContatoRegistro.stidContato.arr,
			    (char*)stContatoRegistro.stidContatoPai.arr,
				(char*)stContatoRegistro.stidNomeContato.arr,
				(char*)stContatoRegistro.stnmContato.arr,
				(char*)stContatoRegistro.stinDisponibilidade.arr,
				(char*)stContatoRegistro.stnmPath.arr,
				stContatoRegistro.iLevel,
		 	    stContatoRegistro.iFolha,
                "");
			iCont++;
		}
		EXEC SQL CLOSE CursorContatoListId;
	}
	
	if(sqlca.sqlcode)
	{
		SetErro( "Erro ao tentar fechar o cursor CursorContatoListId" );
		ULOG_END("CContato::ListId()");
		return 0;
	}
	ULOG_END("CContato::ListId()");
	return iCont;

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContato::ListAll( void )
{
    ULOG_START("CContato::ListAll( void )");
	int ret = ListAll( "",0 );
    ULOG_END("CContato::ListAll( void )");

    return ret;
}

int CContato::ListAll( char* cidContato, char* cidTipoArvore )
{
    ULOG_START("CContato::ListAll( char* cidContato, char* cidTipoArvore )");
	int iCont = 0;

	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		VARCHAR stidTipoArvore[2+1];
        char* cAuxidTipoArvore = cidTipoArvore;
        short i_stidTipoArvore;
		struct
		{
			VARCHAR stidContato[21+1];
			VARCHAR stidNomeContato[21+1];
			VARCHAR stnmContato[255+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stnmPath[2000+1];
			int     iLevel;
			VARCHAR stidContatoPai[21+1];
			int     iFolha;
            VARCHAR dsTipoProcesso[256];
		} stContatoRegistro;
		struct
		{
			short iidContato;
			short iidNomeContato;
			short inmContato;
			short iinDisponibilidade;
			short inmPath;
			short iLevel;
			short iidContatoPai;
			short iiFolha;
            short idsTipoProcesso;
		} stContatoIndicator;
		struct
		{
			VARCHAR stidContato[21+1];
			VARCHAR stidNomeContato[21+1];
			VARCHAR stnmContato[255+1];
			VARCHAR stinDisponibilidade[21+1];
		} stContatoRaiz;
		struct
		{
			short iidContato;
			short iidNomeContato;
			short inmContato;
			short iinDisponibilidade;
		} stContatoRaizIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraContato();

	memset( &stContatoRaiz, 0, sizeof( stContatoRaiz ) );
	memset( &stContatoRaizIndicator, -1, sizeof( stContatoRaizIndicator ) );
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;

    // Se o tipo da árvore não for informado, assume árvore de contatos.
    if ( cidTipoArvore == 0 || *cidTipoArvore == 0 )
    {
        // Obtém o id do tipo da árvore de contatos
        EXEC SQL
            SELECT
                IDTIPOARVORE
            INTO
                :stidTipoArvore 
            FROM
                APOIO.TIPOARVORE
            WHERE
                DSTIPOARVORE = 'ÁRVORE DE CONTATOS';

        cAuxidTipoArvore = (char*)stidTipoArvore.arr;
    }

    ULOG("idContato=%s",cidContato);
    ULOG("idTipoArvore=%s",cAuxidTipoArvore);

	sqlca.sqlcode=0;
	
	// Recupera a raiz da arvore
    //===============================================
    // Removida view bzeroum - Abr/2007 - Cassio
    //===============================================
    // EXEC SQL
    //     SELECT CONTATO.IDCONTATO,
    //            CONTATO.IDNOMECONTATO,
    //            CONTATO.NMCONTATO NMCONTATO,
    //            CONTATO.INDISPONIBILIDADE
    //       INTO :stContatoRaiz:stContatoRaizIndicator
    //       FROM CONTATOADM.CONTATObzeroum CONTATO
    //      WHERE CONTATO.IDCONTATO NOT IN
    //            (SELECT IDCONTATO
    //               FROM CONTATOADM.CONTATOHIERARQUIA
    //              WHERE CONTATOHIERARQUIA.IDCONTATO > 0)
    //        AND ROWNUM <= 1;

    EXEC SQL
		SELECT 
            CONTATO.IDCONTATO,
            CONTATO.IDNOMECONTATO,
            NOMECONTATO.NMCONTATO NMCONTATO,
            CONTATO.INDISPONIBILIDADE
        INTO 
            :stContatoRaiz:stContatoRaizIndicator
        FROM 
            CONTATOADM.CONTATO CONTATO,
            CONTATOADM.NOMECONTATO NOMECONTATO
        WHERE
            CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO 
        AND CONTATO.IDCONTATO NOT IN( SELECT
                                          CONTATOHIERARQUIA.IDCONTATO 
                                      FROM 
                                          CONTATOADM.CONTATOHIERARQUIA 
                                     )
        AND ROWNUM < 2;

	if( strlennull( cAuxidContato ) <= 0 )
	{
		Add((char*)stContatoRaiz.stidContato.arr,
			"",
			(char*)stContatoRaiz.stidNomeContato.arr,
			(char*)stContatoRaiz.stnmContato.arr,
			(char*)stContatoRaiz.stinDisponibilidade.arr,
			(char*)stContatoRaiz.stnmContato.arr,
			0,
		    0,
            "");

		cAuxidContato = (char*)stContatoRaiz.stidContato.arr;
	}
	else
	{
		Add(cAuxidContato,
			"",
			"",
			"",
			"",
			"",
			0,
		    0,
            "");
	}

	//Cursor para recuperar a arvore
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	EXEC SQL 
		DECLARE 
			CursorContatoAll CURSOR FOR
        SELECT
            IDCONTATO
           ,IDNOMECONTATO
           ,NMCONTATO
           ,INDISPONIBILIDADE
           ,NMPATH
           ,NIVEL
           ,IDCONTATOPAI
           ,IDCONTATOFOLHA
           ,DSTIPOPROCESSO
        FROM
        (
            SELECT 
                CONTATO.IDCONTATO
               ,NOMECONTATO.IDNOMECONTATO
               ,NOMECONTATO.NMCONTATO
               ,CONTATO.INDISPONIBILIDADE
               ,1 AS NIVEL
               ,HIERARQUIA.IDCONTATOPAI
               ,DECODE(CONTATOFOLHA.IDCONTATO, NULL, 0, 1) AS IDCONTATOFOLHA
               ,DECODE(CONTATOFOLHA.IDCONTATO, NULL, 1, 0) AS INFOLHA
               ,CONTATO.NMPATH
               ,TIPOPROCESSO.DSTIPOPROCESSO
            FROM
                CONTATOADM.CONTATOHIERARQUIA HIERARQUIA,
                CONTATOADM.CONTATO CONTATO,
                CONTATOADM.NOMECONTATO NOMECONTATO,
                CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
                WORKFLOW.TIPOPROCESSO TIPOPROCESSO
            WHERE
                CONTATO.IDCONTATO = HIERARQUIA.IDCONTATO
            AND CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO
            AND CONTATO.IDCONTATO = CONTATOFOLHA.IDCONTATO(+)
            AND CONTATOFOLHA.IDTIPOPROCESSO = TIPOPROCESSO.IDTIPOPROCESSO(+)
            AND CONTATO.IDTIPOARVORE = :cAuxidTipoArvore
            AND HIERARQUIA.IDCONTATOPAI = :cAuxidContato
        )
        ORDER BY 
            INFOLHA, UPPER(NMCONTATO);

	EXEC SQL OPEN CursorContatoAll;

	if(sqlca.sqlcode)
	{
	   ULOG_END("CContato::ListAll( char* cidContato, char* cidTipoArvore )");
	   return 0;
	}
	else
	{
		for(;;)
		{
			memset( &stContatoRegistro, 0, sizeof(stContatoRegistro) );
			memset( &stContatoIndicator, -1, sizeof(stContatoIndicator) );

			EXEC SQL FETCH CursorContatoAll INTO :stContatoRegistro:stContatoIndicator;

			Add((char*)stContatoRegistro.stidContato.arr,
				(char*)stContatoRegistro.stidContatoPai.arr,
				(char*)stContatoRegistro.stidNomeContato.arr,
				(char*)stContatoRegistro.stnmContato.arr,
				(char*)stContatoRegistro.stinDisponibilidade.arr,
				(char*)stContatoRegistro.stnmPath.arr,
				stContatoRegistro.iLevel,
				stContatoRegistro.iFolha,
                (char*)stContatoRegistro.dsTipoProcesso.arr);

			iCont++;
		}
		EXEC SQL CLOSE CursorContatoAll;
	}

    ULOG_END("CContato::ListAll( char* cidContato, char* cidTipoArvore )");

    return sqlca.sqlcode ? 0 : iCont;

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContato::ListAll( char* cidContato, int pageNumber, char* cidTipoArvore )
{
    ULOG_START("CContato::ListAll( char* cidContato, int pageNumber, char* cidTipoArvore )");
	int iCont = 0;
    const int tamanhoBloco = 90;

	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
        char linIni[32],linFin[32];
		VARCHAR stidTipoArvore[2+1];
        char* cAuxidTipoArvore = cidTipoArvore;
        short i_stidTipoArvore;
		struct
		{
			VARCHAR stidContato[21+1];
			VARCHAR stidNomeContato[21+1];
			VARCHAR stnmContato[255+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stnmPath[2000+1];
			int     iLevel;
			VARCHAR stidContatoPai[21+1];
			int     iFolha;
            VARCHAR dsTipoProcesso[256];
		} stContatoRegistro;
		struct
		{
			short iidContato;
			short iidNomeContato;
			short inmContato;
			short iinDisponibilidade;
			short inmPath;
			short iLevel;
			short iidContatoPai;
			short iiFolha;
            short idsTipoProcesso;
		} stContatoIndicator;
		struct
		{
			VARCHAR stidContato[21+1];
			VARCHAR stidNomeContato[21+1];
			VARCHAR stnmContato[255+1];
			VARCHAR stinDisponibilidade[21+1];
		} stContatoRaiz;
		struct
		{
			short iidContato;
			short iidNomeContato;
			short inmContato;
			short iinDisponibilidade;
		} stContatoRaizIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraContato();

    sprintf(linIni,"%d",pageNumber * tamanhoBloco + 1);
    sprintf(linFin,"%d",(pageNumber+1) * tamanhoBloco + 1); //+1 aqui é necessário para controle de fim de relatório
	
	memset( &stContatoRaiz, 0, sizeof( stContatoRaiz ) );
	memset( &stContatoRaizIndicator, -1, sizeof( stContatoRaizIndicator ) );
	memset( &stidTipoArvore, 0, sizeof( stidTipoArvore ) );
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAll2;

    // Se o tipo da árvore não for informado, assume árvore de contatos.
    if ( cidTipoArvore == 0 || *cidTipoArvore == 0 )
    {
        // Obtém o id do tipo da árvore de contatos
        EXEC SQL
            SELECT
                IDTIPOARVORE
            INTO
                :stidTipoArvore 
            FROM
                APOIO.TIPOARVORE
            WHERE
                DSTIPOARVORE = 'ÁRVORE DE CONTATOS';

        cAuxidTipoArvore = (char*)stidTipoArvore.arr;
    }

    ULOG("idContato=%s",cidContato);
    ULOG("idTipoArvore=%s",cAuxidTipoArvore);

	sqlca.sqlcode=0;
	
	// Recupera a raiz da arvore
    //===============================================
    // Removida view bzeroum - Abr/2007 - Cassio
    //===============================================
    // EXEC SQL
    //     SELECT CONTATO.IDCONTATO,
    //            CONTATO.IDNOMECONTATO,
    //            CONTATO.NMCONTATO NMCONTATO,
    //            CONTATO.INDISPONIBILIDADE
    //       INTO :stContatoRaiz:stContatoRaizIndicator
    //       FROM CONTATOADM.CONTATObzeroum CONTATO
    //      WHERE CONTATO.IDCONTATO NOT IN
    //            (SELECT IDCONTATO
    //               FROM CONTATOADM.CONTATOHIERARQUIA
    //              WHERE CONTATOHIERARQUIA.IDCONTATO > 0)
    //        AND ROWNUM <= 1;

    EXEC SQL
        SELECT 
            CONTATO.IDCONTATO,
            CONTATO.IDNOMECONTATO,
            NOMECONTATO.NMCONTATO NMCONTATO,
            CONTATO.INDISPONIBILIDADE
        INTO 
            :stContatoRaiz:stContatoRaizIndicator
        FROM 
            CONTATOADM.CONTATO CONTATO,
            CONTATOADM.NOMECONTATO NOMECONTATO
        WHERE
            CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO 
        AND CONTATO.IDCONTATO NOT IN( SELECT
                                          CONTATOHIERARQUIA.IDCONTATO 
                                      FROM 
                                          CONTATOADM.CONTATOHIERARQUIA 
                                   )
        AND ROWNUM < 2;

	if( strlennull( cAuxidContato ) <= 0 )
	{
		Add((char*)stContatoRaiz.stidContato.arr,
			"",
			(char*)stContatoRaiz.stidNomeContato.arr,
			(char*)stContatoRaiz.stnmContato.arr,
			(char*)stContatoRaiz.stinDisponibilidade.arr,
			(char*)stContatoRaiz.stnmContato.arr,
			0,
		    0,
            "");

		cAuxidContato = (char*)stContatoRaiz.stidContato.arr;
	}
	else
	{
		Add(cAuxidContato,
			"",
			"",
			"",
			"",
			"",
			0,
		    0,
            "");
	}

	//Cursor para recuperar a arvore
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	EXEC SQL 
		DECLARE 
			CursorContatoAll2 CURSOR FOR
		SELECT
			IDCONTATO,
			IDNOMECONTATO,
			NMCONTATO,
			INDISPONIBILIDADE,
			NMPATH,
			NIVEL,
			IDCONTATOPAI,
			IDCONTATOFOLHA,
            DSTIPOPROCESSO
		FROM
		(
			SELECT
				ROWNUM AS NLIN,
				IDCONTATO,
				IDNOMECONTATO,
				NMCONTATO,
				INDISPONIBILIDADE,
				NMPATH,
				NIVEL,
				IDCONTATOPAI,
				IDCONTATOFOLHA,
                DSTIPOPROCESSO
			FROM
			(
				SELECT
					IDCONTATO,
					IDNOMECONTATO,
					NMCONTATO,
					INDISPONIBILIDADE,
					NMPATH,
					NIVEL,
					IDCONTATOPAI,
					IDCONTATOFOLHA,
                    DSTIPOPROCESSO
				FROM
				(
					SELECT
						CONTATO.IDCONTATO,
						NOMECONTATO.IDNOMECONTATO,
						NOMECONTATO.NMCONTATO,
						CONTATO.INDISPONIBILIDADE,
						1 AS NIVEL,
						HIERARQUIA.IDCONTATOPAI,
						DECODE(CONTATOFOLHA.IDCONTATO, NULL, 0, 1 ) AS IDCONTATOFOLHA,
						DECODE(CONTATOFOLHA.IDCONTATO, NULL, 1, 0 ) AS INFOLHA,
						CONTATO.NMPATH,
                        TIPOPROCESSO.DSTIPOPROCESSO
					FROM
						CONTATOADM.CONTATOHIERARQUIA HIERARQUIA,
						CONTATOADM.CONTATO CONTATO,
						CONTATOADM.NOMECONTATO NOMECONTATO,
						CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
                        WORKFLOW.TIPOPROCESSO TIPOPROCESSO
					WHERE
						CONTATO.IDCONTATO = HIERARQUIA.IDCONTATO
					AND CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO
					AND CONTATO.IDCONTATO = CONTATOFOLHA.IDCONTATO(+)
                    AND CONTATOFOLHA.IDTIPOPROCESSO = TIPOPROCESSO.IDTIPOPROCESSO(+)
                    AND CONTATO.IDTIPOARVORE = :cAuxidTipoArvore
					AND HIERARQUIA.IDCONTATOPAI = :cAuxidContato
				)
				ORDER BY 
					INFOLHA, UPPER(NMCONTATO)
			)
		)
		WHERE
			NLIN >= :linIni AND NLIN <= :linFin;

	EXEC SQL OPEN CursorContatoAll2;

	if( 0 == sqlca.sqlcode )
	{
		for(;;)
		{
			memset( &stContatoRegistro, 0, sizeof(stContatoRegistro) );
			memset( &stContatoIndicator, -1, sizeof(stContatoIndicator) );

			EXEC SQL FETCH CursorContatoAll2 INTO :stContatoRegistro:stContatoIndicator;

			if ( ++iCont > tamanhoBloco ) { break; }

			Add((char*)stContatoRegistro.stidContato.arr,
				(char*)stContatoRegistro.stidContatoPai.arr,
				(char*)stContatoRegistro.stidNomeContato.arr,
				(char*)stContatoRegistro.stnmContato.arr,
				(char*)stContatoRegistro.stinDisponibilidade.arr,
				(char*)stContatoRegistro.stnmPath.arr,
				stContatoRegistro.iLevel,
				stContatoRegistro.iFolha,
                (char*)stContatoRegistro.dsTipoProcesso.arr);

                //ULOG("stidContato=%s",(char*)stContatoRegistro.stidContato.arr);
                //ULOG("dsTipoProcesso=%s",(char*)stContatoRegistro.dsTipoProcesso.arr);
		}

		EXEC SQL CLOSE CursorContatoAll2;
	}

	ULOG_END("CContato::ListAll( char* cidContato, int pageNumber, char* cidTipoArvore )");

	if( sqlca.sqlcode )
	{
		return 0;
	}

	return iCont;

GotoListAll2:
	ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

// Semelhante ao ListAll, mas filtra pelo Grupo e pelo Skill do usuário
int CContato::ListAllSkill( char* cidContato, char* cidGrupo, char* cidSkill )
{
	ULOG( "ListAllSkill::cidContato=[%s] cidGrupo=[%s] cidSkill=[%s]", cidContato, cidGrupo, cidSkill );
	if( strlennull(cidSkill) > 0 )
		return ListAllGrupoSkill( cidContato, cidSkill );
	else
		return ListAllGrupo( cidContato, cidGrupo );
}

int CContato::ListAllGrupo( char* cidContato, char* cidGrupo )
{
    ULOG_START("CContato::ListAllGrupo()");
	int iCont = 0;
	struct sqlca sqlca;

	// Parâmetros recebidos
	ULOG( "ListAllGrupo::cidContato=[%s] cidGrupo=[%s]", cidContato, cidGrupo );

	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		char* cAuxidGrupo = cidGrupo;
		struct
		{
			VARCHAR stidContato[21+1];
			VARCHAR stidNomeContato[21+1];
			VARCHAR stnmContato[255+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stnmPath[2000+1];
			int     iLevel;
			VARCHAR stidContatoPai[21+1];
			int     iFolha;
            VARCHAR dsTipoProcesso[256];
		} stContatoRegistro;
		struct
		{
			short iidContato;
			short iidNomeContato;
			short inmContato;
			short iinDisponibilidade;
			short inmPath;
			short iLevel;
			short iidContatoPai;
			short iiFolha;
            short idsTipoProcesso;
		} stContatoIndicator;
		struct
		{
			VARCHAR stidContato[21+1];
			VARCHAR stidNomeContato[21+1];
			VARCHAR stnmContato[255+1];
			VARCHAR stinDisponibilidade[21+1];
		} stContatoRaiz;
		struct
		{
			short iidContato;
			short iidNomeContato;
			short inmContato;
			short iinDisponibilidade;
		} stContatoRaizIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraContato();

	memset( &stContatoRaiz, 0, sizeof( stContatoRaiz ) );

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAllGrupo;

	sqlca.sqlcode=0;

	//Recupera a raiz da arvore
    /* remoção de views bzeroum -- cassio -- jun/2007
	EXEC SQL
		SELECT CONTATO.IDCONTATO,
			   CONTATO.IDNOMECONTATO,
			   CONTATO.NMCONTATO NMCONTATO,
			   CONTATO.INDISPONIBILIDADE
		  INTO :stContatoRaiz:stContatoRaizIndicator
		  FROM CONTATOADM.CONTATObzeroum CONTATO
		 WHERE CONTATO.IDCONTATO NOT IN
			   (SELECT IDCONTATO
				  FROM CONTATOADM.CONTATOHIERARQUIA
				 WHERE CONTATOHIERARQUIA.IDCONTATO > 0)
		   AND ROWNUM <= 1;
    */

	EXEC SQL
		SELECT CONTATO.IDCONTATO,
			   CONTATO.IDNOMECONTATO,
			   NOMECONTATO.NMCONTATO,
			   CONTATO.INDISPONIBILIDADE
		  INTO :stContatoRaiz:stContatoRaizIndicator
		  FROM CONTATOADM.CONTATO CONTATO,
			   CONTATOADM.NOMECONTATO NOMECONTATO
		 WHERE CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO 
		 AND CONTATO.IDCONTATO NOT IN
			   (SELECT CONTATOHIERARQUIA.IDCONTATO
				  FROM CONTATOADM.CONTATOHIERARQUIA)
		   AND ROWNUM < 2;

	if( strlennull( cAuxidContato ) <= 0 )
	{
		Add((char*)stContatoRaiz.stidContato.arr,
			"",
			(char*)stContatoRaiz.stidNomeContato.arr,
			(char*)stContatoRaiz.stnmContato.arr,
			(char*)stContatoRaiz.stinDisponibilidade.arr,
			(char*)stContatoRaiz.stnmContato.arr,
			0,
		    0,
            "");

		cAuxidContato = (char*)stContatoRaiz.stidContato.arr;
	}
	else
	{
		Add(cAuxidContato,
			"",
			"",
			"",
			"",
			"",
			0,
		    0,
            "");
	}

	//Cursor para recuperar a arvore
	EXEC SQL WHENEVER NOT FOUND DO break;
	
	EXEC SQL 
		DECLARE 
			CursorListAllGrupo CURSOR for
        SELECT
			IDCONTATO
		   ,IDNOMECONTATO
		   ,NMCONTATO
		   ,INDISPONIBILIDADE
		   ,NMPATH
		   ,NIVEL
           ,IDCONTATOPAI
           ,IDCONTATOFOLHA
           ,DSTIPOPROCESSO
		FROM
		(	
			SELECT DISTINCT
				CONTATO.IDCONTATO
			   ,NOMECONTATO.IDNOMECONTATO
			   ,NOMECONTATO.NMCONTATO
			   ,CONTATO.INDISPONIBILIDADE
			   ,1 AS NIVEL
	           ,HIERARQUIA.IDCONTATOPAI
	           ,DECODE(CONTATOFOLHA.IDCONTATO, NULL, 0, 1 ) IDCONTATOFOLHA
	           ,DECODE(CONTATOFOLHA.IDCONTATO, NULL, 1, 0 ) INFOLHA
			   ,CONTATO.NMPATH
               ,TIPOPROCESSO.DSTIPOPROCESSO
			FROM 
				CONTATOADM.CONTATOHIERARQUIA HIERARQUIA,
				CONTATOADM.CONTATO CONTATO,
                CONTATOADM.NOMECONTATO NOMECONTATO,
                CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
                WORKFLOW.TIPOPROCESSO TIPOPROCESSO
            WHERE
                CONTATO.IDCONTATO = HIERARQUIA.IDCONTATO
            AND CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO
            AND CONTATO.IDCONTATO = CONTATOFOLHA.IDCONTATO (+)
            AND CONTATOFOLHA.IDTIPOPROCESSO = TIPOPROCESSO.IDTIPOPROCESSO (+)
            AND HIERARQUIA.IDCONTATOPAI = :cAuxidContato
        	START WITH 
        		CONTATO.IDCONTATO = 
				(
					SELECT 
						IDCONTATO 
					FROM 
						CONTATOADM.CONTATOGRUPO CONTATOGRUPO
					WHERE 
						IDGRUPO = :cAuxidGrupo
					AND
						CONTATOGRUPO.IDCONTATO = CONTATO.IDCONTATO
					AND
						CONTATOGRUPO.IDCONTATOGRUPO = ( SELECT IDCONTATOGRUPO FROM CONTATOADM.SEQUENCIA WHERE IDCONTATOGRUPO = CONTATOGRUPO.IDCONTATOGRUPO AND IDTIPOSEQUENCIA IN ( 2, 3 ) )
                    AND
                        ROWNUM < 2
				)
            CONNECT BY 
        		PRIOR HIERARQUIA.IDCONTATOPAI = CONTATO.IDCONTATO
		)
   		ORDER BY 
            INFOLHA, UPPER(NMCONTATO);


	EXEC SQL OPEN CursorListAllGrupo;

	for(;;)
	{
		memset( &stContatoRegistro, 0, sizeof(stContatoRegistro) );
		memset( &stContatoIndicator, -1, sizeof(stContatoIndicator) );

		EXEC SQL FETCH CursorListAllGrupo INTO :stContatoRegistro:stContatoIndicator;
		Add((char*)stContatoRegistro.stidContato.arr,
			(char*)stContatoRegistro.stidContatoPai.arr,
			(char*)stContatoRegistro.stidNomeContato.arr,
			(char*)stContatoRegistro.stnmContato.arr,
			(char*)stContatoRegistro.stinDisponibilidade.arr,
			(char*)stContatoRegistro.stnmPath.arr,
			stContatoRegistro.iLevel,
			stContatoRegistro.iFolha,
            (char*)stContatoRegistro.dsTipoProcesso.arr);
		iCont++;
	}
	EXEC SQL CLOSE CursorListAllGrupo;
	
    ULOG_END("CContato::ListAllGrupo()");
    
	return iCont;

GotoListAllGrupo:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContato::ListAllGrupoSkill( char* cidContato, char* cidSkill )
{
    ULOG_START("CContato::ListAllGrupoSkill()");
	int iCont = 0;
	struct sqlca sqlca;

	// Parâmetros recebidos
	ULOG( "ListAllGrupoSkill::cidContato=[%s] cidSkill=[%s]", cidContato, cidSkill );

	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		char* cAuxidSkill = cidSkill;
		struct
		{
			VARCHAR stidContato[21+1];
			VARCHAR stidNomeContato[21+1];
			VARCHAR stnmContato[255+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stnmPath[2000+1];
			int     iLevel;
			VARCHAR stidContatoPai[21+1];
			int     iFolha;
		} stContatoRegistro;
		struct
		{
			short iidContato;
			short iidNomeContato;
			short inmContato;
			short iinDisponibilidade;
			short inmPath;
			short iLevel;
			short iidContatoPai;
			short iiFolha;
		} stContatoIndicator;
		struct
		{
			VARCHAR stidContato[21+1];
			VARCHAR stidNomeContato[21+1];
			VARCHAR stnmContato[255+1];
			VARCHAR stinDisponibilidade[21+1];
		} stContatoRaiz;
		struct
		{
			short iidContato;
			short iidNomeContato;
			short inmContato;
			short iinDisponibilidade;
		} stContatoRaizIndicator;
	EXEC SQL END DECLARE SECTION;



	ZeraContato();
	
	memset( &stContatoRaiz, 0, sizeof( stContatoRaiz ) );
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAllGrupoSkill;
	sqlca.sqlcode=0;
	
	//Recupera a raiz da arvore
	/* remoção de views bzeroum -- cassio -- jun/2007
	EXEC SQL
		SELECT CONTATO.IDCONTATO,
			   CONTATO.IDNOMECONTATO,
			   CONTATO.NMCONTATO NMCONTATO,
			   CONTATO.INDISPONIBILIDADE
		  INTO :stContatoRaiz:stContatoRaizIndicator
		  FROM CONTATOADM.CONTATObzeroum CONTATO
		 WHERE CONTATO.IDCONTATO NOT IN
			   (SELECT IDCONTATO
				  FROM CONTATOADM.CONTATOHIERARQUIA
				 WHERE CONTATOHIERARQUIA.IDCONTATO > 0)
		   AND ROWNUM <= 1;
	*/

	EXEC SQL
		SELECT
			CONTATO.IDCONTATO,
			CONTATO.IDNOMECONTATO,
			NOMECONTATO.NMCONTATO,
			CONTATO.INDISPONIBILIDADE
		INTO
			:stContatoRaiz:stContatoRaizIndicator
		FROM
			CONTATOADM.CONTATO CONTATO,
			CONTATOADM.NOMECONTATO NOMECONTATO
		WHERE
			CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO  
		AND CONTATO.IDCONTATO NOT IN (SELECT IDCONTATO
									 FROM CONTATOADM.CONTATOHIERARQUIA
									)
		AND ROWNUM < 2;

	if( strlennull( cAuxidContato ) <= 0 )
	{
		Add((char*)stContatoRaiz.stidContato.arr,
			"",
			(char*)stContatoRaiz.stidNomeContato.arr,
			(char*)stContatoRaiz.stnmContato.arr,
			(char*)stContatoRaiz.stinDisponibilidade.arr,
			(char*)stContatoRaiz.stnmContato.arr,
			0,
		    0,
            "");

		cAuxidContato = (char*)stContatoRaiz.stidContato.arr;
	}
	else
	{
		Add(cAuxidContato,
			"",
			"",
			"",
			"",
			"",
			0,
		    0,
            "");
	}

	//Cursor para recuperar a arvore
	EXEC SQL WHENEVER NOT FOUND DO break;
	
	EXEC SQL 
	DECLARE 
		CursorListAllGrupoSkill CURSOR FOR
		SELECT
			IDCONTATO
		   ,IDNOMECONTATO
		   ,NMCONTATO
		   ,INDISPONIBILIDADE
		   ,NMPATH
		   ,NIVEL
           ,IDCONTATOPAI
           ,IDCONTATOFOLHA
		FROM
		(	
			SELECT DISTINCT
				CONTATO.IDCONTATO
			   ,NOMECONTATO.IDNOMECONTATO
			   ,NOMECONTATO.NMCONTATO
			   ,CONTATO.INDISPONIBILIDADE
			   ,1 NIVEL
	           ,HIERARQUIA.IDCONTATOPAI
	           ,DECODE(CONTATOFOLHA.IDCONTATO, NULL, 0, 1 ) IDCONTATOFOLHA
	           ,DECODE(CONTATOFOLHA.IDCONTATO, NULL, 1, 0 ) INFOLHA
			   ,CONTATO.NMPATH
			FROM 
			CONTATOADM.CONTATOHIERARQUIA HIERARQUIA,
			CONTATOADM.CONTATO CONTATO,
            CONTATOADM.NOMECONTATO NOMECONTATO,
            CONTATOADM.CONTATOFOLHA CONTATOFOLHA
            WHERE
                CONTATO.IDCONTATO = HIERARQUIA.IDCONTATO
            AND
                CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO
            AND
                CONTATO.IDCONTATO = CONTATOFOLHA.IDCONTATO (+)
            AND
                HIERARQUIA.IDCONTATOPAI = :cAuxidContato
        	START WITH 
    		CONTATO.IDCONTATO = 
                (
                    SELECT 
                        IDCONTATO 
                    FROM 
                        CONTATOADM.CONTATOGRUPO CONTATOGRUPO
                    WHERE 
                        IDGRUPO = ( SELECT IDGRUPO FROM ACESSO.GRUPOSKILL WHERE IDGRUPOSKILL = :cAuxidSkill )
					AND
				    	CONTATOGRUPO.IDCONTATO = CONTATO.IDCONTATO
					AND
						CONTATOGRUPO.IDCONTATOGRUPO = ( SELECT IDCONTATOGRUPO FROM CONTATOADM.SEQUENCIA WHERE IDCONTATOGRUPO = CONTATOGRUPO.IDCONTATOGRUPO AND IDTIPOSEQUENCIA IN ( 2, 3 ) )
                    AND
                        ROWNUM < 2
                INTERSECT
                    SELECT 
                        IDCONTATO 
                    FROM 
                    	CONTATOADM.CONTATOTIPOCARTEIRA CONTATOTIPOCARTEIRA
                    WHERE 
                    	CONTATOTIPOCARTEIRA.IDCONTATO = CONTATO.IDCONTATO
                    AND
                    	CONTATOTIPOCARTEIRA.IDTIPOCARTEIRA = ( SELECT IDTIPOCARTEIRA FROM ACESSO.TIPOCARTEIRAGRUPOSKILL WHERE TIPOCARTEIRAGRUPOSKILL.IDGRUPOSKILL = :cAuxidSkill AND TIPOCARTEIRAGRUPOSKILL.IDTIPOCARTEIRA = CONTATOTIPOCARTEIRA.IDTIPOCARTEIRA )
                    AND
                        ROWNUM < 2
                INTERSECT
                    SELECT 
                        IDCONTATO 
                    FROM 
                    	CONTATOADM.CONTATOTIPOLINHA CONTATOTIPOLINHA
                    WHERE 
                    	CONTATOTIPOLINHA.IDCONTATO = CONTATO.IDCONTATO
                    AND
                    	CONTATOTIPOLINHA.IDTIPOLINHA = ( SELECT IDTIPOLINHA FROM ACESSO.TIPOLINHAGRUPOSKILL WHERE TIPOLINHAGRUPOSKILL.IDGRUPOSKILL = :cAuxidSkill AND TIPOLINHAGRUPOSKILL.IDTIPOLINHA = CONTATOTIPOLINHA.IDTIPOLINHA)
                    AND
                        ROWNUM < 2
                INTERSECT
                    SELECT 
                        IDCONTATO 
                    FROM 
                    	CONTATOADM.CONTATOTIPORELACIONAMENTO CONTATOTIPORELACIONAMENTO
                    WHERE 
                    	CONTATOTIPORELACIONAMENTO.IDCONTATO = CONTATO.IDCONTATO
                    AND
				    	CONTATOTIPORELACIONAMENTO.IDTIPORELACIONAMENTO = ( SELECT IDTIPORELACIONAMENTO FROM ACESSO.TPRELACIONAMENTOGRUPOSKILL WHERE TPRELACIONAMENTOGRUPOSKILL.IDGRUPOSKILL = :cAuxidSkill AND TPRELACIONAMENTOGRUPOSKILL.IDTIPORELACIONAMENTO = CONTATOTIPORELACIONAMENTO.IDTIPORELACIONAMENTO)
                    AND
                        ROWNUM < 2
                INTERSECT
                    SELECT 
                        IDCONTATO 
                    FROM 
                    	CONTATOADM.CONTATOSEGMENTACAO CONTATOSEGMENTACAO
                    WHERE 
                    	CONTATOSEGMENTACAO.IDCONTATO = CONTATO.IDCONTATO
                    AND
                    	CONTATOSEGMENTACAO.IDSEGMENTACAO = ( SELECT IDSEGMENTACAO FROM ACESSO.SEGMENTACAOGRUPOSKILL WHERE SEGMENTACAOGRUPOSKILL.IDGRUPOSKILL = :cAuxidSkill AND SEGMENTACAOGRUPOSKILL.IDSEGMENTACAO = CONTATOSEGMENTACAO.IDSEGMENTACAO)
                INTERSECT
                    SELECT 
                        IDCONTATO 
                    FROM 
                    	CONTATOADM.CONTATOUFOPERADORA CONTATOUFOPERADORA
                    WHERE 
                    	CONTATOUFOPERADORA.IDCONTATO = CONTATO.IDCONTATO
                    AND
                    	CONTATOUFOPERADORA.IDUFOPERADORA = ( SELECT IDUFOPERADORA FROM ACESSO.UFOPERADORAGRUPOSKILL WHERE UFOPERADORAGRUPOSKILL.IDGRUPOSKILL = :cAuxidSkill AND UFOPERADORAGRUPOSKILL.IDUFOPERADORA = CONTATOUFOPERADORA.IDUFOPERADORA )
                    AND
                        ROWNUM < 2
                )
            CONNECT BY 
        		PRIOR HIERARQUIA.IDCONTATOPAI = CONTATO.IDCONTATO
		)
   		ORDER BY 
            INFOLHA, UPPER(NMCONTATO);


	EXEC SQL OPEN CursorListAllGrupoSkill;

	for(;;)
	{
		memset( &stContatoRegistro, 0, sizeof(stContatoRegistro) );
		memset( &stContatoIndicator, -1, sizeof(stContatoIndicator) );

		EXEC SQL FETCH CursorListAllGrupoSkill INTO :stContatoRegistro:stContatoIndicator;
		Add((char*)stContatoRegistro.stidContato.arr,
			(char*)stContatoRegistro.stidContatoPai.arr,
			(char*)stContatoRegistro.stidNomeContato.arr,
			(char*)stContatoRegistro.stnmContato.arr,
			(char*)stContatoRegistro.stinDisponibilidade.arr,
			(char*)stContatoRegistro.stnmPath.arr,
			stContatoRegistro.iLevel,
			stContatoRegistro.iFolha,
            "");
		iCont++;
	}
	EXEC SQL CLOSE CursorListAllGrupoSkill;

    ULOG_END("CContato::ListAllGrupoSkill()");
	return iCont;

GotoListAllGrupoSkill:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}


int CContato::ListFiltro( char* cidGrupo
		                 ,char* cidUFOperadora
		                 ,char* cidTipoLinha
		                 ,char* cidTipoCarteira
		                 ,char* cidSegmentacao )
{
    ULOG_START("CContato::ListFiltro()");
	int iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidGrupo = cidGrupo;
		char* cAuxidUFOperadora = cidUFOperadora;
		char  cAuxidTipoLinha[21+1];
		char  cAuxidTipoCarteira[21+1];
		char  cAuxidSegmentacao[21+1];
		VARCHAR stidContato[21+1];
	EXEC SQL END DECLARE SECTION;
	
	if( strlennull( cidGrupo ) <= 0 )
	{
		SetErro( "idGrupo está nulo" );
		ULOG_END("CContato::ListFiltro()");
		return 0;
	}
	if( strlennull( cidUFOperadora ) <= 0 )
	{
		SetErro( "idUFOperadora está nulo" );
		ULOG_END("CContato::ListFiltro()");
		return 0;
	}
	memset( &cAuxidTipoLinha, 0, sizeof( cAuxidTipoLinha ) );
	memset( &cAuxidTipoCarteira, 0, sizeof( cAuxidTipoCarteira ) );
	memset( &cAuxidSegmentacao, 0, sizeof( cAuxidSegmentacao ) );
 	if( strlennull( cidTipoLinha ) <= 0 )
		strcpy( cAuxidTipoLinha, "-1" );
	else
		strcpy( cAuxidTipoLinha, cidTipoLinha );

	if( strlennull( cidTipoCarteira ) <= 0 )
		strcpy( cAuxidTipoCarteira, "-1" );
	else
		strcpy( cAuxidTipoCarteira, cidTipoCarteira );

	if( strlennull( cidSegmentacao ) <= 0 )
		strcpy( cAuxidSegmentacao, "-1" );
	else
		strcpy( cAuxidSegmentacao, cidSegmentacao );

	ZeraContato();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListFiltro;
	sqlca.sqlcode=0;
	
	EXEC SQL 
		DECLARE 
			CursorListFiltro CURSOR FOR
		SELECT 
			CONTATO.IDCONTATO
		FROM 
   			CONTATOADM.CONTATOFILTROV01 CONTATO
   		WHERE
   			CONTATO.IDGRUPO = :cAuxidGrupo
   		AND
   			CONTATO.IDUFOPERADORA = :cAuxidUFOperadora
   		AND
   			( CONTATO.IDTIPOLINHA = :cAuxidTipoLinha OR :cAuxidTipoLinha = '-1' )
   		AND
   			( CONTATO.IDTIPOCARTEIRA = :cAuxidTipoCarteira OR :cAuxidTipoCarteira = '-1' )
   		AND
   			( CONTATO.IDSEGMENTACAO = :cAuxidSegmentacao OR :cAuxidSegmentacao = '-1' );

	EXEC SQL OPEN CursorListFiltro;

	if(sqlca.sqlcode)
	{
	    ULOG_END("CContato::ListFiltro()");
		return 0;
	}
	else
	{
		for(;;)
		{
			memset( &stidContato, 0, sizeof(stidContato) );
			EXEC SQL FETCH CursorListFiltro INTO :stidContato;
			Add((char*)stidContato.arr,
				"",
				"",
				"",
				"",
				"",
				0,
		        0,
                "");
			iCont++;
		}
		EXEC SQL CLOSE CursorListFiltro;
	}
	
    ULOG_END("CContato::ListFiltro()");
	if(sqlca.sqlcode)
		return 0;
	else
		return 1;

GotoListFiltro:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}


int CContato::TemFolha( char* cidContato )
{
    ULOG_START("CContato::TemFolha()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		int iCont = 0;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoFolha;
	sqlca.sqlcode=0;
	
	//Recupera a raiz da arvore
	EXEC SQL
		SELECT 
			COUNT( IDCONTATO )
		INTO
			:iCont
		FROM
			CONTATOADM.CONTATOFOLHA
		WHERE
			IDCONTATO = :cAuxidContato;
    ULOG_END("CContato::TemFolha()");
	if(sqlca.sqlcode)
		return 0;
	else
		return ( iCont <= 0 ? 0 : 1 );

GotoFolha:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CContato::GetXml( char* cNomeTag, XMLGen*xml )
{
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{ 
				xml->addItem("idContato", Registro(x)->cidContato );
				xml->addItem("idNomeContato", Registro(x)->cidNomeContato );
				xml->addItem("nmContato", Registro(x)->cnmContato );
				xml->addItem("inDisponibilidade", Registro(x)->cinDisponibilidade ); 
				xml->addItem("dsPath", Registro(x)->cdsPath ); 
				xml->addItem("inFolha", ( Registro(x)->iFolha ? 1 : 0 ) ); 
			}
			xml->closeTag();
		}
	}
}

int CContato::ContidoNoFiltro( char* cidContato )
{
	int iCont;
	int iRet = 0;
	for( iCont=0; iCont < Quantidade(); iCont++ )
	{
		if( strcmp( Registro(iCont)->cidContato, cidContato ) == 0 )
		{
			iRet++;
			break;
		}
	}
	return iRet;
}

char* CContato::getPath( char* cidContato, char* cidContatoPai )
{
    ULOG_START("CContato::getPath()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
		char* cAuxidContatoPai = cidContatoPai; 
		VARCHAR stPath[2048+1];
		VARCHAR stRaiz[255+1];
		short iPath;
		short iRaiz;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotogetPath;
	sqlca.sqlcode=0;

	memset( &stRaiz, 0, sizeof(stRaiz) );

	/* remoção de views bzeroum -- cassio -- jun/2007
	EXEC SQL
		SELECT
			NMCONTATO
		INTO
			:stRaiz:iRaiz
		FROM
			CONTATOADM.CONTATObzeroum
		WHERE
			IDCONTATO = :cAuxidContatoPai
		AND
			ROWNUM <= 1;
    */

	EXEC SQL
		SELECT
			NOMECONTATO.NMCONTATO
		INTO
			:stRaiz:iRaiz
		FROM
			CONTATOADM.CONTATO CONTATO,
			CONTATOADM.NOMECONTATO NOMECONTATO
		WHERE
			CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO  
		AND CONTATO.IDCONTATO = :cAuxidContatoPai
		AND ROWNUM < 2;

    memset( &stPath, 0, sizeof(stPath) );

	//Recupera a raiz em questao, nao necessariamente a raiz do sistema
   	EXEC SQL 
		SELECT 
		    PATH
		INTO
			:stPath:iPath
		FROM (
		         SELECT 
		              IDCONTATO
		             ,SYS_CONNECT_BY_PATH(REPLACE(NMCONTATO, '/', '\' ), '/') PATH
		         FROM 
		         (
		              SELECT DISTINCT 
		                  IDCONTATO,
		                  IDCONTATOPAI,
		                  NMCONTATO
		              FROM 
		              (    
		                SELECT 
		                  IDCONTATO,
		                  IDCONTATOPAI,
		                  NMCONTATO
		               FROM 
		                  CONTATOADM.CONTATOHIERARQUIAV01 HIERARQUIA
		               START WITH 
		                  HIERARQUIA.IDCONTATO = :cAuxidContato
		               CONNECT BY PRIOR 
		                  HIERARQUIA.IDCONTATOPAI = HIERARQUIA.IDCONTATO
		              )
		         )
		         START WITH 
		             IDCONTATOPAI = :cAuxidContatoPai
		         CONNECT BY 
		             IDCONTATOPAI = PRIOR IDCONTATO
		) 
		WHERE 
		    IDCONTATO = :cAuxidContato
		AND
			ROWNUM <= 1;
		    
	memset( pzcPath, 0, sizeof( pzcPath ) );
	if( stRaiz.len > 0 )
		sprintf( pzcPath, "%s%s", (char*)stRaiz.arr, (char*)stPath.arr );
	else if( stPath.len > 0 )
		sprintf( pzcPath, "%s", (char*)stPath.arr );
		
	ULOG_END("CContato::getPath()");
	
	return pzcPath;

GotogetPath:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

char* CContato::getPath( char* cidContato )
{
    ULOG_START("CContato::getPath()");
    
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
		VARCHAR stidContatoPai[21+1];
		VARCHAR stPath[2048+1];
		VARCHAR stRaiz[255+1];
		short iPath;
		short iRaiz;
		short iidContatoPai;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotogetPath2;
	sqlca.sqlcode=0;

	memset( &stRaiz, 0, sizeof(stRaiz) );
	memset( &stidContatoPai, 0, sizeof(stidContatoPai) );

	EXEC SQL
		SELECT
			CONTATO.IDCONTATO,
			NOMECONTATO.NMCONTATO
		INTO
			:stidContatoPai:iidContatoPai,
			:stRaiz:iRaiz
		FROM
			CONTATOADM.CONTATO CONTATO,
			CONTATOADM.CONTATOHIERARQUIA CONTATOHIERARQUIA,
			CONTATOADM.NOMECONTATO NOMECONTATO
		WHERE
			CONTATO.IDCONTATO = CONTATOHIERARQUIA.IDCONTATO (+)
		AND
			CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO
		AND
			CONTATOHIERARQUIA.IDCONTATO IS NULL
		AND
			ROWNUM <= 1;

	memset( &stPath, 0, sizeof(stPath) );
	//Recupera a raiz em questao, nao necessariamente a raiz do sistema
   	EXEC SQL 
		SELECT 
		    PATH
		INTO
			:stPath:iPath
		FROM (
		         SELECT 
		              IDCONTATO
		             ,SYS_CONNECT_BY_PATH(REPLACE(NMCONTATO, '/', '\' ), '/') PATH
		         FROM 
		         (
		              SELECT DISTINCT 
		                  IDCONTATO,
		                  IDCONTATOPAI,
		                  NMCONTATO
		              FROM 
		              (    
		                SELECT 
		                  IDCONTATO,
		                  IDCONTATOPAI,
		                  NMCONTATO
		               FROM 
		                  CONTATOADM.CONTATOHIERARQUIAV01 HIERARQUIA
		               START WITH 
		                  HIERARQUIA.IDCONTATO = :cAuxidContato
		               CONNECT BY PRIOR 
		                  HIERARQUIA.IDCONTATOPAI = HIERARQUIA.IDCONTATO
		              )
		         )
		         START WITH 
		             IDCONTATOPAI = :stidContatoPai
		         CONNECT BY 
		             IDCONTATOPAI = PRIOR IDCONTATO
		) 
		WHERE 
		    IDCONTATO = :cAuxidContato
		AND
			ROWNUM <= 1;
		    
	memset( pzcPath, 0, sizeof( pzcPath ) );
	if( stRaiz.len > 0 )
		sprintf( pzcPath, "%s%s", (char*)stRaiz.arr, (char*)stPath.arr );
	else if( stPath.len > 0 )
		sprintf( pzcPath, "%s", (char*)stPath.arr );
		
	ULOG_END("CContato::getPath()");
	return pzcPath;

GotogetPath2:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

void CContato::atualizaPath( char* cidContato )
{
    ULOG_START("CContato::atualizaPath()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
		char* cnmPath;
		VARCHAR stnmPathOld[2048];
		short   inmPathOld;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoatualizaPath;
	sqlca.sqlcode=0;

	memset( &stnmPathOld, 0, sizeof( stnmPathOld ) );

	//Recupera o path atual, antes de atualizar
	EXEC SQL
	SELECT
		NMPATH
	INTO
		:stnmPathOld:inmPathOld
	FROM
		CONTATOADM.CONTATO
	WHERE
		IDCONTATO = :cAuxidContato;

	//Monta o novo path
	cnmPath = getPath( cidContato );

	//Atualiza o path, nao da pra inserir direto, porque soh da pra fazer o path depois
	//que o campo for inserido (não precisa alterar a data+usuário pois esta chamada ocorre
    //logo a seguir a um insert na mesma tabela)
	EXEC SQL 
	    UPDATE 
		    CONTATOADM.CONTATO
	    SET 
		    NMPATH = :cnmPath
	    WHERE 
		    IDCONTATO = :cAuxidContato;

	//Atualiza o path de todos os filhos
	EXEC SQL
	UPDATE 
		CONTATOADM.CONTATO
	SET 
		NMPATH = :cnmPath || SUBSTR( NMPATH, LENGTH( :stnmPathOld )+1, LENGTH( NMPATH ) ),
        DTULTIMAALTERACAO = SYSDATE
	WHERE
		IDCONTATO IN 
		( 
			SELECT 
				CONTATOOLD.IDCONTATO 
			FROM 
				CONTATOADM.CONTATO CONTATOOLD,
				CONTATOADM.CONTATOHIERARQUIA CONTATOHIERARQUIA
			WHERE
				CONTATOOLD.IDCONTATO = CONTATOHIERARQUIA.IDCONTATO
			START WITH 
				CONTATOHIERARQUIA.IDCONTATOPAI = :cAuxidContato
			CONNECT BY
				CONTATOHIERARQUIA.IDCONTATOPAI = PRIOR CONTATOOLD.IDCONTATO
		);

    ULOG_END("CContato::atualizaPath()");
	return;

GotoatualizaPath:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContato::ativaInativaArvore( char* cidContato, char *cidUser, char* cinHabilitado )
{
    ULOG_START("CContato::ativaInativaArvore()");
	sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char*   cAuxidContato = cidContato;
        char*   cAuxidUser = cidUser;
		VARCHAR stidContato[21+1];
		short   iidContato;
		int     iCont = 0;
		char    cAuxinHabilitado[2];
	EXEC SQL END DECLARE SECTION;

	if( strlennull( cidContato ) <= 0 )
	{
	    ULOG_END("CContato::ativaInativaArvore()return 1;"); //Sem idContato nao se faz nada
		return 1;//Sem idContato nao se faz nada
	}
	
	cAuxinHabilitado[1] = 0;
	if( strcmp( cinHabilitado, "0" ) == 0 )
		cAuxinHabilitado[0] = '0';
	else
		cAuxinHabilitado[0] = '1';
	
	sqlca.sqlcode=0;
	EXEC SQL WHENEVER SQLERROR GOTO GotoativaInativaArvore;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
		SELECT 
			COUNT(IDCONTATO)
		INTO
			:iCont
		FROM
			CONTATOADM.CONTATO CONTATO
		WHERE
			CONTATO.IDCONTATO = :cAuxidContato;

	if( iCont == 0 )
	{
	    ULOG_END("CContato::ativaInativaArvore()return 2;//Nao se pode atualizar um contato que nao existe");
		return 2;//Nao se pode atualizar um contato que nao existe
	}

	EXEC SQL
		SELECT 
			COUNT(IDCONTATO)
		INTO
			:iCont
		FROM
			CONTATOADM.CONTATOHIERARQUIA CONTATOHIERARQUIA
		WHERE
			CONTATOHIERARQUIA.IDCONTATO = :cAuxidContato;

	if( iCont == 0 )
	{
	    ULOG_END("CContato::ativaInativaArvore() return 3;//Nao se pode atualizar a raiz, senao desabilita/habilita toda a arvore");
		return 3;//Nao se pode atualizar a raiz, senao desabilita/habilita toda a arvore
	}

	//Altera o item passado como parametro
	EXEC SQL
		UPDATE 
			CONTATOADM.CONTATO
		SET 
			INDISPONIBILIDADE = :cAuxinHabilitado,
            DTULTIMAALTERACAO = SYSDATE,
            IDUSUARIOALTERACAO = :cAuxidUser
		WHERE 
			IDCONTATO = :cAuxidContato;

    // 
    // Alteração executada a pedido do Analista Funcional Tiago C. Nascimento
    // Habilitação/Desabilitação não afeta os filhos do nó.
    // Cassio - Out/2007
    //
	// EXEC SQL WHENEVER NOT FOUND DO break;

	//Cursor para recuperar a arvore
	// EXEC SQL 
	// 	DECLARE 
	// 		CursorativaInativaArvore CURSOR FOR
	// 	SELECT 
	// 		HIERARQUIA.IDCONTATO
	// 	FROM 
	// 		CONTATOADM.CONTATOHIERARQUIAV01 HIERARQUIA
	// 	START WITH
	// 		HIERARQUIA.IDCONTATOPAI = :cAuxidContato
	// 	CONNECT BY
	// 		HIERARQUIA.IDCONTATOPAI = PRIOR HIERARQUIA.IDCONTATO;

	// EXEC SQL OPEN CursorativaInativaArvore;
	
	// //Desabilita todos os filhos do contato (se existirem)
	// for(;;)
	// {
	// 	EXEC SQL WHENEVER NOT FOUND DO break;
	// 	memset( &stidContato, 0, sizeof( stidContato ) );
	// 	EXEC SQL FETCH CursorativaInativaArvore INTO :stidContato:iidContato;
    // 
	// 	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	// 	EXEC SQL
	// 		UPDATE 
	// 			CONTATOADM.CONTATO
	// 		SET 
	// 			INDISPONIBILIDADE = :cAuxinHabilitado
	// 		WHERE 
	// 			IDCONTATO = :stidContato;
	// }
    // 
	// EXEC SQL CLOSE CursorativaInativaArvore;

	//Verifica nomes que nao estao sendo utilizados para apaga-los
	ApagaNomesNaoUtilizados();
	
	ULOG_END("CContato::ativaInativaArvore()");

	return 0;//Sucesso

GotoativaInativaArvore:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}


int CContato::ListAllFiltrado( char* cidContato, 
                               CSafePointer* osfidTipoRelacionamento,
                               CSafePointer* osfidSegmentacao,
                               CSafePointer* osfidTipoCarteira,
                               CSafePointer* osfidGrupoAbertura,
                               CSafePointer* osfidGrupoTratamento,
                               CSafePointer* osfidGrupoRetorno,
                               CSafePointer* osfidTipoLinha,
                               CSafePointer* osfidFechamento,
                               CSafePointer* osfidDisponivel,
                               CSafePointer* osfidOperadora,
                               char* cdtInicio,
                               char* cdtFim )
{
    ULOG_START("CContato::ListAllFiltrado)");
	int iCont = 0;
	bool lInc_AND = false ;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		int  iTemDataInicioFim = 0;
		char cPesquisa[10000];
		char* cAuxidContato = cidContato;
		char pzidTipoRelacionamento[21+1];
		char pzidSegmentacao[21+1];
		char pzidTipoCarteira[21+1];
		char pzidGrupoAbertura[21+1];
		char pzidGrupoTratamento[21+1];
		char pzidGrupoRetorno[21+1];
		char pzidTipoLinha[21+1];
		char pzidFechamento[21+1];
		char pzidDisponivel[21+1];
		char pzidOperadora[21+1];
		char pzdtInicio[21+1];
		char pzdtFim[21+1];
		struct
		{
			VARCHAR stidContato[21+1];
			VARCHAR stidNomeContato[21+1];
			VARCHAR stnmContato[255+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stnmPath[2000+1];
			int     iLevel;
			VARCHAR stidContatoPai[21+1];
			int     iFolha;
		} stContatoRegistro;
		struct
		{
			short iidContato;
			short iidNomeContato;
			short inmContato;
			short iinDisponibilidade;
			short inmPath;
			short iLevel;
			short iidContatoPai;
			short iiFolha;
		} stContatoIndicator;
		struct
		{
			VARCHAR stidContato[21+1];
			VARCHAR stidNomeContato[21+1];
			VARCHAR stnmContato[255+1];
			VARCHAR stinDisponibilidade[21+1];
		} stContatoRaiz;
		struct
		{
			short iidContato;
			short iidNomeContato;
			short inmContato;
			short iinDisponibilidade;
		} stContatoRaizIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraContato();
	
	memset( &stContatoRaiz, 0, sizeof( stContatoRaiz ) );
	memset( &pzdtInicio, 0, sizeof( pzdtInicio ) );
	memset( &pzdtFim, 0, sizeof( pzdtFim ) );
	
    if( osfidTipoRelacionamento->getQuantidade() <= 0 )
    	strcpy( pzidTipoRelacionamento, "-1" );
	else
    	strcpy( pzidTipoRelacionamento, "1" );
    if( osfidSegmentacao->getQuantidade() <= 0 )
    	strcpy( pzidSegmentacao, "-1" );
	else
    	strcpy( pzidSegmentacao, "1" );
    if( osfidTipoCarteira->getQuantidade() <= 0 )
    	strcpy( pzidTipoCarteira, "-1" );
	else
    	strcpy( pzidTipoCarteira, "1" );
    if( osfidGrupoAbertura->getQuantidade() <= 0 )
    	strcpy( pzidGrupoAbertura, "-1" );
	else
    	strcpy( pzidGrupoAbertura, "1" );
    if( osfidGrupoTratamento->getQuantidade() <= 0 )
    	strcpy( pzidGrupoTratamento, "-1" );
	else
    	strcpy( pzidGrupoTratamento, "1" );
    if( osfidGrupoRetorno->getQuantidade() <= 0 )
    	strcpy( pzidGrupoRetorno, "-1" );
	else
    	strcpy( pzidGrupoRetorno, "1" );
    if( osfidTipoLinha->getQuantidade() <= 0 )
    	strcpy( pzidTipoLinha, "-1" );
	else
    	strcpy( pzidTipoLinha, "1" );
    if( osfidFechamento->getQuantidade() <= 0 )
		strcpy( pzidFechamento, "-1" );
    else
    	strcpy( pzidFechamento, "1" );
    //osfidDisponivel->getQuantidade() pode ser:
    // 0 - Ambos
    // 1 - Sim ou Nao
	// 2 - Ambos
    if( osfidDisponivel->getQuantidade() > 0 )
	{
    	if( osfidDisponivel->getQuantidade() == 1 )
			strcpy( pzidDisponivel, osfidDisponivel->getTag(0) );//Pode ser sim ou nao
		else
			strcpy( pzidDisponivel, "-1" );//Ambos
	}
    else
    	strcpy( pzidDisponivel, "-1" ); //Ambos
    if( osfidOperadora->getQuantidade() <= 0 )
    	strcpy( pzidOperadora, "-1" );
    else
    	strcpy( pzidOperadora, "1" );
    if( strlennull( cdtInicio ) >= 10 )
    	strDateToYYYYMMDD( pzdtInicio, cdtInicio );//Converte DD/MM/YYYY para YYYYMMDD
    else
    	strcpy( pzdtInicio, "-1" );
    if( strlennull( cdtFim ) >= 10 )
    	strDateToYYYYMMDD( pzdtFim, cdtFim );//Converte DD/MM/YYYY para YYYYMMDD
    else
    	strcpy( pzdtFim, "-1" );
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAllFiltrado3;
	sqlca.sqlcode=0;
	
	//Recupera a raiz da arvore
	/* remoção de views bzeroum -- cassio -- jun/2007
	EXEC SQL
		SELECT CONTATO.IDCONTATO,
			   CONTATO.IDNOMECONTATO,
			   CONTATO.NMCONTATO NMCONTATO,
			   CONTATO.INDISPONIBILIDADE
		  INTO :stContatoRaiz:stContatoRaizIndicator
		  FROM CONTATOADM.CONTATObzeroum CONTATO
		 WHERE CONTATO.IDCONTATO NOT IN
			   (SELECT IDCONTATO
				  FROM CONTATOADM.CONTATOHIERARQUIA
				 WHERE CONTATOHIERARQUIA.IDCONTATO > 0)
		   AND ROWNUM <= 1;
    */

	EXEC SQL
		SELECT
			CONTATO.IDCONTATO,
			CONTATO.IDNOMECONTATO,
			NOMECONTATO.NMCONTATO,
			CONTATO.INDISPONIBILIDADE
		INTO
			:stContatoRaiz:stContatoRaizIndicator
		FROM
			CONTATOADM.CONTATO CONTATO,
			CONTATOADM.NOMECONTATO NOMECONTATO
		WHERE 
			CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO  
		AND CONTATO.IDCONTATO NOT IN (SELECT CONTATOHIERARQUIA.IDCONTATO
										FROM CONTATOADM.CONTATOHIERARQUIA
									  )
		AND ROWNUM < 2;

	if( strlennull( cAuxidContato ) <= 0 )
	{
		Add((char*)stContatoRaiz.stidContato.arr,
			"",
			(char*)stContatoRaiz.stidNomeContato.arr,
			(char*)stContatoRaiz.stnmContato.arr,
			(char*)stContatoRaiz.stinDisponibilidade.arr,
			(char*)stContatoRaiz.stnmContato.arr,
			0,
		    0,
            "");

		cAuxidContato = (char*)stContatoRaiz.stidContato.arr;
	}
	else
	{
		Add(cAuxidContato,
			"",
			"",
			"",
			"",
			"",
			0,
		    0,
            "");
	}


	//Cursor para recuperar a arvore
	EXEC SQL WHENEVER NOT FOUND DO break;
	
	memset( cPesquisa, 0, sizeof( cPesquisa ) );
/*
	strcpy( cPesquisa, 
	"SELECT " 
	   " IDCONTATO" 
	   ",IDNOMECONTATO" 
	   ",NMCONTATO" 
	   ",INDISPONIBILIDADE" 
	   ",NMPATH" 
	   ",NIVEL" 
	   ",IDCONTATOPAI" 
	   ",INFOLHA"
	" FROM " 
	"( "
		"SELECT DISTINCT" 
		   " CONTATO.IDCONTATO" 
		   ",CONTATO.IDNOMECONTATO" 
		   ",NOMECONTATO.NMCONTATO" 
		   ",CONTATO.INDISPONIBILIDADE" 
		   ",CONTATO.NMPATH" 
		   ",1 NIVEL" 
		   ",CONTATOHIERARQUIA.IDCONTATOPAI" 
		   ",DECODE(CONTATOFOLHA.IDCONTATO, NULL, 1, 0) INFOLHAORDENADA"
		   ",DECODE(CONTATOFOLHA.IDCONTATO, NULL, 0, 1) INFOLHA"
		" FROM " 
			"  CONTATOADM.CONTATO CONTATO"
		    " ,CONTATOADM.CONTATOHIERARQUIA CONTATOHIERARQUIA"
		    " ,CONTATOADM.NOMECONTATO NOMECONTATO"
		    " ,CONTATOADM.CONTATOFOLHA CONTATOFOLHA"
		" WHERE"
		    " CONTATO.IDCONTATO = CONTATOFOLHA.IDCONTATO (+)"
		" AND"
		    " CONTATO.IDCONTATO = CONTATOHIERARQUIA.IDCONTATO"
		" AND"
		    " CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO"
		" AND"
			" CONTATOHIERARQUIA.IDCONTATOPAI = " );
		strcat( cPesquisa, cAuxidContato );
		strcat( cPesquisa, 
		" START WITH "
			" CONTATO.IDCONTATO IN "
			"( " 
				" SELECT  " 
					 "CONTATO.IDCONTATO" 
				" FROM " 
					"CONTATOADM.CONTATO CONTATO," 
					"CONTATOADM.CONTATOFOLHA CONTATOFOLHA" 
				" WHERE " 
					"CONTATO.IDCONTATO = CONTATOFOLHA.IDCONTATO" 
		
			                   " AND ( CONTATO.INDISPONIBILIDADE = " );
			strcat( cPesquisa, pzidDisponivel );
			strcat( cPesquisa, " OR " );
			strcat( cPesquisa, pzidDisponivel );
			strcat( cPesquisa, " = -1 ) " );
		
			if( osfidFechamento->getQuantidade() > 0 )
			{
				strcat( cPesquisa,
				        " AND "
				              " CONTATOFOLHA.IDCONTATO = "
				              " ( "
				                  "SELECT IDCONTATO "
				                  "FROM WORKFLOW.FLUXOFASEGRUPO FLUXOFASEGRUPO "
				                  "WHERE CONTATOFOLHA.IDCONTATO = FLUXOFASEGRUPO.idcontato"
				                   " AND ROWNUM < 2   "
				                   " AND IDTIPOFECHAMENTOCONTATO IN (" );
				for( iCont=0; iCont < osfidFechamento->getQuantidade(); iCont++ )
				{
					if( iCont > 0 )
						strcat( cPesquisa, "," );
					strcat( cPesquisa, osfidFechamento->getTag( iCont ) );
				}
				strcat( cPesquisa, ")" );
			}

//			strcat( cPesquisa, ") " );
		
			strcat( cPesquisa, 
				"  AND " 
						"CONTATOFOLHA.IDCONTATO = " 
						"( " 
							" SELECT IDCONTATO " 
							"   FROM CONTATOADM.CONTATOTIPORELACIONAMENTO CONTATOTIPORELACIONAMENTO "
							"  WHERE CONTATOTIPORELACIONAMENTO.IDTIPORELACIONAMENTO > 0 "
							"    AND idcontato = CONTATOFOLHA.idcontato  "
							"    AND ROWNUM < 2  "
						 );
		                    
			if( osfidTipoRelacionamento->getQuantidade() > 0 )
			{
				strcat( cPesquisa, " AND CONTATOTIPORELACIONAMENTO.IDTIPORELACIONAMENTO IN (" );
				for( iCont=0; iCont < osfidTipoRelacionamento->getQuantidade(); iCont++ )
				{
					if( iCont > 0 )
						strcat( cPesquisa, "," );
					strcat( cPesquisa, osfidTipoRelacionamento->getTag( iCont ) );
				}
				strcat( cPesquisa, " ) " );
			}
			strcat( cPesquisa, " ) " );
			
			strcat( cPesquisa, 
			   "AND  "
                "CONTATOFOLHA.IDCONTATO =  " 
                "( "
 						 "SELECT IDCONTATO" 
						  " FROM CONTATOADM.CONTATOSEGMENTACAO CONTATOSEGMENTACAO" 
						 " WHERE CONTATOSEGMENTACAO.IDSEGMENTACAO > 0"
                    "AND idcontato = CONTATOFOLHA.idcontato "
                    "AND ROWNUM < 2 "
				   );
		
			if( osfidSegmentacao->getQuantidade() > 0 )
			{
				strcat( cPesquisa, " AND CONTATOSEGMENTACAO.IDSEGMENTACAO IN (" );
				for( iCont=0; iCont < osfidSegmentacao->getQuantidade(); iCont++ )
				{
					if( iCont > 0 )
						strcat( cPesquisa, "," );
					strcat( cPesquisa, osfidSegmentacao->getTag( iCont ) );
				}
				strcat( cPesquisa, " ) " );
			}
			strcat( cPesquisa, " ) " );		

			strcat( cPesquisa, 
            "AND "
                "CONTATOFOLHA.IDCONTATO = "
                "( "
						" SELECT IDCONTATO" 
						" FROM CONTATOADM.CONTATOTIPOCARTEIRA CONTATOTIPOCARTEIRA" 
						" WHERE CONTATOTIPOCARTEIRA.IDTIPOCARTEIRA > 0" 
                     "AND idcontato = CONTATOFOLHA.idcontato "
                     "AND ROWNUM < 2 "
    				);
		
			if( osfidTipoCarteira->getQuantidade() > 0 )
			{
				strcat( cPesquisa, " AND CONTATOTIPOCARTEIRA.IDTIPOCARTEIRA IN (" );
				for( iCont=0; iCont < osfidTipoCarteira->getQuantidade(); iCont++ )
				{
					if( iCont > 0 )
						strcat( cPesquisa, "," );
					strcat( cPesquisa, osfidTipoCarteira->getTag( iCont ) );
				}
				strcat( cPesquisa, " ) " );
			}
			strcat( cPesquisa, " ) " );
			strcat( cPesquisa, 
            "AND " 
                "CONTATOFOLHA.IDCONTATO = "
                "("
						" SELECT IDCONTATO" 
						" FROM CONTATOADM.CONTATOGRUPO CONTATOGRUPO" 
						" WHERE CONTATOGRUPO.IDGRUPO > 0" 
                     "AND idcontato = CONTATOFOLHA.idcontato "
                     "AND ROWNUM < 2 "
						);
			if( ( osfidGrupoAbertura->getQuantidade() > 0 )
			  ||( osfidGrupoTratamento->getQuantidade() > 0 )
			  ||( osfidGrupoRetorno->getQuantidade() > 0 ) )
			{
				int iVirgula = 0;
				strcat( cPesquisa, " AND CONTATOGRUPO.IDGRUPO IN (" );
				for( iCont=0; iCont < osfidGrupoAbertura->getQuantidade(); iCont++ )
				{	
					if( iCont > 0 )
						strcat( cPesquisa, "," );
		
					iVirgula = 1;
		
					strcat( cPesquisa, osfidGrupoAbertura->getTag( iCont ) );
				}
				for( iCont=0; iCont < osfidGrupoTratamento->getQuantidade(); iCont++ )
				{
					if( ( iCont > 0 ) || ( iVirgula > 0 ) )
						strcat( cPesquisa, "," );
		
					iVirgula = 1;
		
					strcat( cPesquisa, osfidGrupoTratamento->getTag( iCont ) );
				}
				for( iCont=0; iCont < osfidGrupoRetorno->getQuantidade(); iCont++ )
				{
					if( ( iCont > 0 ) || ( iVirgula > 0 ) )
						strcat( cPesquisa, "," );
		
					strcat( cPesquisa, osfidGrupoRetorno->getTag( iCont ) );
				}
				strcat( cPesquisa, " ) " );
			}

			strcat( cPesquisa, " ) " );
		
			strcat( cPesquisa, 
            "AND "
                "CONTATOFOLHA.IDCONTATO = "
                "( "
   					" SELECT IDCONTATO" 
   					"   FROM CONTATOADM.CONTATOTIPOLINHA CONTATOTIPOLINHA" 
   					"  WHERE CONTATOTIPOLINHA.IDTIPOLINHA > 0" 
                      "AND idcontato = CONTATOFOLHA.idcontato  "
                      "AND ROWNUM < 2 "
   					);
		
			if( osfidTipoLinha->getQuantidade() > 0 )
			{
				strcat( cPesquisa, " AND CONTATOTIPOLINHA.IDTIPOLINHA IN (" );
				for( iCont=0; iCont < osfidTipoLinha->getQuantidade(); iCont++ )
				{
					if( iCont > 0 )
						strcat( cPesquisa, "," );
					strcat( cPesquisa, osfidTipoLinha->getTag( iCont ) );
				}
				strcat( cPesquisa, ")" );
			}

			strcat( cPesquisa, ")" );
		
			strcat( cPesquisa, 
            "AND "
                "CONTATOFOLHA.IDCONTATO = "
                "( "
						 " SELECT IDCONTATO" 
						 " FROM CONTATOADM.CONTATOUFOPERADORA CONTATOUFOPERADORA" 
						 " WHERE idcontato = CONTATOFOLHA.idcontato  "  
						 " AND ROWNUM < 2 "     
					 );
			if( strcmp( pzdtInicio, "-1" ) != 0 )
			{
				iTemDataInicioFim++;
				strcat( cPesquisa, 
					   "TO_CHAR(CONTATOUFOPERADORA.DTINICIOVIGENCIA, 'YYYYMMDD' ) >= " );
				strcat( cPesquisa, pzdtInicio );
			}
			if( strcmp( pzdtFim, "-1" ) != 0 )
			{
				iTemDataInicioFim++;
				if( iTemDataInicioFim )
					strcat( cPesquisa, " AND " );
				strcat( cPesquisa, 
		    							"TO_CHAR(CONTATOUFOPERADORA.DTINICIOVIGENCIA, 'YYYYMMDD' ) <= " );
				strcat( cPesquisa, pzdtFim );
			}
			if( osfidOperadora->getQuantidade() > 0 )
			{
				if( iTemDataInicioFim )
					strcat( cPesquisa, " AND " );
					
				strcat( cPesquisa,  "CONTATOUFOPERADORA.IDUFOPERADORA IN ( " );
				for( iCont=0; iCont < osfidOperadora->getQuantidade(); iCont++ )
				{
					if( iCont > 0 )
						strcat( cPesquisa, "," );
					strcat( cPesquisa, osfidOperadora->getTag( iCont ) );
				}
				strcat( cPesquisa, ") " );
			}
		
			strcat( cPesquisa, 
							")" 
//					")" 
				" OR " 
					  " CONTATOFOLHA.IDCONTATO NOT IN " 
					  " ( " 
					  	" SELECT IDCONTATO " 
					  	" FROM " 
					  		"CONTATOADM.CONTATOTIPORELACIONAMENTO " 
					  	" UNION " 
					  	" SELECT IDCONTATO " 
					  	" FROM " 
					  		"CONTATOADM.CONTATOSEGMENTACAO " 
					  	" UNION " 
					  	" SELECT IDCONTATO "  
					  	" FROM " 
					  		"CONTATOADM.CONTATOTIPOCARTEIRA " 
					  	" UNION " 
					  	" SELECT IDCONTATO " 
					  	" FROM " 
					  		"CONTATOADM.CONTATOGRUPO " 
					  	" UNION " 
					  	" SELECT IDCONTATO " 
					  	" FROM " 
					  		"CONTATOADM.CONTATOTIPOLINHA " 
					  	" UNION " 
					  	" SELECT IDCONTATO " 
					  	" FROM " 
					  		"CONTATOADM.CONTATOUFOPERADORA " 
					  " ) " 
			);
			strcat( cPesquisa, " AND " );
			strcat( cPesquisa, pzidGrupoAbertura );
			strcat( cPesquisa, " = -1" );
		
			strcat( cPesquisa, " AND " );
			strcat( cPesquisa, pzidGrupoTratamento );
			strcat( cPesquisa, " = -1" );
		
			strcat( cPesquisa, " AND " );
			strcat( cPesquisa, pzidGrupoRetorno );
			strcat( cPesquisa, " = -1" );
		
			strcat( cPesquisa, " AND " );
			strcat( cPesquisa, pzidSegmentacao );
			strcat( cPesquisa, " = -1" );
		
			strcat( cPesquisa, " AND " );
			strcat( cPesquisa, pzidTipoCarteira );
			strcat( cPesquisa, " = -1" );
		
			strcat( cPesquisa, " AND " );
			strcat( cPesquisa, pzidTipoLinha );
			strcat( cPesquisa, " = -1" );
		
			strcat( cPesquisa, " AND " );
			strcat( cPesquisa, pzidOperadora );
			strcat( cPesquisa, " = -1" );
		
			strcat( cPesquisa, " AND " );
			strcat( cPesquisa, pzdtInicio );
			strcat( cPesquisa, " = -1" );
		
			strcat( cPesquisa, " AND " );
			strcat( cPesquisa, pzdtFim );
			strcat( cPesquisa, " = -1" );
		
			strcat( cPesquisa,
			" ) " 
		    " CONNECT BY PRIOR "
		        "IDCONTATOPAI = CONTATO.IDCONTATO "
	" ) "
	" ORDER BY INFOLHAORDENADA, UPPER(NMCONTATO) "
	            ); */
    
	strcpy( cPesquisa, 
	"SELECT "
		"IDCONTATO, "
		"IDNOMECONTATO, "
		"NMCONTATO, "
		"INDISPONIBILIDADE, "
		"NMPATH, "
		"NIVEL, "
		"IDCONTATOPAI, "
		"INFOLHA "
	"FROM "
	"( "
//		 "--PESQUISA EM FORMA DE ARVORE QUE RETORNA NIVEL A NIVEL "
		 "SELECT DISTINCT " 
		 "    CONTATO.IDCONTATO, "
		 "    CONTATO.IDNOMECONTATO, "
		 "    NOMECONTATO.NMCONTATO, "
		 "    CONTATO.INDISPONIBILIDADE, "
		 "    CONTATO.NMPATH, "
		 "    1 NIVEL, "
		 "    CONTATOHIERARQUIA.IDCONTATOPAI, "
		 "    DECODE(CONTATOFOLHA.IDCONTATO,NULL,1,0) INFOLHAORDENADA, "
		 "    DECODE(CONTATOFOLHA.IDCONTATO,NULL,0,1) INFOLHA "
		 "FROM  "
			 "CONTATOADM.CONTATO           CONTATO, "
			 "CONTATOADM.CONTATOHIERARQUIA CONTATOHIERARQUIA, "
			 "CONTATOADM.NOMECONTATO       NOMECONTATO, "
			 "CONTATOADM.CONTATOFOLHA      CONTATOFOLHA "
		 "WHERE  "
			 "CONTATO.IDCONTATO = CONTATOFOLHA.IDCONTATO(+)  "
		 "AND "
			 "CONTATO.IDCONTATO = CONTATOHIERARQUIA.IDCONTATO  "
		 "AND "
			 "CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO  "
		 "AND "
			 "CONTATOHIERARQUIA.IDCONTATOPAI = ");   //  --VARIAVEL COM A PAI "
		 strcat( cPesquisa, cAuxidContato );    
		 strcat( cPesquisa, 
		 " AND "
			" ( CONTATO.INDISPONIBILIDADE = "); //1 --VARIAVEL COM A DISPONIBILIDADE "
		  strcat( cPesquisa, pzidDisponivel );
		  strcat( cPesquisa, " OR " );
		  strcat( cPesquisa, pzidDisponivel );
		  strcat( cPesquisa, " = -1 ) " );
		 strcat( cPesquisa,    
		 "START WITH  "
			 "CONTATO.IDCONTATO IN "
			 "( "
				 "SELECT "
					 "CONTATOFOLHA1.IDCONTATO "
				 "FROM  "
					 "CONTATOADM.CONTATOFOLHA  CONTATOFOLHA1 "
				 "WHERE  "
				 "( " );
				 if( osfidFechamento->getQuantidade() > 0 )
				 {
					 lInc_AND = true ;
					
					 // "--LISTA DE TIPO DE FECHAMENTO "
					 strcat( cPesquisa,  
					 "CONTATOFOLHA1.IDCONTATO = "
					 "( "
						 "SELECT IDCONTATO "
						 "FROM WORKFLOW.FLUXOFASEGRUPO FLUXOFASEGRUPO "
						 "WHERE FLUXOFASEGRUPO.IDCONTATO = CONTATOFOLHA1.idcontato "
						 "AND ROWNUM < 2 "
						 "AND IDTIPOFECHAMENTOCONTATO IN ( " );
						 for( iCont=0; iCont < osfidFechamento->getQuantidade(); iCont++ )
							 {
								 if( iCont > 0 )
									  strcat( cPesquisa, "," );
								 strcat( cPesquisa, osfidFechamento->getTag( iCont ) );
							 }
							 strcat( cPesquisa, ") "
					 ") " );
				   
				}
				   if( osfidTipoRelacionamento->getQuantidade() > 0 )
				{
                    // "--LISTA DE TIPO RELACIONAMENTO "
                    
                    if  (lInc_AND == true)
                    {
                        strcat( cPesquisa, "AND  " );
					}

					lInc_AND = true ;

                    strcat( cPesquisa,   
					"CONTATOFOLHA1.IDCONTATO =  "
					"( "
					   "SELECT IDCONTATO "
						"FROM CONTATOADM.CONTATOTIPORELACIONAMENTO CONTATOTIPORELACIONAMENTO "
						"WHERE CONTATOTIPORELACIONAMENTO.IDTIPORELACIONAMENTO > 0  "
						"AND CONTATOTIPORELACIONAMENTO.IDCONTATO = CONTATOFOLHA1.idcontato  "
						"AND ROWNUM < 2  "
						"AND CONTATOTIPORELACIONAMENTO.IDTIPORELACIONAMENTO IN (");   //2, 3, 8, 4, 5, 7, 6, 1) "
						for( iCont=0; iCont < osfidTipoRelacionamento->getQuantidade(); iCont++ )
							{
								  if( iCont > 0 )
									   strcat( cPesquisa, "," );
								  strcat( cPesquisa, osfidTipoRelacionamento->getTag( iCont ) );
							}
							strcat( cPesquisa, " ) "
					") " );
				 
				}
				if( osfidSegmentacao->getQuantidade() > 0 )
				{
                    if  (lInc_AND == true)
                    {
                        strcat( cPesquisa, "AND  " );
					}

					lInc_AND = true ;

					 // "--LISTA DE SEGMENTACAO "
					 strcat( cPesquisa, 
					 "CONTATOFOLHA1.IDCONTATO =  "
					 "( "
						"SELECT IDCONTATO "
						  "FROM CONTATOADM.CONTATOSEGMENTACAO CONTATOSEGMENTACAO "
						 "WHERE CONTATOSEGMENTACAO.IDSEGMENTACAO > 0  "
						 "AND CONTATOSEGMENTACAO.IDCONTATO = CONTATOFOLHA1.idcontato  "
						 "AND ROWNUM < 2  "
						 "AND CONTATOSEGMENTACAO.IDSEGMENTACAO IN( ");        //1, 2, 3, 7, 8, 9, 11, 4, 5, 6, 10) "
           					for( iCont=0; iCont < osfidSegmentacao->getQuantidade(); iCont++ )
         					{
         						if( iCont > 0 )
         							strcat( cPesquisa, "," );
         						strcat( cPesquisa, osfidSegmentacao->getTag( iCont ) );
         					}
         					strcat( cPesquisa, " ) " 
					 ") " );
				 
				}
				if( osfidTipoCarteira->getQuantidade() > 0 )
				{
                    if  (lInc_AND == true)
                    {
                        strcat( cPesquisa, "AND  " );
					}

					lInc_AND = true ;

					 
					 //"--LISTA DE TIPO CARTEIRA "
					 strcat( cPesquisa,  
					 "CONTATOFOLHA1.IDCONTATO =  "
					 "( "
						"SELECT IDCONTATO "
						  "FROM CONTATOADM.CONTATOTIPOCARTEIRA CONTATOTIPOCARTEIRA "
						 "WHERE CONTATOTIPOCARTEIRA.IDTIPOCARTEIRA > 0  "
						 "AND CONTATOTIPOCARTEIRA.IDCONTATO = CONTATOFOLHA1.idcontato  "
						 "AND ROWNUM < 2  "
						 "AND CONTATOTIPOCARTEIRA.IDTIPOCARTEIRA IN( ");       //14, 4, 15, 9, 8, 13, 12, 3, 10, 16, 7, 5, 39, 11, 17, 2, 6, 18, 19, 40, 1) "                     
						 for( iCont=0; iCont < osfidTipoCarteira->getQuantidade(); iCont++ )
						 {
							if( iCont > 0 )
							   strcat( cPesquisa, "," );
							strcat( cPesquisa, osfidTipoCarteira->getTag( iCont ) );
						 }
						 strcat( cPesquisa, " ) "
					 ") " );
				 
				} 
				if ( osfidGrupoAbertura->getQuantidade() > 0 )
				{ 
                    if  (lInc_AND == true)
                    {
                        strcat( cPesquisa, "AND  " );
					}

					lInc_AND = true ;

					 
					 // "--LISTA DE GRUPO ABERTURA "
					 strcat( cPesquisa, 
					 "CONTATOFOLHA1.IDCONTATO =  "
					 "( "
						"SELECT IDCONTATO "
						  "FROM CONTATOADM.CONTATOGRUPO CONTATOGRUPO, CONTATOADM.SEQUENCIA SEQUENCIA "
						 "WHERE CONTATOGRUPO.IDCONTATOGRUPO = SEQUENCIA.IDCONTATOGRUPO "
						 "AND CONTATOGRUPO.IDGRUPO > 0  "
						 "AND SEQUENCIA.IDTIPOSEQUENCIA = 1 " //-- ABERTURA (NAO EH VARIAVEL "
						 "AND CONTATOGRUPO.IDCONTATO = CONTATOFOLHA1.idcontato  "
						 "AND ROWNUM < 2  "
						 "AND CONTATOGRUPO.IDGRUPO IN ( " );   //475) "
						  for( iCont=0; iCont < osfidGrupoAbertura->getQuantidade(); iCont++ )
						  {	
						     if(iCont > 0 )
				 	    	    strcat( cPesquisa, "," );
						     strcat( cPesquisa, osfidGrupoAbertura->getTag( iCont ) );
						  }  
						  strcat( cPesquisa, " ) "  
					 ") " );
				 
				}    
				if ( osfidGrupoTratamento->getQuantidade() > 0 )
				{ 
                    if  (lInc_AND == true)
                    {
                        strcat( cPesquisa, "AND  " );
					}

					lInc_AND = true ;


				     //"--LISTA DE GRUPO TRATAMENTO "
					 strcat( cPesquisa, 
					 "CONTATOFOLHA1.IDCONTATO =  "
					 "( "
						"SELECT IDCONTATO "
						  "FROM CONTATOADM.CONTATOGRUPO CONTATOGRUPO, CONTATOADM.SEQUENCIA SEQUENCIA "
						 "WHERE CONTATOGRUPO.IDCONTATOGRUPO = SEQUENCIA.IDCONTATOGRUPO "
						 "AND CONTATOGRUPO.IDGRUPO > 0  "
						 "AND SEQUENCIA.IDTIPOSEQUENCIA = 2 " // -- TRATAMENTO (NAO EH VARIAVEL "
						 "AND CONTATOGRUPO.IDCONTATO = CONTATOFOLHA1.idcontato  "
						 "AND ROWNUM < 2  "
						 "AND CONTATOGRUPO.IDGRUPO IN (");   //475) "
						 for( iCont=0; iCont < osfidGrupoTratamento->getQuantidade(); iCont++ )
							 {
								 if(  iCont > 0  )
										strcat( cPesquisa, "," );
								   strcat( cPesquisa, osfidGrupoTratamento->getTag( iCont ) );
							 }
						 strcat( cPesquisa, " ) "  
					 ") " ) ;
				 
				}
				if ( osfidGrupoRetorno->getQuantidade() > 0 ) 
				{
                    if  (lInc_AND == true)
                    {
                        strcat( cPesquisa, "AND  " );
					}

					lInc_AND = true ;

					
  				  // "--LISTA DE GRUPO RETORNO "
					 strcat( cPesquisa, 
					 "CONTATOFOLHA1.IDCONTATO =  "
					 "( "
					   " SELECT IDCONTATO "
						  "FROM CONTATOADM.CONTATOGRUPO CONTATOGRUPO, CONTATOADM.SEQUENCIA SEQUENCIA "
						 "WHERE CONTATOGRUPO.IDCONTATOGRUPO = SEQUENCIA.IDCONTATOGRUPO "
						 "AND CONTATOGRUPO.IDGRUPO > 0  "
						 "AND SEQUENCIA.IDTIPOSEQUENCIA = 3 " // -- RETORNO (NAO EH VARIAVEL "
						 "AND CONTATOGRUPO.IDCONTATO = CONTATOFOLHA1.idcontato  "
						 "AND ROWNUM < 2  "
						 "AND CONTATOGRUPO.IDGRUPO IN (") ;       // 475) ")
         					for( iCont=0; iCont < osfidGrupoRetorno->getQuantidade(); iCont++ )
         					{
         						if( ( iCont > 0 )  )
         							strcat( cPesquisa, "," );
         						strcat( cPesquisa, osfidGrupoRetorno->getTag( iCont ) );
         					}
         					strcat( cPesquisa, " ) "
					 ") " );
				 
				}
				if( osfidTipoLinha->getQuantidade() > 0 )
				{
                    if  (lInc_AND == true)
                    {
                        strcat( cPesquisa, "AND  " );
					}

					lInc_AND = true ;

					 
					 //"--LISTA DE TIPO DE LINHA "
                     strcat( cPesquisa, 
					 "CONTATOFOLHA1.IDCONTATO =  "
					 "( "
						"SELECT IDCONTATO "
						 " FROM CONTATOADM.CONTATOTIPOLINHA CONTATOTIPOLINHA "
						 "WHERE CONTATOTIPOLINHA.IDTIPOLINHA > 0  "
						 "AND CONTATOTIPOLINHA.IDCONTATO = CONTATOFOLHA1.idcontato  "
						 "AND ROWNUM < 2  "
						 "AND CONTATOTIPOLINHA.IDTIPOLINHA IN(" )  ;  // 41, 3, 21, 2, 1, 61) "
						 for( iCont=0; iCont < osfidTipoLinha->getQuantidade(); iCont++ )
         					{
         						if( iCont > 0 )
         							strcat( cPesquisa, "," );
         						strcat( cPesquisa, osfidTipoLinha->getTag( iCont ) );
         					}
         					strcat( cPesquisa, ")"
					 ") " );
				 
				}
				if(
					( osfidOperadora->getQuantidade() > 0 ) ||
					( strcmp( pzdtInicio, "-1" ) != 0 )     ||
					( strcmp( pzdtFim, "-1" ) != 0 )
				  )
				{
                    if  (lInc_AND == true)
					{
                        strcat( cPesquisa, "AND  " );
					}

					lInc_AND = true ;

					 
					 // "--LISTA DE REGIONAI (UFOPERADORA) "
                     strcat( cPesquisa, 
					 "CONTATOFOLHA1.IDCONTATO =  "
					 "( "
						"SELECT IDCONTATO "
						  "FROM CONTATOADM.CONTATOUFOPERADORA CONTATOUFOPERADORA "
						 "WHERE CONTATOUFOPERADORA.IDCONTATO = CONTATOFOLHA1.idcontato  "
						 "AND   ROWNUM < 2  ");
                         if( osfidOperadora->getQuantidade() > 0 )
						 {
							 strcat( cPesquisa,
							 " AND   CONTATOUFOPERADORA.IDUFOPERADORA IN( ") ; //11, 3, 4, 5, 19, 7, 10, 14, 8, 9, 21, 15, 6, 2, 16, 17, 20, 1, 18) "
							 for( iCont=0; iCont < osfidOperadora->getQuantidade(); iCont++ )
         						{
         							if( iCont > 0 )
         								strcat( cPesquisa, "," );
         							strcat( cPesquisa, osfidOperadora->getTag( iCont ) );
         						}
         						strcat( cPesquisa, ") ");
						 }
						if( strcmp( pzdtInicio, "-1" ) != 0 )
						{
							strcat( cPesquisa, 
								   " AND TO_CHAR(CONTATOUFOPERADORA.DTINICIOVIGENCIA, 'YYYYMMDD' ) >= " );
							strcat( cPesquisa, pzdtInicio );
						}
						if( strcmp( pzdtFim, "-1" ) != 0 )
						{
							strcat( cPesquisa, 
								   " AND TO_CHAR(CONTATOUFOPERADORA.DTINICIOVIGENCIA, 'YYYYMMDD' ) <= " );
							strcat( cPesquisa, pzdtFim );
						}
					 strcat( cPesquisa,
						 ") "
				 ") " );
				}  
				strcat( cPesquisa, 
				 //"--ESTA PARTE COMENTADA, ABAIXO, SERVE PARA RETORNAR AS FOLHAS QUE NÃO TEM NADA PARAMETRIZADO "
				 //"--SE DESCOMENTAR AS FOLHAS QUE NÃO TEM CONFIGURACAO SERAO RETORNADAS "
				 //"--SE MANTER O COMENTARIO ELAS NAO APARECEM "
				 //"--LEMBRO DE ALGUMA COISA QUE ERA PRA RETORNAR OS NAO CONFIGURADOS "
//				 "/* "
//				"UNION "
//				 "SELECT "
//					 "CONTATOFOLHA2.IDCONTATO "
//				 "FROM  "
//					 "CONTATOADM.CONTATOFOLHA CONTATOFOLHA2 "
//				 "WHERE  "
//				 "( "
//					"( SELECT IDCONTATO "
//					  "FROM CONTATOADM.CONTATOTIPORELACIONAMENTO CONTATOTIPORELACIONAMENTO1 "
//					  "WHERE CONTATOTIPORELACIONAMENTO1.IDCONTATO = CONTATOFOLHA2.IDCONTATO "
//					  "AND ROWNUM < 2 ) IS NULL "
//					"AND "
//					"( SELECT IDCONTATO "
//					  "FROM CONTATOADM.CONTATOSEGMENTACAO CONTATOSEGMENTACAO1 "
//					  "WHERE CONTATOSEGMENTACAO1.IDCONTATO = CONTATOFOLHA2.IDCONTATO "
//					  "AND ROWNUM < 2 ) IS NULL "
//					"AND "
//					"( SELECT IDCONTATO "
//					  "FROM CONTATOADM.CONTATOTIPOCARTEIRA CONTATOTIPOCARTEIRA1 "
//					  "WHERE CONTATOTIPOCARTEIRA1.IDCONTATO = CONTATOFOLHA2.IDCONTATO "
//					  "AND ROWNUM < 2 ) IS NULL "
//					"AND "
//					"( SELECT IDCONTATO "
//					  "FROM CONTATOADM.CONTATOGRUPO CONTATOGRUPO1 "
//					  "WHERE CONTATOGRUPO1.IDGRUPO = 23123123123123 --IDCONTATO = CONTATOFOLHA2.IDCONTATO "
//					  "AND ROWNUM < 2 ) IS NULL "
//					"AND "
//					"( SELECT IDCONTATO "
//					  "FROM CONTATOADM.CONTATOTIPOLINHA CONTATOTIPOLINHA1 "
//					  "WHERE CONTATOTIPOLINHA1.IDCONTATO = CONTATOFOLHA2.IDCONTATO "
//					  "AND ROWNUM < 2 ) IS NULL "
//					"AND "
//					"( SELECT IDCONTATO "
//					  "FROM CONTATOADM.CONTATOUFOPERADORA CONTATOUFOPERADORA1 "
//					  "WHERE CONTATOUFOPERADORA1.IDCONTATO = CONTATOFOLHA2.IDCONTATO "
//					  "AND ROWNUM < 2 ) IS NULL "
//				 ") */ "
			 " ) ) "
		 "CONNECT BY PRIOR  "
			 "IDCONTATOPAI = CONTATO.IDCONTATO "
	 ") "
	 "ORDER BY INFOLHAORDENADA, UPPER(NMCONTATO) ");



    ULOG( "\n\n VIEW = %s\n\n", cPesquisa );

	EXEC SQL PREPARE qPesquisa FROM :cPesquisa;
	EXEC SQL DECLARE CursorListAllFiltrado3 CURSOR FOR qPesquisa;

	EXEC SQL OPEN CursorListAllFiltrado3;

	if(sqlca.sqlcode)
		return 0;
	else
	{
		for(;;)
		{
			memset( &stContatoRegistro, 0, sizeof(stContatoRegistro) );
			memset( &stContatoIndicator, -1, sizeof(stContatoIndicator) );

			EXEC SQL FETCH CursorListAllFiltrado3 INTO :stContatoRegistro:stContatoIndicator;
			Add((char*)stContatoRegistro.stidContato.arr,
				(char*)stContatoRegistro.stidContatoPai.arr,
				(char*)stContatoRegistro.stidNomeContato.arr,
				(char*)stContatoRegistro.stnmContato.arr,
				(char*)stContatoRegistro.stinDisponibilidade.arr,
				(char*)stContatoRegistro.stnmPath.arr,
				stContatoRegistro.iLevel,
			    stContatoRegistro.iFolha,
                "");
			iCont++;
		}
		EXEC SQL CLOSE CursorListAllFiltrado3;
	}

	if(sqlca.sqlcode)
	   iCont = 0 ;  // erro de banco

    ULOG("  Return = [%d]",iCont);
    
    ULOG_END("CContato::ListAllFiltrado)");
	return iCont;

GotoListAllFiltrado3:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}



int CContato::TemArvoreBaixa( char* cidContato )
{
    ULOG_START("CContato::TemArvoreBaixa)");
	sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char*   cAuxidContato = cidContato;
		int     iCont = 0;
	EXEC SQL END DECLARE SECTION;

	sqlca.sqlcode=0;
	EXEC SQL WHENEVER SQLERROR GOTO GotoTemArvoreBaixa;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
		SELECT 
			COUNT(1)
		INTO
			:iCont
		FROM
			CONTATOADM.CONTATOFOLHABAIXA CONTATO
		WHERE
			CONTATO.IDCONTATO = :cAuxidContato;

    ULOG_END("CContato::TemArvoreBaixa)");
	return iCont;

GotoTemArvoreBaixa:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
   throw TuxBasicOraException(sqlca.sqlcode);
}

int CContato::TemGrupoAssociado( char* cidContato, char* cidTipoSequencia )
{
    
    ULOG_START("CContato::TemGrupoAssociado)");
    
	sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char*   cAuxidContato = cidContato;
		char*   cAuxidTipoSequencia = cidTipoSequencia;
		int     iCont = 0;
	EXEC SQL END DECLARE SECTION;

	sqlca.sqlcode=0;
	EXEC SQL WHENEVER SQLERROR GOTO GotoTemArvoreBaixa;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
		SELECT 
			COUNT(1)
		INTO
			:iCont
		FROM
			CONTATOADM.SEQUENCIA SEQUENCIA,
			CONTATOADM.CONTATOGRUPO CONTATOGRUPO
		WHERE
			CONTATOGRUPO.IDCONTATOGRUPO = SEQUENCIA.IDCONTATOGRUPO
		AND
			CONTATOGRUPO.IDCONTATO = :cAuxidContato
		AND
			SEQUENCIA.IDTIPOSEQUENCIA = :cAuxidTipoSequencia;
			
    ULOG_END("CContato::TemGrupoAssociado)");
	return iCont;

GotoTemArvoreBaixa:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}


int CContato::TemProcessoEmAndamento( char* cidContato )
{
    ULOG_START("CContato::TemProcessoEmAndamento)");
	sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char*   cAuxidContato = cidContato;
		int     iCont = 0;
	EXEC SQL END DECLARE SECTION;

	sqlca.sqlcode=0;
	EXEC SQL WHENEVER SQLERROR GOTO GotoTemProcessoEmAndamento;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	//Recupera a quantidade de contatos que estao em atendimentos nao fechados
    // ==> Remodelagem Atendimento--Fev/2007--Cassio 
    // EXEC SQL 
    //     SELECT 
    //         COUNT(1)
    //     INTO
    //         :iCont
    //     FROM
    //         ATENDIMENTO.ATENDIMENTOB0 ATENDIMENTO,
    //         ATENDIMENTO.ATENDIMENTOANDAMENTOATUALB0 ATENDIMENTOANDAMENTOATUAL
    //     WHERE
    //         ATENDIMENTO.IDATENDIMENTO = ATENDIMENTOANDAMENTOATUAL.IDATENDIMENTO
    //     AND
    //         ATENDIMENTO.IDATENDIMENTO NOT IN 
    //         (
    //             SELECT 
    //                 ATENDIMENTO.IDATENDIMENTO
    //             FROM
    //                 ATENDIMENTO.ATENDIMENTOB0 ATENDIMENTO,
    //                 ATENDIMENTO.ATENDIMENTOFECHAMENTOB0 ATENDIMENTOFECHAMENTO
    //             WHERE
    //                 ATENDIMENTO.IDATENDIMENTO = ATENDIMENTOFECHAMENTO.IDATENDIMENTO
    //             AND
    //                 ATENDIMENTO.IDCONTATO = :cAuxidContato
    //         )
    //     AND
    //         ATENDIMENTO.IDCONTATO = :cAuxidContato;
    EXEC SQL
		SELECT 
			COUNT(1)
		INTO
			:iCont
		FROM
			ATENDIMENTO.ATENDIMENTOPRIORIZACAO ATENDIMENTOPRIORIZACAO
		WHERE
			ATENDIMENTOPRIORIZACAO.IDCONTATO = :cAuxidContato;

    ULOG_END("CContato::TemProcessoEmAndamento)");

	return iCont;

GotoTemProcessoEmAndamento:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}

int CContato::TemNomeIgualNoMesmoNivel( char* cidContatoPai, char* cidNomeContato, char* cinFolha )
{
    ULOG_START("CContato::TemNomeIgualNoMesmoNivel)");
	sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char*   cAuxidContatoPai = cidContatoPai;
		char*   cAuxidNomeContato = cidNomeContato;
		char*   cAuxinFolha = cinFolha;
		int     iCont = 0;
	EXEC SQL END DECLARE SECTION;

	sqlca.sqlcode=0;
	EXEC SQL WHENEVER SQLERROR GOTO GotoTemNomeIgualNoMesmoNivel;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
	//Verifica se existe algum nome neste nivel da arvore
	EXEC SQL
		SELECT
			COUNT( IDCONTATO )
		INTO
			:iCont
		FROM
		(
			SELECT 
				 CONTATO.IDCONTATO,
				 DECODE(CONTATOFOLHA.IDCONTATO, NULL, '0', '1' ) INFOLHA
			FROM 
				CONTATOADM.CONTATOHIERARQUIA HIERARQUIA,
				CONTATOADM.CONTATO CONTATO,
				CONTATOADM.NOMECONTATO NOMECONTATO,
				CONTATOADM.CONTATOFOLHA CONTATOFOLHA
			WHERE
				CONTATO.IDCONTATO = CONTATOFOLHA.IDCONTATO (+)
			AND
				CONTATO.IDCONTATO = HIERARQUIA.IDCONTATO
			AND
				CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO
			AND
				HIERARQUIA.IDCONTATOPAI = :cAuxidContatoPai
    		AND
    			NOMECONTATO.IDNOMECONTATO = :cAuxidNomeContato
		)
		WHERE INFOLHA = :cAuxinFolha;

    ULOG_END("CContato::TemNomeIgualNoMesmoNivel)");
	return iCont;

GotoTemNomeIgualNoMesmoNivel:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}

int CContato::TemNomeIgualNoMesmoNivel( char* cidContatoPai, char* cidContato, char* cidNomeContato, char* cinFolha )
{
	sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char*   cAuxidContato = cidContato;
		char*   cAuxidContatoPai = cidContatoPai;
		char*   cAuxidNomeContato = cidNomeContato;
		char*   cAuxinFolha = cinFolha;
		int     iCont = 0;
	EXEC SQL END DECLARE SECTION;

	sqlca.sqlcode=0;
	EXEC SQL WHENEVER SQLERROR GOTO GotoTemNomeIgualNoMesmoNivel2;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
	//Verifica se existe algum nome neste nivel da arvore e nao eh ele mesmo
	EXEC SQL
		SELECT
			COUNT( IDCONTATO )
		INTO
			:iCont
		FROM
		(
			SELECT 
				 CONTATO.IDCONTATO,
				 DECODE(CONTATOFOLHA.IDCONTATO, NULL, '0', '1' ) INFOLHA
			FROM 
				CONTATOADM.CONTATOHIERARQUIA HIERARQUIA,
				CONTATOADM.CONTATO CONTATO,
				CONTATOADM.NOMECONTATO NOMECONTATO,
				CONTATOADM.CONTATOFOLHA CONTATOFOLHA
			WHERE
				CONTATO.IDCONTATO = CONTATOFOLHA.IDCONTATO (+)
			AND
				CONTATO.IDCONTATO = HIERARQUIA.IDCONTATO
			AND
				CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO
			AND
				HIERARQUIA.IDCONTATOPAI = :cAuxidContatoPai
    		AND
    			NOMECONTATO.IDNOMECONTATO = :cAuxidNomeContato
			AND
				CONTATO.IDCONTATO <> :cAuxidContato
		)
		WHERE INFOLHA = :cAuxinFolha;

	return iCont;

GotoTemNomeIgualNoMesmoNivel2:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}

void CContato::ApagaNomesNaoUtilizados( void )
{
	sqlca sqlca;

	sqlca.sqlcode=0;
	EXEC SQL WHENEVER SQLERROR GOTO GotoApagaNomesNaoUtilizados;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
	//Apaga todos os nomes nao utilizados
	EXEC SQL
		DELETE 
			CONTATOADM.NOMECONTATO
		WHERE
			IDNOMECONTATO NOT IN
			(
				SELECT 
					IDNOMECONTATO
				FROM
					CONTATOADM.CONTATO
			);

	return;

GotoApagaNomesNaoUtilizados:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}


int CContato::ProcuraNome( char* cnmContato )
{
	//Variavel de controle para a quantidade de registros retornada
	int iRet = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char*   cAuxnmContato = cnmContato;
		VARCHAR stidNomeContato[21+1];
		short   iidNomeContato;
		VARCHAR stnmContato[25+1];
		short   inmContato;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoProcuraNome;
	memset( &stidNomeContato, 0, sizeof( stidNomeContato ) );
	memset( &stnmContato, 0, sizeof( stnmContato ) );
    //Verifica se o nome ja existe, se existe recupera o id
	EXEC SQL
		SELECT
			IDNOMECONTATO
		   ,NMCONTATO
		INTO
			:stidNomeContato:iidNomeContato,
			:stnmContato:inmContato
		FROM
			CONTATOADM.NOMECONTATO
		WHERE
			UPPER(NMCONTATO) = UPPER(TRIM(:cAuxnmContato))
		AND
			ROWNUM <= 1;

	setIdNome( (char*)stidNomeContato.arr );

	//0 - Nao achou  1 - Achou o nome
	if( ( iRet = ( stidNomeContato.len <= 0 ? 0 : 1 ) ) == 1 )
	{
		if( strcmp( (char*)stidNomeContato.arr, cAuxnmContato ) == 0 )
			iRet = 2; //Achou o nome e eh igual ao de entrada (maiusculas e minusculas)
	}
	return iRet;
GotoProcuraNome:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);

}

char* CContato::getIdNome( void )
{
	return pzcidNome;
}

void CContato::setIdNome( char* cidNome )
{
	memset( pzcidNome, 0, sizeof( pzcidNome ) );
	if( strlennull( cidNome ) > 0 )
	{
		if( strlennull( cidNome ) <= 21  )
			strcpy( pzcidNome, cidNome );
		else
			strncpy( pzcidNome, &cidNome[0], 21 );
	}
}

int CContato::TemGrupoRetorno( char* cidContato, char* cidTipoRetornoContato )
{
    ULOG_START("CContato::TemGrupoRetorno)");
	//Variavel de controle para a quantidade de registros retornada
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		char* cAuxidTipoRetornoContato = cidTipoRetornoContato;
		int   iTemTipoRetorno = 0;
		VARCHAR stidContatoTipoRetono[21+1];
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoTemGrupoRetorno;

	memset( &stidContatoTipoRetono, 0, sizeof( stidContatoTipoRetono ) );

    //Verifica se existe tipo retorno contato
	EXEC SQL
	SELECT
		IDCONTATOTIPORETORNO
	INTO
		:stidContatoTipoRetono
	FROM
		CONTATOADM.CONTATOTIPORETORNO
	WHERE
		IDTIPORETORNOCONTATO = :cAuxidTipoRetornoContato
	AND
		IDCONTATO = :cAuxidContato;

	//Existindo tipo retorno contato, conforme conversado com Cassio, Marcos e Denys do
	//workflow, mesmo quando nao ha parametros associados continua existindo um registro em
	//contatotiporetorno, entao tem que verificar se existe parametrizacao
	if( stidContatoTipoRetono.len > 0 )
	{
		EXEC SQL
		SELECT
			COUNT(1)
		INTO
			:iTemTipoRetorno
		FROM
			CONTATOADM.CONTATOTIPORETORNOCANAL
		WHERE
			IDCONTATOTIPORETORNO = :stidContatoTipoRetono;

		if( iTemTipoRetorno <= 0 )
		{
			EXEC SQL
			SELECT
				COUNT(1)
			INTO
				:iTemTipoRetorno
			FROM
				CONTATOADM.CONTATOTIPORETORNOCANAL
			WHERE
				IDCONTATOTIPORETORNO = :stidContatoTipoRetono;
		}
		if( iTemTipoRetorno <= 0 )
		{
			EXEC SQL
			SELECT
				COUNT(1)
			INTO
				:iTemTipoRetorno
			FROM
				CONTATOADM.TIPOPESSOATPRELACIONAMENTO
			WHERE
				IDCONTATOTIPORETORNO = :stidContatoTipoRetono;
		}
		if( iTemTipoRetorno <= 0 )
		{
			EXEC SQL
			SELECT
				COUNT(1)
			INTO
				:iTemTipoRetorno
			FROM
				CONTATOADM.TIPORETORNOPROCEDENCIA
			WHERE
				IDCONTATOTIPORETORNO = :stidContatoTipoRetono;
		}

		if( iTemTipoRetorno <= 0 )
		{
			EXEC SQL
			SELECT
				COUNT(1)
			INTO
				:iTemTipoRetorno
			FROM
				CONTATOADM.TIPORETORNOSEGMENTACAO
			WHERE
				IDCONTATOTIPORETORNO = :stidContatoTipoRetono;
		}
		if( iTemTipoRetorno <= 0 )
		{
			EXEC SQL
			SELECT
				COUNT(1)
			INTO
				:iTemTipoRetorno
			FROM
				CONTATOADM.TIPORETORNOSEQUENCIA
			WHERE
				IDCONTATOTIPORETORNO = :stidContatoTipoRetono;
		}
		if( iTemTipoRetorno <= 0 )
		{
			EXEC SQL
			SELECT
				COUNT(1)
			INTO
				:iTemTipoRetorno
			FROM
				CONTATOADM.TIPORETORNOTIPOCARTEIRA
			WHERE
				IDCONTATOTIPORETORNO = :stidContatoTipoRetono;
		}
		if( iTemTipoRetorno <= 0 )
		{
			EXEC SQL
			SELECT
				COUNT(1)
			INTO
				:iTemTipoRetorno
			FROM
				CONTATOADM.TIPORETORNOTIPOLINHA
			WHERE
				IDCONTATOTIPORETORNO = :stidContatoTipoRetono;
		}
		if( iTemTipoRetorno <= 0 )
		{
			EXEC SQL
			SELECT
				COUNT(1)
			INTO
				:iTemTipoRetorno
			FROM
				CONTATOADM.TIPORETORNOTIPOPESSOA
			WHERE
				IDCONTATOTIPORETORNO = :stidContatoTipoRetono;
		}
	}//if( stidContatoTipoRetono.len > 0 )

    ULOG_START("CContato::TemGrupoRetorno)");
	//Este retorno soh eh verdadeiro se existe ContatoTipoRetorno com parametros
	return iTemTipoRetorno;

GotoTemGrupoRetorno:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
   throw TuxBasicOraException(sqlca.sqlcode);
}

int CContato::TemRegionais( char* cidContato )
{
	//Variavel de controle para a quantidade de registros retornada
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		int   iTemRegional = 0;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoTemRegionais;

    //Verifica se o nome ja existe, se existe recupera o id
	EXEC SQL
		SELECT
			COUNT(1)
		INTO
			:iTemRegional
		FROM
			CONTATOADM.CONTATOUFOPERADORA
		WHERE
			IDCONTATO = :cAuxidContato;

	return iTemRegional;

GotoTemRegionais:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}

int CContato::TemTipoLinha( char* cidContato )
{
	//Variavel de controle para a quantidade de registros retornada
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		int   iTemRelacao = 0;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoTemTipoLinha;

    //Verifica se o nome ja existe, se existe recupera o id
	EXEC SQL
		SELECT
			COUNT(1)
		INTO
			:iTemRelacao
		FROM
			CONTATOADM.CONTATOTIPOLINHA
		WHERE
			IDCONTATO = :cAuxidContato;

	return iTemRelacao;

GotoTemTipoLinha:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}

int CContato::TemTipoRelacionamento( char* cidContato )
{
	//Variavel de controle para a quantidade de registros retornada
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		int   iTemRelacao = 0;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoTemTipoRelacionamento;

    //Verifica se o nome ja existe, se existe recupera o id
	EXEC SQL
		SELECT
			COUNT(1)
		INTO
			:iTemRelacao
		FROM
			CONTATOADM.CONTATOTIPORELACIONAMENTO
		WHERE
			IDCONTATO = :cAuxidContato;

	return iTemRelacao;

GotoTemTipoRelacionamento:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}

int CContato::TemSegmentacao( char* cidContato )
{
	//Variavel de controle para a quantidade de registros retornada
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		int   iTemRelacao = 0;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoTemSegmentacao;

    //Verifica se o nome ja existe, se existe recupera o id
	EXEC SQL
		SELECT
			COUNT(1)
		INTO
			:iTemRelacao
		FROM
			CONTATOADM.CONTATOSEGMENTACAO
		WHERE
			IDCONTATO = :cAuxidContato;

	return iTemRelacao;

GotoTemSegmentacao:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}

int CContato::TemTipoCarteira( char* cidContato )
{
	//Variavel de controle para a quantidade de registros retornada
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		int   iTemRelacao = 0;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoTemTipoCarteira;

    //Verifica se o nome ja existe, se existe recupera o id
	EXEC SQL
		SELECT
			COUNT(1)
		INTO
			:iTemRelacao
		FROM
			CONTATOADM.CONTATOTIPOCARTEIRA
		WHERE
			IDCONTATO = :cAuxidContato;

	return iTemRelacao;

GotoTemTipoCarteira:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}

void CContato::LimpaNomeContato( void )
{
	//Variavel de controle para a quantidade de registros retornada
	struct sqlca sqlca;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoLimpaNomeContato;

	//Apaga todos os nomes não utilizados
	EXEC SQL
	DELETE FROM
		CONTATOADM.NOMECONTATO
	WHERE
		IDNOMECONTATO NOT IN
		(
			SELECT 
				IDNOMECONTATO
			FROM
				CONTATOADM.CONTATO
		);

	return;

GotoLimpaNomeContato:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}


//Metodos abaixo foram criados por Marcelo Nunez
int CContato::ListaSemContato( 
                                 char* cidUFOperadora,
                                 char* cidTipoLinha,
                                 char* cidTipoCarteira,
                                 char* cidSegmentacao 
                              )
{
    ULOG_START("CContato::ListaSemContato)");
   int iCont = 0;
   struct sqlca sqlca;
   EXEC SQL BEGIN DECLARE SECTION;
      char* cAuxidUFOperadora = cidUFOperadora;
      char  cAuxidTipoLinha[21+1];
      char  cAuxidTipoCarteira[21+1];
      char  cAuxidSegmentacao[21+1];
     
      struct
      {
         VARCHAR stidContato[255+1];
         VARCHAR stidNomeContato[255+1];
         VARCHAR stnmContato[255+1];
         VARCHAR stinDisponibilidade[255+1];
         int     iLevel;
         VARCHAR stidContatoPai[255+1];
         VARCHAR stdsPath[2048+1];
         int     iFolha;
      } stContatoRegistro;
      struct
      {
         short iidContato;
         short iidNomeContato;
         short inmContato;
         short iinDisponibilidade;
         short iLevel;
         short iidContatoPai;
         short idsPath;
         short iiFolha;
      } stContatoIndicator;
      struct
      {
         VARCHAR stidContato[21+1];
         VARCHAR stidNomeContato[21+1];
         VARCHAR stnmContato[255+1];
         VARCHAR stinDisponibilidade[21+1];
      } stContatoRaiz;
      struct
      {
         short iidContato;
         short iidNomeContato;
         short inmContato;
         short iinDisponibilidade;
      } stContatoRaizIndicator;
   EXEC SQL END DECLARE SECTION;

   //Processamento Principal
   try
   {
      memset( &cAuxidTipoLinha, 0, sizeof( cAuxidTipoLinha ) );
      memset( &cAuxidTipoCarteira, 0, sizeof( cAuxidTipoCarteira ) );
      memset( &cAuxidSegmentacao, 0, sizeof( cAuxidSegmentacao ) );

      if( strlennull( cidTipoLinha ) <= 0 )
         strcpy( cAuxidTipoLinha, "-1" );
      else
         strcpy( cAuxidTipoLinha, cidTipoLinha );

      if( strlennull( cidTipoCarteira ) <= 0 )
         strcpy( cAuxidTipoCarteira, "-1" );
      else
         strcpy( cAuxidTipoCarteira, cidTipoCarteira );

      if( strlennull( cidSegmentacao ) <= 0 )
         strcpy( cAuxidSegmentacao, "-1" );
      else
         strcpy( cAuxidSegmentacao, cidSegmentacao );

      ZeraContato();
      memset( &stContatoRaiz, 0, sizeof( stContatoRaiz ) );

      sqlca.sqlcode=0;
	  EXEC SQL WHENEVER NOT FOUND CONTINUE;
      EXEC SQL WHENEVER SQLERROR GOTO SemContatoError;
      //Recupera a raiz da arvore
	/* remoção de views bzeroum -- cassio -- jun/2007
      EXEC SQL
         SELECT CONTATO.IDCONTATO,
                CONTATO.IDNOMECONTATO,
                CONTATO.NMCONTATO NMCONTATO,
                CONTATO.INDISPONIBILIDADE
           INTO :stContatoRaiz:stContatoRaizIndicator
           FROM CONTATOADM.CONTATObzeroum CONTATO
          WHERE CONTATO.IDCONTATO NOT IN
                (SELECT IDCONTATO
                   FROM CONTATOADM.CONTATOHIERARQUIA
                  WHERE CONTATOHIERARQUIA.IDCONTATO > 0)
            AND ROWNUM <= 1;
    */

	  EXEC SQL
		 SELECT
			CONTATO.IDCONTATO,
			CONTATO.IDNOMECONTATO,
			NOMECONTATO.NMCONTATO,
			CONTATO.INDISPONIBILIDADE
		INTO
			:stContatoRaiz:stContatoRaizIndicator
		FROM
			CONTATOADM.CONTATO CONTATO,
			CONTATOADM.NOMECONTATO NOMECONTATO
		WHERE 
			CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO  
		AND CONTATO.IDCONTATO NOT IN (SELECT IDCONTATO
										FROM CONTATOADM.CONTATOHIERARQUIA
									   WHERE CONTATOHIERARQUIA.IDCONTATO > 0)
		AND ROWNUM < 2;

	  Add( (char*)stContatoRaiz.stidContato.arr,
            "",
            (char*)stContatoRaiz.stidNomeContato.arr,
            (char*)stContatoRaiz.stnmContato.arr,
            (char*)stContatoRaiz.stinDisponibilidade.arr,
            "",
            0,
            0,
            "");
      iCont++;

    //Cursor para recuperar a arvore
    EXEC SQL DECLARE readContato CURSOR FOR
        SELECT 
            HIERARQUIA.IDCONTATO,
            HIERARQUIA.IDNOMECONTATO,
            HIERARQUIA.NMCONTATO NMCONTATO,
            HIERARQUIA.INDISPONIBILIDADE,
            LEVEL,
            HIERARQUIA.IDCONTATOPAI,
            SYS_CONNECT_BY_PATH(REPLACE(HIERARQUIA.NMCONTATO, '/', '\' ), '/') AS "PATH",
            DECODE(IDCONTATOFOLHA, NULL, 0, 1 )
        FROM 
            CONTATOADM.CONTATOHIERARQUIAV01 HIERARQUIA,
			CONTATOADM.CONTATO CONTATO
        WHERE	
            HIERARQUIA.IDCONTATOPAI = :stContatoRaiz.stidContato
		AND HIERARQUIA.IDCONTATO = CONTATO.IDCONTATO
		AND CONTATO.IDTIPOARVORE = (SELECT IDTIPOARVORE
                                      FROM APOIO.TIPOARVORE
                                     WHERE DSTIPOARVORE = 'ÁRVORE DE CONTATOS')
        START WITH
            HIERARQUIA.IDCONTATOPAI = :stContatoRaiz.stidContato
        CONNECT BY
            HIERARQUIA.IDCONTATOPAI = PRIOR HIERARQUIA.IDCONTATO;

      EXEC SQL WHENEVER NOT FOUND DO break;
      EXEC SQL OPEN readContato;
      for(;;)
      {
         memset( &stContatoRegistro, 0, sizeof(stContatoRegistro) );
         memset( &stContatoIndicator, -1, sizeof(stContatoIndicator) );

         EXEC SQL FETCH readContato INTO :stContatoRegistro:stContatoIndicator;

         Add((char*)stContatoRegistro.stidContato.arr,
            (char*)stContatoRegistro.stidContatoPai.arr,
            (char*)stContatoRegistro.stidNomeContato.arr,
            (char*)stContatoRegistro.stnmContato.arr,
            (char*)stContatoRegistro.stinDisponibilidade.arr,
            (char*)stContatoRegistro.stdsPath.arr,
            stContatoRegistro.iLevel,
            stContatoRegistro.iFolha,
            "");
         iCont++;
      }
      EXEC SQL CLOSE readContato;
      
      ULOG_START("CContato::ListaSemContato)");
      
      return iCont;
   }
   catch(...)
   {
      throw;
   }

SemContatoError:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);

}

void CContato::GetXmlWF( char* cNomeTag, char *cidTpRelacionamento, int idContatoAux,XMLGen*xml )
{
   CContato     oContato;
   char        *idContato;
   char         idTpRetorno[ 23 ];
   char         UrlInf[256];
   bool         flagTAG = false;


   int idTpRelac = atoi( cidTpRelacionamento );
   idTpRetorno[0] = 0x0;
   UrlInf[0] = 0x0;

   strcpy( idTpRetorno,"0" );

	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
         if ( idContatoAux > 0 )
            flagTAG = true;
         
         if ( flagTAG == true )
         {
			   xml->createTag(cNomeTag);
            idContatoAux = 1;
         }

//         if ( x == 0 )
//            xml->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{ 
            idContato = Registro(x)->cidContato;
            oContato.TpRetorno( idContato, idTpRelac, idTpRetorno );
            oContato.URLInf( idContato, UrlInf );
				xml->addItem("idContato", Registro(x)->cidContato );
				xml->addItem("idNomeContato", Registro(x)->cidNomeContato );
				xml->addItem("nmContato", Registro(x)->cnmContato );
				xml->addItem("inDisponibilidade", Registro(x)->cinDisponibilidade ); 
				xml->addItem("nrNivel", Registro(x)->cdsPath ); 
				xml->addItem("inFolha", ( Registro(x)->iFolha ? 1 : 0 ) );
            xml->addItem("inRelacionamento", idTpRetorno );
            if ( strlen(UrlInf) > 0 )
            {
               xml->createTag("AdmContatoInformacaoVO");
                  xml->addItem("nmURLContatoInformacao", UrlInf );
               xml->closeTag();
            }
			}
         if ( flagTAG == true )
         {
   			xml->closeTag();
            flagTAG = true;
         }
         else
         {
            idContatoAux = 1;
            flagTAG = true;
         }
		}
	}
}

int CContato::ListaSemGrupo( 
                              char *idContatoParam, 
                              char* cidUFOperadora ,
                              char* cidTipoLinha ,
                              char* cidTipoCarteira ,
                              char* cidSegmentacao 
                           )
{
    ULOG_START("CContato::ListaSemGrupo)");
    int iCont = 0;
    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;
   
      int idContatoWrk = atoi( idContatoParam );
 
      char* cAuxidUFOperadora = cidUFOperadora;
      char  cAuxidTipoLinha[21+1];
      char  cAuxidTipoCarteira[21+1];
      char  cAuxidSegmentacao[21+1];

      struct
      {
         VARCHAR stidContato[21+1];
         VARCHAR stidNomeContato[21+1];
         VARCHAR stnmContato[255+1];
         VARCHAR stinDisponibilidade[21+1];
         int     iLevel;
         VARCHAR stidContatoPai[21+1];
         VARCHAR stdsPath[1024+1];
         int     iFolha;
      } stContatoRegistro;
      struct
      {
         short iidContato;
         short iidNomeContato;
         short inmContato;
         short iinDisponibilidade;
         short iLevel;
         short iidContatoPai;
         short idsPath;
         short iiFolha;
      } stContatoIndicator;
      struct
      {
         VARCHAR stidContato[21+1];
         VARCHAR stidNomeContato[21+1];
         VARCHAR stnmContato[255+1];
         VARCHAR stinDisponibilidade[21+1];
      } stContatoRaiz;
      struct
      {
         short iidContato;
         short iidNomeContato;
         short inmContato;
         short iinDisponibilidade;
      } stContatoRaizIndicator;
   EXEC SQL END DECLARE SECTION;


   memset( &cAuxidTipoLinha, 0, sizeof( cAuxidTipoLinha ) );
   memset( &cAuxidTipoCarteira, 0, sizeof( cAuxidTipoCarteira ) );
   memset( &cAuxidSegmentacao, 0, sizeof( cAuxidSegmentacao ) );
   if( strlennull( cidTipoLinha ) <= 0 )
      strcpy( cAuxidTipoLinha, "-1" );
   else
      strcpy( cAuxidTipoLinha, cidTipoLinha );

   if( strlennull( cidTipoCarteira ) <= 0 )
      strcpy( cAuxidTipoCarteira, "-1" );
   else
      strcpy( cAuxidTipoCarteira, cidTipoCarteira );

   if( strlennull( cidSegmentacao ) <= 0 )
      strcpy( cAuxidSegmentacao, "-1" );
   else
      strcpy( cAuxidSegmentacao, cidSegmentacao );

   ZeraContato();
   
   
   memset( &stContatoRaiz, 0, sizeof( stContatoRaiz ) );

   EXEC SQL WHENEVER NOT FOUND CONTINUE;
   EXEC SQL WHENEVER SQLERROR GOTO GotoListaSemGrupo;
   sqlca.sqlcode=0;

	/* remoção de views bzeroum -- cassio -- jun/2007
   EXEC SQL
      SELECT CONTATO.IDCONTATO,
             CONTATO.IDNOMECONTATO,
             CONTATO.NMCONTATO NMCONTATO,
             CONTATO.INDISPONIBILIDADE
        INTO :stContatoRaiz:stContatoRaizIndicator
        FROM CONTATOADM.CONTATObzeroum CONTATO
       WHERE CONTATO.IDCONTATO NOT IN
             (SELECT IDCONTATO
                FROM CONTATOADM.CONTATOHIERARQUIA
               WHERE CONTATOHIERARQUIAB0.IDCONTATO = :idContatoWrk)
         AND ROWNUM <= 1;
    */

	EXEC SQL
		SELECT
			CONTATO.IDCONTATO,
			CONTATO.IDNOMECONTATO,
			NOMECONTATO.NMCONTATO,
			CONTATO.INDISPONIBILIDADE
		INTO
			:stContatoRaiz:stContatoRaizIndicator
		FROM
			CONTATOADM.CONTATO CONTATO,
			CONTATOADM.NOMECONTATO NOMECONTATO
		WHERE 
			CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO  
		AND CONTATO.IDCONTATO NOT IN (SELECT CONTATOHIERARQUIA.IDCONTATO
										FROM CONTATOADM.CONTATOHIERARQUIA
									   WHERE CONTATOHIERARQUIA.IDCONTATO = :idContatoWrk)
		AND ROWNUM < 2;

   Add((char*)stContatoRaiz.stidContato.arr,
       "",
      (char*)stContatoRaiz.stidNomeContato.arr,
      (char*)stContatoRaiz.stnmContato.arr,
      (char*)stContatoRaiz.stinDisponibilidade.arr,
       "",
      0,
	  0,
      "");
   iCont++;
  
   //Cursor para recuperar a arvore
    EXEC SQL WHENEVER NOT FOUND DO break;

	EXEC SQL DECLARE ReadContatoGrupo CURSOR FOR

        SELECT 
            HIERARQUIA.IDCONTATO,
            HIERARQUIA.IDNOMECONTATO,
            HIERARQUIA.NMCONTATO NMCONTATO,
            HIERARQUIA.INDISPONIBILIDADE,
            LEVEL,
            HIERARQUIA.IDCONTATOPAI,
            SYS_CONNECT_BY_PATH(REPLACE(HIERARQUIA.NMCONTATO, '/', '\' ), '/') AS "PATH",
            DECODE(IDCONTATOFOLHA, NULL, 0, 1 )
        FROM 
            CONTATOADM.CONTATOHIERARQUIAV01 HIERARQUIA,
			CONTATOADM.CONTATO CONTATO
        WHERE 
            HIERARQUIA.IDCONTATOPAI = :stContatoRaiz.stidContato
		AND HIERARQUIA.IDCONTATO = CONTATO.IDCONTATO
		AND CONTATO.IDTIPOARVORE = (SELECT IDTIPOARVORE 
                                      FROM APOIO.TIPOARVORE 
                                     WHERE DSTIPOARVORE = 'ÁRVORE DE CONTATOS')
        START WITH
            HIERARQUIA.IDCONTATOPAI = :stContatoRaiz.stidContato
        CONNECT BY
            HIERARQUIA.IDCONTATOPAI = PRIOR HIERARQUIA.IDCONTATO;

    EXEC SQL OPEN ReadContatoGrupo;

    if(sqlca.sqlcode)
      return 0;
    else
   {
      for(;;)
      {
         memset( &stContatoRegistro, 0, sizeof(stContatoRegistro) );
		 memset( &stContatoIndicator, -1, sizeof(stContatoIndicator) );

         EXEC SQL FETCH ReadContatoGrupo INTO :stContatoRegistro:stContatoIndicator;
         Add((char*)stContatoRegistro.stidContato.arr,
            (char*)stContatoRegistro.stidContatoPai.arr,
            (char*)stContatoRegistro.stidNomeContato.arr,
            (char*)stContatoRegistro.stnmContato.arr,
            (char*)stContatoRegistro.stinDisponibilidade.arr,
            (char*)stContatoRegistro.stdsPath.arr,
            stContatoRegistro.iLevel,
            stContatoRegistro.iFolha,
            "");
         iCont++;
      }
      EXEC SQL CLOSE ReadContatoGrupo;
   }

    ULOG_END("CContato::ListaSemGrupo)");
    if(sqlca.sqlcode)
      return 0;
    else
      return iCont;

GotoListaSemGrupo:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);

}


int CContato::ListaComGrupo( 
                              char *idGrupoParam ,
                              char* cidUFOperadora ,
                              char* cidTipoLinha ,
                              char* cidTipoCarteira ,
                              char* cidSegmentacao 
                           )
{
 
   ULOG_START("CContato::ListaComGrupo)");    
   int iCont = 0;
   struct sqlca sqlca;
   
   EXEC SQL BEGIN DECLARE SECTION;
   
      int idContatoWrk;
      int idGrupoWrk = atoi( idGrupoParam );
 
      char* cAuxidUFOperadora = cidUFOperadora;
      char  cAuxidTipoLinha[21+1];
      char  cAuxidTipoCarteira[21+1];
      char  cAuxidSegmentacao[21+1];
     
      struct
      {
         VARCHAR stidContato[21+1];
         VARCHAR stidNomeContato[21+1];
         VARCHAR stnmContato[255+1];
         VARCHAR stinDisponibilidade[21+1];
         int     iLevel;
         VARCHAR stidContatoPai[21+1];
         VARCHAR stdsPath[1024+1];
         int     iFolha;
      } stContatoRegistro;
      struct
      {
         short iidContato;
         short iidNomeContato;
         short inmContato;
         short iinDisponibilidade;
         short iLevel;
         short iidContatoPai;
         short idsPath;
         short iiFolha;
      } stContatoIndicator;
      struct
      {
         VARCHAR stidContato[21+1];
         VARCHAR stidNomeContato[21+1];
         VARCHAR stnmContato[255+1];
         VARCHAR stinDisponibilidade[21+1];
      } stContatoRaiz;
      struct
      {
         short iidContato;
         short iidNomeContato;
         short inmContato;
         short iinDisponibilidade;
      } stContatoRaizIndicator;
   EXEC SQL END DECLARE SECTION;


   memset( &cAuxidTipoLinha, 0, sizeof( cAuxidTipoLinha ) );
   memset( &cAuxidTipoCarteira, 0, sizeof( cAuxidTipoCarteira ) );
   memset( &cAuxidSegmentacao, 0, sizeof( cAuxidSegmentacao ) );
   if( strlennull( cidTipoLinha ) <= 0 )
      strcpy( cAuxidTipoLinha, "-1" );
   else
      strcpy( cAuxidTipoLinha, cidTipoLinha );

   if( strlennull( cidTipoCarteira ) <= 0 )
      strcpy( cAuxidTipoCarteira, "-1" );
   else
      strcpy( cAuxidTipoCarteira, cidTipoCarteira );

   if( strlennull( cidSegmentacao ) <= 0 )
      strcpy( cAuxidSegmentacao, "-1" );
   else
      strcpy( cAuxidSegmentacao, cidSegmentacao );

   ZeraContato();
   memset( &stContatoRaiz, 0, sizeof( stContatoRaiz ) );

   EXEC SQL WHENEVER NOT FOUND CONTINUE;
   EXEC SQL WHENEVER SQLERROR GOTO GotoListaComGrupo;
   sqlca.sqlcode=0;
   
   //Recupera a raiz da arvore
	/* remoção de views bzeroum -- cassio -- jun/2007
    EXEC SQL
      SELECT CONTATO.IDCONTATO,
             CONTATO.IDNOMECONTATO,
             CONTATO.NMCONTATO NMCONTATO,
             CONTATO.INDISPONIBILIDADE
        INTO :stContatoRaiz:stContatoRaizIndicator
        FROM CONTATOADM.CONTATObzeroum CONTATO
       WHERE CONTATO.IDCONTATO NOT IN
             (SELECT IDCONTATO
                FROM CONTATOADM.CONTATOHIERARQUIA
               WHERE CONTATOHIERARQUIAB0.IDCONTATO > 0)
         AND ROWNUM <= 1;
    */

	EXEC SQL
		SELECT
			CONTATO.IDCONTATO,
			CONTATO.IDNOMECONTATO,
			NOMECONTATO.NMCONTATO,
			CONTATO.INDISPONIBILIDADE
		INTO
			:stContatoRaiz:stContatoRaizIndicator
		FROM
			CONTATOADM.CONTATO CONTATO,
			CONTATOADM.NOMECONTATO NOMECONTATO
		WHERE 
			CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO  
		AND CONTATO.IDCONTATO NOT IN (SELECT CONTATOHIERARQUIA.IDCONTATO
										FROM CONTATOADM.CONTATOHIERARQUIA
									   WHERE CONTATOHIERARQUIA.IDCONTATO > 0)
		AND ROWNUM < 2;

   Add((char*)stContatoRaiz.stidContato.arr,
       "",
      (char*)stContatoRaiz.stidNomeContato.arr,
      (char*)stContatoRaiz.stnmContato.arr,
      (char*)stContatoRaiz.stinDisponibilidade.arr,
       "",
      0,
	  0,
      "");

   iCont++;
   idContatoWrk = atoi((char *)stContatoRaiz.stidContato.arr);

   //Cursor para recuperar a arvore
   EXEC SQL WHENEVER NOT FOUND DO break;
   
	EXEC SQL 
		DECLARE 
			ReadListaComGrupo CURSOR FOR
      SELECT DISTINCT
          HIERARQUIA.IDCONTATO
         ,HIERARQUIA.IDNOMECONTATO
         ,HIERARQUIA.NMCONTATO NMCONTATO
         ,HIERARQUIA.INDISPONIBILIDADE
         ,LEVEL
         ,HIERARQUIA.IDCONTATOPAI
         ,'1' "PATH"
         ,DECODE(IDCONTATOFOLHA, NULL, 0, 1 )
      FROM 
         CONTATOADM.CONTATOHIERARQUIAV01 HIERARQUIA
      WHERE 
         HIERARQUIA.IDCONTATOPAI = :idContatoWrk
      START WITH 
         HIERARQUIA.IDCONTATO
      IN 
         ( SELECT 
               IDCONTATO 
           FROM
               CONTATOADM.CONTATOFILTROV01
           WHERE 
               IDGRUPO = :idGrupoWrk
           AND 
               IDUFOPERADORA = :cAuxidUFOperadora
           AND 
              ( IDTIPOLINHA = :cAuxidTipoLinha OR :cAuxidTipoLinha = '-1' )
           AND 
              ( IDTIPOCARTEIRA = :cAuxidTipoCarteira OR :cAuxidTipoCarteira = '-1' )
           AND 
              ( IDSEGMENTACAO = :cAuxidSegmentacao OR :cAuxidSegmentacao = '-1' )
         )
         CONNECT BY PRIOR 
            HIERARQUIA.IDCONTATOPAI = HIERARQUIA.IDCONTATO
         ORDER BY LEVEL DESC;

   EXEC SQL OPEN ReadListaComGrupo;

   if(sqlca.sqlcode)
      return 0;
   else
   {
      for(;;)
      {
         memset( &stContatoRegistro, 0, sizeof(stContatoRegistro) );
		 memset( &stContatoIndicator, -1, sizeof(stContatoIndicator) );

         EXEC SQL FETCH ReadListaComGrupo INTO :stContatoRegistro:stContatoIndicator;
         Add((char*)stContatoRegistro.stidContato.arr,
            (char*)stContatoRegistro.stidContatoPai.arr,
            (char*)stContatoRegistro.stidNomeContato.arr,
            (char*)stContatoRegistro.stnmContato.arr,
            (char*)stContatoRegistro.stinDisponibilidade.arr,
            (char*)stContatoRegistro.stdsPath.arr,
            stContatoRegistro.iLevel,
            stContatoRegistro.iFolha,
            "");
         iCont++;
      }
      EXEC SQL CLOSE ReadListaComGrupo;
   }
   ULOG_START("CContato::ListaComGrupo)");    
   
   if(sqlca.sqlcode)
      return 0;
   else
      return iCont;

GotoListaComGrupo:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);

}


int CContato::ListaComContato( 
                                 char *idContatoParam, 
                                 char *idGrupoParam ,
                                 char* cidUFOperadora ,
                                 char* cidTipoLinha ,
                                 char* cidTipoCarteira ,
                                 char* cidSegmentacao 
                             )
{
   ULOG_START("CContato::ListaComContato)");    
   int iCont = 0;
   struct sqlca sqlca;
   EXEC SQL BEGIN DECLARE SECTION;
   
      int idContatoWrk = atoi( idContatoParam );
      int idGrupoWrk = atoi( idGrupoParam );
 
      char* cAuxidUFOperadora = cidUFOperadora;
      char  cAuxidTipoLinha[21+1];
      char  cAuxidTipoCarteira[21+1];
      char  cAuxidSegmentacao[21+1];
     
      struct
      {
         VARCHAR stidContato[21+1];
         VARCHAR stidNomeContato[21+1];
         VARCHAR stnmContato[255+1];
         VARCHAR stinDisponibilidade[21+1];
         int     iLevel;
         VARCHAR stidContatoPai[21+1];
         VARCHAR stdsPath[1024+1];
         int     iFolha;
      } stContatoRegistro;
      struct
      {
         short iidContato;
         short iidNomeContato;
         short inmContato;
         short iinDisponibilidade;
         short iLevel;
         short iidContatoPai;
         short idsPath;
         short iiFolha;
      } stContatoIndicator;
      struct
      {
         VARCHAR stidContato[21+1];
         VARCHAR stidNomeContato[21+1];
         VARCHAR stnmContato[255+1];
         VARCHAR stinDisponibilidade[21+1];
      } stContatoRaiz;
      //struct
      //{
      //   short iidContato;
      //   short iidNomeContato;
      //   short inmContato;
      //   short iinDisponibilidade;
      //} stContatoRaizIndicator;
   EXEC SQL END DECLARE SECTION;

   memset( &cAuxidTipoLinha, 0, sizeof( cAuxidTipoLinha ) );
   memset( &cAuxidTipoCarteira, 0, sizeof( cAuxidTipoCarteira ) );
   memset( &cAuxidSegmentacao, 0, sizeof( cAuxidSegmentacao ) );

   if( strlennull( cidTipoLinha ) <= 0 )
      strcpy( cAuxidTipoLinha, "-1" );
   else
      strcpy( cAuxidTipoLinha, cidTipoLinha );

   if( strlennull( cidTipoCarteira ) <= 0 )
      strcpy( cAuxidTipoCarteira, "-1" );
   else
      strcpy( cAuxidTipoCarteira, cidTipoCarteira );

   if( strlennull( cidSegmentacao ) <= 0 )
      strcpy( cAuxidSegmentacao, "-1" );
   else
      strcpy( cAuxidSegmentacao, cidSegmentacao );

   ZeraContato();
   memset( &stContatoRaiz, 0, sizeof( stContatoRaiz ) );

   EXEC SQL WHENEVER NOT FOUND CONTINUE;
   EXEC SQL WHENEVER SQLERROR GOTO GotoListaComContato;
   sqlca.sqlcode=0;
   
   //Cursor para recuperar a arvore
   EXEC SQL WHENEVER NOT FOUND DO break;
   
	EXEC SQL 
		DECLARE 
			ReadComContatos CURSOR FOR
      SELECT DISTINCT
          HIERARQUIA.IDCONTATO
         ,HIERARQUIA.IDNOMECONTATO
         ,HIERARQUIA.NMCONTATO NMCONTATO
         ,HIERARQUIA.INDISPONIBILIDADE
         ,LEVEL
         ,HIERARQUIA.IDCONTATOPAI
         ,'1' "PATH"
         ,DECODE(IDCONTATOFOLHA, NULL, 0, 1 )
      FROM 
         CONTATOADM.CONTATOHIERARQUIAV01 HIERARQUIA
      WHERE 
         HIERARQUIA.IDCONTATOPAI = :idContatoWrk
      START WITH 
         HIERARQUIA.IDCONTATO
      IN 
         ( SELECT 
               IDCONTATO 
           FROM
               CONTATOADM.CONTATOFILTROV01
           WHERE 
               IDGRUPO = :idGrupoWrk
           AND 
               IDUFOPERADORA = :cAuxidUFOperadora
           AND 
              ( IDTIPOLINHA = :cAuxidTipoLinha OR :cAuxidTipoLinha = '-1' )
           AND 
              ( IDTIPOCARTEIRA = :cAuxidTipoCarteira OR :cAuxidTipoCarteira = '-1' )
           AND 
              ( IDSEGMENTACAO = :cAuxidSegmentacao OR :cAuxidSegmentacao = '-1' )
         )
         CONNECT BY PRIOR 
            HIERARQUIA.IDCONTATOPAI = HIERARQUIA.IDCONTATO
         ORDER BY LEVEL DESC;

   EXEC SQL OPEN ReadComContatos;

   if(sqlca.sqlcode)
      return 0;
   else
   {
      for(;;)
      {
         memset( &stContatoRegistro, 0, sizeof(stContatoRegistro) );
		 memset( &stContatoIndicator, -1, sizeof(stContatoIndicator) );

         EXEC SQL FETCH ReadComContatos INTO :stContatoRegistro:stContatoIndicator;
         Add((char*)stContatoRegistro.stidContato.arr,
            (char*)stContatoRegistro.stidContatoPai.arr,
            (char*)stContatoRegistro.stidNomeContato.arr,
            (char*)stContatoRegistro.stnmContato.arr,
            (char*)stContatoRegistro.stinDisponibilidade.arr,
            (char*)stContatoRegistro.stdsPath.arr,
            stContatoRegistro.iLevel,
            stContatoRegistro.iFolha,
            "");
         iCont++;
      }
      EXEC SQL CLOSE ReadComContatos;
   }
   ULOG_END("CContato::ListaComContato)");    
   if(sqlca.sqlcode)
      return 0;
   else
      return iCont;

GotoListaComContato:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);

}

void CContato::TpRetorno( char *idContatoParam, int idTpRetornoParam, char * Saida )
{
   struct sqlca sqlca;
   EXEC SQL BEGIN DECLARE SECTION;
      int idTpRetornoWrk = idTpRetornoParam;
      int idContatoWrk = atoi( idContatoParam );

      int Retorno;
   EXEC SQL END DECLARE SECTION;
  
   EXEC SQL WHENEVER SQLERROR GOTO ErroTpRetorno;
   EXEC SQL WHENEVER NOT FOUND CONTINUE;
   EXEC SQL
      SELECT 
	         COUNT(*)
      INTO
            :Retorno 
      FROM 
	       CONTATOADM.CONTATOTIPORELACIONAMENTO A,
	       CONTATOADM.CONTATO B
      WHERE
	       A.IDCONTATO = B.IDCONTATO
      and
	       A.IDCONTATO = :idContatoWrk
      AND
           A.IDTIPORELACIONAMENTO = :idTpRetornoWrk;

   if ( Retorno > 0 )
      strcpy( Saida,"1" );
   else
      strcpy( Saida,"0" );

   return;

ErroTpRetorno:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);

}


void CContato::URLInf( char *idContatoParam, char * Saida )
{
    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;
        int idContatoWrk = atoi( idContatoParam );
        VARCHAR  OraURL[ 256 ];

        short i_OraURL;
    EXEC SQL END DECLARE SECTION;
  
    EXEC SQL WHENEVER SQLERROR GOTO ErroTpRetorno;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL
        SELECT
	        NMURLCONTATOINFORMACAO
        INTO
            :OraURL:i_OraURL
        FROM
            CONTATOADM.CONTATOINFORMACAO
        WHERE
	        IDCONTATO = :idContatoWrk;

    if ( i_OraURL < 0 )
        return;

    OraURL.arr[OraURL.len] = 0x0;

    strcpy( Saida,(char *)OraURL.arr );

    return;

ErroTpRetorno:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);

}


void CContato::ObterTipoProcesso( const char *idContatoParam, char *dsTipoProcessoParam )
{
    ULOG_START("ObterTipoProcesso( const char *idContatoParam, char *dsTipoProcessoParam )");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        const char *OraIdContato = idContatoParam;
        VARCHAR OraDsTipoProcesso[256];
        short StatOraDsTipoProcesso = -1;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR GOTO ErroTpRetorno;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        SELECT
            DSTIPOPROCESSO
        INTO
            :OraDsTipoProcesso:StatOraDsTipoProcesso
        FROM
            CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
            WORKFLOW.TIPOPROCESSO TIPOPROCESSO
        WHERE
            CONTATOFOLHA.IDTIPOPROCESSO = TIPOPROCESSO.IDTIPOPROCESSO
        AND CONTATOFOLHA.IDCONTATO = :OraIdContato;

    if ( sqlca.sqlcode == 0 )
    {
        CONVIND(OraDsTipoProcesso,StatOraDsTipoProcesso);
        strcpy(dsTipoProcessoParam,(char*)OraDsTipoProcesso.arr);
    }
    else
    {
        *dsTipoProcessoParam = 0;
    }

    ULOG("sqlcode=%d",sqlca.sqlcode);
    ULOG("idContato='%s'",OraIdContato);
    ULOG("dsTipoProcesso='%s'",(char*)OraDsTipoProcesso.arr);

    ULOG_END("ObterTipoProcesso( const char *idContatoParam, char *dsTipoProcessoParam )");

    return;

ErroTpRetorno:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}

void CContato::HabilitarContato( const char *idContatoParam,const char* cidUser )
{
    ULOG_START("HabilitarContato( const char *idContatoParam,const char* cidUser )");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        const char *OraIdContato = idContatoParam;
        const char *cOraIdUser = cidUser;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR GOTO ErroHabilitarContato;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    ULOG("idContato =%s",OraIdContato);

    EXEC SQL
		UPDATE CONTATOADM.CONTATO
		   SET INDISPONIBILIDADE = 1
			  ,IDUSUARIOALTERACAO = :cOraIdUser
			  ,DTULTIMAALTERACAO = SYSDATE
		 WHERE IDCONTATO = :OraIdContato
         AND INDISPONIBILIDADE <> 1;

    ULOG_END("HabilitarContato( const char *idContatoParam,const char* cidUser )");

    return;

ErroHabilitarContato:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}