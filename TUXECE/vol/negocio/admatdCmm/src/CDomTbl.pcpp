#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CDomTbl.h"

CTabelaDominio::CTabelaDominio()
{
}

CTabelaDominio::~CTabelaDominio()
{
}

int CTabelaDominio::ListId( char* cidTabelaDominio ) 
{
    ULOG_START("CTabelaDominio::ListId()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidTabelaDominio = cidTabelaDominio; 
		struct
		{
			VARCHAR stidTabelaDominio[21+1];
			VARCHAR stnmTabelaDominio[255+1];
		} stTabelaDominioRegistro;
		struct
		{
			short iidTabelaDominio;
			short inmTabelaDominio;
		} stTabelaDominioIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraTabelaDominio();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL DECLARE CursorTabelaDominioId CURSOR FOR 
   		SELECT 	idTabelaDominio,
	nmTabelaDominio
		FROM contatoadm.TabelaDominio
		WHERE idTabelaDominio = :cAuxidTabelaDominio;

		//Abre o cursor
		EXEC SQL OPEN CursorTabelaDominioId;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CTabelaDominio::ListId()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stTabelaDominioRegistro, 0, sizeof(stTabelaDominioRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorTabelaDominioId INTO :stTabelaDominioRegistro:stTabelaDominioIndicator;
				//Adiciona a classe
				Add( 	(char*)stTabelaDominioRegistro.stidTabelaDominio.arr,
				(char*)stTabelaDominioRegistro.stnmTabelaDominio.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorTabelaDominioId;
		}
		ULOG_END("CTabelaDominio::ListId()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CTabelaDominio::ListByName( char* cnmTabelaDominio ) 
{
    ULOG_START("CTabelaDominio::ListByName()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxnmTabelaDominio = cnmTabelaDominio; 
		struct
		{
			VARCHAR stidTabelaDominio[21+1];
			VARCHAR stnmTabelaDominio[255+1];
		} stTabelaDominioRegistro;
		struct
		{
			short iidTabelaDominio;
			short inmTabelaDominio;
		} stTabelaDominioIndicator;
	EXEC SQL END DECLARE SECTION;
	if(cnmTabelaDominio!=NULL)
	{
		sprintf(cAuxnmTabelaDominio,"%.*s%%",255,cnmTabelaDominio);
	}
	else
	{
		cAuxnmTabelaDominio = "%";
	}

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraTabelaDominio();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL DECLARE CursorTabelaDominioByName CURSOR FOR 
   		SELECT 	idTabelaDominio,
				nmTabelaDominio
		FROM 
			contatoadm.TabelaDominio
		WHERE 
			UPPER(nmTabelaDominio) LIKE UPPER(:cAuxnmTabelaDominio)
		ORDER BY
			nmTabelaDominio;

		//Abre o cursor
		EXEC SQL OPEN CursorTabelaDominioByName;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CTabelaDominio::ListByName()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stTabelaDominioRegistro, 0, sizeof(stTabelaDominioRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorTabelaDominioByName INTO :stTabelaDominioRegistro:stTabelaDominioIndicator;
				//Adiciona a classe
				Add( 	(char*)stTabelaDominioRegistro.stidTabelaDominio.arr,
				(char*)stTabelaDominioRegistro.stnmTabelaDominio.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorTabelaDominioByName;
		}
		ULOG_END("CTabelaDominio::ListByName()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CTabelaDominio::ListAll( void )
{
    ULOG_START("CTabelaDominio::ListAll()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidTabelaDominio[21+1];
			VARCHAR stnmTabelaDominio[255+1];
		} stTabelaDominioRegistro;
		struct
		{
			short iidTabelaDominio;
			short inmTabelaDominio;
		} stTabelaDominioIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraTabelaDominio();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL DECLARE CursorTabelaDominioAll CURSOR FOR
   		SELECT 	idTabelaDominio,
		nmTabelaDominio
		FROM contatoadm.TabelaDominio; 

		//Abre o cursor
		EXEC SQL OPEN CursorTabelaDominioAll;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CTabelaDominio::ListAll()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stTabelaDominioRegistro, 0, sizeof(stTabelaDominioRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorTabelaDominioAll INTO :stTabelaDominioRegistro:stTabelaDominioIndicator;
				//Adiciona a classe
				Add( 	(char*)stTabelaDominioRegistro.stidTabelaDominio.arr,
				(char*)stTabelaDominioRegistro.stnmTabelaDominio.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorTabelaDominioAll;
		}
		ULOG_END("CTabelaDominio::ListAll()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CTabelaDominio::GetXml( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			xml->createTag(cNomeTag);
			//Adiciona a proprieda necessaria para o Weblogic
			//xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idTabelaDominio", Registro(x)->cidTabelaDominio );
				xml->addItem("nmTabelaDominio", Registro(x)->cnmTabelaDominio ); 
			}
			//So fecha um tag se abriu anteriormente
			xml->closeTag();
		}
	}
}

int CTabelaDominio::Insert(
					 char* cnmTabelaDominio
					,char* cidUser
	 )
{
    ULOG_START("CTabelaDominio::Insert()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidUserAux = cidUser;
		VARCHAR stidTabelaDominio[21+1];
		char* cnmTabelaDominioAux = cnmTabelaDominio;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );
	memset( &stidTabelaDominio, 0, sizeof( stidTabelaDominio ) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;

	//Recupera um id unico
	EXEC SQL
	SELECT 
		CONTATOADM.TABELADOMINIOSQ.NEXTVAL
	INTO
		:stidTabelaDominio
	FROM
		DUAL;

	//Insere um registro
	EXEC SQL 
	INSERT INTO CONTATOADM.TABELADOMINIO
	( 
		 IDTABELADOMINIO
		,NMTABELADOMINIO
		,IDUSUARIOALTERACAO
		,DTULTIMAALTERACAO
	)
	VALUES 
	( 
		:stidTabelaDominio
		,:cnmTabelaDominioAux
		,:cidUserAux
		,SYSDATE 
	);

	//Salva o registro na estrutura interna
	Add(
		 (char*)stidTabelaDominio.arr
		,cnmTabelaDominio
	);
    ULOG_END("CTabelaDominio::Insert()");
	return 1;

GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CTabelaDominio::Update(
					 char* cidTabelaDominio
					,char* cnmTabelaDominio
					,char* cidUser
	 ) 
{
    ULOG_START("CTabelaDominio::Update()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidUserAux = cidUser;
		char* cidTabelaDominioAux = cidTabelaDominio;
		char* cnmTabelaDominioAux = cnmTabelaDominio;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;

	//Atualiza um registro
	EXEC SQL 
	UPDATE 
		CONTATOADM.TABELADOMINIO
	SET 
		 NMTABELADOMINIO = :cnmTabelaDominioAux
		,IDUSUARIOALTERACAO = :cidUserAux
		,DTULTIMAALTERACAO = SYSDATE
	WHERE
		IDTABELADOMINIO = :cidTabelaDominioAux;

	//Salva o registro na estrutura interna
	Add(
		 cidTabelaDominio
		,cnmTabelaDominio
	);

    ULOG_END("CTabelaDominio::Update()");
	return 1;

GotoUpdate:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CTabelaDominio::Delete( 
					 char* cidTabelaDominio
				  ) 
{
    ULOG_START("CTabelaDominio::Delete()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidTabelaDominioAux = cidTabelaDominio;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;

	//Apaga um registro
	EXEC SQL 
	DELETE FROM 
		CONTATOADM.TABELADOMINIO
	WHERE 
		IDTABELADOMINIO = :cidTabelaDominioAux;
		
    ULOG_END("CTabelaDominio::Delete()");
	return 1;

GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if(sqlca.sqlcode == -2292)
	{
		return -2;
	}
	throw TuxBasicOraException(sqlca.sqlcode);
}