#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CDom.h"

CDominio::CDominio()
{
}

CDominio::~CDominio()
{
}

int CDominio::ListId( char* cidDominio ) 
{
    ULOG_START("CDominio::ListId()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidDominio = cidDominio; 
		struct
		{
			VARCHAR stidDominio[21+1];
			VARCHAR stidTabelaDominio[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stidTipoLinha[21+1];
			VARCHAR stnmDominio[255+1];
			VARCHAR stinDisponibilidade[21+1];
		} stDominioRegistro;
		struct
		{
			short iidDominio;
			short iidTabelaDominio;
			short iidUFOperadora;
			short iidTipoLinha;
			short inmDominio;
			short iinDisponibilidade;
		} stDominioIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraDominio();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL DECLARE CursorDominioId CURSOR FOR 
   		SELECT 	idDominio,
	            idTabelaDominio,
	            idUFOperadora,
	            idTipoLinha,
	            nmDominio,
	            inDisponibilidade
		FROM contatoadm.Dominio
		WHERE idDominio = :cAuxidDominio;

		//Abre o cursor
		EXEC SQL OPEN CursorDominioId;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CDominio::ListId()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stDominioRegistro, 0, sizeof(stDominioRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorDominioId INTO :stDominioRegistro:stDominioIndicator;
				//Adiciona a classe
				Add( 	(char*)stDominioRegistro.stidDominio.arr,
				(char*)stDominioRegistro.stidTabelaDominio.arr,
				(char*)stDominioRegistro.stidUFOperadora.arr,
				(char*)stDominioRegistro.stidTipoLinha.arr,
				(char*)stDominioRegistro.stnmDominio.arr,
				(char*)stDominioRegistro.stinDisponibilidade.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorDominioId;
		}
		ULOG_END("CDominio::ListId()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}
int CDominio::ListAllById()
{
    ULOG_START("CDominio::ListAllById()");
	struct sqlca sqlca;
	CDominioItr oCDominioItr;
	int length = Quantidade();
	for(int j=0;j<length;j++){
		oCDominioItr.Add(Registro(j));
	}
	ZeraDominio();
	int    iCont = 0;
	for(int i=0;i<length;i++)
	{
		//Variavel de controle para a quantidade de registros retornada		
		//Variavel de status do oracle para PROC		
		//Declaracao das variaveis para o PROC
		EXEC SQL BEGIN DECLARE SECTION;
			char* cidDominioAux = oCDominioItr.Registro(i)->cidDominio; 
			struct
			{
				VARCHAR stidDominio[21+1];
				VARCHAR stidTabelaDominio[21+1];
				VARCHAR stidUFOperadora[21+1];
				VARCHAR stidTipoLinha[21+1];
				VARCHAR stnmDominio[255+1];
				VARCHAR stinDisponibilidade[21+1];
				VARCHAR stsgTipoLinha[255+1];
				VARCHAR stdsTipoLinha[255+1];
				VARCHAR stdsUFOperadora[255+1];
				VARCHAR stnmTabelaDominio[255+1];
			} stDominioRegistro;
			struct
			{
				short iidDominio;
				short iidTabelaDominio;
				short iidUFOperadora;
				short iidTipoLinha;
				short inmDominio;
				short iinDisponibilidade;
				short isgTipoLinha;
				short idsTipoLinha;
				short idsUFOperadora;
				short inmTabelaDominio;
			} stDominioIndicator;
		EXEC SQL END DECLARE SECTION;

		//Processamento Principal
		try
		{
			//Ativa as acoes decorrentes de erros ORACLE
			EXEC SQL WHENEVER NOT FOUND DO break;
			EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
			sqlca.sqlcode=0;

			//Declara um cursor para listar os IDs
   			EXEC SQL DECLARE CursorListaParID CURSOR FOR 
			SELECT 
				   D.IDDOMINIO,
				   TD.IDTABELADOMINIO,
				   UFO.IDUFOPERADORA,
				   TL.IDTIPOLINHA,
				   D.NMDOMINIO,
				   D.INDISPONIBILIDADE,
				   TL.SGTIPOLINHA,
				   TL.DSTIPOLINHA,
				   UF.SGUF || '-' || P.NMPESSOA AS SGUFOPERADORA,
				   TD.NMTABELADOMINIO
			FROM
				CONTATOADM.DOMINIO D,
				APOIO.TIPOLINHA TL,
				CONTATOADM.TABELADOMINIO TD,
				APOIO.UF UF,
				CUSTOMER.UFOPERADORA UFO,
				CUSTOMER.PESSOADEPARA PDP,
				CUSTOMER.PESSOA P,
				CUSTOMER.OPERADORA O	
			WHERE
				 D.IDTIPOLINHA = TL.IDTIPOLINHA AND
				 D.IDTABELADOMINIO = TD.IDTABELADOMINIO AND
				 UF.IDUF = UFO.IDUF AND
				 P.IDPESSOA = PDP.IDPESSOA AND
				 P.IDUF = UF.IDUF AND
				 O.IDPESSOADEPARAOPERADORA = UFO.IDPESSOADEPARAOPERADORA AND
				 O.IDPESSOADEPARAOPERADORA = PDP.IDPESSOADEPARA	 AND
				 D.IDDOMINIO = :cidDominioAux;

			//Abre o cursor
			EXEC SQL OPEN CursorListaParID;

			//Verifica se nao house erro ORACLE
			if(sqlca.sqlcode)
			{
			    ULOG_END("CDominio::ListAllById()");
				return 0;//Erro
			}
			else
			{
				//Caso inexista registros sair do loop
				EXEC SQL WHENEVER NOT FOUND DO break;
				for(;;)
				{
					//Zera a estrutura de restorno
					memset( &stDominioRegistro, 0, sizeof(stDominioRegistro) );
					//Pega um registro no CURSOR
					EXEC SQL FETCH CursorListaParID INTO :stDominioRegistro:stDominioIndicator;
					//Adiciona a classe							
					Add(
					(char*) stDominioRegistro.stidDominio.arr,
					(char*) stDominioRegistro.stnmDominio.arr,
					(char*) stDominioRegistro.stinDisponibilidade.arr,
					(char*) stDominioRegistro.stidTabelaDominio.arr,
					(char*) stDominioRegistro.stnmTabelaDominio.arr,
					(char*) stDominioRegistro.stidUFOperadora.arr,
					(char*) stDominioRegistro.stdsUFOperadora.arr,
					(char*) stDominioRegistro.stidTipoLinha.arr,
					(char*) stDominioRegistro.stsgTipoLinha.arr,
					(char*) stDominioRegistro.stdsTipoLinha.arr);
					//conta quantos existem
					iCont++;
				}
				//Fecha o CURSOR
				EXEC SQL CLOSE CursorListaParID;
			}
		}
		catch(...)
		{
			throw;
		}
	}
	ULOG_END("CDominio::ListAllById()");
	return iCont;
GotoListId:	
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}
int CDominio::ListPar(char *cidDominio)
{
	return ListPar(cidDominio,
			NULL,
			NULL,
			NULL,
			NULL,
			NULL);
}
int CDominio::ListPar(char *cidDominio,
			char *cnmDominio,
			char *cinDisponibilidade ,
			char *cidUFOperadora,
			char *cidTipoLinha,
			char *cidTabelaDominio)
{
    ULOG_START("CDominio::ListPar()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidDominioAux = cidDominio; 
		char* cnmDominioAux = cnmDominio;
		char* cinDisponibilidadeAux = cinDisponibilidade;
		char* cidUFOperadoraAux = cidUFOperadora;
		char* cidTipoLinhaAux = cidTipoLinha;
		char* cidTabelaDominioAux = cidTabelaDominio;
		struct
		{
			VARCHAR stidDominio[21+1];
			VARCHAR stidTabelaDominio[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stidTipoLinha[21+1];
			VARCHAR stnmDominio[255+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stsgTipoLinha[255+1];
			VARCHAR stdsTipoLinha[255+1];
			VARCHAR stdsUFOperadora[255+1];
			VARCHAR stnmTabelaDominio[255+1];
		} stDominioRegistro;
		struct
		{
			short iidDominio;
			short iidTabelaDominio;
			short iidUFOperadora;
			short iidTipoLinha;
			short inmDominio;
			short iinDisponibilidade;
			short isgTipoLinha;
			short idsTipoLinha;
			short idsUFOperadora;
			short inmTabelaDominio;
		} stDominioIndicator;
	EXEC SQL END DECLARE SECTION;

	if(cidDominioAux == NULL)
	{
		cidDominioAux = "-1";
	}
	if(cnmDominioAux == NULL)
	{
		cnmDominioAux = "-1";
	}
	if(cinDisponibilidadeAux == NULL)
	{
		cinDisponibilidadeAux = "-1";
	}
	if(cidUFOperadoraAux == NULL)
	{
		cidUFOperadoraAux = "-1";
	}
	if(cidTipoLinhaAux == NULL)
	{
		cidTipoLinhaAux = "-1";
	}
	if(cidTabelaDominioAux == NULL)
	{
		cidTabelaDominioAux = "-1";
	}
	if(strcmp(cnmDominioAux,"-1") != 0)
	{
		sprintf(cnmDominioAux,"%.*s%%",255,cnmDominio);
	}

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraDominio();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL DECLARE CursorListaPar CURSOR FOR 
		SELECT 
			   D.IDDOMINIO,
			   TD.IDTABELADOMINIO,
			   UFO.IDUFOPERADORA,
			   TL.IDTIPOLINHA,
			   D.NMDOMINIO,
			   D.INDISPONIBILIDADE,
			   TL.SGTIPOLINHA,
			   TL.DSTIPOLINHA,
			   UF.SGUF || '-' || P.NMPESSOA AS SGUFOPERADORA,
			   TD.NMTABELADOMINIO
		FROM
			CONTATOADM.DOMINIO D,
			APOIO.TIPOLINHA TL,
			CONTATOADM.TABELADOMINIO TD,
			APOIO.UF UF,
			CUSTOMER.UFOPERADORA UFO,
			CUSTOMER.PESSOADEPARA PDP,
			CUSTOMER.PESSOA P,
			CUSTOMER.OPERADORA O	
		WHERE
			 D.IDTIPOLINHA = TL.IDTIPOLINHA AND
			 D.IDTABELADOMINIO = TD.IDTABELADOMINIO AND
			 UF.IDUF = UFO.IDUF AND
			 P.IDPESSOA = PDP.IDPESSOA AND
			 P.IDUF = UF.IDUF AND
			 O.IDPESSOADEPARAOPERADORA = UFO.IDPESSOADEPARAOPERADORA AND
			 O.IDPESSOADEPARAOPERADORA = PDP.IDPESSOADEPARA	 AND
			 (D.IDDOMINIO = :cidDominioAux OR :cidDominioAux = '-1') AND
			 (UPPER(D.NMDOMINIO) LIKE UPPER(:cnmDominioAux) OR :cnmDominioAux = '-1') AND
			 (D.INDISPONIBILIDADE = :cinDisponibilidadeAux OR :cinDisponibilidadeAux = '-1') AND
			 (UFO.IDUFOPERADORA = :cidUFOperadoraAux OR :cidUFOperadoraAux = '-1') AND
			 (TL.IDTIPOLINHA = :cidTipoLinhaAux OR :cidTipoLinhaAux = '-1') AND
			 (TD.IDTABELADOMINIO = :cidTabelaDominioAux OR :cidTabelaDominioAux = '-1')
		ORDER BY
			D.NMDOMINIO;

		//Abre o cursor
		EXEC SQL OPEN CursorListaPar;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CDominio::ListPar()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stDominioRegistro, 0, sizeof(stDominioRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorListaPar INTO :stDominioRegistro:stDominioIndicator;
				//Adiciona a classe		
				Add(
				(char*) stDominioRegistro.stidDominio.arr,
				(char*) stDominioRegistro.stnmDominio.arr,
				(char*) stDominioRegistro.stinDisponibilidade.arr,
				(char*) stDominioRegistro.stidTabelaDominio.arr,
				(char*) stDominioRegistro.stnmTabelaDominio.arr,
				(char*) stDominioRegistro.stidUFOperadora.arr,
				(char*) stDominioRegistro.stdsUFOperadora.arr,
				(char*) stDominioRegistro.stidTipoLinha.arr,
				(char*) stDominioRegistro.stsgTipoLinha.arr,
				(char*) stDominioRegistro.stdsTipoLinha.arr);
				//conta quantos existem
				iCont++;
			}
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorListaPar;
		}
		ULOG_END("CDominio::ListPar()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CDominio::ListTabelaDominio(void)
{
    ULOG_START("CDominio::ListTabelaDominio()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidTabelaDominio[21+1];
			VARCHAR stnmTabelaDominio[255+1];
		} stDominioRegistro;
		struct
		{
			short iidTabelaDominio;
			short inmTabelaDominio;
		} stDominioIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraDominio();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL DECLARE CursorTabelaDominio CURSOR FOR
			SELECT 
				   IDTABELADOMINIO,
				   NMTABELADOMINIO
			FROM 
				 CONTATOADM.TABELADOMINIO
			ORDER BY
				  NMTABELADOMINIO;

		//Abre o cursor
		EXEC SQL OPEN CursorTabelaDominio;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CDominio::ListTabelaDominio()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stDominioRegistro, 0, sizeof(stDominioRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorTabelaDominio INTO :stDominioRegistro:stDominioIndicator;
				//Adiciona a classe
				Add("","","",(char*)stDominioRegistro.stidTabelaDominio.arr,
				(char*)stDominioRegistro.stnmTabelaDominio.arr,
				(char*)"",
				(char*)"",
				(char*)"",
				(char*)"",
				(char*)"");
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorTabelaDominio;
		}
		ULOG_END("CDominio::ListTabelaDominio()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CDominio::ListUFOperadora(void)
{
    ULOG_START("CDominio::ListUFOperadora()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stdsUFOperadora[255+1];
		} stDominioRegistro;
		struct
		{
			short iidUFOperadora;
			short idsUFOperadora;
		} stDominioIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraDominio();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL DECLARE CursorUFOperadora CURSOR FOR
		SELECT
			 UFO.IDUFOPERADORA, UF.SGUF || '-' || P.NMPESSOA AS SGUFOPERADORA
		FROM
			APOIO.UF UF,
			CUSTOMER.UFOPERADORA UFO,
			CUSTOMER.PESSOADEPARA PDP,
			CUSTOMER.PESSOA P,
			CUSTOMER.OPERADORA O
		WHERE
			 UF.IDUF = UFO.IDUF AND
			 P.IDPESSOA = PDP.IDPESSOA AND
			 P.IDUF = UF.IDUF AND
			 O.IDPESSOADEPARAOPERADORA = UFO.IDPESSOADEPARAOPERADORA AND
			 O.IDPESSOADEPARAOPERADORA = PDP.IDPESSOADEPARA
		ORDER BY	  
			 SGUFOPERADORA;

		//Abre o cursor
		EXEC SQL OPEN CursorUFOperadora;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CDominio::ListUFOperadora()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stDominioRegistro, 0, sizeof(stDominioRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorUFOperadora INTO :stDominioRegistro:stDominioIndicator;
				//Adiciona a classe
				Add("","","",(char*)"",
				(char*)"",
				(char*)stDominioRegistro.stidUFOperadora.arr,
				(char*)stDominioRegistro.stdsUFOperadora.arr,
				(char*)"",
				(char*)"",
				(char*)"");
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorUFOperadora;
		}
		ULOG_END("CDominio::ListUFOperadora()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CDominio::ListTipoLinha(void)
{
    ULOG_START("CDominio::ListTipoLinha()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidTipoLinha[21+1];
			VARCHAR stsgTipoLinha[255+1];
			VARCHAR stdsTipoLinha[255+1];
		} stDominioRegistro;
		struct
		{
			short iidTipoLinha;
			short isgTipoLinha;
			short idsTipoLinha;
		} stDominioIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraDominio();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL DECLARE CursorTipoLinha CURSOR FOR
		SELECT 
			   IDTIPOLINHA,
			   SGTIPOLINHA,
			   DSTIPOLINHA
		FROM 
			 APOIO.TIPOLINHA
		WHERE
			 IDTIPOLINHA > 0
		ORDER BY
			  DSTIPOLINHA;

		//Abre o cursor
		EXEC SQL OPEN CursorTipoLinha;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CDominio::ListTipoLinha()");
			return 0;//Erro
		}	
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stDominioRegistro, 0, sizeof(stDominioRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorTipoLinha INTO :stDominioRegistro:stDominioIndicator;
				//Adiciona a classe
				Add("","","",(char*)"",
				(char*)"",
				(char*)"",
				(char*)"",
				(char*)stDominioRegistro.stidTipoLinha.arr,
				(char*)stDominioRegistro.stsgTipoLinha.arr,
				(char*)stDominioRegistro.stdsTipoLinha.arr);
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorTipoLinha;
		}
		ULOG_END("CDominio::ListTipoLinha()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}
int CDominio::ListAll( void )
{
    ULOG_START("CDominio::ListAll()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidDominio[21+1];
			VARCHAR stidTabelaDominio[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stidTipoLinha[21+1];
			VARCHAR stnmDominio[255+1];
			VARCHAR stinDisponibilidade[21+1];
		} stDominioRegistro;
		struct
		{
			short iidDominio;
			short iidTabelaDominio;
			short iidUFOperadora;
			short iidTipoLinha;
			short inmDominio;
			short iinDisponibilidade;
		} stDominioIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraDominio();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL DECLARE CursorDominioAll CURSOR FOR
   		SELECT 	idDominio,
		idTabelaDominio,
		idUFOperadora,
		idTipoLinha,
		nmDominio,
		inDisponibilidade
		FROM contatoadm.Dominio; 

		//Abre o cursor
		EXEC SQL OPEN CursorDominioAll;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CDominio::ListAll()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stDominioRegistro, 0, sizeof(stDominioRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorDominioAll INTO :stDominioRegistro:stDominioIndicator;
				//Adiciona a classe
				Add( 	(char*)stDominioRegistro.stidDominio.arr,
				(char*)stDominioRegistro.stidTabelaDominio.arr,
				(char*)stDominioRegistro.stidUFOperadora.arr,
				(char*)stDominioRegistro.stidTipoLinha.arr,
				(char*)stDominioRegistro.stnmDominio.arr,
				(char*)stDominioRegistro.stinDisponibilidade.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorDominioAll;
		}
		ULOG_END("CDominio::ListAll()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CDominio::GetXml( char* cNomeTag, XMLGen*xml )
{
    
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			xml->createTag(cNomeTag);
			//Adiciona a proprieda necessaria para o Weblogic
			xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idDominio", Registro(x)->cidDominio );
				xml->addItem("idTabelaDominio", Registro(x)->cidTabelaDominio );
				xml->addItem("idUFOperadora", Registro(x)->cidUFOperadora );
				xml->addItem("idTipoLinha", Registro(x)->cidTipoLinha );
				xml->addItem("nmDominio", Registro(x)->cnmDominio );
				xml->addItem("inDisponibilidade", Registro(x)->cinDisponibilidade ); 
			}
			//So fecha um tag se abriu anteriormente
			xml->closeTag();
		}
	}
}

void CDominio::GetXmlListPar(char* cNomeTag, XMLGen*xml)
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			xml->createTag(cNomeTag);
			//Adiciona a proprieda necessaria para o Weblogic
			xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idDominio", Registro(x)->cidDominio );
				xml->addItem("nmDominio", Registro(x)->cnmDominio );
				xml->addItem("inDisponibilidade", Registro(x)->cinDisponibilidade ); 
				xml->createTag("AdmUFOperadoraSimplVO");
				xml->addItem("idUFOperadora", Registro(x)->cidUFOperadora );
				xml->addItem("dsUFOperadora", Registro(x)->cdsUFOperadora );
				xml->closeTag();				
				xml->createTag("AdmTipoLinhaSimplVO");
				xml->addItem("idTipoLinha", Registro(x)->cidTipoLinha );
				xml->addItem("sgTipoLinha", Registro(x)->csgTipoLinha );
				xml->addItem("dsTipoLinha", Registro(x)->cdsTipoLinha );
				xml->closeTag();
				xml->createTag("AdmTabelaDominioVO");
				xml->addItem("idTabelaDominio", Registro(x)->cidTabelaDominio );
				xml->addItem("nmTabelaDominio", Registro(x)->cnmTabelaDominio );				
				xml->closeTag();	
			}
			//So fecha um tag se abriu anteriormente
			xml->closeTag();
		}
	}
}

void CDominio::GetXmlTabelaDominio(char* cNomeTag, XMLGen*xml)
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			xml->createTag(cNomeTag);
			//Adiciona a proprieda necessaria para o Weblogic
			//xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idTabelaDominio", Registro(x)->cidTabelaDominio );
				xml->addItem("nmTabelaDominio", Registro(x)->cnmTabelaDominio );
			}
			//So fecha um tag se abriu anteriormente
			xml->closeTag();
		}
	}
}
void CDominio::GetUFOperadora(char* cNomeTag, XMLGen*xml)
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			xml->createTag(cNomeTag);
			//Adiciona a proprieda necessaria para o Weblogic
			//xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idUFOperadora", Registro(x)->cidUFOperadora );
				xml->addItem("dsUFOperadora", Registro(x)->cdsUFOperadora );
			}
			//So fecha um tag se abriu anteriormente
			xml->closeTag();
		}
	}
}
void CDominio::GetTipoLinha(char* cNomeTag, XMLGen*xml)
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			xml->createTag(cNomeTag);
			//Adiciona a proprieda necessaria para o Weblogic
			//xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idTipoLinha", Registro(x)->cidTipoLinha );
				xml->addItem("sgTipoLinha", Registro(x)->csgTipoLinha );
				xml->addItem("dsTipoLinha", Registro(x)->cdsTipoLinha );
			}
			//So fecha um tag se abriu anteriormente
			xml->closeTag();
		}
	}
}

int CDominio::Insert(
					 char* cidTabelaDominio
					,char* cidUFOperadora
					,char* cidTipoLinha
					,char* cnmDominio
					,char* cinDisponibilidade
					,char* cidUser
	 )
{
    ULOG_START("CDominio::Insert()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidUserAux = cidUser;
		VARCHAR stidDominio[21+1];
		char* cidTabelaDominioAux = cidTabelaDominio;
		char* cidUFOperadoraAux = cidUFOperadora;
		char* cidTipoLinhaAux = cidTipoLinha;
		char* cnmDominioAux = cnmDominio;
		char* cinDisponibilidadeAux = cinDisponibilidade;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );
	memset( &stidDominio, 0, sizeof( stidDominio ) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;

	//Recupera um id unico
	EXEC SQL
	SELECT 
		CONTATOADM.DOMINIOSQ.NEXTVAL
	INTO
		:stidDominio
	FROM
		DUAL;

	//Insere um registro
	EXEC SQL 
	INSERT INTO CONTATOADM.DOMINIO
	( 
		 IDDOMINIO
		,IDTABELADOMINIO
		,IDUFOPERADORA
		,IDTIPOLINHA
		,NMDOMINIO
		,INDISPONIBILIDADE
		,IDUSUARIOALTERACAO
		,DTULTIMAALTERACAO
	)
	VALUES 
	( 
		:stidDominio
		,:cidTabelaDominioAux
		,:cidUFOperadoraAux
		,:cidTipoLinhaAux
		,:cnmDominioAux
		,:cinDisponibilidadeAux
		,:cidUserAux
		,SYSDATE 
	);

	//Salva o registro na estrutura interna
	Add(
		 (char*)stidDominio.arr
		,cidTabelaDominio
		,cidUFOperadora
		,cidTipoLinha
		,cnmDominio
		,cinDisponibilidade
	);

    ULOG_END("CDominio::Insert()");
	return 1;

GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if(sqlca.sqlcode == -1 || sqlca.sqlcode == 2291 ||
		sqlca.sqlcode == 2292)
	{
		return -2;
	}
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CDominio::Update(
					 char* cidDominio
					,char* cidTabelaDominio
					,char* cidUFOperadora
					,char* cidTipoLinha
					,char* cnmDominio
					,char* cinDisponibilidade
					,char* cidUser
	 ) 
{
    ULOG_START("CDominio::Update()");
	if(cidDominio == NULL ||
		cidTabelaDominio == NULL ||
		cidUFOperadora == NULL ||
		cidTipoLinha == NULL)
	{
	    ULOG_END("CDominio::Update()");
		return -2;
	}
	if(cnmDominio == NULL)
	{	
		cnmDominio = "";
	}
	if(cinDisponibilidade == NULL)
	{
		cinDisponibilidade = "";
	}
	if(cidUser == NULL)
	{
		cidUser = "";
	}

	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidUserAux = cidUser;
		char* cidDominioAux = cidDominio;
		char* cidTabelaDominioAux = cidTabelaDominio;
		char* cidUFOperadoraAux = cidUFOperadora;
		char* cidTipoLinhaAux = cidTipoLinha;
		char* cnmDominioAux = cnmDominio;
		char* cinDisponibilidadeAux = cinDisponibilidade;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;

	//Atualiza um registro
	EXEC SQL 
	UPDATE 
		CONTATOADM.DOMINIO
	SET 
		 IDTABELADOMINIO = :cidTabelaDominioAux
		,IDUFOPERADORA = :cidUFOperadoraAux
		,IDTIPOLINHA = :cidTipoLinhaAux
		,NMDOMINIO = :cnmDominioAux
		,INDISPONIBILIDADE = :cinDisponibilidadeAux
		,IDUSUARIOALTERACAO = :cidUserAux
		,DTULTIMAALTERACAO = SYSDATE
	WHERE
		IDDOMINIO = :cidDominioAux;

	//Salva o registro na estrutura interna
	Add(
		 cidDominio
		,cidTabelaDominio
		,cidUFOperadora
		,cidTipoLinha
		,cnmDominio
		,cinDisponibilidade
	);
    ULOG_END("CDominio::Update()");
	return 1;

GotoUpdate:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CDominio::Delete( 
					 char* cidDominio
				  ) 
{
    ULOG_START("CDominio::Delete()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidDominioAux = cidDominio;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;

	//Apaga um registro
	EXEC SQL 
	DELETE FROM 
		CONTATOADM.DOMINIO
	WHERE 
		IDDOMINIO = :cidDominioAux;
		
    ULOG_END("CDominio::Delete()");
	return 1;

GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if(sqlca.sqlcode == -2292)
	{
		return -1;
	}
	throw TuxBasicOraException(sqlca.sqlcode);
}