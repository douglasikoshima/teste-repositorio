/**
 * @modulo  Admsistemas
 * @usecase Admsistemas
 * @author  Max
 * @version $Revision: 1.1.6.3 $
 * @CVS     $Author: a5114878 $ - $Date: 2012/08/27 19:27:26 $
 **/

#ifdef WIN32
#include "../../../negocio/admatdCmm/include/CAdmCamposDepend.h"
#else
#include "../../negocio/admatdCmm/include/CAdmCamposDepend.h"
#endif

#undef SQLCA
#define SQLCA_NONE
#include <sqlca.h>
#include <sqlda.h>

// =========================================================================
// Defines & tipos ProC
// =========================================================================
EXEC SQL BEGIN DECLARE SECTION;
   #define NRO_MAX_REG_ORA     25

    struct OraArvoreDominio
    {
        int idDominioPai;
        VARCHAR nmDominioPai[21];
        int idDominioFilho;
        VARCHAR nmDominioFilho[21];
        int idCampo;
        VARCHAR nmPath[4001];
        int idNivelCampoValor;
        int inProcessado;
    };

    struct StatusOraArvoreDominio
    {
        short idDominioPai;
        short nmDominioPai;
        short idDominioFilho;
        short nmDominioFilho;
        short idCampo;
        short nmPath;
        short idNivelCampoValor;
        short inProcessado;
    };
EXEC SQL END DECLARE SECTION;

// =========================================================================
// Defines & tipos
// =========================================================================
typedef vector<OraArvoreDominio> VEC_ORAARVOREDOMINIO;

#define CONVIND(O,I) \
{\
    if (I == -1) { \
        ##O.arr[0]=0; \
    } else { \
        ##O.arr[##O.len]=0; \
    } \
}

#define endOraStr(varstr) varstr.arr[varstr.len]= '\0'
#define oraToStr(bstr,vchar) if(!bstr) strncpy(bstr,vchar.arr,vchar.len)
#define strToOra(vchar,bstr) vchar.len = strlen(bstr);strncpy((char *)vchar.arr,bstr,vchar.len);vchar.arr[vchar.len] = 0

// =========================================================================
// Prototipos
// =========================================================================
bool montarFamilia(int idDominioPai,unsigned char *nmPath,int vecOraArvoreDominioIt,VEC_ORAARVOREDOMINIO &vecOraArvoreDominio,XMLGen *saida);
extern const char *obterNmPathAnterior(const char *nmPath,int nivel);

bool proCExisteCampoDominio(int idCampoPrm);
bool proCBuscarIdTabelaDominio(int *idTabelaDominioPrm,const char *nmTabelaDominioPrm);
int proCRelacaoCampoSubFormulario(int idCampoPrm,int idSubFormularioPrm);
void procCObterNmDominioPorIdCampo( int idCampoPrm,XMLGen* xml );
void proCGravaProcArvore(int idUsuarioPrm,int idSubFormularioPrm,int iNivelPrm,int idCampoPrm,const char *nmValorPaiPrm,const char *nmValorFilhoPrm);
void proCLupaCarregaCampoDependente(int idSubFormularioPrm,char *nmCampoPrm,XMLGen *saida);
void procObterNomeCampo(char *nmCampoPrm,const char *idCampoPrm);
void procObterNomeCampo(char *nmCampoPrm,const char *idCampoPrm);
bool proCExisteHierarquia( int idDominioPrm );
void SqlErrorCampos( sqlca * sqlca );

// =========================================================================
// Implementação
// =========================================================================
void proCExcluirCampos(int idUsuarioPrm,int idSubFormularioPrm,vector <string> &lstValorExc)
{
    ULOG_START( "proCExcluirCampos()" );
    bool persistiuSubFormularioCampo = false;

    struct sqlca sqlca;
    //char nmCampo[256];

    EXEC SQL BEGIN DECLARE SECTION;
        //const char *idCampoItem;
        int listaIdCampo[NRO_MAX_REG_ORA];
        int listaIdSubFormulario[NRO_MAX_REG_ORA];
        int idUsuario = idUsuarioPrm;
        int idSubFormulario = idSubFormularioPrm;
        //int nCount;
        // VARCHAR nmLoginUsuario[256];

        // short i_nmLoginUsuario = -1;
        short listaStatusIdCampo[NRO_MAX_REG_ORA];
        short listaStatusIdSubFormulario[NRO_MAX_REG_ORA];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);

    int lstValorExcSize = lstValorExc.size();
    int i,j;

    ULOG( "Foram enviados %d campos para exclusao",lstValorExcSize);

    i = 0;
    while ( i < lstValorExcSize )
    {
        memset(&listaIdCampo,0,sizeof(listaIdCampo));
        memset(&listaIdSubFormulario,0,sizeof(listaIdSubFormulario));

        memset(&listaStatusIdCampo,-1,sizeof(listaStatusIdCampo));
        memset(&listaStatusIdSubFormulario,-1,sizeof(listaStatusIdSubFormulario));

        j = 0;
        while ( j<NRO_MAX_REG_ORA && i<lstValorExcSize )
        {
            const char *idCampoItem = lstValorExc.at(i++).c_str();
            listaIdCampo[j] = atoi(idCampoItem);
            listaIdSubFormulario[j] = idSubFormularioPrm;

            listaStatusIdCampo[j] = 0;
            listaStatusIdSubFormulario[j] = 0;

            j++;
        }

        if ( j )
        {
            ULOG("Bloco de campos contém %d campos",j);

            //===========================================================================
            // Não estamos mais enviando solicitações de gravação à procedure
            // de gravação de hierarquia, pois com a remoção de multipla associação
            // de IDUFOPERADORA e IDTIPOLINHA não há mais a necessidade de persistência
            // nesta tabela via batch. -- Julho, 2007 -- Cassio.
            //===========================================================================
            //
            // EXEC SQL
            //     INSERT INTO CONTATOADM.PROCESSADOMINIOHIERARQUIA
            //     (
            //         IDPROCESSADOMINIOHIERARQUIA ,
            //         INPROCESSAMENTO ,
            //         IDSUBFORMULARIO ,
            //         IDCAMPO ,
            //         IDNIVELCAMPOVALOR 
            //     )
            //     VALUES
            //     (
            //         CONTATOADM.PROCESSADOMINIOHIERARQUIASQ.NEXTVAL ,
            //         0 ,
            //         :listaIdSubFormulario ,
            //         :listaIdCampo ,
            //         999 
            //     );

            ULOG( "Vai excluir bloco de campos de CONTATOADM.DOMINIOHIERARQUIA");

            EXEC SQL
                DELETE
                    CONTATOADM.DOMINIOHIERARQUIA
                WHERE
                    (IDDOMINIOPAI IN
                             (
                                SELECT IDDOMINIO
                                FROM
                                    CONTATOADM.DOMINIO
                                WHERE
                                    IDTABELADOMINIO IN
                                (
                                    SELECT IDTABELADOMINIO 
                                    FROM CONTATOADM.TABELADOMINIO 
                                    WHERE IDTABELADOMINIO IN 
                                    ( 
                                        SELECT IDTABELADOMINIO
                                        FROM CONTATOADM.CAMPODOMINIO
                                        WHERE IDCAMPO IN (:listaIdCampo:listaStatusIdCampo)
                                    )
                                    AND NMTABELADOMINIO LIKE 'tb_%'
                                )
                             )
                        OR IDDOMINIOFILHO IN
                             (
                                SELECT IDDOMINIO
                                FROM
                                    CONTATOADM.DOMINIO
                                WHERE
                                    IDTABELADOMINIO IN
                                (
                                    SELECT IDTABELADOMINIO 
                                    FROM CONTATOADM.TABELADOMINIO 
                                    WHERE IDTABELADOMINIO IN 
                                    ( 
                                        SELECT IDTABELADOMINIO
                                        FROM CONTATOADM.CAMPODOMINIO
                                        WHERE IDCAMPO IN (:listaIdCampo:listaStatusIdCampo)
                                    )
                                    AND NMTABELADOMINIO LIKE 'tb_%'
                                )
                             )
                    )
                    AND IDSUBFORMULARIO IN (:listaIdSubFormulario:listaStatusIdSubFormulario);

            if ( sqlca.sqlcode && -1400 != sqlca.sqlcode && 1403 != sqlca.sqlcode )
            {
                SqlErrorCampos(&sqlca);
            }

            //
            // Não é possível excluir de dominio, pois um mesmo dominio pode estar
            // associado a outros campos ou grupo e não é possivel saber quando
            // esta situação ocorre.
            // ULOG( "Vai excluir bloco de campos de CONTATOADM.DOMINIO");
            // EXEC SQL
            //     DELETE
            //         CONTATOADM.DOMINIO
            //                 WHERE
            //         IDTABELADOMINIO IN
            //             (
            //                 SELECT IDTABELADOMINIO 
            //                   FROM CONTATOADM.TABELADOMINIO 
            //                  WHERE IDTABELADOMINIO IN 
            //                     ( 
            //                         SELECT IDTABELADOMINIO
            //                           FROM CONTATOADM.CAMPODOMINIO
            //                          WHERE IDCAMPO IN (:listaIdCampo:listaStatusIdCampo)
            //                     )
            //                 AND NMTABELADOMINIO LIKE 'tb_%'
            //              );
            // 
            // if ( sqlca.sqlcode && -1400 != sqlca.sqlcode && 1403 != sqlca.sqlcode )
            // {
            //     SqlErrorCampos(&sqlca);
            // }

            // ULOG( "Vai excluir bloco de campos de CONTATOADM.TABELADOMINIO");
            // EXEC SQL
            //     DELETE CONTATOADM.TABELADOMINIO
            //     WHERE IDTABELADOMINIO IN (SELECT IDTABELADOMINIO 
            //                                 FROM CONTATOADM.CAMPODOMINIO 
            //                                WHERE IDCAMPO IN (:listaIdCampo:listaStatusIdCampo)
            //                              )
            //     AND NMTABELADOMINIO LIKE 'tb_%';
            // 
            // if ( sqlca.sqlcode && -1400 != sqlca.sqlcode && 1403 != sqlca.sqlcode )
            // {
            //     SqlErrorCampos(&sqlca);
            // }

            // Agora não será necessario remover os dominios relacionados aos campos,
            // pois um campo mesmo inativo, poderá ser reutilizado pelo sistema.
            // (LUPA)
            //
            // ULOG( "Vai excluir bloco de campos de CONTATOADM.CAMPODOMINIO");
            // EXEC SQL
            //     DELETE
            //         CONTATOADM.CAMPODOMINIO
            //     WHERE
            //         IDCAMPO IN (:listaIdCampo:listaStatusIdCampo);

            if ( sqlca.sqlcode && -1400 != sqlca.sqlcode && 1403 != sqlca.sqlcode )
            {
                SqlErrorCampos(&sqlca);
            }

            ULOG( "Vai excluir bloco de campos de CONTATOADM.SUBFORMULARIOCAMPO");
            EXEC SQL
                DELETE
                    CONTATOADM.SUBFORMULARIOCAMPO
                WHERE 
                    IDCAMPO IN (:listaIdCampo:listaStatusIdCampo)
                AND IDSUBFORMULARIO IN (:listaIdSubFormulario:listaStatusIdSubFormulario);

            if ( sqlca.sqlcode && -1400 != sqlca.sqlcode && 1403 != sqlca.sqlcode )
            {
                SqlErrorCampos(&sqlca);
            }
        }
    }

    // Log somente nos inserts por solicitação do analista funcional Indra
    //
    // if ( persistiuSubFormularioCampo )
    // {
    //     EXEC SQL
    //         SELECT 
    //            NMLOGINUSUARIO
    //         INTO
    //            :nmLoginUsuario:i_nmLoginUsuario
    //         FROM
    //            ACESSO.USUARIO
    //         WHERE
    //            IDPESSOAUSUARIO = :idUsuario;
    // 
    //     if ( 1403 == sqlca.sqlcode )
    //     {
    //         throw new TuxException("14E9999","Usuario não cadastrado");
    //     }
    // 
    //     CONVIND(nmLoginUsuario,i_nmLoginUsuario);
    // 
    //     ULOG( "obteve NMLOGINUSUARIO=%s para IDPESSOAUSUARIO=%d em ACESSO.USUARIO",nmLoginUsuario.arr,idUsuario);
    // 
    //     ULOG( "vai inserir em CONTATOADM.SUBFORMULARIOCAMPOLOG o log da persistência de IDSUBFORMULARIO=%d",idSubFormulario);
    // 
    //     EXEC SQL
    //         INSERT INTO
    //             CONTATOADM.SUBFORMULARIOCAMPOLOG
    //                 (IDSUBFORMULARIOCAMPOLOG,
    //                  NMLOGINUSUARIO,
    //                  DTULTIMAALTERACAO,
    //                  IDSUBFORMULARIO)
    //         VALUES
    //                 (CONTATOADM.SUBFORMULARIOCAMPOLOGSQ.NEXTVAL,
    //                 :nmLoginUsuario,
    //                 SYSDATE,
    //                 :idSubFormulario);
    // }

    ULOG_END( "proCExcluirCampos()" );
}

void procObterNomeCampo(char *nmCampoPrm,const char *idCampoPrm)
{
    ULOG_START( "procObterNomeCampo()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        const char *idCampo = idCampoPrm;
        VARCHAR nmCampo[2001];
        short i_nmCampo = -1;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);

    EXEC SQL
        SELECT 
           NMCAMPO
        INTO 
           :nmCampo:i_nmCampo
        FROM 
           CONTATOADM.CAMPO
        WHERE 
           IDCAMPO = :idCampo;

    if ( 0 == sqlca.sqlcode )
    {
        CONVIND( nmCampo,i_nmCampo );
        strcpy(nmCampoPrm,(char*)nmCampo.arr);
    }
    else
    {
        strcpy(nmCampoPrm,"??? CAMPO NAO ENCONTRADO ???");
    }

    ULOG_END( "procObterNomeCampo()" );
}
// =========================================================================
void proCInsereValor(char * MsgErro,bool flgRemove,int iNivelPrm,int idUsuarioPrm,
                     int * idSubFormularioPrm,char * nmGrupoPrm,int idContatoPrm,
                     int * idCampoPrm,char * nmCampoPrm,list <string> * lstValorInc,
                     list <string> * lstValorExc)
{
    ULOG_START( "proCInsereValor()" );
    bool persistiuSubFormularioCampo = false;

    struct sqlca sqlca;
    char buffer[256];
    //string bf;
    list <string>::iterator itValoresInc;
    list <string>::iterator itValoresExc;

    EXEC SQL BEGIN DECLARE SECTION;
        const char *nmValor;

        int ctCampo = 0;
        int idCampo = *idCampoPrm;
        int idCampoCmp;
        int idContato = idContatoPrm;
        int idDominio;
        int idNivelCmp;
        int idSubFormulario = *idSubFormularioPrm;
        int idTabelaDominio;
        int idUsuario = idUsuarioPrm;
        int indisponivel;
        int iNivel = iNivelPrm;
        int iRegs = 0 ;
        int TipoDadoAux;
        int idFase;

        int Classificador = CLASSIFICADORCAMPO;
        int LayOut        = LAYOUTAPRESENTACAOCAMPO;
        int Mascara       = MASCARAAPRESENCAOCAMPO;
        int TipoDadoCampo = TIPODADOCAMPO;
        int ctGrupos;
        int idDominioExcluir;

        VARCHAR nmLoginUsuario[256];
        VARCHAR nmCampo[2001] ;
        VARCHAR nmSubFormulario[256];
        VARCHAR nmtbDominio[256] ;

        short i_idCampo = -1;
        short i_idCampoCmp = -1;
        short i_idNivelCmp = -1;
        short i_idSubFormulario = -1;
        short i_idTipoLinha = -1;
        short i_idUF = -1;
        short i_indisponivel = -1;
        short i_nmtbDominio = -1 ;
        short i_nmLoginUsuario = -1;
        short i_TipoDadoAux = -1;


    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);

    strToOra(nmSubFormulario,nmGrupoPrm);

    strToOra(nmCampo,nmCampoPrm);

    bool existeCampo;

    // Implementação: Incidência 4507
    // Será emitida mensagem de Grupo Existente na base.
    if ( *idSubFormularioPrm <= 0)
    {
        ULOG( "Verificando Grupo [%s]",(char*)nmSubFormulario.arr);
        EXEC SQL
            SELECT
               COUNT(1)
            INTO
              :ctGrupos
            FROM
               CONTATOADM.SUBFORMULARIO
            WHERE
               IDTIPOSUBFORMULARIO = 2
            AND
               UPPER(NMSUBFORMULARIO) = UPPER(:nmSubFormulario);

        if ( ctGrupos > 0 )
        {
            sprintf(MsgErro,"O grupo [%s] já está cadastrado, favor alterar o nome.",
                            (char*)nmSubFormulario.arr );
            ULOG( MsgErro );
            return;
        }

    }

    if ( idCampo > 0 )
    {
        ULOG( "Vai atualizar nmcampo=[%s] para idCampo=%d em CONTATOADM.CAMPO",
                                                        (char*)nmCampo.arr,idCampo);

        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL
            UPDATE
               CONTATOADM.CAMPO
            SET
                NMCAMPO = :nmCampo,
                IDUSUARIOALTERACAO = :idUsuario,
                DTULTIMAALTERACAO = SYSDATE
            WHERE
                IDCAMPO = :idCampo;

        // Não permite atualizar o campo para um nome que já existe.
        if (sqlca.sqlcode < 0) 
        {
            if ( sqlca.sqlcode == -1)
            {
                sprintf(MsgErro,"O campo [%s] já está cadastrado, favor alterar o nome.",(char*)nmCampo.arr );
                return;
            }
            else
            {
               SqlErrorCampos((&(sqlca)));
            }
        }


        if ( iNivel > 0 )
        {
            ULOG( "Vai atualizar IDNIVELCAMPOVALOR para %d para idCampo=%d em "
                            "CONTATOADM.SUBFORMULARIOCAMPO",iNivel,idCampo);

            EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);
            EXEC SQL
                UPDATE
                   CONTATOADM.SUBFORMULARIOCAMPO
                SET
                    IDNIVELCAMPOVALOR = :iNivel
                WHERE
                    IDCAMPO = :idCampo
                AND IDSUBFORMULARIO = :idSubFormulario;
        }

        existeCampo = true;
    }
    else
    {
        ULOG( "Vai obter idCampo para nmcampo=[%s] em CONTATOADM.CAMPO",(char*)nmCampo.arr);

        EXEC SQL
            SELECT
               IDCAMPO
            INTO 
               :idCampo:i_idCampo 
            FROM 
               CONTATOADM.CAMPO 
            WHERE 
               UPPER(NMCAMPO) = UPPER(:nmCampo)
            AND
                ROWNUM < 2;

        existeCampo = 0 == sqlca.sqlcode ? true : false;
    }

    if ( existeCampo )
    {

        //
        // Campo sendo reutilizado.
        // Estava cadastrado, porém ajustado com INDISPONIVEL = 0.
        //
        ULOG( "Vai atualizar INDISPONIBILIDADE=1 para idCampo=%d em CONTATOADM.CAMPO",idCampo);

        EXEC SQL
            UPDATE 
               CONTATOADM.CAMPO
            SET 
               INDISPONIBILIDADE = 1
            WHERE
               IDCAMPO = :idCampo;

        // Verifica se existe campo com mesmo nome
        // para niveis diferentes
        ULOG( "Vai comparar campos para IDSUBFORMULARIO=%d em CONTATOADM.SUBFORMULARIOCAMPO"
                                                                                ,idSubFormulario);

        EXEC SQL WHENEVER NOT FOUND DO BREAK;
        EXEC SQL DECLARE ComparaCampos CURSOR FOR 
        SELECT
           SUBFORMULARIOCAMPO.IDCAMPO ,
           SUBFORMULARIOCAMPO.IDNIVELCAMPOVALOR  
        INTO
           :idCampoCmp:i_idCampoCmp ,
           :idNivelCmp:i_idNivelCmp
        FROM
           CONTATOADM.SUBFORMULARIOCAMPO SUBFORMULARIOCAMPO 
        WHERE
           SUBFORMULARIOCAMPO.IDSUBFORMULARIO = :idSubFormulario;

        EXEC SQL OPEN ComparaCampos;

        while(true)
        {
            EXEC SQL FETCH ComparaCampos INTO :idCampoCmp:i_idCampoCmp ,
                                              :idNivelCmp:i_idNivelCmp ;

            ULOG( "Comparando idCampo [%lu] - idCampoCmp [%lu]",idCampo,idCampoCmp );
            if ( idCampo == idCampoCmp )
            {
                ULOG( "Comparando iNivel [%lu] - idNivelCmp [%lu]",iNivel,idNivelCmp );
                if ( iNivel != idNivelCmp )
                {
                    strcpy(MsgErro,"Não é permitido configurar o mesmo campo para níveis diferentes." );
                    return;
                }
            }
        }

        EXEC SQL CLOSE ComparaCampos;
        EXEC SQL WHENEVER NOT FOUND CONTINUE;
    
    }
    else
    {
        ULOG( "idCampo para nmcampo=[%s] não encontrado",(char*)nmCampo.arr);
    }

    ULOG( "Vai obter IDCAMPO IDSUBFORMULARIO=%d e IDNIVELCAMPOVALOR=%d em CONTATOADM.SUBFORMULARIOCAMPO"
                                                                            ,idSubFormulario,iNivel);
    EXEC SQL
        SELECT
           SUBFORMULARIOCAMPO.IDCAMPO 
        INTO
           :idCampo:i_idCampo
        FROM
           CONTATOADM.SUBFORMULARIOCAMPO SUBFORMULARIOCAMPO 
        WHERE
           SUBFORMULARIOCAMPO.IDNIVELCAMPOVALOR = :iNivel
        AND
           SUBFORMULARIOCAMPO.IDSUBFORMULARIO = :idSubFormulario;

    if ( existeCampo )
    {
        ULOG( "Atualizando NMCAMPO para %s para IDCAMPO=%d em CONTATOADM.CAMPO",nmCampo.arr,idCampo);

        EXEC SQL WHENEVER SQLERROR CONTINUE;
        EXEC SQL
            UPDATE
                CONTATOADM.CAMPO
            SET
                NMCAMPO = :nmCampo 
            WHERE
                IDCAMPO = :idCampo;

        // Não permite atualizar o campo para um nome que já existe.
        if (sqlca.sqlcode < 0) 
        {
            if ( sqlca.sqlcode != -1)
            {
               SqlErrorCampos((&(sqlca)));
            }
        }

        TipoDadoAux = 6;
        indisponivel = 1;
    }
    else
    {
        ULOG( "Obtendo dados de campo em CONTATOADM.CAMPO para NMCAMPO=%s",nmCampo.arr);

        EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);
        EXEC SQL
            SELECT
               IDCAMPO,
               IDTIPODADOCAMPO,
               INDISPONIBILIDADE
            INTO
               :idCampo:i_idCampo ,
               :TipoDadoAux:i_TipoDadoAux ,
               :indisponivel:i_indisponivel
            FROM 
               CONTATOADM.CAMPO 
            WHERE 
               UPPER(NMCAMPO) = UPPER(:nmCampo)
            AND ROWNUM < 2;
    }

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);

    if( !existeCampo )
    {
        EXEC SQL SELECT CONTATOADM.CAMPOSQ.NEXTVAL INTO :idCampo FROM DUAL;

        ULOG( "Vai inserir idCampo=%d em CONTATOADM.CAMPO",idCampo );

        EXEC SQL
            INSERT INTO CONTATOADM.CAMPO
            (
                IDCAMPO ,
                NMCAMPO ,
                IDTIPODADOCAMPO ,
                IDMASCARAAPRESENCAOCAMPO ,
                IDLAYOUTAPRESENTACAOCAMPO ,
                INDISPONIBILIDADE ,
                IDCLASSIFICADORCAMPO ,
                IDUSUARIOALTERACAO ,
                DTULTIMAALTERACAO
            )
            VALUES
            (
                :idCampo ,
                :nmCampo ,
                :TipoDadoCampo ,
                :Mascara ,
                :LayOut ,
                1 ,
                :Classificador , // Classificador de Campos Dependentes
                :idUsuario ,
                SYSDATE
            );

        // Verifica se o formulário já foi associado a um contato, e caso sim,
        // associa o novo campo ao contato para atualização.
        EXEC SQL DECLARE cursorCFCampo CURSOR FOR
            SELECT DISTINCT
                CONTATOFOLHACAMPO.IDFASEPROCESSO
            FROM
                CONTATOADM.CONTATOFOLHACAMPO CONTATOFOLHACAMPO,
                CONTATOADM.SUBFORMULARIOCAMPO SUBFORMULARIOCAMPO
            WHERE
                CONTATOFOLHACAMPO.IDCAMPO = SUBFORMULARIOCAMPO.IDCAMPO
            AND SUBFORMULARIOCAMPO.IDSUBFORMULARIO = :idSubFormulario
            AND CONTATOFOLHACAMPO.IDCONTATO = :idContato;

        EXEC SQL OPEN cursorCFCampo;
        EXEC SQL WHENEVER NOT FOUND DO BREAK;
        while(true)
        {
            EXEC SQL FETCH cursorCFCampo INTO :idFase;

            EXEC SQL WHENEVER NOT FOUND CONTINUE;
            EXEC SQL
                INSERT INTO
                    CONTATOADM.CONTATOFOLHACAMPO(IDCONTATOFOLHACAMPO,
                                                 IDCONTATO,
                                                 IDUFOPERADORA,
                                                 IDTIPOLINHA,
                                                 IDCAMPO,
                                                 SQORDEMAPRESENTACAO,
                                                 IDFASEPROCESSO,
                                                 IDUSUARIOALTERACAO,
                                                 DTULTIMAALTERACAO,
                                                 IDSUBFORMULARIO)
                    VALUES (CONTATOADM.CONTATOFOLHACAMPOSQ.NEXTVAL,
                            :idContato,
                            1, // IDUFOPERADORA
                            1, // IDTIPOLINHA
                            :idCampo,
                            1, // SQORDEMAPRESENTACAO
                            :idFase,
                            :idUsuario ,
                            SYSDATE,
                            :idSubFormulario);
        }

        EXEC SQL CLOSE cursorCFCampo;

        ULOG( "Sinalizando para processamento de contatos pelo batch..." );
		EXEC SQL
			INSERT INTO CONTATOADM.PROCESSASUBFORMULARIO
			(
			   IDPROCESSASUBFORMULARIO ,
			   IDSUBFORMULARIO ,
			   IDCAMPO ,
			   TPOPERACAO ,
			   INPROCESSAMENTO
			) 
			VALUES 
			(
			   CONTATOADM.PROCESSASUBFORMULARIOSQ.NEXTVAL ,
			   :idSubFormulario ,
			   :idCampo ,
			   1 ,
			   0
			);


    }
    else
    {
        if ( TipoDadoAux != 6 && indisponivel != 1 )
        {
            sprintf(MsgErro,"O campo %s não é válido para esta operação",(char*)nmCampo.arr );
            return;
        }
    }

    if ( !idSubFormulario )
    {
        ULOG( "Nao achou grupo, realizando busca pelo nome [%s]",(char*)nmSubFormulario.arr );

        EXEC SQL
            SELECT 
               IDSUBFORMULARIO
            INTO
               :idSubFormulario:i_idSubFormulario
            FROM 
               CONTATOADM.SUBFORMULARIO 
            WHERE 
               UPPER(NMSUBFORMULARIO) = UPPER(:nmSubFormulario)
            AND
               IDTIPOSUBFORMULARIO = 2 // Este tipo é usado para grupos de campos dependentes
            AND 
               ROWNUM < 2;

        if ( 1403 == sqlca.sqlcode )
        {
            EXEC SQL
                SELECT
                    CONTATOADM.SUBFORMULARIOSQ.NEXTVAL
                INTO
                    :idSubFormulario
                FROM
                    DUAL;

            ULOG( "Vai inserir idSubFormulario=%d,nmSubFormulario[%s] em CONTATOADM.SUBFORMULARIO",
                        idSubFormulario,(char*)nmSubFormulario.arr );

            EXEC SQL
                INSERT INTO
                    CONTATOADM.SUBFORMULARIO(IDSUBFORMULARIO
                                            ,NMSUBFORMULARIO
                                            ,IDTIPOSUBFORMULARIO)
                VALUES(:idSubFormulario,:nmSubFormulario,2);
        }
    }
    else // Verifica se o grupo esta sendo renomeado, e barra a acao
    {
        ULOG("Vai verificar se NMSUBFORMULARIO=%s existe em CONTATOADM.SUBFORMULARIO",nmSubFormulario.arr);

        EXEC SQL
            SELECT 
               COUNT(1)
            INTO
              :ctCampo
            FROM 
               CONTATOADM.SUBFORMULARIO 
            WHERE 
               UPPER(NMSUBFORMULARIO) = UPPER(:nmSubFormulario)
            AND
               IDSUBFORMULARIO = :idSubFormulario
            AND 
               ROWNUM < 2;

        if ( 0 == ctCampo )
        {
            sprintf(MsgErro,"Grupo não pode ser renomeado." );
            return;
        }
    }

    ULOG("Vai verificar se IDSUBFORMULARIO=%d e IDCAMPO=%d existem em CONTATOADM.SUBFORMULARIO"
                ,idSubFormulario,idCampo);

    EXEC SQL
        SELECT 
            COUNT(1)
        INTO 
            :ctCampo
        FROM 
            CONTATOADM.SUBFORMULARIOCAMPO 
        WHERE 
            IDSUBFORMULARIO = :idSubFormulario
        AND
            IDCAMPO = :idCampo
        AND
            ROWNUM < 2;

    if ( 0 == ctCampo )
    { // Vai atribuir o novo campo a SubFormularioCampo
        ULOG( "Vai inserir idSubFormulario=%d,idCampo=%d,iNivel=%d em CONTATOADM.SUBFORMULARIOCAMPO"
                                            ,idSubFormulario,idCampo,iNivel );

        EXEC SQL
            INSERT INTO CONTATOADM.SUBFORMULARIOCAMPO
            (
                IDSUBFORMULARIO ,
                IDCAMPO ,
                IDNIVELCAMPOVALOR
            )
            VALUES
            (
                :idSubFormulario ,
                :idCampo ,
                :iNivel
            );

        persistiuSubFormularioCampo = true;
    }

    sprintf( buffer,"tb_%s",nmCampoPrm );
    strToOra(nmtbDominio,buffer);

    if ( proCBuscarIdTabelaDominio( &idTabelaDominio,buffer ) == false )
    {
        EXEC SQL
            SELECT CONTATOADM.TABELADOMINIOSQ.NEXTVAL INTO :idTabelaDominio FROM DUAL;

        ULOG( "Vai inserir idTabelaDominio=%d,nmtbDominio=%s em CONTATOADM.TABELADOMINIO"
                                                        ,idTabelaDominio,(char*)nmtbDominio.arr );

        EXEC SQL
            INSERT INTO
                CONTATOADM.TABELADOMINIO(IDTABELADOMINIO
                                        ,NMTABELADOMINIO
                                        ,IDUSUARIOALTERACAO
                                        ,DTULTIMAALTERACAO)
            VALUES (:idTabelaDominio
                   ,:nmtbDominio
                   ,:idUsuario
                   ,SYSDATE);
    }

    // if ( flgRemove == true )
    // {
    //     ULOG( "Vai deletar idCampo=%d em CONTATOADM.CAMPODOMINIO",idCampo );
    // 
    //     EXEC SQL
    //         DELETE
    //             CONTATOADM.CAMPODOMINIO
    //         WHERE
    //             IDCAMPO = :idCampo;
    // }

    if ( proCExisteCampoDominio(idCampo) == false ) // Nao existe associacao entre campo e dominio
    {
        ULOG( "Vai inserir IDCAMPO=%d,IDTABELADOMINIO=%d em CONTATOADM.CAMPODOMINIO",
                                                                        idCampo,idTabelaDominio );
        EXEC SQL
            INSERT INTO CONTATOADM.CAMPODOMINIO
                ( IDCAMPO, IDTABELADOMINIO, IDUSUARIOALTERACAO, DTULTIMAALTERACAO )
            VALUES
                ( :idCampo, :idTabelaDominio, :idUsuario, SYSDATE  );
    }
    else // Neste caso existe associacao, devemos apenas atualizar os novos dominios ao campo
    {
        ULOG( "Vai atualizar IDTABELADOMINIO=%d em CONTATOADM.CAMPODOMINIO para IDCAMPO=%d",
                                                                        idTabelaDominio,idCampo );
        EXEC SQL
            UPDATE 
               CONTATOADM.CAMPODOMINIO
            SET 
               IDTABELADOMINIO = :idTabelaDominio
            WHERE
               IDCAMPO = :idCampo;
    }

    ULOG( "Vai obter NMLOGINUSUARIO para IDPESSOAUSUARIO=%d em ACESSO.USUARIO",idUsuario);

    EXEC SQL
        SELECT 
           NMLOGINUSUARIO
        INTO
           :nmLoginUsuario:i_nmLoginUsuario
        FROM
           ACESSO.USUARIO
        WHERE
           IDPESSOAUSUARIO = :idUsuario;

    if ( 1403 == sqlca.sqlcode )
    {
        throw new TuxException("14E9999","Usuario não cadastrado");
    }

    CONVIND( nmLoginUsuario,i_nmLoginUsuario );

    ULOG( "obteve NMLOGINUSUARIO=%s para IDPESSOAUSUARIO=%d em ACESSO.USUARIO",nmLoginUsuario.arr,idUsuario);

    ULOG( "Processando as alterações de dominios ...");

    for (itValoresInc = lstValorInc->begin(); itValoresInc != lstValorInc->end(); itValoresInc++)
    {
        //bf = *itValoresInc;
        //strToOra(nmValor,(char*)bf.c_str());
        nmValor = itValoresInc->c_str();

        EXEC SQL
            UPDATE
                CONTATOADM.DOMINIO
            SET INDISPONIBILIDADE = 3,
                IDTABELADOMINIO = :idTabelaDominio
            WHERE
                NMDOMINIO = :nmValor
            AND 
                INDISPONIBILIDADE = 0;

        EXEC SQL
            SELECT
                COUNT(1)
            INTO
                :ctCampo
            FROM
                CONTATOADM.DOMINIO
            WHERE
                NMDOMINIO = :nmValor
            AND IDTABELADOMINIO = :idTabelaDominio
            AND INDISPONIBILIDADE = 3 // 3 = campo dependente
            AND IDUFOPERADORA = 1 // Associa apenas com uma ufOperadora e um tipoLinha
            AND IDTIPOLINHA = 1;  // para evitar problemas de performance.

        if ( 0 == ctCampo )
        {
            EXEC SQL
                INSERT INTO
                    CONTATOADM.DOMINIO
                    (
                        IDDOMINIO,
                        IDTABELADOMINIO,
                        NMDOMINIO,
                        INDISPONIBILIDADE,
                        IDUFOPERADORA,
                        IDTIPOLINHA,
                        IDUSUARIOALTERACAO,
                        DTULTIMAALTERACAO
                    )
                VALUES
                    (
                        CONTATOADM.DOMINIOSQ.NEXTVAL,
                        :idTabelaDominio,
                        :nmValor,
                        3, // INDISPONIBILIDADE
                        1, // IDUFOPERADORA
                        1, // IDTIPOLINHA
                        :idUsuario,
                        SYSDATE
                    );
        }

        EXEC SQL
            SELECT
               IDDOMINIO
            INTO
               :idDominio
            FROM
               CONTATOADM.DOMINIO
            WHERE
               NMDOMINIO = :nmValor
            AND
               IDTABELADOMINIO = :idTabelaDominio
            AND 
               ROWNUM < 2;

        // int row_count = sqlca.sqlerrd[2];
        // ULOG( "Valor [%s] encontrado, atualizando [%d] linhas...",(char*)nmValor.arr,row_count );

        // if( row_count == 0 )
        // {
            // ULOG( "Incluindo idTabelaDominio [%d], nmValor [%s] na tabela Dominio",
            //             idTabelaDominio, (char*)nmValor.arr);

            //------------------------------------------------------------------------
            // Indica que a tabela CONTATOADM.DOMINIO deverá ser populada pelo batch,
            // observando que todo o conteúdo das variáveis para Tipo de Linha e
            // UF Operadora deverão ter o mesmo valor para nmDominio.
            //
            // EXEC SQL
            // INSERT INTO CONTATOADM.PROCESSADOMINIO
            // (
            //     IDPROCESSADOMINIO ,
            //     IDTABELADOMINIO ,
            //     NMDOMINIO ,
            //     INPROCESSAMENTO ,
            //     TPOPERACAO ,
            //     IDCAMPO ,
            //     NRNIVEL ,
            //     NMLOGIN 
            // )
            // VALUES
            // (
            //     CONTATOADM.PROCESSADOMINIOSQ.NEXTVAL ,
            //     :idTabelaDominio ,
            //     :nmValor ,
            //     0 ,
            //     1 ,
            //     :idCampo ,
            //     :iNivel ,
            //     :nmLoginUsuario 
            // );
        // }

        if ( iNivel == 1 )  // Somente para o primeiro nivel
        {
            //proCGravaProcArvore( idUsuario,idSubFormulario, iNivel, idCampo, (char*)nmValor.arr, (char*)nmValor.arr );
            proCGravaProcArvore( idUsuario,idSubFormulario, iNivel, idCampo, nmValor, nmValor );
        }
    } // for (itValoresInc = lstValorInc->begin(); itValoresInc != lstValorInc->end(); itValoresInc++)

    ULOG( "Processando as exclusões de dominios ...");

    for (itValoresExc = lstValorExc->begin(); itValoresExc != lstValorExc->end(); itValoresExc++)
    {
        // bf = *itValoresExc;
        // strToOra(nmValor,(char*)bf.c_str());
        nmValor = itValoresExc->c_str();

        EXEC SQL
            SELECT
               IDDOMINIO
            INTO
               :idDominioExcluir
            FROM
               CONTATOADM.DOMINIO
            WHERE
                NMDOMINIO = :nmValor
            AND
               IDTABELADOMINIO = :idTabelaDominio;
               

        if ( proCExisteHierarquia(idDominioExcluir) == true )
        {
            sprintf(MsgErro,"O valor [%s] possui relacionamento de hierarquia e não poderá ser removido.",
                            nmValor );
            ULOG( MsgErro );
            return;
        }

        ULOG( "Atualizando INDISPONIBILIDADE=0 para nmValor=[%s] em CONTATOADM.DOMINIO",nmValor);

        EXEC SQL
            UPDATE
                CONTATOADM.DOMINIO
            SET
                INDISPONIBILIDADE = 0
            WHERE
                NMDOMINIO = :nmValor
            AND
               IDTABELADOMINIO = :idTabelaDominio;

        // =====================================================================
        // Indica que a tabela CONTATOADM.DOMINIO deverá ter remoção do campo 
        // nmDominio passado como parâmetro para o batch,
        // observando que todo o conteúdo das variáveis para Tipo de Linha e
        // UF Operadora será refletido.
        // Devido a problemas de performance o dominio só é associado a uma
        // UFOPERADORA e um TIPOLINHA, por convenção decidimos que os valores
        // associados seriam sempre 1 para os dois campos.
        // Alteração fechada pelo analista funcional Marcelo Novaes.
        // Julho, 2005 - Cassio.
        // 
        // EXEC SQL
        // INSERT INTO CONTATOADM.PROCESSADOMINIO
        // (
        //     IDPROCESSADOMINIO ,
        //     IDTABELADOMINIO ,
        //     NMDOMINIO ,
        //     INPROCESSAMENTO ,
        //     TPOPERACAO ,
        //     IDCAMPO ,
        //     NRNIVEL ,
        //     NMLOGIN 
        // )
        // VALUES
        // (
        //     CONTATOADM.PROCESSADOMINIOSQ.NEXTVAL ,
        //     :idTabelaDominio ,
        //     :nmValor ,
        //     0 ,
        //     3 ,
        //     :idCampo ,
        //     :iNivel ,
        //     :nmLoginUsuario 
        // );

        // Remove da árvore todos os filhos do dominio sendo excluido

        ULOG( "Removendo linhas de CONTATOADM.DOMINIOHIERARQUIA para nmValor=[%s]",nmValor);

        EXEC SQL
            DELETE
                CONTATOADM.DOMINIOHIERARQUIA
            WHERE
                IDDOMINIOPAI IN
                                (
                                    SELECT DISTINCT
                                        DOMINIOPAI.IDDOMINIO IDDOMINIOPAI
                                    FROM
                                        CONTATOADM.DOMINIO DOMINIOPAI
                                    WHERE
                                        DOMINIOPAI.NMDOMINIO = :nmValor
                                    AND
                                        IDTABELADOMINIO = :idTabelaDominio

                                )
            OR
                IDDOMINIOFILHO IN
                                (
                                    SELECT DISTINCT
                                        DOMINIOFILHO.IDDOMINIO IDDOMINIOFILHO
                                    FROM
                                        CONTATOADM.DOMINIO DOMINIOFILHO
                                    WHERE
                                        DOMINIOFILHO.NMDOMINIO = :nmValor
                                    AND
                                        IDTABELADOMINIO = :idTabelaDominio
                                );

    } // for (itValoresExc = lstValorExc->begin(); itValoresExc != lstValorExc->end(); itValoresExc++)

    if ( persistiuSubFormularioCampo )
    {
        EXEC SQL
            INSERT INTO
                CONTATOADM.SUBFORMULARIOCAMPOLOG
                    (IDSUBFORMULARIOCAMPOLOG,
                     NMLOGINUSUARIO,
                     DTULTIMAALTERACAO,
                     IDSUBFORMULARIO)
            VALUES
                    (CONTATOADM.SUBFORMULARIOCAMPOLOGSQ.NEXTVAL,
                    :nmLoginUsuario,
                    SYSDATE,
                    :idSubFormulario);
    }

    *idSubFormularioPrm = idSubFormulario;
    *idCampoPrm = idCampo;

    ULOG_END( "proCInsereValor()" );
}


// =========================================================================
bool proCAlteraValor(int idUsuarioPrm,int iNivelPrm,int idSubFormularioPrm,
                     int idCampoPrm,char * nmCampoPrm)
{
    ULOG_START( "proCAlteraValor()" );

    bool retorno = false;
    bool persistiuSubFormularioCampo = false;
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int idUsuario = idUsuarioPrm;
        int idCampo = idCampoPrm;
        int idSubFormulario = idSubFormularioPrm;
        int iNivel = iNivelPrm;
        int idNivelCampoValor;

        VARCHAR nmCampo[2001] ;
        // VARCHAR nmLoginUsuario[256];

        // short i_nmLoginUsuario = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);

    strToOra(nmCampo,nmCampoPrm);

    if ( idCampo > 0 )
    {
        ULOG( "Vai atualizar nmcampo=[%s] para idCampo=%d em CONTATOADM.CAMPO",
                                                        (char*)nmCampo.arr,idCampo);

        EXEC SQL
            UPDATE
               CONTATOADM.CAMPO
            SET
                NMCAMPO = :nmCampo,
                IDUSUARIOALTERACAO = :idUsuario,
                DTULTIMAALTERACAO = SYSDATE
            WHERE
                IDCAMPO = :idCampo;

        if ( iNivel > 0 )
        {
            ULOG( "Vai obter IDNIVELCAMPOVALOR para idCampo=%d e idSubFormulario=%d em "
                            "CONTATOADM.SUBFORMULARIOCAMPO",idCampo,idSubFormulario);

            EXEC SQL
                SELECT
                    IDNIVELCAMPOVALOR
                INTO
                    :idNivelCampoValor
                FROM
                    CONTATOADM.SUBFORMULARIOCAMPO
                WHERE
                    IDCAMPO = :idCampo
                AND IDSUBFORMULARIO = :idSubFormulario;

            if ( 0 == sqlca.sqlcode )
            {
                ULOG( "idNivelCampoValor obtido = %d",idNivelCampoValor);

                // só trocar se houve mudança de valor
                if ( idNivelCampoValor != iNivel )
                {
                    ULOG( "Vai atualizar IDNIVELCAMPOVALOR para %d para idCampo=%d "
                          "e idSubFormulario=%d em CONTATOADM.SUBFORMULARIOCAMPO"
                                                            ,iNivel,idCampo,idSubFormulario);

                    EXEC SQL
                        UPDATE
                           CONTATOADM.SUBFORMULARIOCAMPO
                        SET
                            IDNIVELCAMPOVALOR = :iNivel
                        WHERE
                            IDCAMPO = :idCampo
                        AND IDSUBFORMULARIO = :idSubFormulario;

                    if ( 0 == sqlca.sqlcode ) { retorno = true; }
                }
            } // if ( 0 == sqlca.sqlcode )
            else
            {
                ULOG( "Sem registro para idCampo=%d e idSubFormulario=%d em "
                                "CONTATOADM.SUBFORMULARIOCAMPO",idCampo,idSubFormulario);
            }
        }
    }
    else
    {
        ULOG("idCampo não informado");
    }

    // Log somente nos inserts por solicitação do analista funcional Indra
    //
    // if ( persistiuSubFormularioCampo && retorno )
    // {
    //     EXEC SQL
    //         SELECT 
    //            NMLOGINUSUARIO
    //         INTO
    //            :nmLoginUsuario:i_nmLoginUsuario
    //         FROM
    //            ACESSO.USUARIO
    //         WHERE
    //            IDPESSOAUSUARIO = :idUsuario;
    // 
    //     if ( 1403 == sqlca.sqlcode )
    //     {
    //         throw new TuxException("14E9999","Usuario não cadastrado");
    //     }
    // 
    //     CONVIND(nmLoginUsuario,i_nmLoginUsuario);
    // 
    //     ULOG( "obteve NMLOGINUSUARIO=%s para IDPESSOAUSUARIO=%d em ACESSO.USUARIO",nmLoginUsuario.arr,idUsuario);
    // 
    //     ULOG( "vai inserir em CONTATOADM.SUBFORMULARIOCAMPOLOG o log da persistência de IDSUBFORMULARIO=%d",idSubFormulario);
    // 
    //     EXEC SQL
    //         INSERT INTO
    //             CONTATOADM.SUBFORMULARIOCAMPOLOG
    //                 (IDSUBFORMULARIOCAMPOLOG,
    //                  NMLOGINUSUARIO,
    //                  DTULTIMAALTERACAO,
    //                  IDSUBFORMULARIO)
    //         VALUES
    //                 (CONTATOADM.SUBFORMULARIOCAMPOLOGSQ.NEXTVAL,
    //                 :nmLoginUsuario,
    //                 SYSDATE,
    //                 :idSubFormulario);
    // }

    ULOG("retorno=%d",retorno);

    ULOG_END( "proCAlteraValor()" );

    return retorno;
}

// =========================================================================
void proCExluirHierarquia(int iNivelPrm,int idSubFormularioPrm)
{
    ULOG_START( "proCExluirHierarquia()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        int idSubFormulario = idSubFormularioPrm;
        int iNivel = iNivelPrm < 3 ? 1 : iNivelPrm;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);

    ULOG( "Excluindo em CONTATOADM.DOMINIOHIERARQUIA devido a troca de níveis de "
                                                    "campos a partir do nível %d",iNivel);

    EXEC SQL
        DELETE
            CONTATOADM.DOMINIOHIERARQUIA
        WHERE
            IDDOMINIOPAI IN
            (
                SELECT --//DISTINCT 
                    DOMINIOPAI.IDDOMINIO
                FROM
                    CONTATOADM.DOMINIOHIERARQUIA DOMINIOHIERARQUIA,
                    CONTATOADM.SUBFORMULARIOCAMPO SUBFORMULARIOCAMPO,
                    CONTATOADM.DOMINIO DOMINIOPAI,
                    CONTATOADM.DOMINIO DOMINIOFILHO
                WHERE
                    DOMINIOHIERARQUIA.IDCAMPO = SUBFORMULARIOCAMPO.IDCAMPO
                AND SUBFORMULARIOCAMPO.IDSUBFORMULARIO = :idSubFormulario
                AND DOMINIOHIERARQUIA.IDDOMINIOPAI = DOMINIOPAI.IDDOMINIO
                AND DOMINIOHIERARQUIA.IDDOMINIOFILHO = DOMINIOFILHO.IDDOMINIO
                AND SUBFORMULARIOCAMPO.IDNIVELCAMPOVALOR >= :iNivel
            )
        AND IDDOMINIOFILHO IN
            (
                SELECT --//DISTINCT 
                    DOMINIOFILHO.IDDOMINIO
                FROM
                    CONTATOADM.DOMINIOHIERARQUIA DOMINIOHIERARQUIA,
                    CONTATOADM.SUBFORMULARIOCAMPO SUBFORMULARIOCAMPO,
                    CONTATOADM.DOMINIO DOMINIOPAI,
                    CONTATOADM.DOMINIO DOMINIOFILHO
                WHERE
                    DOMINIOHIERARQUIA.IDCAMPO = SUBFORMULARIOCAMPO.IDCAMPO
                AND SUBFORMULARIOCAMPO.IDSUBFORMULARIO = :idSubFormulario
                AND DOMINIOHIERARQUIA.IDDOMINIOPAI = DOMINIOPAI.IDDOMINIO
                AND DOMINIOHIERARQUIA.IDDOMINIOFILHO = DOMINIOFILHO.IDDOMINIO
                AND SUBFORMULARIOCAMPO.IDNIVELCAMPOVALOR >= :iNivel
            );

    ULOG_END( "proCExluirHierarquia()" );
}

// =========================================================================
void proCRemoverRelacionamentos( int idCampoPrm, int idUsuarioPrm )
{
    ULOG_START( "proCRemoverRelacionamentos()" );

    struct sqlca sqlca;
    MAP_INT mapListaIdSubFormulario;
    MAP_INT::iterator itmapListaIdSubFormulario;

    EXEC SQL BEGIN DECLARE SECTION;

        int idCampo = idCampoPrm;
        int idUsuario = idUsuarioPrm;
        // int idSubFormulario;
        // int listaUnicaIdSubFormulario[NRO_MAX_REG_ORA];
        // int it;
        // char listaNmLoginUsuario[NRO_MAX_REG_ORA][256];
        // VARCHAR nmLoginUsuario[256];

        // short i_nmLoginUsuario = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);

    // Log somente nos inserts por solicitação do analista funcional Indra
    // EXEC SQL WHENEVER NOT FOUND CONTINUE;
    // 
    // ULOG( "Vai obter NMLOGINUSUARIO para IDPESSOAUSUARIO=%d em ACESSO.USUARIO",idUsuario);
    // 
    // EXEC SQL
    //     SELECT 
    //        NMLOGINUSUARIO
    //     INTO
    //        :nmLoginUsuario:i_nmLoginUsuario
    //     FROM
    //        ACESSO.USUARIO
    //     WHERE
    //        IDPESSOAUSUARIO = :idUsuario;
    // 
    // if ( 1403 == sqlca.sqlcode )
    // {
    //     throw new TuxException("14E9999","Usuario não cadastrado");
    // }
    // 
    // CONVIND(nmLoginUsuario,i_nmLoginUsuario);
    // 
    // ULOG( "obteve NMLOGINUSUARIO=%s para IDPESSOAUSUARIO=%d em ACESSO.USUARIO",nmLoginUsuario.arr,idUsuario);
    // 
    // varre a lista de IDSUBFORMULARIO´s que será alterada
    // EXEC SQL DECLARE curLogSubFormCampo CURSOR FOR
    //     SELECT DISTINCT
    //         IDSUBFORMULARIO
    //     FROM
    //         CONTATOADM.SUBFORMULARIOCAMPO
    //     WHERE
    //         IDCAMPO = :idCampo;
    // 
    // EXEC SQL WHENEVER NOT FOUND DO BREAK;
    // 
    // EXEC SQL OPEN curLogSubFormCampo;
    // 
    // while(true)
    // {
    //     EXEC SQL FETCH curLogSubFormCampo INTO :idSubFormulario;
    // 
    //     // cria lista contendo valores únicos de idSubFormulario
    //     itmapListaIdSubFormulario = mapListaIdSubFormulario.find(idSubFormulario);
    // 
    //     if ( itmapListaIdSubFormulario == mapListaIdSubFormulario.end() )
    //     { // se não encontrou insere na lista unica
    //         mapListaIdSubFormulario[idSubFormulario] = idSubFormulario;
    //     }
    // }
    // 
    // EXEC SQL CLOSE curLogSubFormCampo;
    // 
    // EXEC SQL WHENEVER NOT FOUND CONTINUE;
    // 
    // preenche a lista de IDs únicos
    // memset(&listaNmLoginUsuario,0,sizeof(listaNmLoginUsuario));
    // memset(&listaUnicaIdSubFormulario,0,sizeof(listaUnicaIdSubFormulario));
    // 
    // itmapListaIdSubFormulario = mapListaIdSubFormulario.begin();
    // 
    // while (itmapListaIdSubFormulario != mapListaIdSubFormulario.end() )
    // {
    //     itmapListaIdSubFormulario++;
    // 
    //     if ( it > NRO_MAX_REG_ORA )
    //     { // bastante improvavel 100 grupos associados a um mesmo campo!
    //         throw new TuxException("14E9999","Limite de campos atingido.");
    //     }
    // 
    //     listaUnicaIdSubFormulario[it] = mapListaIdSubFormulario[idSubFormulario];
    //     strcpy(listaNmLoginUsuario[it],(char*)nmLoginUsuario.arr);
    //     it++;
    // }
    // 
    // grava log da alteração em SUBFORMULARIOCAMPO
    // ULOG( "Vai inserir em CONTATOADM.SUBFORMULARIOCAMPOLOG o log da alteração do campo %d",idCampo);
    // 
    // EXEC SQL
    //     INSERT INTO
    //         CONTATOADM.SUBFORMULARIOCAMPOLOG
    //             (IDSUBFORMULARIOCAMPOLOG,
    //              NMLOGINUSUARIO,
    //              DTULTIMAALTERACAO,
    //              IDSUBFORMULARIO)
    //     VALUES
    //             (CONTATOADM.SUBFORMULARIOCAMPOLOGSQ.NEXTVAL,
    //             :listaNmLoginUsuario,
    //             SYSDATE,
    //             :listaUnicaIdSubFormulario);

    ULOG( "Vai remover campo %ld de CONTATOADM.DOMINIOHIERARQUIA",idCampo );

    EXEC SQL
        DELETE
            CONTATOADM.DOMINIOHIERARQUIA
        WHERE
            IDCAMPO = :idCampo;

    ULOG( "Vai remover campo %ld de CONTATOADM.SUBFORMULARIOCAMPO",idCampo );

    EXEC SQL
        DELETE
            CONTATOADM.SUBFORMULARIOCAMPO
        WHERE
            IDCAMPO = :idCampo;

    ULOG_END( "proCRemoverRelacionamentos()" );
}

// =========================================================================
bool proCBuscarIdTabelaDominio(int *idTabelaDominioPrm,const char *nmTabelaDominioPrm)
{
    ULOG_START( "proCBuscarIdTabelaDominio()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        int idTabelaDominio;
        const char *nmTabelaDominio = nmTabelaDominioPrm;
    EXEC SQL END DECLARE SECTION;

    ULOG( "Pesquisando CONTATOADM.TABELADOMINIO para NMTABELADOMINIO=[%s]",nmTabelaDominio );

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        SELECT
           IDTABELADOMINIO
        INTO
           :idTabelaDominio
        FROM
           CONTATOADM.TABELADOMINIO
        WHERE
           UPPER(TRIM(NMTABELADOMINIO)) = UPPER(TRIM(:nmTabelaDominio));

    if ( idTabelaDominioPrm )
    {
        *idTabelaDominioPrm = sqlca.sqlcode == 0 ? idTabelaDominio : 0;
        ULOG( "idTabelaDominio=%d",*idTabelaDominioPrm );
    }

    ULOG_END( "proCBuscarIdTabelaDominio()" );

    return sqlca.sqlcode == 0 ? true : false;
}

// =========================================================================
void proCListaGrupos( XMLGen* saida )
{
    ULOG_START( "proCListaGrupos()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int idSubFormulario;
        VARCHAR nmSubFormulario[256];
        short i_nmSubFormulario;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);

    EXEC SQL DECLARE GrupoDependentes CURSOR FOR
        SELECT
            IDSUBFORMULARIO ,
            NMSUBFORMULARIO
        FROM
            CONTATOADM.SUBFORMULARIO
        WHERE
            IDTIPOSUBFORMULARIO = 2
        ORDER BY 
            UPPER(NMSUBFORMULARIO);

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    saida->createTag( "AdmGruposCamposVO" );
    saida->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
    saida->addProp("xmlns:ns1", "usuario.fo.vivo.com.br/vo" );

    EXEC SQL OPEN GrupoDependentes;

    while(true)
    {
        i_nmSubFormulario = -1;

        EXEC SQL FETCH GrupoDependentes INTO :idSubFormulario,
                                             :nmSubFormulario:i_nmSubFormulario;
        CONVIND( nmSubFormulario,i_nmSubFormulario );

        saida->createTag("AdmGrupoCamposVO");
            saida->addItem("idGrupoCampos", idSubFormulario );
            saida->addItem("nmGrupoCampos", (char *)nmSubFormulario.arr );
        saida->closeTag();
    }

    EXEC SQL CLOSE GrupoDependentes;

    saida->closeTag(); //AdmGruposCamposVO

    ULOG_END( "proCListaGrupos()" );

}

// =========================================================================
void proCCamposValores( int idSubFormularioPrm,XMLGen* xml )
{
    ULOG_START( "proCCamposValores()" );

    struct sqlca sqlca;
    int inContatoAssociado;
    int inSubFormularios;   // Indicador de habilitação/desabilitação do botão de excluir valores
                            // 0 - Não há relacionamento em mais de um idSubFormulario
                            // 1 - Há relacionamento com mais de um idSubFormulario


    EXEC SQL BEGIN DECLARE SECTION;

        int idSubFormulario = idSubFormularioPrm;
        int idCampo;
        int idNivel;
        int ctContatosRelacionados;
        VARCHAR nmCampo[2001];

        short i_nmCampo = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);

    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    // 
    // Verifica se o Grupo, está relacionado a algum contato.
    // 
    EXEC SQL
        SELECT
           COUNT(1)
        INTO
           :ctContatosRelacionados
        FROM 
           CONTATOADM.CONTATOFOLHACAMPO
        WHERE
           IDSUBFORMULARIO = :idSubFormulario;
    
    inContatoAssociado = (ctContatosRelacionados > 0) ? 1:0;


    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE CamposValores CURSOR FOR
        SELECT
            SUBFORMULARIOCAMPO.IDCAMPO,
            CAMPO.NMCAMPO,
            SUBFORMULARIOCAMPO.IDNIVELCAMPOVALOR
        FROM
            CONTATOADM.SUBFORMULARIOCAMPO SUBFORMULARIOCAMPO,
            CONTATOADM.CAMPO CAMPO
        WHERE
            SUBFORMULARIOCAMPO.IDCAMPO = CAMPO.IDCAMPO
        AND
            SUBFORMULARIOCAMPO.IDSUBFORMULARIO = :idSubFormulario
        ORDER BY
            SUBFORMULARIOCAMPO.IDNIVELCAMPOVALOR;

    xml->createTag( "AdmGruposCamposDependentesVO" );
    xml->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
    xml->addProp("xmlns:ns1", "usuario.fo.vivo.com.br/vo" );
    xml->addItem("inContatoAssociado", inContatoAssociado );

    EXEC SQL OPEN CamposValores;
    
    while(true)
    {
        i_nmCampo = -1;

        EXEC SQL FETCH CamposValores INTO :idCampo,
                                          :nmCampo:i_nmCampo,
                                          :idNivel;

        CONVIND( nmCampo,i_nmCampo );

        xml->createTag( "AdmGrupoCamposDependentesVO" );
        xml->addItem("idCampoDependente", idCampo );
        xml->addItem("nmCampoDependente", (char *)nmCampo.arr );
        xml->addItem("nrNivel", idNivel );
        
        inSubFormularios = proCRelacaoCampoSubFormulario(idCampo,idSubFormulario);
        xml->addItem("inSubFormularios", inSubFormularios );  //  1 - Inibe o botao excluir valor

        procCObterNmDominioPorIdCampo( idCampo,xml );

        xml->closeTag();

    }

    EXEC SQL CLOSE CamposValores;
    xml->closeTag();

    ULOG_END( "proCCamposValores()" );

}

// =========================================================================
void procCObterNmDominioPorIdCampo( int idCampoPrm,XMLGen* xml )
{
    ULOG_START( "procCObterNmDominioPorIdCampo()" );

    struct sqlca sqlca;


    EXEC SQL BEGIN DECLARE SECTION;

        int idCampo = idCampoPrm;

        int idDominio;
        VARCHAR nmDominio[256];
        short i_nmDominio;

    EXEC SQL END DECLARE SECTION;

    ULOG( "Pesquisando idCampo [%d]",idCampo );

    EXEC SQL DECLARE cursorCampoDominio CURSOR FOR
        SELECT DISTINCT
           DOMINIO.IDDOMINIO ,
           DOMINIO.NMDOMINIO
        FROM
           CONTATOADM.DOMINIO DOMINIO,
           CONTATOADM.CAMPODOMINIO CAMPODOMINIO
        WHERE
           CAMPODOMINIO.IDCAMPO = :idCampo
        AND
           DOMINIO.IDTABELADOMINIO = CAMPODOMINIO.IDTABELADOMINIO
        AND
           DOMINIO.INDISPONIBILIDADE = 3
        ORDER BY
            UPPER(DOMINIO.NMDOMINIO);

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL OPEN cursorCampoDominio;

    for(;;)
    {
        i_nmDominio = -1;

        EXEC SQL FETCH cursorCampoDominio INTO :idDominio ,
                                               :nmDominio:i_nmDominio ;

        CONVIND( nmDominio,i_nmDominio );

        xml->createTag( "AdmCampoVO" );
            xml->addItem("idCampo", idDominio );
            xml->addItem("nmCampo", (char *)nmDominio.arr );
        xml->closeTag();
    }

    EXEC SQL CLOSE cursorCampoDominio;

    ULOG_END( "procCObterNmDominioPorIdCampo()" );
}

// =========================================================================
void proCListaArvore( int idSubFormularioPrm, int iNivelPrm, XMLGen * saida )
{
    ULOG_START( "proCListaArvore()" );

    struct sqlca sqlca;
    //int loop = 0;
    int iNivelAux = 0;
    VEC_ORAARVOREDOMINIO vecOraArvoreDominio;

    EXEC SQL BEGIN DECLARE SECTION;

        int idSubFormulario = idSubFormularioPrm;
        int iNivel = iNivelPrm - 1;

        VARCHAR nmSubFormulario[61];
        short i_nmSubFormulario = -1;

        struct OraArvoreDominio oraArvoreDominio;
        struct StatusOraArvoreDominio statusOraArvoreDominio;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    ULOG("Vai obter nmSubformulario para idSubFormulario=%d",idSubFormulario);
  
    EXEC SQL
        SELECT
            NMSUBFORMULARIO 
        INTO
            :nmSubFormulario:i_nmSubFormulario
        FROM
            CONTATOADM.SUBFORMULARIO
        WHERE
            IDSUBFORMULARIO = :idSubFormulario 
        AND
            ROWNUM < 2;

    if ( 1403 == sqlca.sqlcode )
    {
        throw new TuxException("14E9999","Subformulário não cadastrado!");
    }

    CONVIND( nmSubFormulario,i_nmSubFormulario );

    ULOG("nmSubformulario para idSubFormulario %d='%s'",idSubFormulario,nmSubFormulario.arr);

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE CursorArvoreDominio CURSOR FOR 
        SELECT
            IDDOMINIOPAI,
            NMDOMINIOPAI,
            IDDOMINIOFILHO,
            NMDOMINIOFILHO,
            IDCAMPO,
            NMPATH,
            IDNIVELCAMPOVALOR,
            0 AS INPROCESSADO
        FROM
        (
            SELECT --//DISTINCT
                DOMINIOPAI.IDDOMINIO AS IDDOMINIOPAI,
                DOMINIOPAI.NMDOMINIO AS NMDOMINIOPAI,
                DOMINIOFILHO.IDDOMINIO AS IDDOMINIOFILHO,
                DOMINIOFILHO.NMDOMINIO NMDOMINIOFILHO,
                DOMINIOHIERARQUIA.IDCAMPO,
                DOMINIOHIERARQUIA.NMPATH,
                SUBFORMULARIOCAMPO.IDNIVELCAMPOVALOR
            FROM
                CONTATOADM.DOMINIOHIERARQUIA DOMINIOHIERARQUIA,
                CONTATOADM.SUBFORMULARIOCAMPO SUBFORMULARIOCAMPO,
                CONTATOADM.DOMINIO DOMINIOPAI,
                CONTATOADM.DOMINIO DOMINIOFILHO
            WHERE
                DOMINIOHIERARQUIA.IDCAMPO = SUBFORMULARIOCAMPO.IDCAMPO
            AND SUBFORMULARIOCAMPO.IDSUBFORMULARIO = :idSubFormulario
            AND DOMINIOHIERARQUIA.IDSUBFORMULARIO = SUBFORMULARIOCAMPO.IDSUBFORMULARIO
            AND DOMINIOHIERARQUIA.IDDOMINIOPAI = DOMINIOPAI.IDDOMINIO
            AND DOMINIOHIERARQUIA.IDDOMINIOFILHO = DOMINIOFILHO.IDDOMINIO
            AND SUBFORMULARIOCAMPO.IDNIVELCAMPOVALOR >= :iNivel
        UNION
            SELECT --//DISTINCT
                DOMINIO.IDDOMINIO AS IDDOMINIOPAI,
                DOMINIO.NMDOMINIO AS NMDOMINIOPAI,
                DOMINIO.IDDOMINIO AS IDDOMINIOFILHO,
                DOMINIO.NMDOMINIO AS NMDOMINIOFILHO,
                CAMPODOMINIO.IDCAMPO,
                DOMINIO.NMDOMINIO || '/' AS NMPATH,
                SUBFORMULARIOCAMPO.IDNIVELCAMPOVALOR
            FROM
                CONTATOADM.DOMINIO DOMINIO,
                CONTATOADM.CAMPODOMINIO CAMPODOMINIO,
                CONTATOADM.SUBFORMULARIOCAMPO SUBFORMULARIOCAMPO
            WHERE
                DOMINIO.IDTABELADOMINIO = CAMPODOMINIO.IDTABELADOMINIO
            AND DOMINIO.INDISPONIBILIDADE = 3 --// 3= tem campo dependente
            AND CAMPODOMINIO.IDCAMPO = SUBFORMULARIOCAMPO.IDCAMPO
            AND SUBFORMULARIOCAMPO.IDSUBFORMULARIO = :idSubFormulario
            AND SUBFORMULARIOCAMPO.IDNIVELCAMPOVALOR = 1
        )
        ORDER BY
            UPPER(NMPATH);
            // IDDOMINIOPAI,
            // UPPER(NMDOMINIOPAI),
            // IDNIVELCAMPOVALOR,
            // UPPER(NMDOMINIOFILHO);

    EXEC SQL OPEN CursorArvoreDominio;

    while(true)
    {
        memset(&oraArvoreDominio,0,sizeof(oraArvoreDominio));
        memset(&statusOraArvoreDominio,-1,sizeof(statusOraArvoreDominio));

        EXEC SQL FETCH CursorArvoreDominio INTO :oraArvoreDominio:statusOraArvoreDominio;

        CONVIND( oraArvoreDominio.nmDominioPai,statusOraArvoreDominio.nmDominioPai );
        CONVIND( oraArvoreDominio.nmDominioFilho,statusOraArvoreDominio.nmDominioFilho);

        vecOraArvoreDominio.push_back(oraArvoreDominio);
    } 

    EXEC SQL CLOSE CursorArvoreDominio;

    saida->createTag( "AdmArvoreGruposCamposDependentesVO" );
    saida->createTag( "TreeItemVO" );
    saida->addItem("nivel", 0 );

    // Monta a árvore do grupo informado
    if ( vecOraArvoreDominio.size() > 0 )
    {
        for (int i = 0; i < vecOraArvoreDominio.size(); i++)
        {
            if (vecOraArvoreDominio.at(i).idDominioPai == vecOraArvoreDominio.at(i).idDominioFilho )
            {
                montarFamilia(vecOraArvoreDominio.at(i).idDominioPai
                             ,vecOraArvoreDominio.at(i).nmPath.arr
                             ,i
                             ,vecOraArvoreDominio
                             ,saida);
            }
        }
    }

    saida->closeTag(); // TreeItemVO
    saida->addItem("idGrupo", idSubFormulario );
    saida->addItem("nmGrupo", (char *)nmSubFormulario.arr );
    saida->closeTag(); // AdmArvoreGruposCamposDependentesVO

    ULOG_END( "proCListaArvore()" );
}

// =========================================================================
void proCGetCamposNivel(DadosEntradaGetCamposNivel dadosEntradaGetCamposNivel,XMLGen * saida )
{
    ULOG_START( "proCGetCamposNivel()" );

    struct sqlca sqlca;
    string nmDominioFilhoAnterior;
    string nmPathAnterior;
    char nmTabela[256];

    nmPathAnterior = dadosEntradaGetCamposNivel.nmPath;
    nmPathAnterior += "%";

    EXEC SQL BEGIN DECLARE SECTION;
        struct
        {
            VARCHAR nmDominioFilho[256];
            VARCHAR idCampo[21];
            VARCHAR idNivelCampoValor[21];
            VARCHAR nmPath[4001];
        } OraDadosProximoNivel;

        struct
        {
            short nmDominioFilho;
            short idCampo;
            short idNivelCampoValor;
            short nmPath;
        } OraStatusProximoNivel;

        int idDominioPai = dadosEntradaGetCamposNivel.idDominioPai;
        int iNivel = dadosEntradaGetCamposNivel.idNivel;
        int iNivelAnt = iNivel - 1;
        int idSubFormulario = dadosEntradaGetCamposNivel.idSubFormulario;
        const char *nmPath = nmPathAnterior.c_str();
        VARCHAR nmCampo[2001];
        VARCHAR nmTabelaDominio[256];

        int idDominio = 0;
        int idTabelaDominio = 0;
        short i_idTabelaDominio = -1;

        short i_nmPathNivelAnt = -1;
        short i_nmCampo;
        short i_idDominio;
    EXEC SQL END DECLARE SECTION;

    ULOG("idSubFormulario=%d,Nivel=%d,idDominioPai=%d,nmPath=%s"
                                        ,idSubFormulario,iNivel,idDominioPai,nmPath);

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL DECLARE cursorProximoNivel CURSOR FOR
        SELECT
            DOMINIOFILHO.NMDOMINIO AS NMDOMINIOFILHO,
            DOMINIOHIERARQUIA.IDCAMPO,
            SUBFORMULARIOCAMPO.IDNIVELCAMPOVALOR,
            DOMINIOHIERARQUIA.NMPATH
        FROM
            CONTATOADM.DOMINIOHIERARQUIA DOMINIOHIERARQUIA,
            CONTATOADM.SUBFORMULARIOCAMPO SUBFORMULARIOCAMPO,
            CONTATOADM.DOMINIO DOMINIOFILHO
        WHERE
            DOMINIOHIERARQUIA.IDCAMPO = SUBFORMULARIOCAMPO.IDCAMPO
        AND SUBFORMULARIOCAMPO.IDSUBFORMULARIO = :idSubFormulario
		AND DOMINIOHIERARQUIA.IDSUBFORMULARIO = SUBFORMULARIOCAMPO.IDSUBFORMULARIO
        AND DOMINIOHIERARQUIA.IDDOMINIOPAI = :idDominioPai 
        AND DOMINIOHIERARQUIA.IDDOMINIOFILHO = DOMINIOFILHO.IDDOMINIO
        AND SUBFORMULARIOCAMPO.IDNIVELCAMPOVALOR = :iNivel
        AND DOMINIOHIERARQUIA.NMPATH LIKE :nmPath --// a path deve conter o caminho anterior
        ORDER BY
            UPPER(DOMINIOFILHO.NMDOMINIO);

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL OPEN cursorProximoNivel;
        
    bool header = false;

    while (true)
    {
        memset(&OraDadosProximoNivel,0,sizeof(OraDadosProximoNivel));
        memset(&OraStatusProximoNivel,-1,sizeof(OraStatusProximoNivel));

        EXEC SQL FETCH cursorProximoNivel INTO :OraDadosProximoNivel:OraStatusProximoNivel;

        CONVIND(OraDadosProximoNivel.nmDominioFilho,OraStatusProximoNivel.nmDominioFilho);
        CONVIND(OraDadosProximoNivel.idCampo,OraStatusProximoNivel.idCampo);
        CONVIND(OraDadosProximoNivel.idNivelCampoValor,OraStatusProximoNivel.idNivelCampoValor);
        CONVIND(OraDadosProximoNivel.nmPath,OraStatusProximoNivel.nmPath);

        if( !header )
        {
            ULOG( "vai obter NMCAMPO para IDCAMPO=[%s]",OraDadosProximoNivel.idCampo.arr );

            i_nmCampo = -1;

                EXEC SQL
                SELECT
                    NMCAMPO
                INTO
                    :nmCampo:i_nmCampo
                FROM
                    CONTATOADM.CAMPO 
                WHERE
                    IDCAMPO = :OraDadosProximoNivel.idCampo;

                CONVIND( nmCampo,i_nmCampo );

            ULOG("nmCampo=[%s]",(char *)nmCampo.arr);

            string nmPathAnterior;
            if ( iNivel > 1 )
            {
                nmPathAnterior = obterNmPathAnterior((char*)OraDadosProximoNivel.nmPath.arr,iNivel);
            }
            else
            {
                nmPathAnterior = (char*)OraDadosProximoNivel.nmPath.arr;
            }
                saida->createTag( "AdmGrupoCamposDependentesVO" );
                saida->addProp("xmlns:vo", "admsistemas.fo.vivo.com.br/vo" );
                saida->addItem("idCampoDependente",(char*)OraDadosProximoNivel.idCampo.arr);
                saida->addItem("nmCampoDependente",(char*)nmCampo.arr);
                saida->addItem("nrNivel",(char*)OraDadosProximoNivel.idNivelCampoValor.arr);
            saida->addItem("nmPath",(char *)nmPathAnterior.c_str() );

            header = true;
        }

        if ( strcmp(nmDominioFilhoAnterior.c_str(),(const char*)OraDadosProximoNivel.nmDominioFilho.arr) )
        {
            ULOG("Vai obter IDDOMINIO em CONTATOADM.DOMINIO para NMDOMINIOFILHO=[%s]",OraDadosProximoNivel.nmDominioFilho.arr);

            EXEC SQL WHENEVER NOT FOUND CONTINUE;

            sprintf(nmTabela,"tb_%s",(char *)nmCampo.arr);
            strToOra(nmTabelaDominio,nmTabela);

            EXEC SQL
                SELECT
                   IDTABELADOMINIO
                INTO
                   :idTabelaDominio:i_idTabelaDominio
                FROM
                   CONTATOADM.TABELADOMINIO
                WHERE
                   NMTABELADOMINIO = :nmTabelaDominio;


            i_idDominio = -1;

            EXEC SQL
                SELECT 
                   IDDOMINIO 
                INTO 
                   :idDominio:i_idDominio 
                FROM 
                   CONTATOADM.DOMINIO 
                WHERE 
                   NMDOMINIO = :OraDadosProximoNivel.nmDominioFilho
                AND
                   IDTABELADOMINIO = :idTabelaDominio
                AND 
                   ROWNUM < 2;

            nmDominioFilhoAnterior = (char*)OraDadosProximoNivel.nmDominioFilho.arr;

            ULOG( "Obteve IDDOMINIO=%d",idDominio);
        }

        saida->createTag( "AdmCampoVO" );
            saida->addItem("idCampo",idDominio );
            saida->addItem("nmCampo",(char *)OraDadosProximoNivel.nmDominioFilho.arr );
        saida->closeTag();
    }

    EXEC SQL CLOSE cursorProximoNivel;

    saida->closeTag();
    
    ULOG_END( "proCGetCamposNivel()" );
}

// =========================================================================
void proCGetCamposNivelArvore( int idSubFormularioPrm, int iNivelPrm, XMLGen * saida )
{
    ULOG_START( "proCGetCamposNivelArvore()" );

    struct sqlca sqlca;
    bool header = false;
    string nmDominioFilhoAnterior;

    EXEC SQL BEGIN DECLARE SECTION;
        int idSubFormulario = idSubFormularioPrm;
        int iNivel = iNivelPrm;

        VARCHAR nmCampo[2001];
        short i_nmCampo;

        struct
        {
            int idDominioPai;
            VARCHAR nmDominioPai[256];
            int idDominioFilho;
            VARCHAR nmDominioFilho[256];
            int idCampo;
            int idNivelCampoValor;
        } OraArvoreDominio;

        struct
        {
            short idDominioPai;
            short nmDominioPai;
            short idDominioFilho;
            short nmDominioFilho;
            short idCampo;
            short idNivelCampoValor;
        } StatusOraArvoreDominio;


    EXEC SQL END DECLARE SECTION;

    ULOG( "Pesquisando idSubFormulario [%d], Nivel [%d]",idSubFormulario,iNivel );

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);

    EXEC SQL DECLARE CampoValorArvore CURSOR FOR
        SELECT --//DISTINCT
            DOMINIO.IDDOMINIO AS IDDOMINIOPAI,
            DOMINIO.NMDOMINIO AS NMDOMINIOPAI,
            DOMINIO.IDDOMINIO AS IDDOMINIOFILHO,
            DOMINIO.NMDOMINIO AS NMDOMINIOFILHO,
            CAMPODOMINIO.IDCAMPO ,
            SUBFORMULARIOCAMPO.IDNIVELCAMPOVALOR
        FROM
            CONTATOADM.DOMINIO DOMINIO,
            CONTATOADM.CAMPODOMINIO CAMPODOMINIO,
            CONTATOADM.SUBFORMULARIOCAMPO SUBFORMULARIOCAMPO
        WHERE
            DOMINIO.IDTABELADOMINIO = CAMPODOMINIO.IDTABELADOMINIO
        AND DOMINIO.INDISPONIBILIDADE = 3 --// 3= tem campo dependente
        AND CAMPODOMINIO.IDCAMPO = SUBFORMULARIOCAMPO.IDCAMPO
        AND SUBFORMULARIOCAMPO.IDSUBFORMULARIO = :idSubFormulario
        AND SUBFORMULARIOCAMPO.IDNIVELCAMPOVALOR = :iNivel
        ORDER BY UPPER(DOMINIO.NMDOMINIO);

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL OPEN CampoValorArvore;

    while(true)
    {
        memset(&OraArvoreDominio,0,sizeof(OraArvoreDominio));
        memset(&StatusOraArvoreDominio,-1,sizeof(StatusOraArvoreDominio));

        EXEC SQL FETCH CampoValorArvore INTO :OraArvoreDominio:StatusOraArvoreDominio;

        if ( false == header )
        {
            ULOG( "Vai pesquisar nome de campo para idCampo=%d",OraArvoreDominio.idCampo );

            i_nmCampo = -1;

            EXEC SQL
                SELECT 
                   NMCAMPO
                INTO 
                   :nmCampo:i_nmCampo
                FROM 
                   CONTATOADM.CAMPO
                WHERE 
                   IDCAMPO = :OraArvoreDominio.idCampo;

            CONVIND( nmCampo,i_nmCampo );

            ULOG( "Nome de campo para idCampo %d = [%s]",OraArvoreDominio.idCampo,nmCampo.arr );

            saida->createTag( "AdmGrupoCamposDependentesVO" );
            saida->addProp("xmlns:vo", "admsistemas.fo.vivo.com.br/vo" );
                saida->addItem("idCampoDependente", OraArvoreDominio.idCampo);
                saida->addItem("nmCampoDependente",(char*)nmCampo.arr);
                saida->addItem("nrNivel", OraArvoreDominio.idNivelCampoValor);
            header = true;
        }

        CONVIND( OraArvoreDominio.nmDominioPai,StatusOraArvoreDominio.nmDominioPai );
        CONVIND( OraArvoreDominio.nmDominioFilho,StatusOraArvoreDominio.nmDominioFilho);

        // if ( strcmp(nmDominioFilhoAnterior.c_str(),(const char*)nmDominio.arr) )
        // {
        //     ULOG("vai obter idValor para nmDominio=[%s]",(char *)nmDominio.arr);
        // 
        //     i_idValor = -1;
        // 
        //     EXEC SQL WHENEVER NOT FOUND CONTINUE;
        //     EXEC SQL
        //         SELECT 
        //            IDDOMINIO 
        //         INTO 
        //            :idValor:i_idValor 
        //         FROM 
        //            CONTATOADM.DOMINIO 
        //         WHERE 
        //            NMDOMINIO = :nmDominio
        //         AND ROWNUM < 2;
        // 
        //     nmDominioFilhoAnterior = (char*)nmDominio.arr;
        // 
        //     ULOG( "Obteve idValor [%d] - nmDominio [%s]",idValor,(char *)nmDominio.arr );
        // }

        // saida->createTag( "AdmCampoVO" );
        //     saida->addItem("id", OraArvoreDominio.idDominio );
        //     saida->addItem("", OraArvoreDominio.idDominio );
        //     saida->addItem("idCampo", OraArvoreDominio.idCampo );
        //     saida->addItem("nmCampo", (char *)OraArvoreDominio.nmDominio.arr );
        // saida->closeTag();

        saida->createTag( "AdmCampoVO" );
            saida->addItem("id", OraArvoreDominio.idDominioFilho );
            saida->addItem("idCampo", OraArvoreDominio.idCampo );
            saida->addItem("nmCampo", (char *)OraArvoreDominio.nmDominioFilho.arr );
            saida->addItem("descricao", (char *)OraArvoreDominio.nmDominioFilho.arr );
            saida->addItem("descricaoPai", (char *)OraArvoreDominio.nmDominioPai.arr );
            saida->addItem("nivel", OraArvoreDominio.idNivelCampoValor );
            saida->addItem("idPai", OraArvoreDominio.idDominioPai );
        saida->closeTag();

    }

    EXEC SQL CLOSE CampoValorArvore;

    saida->closeTag();

    ULOG_END( "proCGetCamposNivelArvore()" );
}

// =========================================================================
void proCGetProximoNivel( int idCampoPrm, int iNivelPrm, XMLGen * saida )
{
    ULOG_START( "proCGetProximoNivel()" );

    struct sqlca sqlca;
    bool header = false;
    char nmTabela[256];

    EXEC SQL BEGIN DECLARE SECTION;

        // int idSubFormulario = 0;
        int iNivel = iNivelPrm;
        int idCampo = idCampoPrm;
        int idNivel;

        //int idValor = 0;
        VARCHAR nmValor[256];
        short i_nmValor;

        // VARCHAR nmSubFormulario[256];
        // short i_nmSubFormulario = -1;

        VARCHAR nmCampo[2001];
        short i_nmCampo = -1;

        int idDominio = 0;
        short i_idDominio = -1;

        int idTabelaDominio=0;
        short i_idTabelaDominio = -1;
        VARCHAR nmTabelaDominio[256];

    EXEC SQL END DECLARE SECTION;

    // ULOG( "Pesquisando idSubFormulario [%d], Nivel [%d]",idSubFormulario,iNivel );

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    // EXEC SQL
    //     SELECT
    //         NMSUBFORMULARIO
    //     INTO
    //         :nmSubFormulario:i_nmSubFormulario
    //     FROM
    //         CONTATOADM.SUBFORMULARIO
    //     WHERE
    //         IDSUBFORMULARIO = :idSubFormulario 
    //     AND
    //         ROWNUM < 2;

    // if ( 1403 == sqlca.sqlcode )
    // {
    //     throw new TuxException("14E9999","Grupo não encontrado");
    // }

    // CONVIND( nmSubFormulario,i_nmSubFormulario );

    EXEC SQL DECLARE GetProximoNivel CURSOR FOR
        SELECT DISTINCT
            DOMINIO.NMDOMINIO,
            CAMPODOMINIO.IDCAMPO,
            SUBFORMULARIOCAMPO.IDNIVELCAMPOVALOR
        FROM
            CONTATOADM.DOMINIO DOMINIO,
            CONTATOADM.CAMPODOMINIO CAMPODOMINIO,
            CONTATOADM.SUBFORMULARIOCAMPO SUBFORMULARIOCAMPO
        WHERE
            DOMINIO.IDTABELADOMINIO = CAMPODOMINIO.IDTABELADOMINIO
        AND CAMPODOMINIO.IDCAMPO = SUBFORMULARIOCAMPO.IDCAMPO
        AND SUBFORMULARIOCAMPO.IDSUBFORMULARIO = (SELECT IDSUBFORMULARIO
                                                    FROM CONTATOADM.SUBFORMULARIOCAMPO
                                                   WHERE IDCAMPO = :idCampo)
        AND SUBFORMULARIOCAMPO.IDNIVELCAMPOVALOR = :iNivel;

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL OPEN GetProximoNivel;

    for(;;)
    {
        i_nmValor = -1;
        EXEC SQL FETCH GetProximoNivel INTO
                                    :nmValor:i_nmValor ,
                                    :idCampo ,
                                    :idNivel ;

        CONVIND( nmValor,i_nmValor );

        ULOG( "nmValor=[%s],idCampo=%d,idNivel=%d",nmValor.arr,idCampo,idNivel);

        if ( header == false )
        {
            header = true;
            i_nmCampo = -1;

            EXEC SQL
                SELECT
                    NMCAMPO
                INTO
                    :nmCampo:i_nmCampo
                FROM
                    CONTATOADM.CAMPO
                WHERE
                    IDCAMPO = :idCampo;

            CONVIND( nmCampo,i_nmCampo );

            ULOG( "nmCampo=[%s]",nmCampo.arr);

            saida->createTag( "AdmGrupoCamposDependentesVO" );
            saida->addItem("nmCampoDependente",(char*)nmCampo.arr );
        }

        sprintf( nmTabela,"tb_%s",(char*)nmCampo.arr );
        strToOra(nmTabelaDominio,nmTabela);

        EXEC SQL
            SELECT
               IDTABELADOMINIO
            INTO
               :idTabelaDominio:i_idTabelaDominio
            FROM
               CONTATOADM.TABELADOMINIO
            WHERE
               NMTABELADOMINIO = :nmTabelaDominio;

        EXEC SQL
            SELECT 
               IDDOMINIO
            INTO
               :idDominio:i_idDominio
            FROM
               CONTATOADM.DOMINIO
            WHERE
               UPPER(NMDOMINIO) = UPPER(:nmValor)
            AND
               IDTABELADOMINIO = :idTabelaDominio
            AND
               ROWNUM < 2;

        if ( 1403 == sqlca.sqlcode )
        {
            throw new TuxException("14E9999","Dominio de campo não encontrado");
        }

        ULOG( "idDominio=%d",idDominio);

        saida->createTag( "AdmCampoVO" );
            saida->addItem("idCampo", idDominio );
            saida->addItem("nmCampo", (char *)nmValor.arr );
        saida->closeTag();
    }

    EXEC SQL CLOSE GetProximoNivel;

    saida->closeTag();
    
    ULOG_END( "proCGetProximoNivel()" );

}

// =========================================================================
void proCGravaProcArvore( int idUsuarioPrm,int idSubFormularioPrm,int iNivelPrm,
                          int idCampoPrm,const char * nmValorPaiPrm,const char * nmValorFilhoPrm )
{
    ULOG_START( "proCGravaProcArvore()" );

    struct sqlca sqlca;
    char buffer[256];

    EXEC SQL BEGIN DECLARE SECTION;
        int idSubFormulario = idSubFormularioPrm;
        int iNivel = iNivelPrm;
        int idCampo = idCampoPrm;
        short i_idCampo = -1;
        //VARCHAR nmValorPai[256];
        //VARCHAR nmValorFilho[256];
        const char *nmValorFilho = nmValorFilhoPrm;
        VARCHAR nmtbDominio[256] ;
        short i_nmtbDominio = -1 ;
        VARCHAR nmCampo[2001] ;
        short i_nmCampo = -1 ;
        int idTabelaDominio;
        int idUsuario = idUsuarioPrm;

    EXEC SQL END DECLARE SECTION;

    //memset(&nmValorPai,0x0,sizeof(nmValorPai));
    //memset(&nmValorFilho,0x0,sizeof(nmValorFilho));

    //strToOra(nmValorPai,nmValorPaiPrm);
    //strToOra(nmValorFilho,nmValorFilhoPrm);

    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);

    ULOG( "Vai buscar dados de campo para [%s]",nmValorFilho);

    EXEC SQL
        SELECT
            CAMPODOMINIO.IDCAMPO,
            CAMPO.NMCAMPO NMCAMPO
        INTO
            :idCampo:i_idCampo,
            :nmCampo:i_nmCampo
        FROM 
            CONTATOADM.CAMPODOMINIO CAMPODOMINIO,
            CONTATOADM.CAMPO CAMPO
        WHERE
            CAMPODOMINIO.IDCAMPO = CAMPO.IDCAMPO (+)
        AND CAMPODOMINIO.IDTABELADOMINIO IN (SELECT IDTABELADOMINIO
                                             FROM CONTATOADM.DOMINIO
                                             WHERE NMDOMINIO = :nmValorFilho
                                             AND ROWNUM < 2);

    EXEC SQL
        SELECT
            NMCAMPO 
        INTO
            nmCampo:i_nmCampo
        FROM
            CONTATOADM.CAMPO
        WHERE
            IDCAMPO = :idCampo;

    CONVIND( nmCampo,i_nmCampo );

    sprintf( buffer,"tb_%s",(char *)nmCampo.arr );
    strToOra(nmtbDominio,buffer);
    
    if ( proCBuscarIdTabelaDominio( &idTabelaDominio,buffer ) == false )
    {
        EXEC SQL
            SELECT CONTATOADM.TABELADOMINIOSQ.NEXTVAL INTO :idTabelaDominio FROM DUAL;

        ULOG( "Campos Dependentes: Inserindo idTabelaDominio [%d], nmtbDominio [%s] "
                                                    ,idTabelaDominio,(char*)nmtbDominio.arr );

        // Armazena os valores associados ao campo
        EXEC SQL
            INSERT INTO CONTATOADM.TABELADOMINIO
            (
                IDTABELADOMINIO ,
                NMTABELADOMINIO ,
                IDUSUARIOALTERACAO ,
                DTULTIMAALTERACAO
            )
            VALUES
            (
               :idTabelaDominio ,
               :nmtbDominio ,
               :idUsuario ,
               SYSDATE
            );

    }

    if ( proCExisteCampoDominio(idCampo) == false ) // Nao existe campo e dominio associado
    {
        ULOG( "Inserindo CONTATOADM.CAMPODOMINIO idCampo [%d], idTabelaDominio [%d]",idCampo,idTabelaDominio );
        EXEC SQL
            INSERT INTO CONTATOADM.CAMPODOMINIO 
                ( IDCAMPO, IDTABELADOMINIO, IDUSUARIOALTERACAO, DTULTIMAALTERACAO )
            VALUES
                ( :idCampo, :idTabelaDominio, :idUsuario, SYSDATE  );
    }
    else  // Campo e dominio, jah estao associados, devemos apenas associar o campo com os novos dominios
    {
        EXEC SQL
            UPDATE 
               CONTATOADM.CAMPODOMINIO
            SET 
               IDTABELADOMINIO = :idTabelaDominio
            WHERE
               IDCAMPO = :idCampo;
    }

    //===========================================================================
    // Não estamos mais enviando solicitações de gravação à procedure
    // de gravação de hierarquia, pois com a remoção de multipla associação
    // de IDUFOPERADORA e IDTIPOLINHA não há mais a necessidade de persistência
    // nesta tabela via batch. -- Julho, 2007 -- Cassio.
    //===========================================================================
    //
    //ULOG( "Inserindo idSubFormulario [%d], iNivel [%d], idCampo [%d], nmValorPai [%s], nmValor [%s]",
    //       idSubFormulario ,
    //       iNivel ,
    //       idCampo ,
    //       (char *)nmValorPai.arr ,
    //       (char *)nmValorFilho.arr );
    //
    //EXEC SQL
    //    INSERT INTO CONTATOADM.PROCESSADOMINIOHIERARQUIA
    //    (
    //        IDPROCESSADOMINIOHIERARQUIA ,
    //        INPROCESSAMENTO ,
    //        IDSUBFORMULARIO ,
    //        IDCAMPO ,
    //        IDNIVELCAMPOVALOR ,
    //        NMDOMINIOPAI ,
    //        NMDOMINIOFILHO 
    //    )
    //    VALUES
    //    (
    //        CONTATOADM.PROCESSADOMINIOHIERARQUIASQ.NEXTVAL ,
    //        0 ,
    //        :idSubFormulario ,
    //        :idCampo ,
    //        :iNivel ,
    //        :nmValorPai ,
    //        :nmValorFilho
    //    );

    ULOG_END( "proCGravaProcArvore()" );
}

// =========================================================================
void proCGravaRelacionamentoCpoDepend(int idUsuarioPrm,VEC_PRODOMHIERARQUIA &vecProcDomHierarquia,const char *nmSubFormularioPrm)
{
    ULOG_START( "proCGravaRelacionamentoCpoDepend()" );

    struct sqlca sqlca;
    string strNmTabelaDominio;
    MAP_INT mapListaIdCampos;
    MAP_INT mapListaIdSubFormulario;
    MAP_INT::iterator itmapListaIdCampos;
    MAP_INT::iterator itmapListaIdSubFormulario;

    EXEC SQL BEGIN DECLARE SECTION;
        int listaIdCampo[NRO_MAX_REG_ORA];
        int listaIdSubFormulario[NRO_MAX_REG_ORA];
        int listaIdDominioPai[NRO_MAX_REG_ORA];
        int listaIdDominioFilho[NRO_MAX_REG_ORA];
        int listaIdTabelaDominio[NRO_MAX_REG_ORA];
        int listaUnicaIdCampo[NRO_MAX_REG_ORA];
        int listaUnicaIdSubFormulario[NRO_MAX_REG_ORA];
        int listaUnicaIdUsuario[NRO_MAX_REG_ORA];
        //char listaNmLoginUsuario[NRO_MAX_REG_ORA][256];
        char listaNmPath[NRO_MAX_REG_ORA][4001];

        short listaStatusIdCampo[NRO_MAX_REG_ORA];
        short listaStatusIdSubFormulario[NRO_MAX_REG_ORA];
        short listaStatusIdDominioPai[NRO_MAX_REG_ORA];
        short listaStatusIdDominioFilho[NRO_MAX_REG_ORA];
        short listaStatusIdTabelaDominio[NRO_MAX_REG_ORA];
        short listaStatusUnicaIdCampo[NRO_MAX_REG_ORA];
        short listaStatusUnicaIdSubFormulario[NRO_MAX_REG_ORA];
        short listaUnicaUnicaIdUsuario[NRO_MAX_REG_ORA];
        short listaStatusNmPath[NRO_MAX_REG_ORA];
        //short listaStatusNmLoginUsuario[NRO_MAX_REG_ORA];

        VARCHAR nmLoginUsuario[256];
        short i_nmLoginUsuario = -1;
        int idUsuario = idUsuarioPrm;
        int idSubFormulario;
        //int idTabelaDominio;
        //int idDominioRaiz;

        const char *nmTabelaDominio = nmSubFormularioPrm;
        //const char *nmDominio;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);

    // =========================================================================
    // Obtém o NMLOGINUSUARIO para gravar na tabela de log
    // =========================================================================
    //
    ULOG( "Vai obter NMLOGINUSUARIO para IDPESSOAUSUARIO=%d em ACESSO.USUARIO",idUsuario);

    EXEC SQL
        SELECT 
           NMLOGINUSUARIO
        INTO
           :nmLoginUsuario:i_nmLoginUsuario
        FROM
           ACESSO.USUARIO
        WHERE
           IDPESSOAUSUARIO = :idUsuario;

    if ( 1403 == sqlca.sqlcode )
    {
        throw new TuxException("14E9999","Usuario não cadastrado");
    }

    CONVIND(nmLoginUsuario,i_nmLoginUsuario);

    ULOG( "obteve NMLOGINUSUARIO=%s para IDPESSOAUSUARIO=%d em ACESSO.USUARIO",nmLoginUsuario.arr,idUsuario);

    // =========================================================================
    // Gera os nós dos campos dependentes e gera a árvore do grupo
    // =========================================================================
    //
    int i = 0;
    int j = 0;
    int sizeVecProcDomHierarquia = vecProcDomHierarquia.size();

    do
    {
        memset(&listaIdSubFormulario,0,sizeof(listaIdSubFormulario));
        memset(&listaIdCampo,0,sizeof(listaIdCampo));
        memset(&listaIdDominioPai,0,sizeof(listaIdDominioPai));
        memset(&listaIdDominioFilho,0,sizeof(listaIdDominioFilho));
        memset(&listaIdTabelaDominio,0,sizeof(listaIdTabelaDominio));
        memset(&listaUnicaIdCampo,0,sizeof(listaUnicaIdCampo));
        memset(&listaUnicaIdUsuario,0,sizeof(listaUnicaIdUsuario));
        memset(&listaUnicaIdSubFormulario,0,sizeof(listaUnicaIdSubFormulario));
        //memset(&listaNmLoginUsuario,0,sizeof(listaNmLoginUsuario));
        memset(&listaNmPath,0,sizeof(listaNmPath));

        memset(&listaStatusIdSubFormulario,-1,sizeof(listaStatusIdSubFormulario));
        memset(&listaStatusIdCampo,-1,sizeof(listaStatusIdCampo));
        memset(&listaStatusIdDominioPai,-1,sizeof(listaStatusIdDominioPai));
        memset(&listaStatusIdDominioFilho,-1,sizeof(listaStatusIdDominioFilho));
        memset(&listaStatusIdTabelaDominio,-1,sizeof(listaStatusIdTabelaDominio));
        memset(&listaStatusUnicaIdCampo,-1,sizeof(listaStatusUnicaIdCampo));
        memset(&listaStatusUnicaIdSubFormulario,-1,sizeof(listaStatusUnicaIdSubFormulario));
        memset(&listaUnicaUnicaIdUsuario,-1,sizeof(listaUnicaUnicaIdUsuario));
        memset(&listaStatusNmPath,-1,sizeof(listaStatusNmPath));
        //memset(&listaStatusNmLoginUsuario,-1,sizeof(listaStatusNmLoginUsuario));

        int itListaIdCampos = 0;
        int itListaIdSubFormulario = 0;

        for ( i=0; j < sizeVecProcDomHierarquia && i < NRO_MAX_REG_ORA; i++)
        {
            listaIdSubFormulario[i] = vecProcDomHierarquia.at(j).idSubFormulario;
            listaStatusIdSubFormulario[i] = 0;

            listaIdCampo[i] = vecProcDomHierarquia.at(j).idCampo;
            listaStatusIdCampo[i] = 0;

            listaIdDominioPai[i] = vecProcDomHierarquia.at(j).idDominioPai;
            listaStatusIdDominioPai[i] = 0;

            //strcpy(listaNmLoginUsuario[i],(char*)nmLoginUsuario.arr);
            //listaStatusNmLoginUsuario[i] = 0;

            strcpy(listaNmPath[i],vecProcDomHierarquia.at(j).nmPath.c_str());
            listaStatusNmPath[i] = 0;

            listaIdDominioFilho[i] = vecProcDomHierarquia.at(j).idDominioFilho;
            listaStatusIdDominioFilho[i] = 0;

            // cria lista contendo valores únicos de idCampo
            itmapListaIdCampos = mapListaIdCampos.find(listaIdCampo[i]);

            if ( itmapListaIdCampos == mapListaIdCampos.end() )
            { // se não encontrou insere na lista unica
                mapListaIdCampos[listaIdCampo[i]] = listaIdCampo[i];
                listaUnicaIdCampo[itListaIdCampos] = listaIdCampo[i];
                listaStatusUnicaIdCampo[itListaIdCampos] = 0;

                listaUnicaIdUsuario[itListaIdCampos] = idUsuario;

                strNmTabelaDominio = "tb_" + vecProcDomHierarquia.at(j).nmDominioFilho;
                //strNmTabelaDominio = vecProcDomHierarquia.at(j).nmDominioFilho;

                nmTabelaDominio = strNmTabelaDominio.c_str();

                listaStatusIdTabelaDominio[itListaIdCampos] = 0;

                // if ( false == proCBuscarIdTabelaDominio(&listaIdTabelaDominio[itListaIdCampos],
                //                                                                     nmTabelaDominio) )
                // {
                //     EXEC SQL
                //         SELECT
                //             CONTATOADM.TABELADOMINIOSQ.NEXTVAL
                //         INTO
                //             :listaIdTabelaDominio[itListaIdCampos]
                //         FROM
                //             DUAL;
                // 
                //     ULOG( "Vai inserir IDTABELADOMINIO=%d para NMTABELADOMINIO=[%s]"
                //                 ,listaIdTabelaDominio[itListaIdCampos],nmTabelaDominio);
                //     EXEC SQL
                //         INSERT INTO
                //             CONTATOADM.TABELADOMINIO(IDTABELADOMINIO
                //                                     ,NMTABELADOMINIO
                //                                     ,IDUSUARIOALTERACAO
                //                                     ,DTULTIMAALTERACAO)
                //         VALUES (:listaIdTabelaDominio[itListaIdCampos]:listaStatusIdTabelaDominio[itListaIdCampos]
                //                ,:nmTabelaDominio
                //                ,:idUsuario
                //                ,SYSDATE);
                // 
                //     // nmDominio = vecProcDomHierarquia.at(j).nmDominioFilho.c_str();
                // 
                //     // ULOG( "Vai atualizar IDTABELADOMINIO para %d em CONTATOADM.DOMINIO "
                //     //                                             "para NMDOMINIO=[%s]",nmDominio);
                //     // EXEC SQL
                //     //     UPDATE
                //     //         CONTATOADM.DOMINIO
                //     //     SET
                //     //         IDTABELADOMINIO = :listaIdTabelaDominio[itListaIdCampos]
                //     //     WHERE
                //     //         NMDOMINIO = :nmDominio;
                // }

                itListaIdCampos++;
            }

            // cria lista contendo valores únicos de idSubFormulario
            itmapListaIdSubFormulario = mapListaIdSubFormulario.find(listaIdSubFormulario[i]);

            if ( itmapListaIdSubFormulario == mapListaIdSubFormulario.end() )
            { // se não encontrou insere na lista unica
                mapListaIdSubFormulario[listaIdSubFormulario[i]] = listaIdSubFormulario[i];
                listaUnicaIdSubFormulario[itListaIdSubFormulario] = listaIdSubFormulario[i];
                listaStatusUnicaIdSubFormulario[itListaIdSubFormulario] = 0;

                itListaIdSubFormulario++;
            }

            j++;
        }

        // if ( -1 != listaStatusUnicaIdCampo[0] )
        // {
        //     ULOG( "Vai deletar em CONTATOADM.CAMPODOMINIO");
        // 
        //     EXEC SQL
        //         DELETE
        //             CONTATOADM.CAMPODOMINIO
        //         WHERE
        //             IDCAMPO IN (:listaUnicaIdCampo:listaStatusUnicaIdCampo);
        //         //AND IDTABELADOMINIO IN (:listaIdTabelaDominio:listaStatusIdTabelaDominio);
        // 
        //     ULOG( "Vai inserir em CONTATOADM.CAMPODOMINIO");
        // 
        //     EXEC SQL WHENEVER SQLERROR CONTINUE;
        // 
        //     EXEC SQL
        //         INSERT INTO
        //             CONTATOADM.CAMPODOMINIO(IDCAMPO
        //                                    ,IDTABELADOMINIO
        //                                    ,IDUSUARIOALTERACAO
        //                                    ,DTULTIMAALTERACAO)
        //         VALUES
        //             (:listaUnicaIdCampo INDICATOR :listaStatusUnicaIdCampo
        //             ,:listaIdTabelaDominio INDICATOR :listaStatusIdTabelaDominio
        //             ,:listaUnicaIdUsuario INDICATOR :listaUnicaUnicaIdUsuario
        //             ,SYSDATE);
        // 
        //     if ( sqlca.sqlcode && -1400 != sqlca.sqlcode)
        //     {
        //         SqlErrorCampos(&sqlca);
        //     }
        // 
        //     EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);
        // }
        // else
        // {
        //     ULOG( "Não existem campos unicos para inserção");
        // }

        // Antes de gerar a árvore, limpa completamente a árvore anterior do grupo, se existir.
        if ( -1 != listaStatusUnicaIdSubFormulario[0] )
        {
            EXEC SQL
                DELETE
                    CONTATOADM.DOMINIOHIERARQUIA
                WHERE
                    IDSUBFORMULARIO IN (:listaUnicaIdSubFormulario:listaStatusUnicaIdSubFormulario);
        }

        // Gera a nova árvore
        if ( -1 != listaStatusIdSubFormulario[0] )
        {
            ULOG( "Vai inserir em CONTATOADM.DOMINIOHIERARQUIA");

            EXEC SQL WHENEVER SQLERROR CONTINUE;

            EXEC SQL
                INSERT INTO CONTATOADM.DOMINIOHIERARQUIA(IDSUBFORMULARIO
                                                        ,IDCAMPO
                                                        ,IDDOMINIOPAI
                                                        ,IDDOMINIOFILHO
                                                        ,NMPATH)
                VALUES (:listaIdSubFormulario INDICATOR :listaStatusIdSubFormulario
                       ,:listaIdCampo INDICATOR :listaStatusIdCampo
                       ,:listaIdDominioPai INDICATOR :listaStatusIdDominioPai
                       ,:listaIdDominioFilho INDICATOR :listaStatusIdDominioFilho
                       ,:listaNmPath INDICATOR :listaStatusNmPath);

            if ( sqlca.sqlcode && -1400 != sqlca.sqlcode)
            {
                SqlErrorCampos(&sqlca);
            }
        }
        else
        {
            ULOG( "Bloco de hierarquia estava vazio");
        }

    } while ( j < sizeVecProcDomHierarquia );

    if ( sizeVecProcDomHierarquia > 0 )
    {
        // Apesar de idSubFormulario vir em um <list> o valor é sempre o mesmo
        idSubFormulario = vecProcDomHierarquia.at(0).idSubFormulario;

        ULOG( "Vai inserir NMLOGINUSUARIO=%s,IDSUBFORMULARIO=%d em CONTATOADM.DOMINIOHIERARQUIALOG",
             nmLoginUsuario.arr,idSubFormulario);

        EXEC SQL
            INSERT INTO CONTATOADM.DOMINIOHIERARQUIALOG
                (IDDOMINIOHIERARQUIALOG
                ,NMLOGINUSUARIO
                ,IDSUBFORMULARIO
                ,DTULTIMAALTERACAO)
            VALUES (CONTATOADM.DOMINIOHIERARQUIALOGSQ.NEXTVAL
                   ,:nmLoginUsuario
                   ,:idSubFormulario
                   ,SYSDATE);

        if ( sqlca.sqlcode && -1400 != sqlca.sqlcode)
        {
            SqlErrorCampos(&sqlca);
        }
    }

    ULOG_END( "proCGravaRelacionamentoCpoDepend()" );
}

// =========================================================================
void proCAtualizarCampos()
{
    ULOG_START( "proCAtualizarCampos()" );

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);
    EXEC SQL CALL contatoadm.AtualizaCamposDependentes();

    ULOG_END( "proCAtualizarCampos()" );
}

// =========================================================================
// Implementação para Lupa de Campo Dependente.
// Carrega dominios e idCampo, caso nmCampo seja encontrado na base.
//
void proCLupaCarregaCampoDependente(int idSubFormularioPrm,char *nmCampoPrm,XMLGen *saida)
{
    ULOG_START( "proCLupaCarregaCampoDependente()" );

    struct sqlca sqlca;
    int inSubFormularios;   // Indicador de habilitação/desabilitação do botão de excluir valores
                            // 0 - Não há relacionamento em mais de um idSubFormulario
                            // 1 - Há relacionamento com mais de um idSubFormulario

    EXEC SQL BEGIN DECLARE SECTION;
       int idCampo;
       short i_idCampo = -1;
       VARCHAR nmCampo[2001];
       short i_nmCampo = -1;
       VARCHAR nmCampoPsq[256];
    EXEC SQL END DECLARE SECTION;

    strToOra(nmCampoPsq,nmCampoPrm);
    ULOG( "Pesquisando nmCampo [%s]",(char*)nmCampoPsq.arr);

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);
    EXEC SQL
        SELECT DISTINCT
            CAMPO.IDCAMPO ,
            CAMPO.NMCAMPO
        INTO
            :idCampo:i_idCampo ,
            :nmCampo:i_nmCampo
        FROM
            CONTATOADM.SUBFORMULARIOCAMPO SUBFORMULARIOCAMPO ,
            CONTATOADM.SUBFORMULARIO SUBFORMULARIO ,
            CONTATOADM.CAMPO CAMPO
        WHERE
            SUBFORMULARIO.IDSUBFORMULARIO = SUBFORMULARIOCAMPO.IDSUBFORMULARIO
        AND CAMPO.IDCAMPO = SUBFORMULARIOCAMPO.IDCAMPO
        AND SUBFORMULARIO.IDTIPOSUBFORMULARIO = 2
        AND UPPER(TRIM(CAMPO.NMCAMPO)) = UPPER(TRIM(:nmCampoPsq));

    if (-1 == i_nmCampo)
    {
        ULOGW("proCLupaCarregaCampoDependente()");

        saida->createTag( "AdmGrupoCamposDependentesVO" );
        saida->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
            saida->addItem("inSubFormularios", 0 );   // Obrigatorio para o Java
            saida->addItem("msg", "Não foram encontrados campos com esta descrição." );
        saida->closeTag();
        return;
    }

    CONVIND(nmCampo,i_nmCampo);

    saida->createTag( "AdmGrupoCamposDependentesVO" );
    saida->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
        saida->addItem("idCampoDependente", idCampo );
        saida->addItem("nmCampoDependente", (char *)nmCampo.arr );
        inSubFormularios = proCRelacaoCampoSubFormulario(idCampo,idSubFormularioPrm);
        saida->addItem("inSubFormularios", inSubFormularios );  //  1 - Inibe o botao excluir valor
        procCObterNmDominioPorIdCampo( idCampo,saida );
    saida->closeTag();

    ULOG_END( "proCLupaCarregaCampoDependente()" );
}

// =========================================================================
// Implementação para Lupa de Campo Dependente.
// Identifica relacionamentos entre campo e subformularios.
// Retorno: 0 - Não está relacionado com outros idSubFormularios
//          1 - Tem relação com outros idSubFormularios
//
int proCRelacaoCampoSubFormulario(int idCampoPrm,int idSubFormularioPrm)
{
    ULOG_START( "proCRelacaoCampoSubFormulario()" );
    struct sqlca sqlca;
    int inSubFormularios;

    EXEC SQL BEGIN DECLARE SECTION;
       int     idCampo = idCampoPrm;
       int     idSubFormulario = idSubFormularioPrm;
       int     ctSubFormularios;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);

    ULOG( "Pesquisando grupos diferentes de [%d]",idSubFormulario );

    EXEC SQL
        SELECT
            COUNT(IDCAMPO)
        INTO
            :ctSubFormularios
        FROM
            CONTATOADM.SUBFORMULARIOCAMPO 
        WHERE
            IDCAMPO = :idCampo 
        AND IDSUBFORMULARIO <> :idSubFormulario;

    inSubFormularios = (ctSubFormularios > 0) ? 1 : 0;

    ULOG( "Existem [%d] grupos diferentes de [%d]",ctSubFormularios,idSubFormulario );

    ULOG_END( "proCRelacaoCampoSubFormulario()" );

    return inSubFormularios;
}

// =========================================================================
bool proCExisteCampoDominio(int idCampoPrm)
{
    ULOG_START( "proCExisteCampoDominio()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
       int idCampo = idCampoPrm;
       int ctCampos;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);

    EXEC SQL
        SELECT
            COUNT(1)
        INTO
            :ctCampos
        FROM 
            CONTATOADM.CAMPODOMINIO
        WHERE 
            IDCAMPO = :idCampo;

    bool inExisteCampoDominio = (ctCampos > 0) ? true : false;

    ULOG( "inExisteCampoDominio=%d",inExisteCampoDominio );

    ULOG_END( "proCExisteCampoDominio()" );

    return inExisteCampoDominio;
}

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// ***********************************************************************************************
// *                                                                                             *
// * **** FUNÇÕES DE SUPORTE ÀS FUNÇOES PRO-C DO MÓDULO - ESTAS FUNÇÕES NÃO ACESSAM O BANCO **** *
// *                                                                                             *
// ***********************************************************************************************
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//================================================================================================
// Função de suporte ao método proCListaArvore()
// A tabela CONTATOADM.DOMINIOHIERARQUIA foi desenhada para aceitar árvores com multiplas raizes
// esta função faz a montagem recurvisa da familia de um dado pai.
// Julho, 2007 -- Cassio.
bool montarFamilia(int idDominioPai,unsigned char *nmPath,int vecOraArvoreDominioIt,VEC_ORAARVOREDOMINIO &vecOraArvoreDominio,XMLGen *saida)
{
    static bool primeiraVez = true;

    while ( vecOraArvoreDominioIt < vecOraArvoreDominio.size() )
    {
        if ( 0 == vecOraArvoreDominio.at(vecOraArvoreDominioIt).inProcessado
            && ((idDominioPai == vecOraArvoreDominio.at(vecOraArvoreDominioIt).idDominioPai
            &&  0==memcmp((const char*)nmPath,(const char*)vecOraArvoreDominio.at(vecOraArvoreDominioIt).nmPath.arr,strlen((char*)nmPath)))
               || primeiraVez) )
        {
            primeiraVez = false;

            saida->createTag( "TreeItemVO" );
            saida->addItem("idPai", vecOraArvoreDominio.at(vecOraArvoreDominioIt).idDominioPai );
            saida->addItem("id", vecOraArvoreDominio.at(vecOraArvoreDominioIt).idDominioFilho );
            saida->addItem("descricaoPai", (char *)vecOraArvoreDominio.at(vecOraArvoreDominioIt).nmDominioPai.arr );
            saida->addItem("descricao", (char *)vecOraArvoreDominio.at(vecOraArvoreDominioIt).nmDominioFilho.arr );
            saida->addItem("nivel", vecOraArvoreDominio.at(vecOraArvoreDominioIt).idNivelCampoValor );
            saida->addItem("idCampo", vecOraArvoreDominio.at(vecOraArvoreDominioIt).idCampo );

            vecOraArvoreDominio.at(vecOraArvoreDominioIt).inProcessado = 1;

            montarFamilia(vecOraArvoreDominio.at(vecOraArvoreDominioIt).idDominioFilho
                         ,vecOraArvoreDominio.at(vecOraArvoreDominioIt).nmPath.arr
                         ,(vecOraArvoreDominioIt+1),vecOraArvoreDominio,saida);

            saida->closeTag();

       }

        vecOraArvoreDominioIt++;
    }

    return true;
}



bool proCExisteHierarquia( int idDominioPrm )
{
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
       int idDominio = idDominioPrm;
       int ctDominios;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO SqlErrorCampos(&sqlca);

    ULOG( "Verificando relacionamento de idDominio [%d]",idDominio );

    EXEC SQL
        SELECT
           COUNT(1)
        INTO
           :ctDominios
        FROM
           CONTATOADM.DOMINIOHIERARQUIA
        WHERE
           IDDOMINIOPAI = :idDominio
        OR 
           IDDOMINIOFILHO = :idDominio;

    bool inExisteDominio = (ctDominios > 0) ? true : false;

    ULOG( "inExisteDominio=%d",inExisteDominio );

    return inExisteDominio;
}



// =========================================================================
void SqlErrorCampos( sqlca * sqlca )
{
    ULOGE("sql_error:sqlcode=%d,sqlerrmc=%.256s"
                            ,sqlca->sqlcode
                            ,sqlca->sqlerrm.sqlerrmc);

    throw new TuxBasicOraException(sqlca->sqlcode
                                  ,sqlca->sqlerrm.sqlerrmc
                                  ,sqlca->sqlerrm.sqlerrml);
}
