#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CTipPes.h"

CTipoPessoa::CTipoPessoa()
{
}

CTipoPessoa::~CTipoPessoa()
{
}

int CTipoPessoa::ListId( char* cid )
{
    ULOG_START("CTipoPessoa::ListId()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidOra = cid;
		struct
		{
			VARCHAR cidTipoPessoa[21+1];
			VARCHAR csgTipoPessoa[255+1];
			VARCHAR cdsTipoPessoa[255+1];
		} stTipoPessoaRegistro;
		struct
		{
			short iId;
			short iSigla;
			short iDescricao;
		} stTipoPessoaIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraTipoPessoa();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;
	
	   	EXEC SQL DECLARE CursorTipoPessoaId CURSOR FOR
			SELECT IDTIPOPESSOA, 
			       SGTIPOPESSOA,
			       DSTIPOPESSOA
			  FROM APOIO.TIPOPESSOA
			 WHERE IDSTATUSUSUARIO = :cidOra;
	
		EXEC SQL OPEN CursorTipoPessoaId;
	
		if(sqlca.sqlcode)
		{
		    ULOG_END("CTipoPessoa::ListId()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stTipoPessoaRegistro, 0, sizeof(stTipoPessoaRegistro) );
				EXEC SQL FETCH CursorTipoPessoaId INTO :stTipoPessoaRegistro:stTipoPessoaIndicator;
	
				Add( (char*)stTipoPessoaRegistro.cidTipoPessoa.arr
				    ,(char*)stTipoPessoaRegistro.csgTipoPessoa.arr
				    ,(char*)stTipoPessoaRegistro.cdsTipoPessoa.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorTipoPessoaId;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CTipoPessoa::ListId()");
	return iCont;

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CTipoPessoa::ListAll( void )
{
    ULOG_START("CTipoPessoa::ListAll()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR cidTipoPessoa[21+1];
			VARCHAR csgTipoPessoa[255+1];
			VARCHAR cdsTipoPessoa[255+1];
		} stTipoPessoaRegistro;
		struct
		{
			short iId;
			short iSigla;
			short iDescricao;
		} stTipoPessoaIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{
		ZeraTipoPessoa();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;
	
	   	EXEC SQL DECLARE CursorTipoPessoaAll CURSOR FOR
			SELECT IDTIPOPESSOA, 
			       SGTIPOPESSOA, 
			       DSTIPOPESSOA
			  FROM APOIO.TIPOPESSOA
			 WHERE IDTIPOPESSOA > 0
		  ORDER BY DSTIPOPESSOA;
	
		EXEC SQL OPEN CursorTipoPessoaAll;
	
		if(sqlca.sqlcode)
		{
		    ULOG_END("CTipoPessoa::ListAll()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stTipoPessoaRegistro, 0, sizeof(stTipoPessoaRegistro) );
				EXEC SQL FETCH CursorTipoPessoaAll INTO :stTipoPessoaRegistro:stTipoPessoaIndicator;
	
				Add( (char*)stTipoPessoaRegistro.cidTipoPessoa.arr
				    ,(char*)stTipoPessoaRegistro.csgTipoPessoa.arr
				    ,(char*)stTipoPessoaRegistro.cdsTipoPessoa.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorTipoPessoaAll;
		}
	}
	catch(...)
	{
		throw;
	}

    ULOG("return iCont = [%d] ",iCont);
	ULOG_END("CTipoPessoa::ListAll()");
	
	return iCont;

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CTipoPessoa::ListSigla( char* csgTipoPessoa )
{
    ULOG_START("CTipoPessoa::ListSigla()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxsgTipoPessoa = csgTipoPessoa;
		struct
		{
			VARCHAR cidTipoPessoa[21+1];
			VARCHAR csgTipoPessoa[255+1];
			VARCHAR cdsTipoPessoa[255+1];
		} stTipoPessoaRegistro;
		struct
		{
			short iId;
			short iSigla;
			short iDescricao;
		} stTipoPessoaIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{
		ZeraTipoPessoa();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListSigla;
		sqlca.sqlcode=0;
	
	   	EXEC SQL DECLARE CursorListSigla CURSOR FOR
			SELECT TIPOPESSOA.IDTIPOPESSOA
			      ,TIPOPESSOA.SGTIPOPESSOA 
			      ,TIPOPESSOA.DSTIPOPESSOA 
			  FROM APOIO.TIPOPESSOA TIPOPESSOA
			 WHERE TIPOPESSOA.SGTIPOPESSOA = :cAuxsgTipoPessoa;
	
		EXEC SQL OPEN CursorListSigla;
	
		if(sqlca.sqlcode)
			return 0;
		else
		{
			for(;;)
			{
				memset( &stTipoPessoaRegistro, 0, sizeof(stTipoPessoaRegistro) );
				EXEC SQL FETCH CursorListSigla INTO :stTipoPessoaRegistro:stTipoPessoaIndicator;
	
				Add( (char*)stTipoPessoaRegistro.cidTipoPessoa.arr
				    ,(char*)stTipoPessoaRegistro.csgTipoPessoa.arr
				    ,(char*)stTipoPessoaRegistro.cdsTipoPessoa.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorListSigla;
		}
	}
	catch(...)
	{
		throw;
	}
	
	ULOG_END("CTipoPessoa::ListSigla()");
	return iCont;

GotoListSigla:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CTipoPessoa::GetXml( char* cNomeTag, XMLGen*xml )
{
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			if( Registro( x ) != NULL )
			{
				xml->addItem("idTipoPessoa", Registro(x)->cidTipoPessoa );
				xml->addItem("sgTipoPessoa", Registro(x)->csgTipoPessoa );
				xml->addItem("dsTipoPessoa", Registro(x)->cdsTipoPessoa );
			}
			xml->closeTag();
		}
	}
}

void CTipoPessoa::GetXmlNatureza( char* cNomeTag, XMLGen*xml )
{
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			if( Registro( x ) != NULL )
			{
				xml->addItem("idNatureza", Registro(x)->cidTipoPessoa );
				xml->addItem("sgNatureza", Registro(x)->csgTipoPessoa );
				xml->addItem("dsNatureza", Registro(x)->cdsTipoPessoa );
			}
			xml->closeTag();
		}
	}
}
