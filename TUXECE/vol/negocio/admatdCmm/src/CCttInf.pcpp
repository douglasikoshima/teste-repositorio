#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include<tuxfw.h>
#include "../include/CCttInf.h"

CContatoInformacao::CContatoInformacao()
{
}

CContatoInformacao::~CContatoInformacao()
{
}

int CContatoInformacao::Insert( char* cidContato,
								char* cidUFOperadora,
								char* cidTipoLinha,
								char* cidTipoCliente,
								char* cnmURLContatoInformacao,
								char* cidUsuarioAlteracao )
{
    ULOG_START("CContatoInformacao::Insert()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		char* cAuxidUFOperadora = cidUFOperadora;
		char* cAuxidTipoLinha = cidTipoLinha;
		char* cAuxidTipoCliente = cidTipoCliente;
		char* cAuxnmURLContatoInformacao = cnmURLContatoInformacao;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
		VARCHAR stidContatoInformacao[21+1];
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Este metodo nao zera a classe
		//ZeraContatoInformacao();
		
		memset( &stidContatoInformacao, 0, sizeof( stidContatoInformacao ) );
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
		sqlca.sqlcode=0;
		
		EXEC SQL
			SELECT
				CONTATOADM.CONTATOINFORMACAOSQ.NEXTVAL
			INTO :stidContatoInformacao
			FROM
				DUAL;
		
		//Realiza o insert
		EXEC SQL INSERT INTO CONTATOADM.ContatoInformacao
		(	idContatoInformacao,
			idContato,
			idUFOperadora,
			idTipoLinha,
			idTipoRelacionamento,
			nmURLContatoInformacao,
			idUsuarioAlteracao,
			dtUltimaAlteracao) 
		VALUES 
		(	:stidContatoInformacao,
			:cAuxidContato,
			:cAuxidUFOperadora,
			:cAuxidTipoLinha,
			:cAuxidTipoCliente,
			:cAuxnmURLContatoInformacao,
			:cAuxidUsuarioAlteracao,
			SYSDATE);

		//Adiciona a classe
		Add( (char*)stidContatoInformacao.arr
			,(char*)cAuxidContato
			,(char*)cAuxidUFOperadora
			,""
			,cAuxidTipoLinha
			,""
			,cAuxidTipoCliente
			,""
			,cAuxnmURLContatoInformacao );


        ULOG_END("CContatoInformacao::Insert()");
        
		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode) {
			return 0;//Erro
		}
		else {
			return 1;//Sucesso
		}
	}
	catch(...)
	{
		throw;
	}
	
GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CContatoInformacao::Update( char* cidContatoInformacao,
								char* cidContato,
								char* cidUFOperadora,
								char* cidTipoLinha,
								char* cidTipoCliente,
								char* cnmURLContatoInformacao,
								char* cidUsuarioAlteracao )
{
    ULOG_START("CContatoInformacao::Update()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
			char* cAuxidContatoInformacao = cidContatoInformacao;
			char* cAuxidContato = cidContato;
			char* cAuxidUFOperadora = cidUFOperadora;
			char* cAuxidTipoLinha = cidTipoLinha;
			char* cAuxidTipoCliente = cidTipoCliente;
			char* cAuxnmURLContatoInformacao = cnmURLContatoInformacao;
			char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		//ZeraContatoInformacao();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
		sqlca.sqlcode=0;
		
		//Executa a instrucao de update
		EXEC SQL 
			UPDATE 
				CONTATOADM.CONTATOINFORMACAO
			SET 
				NMURLCONTATOINFORMACAO = :cAuxnmURLContatoInformacao,
				IDUSUARIOALTERACAO = :cAuxidUsuarioAlteracao,
				DTULTIMAALTERACAO = SYSDATE
			WHERE
				IDCONTATOINFORMACAO = :cAuxidContatoInformacao;
				
			//	idContato = :cAuxidContato
			//AND
			//	idUFOperadora = :cAuxidUFOperadora
			//AND
			//	idTipoLinha = :cAuxidTipoLinha
			//AND
			//	idTipoRelacionamento = :cAuxidTipoCliente;
		
		Add( cAuxidContatoInformacao
			,cAuxidContato
			,cAuxidUFOperadora
			,""
			,cAuxidTipoLinha
			,""
			,cAuxidTipoCliente
			,""
			,cAuxnmURLContatoInformacao );		
			
		ULOG_END("CContatoInformacao::Update()");
		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
			return sqlca.sqlerrd[2];//Quantidade de linhas afetadas
	}
	catch(...)
	{
		throw;
	}

GotoUpdate:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CContatoInformacao::Delete( char* cidContatoInformacao )
{
    ULOG_START("CContatoInformacao::Delete()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;	
		char* cAuxidContatoInformacao = cidContatoInformacao;
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Nao zera a classe
		//ZeraContatoInformacao();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
		sqlca.sqlcode=0;
		
		//Executa a instrucao de delecao
		EXEC SQL 
			DELETE FROM 
				CONTATOADM.CONTATOINFORMACAO
			WHERE 
				IDCONTATOINFORMACAO = :cAuxidContatoInformacao;
		
		ULOG_END("CContatoInformacao::Delete()");
		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
			return 1;//Sucesso
	}
	catch(...)
	{
		throw;
	}

GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoInformacao::DeletePorContato( char* cidContato )
{
    ULOG_START("CContatoInformacao::DeletePorContato()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;	
		char* cAuxidContato = cidContato; 
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoInformacao();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDeletePorContato;
		sqlca.sqlcode=0;
		
		//Executa a instrucao de delecao
		EXEC SQL 
			DELETE FROM 
				CONTATOADM.CONTATOINFORMACAO
			WHERE 
				IDCONTATO = :cAuxidContato;
		
		ULOG_END("CContatoInformacao::DeletePorContato()");
		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
			return sqlca.sqlerrd[2];//Quantidade de linhas afetadas
	}
	catch(...)
	{
		throw;
	}

GotoDeletePorContato:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoInformacao::ListId( char* cidContato ) 
{
    ULOG_START("CContatoInformacao::ListId()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
		struct
		{
			VARCHAR stidContatoInformacao[21+1];
			VARCHAR stidContato[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stdsUFOperadora[255+1];
			VARCHAR stidTipoLinha[21+1];
			VARCHAR stdsTipoLinha[255+1];
			VARCHAR stidTipoCliente[21+1];
			VARCHAR stdsTipoCliente[255+1];
			VARCHAR stnmURLContatoInformacao[255+1];
		} stContatoInformacaoRegistro;
		struct
		{
			short iidContatoInformacao;
			short iidContato;
			short iidUFOperadora;
			short idsUFOperadora;
			short iidTipoLinha;
			short idsTipoLinha;
			short iidTipoCliente;
			short idsTipoCliente;
			short inmURLContatoInformacao;
		} stContatoInformacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoInformacao();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorContatoInformacaoId CURSOR FOR 
   			SELECT 	
   				CONTATOINFORMACAO.IDCONTATOINFORMACAO
			   ,CONTATOINFORMACAO.IDCONTATO
			   ,CONTATOINFORMACAO.IDUFOPERADORA
			   ,CONTATOINFORMACAO.SGUF || ' - ' || CONTATOINFORMACAO.NMPESSOA
			   ,CONTATOINFORMACAO.IDTIPOLINHA
			   ,CONTATOINFORMACAO.DSTIPOLINHA
			   ,CONTATOINFORMACAO.IDTIPORELACIONAMENTO
			   ,CONTATOINFORMACAO.NMTIPORELACIONAMENTO
			   ,CONTATOINFORMACAO.NMURLCONTATOINFORMACAO
			FROM 
				CONTATOADM.CONTATOINFORMACAOV01 CONTATOINFORMACAO
			WHERE 
				CONTATOINFORMACAO.IDCONTATO = :cAuxidContato
			ORDER BY
				SGUF, NMPESSOA;

		//Abre o cursor
		EXEC SQL OPEN CursorContatoInformacaoId;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		   ULOG_END("CContatoInformacao::ListId()");
		   return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stContatoInformacaoRegistro, 0, sizeof(stContatoInformacaoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorContatoInformacaoId INTO :stContatoInformacaoRegistro:stContatoInformacaoIndicator;
				//Adiciona a classe
				Add( (char*)stContatoInformacaoRegistro.stidContatoInformacao.arr
					,(char*)stContatoInformacaoRegistro.stidContato.arr
					,(char*)stContatoInformacaoRegistro.stidUFOperadora.arr
					,(char*)stContatoInformacaoRegistro.stdsUFOperadora.arr
					,(char*)stContatoInformacaoRegistro.stidTipoLinha.arr
					,(char*)stContatoInformacaoRegistro.stdsTipoLinha.arr
					,(char*)stContatoInformacaoRegistro.stidTipoCliente.arr
					,(char*)stContatoInformacaoRegistro.stdsTipoCliente.arr
					,(char*)stContatoInformacaoRegistro.stnmURLContatoInformacao.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorContatoInformacaoId;
		}
		ULOG_END("CContatoInformacao::ListId()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContatoInformacao::ListAll( void )
{
    ULOG_START("CContatoInformacao::ListAll()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidContatoInformacao[21+1];
			VARCHAR stidContato[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stdsUFOperadora[255+1];
			VARCHAR stidTipoLinha[21+1];
			VARCHAR stdsTipoLinha[255+1];
			VARCHAR stidTipoCliente[21+1];
			VARCHAR stdsTipoCliente[255+1];
			VARCHAR stnmURLContatoInformacao[255+1];
		} stContatoInformacaoRegistro;
		struct
		{
			short iidContatoInformacao;
			short iidContato;
			short iidUFOperadora;
			short idsUFOperadora;
			short iidTipoLinha;
			short idsTipoLinha;
			short iidTipoCliente;
			short idsTipoCliente;
			short inmURLContatoInformacao;
		} stContatoInformacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoInformacao();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL 
   			DECLARE 
   				CursorContatoInformacaoAll CURSOR FOR
   			SELECT 	
   				CONTATOINFORMACAO.IDCONTATOINFORMACAO
			   ,CONTATOINFORMACAO.IDCONTATO
			   ,CONTATOINFORMACAO.IDUFOPERADORA
			   ,CONTATOINFORMACAO.NMPESSOA
			   ,CONTATOINFORMACAO.IDTIPOLINHA
			   ,CONTATOINFORMACAO.DSTIPOLINHA
			   ,CONTATOINFORMACAO.IDTIPORELACIONAMENTO
			   ,CONTATOINFORMACAO.NMTIPORELACIONAMENTO
			   ,CONTATOINFORMACAO.NMURLCONTATOINFORMACAO
			FROM 
				CONTATOADM.CONTATOINFORMACAOV01 CONTATOINFORMACAO;

		//Abre o cursor
		EXEC SQL OPEN CursorContatoInformacaoAll;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CContatoInformacao::ListAll()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stContatoInformacaoRegistro, 0, sizeof(stContatoInformacaoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorContatoInformacaoAll INTO :stContatoInformacaoRegistro:stContatoInformacaoIndicator;
				//Adiciona a classe
				Add( (char*)stContatoInformacaoRegistro.stidContatoInformacao.arr
					,(char*)stContatoInformacaoRegistro.stidContato.arr
					,(char*)stContatoInformacaoRegistro.stidUFOperadora.arr
					,(char*)stContatoInformacaoRegistro.stdsUFOperadora.arr
					,(char*)stContatoInformacaoRegistro.stidTipoLinha.arr
					,(char*)stContatoInformacaoRegistro.stdsTipoLinha.arr
					,(char*)stContatoInformacaoRegistro.stidTipoCliente.arr
					,(char*)stContatoInformacaoRegistro.stdsTipoCliente.arr
					,(char*)stContatoInformacaoRegistro.stnmURLContatoInformacao.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorContatoInformacaoAll;
		}
		ULOG_END("CContatoInformacao::ListAll()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CContatoInformacao::GetXml( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )			
			{
				xml->createTag(cNomeTag);
				//Adiciona a proprieda necessaria para o Weblogic
				xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idContatoInformacao", Registro(x)->cidContatoInformacao );
				xml->addItem("idContato", Registro(x)->cidContato );
				xml->addItem("idTipoRelacionamento", Registro(x)->cidTipoCliente );
				xml->addItem("nmTipoRelacionamento", Registro(x)->cdsTipoCliente );
				xml->addItem("idUFOperadora", Registro(x)->cidUFOperadora );
				xml->addItem("nmUFOperadora", Registro(x)->cdsUFOperadora );
				xml->addItem("idTipoLinha", Registro(x)->cidTipoLinha );
				xml->addItem("nmTipoLinha", Registro(x)->cdsTipoLinha );
				xml->addItem("nmLink", Registro(x)->cnmURLContatoInformacao ); 
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )			
				xml->closeTag();
		}
	}
}

void CContatoInformacao::GetXmlWorkflow( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )			
			{
				xml->createTag(cNomeTag);
				//Adiciona a proprieda necessaria para o Weblogic
				xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idContatoInformacao", Registro(x)->cidContatoInformacao );
				xml->addItem("idContato", Registro(x)->cidContato );
				xml->addItem("idUFOperadora", Registro(x)->cidUFOperadora );
				xml->addItem("idTipoLinha", Registro(x)->cidTipoLinha );
				xml->addItem("idTipoCliente", Registro(x)->cidTipoCliente );
				xml->addItem("nmTipoRelacionamento", Registro(x)->cdsTipoCliente );
				xml->addItem("nmURLContatoInformacao", Registro(x)->cnmURLContatoInformacao ); 
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )			
				xml->closeTag();
		}
	}
}

void CContatoInformacao::GetXmlUFOperadora( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )			
			{
				xml->createTag(cNomeTag);
				//Adiciona a proprieda necessaria para o Weblogic
				xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idUFOperadora", Registro(x)->cidUFOperadora );
				xml->addItem("nmUFOperadora", Registro(x)->cdsUFOperadora );
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )			
				xml->closeTag();
		}
	}
}

void CContatoInformacao::GetXmlTipoLinha( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )			
			{
				xml->createTag(cNomeTag);
				//Adiciona a proprieda necessaria para o Weblogic
				xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idTipoLinha", Registro(x)->cidTipoLinha );
				xml->addItem("sgTipoLinha", "" );
				xml->addItem("dsTipoLinha", Registro(x)->cdsTipoLinha );
				xml->addItem("vlPeso", "" );
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )			
				xml->closeTag();
		}
	}
}

void CContatoInformacao::GetXmlTipoCliente( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )			
			{
				xml->createTag(cNomeTag);
				//Adiciona a proprieda necessaria para o Weblogic
				xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idTipoCliente", Registro(x)->cidTipoCliente );
				xml->addItem("nmTipoCliente", Registro(x)->cdsTipoCliente );
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )			
				xml->closeTag();
		}
	}
}

int CContatoInformacao::ListUFOperadoraR( char* cidContato )
{
    ULOG_START("CContatoInformacao::ListUFOperadoraR()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		struct
		{
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stdsUFOperadora[255+1];
		} stContatoInformacaoRegistro;
		struct
		{
			short iidUFOperadora;
			short idsUFOperadora;
		} stContatoInformacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoInformacao();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListUFOperadoraR;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL 
   			DECLARE 
   				CursorListUFOperadoraR CURSOR FOR
			SELECT DISTINCT
			     IDUFOPERADORA
			    ,SGUF || ' - ' || NMPESSOA
			FROM 
			     CONTATOADM.CONTATOINFORMACAOV01 INFORMACAO
			WHERE
			     INFORMACAO.IDCONTATO = :cAuxidContato;

		//Abre o cursor
		EXEC SQL OPEN CursorListUFOperadoraR;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		   ULOG_END("CContatoInformacao::ListUFOperadoraR()");
		   return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stContatoInformacaoRegistro, 0, sizeof(stContatoInformacaoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorListUFOperadoraR INTO :stContatoInformacaoRegistro:stContatoInformacaoIndicator;
				//Adiciona a classe
				AddUFOperadora( cidContato
					           ,(char*)stContatoInformacaoRegistro.stidUFOperadora.arr
					           ,(char*)stContatoInformacaoRegistro.stdsUFOperadora.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorListUFOperadoraR;
		}
		ULOG_END("CContatoInformacao::ListUFOperadoraR()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListUFOperadoraR:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContatoInformacao::ListUFOperadoraNR( char* cidContato )
{
    ULOG_START("CContatoInformacao::ListUFOperadoraNR()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		struct
		{
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stdsUFOperadora[355+1];
		} stContatoInformacaoRegistro;
		struct
		{
			short iidUFOperadora;
			short idsUFOperadora;
		} stContatoInformacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoInformacao();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListUFOperadoraNR;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		/*EXEC SQL 
   			DECLARE 
   				CursorListUFOperadoraNR CURSOR FOR
			SELECT
			     IDUFOPERADORA
			    ,SGUF || ' - ' || NMPESSOA
			FROM 
			     CUSTOMER.UFOPERADORABZEROUM UFOPERADORA
			WHERE
				IDUFOPERADORA > 0
			ORDER BY
				SGUF, NMPESSOA;*/
		/*REMOVENDO BZEROUM
		 TCOSTA 18/06/2007 MPOG
		*/

		
		EXEC SQL 
		DECLARE CursorListUFOperadoraNR CURSOR FOR
		SELECT UFOPERADORA.IDUFOPERADORA
			    ,UF.SGUF || ' - ' ||GRUPOOPERADORA.NMGRUPOOPERADORA NMPESSOA
			FROM
			     CUSTOMER.UFOPERADORA UFOPERADORA,
				 CUSTOMER.OPERADORA	 OPERADORA,
				 CUSTOMER.GRUPOOPERADORA GRUPOOPERADORA,
				 APOIO.UF			 UF
		  WHERE	UFOPERADORA.IDUF=UF.IDUF
		  AND	OPERADORA.IDPESSOADEPARAOPERADORA=UFOPERADORA.IDPESSOADEPARAOPERADORA
		  AND   OPERADORA.IDGRUPOOPERADORA=GRUPOOPERADORA.IDGRUPOOPERADORA
			ORDER BY
				SGUF, NMPESSOA;  


				//IDUFOPERADORA NOT IN
				//(
				//	SELECT DISTINCT
				//		IDUFOPERADORA
				//	FROM 
				//		CONTATOADM.CONTATOINFORMACAO INFORMACAO
				//	WHERE
				// 	INFORMACAO.IDCONTATO = :cAuxidContato
				//);

		//Abre o cursor
		EXEC SQL OPEN CursorListUFOperadoraNR;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CContatoInformacao::ListUFOperadoraNR()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stContatoInformacaoRegistro, 0, sizeof(stContatoInformacaoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorListUFOperadoraNR INTO :stContatoInformacaoRegistro:stContatoInformacaoIndicator;
				//Adiciona a classe
				AddUFOperadora( cidContato
					           ,(char*)stContatoInformacaoRegistro.stidUFOperadora.arr
					           ,(char*)stContatoInformacaoRegistro.stdsUFOperadora.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorListUFOperadoraNR;
		}
		ULOG_END("CContatoInformacao::ListUFOperadoraNR()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListUFOperadoraNR:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContatoInformacao::ListTipoLinhaR( char* cidContato )
{
    ULOG_START("CContatoInformacao::ListTipoLinhaR()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		struct
		{
			VARCHAR stidTipoLinha[21+1];
			VARCHAR stdsTipoLinha[255+1];
		} stContatoInformacaoRegistro;
		struct
		{
			short iidTipoLinha;
			short idsTipoLinha;
		} stContatoInformacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoInformacao();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListTipoLinhaR;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL 
   			DECLARE 
   				CursorListTipoLinhaR CURSOR FOR
			SELECT DISTINCT
			    INFORMACAO.IDTIPOLINHA
			   ,INFORMACAO.DSTIPOLINHA
			FROM 
			    CONTATOADM.CONTATOINFORMACAOV01 INFORMACAO
			WHERE
			    INFORMACAO.IDCONTATO = :cAuxidContato;

		//Abre o cursor
		EXEC SQL OPEN CursorListTipoLinhaR;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CContatoInformacao::ListTipoLinhaR()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stContatoInformacaoRegistro, 0, sizeof(stContatoInformacaoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorListTipoLinhaR INTO :stContatoInformacaoRegistro:stContatoInformacaoIndicator;
				//Adiciona a classe
				AddTipoLinha( cidContato
					         ,(char*)stContatoInformacaoRegistro.stidTipoLinha.arr
					         ,(char*)stContatoInformacaoRegistro.stdsTipoLinha.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorListTipoLinhaR;
		}
		ULOG_END("CContatoInformacao::ListTipoLinhaR()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListTipoLinhaR:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContatoInformacao::ListTipoLinhaNR( char* cidContato )
{
    ULOG_START("CContatoInformacao::ListTipoLinhaNR()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		struct
		{
			VARCHAR stidTipoLinha[21+1];
			VARCHAR stdsTipoLinha[255+1];
		} stContatoInformacaoRegistro;
		struct
		{
			short iidTipoLinha;
			short idsTipoLinha;
		} stContatoInformacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoInformacao();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListTipoLinhaNR;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL 
   			DECLARE 
   				CursorListTipoLinhaNR CURSOR FOR
			SELECT
				IDTIPOLINHA
			   ,DSTIPOLINHA
			FROM 
				APOIO.TIPOLINHA
			WHERE
				IDTIPOLINHA > 0
			ORDER BY
				DSTIPOLINHA;
				//IDTIPOLINHA NOT IN
				//(
				//	SELECT DISTINCT
				//		IDTIPOLINHA
				//	FROM 
				//		CONTATOADM.CONTATOINFORMACAO INFORMACAO
				//	WHERE
				//		INFORMACAO.IDCONTATO = :cAuxidContato
				//);

		//Abre o cursor
		EXEC SQL OPEN CursorListTipoLinhaNR;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		   ULOG_END("CContatoInformacao::ListTipoLinhaNR()");
		   return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stContatoInformacaoRegistro, 0, sizeof(stContatoInformacaoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorListTipoLinhaNR INTO :stContatoInformacaoRegistro:stContatoInformacaoIndicator;
				//Adiciona a classe
				AddTipoLinha( cidContato
					         ,(char*)stContatoInformacaoRegistro.stidTipoLinha.arr
					         ,(char*)stContatoInformacaoRegistro.stdsTipoLinha.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorListTipoLinhaNR;
		}
		ULOG_END("CContatoInformacao::ListTipoLinhaNR()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListTipoLinhaNR:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContatoInformacao::ListTipoClienteR( char* cidContato )
{
    ULOG_START("CContatoInformacao::ListTipoClienteR()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		struct
		{
			VARCHAR stidTipoCliente[21+1];
			VARCHAR stdsTipoCliente[255+1];
		} stContatoInformacaoRegistro;
		struct
		{
			short iidTipoCliente;
			short idsTipoCliente;
		} stContatoInformacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoInformacao();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListTipoClienteR;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL
   			DECLARE
   				CursorListTipoClienteR CURSOR FOR
			SELECT DISTINCT
				TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
			   ,TIPORELACIONAMENTO.NMTIPORELACIONAMENTO
			FROM
			    CONTATOADM.CONTATOINFORMACAO CONTATOINFORMACAO
         	   ,CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTO
			WHERE
			    TIPORELACIONAMENTO.SGTIPORELACIONAMENTO IN( 'NC', 'P', 'C', 'U' )
      		AND 
          		TIPORELACIONAMENTO.IDTIPORELACIONAMENTO = CONTATOINFORMACAO.IDTIPORELACIONAMENTO
          	AND
          		CONTATOINFORMACAO.IDCONTATO = :cAuxidContato;


		//Abre o cursor
		EXEC SQL OPEN CursorListTipoClienteR;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		   ULOG_END("CContatoInformacao::ListTipoClienteR()");
		   return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stContatoInformacaoRegistro, 0, sizeof(stContatoInformacaoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorListTipoClienteR INTO :stContatoInformacaoRegistro:stContatoInformacaoIndicator;
				//Adiciona a classe
				AddTipoCliente( cidContato
					           ,(char*)stContatoInformacaoRegistro.stidTipoCliente.arr
					           ,(char*)stContatoInformacaoRegistro.stdsTipoCliente.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorListTipoClienteR;
		}
		ULOG_END("CContatoInformacao::ListTipoClienteR()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListTipoClienteR:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContatoInformacao::ListTipoClienteNR( char* cidContato )
{
    ULOG_START("CContatoInformacao::ListTipoClienteNR()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		struct
		{
			VARCHAR stidTipoCliente[21+1];
			VARCHAR stdsTipoCliente[255+1];
		} stContatoInformacaoRegistro;
		struct
		{
			short iidTipoCliente;
			short idsTipoCliente;
		} stContatoInformacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoInformacao();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListTipoClienteNR;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL 
   			DECLARE 
   				CursorListTipoClienteNR CURSOR FOR
			SELECT
				TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
			   ,TIPORELACIONAMENTO.NMTIPORELACIONAMENTO
			FROM
			    CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTO
			WHERE
			    TIPORELACIONAMENTO.SGTIPORELACIONAMENTO IN( 'NC', 'P', 'C', 'U' )
			AND
				TIPORELACIONAMENTO.IDTIPORELACIONAMENTO > 0
			ORDER BY
				TIPORELACIONAMENTO.NMTIPORELACIONAMENTO;
			   	//TIPORELACIONAMENTO.IDTIPORELACIONAMENTO NOT IN
			   	//(SELECT
			    //  	CONTATOINFORMACAO.IDTIPORELACIONAMENTO
			    // FROM
			    //     CONTATOADM.CONTATOINFORMACAO CONTATOINFORMACAO
			    // WHERE
			    //     CONTATOINFORMACAO.IDCONTATO = :cAuxidContato
			    //);

		//Abre o cursor
		EXEC SQL OPEN CursorListTipoClienteNR;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		   ULOG_END("CContatoInformacao::ListTipoClienteNR()");
		   return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stContatoInformacaoRegistro, 0, sizeof(stContatoInformacaoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorListTipoClienteNR INTO :stContatoInformacaoRegistro:stContatoInformacaoIndicator;
				//Adiciona a classe
				AddTipoCliente( cidContato
					           ,(char*)stContatoInformacaoRegistro.stidTipoCliente.arr
					           ,(char*)stContatoInformacaoRegistro.stdsTipoCliente.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorListTipoClienteNR;
		}
		ULOG_END("CContatoInformacao::ListTipoClienteNR()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListTipoClienteNR:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContatoInformacao::FindPar( char* cidUFOperadora
								,char* cidTipoLinha
								,char* cidTipoCliente )
{
    
	int iRet = -1;
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			if( ( strcmp( cidUFOperadora, Registro(x)->cidUFOperadora ) == 0 )
			  &&( strcmp( cidTipoLinha, Registro(x)->cidTipoLinha ) == 0 )
			  &&( strcmp( cidTipoCliente, Registro(x)->cidTipoCliente ) == 0 ) )
			{
				iRet = x;
				break;
			}
		}
	}
	
	return iRet;
}
												  
int CContatoInformacao::Relacao(char* cidContato,XMLGen*xml_g)
{
    ULOG_START("CContatoInformacao::Relacao()");
	int iRet = 0;
	if( strlennull( cidContato ) > 0 )
	{
		xml_g->createTag("AdmListaLinkVO");
		xml_g->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );


			xml_g->createTag("listaAssociada");
			if( ListId( cidContato ) > 0 )
				GetXml( "AdmObjetoLinkVO", xml_g );
			xml_g->closeTag();//listaAssociada

			xml_g->createTag("selecionados");
				//if( ListTipoLinhaR( cidContato ) > 0 )
				//	GetXmlTipoLinha( "AdmTipoLinhaVO", xml_g );
				//if( ListTipoClienteR( cidContato ) > 0 )
				//	GetXmlTipoCliente( "AdmTipoClienteVO", xml_g );
				//if( ListUFOperadoraR( cidContato ) > 0 )
				//	GetXmlUFOperadora( "AdmTipoOperadoraVO", xml_g );

				xml_g->addItem("nmLink", "" );
				xml_g->addItem("idContato", cidContato );

			xml_g->closeTag();//selecionados

			xml_g->createTag("disponiveis");
				if( ListTipoLinhaNR( cidContato ) > 0 )
					GetXmlTipoLinha( "AdmTipoLinhaVO", xml_g );
				if( ListTipoClienteNR( cidContato ) > 0 )
					GetXmlTipoCliente( "AdmTipoClienteVO", xml_g );
				if( ListUFOperadoraNR( cidContato ) > 0 )
					GetXmlUFOperadora( "AdmTipoOperadoraVO", xml_g );

				xml_g->addItem("nmLink", "" );
				xml_g->addItem("idContato", cidContato );

			xml_g->closeTag();//disponiveis

		xml_g->closeTag();//AdmListaLinkVO
		iRet++;
	}
    ULOG_END("CContatoInformacao::Relacao()");
	return iRet;
}
