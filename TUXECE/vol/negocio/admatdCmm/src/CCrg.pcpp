#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CCrg.h"

CCargo::CCargo()
{
}

CCargo::~CCargo()
{
}

int CCargo::Insert( 
			char* cnmCargo,
			char* cidUsuarioAlteracao )
{
    ULOG_START("CCargo::Insert()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cAuxidCargo[255+1];
		char* cAuxnmCargo = cnmCargo;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
		int iCont;
	EXEC SQL END DECLARE SECTION;
	
	//Zera a estrutura da classe
	ZeraCargo();
	
	memset( &cAuxidCargo, 0, sizeof(cAuxidCargo) ); 
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
	
	EXEC SQL SELECT	COUNT( idCargo ) 
	INTO :iCont 
	FROM acesso.Cargo
	WHERE UPPER(nmCargo) = UPPER(TRIM(:cAuxnmCargo));
	if( iCont > 0 )
		return -1;//Nome duplicado			

	//Pega um id unico e sequencia para a insercao
	EXEC SQL SELECT acesso.CargoSQ.NEXTVAL INTO :cAuxidCargo FROM DUAL;

	//Realiza o insert
	EXEC SQL INSERT INTO acesso.Cargo
	(	idCargo,
		nmCargo,
		idUsuarioAlteracao,
		dtUltimaAlteracao) 
	VALUES 
	(	:cAuxidCargo,
		TRIM(:cAuxnmCargo),
		:cAuxidUsuarioAlteracao,
		SYSDATE);
		
    ULOG_END("CCargo::Insert()");
	return 1;//Sucesso
	
GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}



// Insere e lista o novo intem inserido
int CCargo::InsertList( 
			char* cnmCargo,
			char* cidUsuarioAlteracao )
{
    ULOG_START("CCargo::InsertList()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cAuxidCargo[255+1];
		char* cAuxnmCargo = cnmCargo;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
		int iCont;
	EXEC SQL END DECLARE SECTION;
	
	//Zera a estrutura da classe
	ZeraCargo();
	
	memset( &cAuxidCargo, 0, sizeof(cAuxidCargo) ); 
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
	
	EXEC SQL SELECT	COUNT( idCargo ) 
	INTO :iCont 
	FROM acesso.Cargo
	WHERE UPPER(nmCargo) = UPPER(TRIM(:cAuxnmCargo));
	if( iCont > 0 )
		return -1;//Nome duplicado			

	//Pega um id unico e sequencia para a insercao
	EXEC SQL SELECT acesso.CargoSQ.NEXTVAL INTO :cAuxidCargo FROM DUAL;

	//Realiza o insert
	EXEC SQL INSERT INTO acesso.Cargo
	(	idCargo,
		nmCargo,
		idUsuarioAlteracao,
		dtUltimaAlteracao) 
	VALUES 
	(	:cAuxidCargo,
		TRIM(:cAuxnmCargo),
		:cAuxidUsuarioAlteracao,
		SYSDATE);

	//Adiciona a classe
	Add( (char*)cAuxidCargo.arr, cnmCargo );
	
	ULOG_END("CCargo::InsertList()");
	
	return 1;//Sucesso
	
GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}




int CCargo::RelacaoCA( char* cid, char* cNomeIdTag, char* cNomeTag, char* cNomeTagAssociadasExterna, char* cNomeTagAssociadas, char* cNomeTagExistentesExterna, char* cNomeTagExistentes, XMLGen*xml )
{
	//Reader
	xml->createTag( cNomeTag );
	xml->addProp( "xmlns", "usuario.fo.vivo.com.br/vo" );

	//Consistencia	
	if( strlennull( cid ) <= 0 )
		return 0; //Retorno com erro

	//Registros
	xml->addItem( cNomeIdTag, cid );
	
	//Outros itens
	
	//Associados
	RelacaoCA( cid );
	GetXml( cNomeTagAssociadasExterna, cNomeTagAssociadas, xml );
	
	//Existentes
	ExistemCA( cid );
	GetXml( cNomeTagExistentesExterna, cNomeTagExistentes, xml );
	
	//Reader
	xml->closeTag();

	//Retorno com sucesso
	return 1;
}
int CCargo::RelacaoCA( char* cidAtribuicao )
{
    ULOG_START("CCargo::RelacaoCA()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidAtribuicao = cidAtribuicao; 
		struct
		{
			VARCHAR stidCargo[21+1];
			VARCHAR stnmCargo[255+1];
		} stCargoRegistro;
		struct
		{
			short iidCargo;
			short inmCargo;
		} stCargoIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraCargo();

	sqlca.sqlcode=0;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
	//Declara um cursor para listar os Registros
    // ====================================================================
   	// Remoção de views BZEROUM - Maio/2007 -- Cassio
    // ====================================================================
	// EXEC SQL DECLARE CursorCargoRelacao_00 CURSOR FOR
	// 	SELECT acesso.CargoB0.idCargo, acesso.CargoB0.nmCargo 
	// 		FROM acesso.Cargo, organograma.CargoAtribuicaoBZEROUM
	// 		WHERE acesso.CargoB0.idCargo = organograma.CargoAtribuicaoBZEROUM.idCargo AND 
	// 			  organograma.CargoAtribuicaoBZEROUM.idAtribuicao = :cAuxidAtribuicao
	// 	ORDER BY upper(trim(acesso.CargoB0.nmCargo));

	EXEC SQL DECLARE CursorCargoRelacao_00 CURSOR FOR
    SELECT
        CARGO.IDCARGO,
        CARGO.NMCARGO
    FROM
        ACESSO.CARGO CARGO,
        ORGANOGRAMA.CARGOATRIBUICAO CARGOATRIBUICAO
    WHERE
        CARGOATRIBUICAO.IDCARGO = CARGO.IDCARGO
    AND CARGOATRIBUICAO.IDATRIBUICAO = :cAuxidAtribuicao
    ORDER BY
        UPPER (TRIM(CARGO.NMCARGO));

	EXEC SQL WHENEVER SQLERROR GOTO GotoRelacao;

	EXEC SQL OPEN CursorCargoRelacao_00;

	//Caso inexista registros sair do loop
	EXEC SQL WHENEVER NOT FOUND DO break;
	for(;;)
	{
		//Zera a estrutura de restorno
		memset( &stCargoRegistro, 0, sizeof(stCargoRegistro) );
		//Pega um registro no CURSOR
		EXEC SQL FETCH CursorCargoRelacao_00 INTO :stCargoRegistro:stCargoIndicator;
		//Adiciona a classe
		Add( 	(char*)stCargoRegistro.stidCargo.arr,
		(char*)stCargoRegistro.stnmCargo.arr );
		//conta quantos existem
		iCont++;
	}
	//Fecha o cursor
	EXEC SQL CLOSE CursorCargoRelacao_00;

    ULOG_END("CCargo::RelacaoCA()");
    
	//Retorna sucesso
	return 1;

GotoRelacao:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CCargo::ExistemCA( char* cidAtribuicao )
{
    ULOG_START("CCargo::ExistemCA()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidAtribuicao = cidAtribuicao; 
		struct
		{
			VARCHAR stidCargo[21+1];
			VARCHAR stnmCargo[255+1];
		} stCargoRegistro;
		struct
		{
			short iidCargo;
			short inmCargo;
		} stCargoIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraCargo();

	sqlca.sqlcode=0;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
	//Declara um cursor para listar os Registros
    // ====================================================================
   	// Remoção de views BZEROUM - Maio/2007 -- Cassio
    // ====================================================================
	// EXEC SQL DECLARE CursorCargoExistem_00 CURSOR FOR 
	// SELECT acesso.CargoB0.idCargo, acesso.CargoB0.nmCargo 
	// FROM acesso.Cargo 
	// WHERE acesso.CargoB0.idCargo 
	// 	NOT IN ( SELECT acesso.CargoB0.idCargo FROM acesso.Cargo, 
	// 			 organograma.CargoAtribuicaoBZEROUM WHERE 
	// 			 acesso.CargoB0.idCargo = organograma.CargoAtribuicaoBZEROUM.idCargo AND 
	// 			 organograma.CargoAtribuicaoBZEROUM.idAtribuicao = :cAuxidAtribuicao  )
	// ORDER BY upper(trim(acesso.CargoB0.nmCargo)); 

    EXEC SQL DECLARE CursorCargoExistem_00 CURSOR FOR 
        SELECT 
            CARGO.IDCARGO,
            CARGO.NMCARGO 
        FROM
            ACESSO.CARGO CARGO 
        WHERE 
            CARGO.IDCARGO NOT IN ( SELECT 
                                        CARGO2.IDCARGO 
                                    FROM 
                                        ACESSO.CARGO CARGO2, 
                                        ORGANOGRAMA.ATRIBUICAO ATRIBUICAO,
                                        ORGANOGRAMA.CARGOATRIBUICAO CARGOATRIBUICAO
                                    WHERE 
                                        CARGO2.IDCARGO = CARGOATRIBUICAO.IDCARGO 
                                    AND CARGOATRIBUICAO.IDATRIBUICAO = :cAuxidAtribuicao )
        ORDER BY
            UPPER(TRIM(CARGO.NMCARGO)); 

	EXEC SQL WHENEVER SQLERROR GOTO GotoExistem;

	EXEC SQL OPEN CursorCargoExistem_00;

	//Caso inexista registros sair do loop
	EXEC SQL WHENEVER NOT FOUND DO break;
	for(;;)
	{
		//Zera a estrutura de restorno
		memset( &stCargoRegistro, 0, sizeof(stCargoRegistro) );
		//Pega um registro no CURSOR
		EXEC SQL FETCH CursorCargoExistem_00 INTO :stCargoRegistro:stCargoIndicator;
		//Adiciona a classe
		Add( 	(char*)stCargoRegistro.stidCargo.arr,
		(char*)stCargoRegistro.stnmCargo.arr );
		//conta quantos existem
		iCont++;
	}
	//Fecha o cursor
	EXEC SQL CLOSE CursorCargoExistem_00;
	
    ULOG_END("CCargo::ExistemCA()");
    
	//Retorna sucesso
	return 1;

GotoExistem:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CCargo::RelacaoNC( char* cid, char* cNomeIdTag, char* cNomeTag, char* cNomeTagAssociadasExterna, char* cNomeTagAssociadas, char* cNomeTagExistentesExterna, char* cNomeTagExistentes, XMLGen*xml )
{
    ULOG_START("CCargo::RelacaoNC()");
    //Reader
	xml->createTag( cNomeTag );
	xml->addProp( "xmlns", "usuario.fo.vivo.com.br/vo" );

	//Consistencia	
	if( strlennull( cid ) <= 0 )
		return 0; //Retorno com erro

	//Registros
	xml->addItem( cNomeIdTag, cid );
	
	//Outros itens
	
	//Associados
	RelacaoNC( cid );
	GetXml( cNomeTagAssociadasExterna, cNomeTagAssociadas, xml );
	
	//Existentes
	ExistemNC( cid );
	GetXml( cNomeTagExistentesExterna, cNomeTagExistentes, xml );
	
	//Reader
	xml->closeTag();
    ULOG_START("CCargo::RelacaoNC()");
	//Retorno com sucesso
	return 1;
}
int CCargo::RelacaoNC( char* cidNivel )
{
    ULOG_START("CCargo::RelacaoNC()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidNivel = cidNivel; 
		struct
		{
			VARCHAR stidCargo[21+1];
			VARCHAR stnmCargo[255+1];
		} stCargoRegistro;
		struct
		{
			short iidCargo;
			short inmCargo;
		} stCargoIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraCargo();

	sqlca.sqlcode=0;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
	//Declara um cursor para listar os Registros
    // ====================================================================
   	// Remoção de views BZEROUM - Maio/2007 -- Cassio
    // ====================================================================
	// EXEC SQL DECLARE CursorCargoRelacao_01 CURSOR FOR
   	// 	SELECT acesso.CargoB0.idCargo, acesso.CargoB0.nmCargo 
	// 		FROM acesso.Cargo, organograma.NivelCargoBZEROUM
	// 		WHERE acesso.CargoB0.idCargo = organograma.NivelCargoBZEROUM.idCargo 
	// 		AND 
	// 			organograma.NivelCargoBZEROUM.idNivel = :cAuxidNivel 
	// 	ORDER BY upper(trim(acesso.CargoB0.nmCargo)) ;

	EXEC SQL DECLARE CursorCargoRelacao_01 CURSOR FOR
        SELECT 
            CARGO.IDCARGO,
            CARGO.NMCARGO 
        FROM
            ACESSO.CARGO CARGO,
            ORGANOGRAMA.NIVELCARGO NIVELCARGO
        WHERE
            NIVELCARGO.IDCARGO = CARGO.IDCARGO
        AND NIVELCARGO.IDNIVEL = :cAuxidNivel 
        ORDER BY
            UPPER(TRIM(CARGO.NMCARGO));

	EXEC SQL WHENEVER SQLERROR GOTO GotoRelacao;
	EXEC SQL OPEN CursorCargoRelacao_01;

	//Caso inexista registros sair do loop
	EXEC SQL WHENEVER NOT FOUND DO break;
	for(;;)
	{
		//Zera a estrutura de restorno
		memset( &stCargoRegistro, 0, sizeof(stCargoRegistro) );
		//Pega um registro no CURSOR
		EXEC SQL FETCH CursorCargoRelacao_01 INTO :stCargoRegistro:stCargoIndicator;
		//Adiciona a classe
		Add( 	(char*)stCargoRegistro.stidCargo.arr,
		(char*)stCargoRegistro.stnmCargo.arr );
		//conta quantos existem
		iCont++;
	}
	//Fecha o cursor
	EXEC SQL CLOSE CursorCargoRelacao_01;
	ULOG_END("CCargo::RelacaoNC()");
	//Retorna sucesso
	return iCont;

GotoRelacao:
	ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CCargo::ExistemNC( char* cidNivel )
{
    ULOG_START("CCargo::ExistemNC()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidNivel = cidNivel; 
		struct
		{
			VARCHAR stidCargo[21+1];
			VARCHAR stnmCargo[255+1];
		} stCargoRegistro;
		struct
		{
			short iidCargo;
			short inmCargo;
		} stCargoIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraCargo();

	sqlca.sqlcode=0;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
	//Declara um cursor para listar os Registros
    // ====================================================================
   	// Remoção de views BZEROUM - Maio/2007 -- Cassio
    // ====================================================================
	// EXEC SQL DECLARE CursorCargoExistem_01 CURSOR FOR 
   	// 	SELECT acesso.CargoB0.idCargo, acesso.CargoB0.nmCargo 
	// 		FROM acesso.Cargo 
	// 		WHERE acesso.CargoB0.idCargo 
	// 			NOT IN ( SELECT acesso.CargoB0.idCargo 
	// 					 FROM acesso.Cargo, organograma.NivelCargoBZEROUM 
	// 					 WHERE acesso.CargoB0.idCargo = organograma.NivelCargoBZEROUM.idCargo 
	// 					 AND organograma.NivelCargoBZEROUM.idNivel = :cAuxidNivel  )
	// 		ORDER BY upper(trim(acesso.CargoB0.nmCargo)); 

	EXEC SQL DECLARE CursorCargoExistem_01 CURSOR FOR 
        SELECT
            CARGO.IDCARGO,
            CARGO.NMCARGO 
        FROM
            ACESSO.CARGO CARGO 
        WHERE 
            CARGO.IDCARGO 
        NOT IN ( SELECT CARGO2.IDCARGO 
                   FROM ACESSO.CARGO CARGO2,
                        ORGANOGRAMA.NIVELCARGO NIVELCARGO
                  WHERE 
                        NIVELCARGO.IDCARGO = CARGO2.IDCARGO
                    AND NIVELCARGO.IDNIVEL = :cAuxidNivel  
                )
       ORDER BY 
                UPPER(TRIM(CARGO.NMCARGO));

	EXEC SQL WHENEVER SQLERROR GOTO GotoExistem;
	EXEC SQL OPEN CursorCargoExistem_01;

	//Caso inexista registros sair do loop
	EXEC SQL WHENEVER NOT FOUND DO break;
	for(;;)
	{
		//Zera a estrutura de restorno
		memset( &stCargoRegistro, 0, sizeof(stCargoRegistro) );
		//Pega um registro no CURSOR
		EXEC SQL FETCH CursorCargoExistem_01 INTO :stCargoRegistro:stCargoIndicator;
		//Adiciona a classe
		Add( 	(char*)stCargoRegistro.stidCargo.arr,
		(char*)stCargoRegistro.stnmCargo.arr );
		//conta quantos existem
		iCont++;
	}
	//Fecha o cursor
	EXEC SQL CLOSE CursorCargoExistem_01;
    ULOG_END("CCargo::ExistemNC()");
	//Retorna sucesso
	return 1;

GotoExistem:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CCargo::Update( 
			char* cidCargo,
			char* cnmCargo,
			char* cidUsuarioAlteracao )
{
    ULOG_START("CCargo::Update()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		int iCont;
		char* cAuxidCargo = cidCargo;
		char* cAuxnmCargo = cnmCargo;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;

	//Zera a estrutura da classe
	ZeraCargo();
	
	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
	
	EXEC SQL SELECT	COUNT( idCargo ) 
	INTO :iCont 
	FROM acesso.Cargo
	WHERE UPPER(nmCargo) = UPPER(TRIM(:cAuxnmCargo))
	AND	idCargo != :cAuxidCargo;
	if( iCont > 0 )
		return -1;//Nome duplicado			

	//Executa a instrucao de update
	EXEC SQL 
	UPDATE acesso.Cargo
	SET 	nmCargo = TRIM(:cAuxnmCargo),
	idUsuarioAlteracao = :cAuxidUsuarioAlteracao,
	dtUltimaAlteracao = SYSDATE
	WHERE 	idCargo = :cAuxidCargo;  
	
	ULOG_END("CCargo::Update()"); 
		
	return 1;//Sucesso

GotoUpdate:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

	
}

int CCargo::Delete( char* cidCargo )
{
    ULOG_START("CCargo::Delete()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;	
		char* cAuxidCargo = cidCargo; 
	EXEC SQL END DECLARE SECTION;
	
	//Zera a estrutura da classe
	ZeraCargo();
	
	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
	sqlca.sqlcode=0;
	
	//Executa a instrucao de delecao
	EXEC SQL DELETE FROM acesso.Cargo
	WHERE (idCargo = :cAuxidCargo);
	
	ULOG_END("CCargo::Delete()");
	
	return 1;//Sucesso

GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if(sqlca.sqlcode == -2292)
		return sqlca.sqlcode;
	else
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CCargo::List( char* cidCargo,
			      char* cnmCargo,
			      char* cidUsuarioAlteracao )
{
    ULOG_START("CCargo::List()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char cAuxidCargo[21+1];
		char cAuxnmCargo[265+1];
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao; 
		struct
		{
			VARCHAR stidCargo[21+1];
			VARCHAR stnmCargo[255+1];
		} stCargoRegistro;
		struct
		{
			short iidCargo;
			short inmCargo;
		} stCargoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Zera a estrutura da classe
	ZeraCargo();
	memset( cAuxidCargo, 0, sizeof(cAuxidCargo) );
	memset( cAuxnmCargo, 0, sizeof(cAuxnmCargo) );
	
	if ( strlennull( cidCargo ) == 0 )
		strcpy(cAuxidCargo , "-1" );
	else
		strcpy(cAuxidCargo , cidCargo );
	
	if ( strlennull( cnmCargo ) == 0 )
		strcpy(cAuxnmCargo , "-1" );
	else
		sprintf(cAuxnmCargo,"%.*s%%",255,cnmCargo);
	


	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
	sqlca.sqlcode=0;

	//Declara um cursor para listar os Registros
	EXEC SQL 
	DECLARE 
		CursorCargo CURSOR FOR 
	SELECT
		idCargo, 
		nmCargo
	FROM
		acesso.Cargo
	WHERE 
	(
		IDCARGO = :cAuxidCargo OR '-1' = :cAuxidCargo
	)
	AND 
	(
		UPPER(NMCARGO) LIKE UPPER(:cAuxnmCargo) OR '-1' = :cAuxnmCargo
	)
	ORDER BY UPPER(NMCARGO);

	// Abre o cursor
	EXEC SQL OPEN CursorCargo;

	//Caso inexista registros sair do loop
	EXEC SQL WHENEVER NOT FOUND DO break;
	for(;;)
	{
		//Zera a estrutura de restorno
		memset( &stCargoRegistro, 0, sizeof(stCargoRegistro) );
		//Pega um registro no CURSOR
		EXEC SQL FETCH CursorCargo INTO :stCargoRegistro:stCargoIndicator;
		//Adiciona a classe
		Add( 	(char*)stCargoRegistro.stidCargo.arr,
		(char*)stCargoRegistro.stnmCargo.arr );
		//conta quantos existem
		iCont++;
	}
	//Fecha o CURSOR
	EXEC SQL CLOSE CursorCargo;

    ULOG_END("CCargo::List()");
	//Retorna sucesso
	return 1;

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);


}

int CCargo::ListId( char* cidCargo ) 
{
    ULOG_START("CCargo::ListId()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidCargo = cidCargo; 
		struct
		{
			VARCHAR stidCargo[21+1];
			VARCHAR stnmCargo[255+1];
		} stCargoRegistro;
		struct
		{
			short iidCargo;
			short inmCargo;
		} stCargoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Zera a estrutura da classe
	ZeraCargo();

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
	sqlca.sqlcode=0;

	//Declara um cursor para listar os IDs
	EXEC SQL DECLARE CursorCargoId CURSOR FOR 
	SELECT 	idCargo,
			nmCargo
	FROM acesso.Cargo
	WHERE idCargo = :cAuxidCargo
	ORDER BY upper(trim(nmCargo));

	//Abre o cursor
	EXEC SQL OPEN CursorCargoId;

	//Caso inexista registros sair do loop
	EXEC SQL WHENEVER NOT FOUND DO break;
	for(;;)
	{
		//Zera a estrutura de restorno
		memset( &stCargoRegistro, 0, sizeof(stCargoRegistro) );
		//Pega um registro no CURSOR
		EXEC SQL FETCH CursorCargoId INTO :stCargoRegistro:stCargoIndicator;
		//Adiciona a classe
		Add( 	(char*)stCargoRegistro.stidCargo.arr,
		(char*)stCargoRegistro.stnmCargo.arr );
		//conta quantos existem
		iCont++;
	}
	//Fecha o CURSOR
	EXEC SQL CLOSE CursorCargoId;
    ULOG_END("CCargo::ListId()");
	//Retorna sucesso
	return 1;

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}



int CCargo::ListAll( void )
{
    ULOG_START("CCargo::ListAll()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidCargo[21+1];
			VARCHAR stnmCargo[255+1];
		} stCargoRegistro;
		struct
		{
			short iidCargo;
			short inmCargo;
		} stCargoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Zera a estrutura da classe
	ZeraCargo();

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
	sqlca.sqlcode=0;

	//Declara um cursor para listar todos os registros
	EXEC SQL DECLARE CursorCargoAll CURSOR FOR
	SELECT 	idCargo,
			nmCargo
	FROM acesso.Cargo
	ORDER BY upper(trim(nmCargo)); 

	//Abre o cursor
	EXEC SQL OPEN CursorCargoAll;

	//Caso inexista registros sair do loop
	EXEC SQL WHENEVER NOT FOUND DO break;
	for(;;)
	{
		//Zera a estrutura de restorno
		memset( &stCargoRegistro, 0, sizeof(stCargoRegistro) );
		//Pega um registro no CURSOR
		EXEC SQL FETCH CursorCargoAll INTO :stCargoRegistro:stCargoIndicator;
		//Adiciona a classe
		Add( 	(char*)stCargoRegistro.stidCargo.arr,
		(char*)stCargoRegistro.stnmCargo.arr );
		//conta quantos existem
		iCont++;
	}
	//Fecha o cursor
	EXEC SQL CLOSE CursorCargoAll;
	
	ULOG_END("CCargo::ListAll()");

	return iCont;

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}


int CCargo::ListCargoPorIdNivel( char* cidNivelCargo ) 
{
    ULOG_START("CCargo::ListCargoPorIdNivel()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidCargo[21+1];
			VARCHAR stnmCargo[255+1];
		} stCargoRegistro;
		struct
		{
			short iidCargo;
			short inmCargo;
		} stCargoIndicator;

        char *oszIdNivel = cidNivelCargo;

	EXEC SQL END DECLARE SECTION;

	//Zera a estrutura da classe
	ZeraCargo();

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListIdNivel;
	sqlca.sqlcode=0;

	//Declara um cursor para listar os IDs
	EXEC SQL DECLARE cListIdNivel CURSOR FOR 
         SELECT cargo.idcargo
              , cargo.nmcargo
           FROM acesso.cargo cargo
              , organograma.nivelcargo nivelcargo
          WHERE cargo.idcargo = nivelcargo.IDCARGO
            AND nivelcargo.IDNIVEL = :oszIdNivel
         ORDER BY upper(trim(cargo.nmcargo));

	//Abre o cursor
	EXEC SQL OPEN cListIdNivel;

	//Caso inexista registros sair do loop
	EXEC SQL WHENEVER NOT FOUND DO break;
	for(;;)
	{
		//Zera a estrutura de restorno
		memset( &stCargoRegistro, 0, sizeof(stCargoRegistro) );

		//Pega um registro no CURSOR
		EXEC SQL FETCH cListIdNivel INTO :stCargoRegistro:stCargoIndicator;

		//Adiciona a classe
		Add( 	(char*)stCargoRegistro.stidCargo.arr,
		        (char*)stCargoRegistro.stnmCargo.arr );

		//conta quantos existem
		iCont++;
	}
	//Fecha o CURSOR
	EXEC SQL CLOSE cListIdNivel;
	
	ULOG_END("CCargo::ListCargoPorIdNivel()");
	
	//Retorna a quantidade de registros
	return iCont;

GotoListIdNivel:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}




void CCargo::GetXml( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
				xml->createTag(cNomeTag);
			//Adiciona a propriedade necessaria para o xml
			xml->addProp( "xmlns", "usuario.fo.vivo.com.br/vo" );
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idCargo", Registro(x)->cidCargo );
				xml->addItem("nmCargo", Registro(x)->cnmCargo ); 
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}

void CCargo::GetXml( char* cNomeTagArray, char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() >= 0 )
	{
		//Caso nao tenha recebido uma tag padrao, deixa sem
		if( strlennull( cNomeTagArray ) > 0 ) {
			xml->createTag(cNomeTagArray);
			//Adiciona a propriedade necessaria para o xml
			xml->addProp( "xmlns", "usuario.fo.vivo.com.br/vo" );
		}
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 ) {
				xml->createTag(cNomeTag);
				//Adiciona a propriedade necessaria para o xml
				xml->addProp( "xmlns", "usuario.fo.vivo.com.br/vo" );
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idCargo", Registro(x)->cidCargo );
				xml->addItem("nmCargo", Registro(x)->cnmCargo ); 
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
		//So fecha um tag se abriu anteriormente
		if( strlennull( cNomeTagArray ) > 0 )
			xml->closeTag();
	}
}
