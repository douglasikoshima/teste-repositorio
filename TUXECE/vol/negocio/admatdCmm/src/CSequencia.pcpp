#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CSequencia.h"

CSequencia::CSequencia()
{
}

CSequencia::~CSequencia()
{
}

int CSequencia::Insert( 
								char* cidContatoGrupo,
								char* cidTipoSequencia,
								char* csqOrdem,
								char* cidUsuarioAlteracao
							 )
{
    ULOG_START("CSequencia::Insert( cidContatoGrupo, cidTipoSequencia, csqOrdem, cidUsuarioAlteracao )");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContatoGrupo = cidContatoGrupo;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
		char* cAuxidTipoSequencia = cidTipoSequencia;
		char* cAuxsqOrdem = csqOrdem;
		VARCHAR stidSequencia[21+1];
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
		memset( &stidSequencia, 0, sizeof( stidSequencia ) );
		
    //ULOG( "idContatoGrupo [%d], idTipoSequencia [%d]", cAuxidContatoGrupo, cAuxidTipoSequencia );
    EXEC SQL
    UPDATE contatoadm.Sequencia
    SET idUsuarioAlteracao = :cAuxidUsuarioAlteracao ,
        dtUltimaAlteracao = SYSDATE
    WHERE
      idContatoGrupo = :cAuxidContatoGrupo
    AND SQORDEM = :cAuxsqOrdem
    AND idTipoSequencia = :cAuxidTipoSequencia ;
            
    //ULOG( ">>> Linhas afetadas [%d]", sqlca.sqlerrd[2] );
    
    if ( sqlca.sqlerrd[2] == 0 ) // Nao existe este registro
    {
  		//Recupera um id unico
  		EXEC SQL
  			SELECT
  				CONTATOADM.SEQUENCIASQ.NEXTVAL
  			INTO
  				:stidSequencia
  			FROM DUAL;
  		
  		//Realiza o insert
  		EXEC SQL 
  			INSERT INTO CONTATOADM.SEQUENCIA 
  			(	IDSEQUENCIA,
  				IDCONTATOGRUPO,
  				IDTIPOSEQUENCIA,
  				SQORDEM,
  				IDUSUARIOALTERACAO,
  				DTULTIMAALTERACAO
  			)
  			VALUES 
  			(	:stidSequencia,
  				:cAuxidContatoGrupo,
  				:cAuxidTipoSequencia,
  				:cAuxsqOrdem,
  				:cAuxidUsuarioAlteracao,
  				SYSDATE
  			);
    }
    else
    {
  		EXEC SQL
  			SELECT
  				IDSEQUENCIA
  			INTO
  				:stidSequencia
  			FROM 
  			  CONTATOADM.SEQUENCIA
  			WHERE
          idContatoGrupo = :cAuxidContatoGrupo
        AND idTipoSequencia = :cAuxidTipoSequencia ;
    }
		
		//Adiciona a classe
		Add( 	
			(char*)stidSequencia.arr,
			cAuxidContatoGrupo, 
			cAuxidTipoSequencia,
			cAuxsqOrdem
		);
		
        ULOG_END("CSequencia::Insert()");
		return 0;//Sucesso
	}
	catch(...)
	{
		throw;
	}
	
GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

// CORRECAO CONTATOGRUPO
int CSequencia::Insert( 
								char* cidContatoGrupo,
								char* cidTipoSequencia,
								char* csqOrdem,
								char* cidGrupo,
								char* cidUsuarioAlteracao
							 )
{
    ULOG_START("CSequencia::Insert() cidContatoGrupo, cidTipoSequencia, csqOrdem, cidGrupo, cidUsuarioAlteracao");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContatoGrupo = cidContatoGrupo;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
		char* cAuxidTipoSequencia = cidTipoSequencia;
		char* cAuxsqOrdem = csqOrdem;
		VARCHAR stidSequencia[21+1];
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
		memset( &stidSequencia, 0, sizeof( stidSequencia ) );
		
    //ULOG( "idContatoGrupo [%s], idTipoSequencia [%s]", cAuxidContatoGrupo, cAuxidTipoSequencia );
    
    EXEC SQL
    UPDATE contatoadm.Sequencia
    SET idUsuarioAlteracao = :cAuxidUsuarioAlteracao ,
        dtUltimaAlteracao = SYSDATE
    WHERE
      idContatoGrupo = :cAuxidContatoGrupo
    AND SQORDEM = :cAuxsqOrdem
    AND IDTIPOSEQUENCIA = :cAuxidTipoSequencia
    AND idTipoSequencia = :cAuxidTipoSequencia ;
            
    //ULOG( ">>> Linhas afetadas [%d]", sqlca.sqlerrd[2] );

    if ( sqlca.sqlerrd[2] == 0 ) // Nao existe este registro
    {
  		//Recupera um id unico
  		EXEC SQL
  			SELECT
  				CONTATOADM.SEQUENCIASQ.NEXTVAL
  			INTO
  				:stidSequencia
  			FROM DUAL;
  		
  		//Realiza o insert
  		EXEC SQL 
  			INSERT INTO CONTATOADM.SEQUENCIA 
  			(	IDSEQUENCIA,
  				IDCONTATOGRUPO,
  				IDTIPOSEQUENCIA,
  				SQORDEM,
  				IDUSUARIOALTERACAO,
  				DTULTIMAALTERACAO
  			)
  			VALUES 
  			(	:stidSequencia,
  				:cAuxidContatoGrupo,
  				:cAuxidTipoSequencia,
  				:cAuxsqOrdem,
  				:cAuxidUsuarioAlteracao,
  				SYSDATE
  			);
    }
    else
    {
  		EXEC SQL
  			SELECT
  				IDSEQUENCIA
  			INTO
  				:stidSequencia
  			FROM 
  			  CONTATOADM.SEQUENCIA
  			WHERE
          idContatoGrupo = :cAuxidContatoGrupo
        AND idTipoSequencia = :cAuxidTipoSequencia ;
    }

		//Adiciona a classe
		Add( 	
			(char*)stidSequencia.arr,
			cAuxidContatoGrupo, 
			cAuxidTipoSequencia,
			cAuxsqOrdem,
			cidGrupo
		);
		
        ULOG_END("CSequencia::Insert()");
		return 0;//Sucesso
	}
	catch(...)
	{
		throw;
	}
	
GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CSequencia::Update( 
								char* cidSequencia,
								char* cidContatoGrupo,
								char* cidTipoSequencia,
								char* csqOrdem,
								char* cidUsuarioAlteracao 
							 )
{
    ULOG_START("CSequencia::Update()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidSequencia = cidSequencia;
		char* cAuxidContatoGrupo = cidContatoGrupo;
		char* cAuxidTipoSequencia = cidTipoSequencia;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
		char* cAuxsqOrdem = csqOrdem;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraSequencia();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
		
		//Executa a instrucao de update
		EXEC SQL 
			UPDATE CONTATOADM.SEQUENCIA 
			SET
				IDCONTATOGRUPO = :cAuxidContatoGrupo,
				IDTIPOSEQUENCIA = :cAuxidTipoSequencia,
				SQORDEM = :cAuxsqOrdem,
				IDUSUARIOALTERACAO = :cAuxidUsuarioAlteracao,
				DTULTIMAALTERACAO = SYSDATE
			WHERE
				IDSEQUENCIA = :cAuxidSequencia;
				
		ULOG_END("CSequencia::Update()");
		return 0;
	}
	catch(...)
	{
		throw;
	}

GotoUpdate:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CSequencia::Delete( char* cidSequencia )
{
    ULOG_START("CSequencia::Delete()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;	
		char* cAuxidSequencia = cidSequencia; 
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraSequencia();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
		sqlca.sqlcode=0;
		
		//Executa a instrucao de delecao
		EXEC SQL 
			DELETE FROM 
				CONTATOADM.SEQUENCIA 		
			WHERE 
				IDSEQUENCIA = :cAuxidSequencia;
				
		ULOG_END("CSequencia::Delete()");
		return 0;//Sucesso
	}
	catch(...)
	{
		throw;
	}

GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if( sqlca.sqlcode == -2292 )
		return 1;
	else
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CSequencia::ListId( char* cidSequencia ) 
{
    ULOG_START("CSequencia::ListId()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidSequencia = cidSequencia; 
		struct
		{
			VARCHAR stidSequencia[21+1];
			VARCHAR stidContatoGrupo[21+1];
			VARCHAR stidTipoSequencia[21+1];
			VARCHAR stsqOrdem[21+1];
		} stSequenciaRegistro;
		struct
		{
			short iidSequencia;
			short iidContatoGrupo;
			short iidTipoSequencia;
			short isqOrdem;
		} stSequenciaIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraSequencia();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorSequenciaId CURSOR FOR 
   			SELECT 	
   				IDSEQUENCIA,
				IDCONTATOGRUPO,
				IDTIPOSEQUENCIA,
				SQORDEM
			FROM 
				CONTATOADM.SEQUENCIA
			WHERE 
				IDSEQUENCIA = :cAuxidSequencia;

		//Abre o cursor
		EXEC SQL OPEN CursorSequenciaId;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stSequenciaRegistro, 0, sizeof(stSequenciaRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorSequenciaId INTO :stSequenciaRegistro:stSequenciaIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stSequenciaRegistro.stidSequencia.arr,
				(char*)stSequenciaRegistro.stidContatoGrupo.arr, 
				(char*)stSequenciaRegistro.stidTipoSequencia.arr,
				(char*)stSequenciaRegistro.stsqOrdem.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorSequenciaId;
		

	}
	catch(...)
	{
		throw;
	}

    ULOG_END("CSequencia::ListId()");
    
	//Retorna a quantidade de registros
	return iCont;
GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CSequencia::ListAll( void )
{
    ULOG_START("CSequencia::ListAll()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidSequencia[21+1];
			VARCHAR stidContatoGrupo[21+1];
			VARCHAR stidTipoSequencia[21+1];
			VARCHAR stsqOrdem[21+1];
		} stSequenciaRegistro;
		struct
		{
			short iidSequencia;
			short iidContatoGrupo;
			short iidTipoSequencia;
			short isqOrdem;
		} stSequenciaIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraSequencia();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL DECLARE CursorSequenciaAll CURSOR FOR
   			SELECT 	
   				IDSEQUENCIA,
				IDCONTATOGRUPO,
				IDTIPOSEQUENCIA,
				SQORDEM
			FROM 
				CONTATOADM.SEQUENCIA
			WHERE
				IDSEQUENCIA > 0; 

		//Abre o cursor
		EXEC SQL OPEN CursorSequenciaAll;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stSequenciaRegistro, 0, sizeof(stSequenciaRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorSequenciaAll INTO :stSequenciaRegistro:stSequenciaIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stSequenciaRegistro.stidSequencia.arr,
				(char*)stSequenciaRegistro.stidContatoGrupo.arr, 
				(char*)stSequenciaRegistro.stidTipoSequencia.arr,
				(char*)stSequenciaRegistro.stsqOrdem.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o cursor
		EXEC SQL CLOSE CursorSequenciaAll;
		
	}
	catch(...)
	{
		throw;
	}
	
	ULOG_END("CSequencia::ListAll()");
	//Retorna a quantidade de registros
	return iCont;

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CSequencia::GetXml( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
				xml->createTag(cNomeTag);
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idSequencia", Registro(x)->cidSequencia );
				xml->addItem("idContatoGrupo", Registro(x)->cidContatoGrupo ); 
				xml->addItem("idTipoSequencia", Registro(x)->cidTipoSequencia ); 
				xml->addItem("sqOrdem", Registro(x)->csqOrdem ); 
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}

int CSequencia::RelacaoPoridContatoGrupo( char* cidContatoGrupo ) 
{
    ULOG_START("CSequencia::RelacaoPoridContatoGrupo()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContatoGrupo = cidContatoGrupo; 
		struct
		{
			VARCHAR stidSequencia[21+1];
			VARCHAR stidContatoGrupo[21+1];
			VARCHAR stidTipoSequencia[21+1];
			VARCHAR stsqOrdem[21+1];
		} stSequenciaRegistro;
		struct
		{
			short iidSequencia;
			short iidContatoGrupo;
			short iidTipoSequencia;
			short isqOrdem;
		} stSequenciaIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraSequencia();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoRelacaoPoridContatoGrupo;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorRelacaoPoridContatoGrupo CURSOR FOR 
   			SELECT 	
   				IDSEQUENCIA,
				IDCONTATOGRUPO,
				IDTIPOSEQUENCIA,
				SQORDEM
			FROM 
				CONTATOADM.SEQUENCIA
			WHERE 
                SEQUENCIA.DTEXCLUSAO IS NULL
			AND
				IDCONTATOGRUPO = :cAuxidContatoGrupo;

		//Abre o cursor
		EXEC SQL OPEN CursorRelacaoPoridContatoGrupo;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
        
        //ULOG( "$$$ Consultando IDCONTATOGRUPO [%s]", cAuxidContatoGrupo  );
		
        for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stSequenciaRegistro, 0, sizeof(stSequenciaRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorRelacaoPoridContatoGrupo INTO :stSequenciaRegistro:stSequenciaIndicator;
            //ULOG( ">>> IDCONTATOGRUPO [%s] - idTipoSequencia [%s]", (char*)stSequenciaRegistro.stidContatoGrupo.arr, stSequenciaRegistro.stidTipoSequencia.arr );
			//Adiciona a classe
			Add( 	
				(char*)stSequenciaRegistro.stidSequencia.arr,
				(char*)stSequenciaRegistro.stidContatoGrupo.arr, 
				(char*)stSequenciaRegistro.stidTipoSequencia.arr,
				(char*)stSequenciaRegistro.stsqOrdem.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorRelacaoPoridContatoGrupo;

	}
	catch(...)
	{
		throw;
	}
    ULOG_END("CSequencia::RelacaoPoridContatoGrupo()");
	//Retorna a quantidade de registros
	return iCont;
GotoRelacaoPoridContatoGrupo:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CSequencia::FindPoridGrupoTipoSequencia( char* cidGrupo, char* cidTipoSequencia )
{
	int iRet = -1;
	for( int x = 0; x < Quantidade(); x++ )
	{
		if( ( strcmp( Registro(x)->cidGrupo, cidGrupo ) == 0 )
		  &&( strcmp( Registro(x)->cidTipoSequencia, cidTipoSequencia ) == 0 ) )
		{
			iRet = x;
			break;
		}
	}
	return iRet;
}
