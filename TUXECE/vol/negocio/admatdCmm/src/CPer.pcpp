#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <CPer.h>

CPergunta::CPergunta()
{
}

CPergunta::~CPergunta()
{
}


int CPergunta::Mover( char* cidPergunta
				     ,int   inMoveUp
					 ,char* cLogUser )
{
    ULOG_START("CPergunta::Mover()");
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR stidQuestionario[21+1];
		short    iRegidItemMen;
		VARCHAR  cRegidPergunta[21+1];
		char* cAuxLogUser     = cLogUser;
		char* cAuxidPergunta  = cidPergunta;
		int   inMoverParaCima = 0;//default: para cima
		int   inMoverParaCimaAux;
		int   iCont;
		int   iPerguntaAtual = 0;
	EXEC SQL END DECLARE SECTION;

	/************************************************************************
	 * Processamento Principal
	 ************************************************************************/
	memset( &stidQuestionario, 0, sizeof( stidQuestionario ) );
	if( strlennull( cidPergunta ) <= 0 )
	{
	    ULOG_END("CPergunta::Mover() return 1");
		return 1;
	}

	if( strlennull( cLogUser ) <= 0 )
	{
	    ULOG_END("CPergunta::Mover() return 2");
		return 2;
	}

	if( inMoveUp <= 0 )
		inMoverParaCima = 1;//Dependendo do parametro de entrada, muda para baixo
	
	sqlca.sqlcode=0;
	EXEC SQL WHENEVER SQLERROR GOTO GotoMover;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	//Recupera o id do Questionario, para poder recuperar as perguntas e ordena-las
	EXEC SQL
		SELECT
			IDPESQUISASATISFACAO
		INTO
			:stidQuestionario
		FROM
			CONTATOADM.PESQUISASATISFACAOPERGUNTA
		WHERE
			IDPERGUNTA = :cAuxidPergunta
		AND 
			ROWNUM <= 1;

	//Pergunta sem questionario, nao pode ser alterada, erro
	if( stidQuestionario.len <= 0 )
	{
	    ULOG_END("CPergunta::Mover() return 3");
		return 3;
	}

	//Recupera todas as perguntas do questionario em questao, no qual a pergunta faz parte
	EXEC SQL WHENEVER NOT FOUND DO break;
	/*
    EXEC SQL
		DECLARE 
			CursorMover CURSOR FOR
		SELECT 
			IDPERGUNTA
		FROM
			CONTATOADM.PESQUISASATISFACAOPERGUNTAB01
		WHERE
			IDPESQUISASATISFACAO = :stidQuestionario
		ORDER BY 
			SQAPRESENTACAO;
    */
    
    
	EXEC SQL
		DECLARE 
			CursorMover CURSOR FOR
		SELECT 
			PERGUNTA.IDPERGUNTA
		FROM
            APOIO.TIPOAPRESENTACAOPERGUNTA TIPOAPRESENTACAOPERGUNTA ,
            QUESTIONARIO.PERGUNTA PERGUNTA ,
		    CONTATOADM.PESQUISASATISFACAO PESQUISASATISFACAO ,
            CONTATOADM.PESQUISASATISFACAOPERGUNTA PESQUISASATISFACAOPERGUNTA
		WHERE
		    PERGUNTA.IDTIPOAPRESENTACAOPERGUNTA = TIPOAPRESENTACAOPERGUNTA.IDTIPOAPRESENTACAOPERGUNTA
	    AND
			PESQUISASATISFACAOPERGUNTA.IDPESQUISASATISFACAO = PESQUISASATISFACAO.IDPESQUISASATISFACAO
        AND 
		    PESQUISASATISFACAOPERGUNTA.IDPERGUNTA = PERGUNTA.IDPERGUNTA
	    AND
			PESQUISASATISFACAO.IDPESQUISASATISFACAO = :stidQuestionario
		ORDER BY 
			PERGUNTA.SQAPRESENTACAO;
            

	EXEC SQL OPEN CursorMover;
	
	//Recupera todas as perguntas relativas ao mesmo questionario que a pergunta em questao
	//para reordena-las todas, para garantir a integridade
	for(iCont = 0;;iCont++)
	{
		memset( &cRegidPergunta, 0, sizeof( cRegidPergunta ) );
		EXEC SQL FETCH CursorMover INTO :cRegidPergunta:iRegidItemMen;
		if( strcmp( (char*)cRegidPergunta.arr, cAuxidPergunta ) == 0 )
			iPerguntaAtual = iCont;//Salva a posicao
		Add( (char*)cRegidPergunta.arr
			,iCont );
	}
	EXEC SQL CLOSE CursorMover;

	if( Quantidade() <= 1 )
	{
	    ULOG_END("CPergunta::Mover() return 4");
		return 4;//Nao ha registros para relizar as modificacoes de posicoes
	}

	//Soh realiza alguma operacao se nao for a primeira a tentar mover para cima 
	//ou nao for a ultima e tentar mover para baixo
	if( !( ( ( iPerguntaAtual == (Quantidade()-1) ) && ( inMoverParaCima ) ) 
	    || ( ( iPerguntaAtual == 0 ) && ( !inMoverParaCima ) ) ) )
	{
		//Troca a numeracao, dependendo da escolha
		if( !inMoverParaCima )
			inMoverParaCima = -1;
		Registro(iPerguntaAtual)->isqApresentacao = Registro(iPerguntaAtual)->isqApresentacao + inMoverParaCima;
		inMoverParaCimaAux = inMoverParaCima*(-1);
		Registro(iPerguntaAtual+inMoverParaCima)->isqApresentacao = Registro(iPerguntaAtual)->isqApresentacao + inMoverParaCimaAux;
	}
	else
	{
	    ULOG_END("CPergunta::Mover() return 5");
		return 5;//Eh a primeiro ou ultima e tentou mover para o lado que nao da mais
	}

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	//Acerta todas as sequencias do mesmo quastionario que o ID passado com parametro
	for(iCont = 0;iCont < Quantidade();iCont++)
	{
		cAuxidPergunta = Registro(iCont)->cidPergunta;
		iPerguntaAtual = Registro(iCont)->isqApresentacao;
		EXEC SQL 
			UPDATE
				QUESTIONARIO.PERGUNTA 
			SET 	
				SQAPRESENTACAO     = :iPerguntaAtual,
				IDUSUARIOALTERACAO = :cAuxLogUser, 
				DTULTIMAALTERACAO  =  SYSDATE
			WHERE 	
				IDPERGUNTA = :cAuxidPergunta;
	}
	ULOG_END("CPergunta::Mover() return 0");
	return 0;

/************************************************************************
 * Tratamento de Exception
 ************************************************************************/

GotoMover:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}


int CPergunta::Insert( char* cidQuestionario,
		               char* cidTipoApresentacaoPergunta, 
					   char* cdsPergunta, 
					   char* cdsScriptPergunta, 
					   char* cinEncerramento,
					   char* cinDisponibilidade,
					   char* cinObrigatoria,
					   char* cidUser )
{
    ULOG_START("CPergunta::Insert()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidUser = cidUser;
		VARCHAR stAuxidPergunta[21+1];
		char* cAuxidTipoApresentacaoPergunta  = cidTipoApresentacaoPergunta;
		char* cAuxdsPergunta  = cdsPergunta;
		char* cAuxdsScriptPergunta  = cdsScriptPergunta;
		VARCHAR stsqApresentacao[21+1];
		char* cAuxinEncerramento  = cinEncerramento;
		char* cAuxinDisponibilidade = cinDisponibilidade;
		char* cAuxinObrigatoria     = cinObrigatoria;
		char* cAuxidQuestionario = cidQuestionario;
	EXEC SQL END DECLARE SECTION;
	
	ZeraPergunta();
	
	memset( &stAuxidPergunta, 0, sizeof(stAuxidPergunta) );
	memset( &stsqApresentacao, 0, sizeof(stsqApresentacao) );
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
	sqlca.sqlcode=0;

	//Verifica se ja existe alguma resposta com o mesmo nome
    /*
	EXEC SQL
		SELECT
			IDPERGUNTA
		INTO
			:stAuxidPergunta
		FROM
			CONTATOADM.PESQUISASATISFACAOPERGUNTAB01
		WHERE
			IDPESQUISASATISFACAO = :cAuxidQuestionario
		AND
			TRIM(UPPER(DSPERGUNTA)) = TRIM(UPPER(:cAuxdsPergunta));
    */
            
            
	EXEC SQL
		SELECT 
			PERGUNTA.IDPERGUNTA
		INTO
			:stAuxidPergunta
		FROM
            APOIO.TIPOAPRESENTACAOPERGUNTA TIPOAPRESENTACAOPERGUNTA ,
            QUESTIONARIO.PERGUNTA PERGUNTA ,
		    CONTATOADM.PESQUISASATISFACAO PESQUISASATISFACAO ,
            CONTATOADM.PESQUISASATISFACAOPERGUNTA PESQUISASATISFACAOPERGUNTA
		WHERE
		    PERGUNTA.IDTIPOAPRESENTACAOPERGUNTA = TIPOAPRESENTACAOPERGUNTA.IDTIPOAPRESENTACAOPERGUNTA
	    AND
			PESQUISASATISFACAOPERGUNTA.IDPESQUISASATISFACAO = PESQUISASATISFACAO.IDPESQUISASATISFACAO
        AND 
		    PESQUISASATISFACAOPERGUNTA.IDPERGUNTA = PERGUNTA.IDPERGUNTA
	    AND
			PESQUISASATISFACAOPERGUNTA.IDPESQUISASATISFACAO = :cAuxidQuestionario
		AND
			TRIM(UPPER(PERGUNTA.DSPERGUNTA)) = TRIM(UPPER(:cAuxdsPergunta));
            
            
	//Ja existe esta pergunta cadastrada para este questionario
	if( stAuxidPergunta.len > 0 )
	{
	    ULOG_END("CPergunta::Insert()");
		return 0;
	}

	/*
    EXEC SQL
		SELECT
			COUNT(IDPERGUNTA)
		INTO
			:stsqApresentacao
		FROM
			CONTATOADM.PESQUISASATISFACAOPERGUNTAB01
		WHERE
			IDPESQUISASATISFACAO = :cAuxidQuestionario;
	*/
    
    EXEC SQL
    SELECT
        COUNT(PERGUNTA.IDPERGUNTA)
    INTO
        :stsqApresentacao
    FROM
        APOIO.TIPOAPRESENTACAOPERGUNTA TIPOAPRESENTACAOPERGUNTA,
        QUESTIONARIO.PERGUNTA PERGUNTA ,
        CONTATOADM.PESQUISASATISFACAO PESQUISASATISFACAO ,
        CONTATOADM.PESQUISASATISFACAOPERGUNTA PESQUISASATISFACAOPERGUNTA
    WHERE
        PESQUISASATISFACAO.IDPESQUISASATISFACAO = :cAuxidQuestionario
    AND PESQUISASATISFACAOPERGUNTA.IDPESQUISASATISFACAO = PESQUISASATISFACAO.IDPESQUISASATISFACAO
    AND PESQUISASATISFACAOPERGUNTA.IDPERGUNTA = PERGUNTA.IDPERGUNTA
    AND PERGUNTA.IDTIPOAPRESENTACAOPERGUNTA = TIPOAPRESENTACAOPERGUNTA.IDTIPOAPRESENTACAOPERGUNTA;
      
	memset( &stAuxidPergunta, 0, sizeof(stAuxidPergunta) );
	//Pega um id unico e sequencia para a insercao
	EXEC SQL
		SELECT QUESTIONARIO.PERGUNTASQ.NEXTVAL
		INTO :stAuxidPergunta
		FROM DUAL;

	EXEC SQL 
		INSERT INTO QUESTIONARIO.PERGUNTA
		  (IDPERGUNTA, 
		   IDTIPOAPRESENTACAOPERGUNTA, 
		   DSPERGUNTA, 
		   INOBRIGATORIA,
		   INDISPONIBILIDADE, 
		   SQAPRESENTACAO, 
		   DSSCRIPTPERGUNTA, 
		   INENCERRAMENTO,
		   IDUSUARIOALTERACAO,
		   DTULTIMAALTERACAO)
		VALUES
		  (:stAuxidPergunta, 
		   :cAuxidTipoApresentacaoPergunta, 
		   :cAuxdsPergunta, 
		   :cAuxinObrigatoria, 
		   :cAuxinDisponibilidade, 
		   :stsqApresentacao, 
		   :cAuxdsScriptPergunta, 
		   :cAuxinEncerramento,
		   :cAuxidUser,
		   SYSDATE);

	EXEC SQL
		INSERT INTO CONTATOADM.PESQUISASATISFACAOPERGUNTA
		  (IDPESQUISASATISFACAOPERGUNTA,
		   IDPESQUISASATISFACAO,
		   IDPERGUNTA,
		   IDUSUARIOALTERACAO,
		   DTULTIMAALTERACAO)
		VALUES
		  (CONTATOADM.PESQUISASATISFACAOPERGUNTASQ.NEXTVAL,
		   :cAuxidQuestionario,
		   :stAuxidPergunta,
		   :cAuxidUser,
		   SYSDATE);
		   
    ULOG_END("CPergunta::Insert()");
	return 1;

GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if( sqlca.sqlcode == -2292 )
		return 2;
	else
		throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CPergunta::Update( char* cidQuestionario,
		               char* cidPergunta, 
                       char* cidTipoApresentacaoPergunta, 
					   char* cdsPergunta, 
					   char* cdsScriptPergunta, 
					   char* cinEncerramento,
					   char* cinDisponibilidade,
					   char* cinObrigatoria,
					   char* cidUser )
{  
    ULOG_END("CPergunta::Update()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR stAuxidPergunta[21+1];
		char* cAuxidUser = cidUser;
		char* cAuxidQuestionario = cidQuestionario;
		char* cAuxidPergunta = cidPergunta;
		char* cAuxidTipoApresentacaoPergunta = cidTipoApresentacaoPergunta;
		char* cAuxdsPergunta = cdsPergunta;
		char* cAuxdsScriptPergunta  = cdsScriptPergunta;
		char* cAuxinEncerramento  = cinEncerramento;
		char* cAuxinDisponibilidade = cinDisponibilidade;
		char* cAuxinObrigatoria     = cinObrigatoria;
		int   iCont = 0;
	EXEC SQL END DECLARE SECTION;

	ZeraPergunta();
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
	sqlca.sqlcode=0;
	
	memset( &stAuxidPergunta, 0, sizeof(stAuxidPergunta) );
	/*
    EXEC SQL
		SELECT
			IDPERGUNTA
		INTO
			:stAuxidPergunta
		FROM
			CONTATOADM.PESQUISASATISFACAOPERGUNTAB01
		WHERE
			IDPESQUISASATISFACAO = :cAuxidQuestionario
		AND
			TRIM(UPPER(DSPERGUNTA)) = TRIM(UPPER(:cAuxdsPergunta))
		AND 
			IDPERGUNTA <> :cAuxidPergunta
		AND
			ROWNUM <= 1;
    */

    EXEC SQL
    SELECT
        PERGUNTA.IDPERGUNTA
    INTO
        :stAuxidPergunta
    FROM
        APOIO.TIPOAPRESENTACAOPERGUNTA TIPOAPRESENTACAOPERGUNTA,
        QUESTIONARIO.PERGUNTA PERGUNTA ,
        CONTATOADM.PESQUISASATISFACAO PESQUISASATISFACAO ,
        CONTATOADM.PESQUISASATISFACAOPERGUNTA PESQUISASATISFACAOPERGUNTA
    WHERE
        PESQUISASATISFACAOPERGUNTA.IDPESQUISASATISFACAO = PESQUISASATISFACAO.IDPESQUISASATISFACAO
    AND 
        PESQUISASATISFACAOPERGUNTA.IDPERGUNTA = PERGUNTA.IDPERGUNTA
    AND 
        PERGUNTA.IDTIPOAPRESENTACAOPERGUNTA = TIPOAPRESENTACAOPERGUNTA.IDTIPOAPRESENTACAOPERGUNTA
    AND
        PESQUISASATISFACAO.IDPESQUISASATISFACAO = :cAuxidQuestionario
    AND
        TRIM(UPPER(PERGUNTA.DSPERGUNTA)) = TRIM(UPPER(:cAuxdsPergunta))
    AND 
        PERGUNTA.IDPERGUNTA <> :cAuxidPergunta
    AND
        ROWNUM <= 1;
            
	//Ja existe esta pergunta cadastrada para este questionario
	if( stAuxidPergunta.len > 0 )
	{
	    ULOG_END("CPergunta::Update()");
		return 0;
	}
	
	EXEC SQL 
		UPDATE 
			QUESTIONARIO.PERGUNTA
		SET 
		   	IDTIPOAPRESENTACAOPERGUNTA  = :cAuxidTipoApresentacaoPergunta,
		    DSPERGUNTA        = TRIM(:cAuxdsPergunta),
		    INENCERRAMENTO    = :cAuxinEncerramento,
		    INDISPONIBILIDADE = :cAuxinDisponibilidade,
		    DSSCRIPTPERGUNTA  = TRIM(:cAuxdsScriptPergunta),
		    INOBRIGATORIA     = :cAuxinObrigatoria,
		    IDUSUARIOALTERACAO= :cAuxidUser,
		    DTULTIMAALTERACAO = SYSDATE
		 WHERE 
		 	IDPERGUNTA = :cAuxidPergunta;
		 	
	if( strlennull( cAuxidQuestionario ) > 0 )
	{
		EXEC SQL
			SELECT 
				COUNT( IDPESQUISASATISFACAOPERGUNTA )
			INTO
				:iCont
			FROM
				CONTATOADM.PESQUISASATISFACAOPERGUNTA
			WHERE
				IDPESQUISASATISFACAO = :cAuxidQuestionario
			AND
				IDPERGUNTA = :cAuxidPergunta;
				
		//Caso nao exista a relacao desta pergunta com o questionario, entao relaciona
		if( iCont < 0 )
		{
			EXEC SQL
				INSERT INTO
					CONTATOADM.PESQUISASATISFACAOPERGUNTA
					( PESQUISASATISFACAOPERGUNTA
					 ,IDPESQUISASATISFACAO
					 ,IDPERGUNTA
					 ,IDUSUARIOALTERACAO
					 ,DTULTIMAALTERACAO )
				VALUES
					( CONTATOADM.PESQUISASATISFACAOPERGUNTASQ.NEXTVAL
					 ,:cAuxidQuestionario
					 ,TRIM(:cAuxdsPergunta)
					 ,:cAuxidUser
					 ,SYSDATE );
		}
	}//if( strlennull( cAuxidQuestionario ) > 0 )
	
	ULOG_END("CPergunta::Update()");
	return 1;

GotoUpdate:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CPergunta::ListAll( void )
{
    ULOG_START("CPergunta::ListAll()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidPergunta[21+1];
			VARCHAR stidTipoApresentacaoPergunta[21+1];
			VARCHAR stsgTipoApresentacaoPergunta[255+1];
			VARCHAR stdsTipoApresentacaoPergunta[255+1];
			VARCHAR stdsPergunta[255+1];
			VARCHAR stinObrigatoria[21+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stsqApresentacao[21+1];
			VARCHAR stdsScriptPergunta[255+1];
			VARCHAR stinEncerramento[21+1];
		} stPerguntaRegistro;
		struct
		{
			short iidPergunta;
			short iidTipoApresentacaoPergunta;
			short isgTipoApresentacaoPergunta;
			short idsTipoApresentacaoPergunta;
			short idsPergunta;
			short iinObrigatoria;
			short iinDisponibilidade;
			short isqApresentacao;
			short idsScriptPergunta;
			short iinEncerramento;
		} stPerguntaIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraPergunta();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
	sqlca.sqlcode=0;

    /*
    EXEC SQL 
    DECLARE 
        CursorPerguntaAll CURSOR FOR
    SELECT 
        PERGUNTA.IDPERGUNTA, 
        PERGUNTA.IDTIPOAPRESENTACAOPERGUNTA, 
        PERGUNTA.SGTIPOAPRESENTACAOPERGUNTA, 
        PERGUNTA.DSTIPOAPRESENTACAOPERGUNTA, 
        PERGUNTA.DSPERGUNTA, 
        PERGUNTA.INOBRIGATORIA, 
        PERGUNTA.INDISPONIBILIDADE, 
        PERGUNTA.SQAPRESENTACAO, 
        PERGUNTA.DSSCRIPTPERGUNTA, 
        PERGUNTA.INENCERRAMENTO 
    FROM 
        QUESTIONARIO.PERGUNTAB01 PERGUNTA
    ORDER BY 
        PERGUNTA.SQAPRESENTACAO;
    */
    
    EXEC SQL 
    DECLARE 
        CursorPerguntaAll CURSOR FOR
    SELECT 
        PERGUNTA.IDPERGUNTA, 
        PERGUNTA.IDTIPOAPRESENTACAOPERGUNTA, 
        TIPOAPRESENTACAOPERGUNTA.SGTIPOAPRESENTACAOPERGUNTA, 
        TIPOAPRESENTACAOPERGUNTA.DSTIPOAPRESENTACAOPERGUNTA, 
        PERGUNTA.DSPERGUNTA, 
        PERGUNTA.INOBRIGATORIA, 
        PERGUNTA.INDISPONIBILIDADE, 
        PERGUNTA.SQAPRESENTACAO, 
        PERGUNTA.DSSCRIPTPERGUNTA, 
        PERGUNTA.INENCERRAMENTO 
    FROM 
        APOIO.TIPOAPRESENTACAOPERGUNTA TIPOAPRESENTACAOPERGUNTA ,
        QUESTIONARIO.PERGUNTA PERGUNTA
    WHERE 
        PERGUNTA.IDTIPOAPRESENTACAOPERGUNTA = TIPOAPRESENTACAOPERGUNTA.IDTIPOAPRESENTACAOPERGUNTA
    ORDER BY 
        PERGUNTA.SQAPRESENTACAO;
            
	EXEC SQL OPEN CursorPerguntaAll;

	if(sqlca.sqlcode)
	{
	    ULOG_END("CPergunta::ListAll()");
		return 0;
	}
	else
	{
		for(;;)
		{
			memset( &stPerguntaRegistro, 0, sizeof(stPerguntaRegistro) );
			EXEC SQL FETCH CursorPerguntaAll INTO :stPerguntaRegistro:stPerguntaIndicator;

			Add( "",
			     "",
			     (char*)stPerguntaRegistro.stidPergunta.arr, 
			     (char*)stPerguntaRegistro.stidTipoApresentacaoPergunta.arr,
			     (char*)stPerguntaRegistro.stsgTipoApresentacaoPergunta.arr,
			     (char*)stPerguntaRegistro.stdsTipoApresentacaoPergunta.arr,
			     (char*)stPerguntaRegistro.stdsPergunta.arr,
			     (char*)stPerguntaRegistro.stdsScriptPergunta.arr,
			     (char*)stPerguntaRegistro.stsqApresentacao.arr,
			     (char*)stPerguntaRegistro.stinEncerramento.arr,
			     (char*)stPerguntaRegistro.stinDisponibilidade.arr,
			     (char*)stPerguntaRegistro.stinObrigatoria.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorPerguntaAll;
	}
	
    ULOG_END("CPergunta::ListAll()");
	return iCont;

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CPergunta::ListId( char* cidPergunta )
{
    ULOG_START("CPergunta::ListId()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidPergunta = cidPergunta;
		struct
		{
			VARCHAR stidPergunta[21+1];
			VARCHAR stidTipoApresentacaoPergunta[21+1];
			VARCHAR stsgTipoApresentacaoPergunta[255+1];
			VARCHAR stdsTipoApresentacaoPergunta[255+1];
			VARCHAR stdsPergunta[255+1];
			VARCHAR stinObrigatoria[21+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stsqApresentacao[21+1];
			VARCHAR stdsScriptPergunta[255+1];
			VARCHAR stinEncerramento[21+1];
		} stPerguntaRegistro;
		struct
		{
			short iidPergunta;
			short iidTipoApresentacaoPergunta;
			short isgTipoApresentacaoPergunta;
			short idsTipoApresentacaoPergunta;
			short idsPergunta;
			short iinObrigatoria;
			short iinDisponibilidade;
			short isqApresentacao;
			short idsScriptPergunta;
			short iinEncerramento;
		} stPerguntaIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraPergunta();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
	sqlca.sqlcode=0;

   	/*
    EXEC SQL 
   		DECLARE 
   			CursorPerguntaId CURSOR FOR
		SELECT 
			PERGUNTA.IDPERGUNTA, 
		    PERGUNTA.IDTIPOAPRESENTACAOPERGUNTA, 
		    PERGUNTA.SGTIPOAPRESENTACAOPERGUNTA, 
		    PERGUNTA.DSTIPOAPRESENTACAOPERGUNTA, 
		    PERGUNTA.DSPERGUNTA, 
		    PERGUNTA.INOBRIGATORIA, 
		    PERGUNTA.INDISPONIBILIDADE, 
		    PERGUNTA.SQAPRESENTACAO, 
		    PERGUNTA.DSSCRIPTPERGUNTA, 
		    PERGUNTA.INENCERRAMENTO 
		FROM 
			QUESTIONARIO.PERGUNTAB01 PERGUNTA
		WHERE 
			PERGUNTA.IDPERGUNTA = :cAuxidPergunta;
    */
    
    EXEC SQL 
   		DECLARE 
   			CursorPerguntaId CURSOR FOR
		SELECT 
			PERGUNTA.IDPERGUNTA, 
		    PERGUNTA.IDTIPOAPRESENTACAOPERGUNTA, 
		    TIPOAPRESENTACAOPERGUNTA.SGTIPOAPRESENTACAOPERGUNTA, 
		    TIPOAPRESENTACAOPERGUNTA.DSTIPOAPRESENTACAOPERGUNTA, 
		    PERGUNTA.DSPERGUNTA, 
		    PERGUNTA.INOBRIGATORIA, 
		    PERGUNTA.INDISPONIBILIDADE, 
		    PERGUNTA.SQAPRESENTACAO, 
		    PERGUNTA.DSSCRIPTPERGUNTA, 
		    PERGUNTA.INENCERRAMENTO 
		FROM 
            APOIO.TIPOAPRESENTACAOPERGUNTA TIPOAPRESENTACAOPERGUNTA ,
            QUESTIONARIO.PERGUNTA PERGUNTA
        WHERE 
		    PERGUNTA.IDTIPOAPRESENTACAOPERGUNTA = TIPOAPRESENTACAOPERGUNTA.IDTIPOAPRESENTACAOPERGUNTA
		AND
			PERGUNTA.IDPERGUNTA = :cAuxidPergunta;
    
	EXEC SQL OPEN CursorPerguntaId;

	if(sqlca.sqlcode)
	{
	    ULOG_END("CPergunta::ListId()");
		return 0;
	}
	else
	{
		for(;;)
		{
			memset( &stPerguntaRegistro, 0, sizeof(stPerguntaRegistro) );
			EXEC SQL FETCH CursorPerguntaId INTO :stPerguntaRegistro:stPerguntaIndicator;

			Add( "",
			     "",
			     (char*)stPerguntaRegistro.stidPergunta.arr, 
			     (char*)stPerguntaRegistro.stidTipoApresentacaoPergunta.arr,
			     (char*)stPerguntaRegistro.stsgTipoApresentacaoPergunta.arr,
			     (char*)stPerguntaRegistro.stdsTipoApresentacaoPergunta.arr,
			     (char*)stPerguntaRegistro.stdsPergunta.arr,
			     (char*)stPerguntaRegistro.stdsScriptPergunta.arr,
			     (char*)stPerguntaRegistro.stsqApresentacao.arr,
			     (char*)stPerguntaRegistro.stinEncerramento.arr,
			     (char*)stPerguntaRegistro.stinDisponibilidade.arr,
			     (char*)stPerguntaRegistro.stinObrigatoria.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorPerguntaId;
	}
    ULOG_END("CPergunta::ListId()");
	return iCont;

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}


int CPergunta::ListIdPesquisa( char* cidPesquisa )
{
    ULOG_START("CPergunta::ListIdPesquisa()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidPesquisa = cidPesquisa;
		char  cAuxidPergunta[21+1];
		char  cAuxidPesquisaSatisfacao[21+1];
		struct
		{
			VARCHAR stidPesquisaSatisfacao[21+1];
			VARCHAR stnmPesquisaSatisfacao[255+1];
			VARCHAR stidTipoApresentacaoPergunta[21+1];
			VARCHAR stsgTipoApresentacaoPergunta[255+1];
			VARCHAR stdsTipoApresentacaoPergunta[255+1];
			VARCHAR stidPergunta[21+1];
			VARCHAR stdsPergunta[256+1];
			VARCHAR stinObrigatoria[21+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stsqApresentacao[21+1];
			VARCHAR stdsScriptPergunta[255+1];
			VARCHAR stinEncerramento[21+1];
			VARCHAR stidResposta[21+1];
			VARCHAR stdsResposta[256+1];
			VARCHAR stinDisponibilidadeResposta[21+1];
			VARCHAR stsqApresentacaoResposta[21+1];
			VARCHAR stdsScriptResposta[256+1];
			VARCHAR stinEncerramentoResposta[21+1];
			VARCHAR stidPerguntaSalto[21+1];
			VARCHAR stinAtivo[21+1];			
		} stPerguntaRegistro;
		struct
		{
			short iidPesquisaSatisfacao;
			short inmPesquisaSatisfacao;
			short iidTipoApresentacaoPergunta;
			short isgTipoApresentacaoPergunta;
			short idsTipoApresentacaoPergunta;
			short iidPergunta;
			short idsPergunta;
			short iinObrigatoria;
			short iinDisponibilidade;
			short isqApresentacao;
			short idsScriptPergunta;
			short iinEncerramento;
			short iidResposta;
			short idsResposta;
			short iinDisponibilidadeResposta;
			short isqApresentacaoResposta;
			short idsScriptResposta;
			short iinEncerramentoResposta;
			short iidPerguntaSalto;
			short iinAtivo;
		} stPerguntaIndicator;
		
	EXEC SQL END DECLARE SECTION;

	ZeraPergunta();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListIdPesquisa;
	sqlca.sqlcode=0;

   	/*
    EXEC SQL
   		DECLARE
   			CursorListIdPesquisa CURSOR FOR
		SELECT
			PESQUISA.IDPESQUISASATISFACAO,
			PESQUISA.NMPESQUISASATISFACAO,
			PESQUISA.IDTIPOAPRESENTACAOPERGUNTA,
			PESQUISA.SGTIPOAPRESENTACAOPERGUNTA,
			PESQUISA.DSTIPOAPRESENTACAOPERGUNTA,
			PESQUISA.IDPERGUNTA,
			PESQUISA.DSPERGUNTA,
			PESQUISA.INOBRIGATORIA,
			PESQUISA.INDISPONIBILIDADE,
			PESQUISA.SQAPRESENTACAO,
			PESQUISA.DSSCRIPTPERGUNTA,
			PESQUISA.INENCERRAMENTO,
			PESQUISA.IDRESPOSTA,
			PESQUISA.DSRESPOSTA,
			PESQUISA.INDISPONIBILIDADERESPOSTA,
			PESQUISA.SQAPRESENTACAORESPOSTA,
			PESQUISA.DSSCRIPTRESPOSTA,
			PESQUISA.INENCERRAMENTORESPOSTA,
			PESQUISA.IDPERGUNTASALTO,
			PESQUISA.INATIVO
		FROM
			QUESTIONARIO.PESQUISASATISFACAOV01 PESQUISA
		WHERE
			IDPESQUISASATISFACAO = :cAuxidPesquisa
        ORDER BY 
			SQAPRESENTACAO, IDPERGUNTA, SQAPRESENTACAORESPOSTA, IDRESPOSTA;
    */
    
    EXEC SQL
   		DECLARE
   			CursorListIdPesquisa CURSOR FOR
    SELECT
        PESQUISASATISFACAO.IDPESQUISASATISFACAO,
        PESQUISASATISFACAO.NMPESQUISASATISFACAO,
        TIPOAPRESENTACAOPERGUNTA.IDTIPOAPRESENTACAOPERGUNTA,
        TIPOAPRESENTACAOPERGUNTA.SGTIPOAPRESENTACAOPERGUNTA,
        TIPOAPRESENTACAOPERGUNTA.DSTIPOAPRESENTACAOPERGUNTA,
        PERGUNTA.IDPERGUNTA,
        PERGUNTA.DSPERGUNTA,
        PERGUNTA.INOBRIGATORIA,
        PERGUNTA.INDISPONIBILIDADE,
        PERGUNTA.SQAPRESENTACAO,
        PERGUNTA.DSSCRIPTPERGUNTA,
        PERGUNTA.INENCERRAMENTO,
        RESPOSTA.IDRESPOSTA,
        RESPOSTA.DSRESPOSTA,
        RESPOSTA.INDISPONIBILIDADE INDISPONIBILIDADERESPOSTA,
        RESPOSTA.SQAPRESENTACAO SQAPRESENTACAORESPOSTA,
        RESPOSTA.DSSCRIPTRESPOSTA,
        RESPOSTA.INENCERRAMENTO INENCERRAMENTORESPOSTA,
        SALTO.IDPERGUNTA IDPERGUNTASALTO,
        SALTO.INATIVO
    FROM 
        QUESTIONARIO.RESPOSTAPROXIMAPERGUNTA  SALTO,
        QUESTIONARIO.RESPOSTA                 RESPOSTA,
        QUESTIONARIO.PERGUNTA                 PERGUNTA,
        APOIO.TIPOAPRESENTACAOPERGUNTA        TIPOAPRESENTACAOPERGUNTA,
        CONTATOADM.PESQUISASATISFACAO         PESQUISASATISFACAO,
        CONTATOADM.PESQUISASATISFACAOPERGUNTA PESQUISASATISFACAOPERGUNTA
    WHERE 
        PESQUISASATISFACAO.IDPESQUISASATISFACAO = PESQUISASATISFACAOPERGUNTA.IDPESQUISASATISFACAO
    AND 
        PESQUISASATISFACAOPERGUNTA.IDPERGUNTA = PERGUNTA.IDPERGUNTA (+)
    AND 
        PERGUNTA.IDTIPOAPRESENTACAOPERGUNTA = TIPOAPRESENTACAOPERGUNTA.IDTIPOAPRESENTACAOPERGUNTA (+)
    AND 
        PERGUNTA.IDPERGUNTA = RESPOSTA.IDPERGUNTA (+)
    AND 
        RESPOSTA.IDRESPOSTA = SALTO.IDRESPOSTA(+)
    AND
        PESQUISASATISFACAO.IDPESQUISASATISFACAO = :cAuxidPesquisa
    ORDER BY 
        SQAPRESENTACAO, IDPERGUNTA, SQAPRESENTACAORESPOSTA, IDRESPOSTA;
    

	EXEC SQL OPEN CursorListIdPesquisa;

	if(sqlca.sqlcode)
	{
	    ULOG_END("CPergunta::ListIdPesquisa()");
		return 0;
	}
	else
	{
		memset( &cAuxidPergunta, 0, sizeof(cAuxidPergunta) );
		memset( &cAuxidPesquisaSatisfacao, 0, sizeof(cAuxidPesquisaSatisfacao) );

		for(;;)
		{
			memset( &stPerguntaRegistro, 0, sizeof(stPerguntaRegistro) );
			EXEC SQL FETCH CursorListIdPesquisa INTO :stPerguntaRegistro:stPerguntaIndicator;

			if( ( strcmp( (char*)stPerguntaRegistro.stidPergunta.arr, cAuxidPergunta ) != 0 )
			 || ( strcmp( (char*)stPerguntaRegistro.stidPesquisaSatisfacao.arr, cAuxidPesquisaSatisfacao ) != 0 ) )
			{
				Add( (char*)stPerguntaRegistro.stidPesquisaSatisfacao.arr, 
				     (char*)stPerguntaRegistro.stnmPesquisaSatisfacao.arr, 
				     (char*)stPerguntaRegistro.stidPergunta.arr, 
				     (char*)stPerguntaRegistro.stidTipoApresentacaoPergunta.arr,
				     (char*)stPerguntaRegistro.stsgTipoApresentacaoPergunta.arr,
				     (char*)stPerguntaRegistro.stdsTipoApresentacaoPergunta.arr,
				     (char*)stPerguntaRegistro.stdsPergunta.arr,
				     (char*)stPerguntaRegistro.stdsScriptPergunta.arr,
				     (char*)stPerguntaRegistro.stsqApresentacao.arr,
				     (char*)stPerguntaRegistro.stinEncerramento.arr,
				     (char*)stPerguntaRegistro.stinDisponibilidade.arr,
				     (char*)stPerguntaRegistro.stinObrigatoria.arr );
				     
				memset( &cAuxidPergunta, 0, sizeof(cAuxidPergunta) );
				strcpy( cAuxidPergunta, (char*)stPerguntaRegistro.stidPergunta.arr );

				memset( &cAuxidPesquisaSatisfacao, 0, sizeof(cAuxidPesquisaSatisfacao) );
				strcpy( cAuxidPesquisaSatisfacao, (char*)stPerguntaRegistro.stidPesquisaSatisfacao.arr );

				iCont++;
			}

			if( Quantidade() > 0 )
			{
				AddReposta( Quantidade(),
							(char*)stPerguntaRegistro.stidResposta.arr, 
				            (char*)stPerguntaRegistro.stidPergunta.arr,
				            (char*)stPerguntaRegistro.stdsResposta.arr,
				            (char*)stPerguntaRegistro.stdsScriptResposta.arr,
				            (char*)stPerguntaRegistro.stsqApresentacaoResposta.arr,
				            (char*)stPerguntaRegistro.stinEncerramentoResposta.arr,
				            (char*)stPerguntaRegistro.stinDisponibilidadeResposta.arr,
				            (char*)stPerguntaRegistro.stidPerguntaSalto.arr,
				            (char*)stPerguntaRegistro.stinAtivo.arr );
			}
		}
		EXEC SQL CLOSE CursorListIdPesquisa;
	}
    ULOG_END("CPergunta::ListIdPesquisa()");
	return iCont;

GotoListIdPesquisa:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CPergunta::GetXml( char* cNomeTag, XMLGen*xml )
{
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			if( Registro( x ) != NULL )
			{
				xml->addItem("idTipoApresentacaoPergunta" , Registro(x)->cidTipoApresentacaoPergunta );
				xml->addItem("dsTipoApresentacaoPergunta" , Registro(x)->csgTipoApresentacaoPergunta );
				xml->addItem("idPergunta"       , Registro(x)->cidPergunta );
				xml->addItem("dsPergunta"       , Registro(x)->cdsPergunta );
				xml->addItem("dsScriptPergunta" , Registro(x)->cdsScriptPergunta );
				xml->addItem("sqApresentacao"   , Registro(x)->csqApresentacao );
				xml->addItem("inEncerramento"   , Registro(x)->cinEncerramento );
				xml->addItem("inDisponibilidade", Registro(x)->cinDisponibilidade );
				xml->addItem("inObrigatoria"    , Registro(x)->cinObrigatoria );
				if( Registro(x)->pzResposta != NULL )
					Registro(x)->pzResposta->GetXml( "AdmRespostaVO", xml );
			}
			xml->closeTag();
		}
	}
}

int CPergunta::Delete( char* cidPergunta )
{
    ULOG_START("CPergunta::Delete()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidPergunta = cidPergunta;
	EXEC SQL END DECLARE SECTION;
	
	ZeraPergunta();
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
	sqlca.sqlcode=0;

	//Apaga a relacao da pergunta com pesquisa de satisfacao
	EXEC SQL
		DELETE FROM 
			CONTATOADM.PESQUISASATISFACAOPERGUNTA
		WHERE
			IDPERGUNTA = :cAuxidPergunta;

	//Apaga a pergunta
	EXEC SQL
		DELETE FROM 
			QUESTIONARIO.PERGUNTA
		WHERE
			IDPERGUNTA = :cAuxidPergunta;
			
    ULOG_END("CPergunta::Delete()");
	return 1;

GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if( sqlca.sqlcode == -2292 )
		return 0;
	else
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CPergunta::PerguntaTextoMemo( char* cidPergunta, char* cidTipoPergunta )
{
    ULOG_START("CPergunta::PerguntaTextoMemo()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidPerguntaAux     = cidPergunta;
		char* cidTipoPerguntaAux = cidTipoPergunta;
		int   iCont = 0;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoVerifcaTipoPergunta;
	sqlca.sqlcode=0;

	if( TemResposta( cidPergunta ) )
	{
		EXEC SQL 
		SELECT 
			COUNT(1)
		INTO
			:iCont
		FROM
			APOIO.TIPOAPRESENTACAOPERGUNTA
		WHERE
			IDTIPOAPRESENTACAOPERGUNTA = :cidTipoPerguntaAux
		AND
			SGTIPOAPRESENTACAOPERGUNTA IN ( 'MEM', 'TXT' );
	}
	ULOG_END("CPergunta::PerguntaTextoMemo()");
	return iCont;

GotoVerifcaTipoPergunta:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CPergunta::TemResposta( char* cidPergunta )
{
    ULOG_START("CPergunta::TemResposta()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidPerguntaAux     = cidPergunta;
		int   iCont = 0;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoTemResposta;
	sqlca.sqlcode=0;

	EXEC SQL
	SELECT
		COUNT(1)
	INTO
		:iCont
	FROM
		QUESTIONARIO.RESPOSTA
	WHERE
		IDPERGUNTA = :cidPerguntaAux;
		
    ULOG_END("CPergunta::TemResposta()");
	return iCont;

GotoTemResposta:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}
