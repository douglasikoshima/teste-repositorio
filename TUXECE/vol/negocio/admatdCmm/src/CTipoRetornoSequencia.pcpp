
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CTipoRetornoSequencia.h"

CTipoRetornoSequencia::CTipoRetornoSequencia()
{
}

CTipoRetornoSequencia::~CTipoRetornoSequencia()
{
}

bool CTipoRetornoSequencia::Existe( 
                                    char* cidContatoTipoRetorno,
                                    char* cidSequencia
                                  )
{
    ULOG_START("CTipoRetornoSequencia::Existe()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContatoTipoRetorno = cidContatoTipoRetorno;
		char* cAuxidSequencia = cidSequencia;
        int varOraCount;
	EXEC SQL END DECLARE SECTION;

	try
	{
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoExiste;

		EXEC SQL 
            SELECT
                COUNT(1)
            INTO
                :varOraCount
            FROM
                CONTATOADM.TIPORETORNOSEQUENCIA 
            WHERE
				IDCONTATOTIPORETORNO = :cAuxidContatoTipoRetorno
			AND IDSEQUENCIA = :cAuxidSequencia;

        ULOG_END("CTipoRetornoSequencia::Existe()");

		return varOraCount;
	}
	catch(...)
	{
		throw;
	}

GotoExiste:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CTipoRetornoSequencia::Insert( 
								char* cidContatoTipoRetorno,
								char* cidSequencia,
								char* cidUsuarioAlteracao
							 )
{
    ULOG_START("CTipoRetornoSequencia::Insert()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContatoTipoRetorno = cidContatoTipoRetorno;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
		char* cAuxidSequencia = cidSequencia;
	EXEC SQL END DECLARE SECTION;
	
    ULOG( "cAuxidContatoTipoRetorno [%s]", cAuxidContatoTipoRetorno );
    ULOG( "cAuxidUsuarioAlteracao   [%s]", cAuxidUsuarioAlteracao );
    ULOG( "cAuxidSequencia          [%s]", cAuxidSequencia );
    
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraTipoRetornoSequencia();
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
		
		//Realiza o insert
		EXEC SQL 
			INSERT INTO CONTATOADM.TIPORETORNOSEQUENCIA 
			(	IDTIPORETORNOSEQUENCIA,
				IDCONTATOTIPORETORNO,
				IDSEQUENCIA,
				IDUSUARIOALTERACAO,
				DTULTIMAALTERACAO
			)
			VALUES 
			(	CONTATOADM.TIPORETORNOSEQUENCIASQ.NEXTVAL,
				:cAuxidContatoTipoRetorno,
				:cAuxidSequencia,
				:cAuxidUsuarioAlteracao,
				SYSDATE
			);
        ULOG_END("CTipoRetornoSequencia::Insert()");
		return 0;//Sucesso
	}
	catch(...)
	{
		throw;
	}
	
GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CTipoRetornoSequencia::Update( 
								char* cidTipoRetornoSequencia,
								char* cidContatoTipoRetorno,
								char* cidSequencia,
								char* cidUsuarioAlteracao 
							 )
{
    ULOG_START("CTipoRetornoSequencia::Update()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidTipoRetornoSequencia = cidTipoRetornoSequencia;
		char* cAuxidContatoTipoRetorno = cidContatoTipoRetorno;
		char* cAuxidSequencia = cidSequencia;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraTipoRetornoSequencia();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
		
		//Executa a instrucao de update
		EXEC SQL 
			UPDATE CONTATOADM.TIPORETORNOSEQUENCIA 
			SET
				IDCONTATOTIPORETORNO = :cAuxidContatoTipoRetorno,
				IDSEQUENCIA = :cAuxidSequencia,
				IDUSUARIOALTERACAO = :cAuxidUsuarioAlteracao,
				DTULTIMAALTERACAO = SYSDATE
			WHERE
				IDTipoRetornoSequencia = :cAuxidTipoRetornoSequencia;
		
		ULOG_END("CTipoRetornoSequencia::Update()");
		return 0;
	}
	catch(...)
	{
		throw;
	}

GotoUpdate:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CTipoRetornoSequencia::Delete( char* cidTipoRetornoSequencia )
{
    ULOG_START("CTipoRetornoSequencia::Delete()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;	
		char* cAuxidTipoRetornoSequencia = cidTipoRetornoSequencia; 
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraTipoRetornoSequencia();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
		sqlca.sqlcode=0;
		
		//Executa a instrucao de delecao
		EXEC SQL 
			DELETE FROM 
				CONTATOADM.TIPORETORNOSEQUENCIA 		
			WHERE 
				IDTIPORETORNOSEQUENCIA = :cAuxidTipoRetornoSequencia;
		ULOG_END("CTipoRetornoSequencia::Delete()");
		return 0;//Sucesso
	}
	catch(...)
	{
		throw;
	}

GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if( sqlca.sqlcode == -2292 )
		return 1;
	else
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CTipoRetornoSequencia::ListId( char* cidTipoRetornoSequencia ) 
{
    ULOG_END("CTipoRetornoSequencia::ListId()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidTipoRetornoSequencia = cidTipoRetornoSequencia; 
		struct
		{
			VARCHAR stidTipoRetornoSequencia[21+1];
			VARCHAR stidContatoTipoRetorno[21+1];
			VARCHAR stidSequencia[21+1];
		} stTipoRetornoSequenciaRegistro;
		struct
		{
			short iidTipoRetornoSequencia;
			short iidContatoTipoRetorno;
			short iidSequencia;
		} stTipoRetornoSequenciaIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraTipoRetornoSequencia();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorTipoRetornoSequenciaId CURSOR FOR 
   			SELECT 	
   				IDTIPORETORNOSEQUENCIA,
				IDCONTATOTIPORETORNO,
				IDSEQUENCIA
			FROM 
				CONTATOADM.TIPORETORNOSEQUENCIA
			WHERE 
				IDTIPORETORNOSEQUENCIA = :cAuxidTipoRetornoSequencia;

		//Abre o cursor
		EXEC SQL OPEN CursorTipoRetornoSequenciaId;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stTipoRetornoSequenciaRegistro, 0, sizeof(stTipoRetornoSequenciaRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorTipoRetornoSequenciaId INTO :stTipoRetornoSequenciaRegistro:stTipoRetornoSequenciaIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stTipoRetornoSequenciaRegistro.stidTipoRetornoSequencia.arr,
				(char*)stTipoRetornoSequenciaRegistro.stidContatoTipoRetorno.arr, 
				(char*)stTipoRetornoSequenciaRegistro.stidSequencia.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorTipoRetornoSequenciaId;
		
		ULOG_END("CTipoRetornoSequencia::ListId()");

	}
	catch(...)
	{
		throw;
	}

	//Retorna a quantidade de registros
	return iCont;
GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CTipoRetornoSequencia::ListIdContato( char* cidContato )
{
    ULOG_START("CTipoRetornoSequencia::ListIdContato()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
		struct
		{
			VARCHAR stidTipoRetornoSequencia[21+1];
			VARCHAR stidContatoTipoRetorno[21+1];
			VARCHAR stidSequencia[21+1];
			VARCHAR stidContato[21+1];
			VARCHAR stidTipoSequencia[21+1];
			VARCHAR stidGrupo[21+1];
			VARCHAR stidTipoRetornoContato[21+1];
		} stTipoRetornoSequenciaRegistro;
		struct
		{
			short iidTipoRetornoSequencia;
			short IidContatoTipoRetorno;
			short iidSequencia;
			short iidContato;
			short iidTipoSequencia;
			short iidGrupo;
			short iidTipoRetornoContato;
		} stTipoRetornoSequenciaIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraTipoRetornoSequencia();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListIdContato;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorListIdContato CURSOR FOR 
   			SELECT 	
   				TIPORETORNOSEQUENCIA.IDTIPORETORNOSEQUENCIA,
   				TIPORETORNOSEQUENCIA.IDCONTATOTIPORETORNO,
				TIPORETORNOSEQUENCIA.IDSEQUENCIA,
				CONTATOGRUPO.IDCONTATO,
				SEQUENCIA.IDTIPOSEQUENCIA,
				CONTATOGRUPO.IDGRUPO,
				CONTATOTIPORETORNO.IDTIPORETORNOCONTATO
			FROM 
				CONTATOADM.TIPORETORNOSEQUENCIA TIPORETORNOSEQUENCIA,
                CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO,
                CONTATOADM.SEQUENCIA SEQUENCIA,
                CONTATOADM.CONTATOGRUPO CONTATOGRUPO
			WHERE 
                TIPORETORNOSEQUENCIA.IDCONTATOTIPORETORNO = CONTATOTIPORETORNO.IDCONTATOTIPORETORNO
            AND
                TIPORETORNOSEQUENCIA.IDSEQUENCIA = SEQUENCIA.IDSEQUENCIA
            AND
                SEQUENCIA.IDCONTATOGRUPO = CONTATOGRUPO.IDCONTATOGRUPO
            AND
				CONTATOGRUPO.IDCONTATO = :cAuxidContato;
				
		//Abre o cursor
		EXEC SQL OPEN CursorListIdContato;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stTipoRetornoSequenciaRegistro, 0, sizeof(stTipoRetornoSequenciaRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListIdContato INTO :stTipoRetornoSequenciaRegistro:stTipoRetornoSequenciaIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stTipoRetornoSequenciaRegistro.stidTipoRetornoSequencia.arr,
				(char*)stTipoRetornoSequenciaRegistro.stidContatoTipoRetorno.arr, 
				(char*)stTipoRetornoSequenciaRegistro.stidSequencia.arr,
				(char*)stTipoRetornoSequenciaRegistro.stidContato.arr, 
				(char*)stTipoRetornoSequenciaRegistro.stidTipoSequencia.arr,
				(char*)stTipoRetornoSequenciaRegistro.stidGrupo.arr,
				(char*)stTipoRetornoSequenciaRegistro.stidTipoRetornoContato.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListIdContato;

        ULOG_END("CTipoRetornoSequencia::ListIdContato()");
	}
	catch(...)
	{
		throw;
	}

	//Retorna a quantidade de registros
	return iCont;
GotoListIdContato:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CTipoRetornoSequencia::ListAll( void )
{
    ULOG_START("CTipoRetornoSequencia::ListAll()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidTipoRetornoSequencia[21+1];
			VARCHAR stidContatoTipoRetorno[21+1];
			VARCHAR stidSequencia[21+1];
		} stTipoRetornoSequenciaRegistro;
		struct
		{
			short iidTipoRetornoSequencia;
			short IidContatoTipoRetorno;
			short iidSequencia;
		} stTipoRetornoSequenciaIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraTipoRetornoSequencia();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL DECLARE CursorTipoRetornoSequenciaAll CURSOR FOR
   			SELECT 	
   				IDTIPORETORNOSEQUENCIA,
				IDCONTATOTIPORETORNO,
				IDSEQUENCIA
			FROM 
				CONTATOADM.TIPORETORNOSEQUENCIA
			WHERE
				IDTIPORETORNOSEQUENCIA > 0; 

		//Abre o cursor
		EXEC SQL OPEN CursorTipoRetornoSequenciaAll;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stTipoRetornoSequenciaRegistro, 0, sizeof(stTipoRetornoSequenciaRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorTipoRetornoSequenciaAll INTO :stTipoRetornoSequenciaRegistro:stTipoRetornoSequenciaIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stTipoRetornoSequenciaRegistro.stidTipoRetornoSequencia.arr,
				(char*)stTipoRetornoSequenciaRegistro.stidContatoTipoRetorno.arr, 
				(char*)stTipoRetornoSequenciaRegistro.stidSequencia.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o cursor
		EXEC SQL CLOSE CursorTipoRetornoSequenciaAll;
		
	}
	catch(...)
	{
		throw;
	}
	
	ULOG_END("CTipoRetornoSequencia::ListAll()");
	//Retorna a quantidade de registros
	return iCont;

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CTipoRetornoSequencia::GetXml( char* cNomeTag, XMLGen*xml )
{
    
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
				xml->createTag(cNomeTag);
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idTipoRetornoSequencia", Registro(x)->cidTipoRetornoSequencia );
				xml->addItem("idContatoTipoRetorno", Registro(x)->cidContatoTipoRetorno ); 
				xml->addItem("idSequencia", Registro(x)->cidSequencia ); 
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}
