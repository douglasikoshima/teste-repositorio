// Endereco.cpp: implementation of the CEndereco class.
//
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>

#include <Endereco/Endereco.hpp>



EXEC SQL INCLUDE SQLCA;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEndereco::CEndereco()
	: m_iIdTipoEndereco( -1 )
{
	strcpy( this->m_cNmTipoLogradouro, "" );
	strcpy( this->m_cNmTituloLogradouro, "" );
	strcpy( this->m_cNmLogradouro, "" );
	strcpy( this->m_cNrEndereco, "" );
	strcpy( this->m_cDsEnderecoComplemento, "" );
	strcpy( this->m_cNmBairro, "" );
	strcpy( this->m_cNrCep, "" );
	strcpy( this->m_cNmMunicipio, "" );
	strcpy( this->m_cDsTipoEndereco, "" );
	strcpy( this->m_cSgTipoEndereco, "" );
	strcpy( this->m_iTsSinc, "" );
	this->m_iIdUf = -1;
	this->m_iIdConta = -1;
	this->m_iIdPessoaEndereco = -1;
	this->m_iIdSistemaOrigem = -1;
	this->m_iIdTipoEnderecoCobranca = -1;

	memset(&this->m_iQuantTipo, 0, sizeof(this->m_iQuantTipo));
}
/*
CEndereco::CEndereco( const CEndereco & value )
	: m_iIdTipoEndereco( value.m_iIdTipoEndereco )
{
	strcpy( this->m_cNmTipoLogradouro, value.m_cNmTipoLogradouro );
	strcpy( this->m_cNmTituloLogradouro, value.m_cNmTituloLogradouro );
	strcpy( this->m_cNmLogradouro, value.m_cNmLogradouro );
	strcpy( this->m_cNrEndereco, value.m_cNrEndereco );
	strcpy( this->m_cDsEnderecoComplemento, value.m_cDsEnderecoComplemento );
	strcpy( this->m_cNmBairro, value.m_cNmBairro );
	strcpy( this->m_cNrCep, value.m_cNrCep );
	strcpy( this->m_cNmMunicipio, value.m_cNmMunicipio );
	strcpy( this->m_cDsTipoEndereco, value.m_cDsTipoEndereco );
	strcpy( this->m_cSgTipoEndereco, value.m_cSgTipoEndereco );
	strcpy( this->m_iTsSinc, value.m_iTsSinc );
	this->m_iIdUf = value.m_iIdUf;
	this->m_iIdConta = value.m_iIdConta;
	this->m_iIdPessoaEndereco = value.m_iIdPessoaEndereco;
	this->getListaContas() = value.getListaContas();
}

CEndereco & CEndereco::operator =( const CEndereco & value ) {
	this->m_iIdTipoEndereco = value.m_iIdTipoEndereco;
	this->m_iIdUf = value.m_iIdUf;
	strcpy( this->m_iTsSinc, value.m_iTsSinc );
	strcpy( this->m_cNmTipoLogradouro, value.m_cNmTipoLogradouro );
	strcpy( this->m_cNmTituloLogradouro, value.m_cNmTituloLogradouro );
	strcpy( this->m_cNmLogradouro, value.m_cNmLogradouro );
	strcpy( this->m_cNrEndereco, value.m_cNrEndereco );
	strcpy( this->m_cDsEnderecoComplemento, value.m_cDsEnderecoComplemento );
	strcpy( this->m_cNmBairro, value.m_cNmBairro );
	strcpy( this->m_cNrCep, value.m_cNrCep );
	strcpy( this->m_cNmMunicipio, value.m_cNmMunicipio );
	strcpy( this->m_cDsTipoEndereco, value.m_cDsTipoEndereco );
	strcpy( this->m_cSgTipoEndereco, value.m_cSgTipoEndereco );
	this->m_iIdConta = value.m_iIdConta;
	this->m_iIdPessoaEndereco = value.m_iIdPessoaEndereco;
	this->getListaContas() = value.getListaContas();

	return *this;
}
*/

CEndereco::~CEndereco() {
}

/*

  GETs

*/

int CEndereco::getIdTipoEndereco() {
	return this->m_iIdTipoEndereco;
}

int CEndereco::getIdSistemaOrigem() {
	return this->m_iIdSistemaOrigem;
}

char * CEndereco::getNmTipoLogradouro() {
	return this->m_cNmTipoLogradouro;
}

char * CEndereco::getNmTituloLogradouro() {
	return this->m_cNmTituloLogradouro;
}

char * CEndereco::getNmLogradouro() {
	return this->m_cNmLogradouro;
}

char * CEndereco::getNrEndereco() {
	return this->m_cNrEndereco;
}

char * CEndereco::getDsEnderecoComplemento() {
	return this->m_cDsEnderecoComplemento;
}

char * CEndereco::getNmBairro() {
	return this->m_cNmBairro;
}

char * CEndereco::getNrCep() {
	return this->m_cNrCep;
}

char * CEndereco::getNmMunicipio() {
	return this->m_cNmMunicipio;
}

char * CEndereco::getSgTipoEndereco(){
	return this->m_cSgTipoEndereco;
}
char * CEndereco::getDsTipoEndereco(){
	return this->m_cDsTipoEndereco;
}
int CEndereco::getIdUf(){
	return this->m_iIdUf;
}
int CEndereco::getIdConta(){
	return this->m_iIdConta;
}
long CEndereco::getIdPessoaEndereco(){
	return this->m_iIdPessoaEndereco;
}


char * CEndereco::getTsSinc(){
	return this->m_iTsSinc;
} 

list <CConta> & CEndereco::getListaContas()
{
	return this->listaConta;
}

int CEndereco::getIdTipoEnderecoCobranca()
{
	return this->m_iIdTipoEnderecoCobranca;
}

char * CEndereco::getSgTipoEnderecoCobranca()
{
	return this->m_cSgTipoEnderecoCobranca;
}

char * CEndereco::getDsTipoEnderecoCobranca()
{
	return this->m_cDsTipoEnderecoCobranca;
}

int CEndereco::getIdTipoComplemento()
{
	return this->m_iIdTipoComplemento;
}

char * CEndereco::getSgTipoComplemento()
{
	return this->m_cSgTipoComplemento;
}

char * CEndereco::getDsTipoComplemento()
{
	return this->m_cDsTipoComplemento;
}

int CEndereco::getQuantTipo(int iTipoEndereco)
{
	if(iTipoEndereco >= MAX_TIPO)
		return 0;

	return this->m_iQuantTipo[iTipoEndereco];
}

/*
 
   SETs

*/

void CEndereco::setIdTipoEndereco( int value ) {
	this->m_iIdTipoEndereco = value;
}

void CEndereco::setIdSistemaOrigem( int value ) {
	this->m_iIdSistemaOrigem = value;
}

void CEndereco::setNmTipoLogradouro( char * value ) {
	strcpy( this->m_cNmTipoLogradouro, value );
}

void CEndereco::setNmTituloLogradouro( char * value ) {
	strcpy( this->m_cNmTituloLogradouro, value );
}

void CEndereco::setNmLogradouro( char * value ) {
	strcpy( this->m_cNmLogradouro, value );
}

void CEndereco::setNrEndereco( char * value ) {
	strcpy( this->m_cNrEndereco, value );
}

void CEndereco::setDsEnderecoComplemento( char * value ) {
	strcpy( this->m_cDsEnderecoComplemento, value );
}

void CEndereco::setNmBairro( char * value ) {
	strcpy( this->m_cNmBairro, value );
}

void CEndereco::setNrCep( char * value ) {
	strcpy( this->m_cNrCep, value );
}

void CEndereco::setNmMunicipio( char * value ) {
	strcpy( this->m_cNmMunicipio, value );
}

void CEndereco::setSgTipoEndereco(char * value){
	strcpy( this->m_cSgTipoEndereco, value );
}
void CEndereco::setDsTipoEndereco(char * value){
	strcpy( this->m_cDsTipoEndereco, value );
}

void CEndereco::setIdUf(int value){
	this->m_iIdUf = value ;
}

void CEndereco::setIdConta(int value){
	this->m_iIdConta = value ;
}
void CEndereco::setIdPessoaEndereco(long value){
	this->m_iIdPessoaEndereco = value ;
}


void CEndereco::setTsSinc( char * value ){
	strcpy( this->m_iTsSinc, value );		
} 

void CEndereco::setIdTipoEnderecoCobranca(int   value)
{
	this->m_iIdTipoEnderecoCobranca = value;
}

void CEndereco::setSgTipoEnderecoCobranca(char *value)
{
	strcpy(this->m_cSgTipoEnderecoCobranca, value);
}

void CEndereco::setDsTipoEnderecoCobranca(char *value)
{
	strcpy(this->m_cDsTipoEnderecoCobranca, value);
}

void CEndereco::setIdTipoComplemento(int   value)
{
	this->m_iIdTipoComplemento = value;
}

void CEndereco::setSgTipoComplemento(char *value)
{
	strcpy(this->m_cSgTipoComplemento, value);
}

void CEndereco::setDsTipoComplemento(char *value)
{
	strcpy(this->m_cDsTipoComplemento, value);
}

void CEndereco::incQuantTipo(int iTipoEndereco)
{
	if(iTipoEndereco >= MAX_TIPO)
		return;

	this->m_iQuantTipo[iTipoEndereco] ++;
}

//Metodos de Negocio da Interface da Classe CEndereco:

void CEndereco::alterarEndereco(long iIdPessoa) {

	long iIdPessoaEnderecoAnterior;
	long iIdPessoaEnderecoAtual;

	iIdPessoaEnderecoAnterior = this->getIdPessoaEndereco();

	this->inserirEndereco(iIdPessoa);
	
	iIdPessoaEnderecoAtual = this->getIdPessoaEndereco();

	this->setIdPessoaEndereco(iIdPessoaEnderecoAnterior);

	// se o não sobrou nenhuma conta atrelada ao endereco
	if(this->verificarEnderecoContaDB() == 0)
		// exclui
		this->excluirEndereco();

	this->setIdPessoaEndereco(iIdPessoaEnderecoAtual);

}

void CEndereco::inserirEndereco( long iIdPessoa ) {
	 this->inserirDadosEnderecoDB( iIdPessoa );
	 this->associarContasDB();
}

void CEndereco::associarContas() 
{
	this->associarContasDB();
}

void CEndereco::consultarEndereco( long iIdPessoa ) {
	 this->carregarDadosEnderecoDB( iIdPessoa );
}

void CEndereco::consultarEnderecoCobranca( long iIdPessoa ) {
	 this->carregarDadosEnderecoCobrancaDB( iIdPessoa );
}

void CEndereco::excluirEndereco()
{
	this->excluirEnderecoDB();
}

void CEndereco::consultarTipoEnd(list < CEndereco > & listaEnd ){

	CEndereco::carregarTipoEnderecoDB( listaEnd );

}

void CEndereco::consultarTipoEndCobranca(list < CEndereco > & listaEndCobranca ){

	CEndereco::carregarTipoEnderecoCobrancaDB( listaEndCobranca );

}

void CEndereco::consultarTipoComplemento(list < CEndereco > & listaComplemento ){

	CEndereco::carregarTipoComplementoDB( listaComplemento );

}

// METODOS PRIVATE

void CEndereco::alterarDadosEnderecoDB( long iIdPessoa ) {

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		long  iIdPessoaAux;
		int  iIdTipoEndereco;
		char cNmTipoLogradouro[ 256 ];
		char cNmTituloLogradouro[ 256 ];
		char cNmLogradouro[ 256 ];
		char cNrEndereco[ 256 ];
		char cDsEnderecoComplemento[ 256 ];
		char cNmBairro[ 256 ];
		char cNrCep[ 256 ];
		char cNmMunicipio[ 256 ];
		int iIdUf;
		long iIdPessoaEndereco=0;
 	EXEC SQL END DECLARE SECTION;

	iIdPessoaAux = iIdPessoa;
	iIdUf = getIdUf();
	iIdTipoEndereco = this->m_iIdTipoEndereco;
	strcpy( cNmTipoLogradouro, this->m_cNmTipoLogradouro );
	strcpy( cNmTituloLogradouro, this->m_cNmTituloLogradouro );
	strcpy( cNmLogradouro, this->m_cNmLogradouro );
	strcpy( cNrEndereco, this->m_cNrEndereco );
	strcpy( cDsEnderecoComplemento, this->m_cDsEnderecoComplemento );
	strcpy( cNmBairro, this->m_cNmBairro );
	strcpy( cNrCep, this->m_cNrCep );
	strcpy( cNmMunicipio, this->m_cNmMunicipio );

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL SELECT
		idPessoaEndereco
	INTO
		:iIdPessoaEndereco
	FROM
		customer.PessoaEndereco
	WHERE
		idPessoa		= :iIdPessoaAux
	and idTipoEndereco	= :iIdTipoEndereco
	and	rownum			= 1;		


	EXEC SQL UPDATE
		customer.PessoaEndereco
	SET
		nmTipoLogradouro = :cNmTipoLogradouro
		, nmTituloLogradouro = :cNmTituloLogradouro
		, nmLogradouro = :cNmLogradouro
		, nrEndereco = :cNrEndereco
		, dsEnderecoComplemento = :cDsEnderecoComplemento
		, nmBairro = :cNmBairro
		, nrCep = :cNrCep
		, nmMunicipio = :cNmMunicipio
		, IDUF = :iIdUf
	WHERE
		idPessoa = :iIdPessoaAux
		and idTipoEndereco = :iIdTipoEndereco;

	if (sqlca.sqlerrd[2] == 0 ){ 
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	this->setIdPessoaEndereco(iIdPessoaEndereco);

	return;
	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode );

}
void CEndereco::inserirDadosEnderecoDB( long iIdPessoa ) {

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	long iIdPessoaAux;
	int  iIdTipoEndereco;		
	char cNmTipoLogradouro[ 256 ];
	char cNmTituloLogradouro[ 256 ];
	char cNmLogradouro[ 256 ];
	char cNrEndereco[ 256 ];
	char cDsEnderecoComplemento[ 256 ];
	char cNmBairro[ 256 ];
	char cNrCep[ 256 ];
	char cNmMunicipio[ 256 ];
	int  iIdUf;
	long iIdPessoaEndereco=0;
	int  iIdSistemaOrigem = ID_SISTEMA_ORIGEM_VOL;
 	EXEC SQL END DECLARE SECTION;

	iIdPessoaAux = iIdPessoa;
	iIdUf = getIdUf();
	iIdTipoEndereco = this->m_iIdTipoEndereco;
	strcpy( cNmTipoLogradouro, this->m_cNmTipoLogradouro );
	strcpy( cNmTituloLogradouro, this->m_cNmTituloLogradouro );
	strcpy( cNmLogradouro, this->m_cNmLogradouro );
	strcpy( cNrEndereco, this->m_cNrEndereco );
	strcpy( cDsEnderecoComplemento, this->m_cDsEnderecoComplemento );
	strcpy( cNmBairro, this->m_cNmBairro );
	strcpy( cNrCep, this->m_cNrCep );
	strcpy( cNmMunicipio, this->m_cNmMunicipio );

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;		

	EXEC SQL 
		SELECT 
			customer.pessoaenderecoSQ.NEXTVAL 
		INTO
			:iIdPessoaEndereco
		FROM 
			dual;


	EXEC SQL INSERT INTO 
		customer.PessoaEndereco
		(
			IDPESSOAENDERECO,
			IDPESSOA,
			IDPAIS,
			IDTIPOENDERECO,
			IDUF,
			IDSISTEMAORIGEM,
			nmTipoLogradouro,
			nmTituloLogradouro,
			nmLogradouro,
			nrEndereco,
			dsEnderecoComplemento,
			nmBairro,
			nrCep,
			nmMunicipio,
			idEnderecoSistemaOrigem
		)
		VALUES
		(
			:iIdPessoaEndereco,
			:iIdPessoaAux,
			'1',
			:iIdTipoEndereco,
			:iIdUf,
			:iIdSistemaOrigem,
			:cNmTipoLogradouro,
			:cNmTituloLogradouro,
			:cNmLogradouro,
			:cNrEndereco,
			:cDsEnderecoComplemento,
			:cNmBairro,
			:cNrCep,
			:cNmMunicipio,
			:iIdPessoaEndereco
		);

	//Verifica se houve ou nao erro ORACLE
	if (sqlca.sqlcode)
	{ 
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	this->setIdPessoaEndereco(iIdPessoaEndereco);

	return;

	sqlErrorConstrutor:
			throw TuxBasicOraException( sqlca.sqlcode );

}

void CEndereco::carregarDadosEnderecoDB( long iIdPessoa ) {
	 
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;	
	long iIdPessoaDB;
	int  iIdTipoEnderecoDB;
	char cNmTipoLogradouro[ 256 ];
	char cNmTituloLogradouro[ 256 ];
	char cNmLogradouro[ 256 ];
	char cNrEndereco[ 256 ];
	char cDsEnderecoComplemento[ 256 ];
	char cNmBairro[ 256 ];
	char cNrCep[ 256 ];
	char cNmMunicipio[ 256 ];
	int iIdUf;
	char cTsSinc[50];
	EXEC SQL END DECLARE SECTION;
		
	// valores das chaves da consulta SQL
    iIdPessoaDB = iIdPessoa;
	iIdTipoEnderecoDB = this->getIdTipoEndereco();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
	
	EXEC SQL SELECT 
		NVL(nmTipoLogradouro, ' ') as nmTipoLogradouro,
		NVL(nmTituloLogradouro, ' ') as nmTituloLogradouro,
		NVL(nmLogradouro, ' ') as nmLogradouro,
		NVL(nrEndereco, ' ') as nrEndereco,
		NVL(dsEnderecoComplemento, ' ') as dsEnderecoComplemento,
		NVL(nmBairro, ' ') as nmBairro,
		NVL(nrCep, ' ') as  nrCep,
		NVL(nmMunicipio, ' ') as nmMunicipio,
		IDUF,
		NVL(to_char(TSSINCRONISMO, '9999999999999999999999'), '0' )
	INTO
		:cNmTipoLogradouro,
		:cNmTituloLogradouro,
		:cNmLogradouro,
		:cNrEndereco, 
		:cDsEnderecoComplemento, 
		:cNmBairro, 
		:cNrCep, 
		:cNmMunicipio,
		:iIdUf,
		:cTsSinc
	FROM
		customer.PessoaEndereco
	WHERE
		idPessoa = :iIdPessoaDB AND
		idTipoEndereco = :iIdTipoEnderecoDB;
		
	// Endereço não existe
	if (sqlca.sqlcode == NO_DATA_FOUND) {
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	this->setNmTipoLogradouro( CUtil::trim(cNmTipoLogradouro) );
	this->setNmTituloLogradouro( CUtil::trim(cNmTituloLogradouro) );
	this->setNmLogradouro( CUtil::trim(cNmLogradouro) );
	this->setNrEndereco( CUtil::trim(cNrEndereco) ); 
	this->setDsEnderecoComplemento( CUtil::trim(cDsEnderecoComplemento) ); 
	this->setNmBairro( CUtil::trim(cNmBairro) ); 
	this->setNrCep( CUtil::trim(cNrCep) ); 
	this->setNmMunicipio( CUtil::trim(cNmMunicipio) ); 
	this->setIdUf( iIdUf ); 
	this->setTsSinc( CUtil::trim(cTsSinc) ); 

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 
}

//Carrega os dados do endereço de cobrança considerando a tabela customer.contaEndereco e apoio.tipoEnderecoCobranca.
void CEndereco::carregarDadosEnderecoCobrancaDB( long iIdPessoa ) {
	 
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;	
	long  iIdPessoaDB;
	int  iIdTipoEnderecoDB;
	int  iIdContaDB;
	char cNmTipoLogradouro[ 256 ];
	char cNmTituloLogradouro[ 256 ];
	char cNmLogradouro[ 256 ];
	char cNrEndereco[ 256 ];
	char cDsEnderecoComplemento[ 256 ];
	char cNmBairro[ 256 ];
	char cNrCep[ 256 ];
	char cNmMunicipio[ 256 ];
	int iIdUf;
	char cTsSinc[50];
	int iIdTipoEnderecoCobrancaDB;
	int iIdTipoEnderecoCobrancaDefaultDB;
	int iIdTipoEnderecoCobrancaRemittaDB;
	long iIdPessoaEndereco;
	EXEC SQL END DECLARE SECTION;
		
	// valores das chaves da consulta SQL
    iIdPessoaDB = iIdPessoa;
	iIdTipoEnderecoDB = this->getIdTipoEndereco();
	iIdContaDB = this->getIdConta();
	iIdTipoEnderecoCobrancaDefaultDB = ID_TIPO_ENDERECO_COBRANCA_DEFAULT;
	iIdTipoEnderecoCobrancaRemittaDB = ID_TIPO_ENDERECO_COBRANCA_REMITTANCE;

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL SELECT
		a.idPessoaEndereco
	INTO
		:iIdPessoaEndereco
	FROM
		customer.PessoaEndereco	a,
		customer.ContaEndereco	b
	WHERE
		a.idPessoaEndereco			 = b.idPessoaEndereco 
	AND	a.idPessoa					 = :iIdPessoaDB 
	AND	a.idTipoEndereco			 = :iIdTipoEnderecoDB
	AND b.idConta					 = :iIdContaDB
	AND	b.idTipoEnderecoCobranca     = :iIdTipoEnderecoCobrancaRemittaDB;

	if (sqlca.sqlcode == NO_DATA_FOUND) 
		iIdTipoEnderecoCobrancaDB = iIdTipoEnderecoCobrancaDefaultDB;
	else
		iIdTipoEnderecoCobrancaDB = iIdTipoEnderecoCobrancaRemittaDB;
		

	EXEC SQL SELECT 
		NVL(a.nmTipoLogradouro, ' ') as nmTipoLogradouro,
		NVL(a.nmTituloLogradouro, ' ') as nmTituloLogradouro,
		NVL(a.nmLogradouro, ' ') as nmLogradouro,
		NVL(a.nrEndereco, ' ') as nrEndereco,
		NVL(a.dsEnderecoComplemento, ' ') as dsEnderecoComplemento,
		NVL(a.nmBairro, ' ') as nmBairro,
		NVL(a.nrCep, ' ') as  nrCep,
		NVL(a.nmMunicipio, ' ') as nmMunicipio,
		a.IDUF,
		NVL(to_char(a.TSSINCRONISMO, '9999999999999999999999'), '0' )
	INTO
		:cNmTipoLogradouro,
		:cNmTituloLogradouro,
		:cNmLogradouro,
		:cNrEndereco, 
		:cDsEnderecoComplemento, 
		:cNmBairro, 
		:cNrCep, 
		:cNmMunicipio,
		:iIdUf,
		:cTsSinc
	FROM
		customer.PessoaEndereco	a,
		customer.ContaEndereco	b
	WHERE
		a.idPessoaEndereco			 = b.idPessoaEndereco 
	AND	a.idPessoa					 = :iIdPessoaDB 
	AND	a.idTipoEndereco			 = :iIdTipoEnderecoDB
	AND b.idConta   				 = :iIdContaDB
	AND	b.idTipoEnderecoCobranca     = :iIdTipoEnderecoCobrancaDB
	AND ROWNUM						 = 1;
		
	// Endereço não existe
	if (sqlca.sqlcode == NO_DATA_FOUND) {
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	this->setNmTipoLogradouro( CUtil::trim(cNmTipoLogradouro) );
	this->setNmTituloLogradouro( CUtil::trim(cNmTituloLogradouro) );
	this->setNmLogradouro( CUtil::trim(cNmLogradouro) );
	this->setNrEndereco( CUtil::trim(cNrEndereco) ); 
	this->setDsEnderecoComplemento( CUtil::trim(cDsEnderecoComplemento) ); 
	this->setNmBairro( CUtil::trim(cNmBairro) ); 
	this->setNrCep( CUtil::trim(cNrCep) ); 
	this->setNmMunicipio( CUtil::trim(cNmMunicipio) ); 
	this->setIdUf( iIdUf ); 
	this->setTsSinc( CUtil::trim(cTsSinc) ); 

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 
}

void CEndereco::excluirEnderecoDB()
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;	
	long iIdPessoaEndereco;
	EXEC SQL END DECLARE SECTION;

	iIdPessoaEndereco = this->getIdPessoaEndereco();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER NOT FOUND GOTO sqlErrorConstrutor;

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL
		UPDATE
			customer.PessoaEndereco
		SET
			dtExpiracao = SYSDATE
		WHERE
			idPessoaEndereco = :iIdPessoaEndereco;	

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 
}


//Atualiza (insert ou update) a tabela customer.contaEndereco com o endereco de cobranca
void CEndereco::atualizarContaEndereco(void) {
	 
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;	
	long iIdPessoaEndereco;
	long iIdPessoaEnderecoAnterior=0;
	int iIdConta;
	int iIdTipoEnderecoCobranca;
	EXEC SQL END DECLARE SECTION;
		
	if (this->getIdTipoEndereco() != ID_TIPO_ENDERECO_COBRANCA)
		return;

	// valores das chaves da consulta SQL
	iIdPessoaEndereco = this->getIdPessoaEndereco();
	iIdConta = this->getIdConta();
	iIdTipoEnderecoCobranca = ID_TIPO_ENDERECO_COBRANCA_DEFAULT;

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL
		SELECT
			idPessoaEndereco
		INTO 
			:iIdPessoaEnderecoAnterior
		FROM
			customer.ContaEndereco
		WHERE
			idConta					= :iIdConta
		AND	idTipoEnderecoCobranca  = :iIdTipoEnderecoCobranca
		AND dtExpiracao				is NULL
		AND rownum					= 1;

	if (iIdPessoaEndereco != iIdPessoaEnderecoAnterior)
	{
		EXEC SQL UPDATE
				customer.ContaEndereco
			SET
				dtExpiracao = SYSDATE
			WHERE
				idConta					= :iIdConta
			AND	idTipoEnderecoCobranca  = :iIdTipoEnderecoCobranca
			AND dtExpiracao				is NULL;

		EXEC SQL		
			INSERT INTO
				customer.ContaEndereco
			(	IDCONTAENDERECO, 
				IDPESSOAENDERECO, 
				IDCONTA, 
				DTULTIMAALTERACAO, 
				IDTIPOENDERECOCOBRANCA
			)
			VALUES
			(	customer.ContaEnderecoSQ.NEXTVAL,
				:iIdPessoaEndereco,
				:iIdConta,
				SYSDATE,
				:iIdTipoEnderecoCobranca);

	}
		
	// Endereço não existe
	//if (sqlca.sqlcode == NO_DATA_FOUND) {
	//	throw TuxBasicOraException(sqlca.sqlcode);
	//}


	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 
}


// Métodos de acesso a banco de dados
void CEndereco::associarContasDB()
{
	CConta oConta;

	while(0 < this->getListaContas().size())
	{
		oConta = this->getListaContas().front();

		if(oConta.getIdPessoaEnderecoAssociado() !=
		   this->getIdPessoaEndereco())
		{
			// excluindo associação
			if(oConta.getIdPessoaEnderecoAssociado() > 0)
				oConta.excluirAssociacaoEndereco();

			oConta.setIdPessoaEnderecoAssociado(this->getIdPessoaEndereco());

			// incluindo associação
			oConta.inserirAssociacaoEndereco();

		}

		this->getListaContas().pop_front();
	}

}

int CEndereco::verificarEnderecoContaDB()
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;	
	long  iIdPessoaEndereco;
	int  iIdQt;
	EXEC SQL END DECLARE SECTION;

	iIdPessoaEndereco = this->getIdPessoaEndereco();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL
		SELECT
			COUNT(*)
		INTO
			:iIdQt
		FROM
			customer.ContaEndereco
		WHERE
			idPessoaEndereco = :iIdPessoaEndereco
		AND
			dtExpiracao IS NULL;	

	return iIdQt;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CEndereco::carregarTipoEnderecoDB(list < CEndereco > & listaEnd){

	struct sqlca sqlca;

	
	EXEC SQL BEGIN DECLARE SECTION;
		int  iIdTpEnd;
		char cSgTpEnd[ 256 ];
		char cDsTpEnd[ 256 ];
 	EXEC SQL END DECLARE SECTION;
	
	CEndereco oEndereco;

	// Marca ponto de controle de erro
	listaEnd.clear();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

    EXEC SQL DECLARE LSTEND CURSOR FOR

		SELECT
			idTipoEndereco,
			sgTipoEndereco,
			dsTipoEndereco
		FROM
			apoio.TipoEndereco
		WHERE
			idTipoEndereco != 0
		ORDER BY
			idTipoEndereco;

	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL OPEN LSTEND;

	for( ;; ) {
	// varre todos os registros para criar a lista com os Relacionamentos
		EXEC SQL FETCH LSTEND INTO
			  :iIdTpEnd
			, :cSgTpEnd
			, :cDsTpEnd;

			oEndereco.setIdTipoEndereco(iIdTpEnd);
			oEndereco.setSgTipoEndereco(CUtil::trim(cSgTpEnd));
			oEndereco.setDsTipoEndereco(CUtil::trim(cDsTpEnd));


			listaEnd.push_back( oEndereco );
	}

	EXEC SQL CLOSE LSTEND;
	return;
 
	sqlErrorConstrutor:
			throw TuxBasicOraException( sqlca.sqlcode );

}

void CEndereco::carregarTipoEnderecoCobrancaDB(list < CEndereco > & listaEndCobranca){

	struct sqlca sqlca;
	
	EXEC SQL BEGIN DECLARE SECTION;
	int  iIdTpEndCobranca;
	char cSgTpEndCobranca[256];
	char cDsTpEndCobranca[256];
 	EXEC SQL END DECLARE SECTION;
	
	CEndereco oEndereco;

	// Marca ponto de controle de erro
	listaEndCobranca.clear();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

    EXEC SQL DECLARE LSTENDCOBRANCA CURSOR FOR

		SELECT
			idTipoEnderecoCobranca,
			sgTipoEnderecoCobranca,
			dsTipoEnderecoCobranca
		FROM
			apoio.TipoEnderecoCobranca
		WHERE
			idTipoEnderecoCobranca != 0
		ORDER BY
			idTipoEnderecoCobranca;

	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL OPEN LSTENDCOBRANCA;

	for( ;; ) 
	{
		// varre todos os registros para criar a lista com os Relacionamentos
		EXEC SQL FETCH LSTENDCOBRANCA INTO
			  :iIdTpEndCobranca
			, :cSgTpEndCobranca
			, :cDsTpEndCobranca;

		oEndereco.setIdTipoEnderecoCobranca(iIdTpEndCobranca);
		oEndereco.setSgTipoEnderecoCobranca(CUtil::trim(cSgTpEndCobranca));
		oEndereco.setDsTipoEnderecoCobranca(CUtil::trim(cDsTpEndCobranca));

		listaEndCobranca.push_back( oEndereco );
	}

	EXEC SQL CLOSE LSTENDCOBRANCA;

	return;
 
	sqlErrorConstrutor:
			throw TuxBasicOraException( sqlca.sqlcode );

}

void CEndereco::carregarTipoComplementoDB(list < CEndereco > & listaComplemento){

	struct sqlca sqlca;
	
	EXEC SQL BEGIN DECLARE SECTION;
	int  iIdTpComplemento;
	char cSgTpComplemento[256];
	char cDsTpComplemento[256];
 	EXEC SQL END DECLARE SECTION;
	
	CEndereco oEndereco;

	// Marca ponto de controle de erro
	listaComplemento.clear();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

    EXEC SQL DECLARE LSTENDCOMPLEMENTO CURSOR FOR

	SELECT	NVL(cod_Tipo_Complemento, 0),
				NVL(dsc_Abrev_Tipo_Complemento, ' '),
				NVL(dsc_Tipo_Complemento, ' ')	
		FROM ENDERECO.TIPOCOMPLEMENTO 
		WHERE RTRIM(DSC_ABREV_TIPO_COMPLEMENTO) IN('A/C','A / C','REST','REST.',
			'AP','APTO','ALA','AC','BX','BASE AE','BQ','BL', 'BO','BR','CA','CAIXA',
				'CXP','CX POST','COND','CAMPO','CENTRO','CL','COLONIA','CJ','DEPTO.',
				'DISTRIT','ED','ESCOLA','ESTRADA','GIN','GJ','GL','HG','HOTEL','JD','KM',
				'LA','LJ','MZ','PD','PI','PL','POSTO','PV','PT','QD','SG','SEÇÃO','SJ',
				'SL','SS','TR')
		ORDER BY dsc_Tipo_Complemento;
		
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL OPEN LSTENDCOMPLEMENTO;

	for( ;; ) 
	{
		// varre todos os registros para criar a lista com os Relacionamentos
		EXEC SQL FETCH LSTENDCOMPLEMENTO INTO
			  :iIdTpComplemento
			, :cSgTpComplemento
			, :cDsTpComplemento;

		oEndereco.setIdTipoComplemento(iIdTpComplemento);
		oEndereco.setSgTipoComplemento(CUtil::trim(cSgTpComplemento));
		oEndereco.setDsTipoComplemento(CUtil::trim(cDsTpComplemento));

		listaComplemento.push_back( oEndereco );
	}

	EXEC SQL CLOSE LSTENDCOMPLEMENTO;

	return;
 
	sqlErrorConstrutor:
			throw TuxBasicOraException( sqlca.sqlcode );

}

void CEndereco::consultarPais(long  idPessoaEndereco, XMLGen* xml_g)
{

	struct sqlca sqlca;
	
	EXEC SQL BEGIN DECLARE SECTION;	
	char cNmPais[50];
	char cSgUF[50];
	int  iIdPais = 0;
	long idPessoaEnderecoSQL = idPessoaEndereco;
 	EXEC SQL END DECLARE SECTION;
	
	// Marca ponto de controle de erro
	memset(cNmPais,' ' , sizeof(cNmPais));
	memset(cSgUF,' ' , sizeof(cSgUF));
	// marca ponto de controle de erro
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR  GOTO OraException;

	EXEC SQL
	SELECT
		SGUF,
 		NMPAIS,
		PAIS.IDPAIS
	INTO
		:cSgUF,
		:cNmPais,
		:iIdPais
	FROM
		CUSTOMER.PESSOAENDERECO PESSOAENDERECO,
		APOIO.UF UF,
		APOIO.PAIS PAIS
	WHERE
		 IDPESSOAENDERECO = :idPessoaEnderecoSQL AND 
		 PESSOAENDERECO.IDPAIS =  PAIS.IDPAIS AND 
		 UF.IDUF = PESSOAENDERECO.IDUF;


	
	xml_g->addItem("sgUF", CUtil::trim(cSgUF));		
	xml_g->addItem("nmPais", CUtil::trim(cNmPais));
	xml_g->addItem("idPais", iIdPais);


	return;
 
	OraException:
		throw TuxBasicOraException( sqlca.sqlcode );

} 
