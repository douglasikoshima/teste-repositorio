/**
 * 
 * @modulo  Workflow
 * @usecase Workflow
 * @author  Miguel Benaventes
 * @version $Revision: 1.1.6.6 $
 * @CVS     $Author: a5114878 $ - $Date: 2012/10/09 21:09:57 $
 **/

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/selectData.h"

#include <string>
using namespace std;

void Sql_Error( sqlca * sqlca );

int GruposWriter::TemAtendimentosAbertos(long idContatoParam,long idGrupoParam)
{
    ULOG_START("GruposWriter::TemAtendimentosAbertos()");

    INITIALIZE_SQL;

  EXEC SQL BEGIN DECLARE SECTION;
    long idContato = idContatoParam;
    long idGrupo = idGrupoParam;
    static int iCount;
  EXEC SQL END DECLARE SECTION;

    ULOG("Verificando Abertos para idContato [%ld] e idGrupo [%ld]\n", idContatoParam, idGrupoParam );

  iCount = 0;
  
  EXEC SQL WHENEVER SQLERROR GOTO UndefinedError; 

    // ==> Remodelagem Atendimento--Fev/2007--Cassio 
    // EXEC SQL 
    //     SELECT 
    //         COUNT(1)
    //     INTO  
    //         :iCount
    //     FROM 
    //         atendimento.atendimentoPriorizacao ap,
    //         atendimento.atendimentoGrupoAtual  aga
    //     WHERE 
    //         ap.idContato = :idContato
    //     AND 
    //         aga.idGrupo = :idGrupo
    //     AND 
    //         ap.idAtendimento = aga.idAtendimento;
    EXEC SQL 
        SELECT 
            COUNT(1)
        INTO  
            :iCount
        FROM 
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        WHERE 
            IDCONTATO = :idContato
        AND 
            IDGRUPOATUAL = :idGrupo
        AND 
            ROWNUM < 2;

    ULOG("Qtd.atendimentos=%d", iCount);

    ULOG_END("GruposWriter::TemAtendimentosAbertos()");

    return iCount;

UndefinedError:
    throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int GruposWriter::TemNivelSequencia(long idSequenciaParam)
{
    ULOG_START("GruposWriter::TemNivelSequencia()");

  INITIALIZE_SQL;

  EXEC SQL BEGIN DECLARE SECTION;
    long idSequencia = idSequenciaParam;
        int iCount = 0;
  EXEC SQL END DECLARE SECTION;

    ULOG("Verificando Nivel Sequencia idSequencia [%lu]\n", idSequenciaParam);

  EXEC SQL WHENEVER SQLERROR GOTO UndefinedError; 

  EXEC SQL 
    SELECT 
      COUNT(1)
    INTO  
      :iCount
    FROM 
        contatoadm.sequencia a,
        contatoadm.nivelsequencia b
    WHERE 
        a.idSequencia = b.idSequencia
    AND 
        b.idSequencia = :idSequencia;

    ULOG("Qtd Nivel Sequencia [%d]\n", iCount);

    ULOG_END("GruposWriter::TemNivelSequencia()");

  return iCount;

UndefinedError:
    throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int GruposBase::GetGrupoType(char*pGNM)
{
    ULOG_START("GruposBase::GetGrupoType()");

    INITIALIZE_SQL;

  EXEC SQL BEGIN DECLARE SECTION;
    int idTipoSequencia;
    VARCHAR NmTipoSequencia[255];
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR GOTO UndefinedError;
  EXEC SQL WHENEVER NOT FOUND GOTO NotFound;

  TO_VARCHAR(NmTipoSequencia,pGNM);

  EXEC SQL SELECT idTipoSequencia INTO :idTipoSequencia FROM contatoadm.TipoSequencia
    WHERE NmTipoSequencia=:NmTipoSequencia;

    ULOG_END("GruposBase::GetGrupoType()");

  return idTipoSequencia;

NotFound:
  throw new TuxBasicSvcException("09E0003");

UndefinedError:
    throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int GruposWriter::WriteFluxoAtendimento(long sIdContato, const char *sgFluxoAtendimento)
{
  ULOG_START("GruposWriter::WriteFluxoAtendimento()");

  INITIALIZE_SQL;

  EXEC SQL BEGIN DECLARE SECTION;
    const char *varOraSgFluxoAtendimento = sgFluxoAtendimento;
    long varOraIdContato = sIdContato;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR GOTO UndefinedError; 
  EXEC SQL WHENEVER NOTFOUND CONTINUE;

  EXEC SQL
  UPDATE
    CONTATOADM.CONTATOFOLHA
  SET
    SGFLUXOATENDIMENTO = :varOraSgFluxoAtendimento,
    DTULTIMAALTERACAO = SYSDATE
  WHERE
        IDCONTATO = :varOraIdContato;

  ULOG_END("GruposWriter::WriteFluxoAtendimento()");

  return 1;

UndefinedError:
    throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

// CORRECAO CONTATOGRUPO
int GruposWriter::WriteGrupos(DOMNode*node,long itemID,long sIdContato,CGruposLst &oGrps)
{
    ULOG_START("GruposWriter::WriteGrupos()");
    int idx;
    int flagGravar = 0;
   
    INITIALIZE_SQL;
    EXEC SQL BEGIN DECLARE SECTION;

        struct
        {
            long idSequencia;
            long idContatoGrupo;
            long idGrupo;
            long idContato;
            long idTipoSequencia;
            long idOrder;
            long idUsr;
        }SeqData;

        char *idUsuario = this->idUsr;
        //char idUsuario[41];
        short i_idContatoGrupo;
        
    EXEC SQL END DECLARE SECTION;
    
    SeqData.idUsr = atol(idUsuario);
    //sprintf(idUsuario,"%ld",SeqData.idUsr);
    
    DOMNode*subnode;
    int stItem,item,aord;
    char * pdata;

    EXEC SQL WHENEVER SQLERROR GOTO UndefinedError; 
    //EXEC SQL WHENEVER NOTFOUND DO continue;

    item=0;
    aord=0;
    SeqData.idTipoSequencia=itemID;
    SeqData.idContato=sIdContato;
    for(;;)
    {
        EXEC SQL WHENEVER NOTFOUND DO continue;
        stItem=0;
        if(!(subnode=walkDOM(node,"GrupoVO",&stItem,item++)))
        {
            for( idx=0; idx < oGrps.Quantidade(); idx++ )
            {
                //ULOG( "oGrps.Registro(%d)->flagSalvar = [%d]\n", idx, oGrps.Registro(idx)->flagSalvar );   

                if ( oGrps.Registro(idx)->flagSalvar == 2 )  // Atualiza dtExclusao e sqOrdem
                {
                    SeqData.idSequencia = oGrps.Registro(idx)->idSeqLst;

                    //ULOG("Vai executar\n"
                    //      "UPDATE CONTATOADM.SEQUENCIA "
                    //      "SET dtExclusao=SYSDATE"
                    //      "WHERE idSequencia=%lu", SeqData.idSequencia );

                    EXEC SQL 
                    UPDATE 
                     contatoadm.Sequencia 
                    SET 
                    dtExclusao = SYSDATE,
                    dtUltimaAlteracao = SYSDATE,
                    idUsuarioAlteracao = :idUsuario
                    WHERE 
                    idSequencia = :SeqData.idSequencia;
                }
            }
            break;
        }

        pdata=walkTree(subnode,"codigo",0);
        if(!pdata)
            throw new TuxBasicSvcException("09E0004","Cannot find required item \"codigo\"");
        SeqData.idGrupo = atol(pdata);
        XMLString::release(&pdata);

        pdata=walkTree(subnode,"ordem",0);
        if( pdata )
        {
            SeqData.idOrder = atol( pdata );
            XMLString::release( &pdata );
        }
        else
        {
          SeqData.idOrder=aord++;
        }

        EXEC SQL WHENEVER SQLERROR GOTO UndefinedError;

        for( idx=0; idx < oGrps.Quantidade(); idx++ )
        {
            flagGravar = 0;
            SeqData.idOrder = idx;
            //ULOG("Memoria [%lu] - flagSalvar [%lu] - XML [%d]\n", oGrps.Registro(idx)->idGrupoMemLst,oGrps.Registro(idx)->flagSalvar,SeqData.idGrupo );     

            if ( oGrps.Registro(idx)->flagSalvar == 2 )  // Atualiza dtExclusao e sqOrdem
            {
                //ULOG("[%lu] - Flag [%lu] - XML [%d]\n"
                 //    ,oGrps.Registro(idx)->idGrupoMemLst
                 //    ,oGrps.Registro(idx)->flagSalvar
                 //    ,SeqData.idGrupo );

                SeqData.idSequencia = oGrps.Registro(idx)->idSeqLst;

                //ULOG("Vai executar\n"
                //      "UPDATE CONTATOADM.SEQUENCIA "
                //      "SET sqOrdem=%lu"
                //      "    dtExclusao=SYSDATE "
                //      "WHERE idSequencia=%lu", SeqData.idOrder, SeqData.idSequencia );

                EXEC SQL 
                UPDATE 
                  contatoadm.Sequencia 
                SET 
                   sqOrdem = :SeqData.idOrder,
                   dtExclusao = SYSDATE,
                   dtUltimaAlteracao = SYSDATE,
                   idUsuarioAlteracao = :idUsuario
                WHERE 
                   idSequencia = :SeqData.idSequencia;

                continue;
            }

            if ( oGrps.Registro(idx)->idGrupoMemLst != SeqData.idGrupo )
            {
                //ULOG( "Passou 1a\n" );
                continue;
            }
        
            //ULOG( "Passou 2\n" );
            
            if ( oGrps.Registro(idx)->flagSalvar == 1 ) //NAO Existe no banco, nao deve ser salvo
            {
               //ULOG( "Passou 3\n" );
               flagGravar = 1;  //  deve gravar registro
               oGrps.Registro(idx)->flagSalvar = 0;
               //ULOG("Memoria [%lu] - Alterou Flag [%lu] - XML [%lu]\n", oGrps.Registro(idx)->idGrupoMemLst,oGrps.Registro(idx)->flagSalvar,SeqData.idGrupo );     
               break;
            }

            //ULOG( "Passou 4\n" );
            if ( oGrps.Registro(idx)->flagSalvar == 0 )  // Atualizar o campo Sequencia
            {
                //ULOG( "Passou 5\n" );
                SeqData.idSequencia = oGrps.Registro(idx)->idSeqLst;

                //ULOG("Vai executar\n"
                //      "UPDATE CONTATOADM.SEQUENCIA "
                //      "SET sqOrdem=%lu"
                //      "    dtExclusao=NULL "
                //      "WHERE idSequencia=%lu", SeqData.idOrder, SeqData.idSequencia );

                EXEC SQL 
                   UPDATE 
                      contatoadm.Sequencia 
                   SET 
                      sqOrdem = :SeqData.idOrder,
                      dtExclusao = NULL,
                      dtUltimaAlteracao = SYSDATE,
                      idUsuarioAlteracao = :idUsuario
                   WHERE 
                      idSequencia = :SeqData.idSequencia;

                continue;
            }

        }
     
        /*
        if ( flagGravar == 0 )  // Nao Encontrou Informacao a ser gravada
        {
            ULOG( "Passou 6\n" );
            continue;
        }
        */

        //ULOG( "Passou 7 flagGravar [%d]\n", flagGravar );
        if ( !idUsr || !*idUsr )
          SeqData.idUsr = 0L;
        else
          SeqData.idUsr=atol(idUsr);

        //ULOG( ">>> Atualizando contatoadm.ContatoGrupo idContato [%lu] - idGrupo [%lu]", SeqData.idContato, SeqData.idGrupo );

        EXEC SQL WHENEVER NOTFOUND GOTO NaoAchouCtGrupo;

        EXEC SQL
        UPDATE contatoadm.ContatoGrupo
        SET idUsuarioAlteracao = :SeqData.idUsr,
            dtUltimaAlteracao = SYSDATE
        WHERE
          idContato = :SeqData.idContato
        AND idGrupo = :SeqData.idGrupo ;
        
    NaoAchouCtGrupo:
        //ULOG( "### Linhas afetadas [%d]", sqlca.sqlerrd[2] );
        
        if ( sqlca.sqlerrd[2] == 0 ) // Nao existe este registro
        {
            EXEC SQL 
            SELECT 
             contatoadm.ContatoGrupoSq.nextval 
            INTO 
             :SeqData.idContatoGrupo 
            FROM DUAL;
          
            //ULOG("Insertando Contato Grupo:%lu %lu %lu\n", SeqData.idContatoGrupo, SeqData.idContato, SeqData.idGrupo );   

            EXEC SQL 
            INSERT INTO contatoadm.ContatoGrupo 
            (
                idContatoGrupo, 
                idContato, 
                idGrupo,
                idUsuarioAlteracao,
                dtUltimaAlteracao
            ) 
            VALUES
            (
                :SeqData.idContatoGrupo,
                :SeqData.idContato,
                :SeqData.idGrupo,
                :SeqData.idUsr,
                SYSDATE
            );

        }
        
        EXEC SQL
        select 
            idContatoGrupo 
        into 
            :SeqData.idContatoGrupo:i_idContatoGrupo 
        from 
            contatoadm.ContatoGrupo 
        where 
            idContato = :SeqData.idContato 
        AND idGrupo = :SeqData.idGrupo 
        and rownum < 2 ;
        
        //ULOG( ">>> Atualizando contatoadm.Sequencia idTipoSequencia [%lu]", SeqData.idTipoSequencia );

        EXEC SQL WHENEVER NOTFOUND GOTO NaoAchouCtSeq;

        EXEC SQL
        UPDATE contatoadm.Sequencia
        SET idUsuarioAlteracao = :SeqData.idUsr ,
            dtUltimaAlteracao = SYSDATE
        WHERE
          idContatoGrupo = :SeqData.idContatoGrupo
        AND idTipoSequencia = :SeqData.idTipoSequencia ;
        
    NaoAchouCtSeq:
            
        //ULOG( "*** Linhas afetadas [%d]", sqlca.sqlerrd[2] );
        if ( sqlca.sqlerrd[2] == 0 ) // Nao existe este registro
        {
            EXEC SQL 
            SELECT 
              contatoadm.SequenciaSq.nextval 
            INTO 
              :SeqData.idSequencia 
            FROM DUAL;
  
  
            //ULOG("Inserindo Sequencia: idSequencia:%lu idContatoGrupo:%lu idTipoSequencia:%lu idOrder:%lu idUsr:%lu\n", SeqData.idSequencia, SeqData.idContatoGrupo, SeqData.idTipoSequencia, SeqData.idOrder, SeqData.idUsr );
  
            EXEC SQL 
            INSERT INTO contatoadm.Sequencia 
            (  
                idSequencia,
                idContatoGrupo,
                idTipoSequencia,
                sqOrdem,
                idUsuarioAlteracao,
                dtUltimaAlteracao
            ) 
            VALUES
            (
                :SeqData.idSequencia,
                :SeqData.idContatoGrupo,
                :SeqData.idTipoSequencia,
                :SeqData.idOrder,
                :SeqData.idUsr,
                SYSDATE
            );
        }
        
    }

    ULOG_END("GruposWriter::WriteGrupos()");
    return 1;

UndefinedError:
    throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int GruposWriter::CleanPreviousRetornoSeq( string &idContatoParam ) const
{
    ULOG_START("GruposWriter::CleanPreviousRetornoSeq()");

    int i;
    char temp[21];
    string idContatoGrupoWrk =         
        "DELETE FROM  "
            "Contatoadm.TipoRetornoSequencia  "
        "WHERE "
            "idSequencia "
        "IN ( "
                "SELECT  "
                    "idSequencia  "
                "FROM  "
                    "Contatoadm.Sequencia S,  "
                    "Contatoadm.ContatoGrupo CG "
                "WHERE  "
                    "S.idContatoGrupo = CG.idContatoGrupo  "
                "AND  "
                    "CG.idContatoGrupo IN ( " + idContatoParam + "))";

    INITIALIZE_SQL;

  EXEC SQL BEGIN DECLARE SECTION;
    const char *query;
  EXEC SQL END DECLARE SECTION;

    query = idContatoGrupoWrk.c_str();
   
    EXEC SQL WHENEVER SQLERROR GOTO UndefinedError;
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL EXECUTE IMMEDIATE :query;

    // EXEC SQL 
    //     DELETE FROM 
    //         Contatoadm.TipoRetornoSequencia 
    //     WHERE
    //         idSequencia
    //     IN (
    //             SELECT 
    //                 idSequencia 
    //             FROM 
    //                 Contatoadm.Sequencia S, 
    //                 Contatoadm.ContatoGrupo CG
    //             WHERE 
    //                 S.idContatoGrupo = CG.idContatoGrupo 
    //             AND 
    //                 CG.idContatoGrupo IN (:idContatoGrupoWrk)
    //         );
   
    ULOG_END("GruposWriter::CleanPreviousRetornoSeq()");
    return 1;

UndefinedError:
    throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int GruposWriter::CleanPreviousNivelSeq( string &idContatoParam ) const
{
    ULOG_START("GruposWriter::CleanPreviousNivelSeq()");

    int i;
    char temp[21];
    string idContatoGrupoWrk =         
       "DELETE FROM "
           "Contatoadm.NivelSequencia "
       "WHERE "
           "idSequenciaMandatoria "
       "IN ( "
               "SELECT  "
                   "idSequencia  "
               "FROM  "
                   "Contatoadm.Sequencia S,"
                   "Contatoadm.ContatoGrupo CG "
               "WHERE  "
                   "S.idContatoGrupo = CG.idContatoGrupo "
               "AND  "
                   "CG.idContatoGrupo IN ( " + idContatoParam + "))";
    INITIALIZE_SQL;

  EXEC SQL BEGIN DECLARE SECTION;
    const char *query;
  EXEC SQL END DECLARE SECTION;

    query = idContatoGrupoWrk.c_str();

    EXEC SQL WHENEVER SQLERROR GOTO UndefinedError;
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL EXECUTE IMMEDIATE :query;

    // EXEC SQL 
    //     DELETE FROM 
    //         Contatoadm.NivelSequencia 
    //     WHERE
    //         idSequenciaMandatoria
    //     IN (
    //             SELECT 
    //                 idSequencia 
    //             FROM 
    //                 Contatoadm.Sequencia S, 
    //                 Contatoadm.ContatoGrupo CG
    //             WHERE 
    //                 S.idContatoGrupo = CG.idContatoGrupo 
    //             AND 
    //                 CG.idContatoGrupo IN (:idContatoGrupoWrk)
    //         );

    ULOG_END("GruposWriter::CleanPreviousNivelSeq()");

  return 1;

UndefinedError:
    throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int GruposWriter::CleanPreviousNiveis( string &idContatoParam ) const
{
    ULOG_START("GruposWriter::CleanPreviousNiveis()");

    int i;
    char temp[21];
    string idContatoGrupoWrk =         
       "DELETE FROM  "
           "Contatoadm.NivelSequencia  "
       "WHERE "
       "idSequencia  "
       "IN ( "
           "SELECT  "
               "idSequencia  "
           "FROM  "
               "Contatoadm.Sequencia S,  "
               "Contatoadm.ContatoGrupo CG "
           "WHERE  "
               "S.idContatoGrupo = CG.idContatoGrupo  "
           "AND  "
               "CG.idContatoGrupo IN ( " + idContatoParam + "))";

    INITIALIZE_SQL;

  EXEC SQL BEGIN DECLARE SECTION;
    const char *query;
  EXEC SQL END DECLARE SECTION;

    query = idContatoGrupoWrk.c_str();

    EXEC SQL WHENEVER SQLERROR GOTO UndefinedError;
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL EXECUTE IMMEDIATE :query;

    // EXEC SQL 
    //     DELETE FROM 
    //         Contatoadm.NivelSequencia 
    //     WHERE
  // 	    idSequencia 
    //     IN (
    //         SELECT 
    //             idSequencia 
    //         FROM 
    //             Contatoadm.Sequencia S, 
    //             Contatoadm.ContatoGrupo CG
    //         WHERE 
    //             S.idContatoGrupo = CG.idContatoGrupo 
    //         AND 
    //             CG.idContatoGrupo IN (:idContatoGrupoWrk)
    //         );

    ULOG_END("GruposWriter::CleanPreviousNiveis()");
  return 1;

UndefinedError:
    throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int GruposWriter::CleanPreviousSequencia( string &idContatoParam ) const
{
    ULOG_START("GruposWriter::CleanPreviousSequencia()");

    int i;
    INITIALIZE_SQL;
    char temp[21];
    string idContatoGrupoWrk =         
       "DELETE FROM  "
           "Contatoadm.Sequencia "
       "WHERE "
           "idContatoGrupo IN (" + idContatoParam + ")";

  EXEC SQL BEGIN DECLARE SECTION;
    const char *query;
  EXEC SQL END DECLARE SECTION;

    query = idContatoGrupoWrk.c_str();

    EXEC SQL WHENEVER SQLERROR GOTO UndefinedError;
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL EXECUTE IMMEDIATE :query;

    // EXEC SQL 
    //     DELETE FROM 
    //         Contatoadm.Sequencia
    //     WHERE
    //         idContatoGrupo IN (:idContatoGrupoWrk);

    // if ( sqlca.sqlcode < 0 )
  // {
    //     if( sqlca.sqlcode != -2292 )
    //         goto UndefinedError;
  // }

  ULOG_END("GruposWriter::CleanPreviousSequencia()");

  return 1;

Exit:
  ULOG_END("GruposWriter::CleanPreviousSequencia(), Exit");
  return 1;

UndefinedError:
    if ( sqlca.sqlcode != 2292 )
    {
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
    }

  ULOG_END("GruposWriter::CleanPreviousSequencia(), Erro 2292");

  return 1;
}

int GruposWriter::CleanPreviousFluxoFase( string &idContatoParam ) const
{
    ULOG_START("GruposWriter::CleanPreviousFluxoFase()");

    int idx;
    string idContatoGrupoWrk =         
       "SELECT DISTINCT "
           "FG.IDFASEGRUPOFECHAMENTO "
       "FROM  "
           "CONTATOADM.CONTATOGRUPO CG,  "
           "CONTATOADM.SEQUENCIA S, "
           "CONTATOADM.FASEGRUPOFECHAMENTO FG "
       "WHERE  "
           "S.IDCONTATOGRUPO = CG.IDCONTATOGRUPO "
       "AND  "
           "CG.IDCONTATO = FG.IDCONTATO "
       "AND  "
           "CG.IDGRUPO = FG.IDGRUPO "
       "AND  "
           "S.IDTIPOSEQUENCIA = 1 "
       "AND  "
           "S.IDCONTATOGRUPO IN (" + idContatoParam + ") ";

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        long idFaseGrupo;
        long idFaseGrupoArr[500];
        const char *query;
  
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    query = idContatoGrupoWrk.c_str();
    idFaseGrupoArr[0] = END_ARRAY;

    EXEC SQL PREPARE recebeQuery FROM :query;
    EXEC SQL DECLARE Consulta CURSOR FOR recebeQuery;
    EXEC SQL OPEN Consulta;

    idx = 0;
    for ( ;; )
    {
        EXEC SQL FETCH Consulta INTO :idFaseGrupo;

        if ( idx > 499 )
        {
            CleanFaseGrupoFechamento(idFaseGrupoArr);
            idx = 0;
        }

        idFaseGrupoArr[idx] = idFaseGrupo;
        idx++;
    }

    EXEC SQL CLOSE Consulta;

    if ( idFaseGrupoArr[0] != END_ARRAY )
    {
        if ( idx < 500 ) idFaseGrupoArr[idx] = END_ARRAY;

        CleanFaseGrupoFechamento(idFaseGrupoArr);
    }
    
    ULOG_END("GruposWriter::CleanPreviousFluxoFase()");

    return 1;

    UndefinedError:
    throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int GruposWriter::CleanFaseGrupoFechamento( long* idFaseFechamentoPrm ) const
{
    ULOG_START("GruposWriter::CleanFaseGrupoFechamento()");

    INITIALIZE_SQL;
    int i;

    EXEC SQL BEGIN DECLARE SECTION;

        long idFaseGrupoFechamentoWrk[500];

    EXEC SQL END DECLARE SECTION;

    memset(&idFaseGrupoFechamentoWrk,0,sizeof(idFaseGrupoFechamentoWrk));

    for ( i=0; i<500 ; i++ )
    {
        if ( idFaseFechamentoPrm[i] == END_ARRAY )
            break;
     
         idFaseGrupoFechamentoWrk[i] = idFaseFechamentoPrm[i];
    }

    EXEC SQL WHENEVER SQLERROR DO Sql_Error( &sqlca );
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
   
    EXEC SQL
        DELETE FROM 
           CONTATOADM.FECHAMENTOTIPOLINHA
        WHERE
           IDFASEGRUPOFECHAMENTO = :idFaseGrupoFechamentoWrk;

    EXEC SQL
        DELETE FROM 
           CONTATOADM.FECHAMENTOTIPOPESSOA
        WHERE
           IDFASEGRUPOFECHAMENTO = :idFaseGrupoFechamentoWrk;

    EXEC SQL
        DELETE FROM 
           CONTATOADM.FECHAMENTOTPCARTEIRA
        WHERE
           IDFASEGRUPOFECHAMENTO = :idFaseGrupoFechamentoWrk;

    EXEC SQL
        DELETE FROM 
           CONTATOADM.FECHAMENTOTPRELACIONAMENTO
        WHERE
           IDFASEGRUPOFECHAMENTO = :idFaseGrupoFechamentoWrk;

    EXEC SQL
        DELETE FROM 
           CONTATOADM.FECHAMENTOSEGMENTACAO
        WHERE
           IDFASEGRUPOFECHAMENTO = :idFaseGrupoFechamentoWrk;
    
    EXEC SQL 
        DELETE FROM 
           CONTATOADM.FASEGRUPOFECHAMENTO 
        WHERE
           IDFASEGRUPOFECHAMENTO = :idFaseGrupoFechamentoWrk;

    ULOG_END("GruposWriter::CleanFaseGrupoFechamento()");

    return 1;

// Exit:
//     ULOG_END("GruposWriter::CleanFaseGrupoFechamento()");
// 
//   	return 1;
}

int GruposWriter::CleanPreviousData( string &idContatoParam ) const
{
    ULOG_START("GruposWriter::CleanPreviousData()");

    int i;
    INITIALIZE_SQL;
    char temp[21];
    string idContatoGrupoWrk =         
       "DELETE FROM "
           "CONTATOADM.CONTATOGRUPO  "
       "WHERE "
           "IDCONTATOGRUPO IN (" + idContatoParam + ")";

  EXEC SQL BEGIN DECLARE SECTION;
    const char *query;
  EXEC SQL END DECLARE SECTION;

    query = idContatoGrupoWrk.c_str();

    EXEC SQL WHENEVER SQLERROR GOTO UndefinedError;
  EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL EXECUTE IMMEDIATE :query;

    // EXEC SQL 
    //     DELETE FROM
    //         CONTATOADM.CONTATOGRUPO 
    //     WHERE
    //         IDCONTATOGRUPO IN (:idContatoGrupoWrk);

    // if ( sqlca.sqlcode < 0 )
  // {
    //     if( sqlca.sqlcode != -2292 )
    //         goto UndefinedError;
  // }

  ULOG_END("GruposWriter::CleanPreviousData()");

  return 1;

Exit:
  ULOG_END("GruposWriter::CleanPreviousData()==>Saida por goto Exit");
  return 1;

UndefinedError:
    if( sqlca.sqlcode != -2292 )
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);

  ULOG_END("GruposWriter::CleanPreviousData()==>ErroOra 2292");
  return 1;
}

int GruposWriter::InsereFluxoFaseGrupo(long  idContatoPrm,long  idGrupoPrm,
                                       long  idTipoFechamentoPrm,
                                       long *idFaseGrupoFechamentoPrm) const

{
    ULOG_START("GruposWriter::InsereFluxoFaseGrupo()");

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

      VARCHAR idContatoAux[65];
        VARCHAR idGrupoAux[65];
        VARCHAR idTipoFechamentoAux[65];
        long idFaseGrupoFechamentoWrk;

    EXEC SQL END DECLARE SECTION;

  sprintf( (char *)idContatoAux.arr,"%lu",idContatoPrm );
    idContatoAux.len = strlen((char *)idContatoAux.arr );
    sprintf( (char *)idGrupoAux.arr,"%lu",idGrupoPrm );
    idGrupoAux.len = strlen((char *)idGrupoAux.arr );
    sprintf( (char *)idTipoFechamentoAux.arr,"%lu",idTipoFechamentoPrm );
    idTipoFechamentoAux.len = strlen((char *)idTipoFechamentoAux.arr );

    EXEC SQL WHENEVER SQLERROR DO Sql_Error( &sqlca );
  EXEC SQL WHENEVER NOTFOUND CONTINUE;
  EXEC SQL 
        SELECT 
            ContatoAdm.FaseGrupoFechamentoSQ.NEXTVAL 
        INTO 
            :idFaseGrupoFechamentoWrk
    FROM DUAL;

    EXEC SQL 
        INSERT INTO ContatoAdm.FaseGrupoFechamento
        (
            idFaseGrupoFechamento,
            idContato,
            idGrupo,
            idTipoFechamentoContato
        )
        VALUES
        (
            :idFaseGrupoFechamentoWrk,
            :idContatoAux,
            :idGrupoAux,
            :idTipoFechamentoAux
        );
    
    *idFaseGrupoFechamentoPrm = idFaseGrupoFechamentoWrk;
    
    ULOG_END("GruposWriter::InsereFluxoFaseGrupo()");    

    return 1;

}

bool GruposWriter::FechamentoTipoLinha( long idFaseGrpFechamParam,
                                        long *idTipoLinhaParam ) const
{
    ULOG_START("GruposWriter::FechamentoTipoLinha()");

    int i;
    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

    long idFaseGrpFechamArr[500];
    long idTipoLinhaArr[500];

  EXEC SQL END DECLARE SECTION;

    memset(&idFaseGrpFechamArr,0,sizeof(idFaseGrpFechamArr));
    memset(&idTipoLinhaArr,0,sizeof(idTipoLinhaArr));

    for ( i=0; i<500 ; i++ )
    {
        if ( idTipoLinhaParam[i] == END_ARRAY )
            break;

        idFaseGrpFechamArr[i] = idFaseGrpFechamParam;
        idTipoLinhaArr[i] = idTipoLinhaParam[i];
    }
    //idFaseGrpFechamArr[i] = END_ARRAY;
    //idTipoLinhaArr[i] = END_ARRAY;

    EXEC SQL WHENEVER SQLERROR CONTINUE;

    EXEC SQL 
        INSERT INTO ContatoAdm.FechamentoTipoLinha
        (
            idFechamentoTipoLinha,
            idFaseGrupoFechamento,
            idTipoLinha
        )
        VALUES
        (
            ContatoAdm.FechamentoTipoLinhaSQ.NEXTVAL,
            :idFaseGrpFechamArr,
            :idTipoLinhaArr
        );
        if ( sqlca.sqlcode < 0 )
      {
            if( sqlca.sqlcode != -2291 )
                Sql_Error( &sqlca );
      }
      
    ULOG_END("GruposWriter::FechamentoTipoLinha()");

    return true;
}

bool GruposWriter::FechamentoSegmentacao(long idFaseGrpFechamParam, 
                                         long *idSegmentacaoParam) const
{
    ULOG_START("GruposWriter::FechamentoSegmentacao()");

    int i;
    INITIALIZE_SQL;
    EXEC SQL BEGIN DECLARE SECTION;

    long idFaseGrupoFechamentoArr[500];
    long idSegmentacaoArr[500];

  EXEC SQL END DECLARE SECTION;

    memset(&idFaseGrupoFechamentoArr,0,sizeof(idFaseGrupoFechamentoArr));
    memset(&idSegmentacaoArr,0,sizeof(idSegmentacaoArr));

    for ( i=0; i<500 ; i++ )
    {
        if ( idSegmentacaoParam[i] == END_ARRAY )
            break;

        idFaseGrupoFechamentoArr[i] = idFaseGrpFechamParam;
        idSegmentacaoArr[i] = idSegmentacaoParam[i];
    }
    //idFaseGrupoFechamentoArr[i] = END_ARRAY;
    //idSegmentacaoArr[i] = END_ARRAY;

    EXEC SQL WHENEVER SQLERROR CONTINUE;

    EXEC SQL
        INSERT INTO ContatoAdm.FechamentoSegmentacao
        (
            idFechamentoSegmentacao,
            idFaseGrupoFechamento,
            idSegmentacao
        )
        VALUES
        (
            ContatoAdm.FechamentoSegmentacaoSQ.NEXTVAL,
            :idFaseGrupoFechamentoArr,
            :idSegmentacaoArr
        );
        if ( sqlca.sqlcode < 0 )
      {
            if( sqlca.sqlcode != -2291 )
                Sql_Error( &sqlca );
      }

    ULOG_END("GruposWriter::FechamentoSegmentacao()");

    return true;
}

bool GruposWriter::FechamentoTipoCarteira(long idFaseGrpFechamParam, 
                                          long *idTipoCarteiraParam) const
{
    ULOG_START("GruposWriter::FechamentoTipoCarteira()");

    int i;
    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

    long idFaseGrpFechamArr[500];
    long idTipoCarteiraArr[500];

  EXEC SQL END DECLARE SECTION;

    memset(&idFaseGrpFechamArr,0,sizeof(idFaseGrpFechamArr));
    memset(&idTipoCarteiraArr,0,sizeof(idTipoCarteiraArr));

    for ( i=0; i<500 ; i++ )
    {
        if ( idTipoCarteiraParam[i] == END_ARRAY )
            break;

        idFaseGrpFechamArr[i] = idFaseGrpFechamParam;
        idTipoCarteiraArr[i] = idTipoCarteiraParam[i];
    }
    // idFaseGrpFechamArr[i] = END_ARRAY;
    // idTipoCarteiraArr[i] = END_ARRAY;

    EXEC SQL WHENEVER SQLERROR CONTINUE;

    EXEC SQL
        INSERT INTO ContatoAdm.FechamentoTpCarteira
        (
            idFechamentoTpCarteira,
            idFaseGrupoFechamento,
            idTipoCarteira
        )
        VALUES
        (
            ContatoAdm.FechamentoTpCarteiraSQ.NEXTVAL,
            :idFaseGrpFechamArr,
            :idTipoCarteiraArr
        );
        if ( sqlca.sqlcode < 0 )
      {
            if( sqlca.sqlcode != -2291 )
                Sql_Error( &sqlca );
      }

    ULOG_END("GruposWriter::FechamentoTipoCarteira()");

    return true;
}

bool GruposWriter::FechamentoTipoPessoa(long idFaseGrpFechamParam, 
                                        long *idTipoPessoaParam) const
{
    ULOG_START("GruposWriter::FechamentoTipoPessoa()");

    int i;
    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

    long idFaseGrupoFechamentoArr[500];
    long idTipoPessoaArr[500];

  EXEC SQL END DECLARE SECTION;

    memset(&idFaseGrupoFechamentoArr,0,sizeof(idFaseGrupoFechamentoArr));
    memset(&idTipoPessoaArr,0,sizeof(idTipoPessoaArr));

    for ( i=0; i<500 ; i++ )
    {
        if ( idTipoPessoaParam[i] == END_ARRAY )
            break;

        idFaseGrupoFechamentoArr[i] = idFaseGrpFechamParam;
        idTipoPessoaArr[i] = idTipoPessoaParam[i];
    }
    // idFaseGrupoFechamentoArr[i] = END_ARRAY;
    // idTipoPessoaArr[i] = END_ARRAY;

    EXEC SQL WHENEVER SQLERROR CONTINUE;

    EXEC SQL 
        INSERT INTO ContatoAdm.FechamentoTipoPessoa
        (
            idFechamentoTipoPessoa,
            idFaseGrupoFechamento,
            idTipoPessoa
        )
        VALUES
        (
            ContatoAdm.FechamentoTipoPessoaSQ.NEXTVAL,
            :idFaseGrupoFechamentoArr,
            :idTipoPessoaArr
        );
        if ( sqlca.sqlcode < 0 )
      {
            if( sqlca.sqlcode != -2291 )
                Sql_Error( &sqlca );
      }

    ULOG_END("GruposWriter::FechamentoTipoPessoa()");

    return true;
}

bool GruposWriter::FechamentoTipoRelac(long idFaseGrpFechamParam,
                                       long *idTipoRelacParam) const
{
    ULOG_START("GruposWriter::FechamentoTipoRelac()");

    int i;
    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

    long idFaseGrupoFechamentoArr[500];
    long idTipoRelacionamentoArr[500];

  EXEC SQL END DECLARE SECTION;

    memset(&idFaseGrupoFechamentoArr,0,sizeof(idFaseGrupoFechamentoArr));
    memset(&idTipoRelacionamentoArr,0,sizeof(idTipoRelacionamentoArr));

    for ( i=0; i<500 ; i++ )
    {
        if ( idTipoRelacParam[i] == END_ARRAY )
            break;

        idFaseGrupoFechamentoArr[i] = idFaseGrpFechamParam;
        idTipoRelacionamentoArr[i] = idTipoRelacParam[i];
    }
    // idFaseGrupoFechamentoArr[i] = END_ARRAY;
    // idTipoRelacionamentoArr[i] = END_ARRAY;

    EXEC SQL WHENEVER SQLERROR CONTINUE;

    EXEC SQL 
        INSERT INTO ContatoAdm.FechamentoTpRelacionamento
        (
            idFechamentoTpRelacionamento,
            idFaseGrupoFechamento,
            idTipoRelacionamento
        )
        VALUES
        (
            ContatoAdm.FechamentoTpRelacionamentoSQ.NEXTVAL,
            :idFaseGrupoFechamentoArr,
            :idTipoRelacionamentoArr
        );
        if ( sqlca.sqlcode < 0 )
      {
            if( sqlca.sqlcode != -2291 )
                Sql_Error( &sqlca );
      }

    ULOG_END("GruposWriter::FechamentoTipoRelac()");   
    return true;
}

int GruposWriter::OrganizaFluxoFaseGrupo(long idFaseFechamentoPrm) const
{
    ULOG_START("GruposWriter::OrganizaFluxoFaseGrupo()");

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        long idFaseGrupoFechamentoWrk = idFaseFechamentoPrm;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO Sql_Error( &sqlca );
 

    EXEC SQL
        DELETE FROM 
           CONTATOADM.FECHAMENTOTIPOLINHA
        WHERE
           IDFASEGRUPOFECHAMENTO = :idFaseGrupoFechamentoWrk;

    EXEC SQL
        DELETE FROM 
           CONTATOADM.FECHAMENTOTIPOPESSOA
        WHERE
           IDFASEGRUPOFECHAMENTO = :idFaseGrupoFechamentoWrk;

    EXEC SQL
        DELETE FROM 
           CONTATOADM.FECHAMENTOTPCARTEIRA
        WHERE
           IDFASEGRUPOFECHAMENTO = :idFaseGrupoFechamentoWrk;

    EXEC SQL
        DELETE FROM 
           CONTATOADM.FECHAMENTOTPRELACIONAMENTO
        WHERE
           IDFASEGRUPOFECHAMENTO = :idFaseGrupoFechamentoWrk;

    EXEC SQL
        DELETE FROM 
           CONTATOADM.FECHAMENTOSEGMENTACAO
        WHERE
           IDFASEGRUPOFECHAMENTO = :idFaseGrupoFechamentoWrk;
    
    ULOG_END("GruposWriter::OrganizaFluxoFaseGrupo()");   

    return 1;

}

int GruposWriter::LimpaFluxoFaseGrupo(long idContatoPrm, 
                                      long idGrupoPrm,
                                      long idTipoFchContatoPrm) const
{
    ULOG_START("GruposWriter::LimpaFluxoFaseGrupo()");

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        long idFaseFluxo;
        long idFaseGrupoFechamentoWrk[500];

        long idContatoWrk = idContatoPrm;
        long idGrupoWrk = idGrupoPrm;
        long idTipoFchContatoWrk = idTipoFchContatoPrm;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO Sql_Error( &sqlca );
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    memset(&idFaseGrupoFechamentoWrk,0L,sizeof(idFaseGrupoFechamentoWrk));

  EXEC SQL DECLARE LimpaFluxo CURSOR FOR
        SELECT
            IDFASEGRUPOFECHAMENTO
        FROM
            CONTATOADM.FASEGRUPOFECHAMENTO
        WHERE
            IDCONTATO = :idContatoWrk
        AND
            IDGRUPO   = :idGrupoWrk
        AND
            IDTIPOFECHAMENTOCONTATO = :idTipoFchContatoWrk;

    EXEC SQL OPEN LimpaFluxo;

    int i = 0;
    for ( ;; )
  {
        EXEC SQL FETCH LimpaFluxo INTO :idFaseFluxo;

        if ( idFaseFluxo != 0L )
            idFaseGrupoFechamentoWrk[i++] = idFaseFluxo;
        
        idFaseFluxo = 0L;
    }    

    EXEC SQL CLOSE LimpaFluxo;

    if ( idFaseGrupoFechamentoWrk[0] == 0L )
    {
        ULOG( "LimpaFluxoFaseGrupo Executou com Sucesso, nao encontrou registros..." );
        ULOG_END("GruposWriter::LimpaFluxoFaseGrupo()");   
        return 1;
    }

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        DELETE FROM 
           CONTATOADM.FECHAMENTOTIPOLINHA
        WHERE
           IDFASEGRUPOFECHAMENTO = :idFaseGrupoFechamentoWrk;

    EXEC SQL
        DELETE FROM 
           CONTATOADM.FECHAMENTOTIPOPESSOA
        WHERE
           IDFASEGRUPOFECHAMENTO = :idFaseGrupoFechamentoWrk;

    EXEC SQL
        DELETE FROM 
           CONTATOADM.FECHAMENTOTPCARTEIRA
        WHERE
           IDFASEGRUPOFECHAMENTO = :idFaseGrupoFechamentoWrk;

    EXEC SQL
        DELETE FROM 
           CONTATOADM.FECHAMENTOTPRELACIONAMENTO
        WHERE
           IDFASEGRUPOFECHAMENTO = :idFaseGrupoFechamentoWrk;

    EXEC SQL
        DELETE FROM 
           CONTATOADM.FECHAMENTOSEGMENTACAO
        WHERE
           IDFASEGRUPOFECHAMENTO = :idFaseGrupoFechamentoWrk;

    EXEC SQL
        DELETE FROM 
           CONTATOADM.FASEGRUPOFECHAMENTO
        WHERE
            IDFASEGRUPOFECHAMENTO = :idFaseGrupoFechamentoWrk;

    ULOG_END("GruposWriter::LimpaFluxoFaseGrupo()");   
    return 1;

}

//Se um contato perder o grupo, entao ele perde a associacao de skill
int GruposWriter::CleanSkill(long idContatoParam,
                             long *idTipoSequenciaArrParam,
                             long *idGrupoArrParam ) const
{
    ULOG_START("GruposWriter::CleanSkill()");   

    INITIALIZE_SQL;

  EXEC SQL BEGIN DECLARE SECTION;
    long idContato = idContatoParam;
    long idTipoSequencia;
    long idGrupo;
    int iTemOutraSequencia = 0;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR GOTO GotoCleanSkill;
  EXEC SQL WHENEVER NOT FOUND DO CONTINUE;

    for( int x = 0 ;; x++ )
    {
        if ( idGrupoArrParam[x] == END_ARRAY )
            break;

        idGrupo = idGrupoArrParam[x];
        idTipoSequencia = idTipoSequenciaArrParam[x];
        
    //Tendo o idGrupo, idContato e idTipoSequencia verifico
    //se existe configuracao do mesmo grupo e contato para outra
    //sequencia
        EXEC SQL
        SELECT
          COUNT(1)
        INTO
          :iTemOutraSequencia
        FROM
          CONTATOADM.CONTATOGRUPO CONTATOGRUPO,
          CONTATOADM.SEQUENCIA
        WHERE
          CONTATOGRUPO.IDCONTATOGRUPO = SEQUENCIA.IDCONTATOGRUPO
        AND
          SEQUENCIA.IDTIPOSEQUENCIA IN ( 2, 3 )
        AND
          SEQUENCIA.IDTIPOSEQUENCIA IN
        ( 
          SELECT IDTIPOSEQUENCIA 
          FROM CONTATOADM.SEQUENCIA, CONTATOADM.CONTATOGRUPO
          WHERE CONTATOGRUPO.IDGRUPO = :idGrupo
          AND CONTATOGRUPO.IDCONTATO = :idContato
        )
        AND
            SEQUENCIA.IDTIPOSEQUENCIA != :idTipoSequencia
      AND
        CONTATOGRUPO.IDCONTATO = :idContato
      AND
        CONTATOGRUPO.IDGRUPO = :idGrupo;

    //Se a verificacao indicou que existe uma sequencia diferente da achada
    //atraves de idGrupo, idContato e idTipoSequencia, entao nao pode perder os Skills
      if( !iTemOutraSequencia )
      {
        //Todas as relacoes daquele contato com os skills daquele grupo
        EXEC SQL
        DELETE FROM
          ACESSO.CONTATOGRUPOSKILL
        WHERE
          IDCONTATO = :idContato
        AND
          IDGRUPOSKILL IN 
          ( 
            SELECT IDGRUPOSKILL 
            FROM ACESSO.GRUPOSKILL
            WHERE IDGRUPO = :idGrupo
          );
          
        //Verifica se algum skill ficou sem contato, se ficou então apaga os usuários tambem
        EXEC SQL
        DELETE FROM
          ACESSO.USUARIOGRUPOSKILL
        WHERE
          IDGRUPOSKILL IN 
          (
            SELECT IDGRUPOSKILL 
            FROM   ACESSO.GRUPOSKILL GS
            WHERE  GS.IDGRUPO = :idGrupo
                    AND    GS.IDGRUPOSKILL NOT IN 
                           ( 
                              SELECT IDGRUPOSKILL 
                              FROM ACESSO.CONTATOGRUPOSKILL CGS 
                              WHERE CGS.IDGRUPOSKILL = GS.IDGRUPOSKILL 
                              AND ROWNUM < 2 
                           )
          );
          
      }//if( !iTemOutraSequencia )
    }//for( int x = 0 ;; x++ )

  
  ULOG_END("GruposWriter::CleanSkill()");   
Exit:
  return 1;

GotoCleanSkill:
    throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

void Sql_Error( sqlca * sqlca )
{
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]"
                              ,sqlca->sqlcode
                              ,sqlca->sqlerrm.sqlerrmc);

    throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
