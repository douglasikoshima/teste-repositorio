#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <sqlda.h>
#include <tuxfw.h>
#include <string>



int ConsultaRetorno( const char *idContatoParam , XMLGen *Saida )
{
    ULOG_START("ConsultaRetorno()");

    struct sqlca sqlca;
    sqlca.sqlcode=0 ;
    
    EXEC SQL BEGIN DECLARE SECTION;

        VARCHAR ORA_nmTipoRetorno[256];
        unsigned long ORA_idTipoRetorno;
        unsigned long ORA_idContato = atol( idContatoParam );
        int isContatoMC1;
        char *cPesquisa;
        short  ORA_i_nmTipoRetorno;

        int numRegs = 0;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL
        SELECT
            COUNT(1)
        INTO
            :numRegs
        FROM
            ATENDIMENTO.SEQUENCIAV01
        WHERE
            IDTIPOSEQUENCIA = 3 // FASE RETORNO
          AND
            IDCONTATO = :ORA_idContato
          AND
            DTEXCLUSAOSEQ IS NULL
          AND
            DTEXCLUSAOGRP IS NULL
          AND
            ROWNUM < 2;

    EXEC SQL
        SELECT
            COUNT(1)
        INTO
            :isContatoMC1
        FROM
            CONTATOADM.CONTATOFOLHA 
        WHERE
            IDCONTATO = :ORA_idContato
        AND
            SGFLUXOATENDIMENTO = 'MC1';

    ULOG("   idContato=%d",ORA_idContato);
    ULOG("     numRegs=%d",numRegs);
    ULOG("isContatoMC1=%d",isContatoMC1);

    // Se o contato não tiver grupo associado na fase RETORNO na árvore de contato, então
    // não é permitido que o usuário configure variáveis para tipo de retorno de contato
    // = SEM RETORNO.
    // Para maiores detalhes, vide a última versão do DES
    // 'BUG_3271_DES - Atualizada Gestão de Processos - Fase Retorno.doc'
    //
    // Se for contato tipo MC1 este não pode ser configurado para retorno por grupo de retorno
    // Cassio -- Dez/2009
    //
    if ( !numRegs || 1==isContatoMC1 )
    {
        cPesquisa = 
            "SELECT IDTIPORETORNOCONTATO,NMTIPORETORNOCONTATO"
             " FROM CONTATOADM.TIPORETORNOCONTATO"
            " WHERE IDTIPORETORNOCONTATO IN (1,3)"
            " ORDER BY UPPER(NMTIPORETORNOCONTATO)";
    }
    else
    { // caso contrário, apresenta todos os tipos de retorno que podem ser associados à
      // variáveis.
        cPesquisa = 
                "SELECT IDTIPORETORNOCONTATO,NMTIPORETORNOCONTATO"
                 " FROM CONTATOADM.TIPORETORNOCONTATO"
                " WHERE IDTIPORETORNOCONTATO BETWEEN 1 AND 3"
                " ORDER BY UPPER(NMTIPORETORNOCONTATO)";
    }

    EXEC SQL WHENEVER SQLERROR GOTO UndefinedError;

    EXEC SQL PREPARE qPesquisa FROM :cPesquisa;
    EXEC SQL DECLARE ReadTipoRetorno CURSOR FOR qPesquisa;
    EXEC SQL OPEN ReadTipoRetorno;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    for( ;; )
    {
        ORA_i_nmTipoRetorno = -1;

        EXEC SQL FETCH ReadTipoRetorno INTO :ORA_idTipoRetorno, 
                                            :ORA_nmTipoRetorno:ORA_i_nmTipoRetorno;

        if ( ORA_i_nmTipoRetorno < 0 )
            ORA_nmTipoRetorno.arr[0] = 0x0;
        else
            ORA_nmTipoRetorno.arr[ ORA_nmTipoRetorno.len ] = 0x0;

        Saida->createTag( "AdmTipoRetornoVO" );
            Saida->addItem( "idTipoRetorno",ORA_idTipoRetorno );
            Saida->addItem( "nmTipoRetorno",(char*)ORA_nmTipoRetorno.arr );
        Saida->closeTag();
    }

    EXEC SQL CLOSE ReadTipoRetorno;

    ULOG_START("ConsultaRetorno()");

    return 1;

UndefinedError:
        throw new TuxBasicOraException( sqlca.sqlcode,
                                        sqlca.sqlerrm.sqlerrmc,
                                        sqlca.sqlerrm.sqlerrml );

}

