/*****************************************************************************
 *
 * Modulo:    CUsr
 * Arquivo:   CUsr.cpp
 * Proposito: Funcao de Negocios 
 * Historico:
 * Data        Autor                 Descricao
 * ----------  --------------------  -----------------------------------------
 * 18/05/2004  C_RECOliveira         Criacao
 * 18/05/2004  C_EDMartins           Criacao
 *
 ****************************************************************************/
/**************************************************************************
 * Notas:
 *
 **************************************************************************/

//Definicao Global
#define CUsrCPP

//Header
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
#include <tuxfw.h>
#include "CUsr.h"
#include "CSafePointer.h"

#define CONVIND(O,I) \
{ \
	if (I == -1) { \
		##O.arr[0]=0; \
	} else { \
		##O.arr[##O.len]=0; \
	} \
}

/* #include "../../../atendimento/servico/AtendimentoGerarXMLDPR/include/cWFAtendimentoGerarXMLDPR.h" */

#include <iostream>
#include <string>
using namespace std;

void CUsr::RemoveNaoNumero( char* cDestino, const char* cOrigem )
{
	long iAux = 0;
	if( strlennull( cOrigem ) > 0 )
	{
        int lenOrigem = strlennull( cOrigem );

		for( unsigned long x = 0; x < lenOrigem; x++ )
		{
			if( ( cOrigem[x] >= '0' ) && ( cOrigem[x] <= '9' ) )
			{
				cDestino[iAux] = cOrigem[x];
				iAux++;
			}
		}
	}
	cDestino[iAux] = 0;
}
void CUsr::RemoveEspecial( char* cDestino, const char* cOrigem )
{
	long iAux = 0;
	if( strlennull( cOrigem ) > 0 )
	{
        int lenOrigem = strlennull( cOrigem );

		for( unsigned long x = 0; x < lenOrigem; x++ )
		{
			if( ( ( cOrigem[x] >= '0' ) && ( cOrigem[x] <= '9' ) ) ||
				( ( cOrigem[x] >= 'a' ) && ( cOrigem[x] <= 'z' ) ) ||
				( ( cOrigem[x] >= 'A' ) && ( cOrigem[x] <= 'Z' ) )  )
			{
				cDestino[iAux] = cOrigem[x];
				iAux++;
			}
		}
	}
}

char* CUsr::RTrim(char *pszString)
{
    long iLen;

    iLen=strlennull(pszString);

    for(;;)
    {
        if(pszString[iLen-1] != ' ')
            break;

        iLen--;

        if(iLen == 0)
            break;
    }
    pszString[iLen] = 0x00;

	return pszString;
}

int CUsr::UpdateSessaoUsuario(char* clogin, char* cdsSessaoUsuario)
{
	ULOG_START("CUsr::UpdateSessaoUsuario()");	
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cloginAux = clogin;
		char* cdsSessaoUsuarioAux = cdsSessaoUsuario;		
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;

	//Atualiza um registro
	EXEC SQL 
	UPDATE
		ACESSO.USUARIO
	SET
	   DSSESSAOUSUARIO = :cdsSessaoUsuarioAux
	WHERE
	   NMLOGINUSUARIO = :cloginAux;
    ULOG_END("CUsr::UpdateSessaoUsuario()");	
	return 0;

GotoUpdate:
	if(sqlca.sqlcode == -1)
	{
		ULOG_END("CUsr::UpdateSessaoUsuario()");	
		return -1;
	}
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::UsrImnRelacao(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CUsr::UsrImnRelacao()");	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		long idPessoaUsuario;
		long idSubSistema;

		struct Tstruct {
			long idItemMenu;
			char cnmItem[256];
		} tstruct;

		struct Tstructindicator {
			short sidItemMenu, snmItem;
		} tstructindicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	memset( &tstruct, 0, sizeof(Tstruct));
	memset( &tstructindicator, 0, sizeof(Tstructindicator));

	char *pcIdUsuario = oSafePointer.getTag(dnode,"idUsuario",0);
	char *pcIdSubSistema = oSafePointer.getTag(dnode,"idSubSistema",0);

	//Se o ID estiver vazio entao retornar com codigo de erro
	if( strlennull( pcIdUsuario ) <= 0 )
	{
		ULOG_END("CUsr::UsrImnRelacao()");	
		return 1;
	}
	if( strlennull( pcIdSubSistema ) <= 0 )
	{
		ULOG_END("CUsr::UsrImnRelacao()");	
		return 2;
	}

	//Le os IDs
	idPessoaUsuario = atol( pcIdUsuario );
	idSubSistema = atol( pcIdSubSistema );

	sqlca.sqlcode=0;

	EXEC SQL 
		DECLARE 
			tvcursorexistentes1 CURSOR FOR
		SELECT 
			ITEMMENU.IDITEMMENU, 
			ITEMMENU.NMITEM
		FROM 
			ACESSO.ITEMMENUPAGINAV01 ITEMMENU
		WHERE 
			ITEMMENU.INVISIBILIDADE = 1
		AND
			ITEMMENU.IDSUBSISTEMA = :idSubSistema
		AND 
			ITEMMENU.IDITEMMENU NOT IN 
			(
				SELECT 
					USUARIOITEMMENU.IDITEMMENU
				FROM 
					ACESSO.USUARIOITEMMENU USUARIOITEMMENU,
					ACESSO.ITEMMENU ITEMMENU2
				WHERE 
					ITEMMENU2.IDITEMMENU = USUARIOITEMMENU.IDITEMMENU
				AND
					ITEMMENU2.INVISIBILIDADE = 1
				AND
					USUARIOITEMMENU.IDPESSOAUSUARIO = :idPessoaUsuario
				AND 
					ITEMMENU2.IDSUBSISTEMA = :idSubSistema
			)
		ORDER BY
			ITEMMENU.NMITEM;

	EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	EXEC SQL WHENEVER NOT FOUND DO break;

	xml_g->createTag("ListaItensMenuVO");
	xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" ); 


	xml_g->createTag("ItensExistentes");
	EXEC SQL OPEN tvcursorexistentes1;
	for(;;) {
		EXEC SQL FETCH tvcursorexistentes1 INTO :tstruct INDICATOR :tstructindicator;
		xml_g->createTag("ItemMenuExistentesVO");
		xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
		xml_g->addItem("idItemMenu",tstruct.idItemMenu);
		xml_g->addItem("nmMenu",RTrim(tstruct.cnmItem));
		xml_g->closeTag();
	}
	EXEC SQL CLOSE tvcursorexistentes1;
	xml_g->closeTag();//ItensExistentes

	EXEC SQL 
	DECLARE 
		tvcursorrelacionados1 CURSOR FOR
	SELECT 
		ITEMMENU.IDITEMMENU,
		ITEMMENU.NMITEM
	FROM 
		ACESSO.USUARIOITEMMENU USUARIOITEMMENU,
        ACESSO.ITEMMENU ITEMMENU
	WHERE
        ITEMMENU.IDITEMMENU = USUARIOITEMMENU.IDITEMMENU
    AND
		ITEMMENU.INVISIBILIDADE = 1
	AND 
		ITEMMENU.IDSUBSISTEMA = :idSubSistema
	AND
		USUARIOITEMMENU.IDPESSOAUSUARIO = :idPessoaUsuario
	ORDER BY
		ITEMMENU.NMITEM;

    xml_g->createTag("ItensMenuRelacionados");
	EXEC SQL OPEN tvcursorrelacionados1;
	for(;;) {
		EXEC SQL FETCH tvcursorrelacionados1 INTO :tstruct INDICATOR :tstructindicator;
		xml_g->createTag("ItemMenuExistentesVO");
		xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
		xml_g->addItem("idItemMenu",tstruct.idItemMenu);
		xml_g->addItem("nmMenu",RTrim(tstruct.cnmItem));
		xml_g->closeTag();
	}
	EXEC SQL CLOSE tvcursorrelacionados1;
	xml_g->closeTag();//ItensMenuRelacionados

	xml_g->closeTag();//ListaItensMenuVO

	ULOG_END("CUsr::UsrImnRelacao()");	
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::UsrListaPar(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CUsr::UsrListaPar()");	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;
	
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 
		struct Tstruct {
			long idUsuario; 
			char cnmUsuario[256];
		} tstruct;

		struct Tstructindicator {
			short sidUsuario, snmUsuario;
		} tstructindicator;

		char vcLike[256];
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		memset( &tstruct, 0, sizeof(Tstruct));
		memset( &tstructindicator, 0, sizeof(Tstructindicator));
	
		char *pc = oSafePointer.getTag(dnode,"dsUsuario",0);
		if ( pc == NULL ) {
			strcpy( tstruct.cnmUsuario, "" );
		} else {
			strcpy( tstruct.cnmUsuario, pc);
		}
		
		sqlca.sqlcode=0;
		
		if ( strlennull(tstruct.cnmUsuario)==0 ) {
	
			EXEC SQL DECLARE tsqlcursor2 CURSOR FOR
			SELECT idUsuario, nmUsuario 
			FROM acesso.Usuario
			ORDER BY nmUsuario;
	
			EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
			EXEC SQL OPEN tsqlcursor2;
			
			if(sqlca.sqlcode)
			{
				ULOG_END("CUsr::UsrListaPar()");	
				return 4;
			}
			else
			{
				EXEC SQL WHENEVER NOT FOUND DO break;
				xml_g->createTag("UsuariosUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				for(;;) {
					EXEC SQL FETCH tsqlcursor2 INTO :tstruct INDICATOR :tstructindicator;
					xml_g->createTag("UsuarioUsuarioVO");
					xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
					xml_g->addItem("idPessoaUsuario",tstruct.idUsuario);
					xml_g->addItem("dsUsuario",RTrim(tstruct.cnmUsuario));
					xml_g->closeTag();
				}
				xml_g->closeTag();
				EXEC SQL CLOSE tsqlcursor2;
			}
	
		} else {
			sprintf( vcLike, "%s%s", tstruct.cnmUsuario, "%" ); 
		
			EXEC SQL DECLARE tsqlcursor3 CURSOR FOR
			SELECT idUsuario, nmUsuario 
			FROM acesso.Usuario
			WHERE nmUsuario LIKE :vcLike
			ORDER BY nmUsuario;
	
			EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
			EXEC SQL OPEN tsqlcursor3;
			
			if(sqlca.sqlcode)
			{
				ULOG_END("CUsr::UsrListaPar()");
				return 4;
			}
			else
			{
				EXEC SQL WHENEVER NOT FOUND DO break;
				xml_g->createTag("UsuariosUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" ); 
				for(;;) {
					EXEC SQL FETCH tsqlcursor3 INTO :tstruct INDICATOR :tstructindicator;
					xml_g->createTag("UsuarioUsuarioVO");
					xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
					xml_g->addItem("idPessoaUsuario",tstruct.idUsuario);
					xml_g->addItem("dsUsuario",RTrim(tstruct.cnmUsuario));
					xml_g->closeTag();
				}
				xml_g->closeTag();
				EXEC SQL CLOSE tsqlcursor3;
			}
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CUsr::UsrListaPar()");	
	return 0;


//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::UsrLista(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CUsr::UsrLista()");	
	
	//Declarar Estruturas
	struct sqlca sqlca; 

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 
		struct Tstruct {
			long idUsuario; 
			char cnmUsuario[256];
		} tstruct;

		struct Tstructindicator {
			short sidUsuario, snmUsuario;
		} tstructindicator;

	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		
		memset( &tstruct, 0, sizeof(Tstruct));
		memset( &tstructindicator, 0, sizeof(Tstructindicator));
	
		sqlca.sqlcode=0;
		
		EXEC SQL 
			DECLARE 
				tsqlcursor4 CURSOR FOR
			SELECT 
				idUsuario, 
				nmUsuario 
			FROM 
				acesso.Usuario
			ORDER BY 
				nmUsuario;
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL OPEN tsqlcursor4;
		
		if(sqlca.sqlcode)
		{
			ULOG_END("CUsr::UsrLista()");
			return 4;
		}
		else
		{
			EXEC SQL WHENEVER NOT FOUND DO break;
			xml_g->createTag("UsuariosUsuarioVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" ); 
			for(;;) {
				EXEC SQL FETCH tsqlcursor4 INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("UsuarioUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idPessoaUsuario",tstruct.idUsuario);
				xml_g->addItem("dsUsuario",RTrim(tstruct.cnmUsuario));
				xml_g->closeTag();
			}
			xml_g->closeTag();
			EXEC SQL CLOSE tsqlcursor4;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CUsr::UsrLista()");	
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::UsrPrfRelaciona(DOMNode*dnode, XMLGen*xml_g,
				          char* cLogUser)
{
	ULOG_START("CUsr::UsrPrfRelaciona()");	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;

		struct Tstruct {
			long idUsuarioRole;
			long idPessoaUsuario;
			long idRole;
		} tstruct;

		struct Tstruct2 {
			long idRole;
			char cnmRole[256];
		} tstruct2;

		struct Tstructindicator {
			short sidUsuarioRole, sidPessoaUsuario, sidRole;
		} tstructindicator;

		struct Tstructindicator2 {
			short sidRole, snmRole;
		} tstructindicator2;

		long iAcumulador;

	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		memset( &tstruct, 0, sizeof(Tstruct) );
		memset( &tstruct2, 0, sizeof(Tstruct2) );
		memset( &tstructindicator, 0, sizeof(Tstructindicator) );
		memset( &tstructindicator2, 0, sizeof(Tstructindicator2) );
	
		//Pega o idPessoaUsuario que sera utilizado na ralacao
		if ( ( tstruct.idPessoaUsuario = atol( oSafePointer.getTag( dnode, "idUsuario", 0  ) ) )  <= 0 ) 
		{
			ULOG_END("CUsr::UsrPrfRelaciona()");	
			return 3;//idUsuario esta nulo
		}
	
		sqlca.sqlcode=0;
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
		EXEC SQL 
		SELECT COUNT(idPessoaUsuario)
		INTO :iAcumulador
		FROM acesso.UsuarioRole
		WHERE idPessoaUsuario = :tstruct.idPessoaUsuario;
	
		ULOG( "*** Passou 1" );
        //Antes de inserir as novas relacoes, deve-se apagar todas, se existirem
		if (iAcumulador>0) {
			EXEC SQL 
			DELETE FROM acesso.UsuarioRole 
			WHERE idPessoaUsuario = :tstruct.idPessoaUsuario;
		    ULOG( "*** deletou acesso.UsuarioRole" );
		}
	
		//Verifica se o comando DELETE obteve sucesso
		if(sqlca.sqlcode == 0 )
		{
		    ULOG( "*** Passou 2" );
			char* pc;
	
			//Pega todos os idRole que existem no XML e insere
			for(long indice=0;;indice++) 
			{
	
				pc = oSafePointer.getTag( dnode, "idPerfil", indice  );
				if ( strlennull( pc ) == 0 )
					break;

				tstruct.idRole = atoi( pc );
	
				sqlca.sqlcode=0;
	
				EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
				EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
				//Pega um id unico e sequencia para a insercao
				EXEC SQL
				SELECT acesso.UsuarioRolesq.nextval
				INTO :tstruct.idUsuarioRole
				FROM dual;
	
				//Insere item a item
                ULOG( "*** Vai inserir em ACESSO.USUARIOROLE" );
                ULOG( "*** idUsuarioRole [%ld] idPessoaUsuario [%ld] idRole [%ld] cLogUserOra [%s]", tstruct.idUsuarioRole, tstruct.idPessoaUsuario, tstruct.idRole, cLogUserOra );
				EXEC SQL 
					INSERT INTO ACESSO.USUARIOROLE 
					( 
						IDUSUARIOROLE, 
						IDPESSOAUSUARIO, 
						IDROLE, 
						IDUSUARIOALTERACAO, 
						DTULTIMAALTERACAO )
				VALUES
					( 
						:tstruct.idUsuarioRole, 
						:tstruct.idPessoaUsuario, 
						:tstruct.idRole, 
						TO_NUMBER(:cLogUserOra),
						SYSDATE );
	
				//Se der algum erro, desfaz tudo
                
                ULOG( "*** sqlca.sqlcode [%d]", sqlca.sqlcode );
                
				if(sqlca.sqlcode)
				{
					ULOG_END("CUsr::UsrPrfRelaciona()");	
					return 2;//Falha na insercao de perfis relacionados
				}
			}//for( indice=1;;indice++) 
		}// if(sqlca.sqlcode == 0 )
		else
		{
			ULOG_END("CUsr::UsrPrfRelaciona()");	
			return 1;//Erro ao tentar limpar a lista de perfis relacionados
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CUsr::UsrPrfRelaciona()");	
	return 0;//Sucesso

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::UsrGrpRelacao(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CUsr::UsrGrpRelacao()");	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;

		long idPessoaUsuario;
        long idUsuario;

        long v_idGrupo;
        VARCHAR v_nmGrupo[256];
        int     v_inSupervisor;
        
        short   i_v_idGrupo = -1;
        short   i_v_nmGrupo = -1;
        short   i_v_inSupervisor = -1;

		struct Tstruct {
			long idGrupo;
			char cnmGrupo[256];
		} tstruct;

		struct Tstructindicator {
			short sidGrupo, snmRole;
		} tstructindicator;

		struct Tstruct2 {
			long idGrupo;
			char cnmGrupo[256];
			char cinSupervisor[256];
		} tstruct2;

		struct Tstructindicator2 {
			short sidGrupo, snmRole,sinSupervisor;
		} tstructindicator2;

	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		memset( &tstruct, 0, sizeof(Tstruct));
		memset( &tstructindicator, 0, sizeof(Tstructindicator));
		memset( &tstruct2, 0, sizeof(Tstruct2));
		memset( &tstructindicator2, 0, sizeof(Tstructindicator2));
        
        memset( &v_nmGrupo, 0x0, sizeof(v_nmGrupo) );
        
	
		char *pc = oSafePointer.getTag(dnode,"idUsuario",0);
	
		//Se o ID estiver vazio entao retornar com codigo de erro
		if ( strlennull( pc ) == 0 ) {
			ULOG_END("CUsr::UsrGrpRelacao()");	
			return 3;
		}
	
		//Le a descricao de Grupo
		idPessoaUsuario = atol( pc );
        idUsuario = atol( pc );
        
		sqlca.sqlcode=0;
	
	
		EXEC SQL 
			DECLARE 
				tvcursorexistentes2 CURSOR FOR
			SELECT 
				GRUPO.IDGRUPO, 
				GRUPO.NMGRUPO
			FROM 
				ACESSO.GRUPO GRUPO
			WHERE 
				GRUPO.IDGRUPO NOT IN 
				(
					SELECT USUARIOGRUPO.IDGRUPO
                      FROM ACESSO.GRUPO GRUPO,
                       ACESSO.USUARIO USUARIO,
                       ACESSO.USUARIOGRUPO USUARIOGRUPO
                 WHERE USUARIOGRUPO.IDGRUPO = GRUPO.IDGRUPO
                   AND USUARIOGRUPO.IDPESSOAUSUARIO = USUARIO.IDPESSOAUSUARIO
                   AND USUARIO.IDPESSOAUSUARIO = :idPessoaUsuario
				)
			AND
				GRUPO.IDGRUPO > 0
			AND                           
				GRUPO.DTEXCLUSAO IS NULL
			ORDER BY
				UPPER(GRUPO.NMGRUPO);
				
				
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	
		if(sqlca.sqlcode)
		{
            ULOG( "@@@ Saindo com ERRO 4" );
            ULOG_END("CUsr::UsrGrpRelacao()");	
            return 4;
        }
        else
        {
            EXEC SQL WHENEVER NOT FOUND DO break;
            xml_g->createTag("RelacionarUsuarioGrupoVO");
            xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" ); 
            xml_g->addItem("idUsuario",idPessoaUsuario);
            EXEC SQL OPEN tvcursorexistentes2;
            xml_g->createTag("GruposExistentes");
            for(;;) 
            {
                EXEC SQL FETCH tvcursorexistentes2 INTO :tstruct INDICATOR :tstructindicator;
                xml_g->createTag("GrupoUsuarioVO");
                xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
                xml_g->addItem("idGrupo",tstruct.idGrupo);
                xml_g->addItem("dsGrupo",RTrim(tstruct.cnmGrupo));
                xml_g->closeTag();
            }
            xml_g->closeTag();
            
            EXEC SQL CLOSE tvcursorexistentes2;
			
            ULOG( "*** idUsuario [%ld]", idUsuario );
            
            EXEC SQL 
            DECLARE 
            tvcursorrelacionados2 CURSOR for
            SELECT 
                   USUARIOGRUPO.IDGRUPO, 
                   GRUPO.NMGRUPO, 
                   USUARIOGRUPO.INSUPERVISOR
              FROM 
                   ACESSO.GRUPO GRUPO,
                   ACESSO.USUARIO USUARIO,
                   ACESSO.USUARIOGRUPO USUARIOGRUPO
             WHERE 
                   USUARIOGRUPO.IDGRUPO = GRUPO.IDGRUPO
               AND USUARIOGRUPO.IDPESSOAUSUARIO = USUARIO.IDPESSOAUSUARIO
               AND USUARIO.IDPESSOAUSUARIO = :idUsuario
               AND USUARIOGRUPO.IDGRUPO > 0
               AND GRUPO.DTEXCLUSAO IS NULL
            ORDER BY
                   UPPER(GRUPO.NMGRUPO);

            ULOG( "### Abrindo CURSOR de Relacionados..." );
            
            EXEC SQL OPEN tvcursorrelacionados2;
            
            ULOG( "### Abriu CURSOR de Relacionados..." );
            
			xml_g->createTag("GruposRelacionados");
			for(;;) 
            {
				EXEC SQL FETCH tvcursorrelacionados2 
                INTO :v_idGrupo:i_v_idGrupo ,
                     :v_nmGrupo:i_v_nmGrupo ,
                     :v_inSupervisor:i_v_inSupervisor ;
                
                CONVIND(v_nmGrupo,i_v_nmGrupo);
                
                ULOG( "### Leu v_idGrupo [%ld] - v_nmGrupo [%s] - v_inSupervisor [%d]", v_idGrupo, (char*)v_nmGrupo.arr, v_inSupervisor );
                
				xml_g->createTag("GrupoUsuarioVO");
                xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
                    xml_g->addItem("idGrupo", v_idGrupo );
                    xml_g->addItem("dsGrupo", (char*)v_nmGrupo.arr );
                    xml_g->addItem("inSupervisor", v_inSupervisor );
				xml_g->closeTag();
			}
			xml_g->closeTag();
            
            ULOG( "*** Ao sair do LOOP de cursor [%d]", sqlca.sqlcode );
            
			EXEC SQL CLOSE tvcursorrelacionados2;

            ULOG( "### Fechou CURSOR de Relacionados..." );
            
			xml_g->closeTag();
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CUsr::UsrGrpRelacao()");	
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::UsrGrpRelaciona(DOMNode*dnode, XMLGen*xml_g, char* cLogUser)
{
	ULOG_START("CUsr::UsrGrpRelaciona()");	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;

		struct Tstruct {
			long idUsuarioGrupo;
			long idPessoaUsuario;
			long idGrupo;
		} tstruct;

		struct Tstruct2 {
			long idGrupo;
			char cnmGrupo[256];
		} tstruct2;

		struct Tstructindicator {
			short sidUsuarioGrupo, sidPessoaUsuario, sidGrupo;
		} tstructindicator;

		struct Tstructindicator2 {
			short sidGrupo, snmGrupo;
		} tstructindicator2;

		long iAcumulador;

	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		memset( &tstruct, 0, sizeof(Tstruct) );
		memset( &tstruct2, 0, sizeof(Tstruct2) );
		memset( &tstructindicator, 0, sizeof(Tstructindicator) );
		memset( &tstructindicator2, 0, sizeof(Tstructindicator2) );
	
		//Pega o idPessoaUsuario que sera utilizado na ralacao
		if ( ( tstruct.idPessoaUsuario = atol( oSafePointer.getTag( dnode, "idUsuario", 0  ) ) )  <= 0 ) 
		{
			ULOG_END("CUsr::UsrGrpRelaciona()");	
			return 3;//idUsuario esta nulo
		}
	
		sqlca.sqlcode=0;
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
		EXEC SQL 
		SELECT COUNT(idPessoaUsuario)
		INTO :iAcumulador
		FROM acesso.UsuarioGrupo
		WHERE idPessoaUsuario = :tstruct.idPessoaUsuario;
	
		//Antes de inserir as novas relacoes, deve-se apagar todas, se existirem
		if (iAcumulador>0) {
			EXEC SQL 
			DELETE FROM acesso.UsuarioGrupo 
			WHERE idPessoaUsuario = :tstruct.idPessoaUsuario;
		}
	
		//Verifica se o comando DELETE obteve sucesso
		if(sqlca.sqlcode == 0 )
		{
			char* pc;
	
			//Pega todos os idGrupo que existem no XML e insere
			for(long indice=0;;indice++) 
			{
	
				//Se tstruct.idGrupo for igual a zero, entao acabou os ids
				pc = oSafePointer.getTag( dnode, "idGrupo", indice  );
				if ( strlennull( pc ) == 0 )
					break;
	
				tstruct.idGrupo = atoi( pc );
	
				sqlca.sqlcode=0;
	
				EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
				EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
				//Pega um id unico e sequencia para a insercao
				EXEC SQL
				SELECT acesso.UsuarioGruposq.nextval
				INTO :tstruct.idUsuarioGrupo
				FROM dual;
	
				//Insere item a item
				EXEC SQL 
					INSERT INTO ACESSO.USUARIOGRUPO 
					( 
						IDUSUARIOGRUPO, 
						IDPESSOAUSUARIO, 
						IDGRUPO, 
						IDUSUARIOALTERACAO, 
						DTULTIMAALTERACAO )
				VALUES
					( 
						:tstruct.idUsuarioGrupo, 
						:tstruct.idPessoaUsuario, 
						:tstruct.idGrupo, 
						TO_NUMBER(:cLogUserOra),
						SYSDATE );
	
				//Se der algum erro, desfaz tudo
				if(sqlca.sqlcode)
				{
					ULOG_END("CUsr::UsrGrpRelaciona()");
					return 2;//Falha na insercao de grupos relacionados
				}
					
			}//for( indice=1;;indice++) 
		}// if(sqlca.sqlcode == 0 )
		else
		{
			ULOG_END("CUsr::UsrGrpRelaciona()");
			return 1;//Falha ao tentar limpar os grupos relacionados
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CUsr::UsrGrpRelaciona()");
	return 0;//Sucesso

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::UsrImnRelaciona(DOMNode*dnode, XMLGen*xml_g, char* cLogUser)
{
	ULOG_START("CUsr::UsrImnRelaciona()");
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;
		char* cIdSubSistema;
        char* pc;

		struct Tstruct {
			long idUsuarioItemMenu;
			long idPessoaUsuario;
			long idItemMenu;
		} tstruct;

		struct Tstructindicator {
			short sidUsuarioItemMenu, sidPessoaUsuario, sidItemMenu;
		} tstructindicator;

		long iAcumulador;

	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		memset( &tstruct, 0, sizeof(Tstruct) );
		memset( &tstructindicator, 0, sizeof(Tstructindicator) );
	
		//Pega o idPessoaUsuario que sera utilizado na ralacao
		if ( ( tstruct.idPessoaUsuario = atol( oSafePointer.getTag( dnode, "idUsuario", 0  ) ) )  <= 0 ) 
		{
			ULOG_END("CUsr::UsrImnRelaciona()");
			return 3;//idUsuario esta nulo
		}

		cIdSubSistema = oSafePointer.getTag( dnode, "idSubSistema", 0  );
		if( strlennull( cIdSubSistema ) <= 0 )
		{
			ULOG_END("CUsr::UsrImnRelaciona()");
			return 4;//IdSubSistema esta nulo
		}
	
		sqlca.sqlcode=0;
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
		EXEC SQL 
			SELECT 
				COUNT(USUARIOITEMMENU.IDPESSOAUSUARIO)
			INTO 
				:iAcumulador
			FROM 
	          ACESSO.USUARIO USUARIO,		  
	          ACESSO.USUARIOITEMMENU USUARIOITEMMENU,
			  ACESSO.SUBSISTEMA SUBSISTEMA,
	          ACESSO.ITEMMENU ITEMMENU
			WHERE
				    USUARIOITEMMENU.IDITEMMENU = ITEMMENU.IDITEMMENU
  			    AND USUARIOITEMMENU.IDPESSOAUSUARIO = USUARIO.IDPESSOAUSUARIO
				AND ITEMMENU.IDSUBSISTEMA = SUBSISTEMA.IDSUBSISTEMA 
				AND	SUBSISTEMA.IDSUBSISTEMA = :cIdSubSistema
				AND	USUARIOITEMMENU.IDPESSOAUSUARIO = :tstruct.idPessoaUsuario;
/*				
			SELECT 
				COUNT(IDPESSOAUSUARIO)
			INTO 
				:iAcumulador
			FROM 
				ACESSO.USUARIOITEMMENUBZEROUM
			WHERE 
				IDSUBSISTEMA = :cIdSubSistema
			AND 
				IDPESSOAUSUARIO = :tstruct.idPessoaUsuario;				
*/
	
		//Antes de inserir as novas relacoes, deve-se apagar todas, se existirem
		if( iAcumulador > 0 ) 
		{
			EXEC SQL 
				DELETE FROM 
					ACESSO.USUARIOITEMMENU 
				WHERE 
					IDUSUARIOITEMMENU IN 
					(	
                    	SELECT 
                     	      USUARIOITEMMENU.IDUSUARIOITEMMENU
                         FROM 
                              CUSTOMER.PESSOA PESSOA,
                              ACESSO.USUARIO USUARIO,		  
                              ACESSO.USUARIOITEMMENU USUARIOITEMMENU,
                    		  ACESSO.SUBSISTEMA SUBSISTEMA,
                              ACESSO.ITEMMENU ITEMMENU
                        WHERE 
                    	      USUARIOITEMMENU.IDITEMMENU = ITEMMENU.IDITEMMENU
                          AND USUARIOITEMMENU.IDPESSOAUSUARIO = USUARIO.IDPESSOAUSUARIO
                    	  AND ITEMMENU.IDSUBSISTEMA = SUBSISTEMA.IDSUBSISTEMA 
                    	  AND USUARIO.IDPESSOAUSUARIO = PESSOA.IDPESSOA 
                      	  AND SUBSISTEMA.IDSUBSISTEMA = :cIdSubSistema
                     	  AND PESSOA.IDPESSOA = :tstruct.idPessoaUsuario
 	  /*
						SELECT 
							IDUSUARIOITEMMENU
			            FROM 
							ACESSO.USUARIOITEMMENUBZEROUM
						WHERE 
							IDSUBSISTEMA = :cIdSubSistema
						AND 
							IDPESSOA = :tstruct.idPessoaUsuario 
*/							
					);
		}//if( iAcumulador > 0 ) 
	
	
		//Pega todos os idItemMenu que existem no XML e insere
		for(long indice=0;;indice++) 
		{
			//Se tstruct.idItemMenu for igual a zero, entao acabou os ids
			pc = oSafePointer.getTag( dnode, "idItemMenu", indice  );
			if( strlennull( pc ) <= 0 )
				break;

			tstruct.idItemMenu = atoi( pc );

			//Pega um id unico e sequencia para a insercao
			EXEC SQL
			SELECT acesso.UsuarioItemMenusq.nextval
			INTO :tstruct.idUsuarioItemMenu
			FROM dual;

			//Insere item a item
			EXEC SQL 
				INSERT INTO ACESSO.USUARIOITEMMENU 
				( 
					IDUSUARIOITEMMENU, 
					IDPESSOAUSUARIO, 
					IDITEMMENU, 
					IDUSUARIOALTERACAO, 
					DTULTIMAALTERACAO )
			VALUES
				( 
					:tstruct.idUsuarioItemMenu, 
					:tstruct.idPessoaUsuario, 
					:tstruct.idItemMenu, 
					TO_NUMBER(:cLogUserOra),
					SYSDATE );

			//Se der algum erro, desfaz tudo
			if(sqlca.sqlcode)
			{
				ULOG_END("CUsr::UsrImnRelaciona()");
				return 2; //Erro ao tentar inserir item de menu relacionado
			}
				
		}//for(long indice=0;;indice++)
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CUsr::UsrImnRelaciona()");
	return 0;//Sucesso

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::UsrPrfRelacao(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CUsr::UsrPrfRelacao()");
	//Declarar Estruturas
	struct sqlca sqlca;

	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;

		long idPessoaUsuario;

		struct Tstruct {
			long idRole;
			char cnmRole[256];
		} tstruct;

		struct Tstructindicator {
			short sidRole, snmRole;
		} tstructindicator;

	EXEC SQL END DECLARE SECTION;
	try
	{
		memset( &tstruct, 0, sizeof(Tstruct));
		memset( &tstructindicator, 0, sizeof(Tstructindicator));
	
		char *pc;
	
		//Se o ID nao for numerico entao retornar com codigo de erro
		if ( ( pc = oSafePointer.getTag(dnode,"idUsuario",0) ) == NULL ) {
			ULOG_END("CUsr::UsrPrfRelacao()");
			return 2;
		}
	
		//Se o ID estiver vazio entao retornar com codigo de erro
		if ( strlennull( pc ) == 0 ) {
			ULOG_END("CUsr::UsrPrfRelacao()");
			return 3;
		}
	
		//Le a descricao de Usuario
		idPessoaUsuario = atol( pc );
	
		sqlca.sqlcode=0;
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CUsr::UsrPrfRelacao()");
			return 4;
		}
		else
		{
            EXEC SQL 
			DECLARE 
				tvcursorexistentes3 CURSOR FOR
			SELECT 
				ACESSO.ROLE.IDROLE, ACESSO.ROLE.NMROLE
			FROM 
				ACESSO.ROLE
			WHERE 
				ACESSO.ROLE.IDROLE NOT IN 
				(
                    SELECT USUARIOROLE.IDROLE 
                      FROM ACESSO.ROLE ROLE,
                           ACESSO.USUARIO USUARIO,
                           ACESSO.USUARIOROLE USUARIOROLE
                     WHERE USUARIOROLE.IDPESSOAUSUARIO = USUARIO.IDPESSOAUSUARIO
                       AND USUARIOROLE.IDROLE = ROLE.IDROLE
                       AND USUARIOROLE.IDPESSOAUSUARIO = :idPessoaUsuario
				)
			ORDER BY
				UPPER(NMROLE);

            xml_g->createTag("RelacionarUsuarioPerfilVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" ); 
			xml_g->addItem("idUsuario",idPessoaUsuario);
			EXEC SQL OPEN tvcursorexistentes3;
			xml_g->createTag("PerfisExistentes");
			for(;;) {
				EXEC SQL FETCH tvcursorexistentes3 INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("PerfilUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idPerfil",tstruct.idRole);
				xml_g->addItem("dsPerfil",RTrim(tstruct.cnmRole));
				xml_g->closeTag();
			}
			xml_g->closeTag();
			EXEC SQL CLOSE tvcursorexistentes3;

		EXEC SQL 
			DECLARE 
				tvcursorrelacionados3 CURSOR FOR
            SELECT USUARIOROLE.IDROLE, 
            	   ROLE.NMROLE
              FROM ACESSO.ROLE ROLE,
                   ACESSO.USUARIO USUARIO,
                   ACESSO.USUARIOROLE USUARIOROLE
             WHERE USUARIOROLE.IDPESSOAUSUARIO = USUARIO.IDPESSOAUSUARIO
               AND USUARIOROLE.IDROLE = ROLE.IDROLE
               and USUARIOROLE.IDPESSOAUSUARIO = :idPessoaUsuario
            ORDER BY UPPER(ROLE.NMROLE);

            EXEC SQL OPEN tvcursorrelacionados3;
			xml_g->createTag("PerfisRelacionados");
			for(;;) {
				EXEC SQL FETCH tvcursorrelacionados3 INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("PerfilUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idPerfil",tstruct.idRole);
				xml_g->addItem("dsPerfil",RTrim(tstruct.cnmRole));
				xml_g->closeTag();
			}
			xml_g->closeTag();
			EXEC SQL CLOSE tvcursorrelacionados3;
			xml_g->closeTag();
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CUsr::UsrPrfRelacao()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::UsrEditar( const char* cidUsuario     
				    ,const char* cemail         
                    ,const char* cidDDD         
                    ,const char* cdsTelefone    
                    ,const char* clogin         
                    ,const char* cloginCti      
                    ,const char* cidStatusAtual 
                    ,const char* cidMotivo
                    ,const char* cloginChefe
                    ,const char* cinConsultor
					,const char* cidUFOperadora
                    ,const char* cLogUser
                    ,const char* cidPerfilConsultorAtd
                    ,const char* cidFornecedorConsultorAtd
                    ,const char* cidSiteConsultorAtd
                    ,const char* cdsLoginRoteamento
                    )
{
	ULOG_START("CUsr::UsrEditar()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		const char* cLogUserOra = cLogUser;
		const char* cAuxidUsuario = cidUsuario;
		const char* cAuxemail = cemail;
		const char* cAuxidDDD = cidDDD;
		const char* cAuxlogin = clogin;
		const char* cAuxloginCti = cloginCti;
		const char* cAuxidStatusAtual = cidStatusAtual;
		const char* cAuxidMotivo = cidMotivo;
		const char* cAuxloginChefe = cloginChefe;
		const char* cAuxidUFOperadora = cidUFOperadora;
        const char* cAuxidPerfilConsultorAtd = cidPerfilConsultorAtd;
        const char* cAuxidFornecedorConsultorAtd = cidFornecedorConsultorAtd;
        const char* cAuxidSiteConsultorAtd = cidSiteConsultorAtd;
        const char* cAuxdsLoginRoteamento = cdsLoginRoteamento;

		char  cAuxdsTelefone[21+1];
		char  cAuxinConsultor[21+1];

		long  iStatus = 0;
		short sStatus = 0;
        short cStatidPerfilConsultorAtd = cAuxidPerfilConsultorAtd==0?-1:0;
        short cStatidFornecedorConsultorAtd = cAuxidFornecedorConsultorAtd==0?-1:0;
        short cStatidSiteConsultorAtd = cAuxidSiteConsultorAtd==0?-1:0;
        short cStatdsLoginRoteamento = cAuxdsLoginRoteamento==0?-1:0;

	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	memset( cAuxinConsultor, 0, sizeof( cAuxinConsultor ) );
	memset( cAuxdsTelefone, 0, sizeof( cAuxdsTelefone ) );
	if( strlennull( cinConsultor ) <= 0 )
		strcpy( cAuxinConsultor, "0" );
	else
		strcpy( cAuxinConsultor, cinConsultor );

	RemoveNaoNumero( cAuxdsTelefone, cdsTelefone );

	EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	sqlca.sqlcode=0;

/*
Inicio das verificacoes necessarias pra workflow, metodos sedidos por Renato Teixeira
*/		
	//Verifica se o usuario esta sendo ativo ou nao
	EXEC SQL
		SELECT
			DECODE( UPPER(SGSTATUSUSUARIO), 'ATIVO', 1, 0 ) STATUS
		INTO
			:iStatus:sStatus
        FROM
            APOIO.STATUSUSUARIO
		WHERE
			IDSTATUSUSUARIO = :cAuxidStatusAtual;

	if( iStatus == 0 )
	{
		removeAtendimentos( cLogUserOra,cAuxidUsuario );
        // removeAtendimentos() acima acumulou esta operação também, pois no 
        // modelo a chamada abaixo estava gerando lock.
		// removeUsuarioDevolucao( cLogUserOra,cAuxidUsuario );
	}

	EXEC SQL
		UPDATE 
			ACESSO.USUARIO
		SET 
		    NMLOGINUSUARIO           = :cAuxlogin,
		    NMLOGINUSUARIOCTI        = :cAuxloginCti,
		    IDSTATUSUSUARIO          = :cAuxidStatusAtual,
		    DTSTATUSUSUARIO          = SYSDATE,
		    IDUSUARIOALTERACAO       = TO_NUMBER(:cLogUserOra),
		    DTULTIMAALTERACAO        = SYSDATE,
		    DSEMAIL                  = :cAuxemail,
		    NRTELEFONE               = :cAuxdsTelefone,
		    IDAREAREGISTRO           = :cAuxidDDD,
		    INCONSULTOR              = :cAuxinConsultor,
			IDUFOPERADORA            = :cAuxidUFOperadora,
			INDISPONIVELWF           = :iStatus,
            IDPERFILCONSULTORATD     = :cAuxidPerfilConsultorAtd:cStatidPerfilConsultorAtd,
            IDFORNECEDORCONSULTORATD = :cAuxidFornecedorConsultorAtd:cStatidFornecedorConsultorAtd,
            IDSITECONSULTORATD       = :cAuxidSiteConsultorAtd:cStatidSiteConsultorAtd,
            DSLOGINROTEAMENTO        = :cAuxdsLoginRoteamento:cStatdsLoginRoteamento
		WHERE
		 	IDPESSOAUSUARIO = :cAuxidUsuario;

	if(sqlca.sqlcode)
	{
		strcpy( cErro, "Erro ao tentar efetuar o UPDATE" );
		ULOG_END("CUsr::UsrEditar()");
		return 0;
	}
	//Insere o chefe
	if( InsertChefeLogin( cAuxidUsuario
		                 ,cAuxloginChefe
		                 ,cLogUserOra ) != 0 )
	{
		ULOG_END("CUsr::UsrEditar()");
		return 2;//Este metodo ja gera uma mensagem de erro
	}
	ULOG_END("CUsr::UsrEditar()");
	return 1;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::UsrUfoRelacao(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CUsr::UsrUfoRelacao()");
	//Declarar Estruturas
	struct sqlca sqlca;

	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;

		char idPessoaUsuario[64];
        long lUsuario;
        long lUsuarioXML;
        long lUsuarioExistentes;
        
        int idUFOperadora;
        short i_idUFOperadora = -1;
        
        VARCHAR nmOperadora[256];
        short i_nmOperadora = -1;

		struct Tstruct {
			long idUFOperadora;
			char cnmUFOperadora[256];
		} tstruct;

		struct Tstructindicator {
			short sidUFOperadora, snmUFOperadora;
		} tstructindicator;

	EXEC SQL END DECLARE SECTION;
	try
	{
		memset( idPessoaUsuario, 0, sizeof(idPessoaUsuario));
		memset( &tstruct, 0, sizeof(Tstruct));
		memset( &tstructindicator, 0, sizeof(Tstructindicator));
	
		char *pc = oSafePointer.getTag(dnode,"idUsuario",0);
	
		//Se o ID estiver vazio entao retornar com codigo de erro
		if ( strlennull( pc ) == 0 ) {
			ULOG_END("CUsr::UsrUfoRelacao()");
			return 3;
		}
	
		//Le a descricao de Usuario
		
        //idPessoaUsuario = atol( pc );
        strcpy(idPessoaUsuario,pc);
        lUsuario = atol( pc );
        lUsuarioXML = atol( pc );
        lUsuarioExistentes = atol( pc );
	
		sqlca.sqlcode=0;

		EXEC SQL 
			DECLARE 
				tvcursorexistentes4 CURSOR FOR
			SELECT 
				UFOPERADORA.IDUFOPERADORA, 
				UF.SGUF || ' - ' ||GRUPOOPERADORA.NMGRUPOOPERADORA
			FROM 
				CUSTOMER.UFOPERADORA UFOPERADORA,
				CUSTOMER.OPERADORA OPERADORA,
				CUSTOMER.GRUPOOPERADORA GRUPOOPERADORA,
				APOIO.UF UF
			WHERE
				 UFOPERADORA.IDPESSOADEPARAOPERADORA=OPERADORA.IDPESSOADEPARAOPERADORA
			AND 
				OPERADORA.IDGRUPOOPERADORA=GRUPOOPERADORA.IDGRUPOOPERADORA
			AND
			    UFOPERADORA.IDUF=UF.IDUF
			AND
				UFOPERADORA.IDUFOPERADORA NOT IN 
				( 
					SELECT 
						USUARIOUFOPERADORA.IDUFOPERADORA
					FROM 
						ACESSO.USUARIOUFOPERADORA
					WHERE 
						ACESSO.USUARIOUFOPERADORA.IDPESSOAUSUARIO = :idPessoaUsuario
				)
		ORDER BY
				UF.SGUF, 
				GRUPOOPERADORA.NMGRUPOOPERADORA;

			
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CUsr::UsrUfoRelacao()");
			return 4;
		}
		else
		{
			xml_g->createTag("RelacionarUsuarioOperadoraVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" ); 
			xml_g->addItem("idUsuario",idPessoaUsuario);
			EXEC SQL OPEN tvcursorexistentes4;
			xml_g->createTag("OperadorasExistentes");
			for(;;) {
				EXEC SQL FETCH tvcursorexistentes4 INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("OperadoraUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idOperadora",tstruct.idUFOperadora);
				xml_g->addItem("dsOperadora",RTrim(tstruct.cnmUFOperadora));
				xml_g->closeTag();
                memset( &tstruct, 0, sizeof(Tstruct));
                memset( &tstructindicator, 0, sizeof(Tstructindicator));
			}
			xml_g->closeTag();
			EXEC SQL CLOSE tvcursorexistentes4;
            
            EXEC SQL 
                DECLARE 
                    tvcursorrelacionados4 CURSOR FOR
            SELECT 
                    UFOPERADORA.IDUFOPERADORA, 
                    UF.SGUF || ' - ' ||GRUPOOPERADORA.NMGRUPOOPERADORA
                FROM 
                    CUSTOMER.UFOPERADORA UFOPERADORA,
                    CUSTOMER.OPERADORA OPERADORA,
                    CUSTOMER.GRUPOOPERADORA GRUPOOPERADORA,
                    APOIO.UF UF
                WHERE
                     UFOPERADORA.IDPESSOADEPARAOPERADORA=OPERADORA.IDPESSOADEPARAOPERADORA
                AND 
                    OPERADORA.IDGRUPOOPERADORA=GRUPOOPERADORA.IDGRUPOOPERADORA
                AND
                    UFOPERADORA.IDUF=UF.IDUF
                AND
                    UFOPERADORA.IDUFOPERADORA IN 
                    ( 
                        SELECT 
                            USUARIOUFOPERADORA.IDUFOPERADORA
                        FROM 
                            ACESSO.USUARIOUFOPERADORA
                        WHERE 
                            ACESSO.USUARIOUFOPERADORA.IDPESSOAUSUARIO = :idPessoaUsuario
                    )
            ORDER BY
                    UF.SGUF, 
                    GRUPOOPERADORA.NMGRUPOOPERADORA;

			EXEC SQL OPEN tvcursorrelacionados4;
			xml_g->createTag("OperadorasRelacionadas");
			for(;;) {
				EXEC SQL FETCH tvcursorrelacionados4 INTO :idUFOperadora:i_idUFOperadora ,
                                                          :nmOperadora:i_nmOperadora ;
                
                CONVIND( nmOperadora,i_nmOperadora );

				xml_g->createTag("OperadoraUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem( "idOperadora",idUFOperadora );
				xml_g->addItem( "dsOperadora",(char*)nmOperadora.arr);
				xml_g->closeTag();
                memset( &nmOperadora, 0x0, sizeof(nmOperadora));
                i_nmOperadora = i_idUFOperadora = -1;
			}
			xml_g->closeTag();
			EXEC SQL CLOSE tvcursorrelacionados4;
			xml_g->closeTag();
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CUsr::UsrUfoRelacao()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}


int CUsr::UsrUfoRelaciona(DOMNode*dnode, XMLGen*xml_g, char* cLogUser)
{
	ULOG_START("CUsr::UsrUfoRelaciona()");
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;
		char* pc;

		struct Tstruct {
			long idUsuarioUFOperadora;
			char* cidPessoaUsuario;
			long idUFOperadora;
		} tstruct;

		struct Tstructindicator {
			short sidUsuarioUFOperadora, sidPessoaUsuario, sidUFOperadora;
		} tstructindicator;

		long iAcumulador;

	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		memset( &tstruct, 0, sizeof(Tstruct) );
		memset( &tstructindicator, 0, sizeof(Tstructindicator) );
	
		//Pega o idPessoaUsuario que sera utilizado na ralacao
		tstruct.cidPessoaUsuario = oSafePointer.getTag( dnode, "idUsuario", 0 );
		if ( strlennull( tstruct.cidPessoaUsuario )  <= 0 ) 
		{
			ULOG_END("CUsr::UsrUfoRelaciona()");
			return 3;//idUsuario esta nulo
		}
	
		sqlca.sqlcode=0;
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
		//Se o primeiro idOperadora nao existir, entao todos serao apagados, eh necessario
		//verificar se o usuario esta ativo
		pc = oSafePointer.getTag( dnode, "idOperadora", 0  );
		if( strlennull( pc ) <= 0 )
		{
			//Soh verifica se usuario estiver ativo
			if( !MesmoStatusSigla( tstruct.cidPessoaUsuario, "DESLIGADO" ) )
			{
				ULOG_END("CUsr::UsrUfoRelaciona()");
				return 4;
			}
		}

		EXEC SQL 
		SELECT COUNT(1)
		INTO :iAcumulador
		FROM acesso.UsuarioUFOperadora
		WHERE idPessoaUsuario = :tstruct.cidPessoaUsuario;

		//Antes de inserir as novas relacoes, deve-se apagar todas, se existirem
		if (iAcumulador>0) {
			EXEC SQL 
			DELETE FROM acesso.UsuarioUFOperadora 
			WHERE idPessoaUsuario = :tstruct.cidPessoaUsuario;
		}
	
		//Verifica se o comando DELETE obteve sucesso
		if(sqlca.sqlcode == 0 )
		{
			//Pega todos os idUFOperadora que existem no XML e insere
			for(long indice=0;;indice++) 
			{
	
				//Se tstruct.idUFOperadora for igual a zero, entao acabou os ids
				pc = oSafePointer.getTag( dnode, "idOperadora", indice  );
				if ( strlennull( pc ) == 0 )
					break;
	
				tstruct.idUFOperadora = atoi( pc );
	
				sqlca.sqlcode=0;
	
				EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
				EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
				//Pega um id unico e sequencia para a insercao
				EXEC SQL
				SELECT acesso.UsuarioUFOperadorasq.nextval
				INTO :tstruct.idUsuarioUFOperadora
				FROM dual;
	
				//Insere item a item
				EXEC SQL 
					INSERT INTO ACESSO.USUARIOUFOPERADORA 
					( 
						IDUSUARIOUFOPERADORA, 
						IDPESSOAUSUARIO, 
						IDUFOPERADORA, 
						IDUSUARIOALTERACAO, 
						DTULTIMAALTERACAO 
					)
				VALUES
					( 
						:tstruct.idUsuarioUFOperadora, 
						:tstruct.cidPessoaUsuario, 
						:tstruct.idUFOperadora, 
						TO_NUMBER(:cLogUserOra),
						SYSDATE 
					);
	
				//Se der algum erro, desfaz tudo
				if(sqlca.sqlcode)
				{
					ULOG_END("CUsr::UsrUfoRelaciona()");
					return 2; //Erro na insecao de UFOperadora
				}
			}//for( indice=1;;indice++) 
		}// if(sqlca.sqlcode == 0 )
		else
		{
			ULOG_END("CUsr::UsrUfoRelaciona()");
			return 1;//Falha na exclusao de UFOperadoras relacionadas
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CUsr::UsrUfoRelaciona()");
	return 0;//Sucesso

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::UsrInserir(DOMNode*dnode,XMLGen*xml_g,
				     char* cLogUser)
{
	ULOG_START("CUsr::UsrInserir()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;

		struct Tstruct { 
			long idUsuario;
			char cnmUsuario[256];
		} tstruct;

		struct Tstructindicator {
			short sidUsuario, snmUsuario;
		} tstructindicator;

		long iAcumulador;

	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Se nao encontrar a proxima TAG entao acabaram os registros para alterar
		for( long indice=0; ; indice++ ) { 
	
			memset( &tstruct, 0, sizeof(Tstruct) );
		
			//Se a DESCRICAO nao existir entao retornar com codigo de erro
			strcpy( tstruct.cnmUsuario, oSafePointer.getTag(dnode,"dsUsuario",indice) ); 
			if ( tstruct.cnmUsuario == NULL )
			{
				//EXEC SQL COMMIT WORK;
				break;
			}
	
			//Se a DESCRICAO estiver vazio entao retornar com codigo de erro
			if ( ( strlennull( tstruct.cnmUsuario ) == 0 ) )
			{
				//EXEC SQL ROLLBACK WORK; 
				ULOG_END("CUsr::UsrInserir()");
				return 3;
			}
	
			sqlca.sqlcode=0;
	
			EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
			EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
			//Conta os casos de ja existentes de descricao 
			EXEC SQL
			SELECT COUNT(idUsuario) 
			INTO :iAcumulador
			FROM acesso.Usuario
			WHERE nmUsuario = :tstruct.cnmUsuario;
	
			//Se nao houver o caso desta descricao entao pode Inserir
			if (iAcumulador==0) {
	
				//Pega um ID único 
				EXEC SQL
				SELECT acesso.Usuariosq.nextval
				INTO :tstruct.idUsuario
				FROM dual;
	
				//Insere o ID novo
				EXEC SQL 
					INSERT INTO ACESSO.USUARIO 
					( 
						IDUSUARIO, 
						NMUSUARIO, 
						IDUSUARIOALTERACAO, 
						DTULTIMAALTERACAO 
					)
				VALUES
					( 
						:tstruct.idUsuario, 
						SUBSTR(TRIM(:tstruct.cnmUsuario),1,255),
						TO_NUMBER(:cLogUserOra),
						SYSDATE 
					);
			}
	
			if(sqlca.sqlcode) { 
				ULOG_END("CUsr::UsrInserir()");
				//EXEC SQL ROLLBACK WORK; 
				return 4; 
			} 
		}
	
		EXEC SQL DECLARE tsqlcursor5 CURSOR FOR
		SELECT idUsuario, nmUsuario 
		FROM acesso.Usuario
		ORDER BY nmUsuario;
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL OPEN tsqlcursor5;
		
		if(sqlca.sqlcode)
		{
			ULOG_END("CUsr::UsrInserir()");
			return 4;
		}
		else
		{
			xml_g->createTag("UsuariosUsuarioVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				for(;;) {
				EXEC SQL FETCH tsqlcursor5 INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("UsuarioUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idPessoaUsuario",tstruct.idUsuario);
				xml_g->addItem("dsUsuario",tstruct.cnmUsuario);
				xml_g->closeTag();
			}
			xml_g->closeTag();
			EXEC SQL CLOSE tsqlcursor5;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CUsr::UsrInserir()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

/************************************************************************
 * Metodos Criados pelo Eder
 ************************************************************************/
CUsr::CUsr()
{
	ULOG_START("CUsr::CUsr()");
	Zerar();
	ULOG_END("CUsr::CUsr()");
}

CUsr::~CUsr()
{
}

int CUsr::ListId( char* cid )
{
	ULOG_START("CUsr::ListId()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidUsuario = cid;
		//Estrutura pra recuperar um registro
		struct {
			VARCHAR stidUsuario[21+1];
			VARCHAR stnome[255+1];
			VARCHAR stsobrenome[255+1];
			VARCHAR stemail[255+1];
			VARCHAR stidDDD[21+1];
			VARCHAR stdsDDD[255+1];
			VARCHAR stTelefone[255+1];
			VARCHAR stlogin[255+1];
			VARCHAR stloginCti[255+1];
			VARCHAR stidStatusAtual[21+1];
			VARCHAR stdescricaoStatusAtual[255+1];
			VARCHAR stdtInicio[255+1];
			VARCHAR stdtRetorno[255+1];
			VARCHAR stidUF[21+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stdtInclusao[255+1];
			VARCHAR stdtExclusao[255+1];
			VARCHAR stinConsultor[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stidPerfilConsultorAtd[10+1];
			VARCHAR stidFornecedorConsultorAtd[10+1];
			VARCHAR stidSiteConsultorAtd[10+1];
            VARCHAR stdsLoginRoteamento[10+1];
		} stRegUsuario;
		struct {                
			short iidUsuario;   
			short inome;        
			short isobrenome;                 
			short iemail;                     
			short iidDDD;                     
			short idsDDD;                     
			short iTelefone;                  
			short ilogin;                     
			short iloginCti;                  
			short iidStatusAtual;             
			short idescricaoStatusAtual;      
			short idtInicio;                  
			short idtRetorno;                 
			short iidUF;                    
			short inmUF;                    
			short idtInclusao;                
			short idtExclusao;     
			short iinConsultor;
			short iidUFOperadora;
			short iidPerfilConsultorAtd;
			short iidFornecedorConsultorAtd;
			short iidSiteConsultorAtd;
            short idsLoginRoteamento;
		} stindicatorRegUsuario;              
	EXEC SQL END DECLARE SECTION;
	          
	Zerar();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO ErrorListId;
	sqlca.sqlcode=0;
	
	//Retorna uma pessoas que SEJAM usuarios do sistema
	EXEC SQL
	DECLARE
		CursorUsuarioListaId CURSOR FOR
	SELECT
		 USUARIO.IDPESSOAUSUARIO
		,PESSOAUSUARIO.NMPESSOA
		,PESSOAUSUARIO.NMSOBRENOME
		,USUARIO.DSEMAIL
		,USUARIO.IDAREAREGISTRO
		,AREAREGISTRO.CDAREAREGISTRO
		,USUARIO.NRTELEFONE
		,USUARIO.NMLOGINUSUARIO
		,USUARIO.NMLOGINUSUARIOCTI
		,USUARIO.IDSTATUSUSUARIO
		,STATUSUSUARIO.DSSTATUSUSUARIO
		,PESSOAUSUARIO.DTCADASTRO
		,USUARIO.DTSTATUSUSUARIO
		,UF.IDUF
		,UF.NMUF
		,PESSOAUSUARIO.DTCADASTRO DTINICIO
		,USUARIO.DTSTATUSUSUARIO DTEXCLUSAO
		,USUARIO.INCONSULTOR
		,USUARIO.IDUFOPERADORA
        ,USUARIO.IDPERFILCONSULTORATD
        ,USUARIO.IDFORNECEDORCONSULTORATD
        ,USUARIO.IDSITECONSULTORATD
        ,USUARIO.DSLOGINROTEAMENTO
	FROM
		ACESSO.USUARIO USUARIO,
		ACESSO.USUARIOHIERARQUIA USUARIOHIERARQUIA,
		APOIO.STATUSUSUARIO STATUSUSUARIO,
		APOIO.AREAREGISTRO AREAREGISTRO,
		CUSTOMER.PESSOA PESSOAUSUARIO,
		APOIO.UF UF
	WHERE
		USUARIO.IDSTATUSUSUARIO = STATUSUSUARIO.IDSTATUSUSUARIO
	AND
		USUARIO.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
	AND
		USUARIO.IDPESSOAUSUARIO = USUARIOHIERARQUIA.IDPESSOAUSUARIO (+) // QUEBRA-GALHO PARA PRODUÇÃO
	AND
		USUARIO.IDPESSOAUSUARIO = PESSOAUSUARIO.IDPESSOA
	AND
		PESSOAUSUARIO.IDUF = UF.IDUF
	AND
		USUARIO.IDPESSOAUSUARIO = :cidUsuario;
		   	
	EXEC SQL OPEN CursorUsuarioListaId;

	for(;;)
	{
		memset( &stRegUsuario, 0, sizeof(stRegUsuario) );
		EXEC SQL
		FETCH 
			CursorUsuarioListaId 
		INTO 
			:stRegUsuario:stindicatorRegUsuario;
		
		Add( (char*)stRegUsuario.stidUsuario.arr
			,(char*)stRegUsuario.stnome.arr
			,(char*)stRegUsuario.stsobrenome.arr
			,(char*)stRegUsuario.stemail.arr
			,(char*)stRegUsuario.stidDDD.arr
			,(char*)stRegUsuario.stdsDDD.arr
			,(char*)stRegUsuario.stTelefone.arr
			,(char*)stRegUsuario.stlogin.arr
			,(char*)stRegUsuario.stloginCti.arr
			,(char*)stRegUsuario.stidStatusAtual.arr
			,(char*)stRegUsuario.stdescricaoStatusAtual.arr
			,""
			,""
			,(char*)stRegUsuario.stdtInicio.arr
			,(char*)stRegUsuario.stdtRetorno.arr
			,""
			,""
			,""
			,""
			,(char*)stRegUsuario.stidUF.arr
			,(char*)stRegUsuario.stnmUF.arr
			,(char*)stRegUsuario.stdtInclusao.arr
			,(char*)stRegUsuario.stdtExclusao.arr
			,(char*)stRegUsuario.stinConsultor.arr
			,(char*)stRegUsuario.stidUFOperadora.arr
            ,(char*)stRegUsuario.stidPerfilConsultorAtd.arr
            ,(char*)stRegUsuario.stidFornecedorConsultorAtd.arr
            ,(char*)stRegUsuario.stidSiteConsultorAtd.arr
            ,(char*)stRegUsuario.stdsLoginRoteamento.arr
		);
	}//for(;;)
	EXEC SQL CLOSE CursorUsuarioListaId;
    ULOG_END("CUsr::ListId()");
	return Quantidade();

ErrorListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CUsr::ListLogin( char* cLogin )
{
	ULOG_START("CUsr::ListLogin()");
	struct sqlca sqlca;
	long iCont = 0;
	EXEC SQL BEGIN DECLARE SECTION;
	char* cAuxLogin = cLogin;
	//Estrutura pra recuperar um registro
		struct {
			VARCHAR stidUsuario[21+1];
			VARCHAR stnome[255+1];
			VARCHAR stlogin[255+1];
			VARCHAR stloginCti[255+1];
			VARCHAR stloginChefe[255+1];
			VARCHAR stinConsultor[21+1];
			VARCHAR stidStatusAtual[21+1];
			VARCHAR stsiglaStatusAtual[255+1];
			VARCHAR stdescricaoStatusAtual[255+1];
			VARCHAR stidPerfilConsultorAtd[10+1];
			VARCHAR stidFornecedorConsultorAtd[10+1];
			VARCHAR stidSiteConsultorAtd[10+1];
            VARCHAR stdsLoginRoteamento[10+1];
			VARCHAR stdsFornecedorConsultorAtd[255+1];
			VARCHAR stdsSiteConsultorAtd[255+1];
		} stRegUsuario;

		struct {                
			short iidUsuario;   
			short inome;        
			short ilogin;                     
			short iloginCti;                  
			short iloginChefe;
			short iinConsultor;
			short iidStatusAtual;
			short isiglaStatusAtual;
			short idescricaoStatusAtual;
			short iidPerfilConsultorAtd;
			short iidFornecedorConsultorAtd;
			short iidSiteConsultorAtd;
            short idsLoginRoteamento;
            short idsFornecedorConsultorAtd;
            short idsSiteConsultorAtd;
		} stindicatorRegUsuario;              
	EXEC SQL END DECLARE SECTION;
	          
	try       
	{
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorListLogin;
		sqlca.sqlcode=0;
		
		//Retorna todas as pessoas que sao usuario
		EXEC SQL
			DECLARE
				CursorUsuarioListaLogin CURSOR FOR
			SELECT DISTINCT
			     PESSOA.IDPESSOA
			    ,PESSOA.NMPESSOA
			    ,USUARIO.NMLOGINUSUARIO
			    ,USUARIO.NMLOGINUSUARIOCTI
			    ,USUARIOCHEFE.NMLOGINUSUARIO NMLOGINUSUARIOCHEFE
			    ,USUARIO.INCONSULTOR
				,USUARIO.IDSTATUSUSUARIO
				,UPPER(STATUSUSUARIO.SGSTATUSUSUARIO)
				,STATUSUSUARIO.DSSTATUSUSUARIO
                ,USUARIO.IDPERFILCONSULTORATD
                ,USUARIO.IDFORNECEDORCONSULTORATD
                ,USUARIO.IDSITECONSULTORATD
                ,USUARIO.DSLOGINROTEAMENTO
                ,FORNECEDORCONSULTORATD.DSFORNECEDORCONSULTORATD
                ,SITECONSULTORATD.DSSITECONSULTORATD
			FROM 
			  	ACESSO.USUARIO USUARIO,
				CUSTOMER.PESSOA PESSOA,
                ACESSO.USUARIO USUARIOCHEFE,
                ACESSO.USUARIOHIERARQUIA USUARIOHIERARQUIA,
				APOIO.STATUSUSUARIO STATUSUSUARIO,
                APOIO.FORNECEDORCONSULTORATD FORNECEDORCONSULTORATD,
                APOIO.SITECONSULTORATD SITECONSULTORATD
			WHERE
				USUARIO.IDPESSOAUSUARIO = PESSOA.IDPESSOA
			AND USUARIO.IDSTATUSUSUARIO = STATUSUSUARIO.IDSTATUSUSUARIO
            AND USUARIO.IDPESSOAUSUARIO = USUARIOHIERARQUIA.IDPESSOAUSUARIO (+)
            AND USUARIOHIERARQUIA.IDPESSOAUSUARIOCHEFE = USUARIOCHEFE.IDPESSOAUSUARIO (+)
            AND USUARIO.IDFORNECEDORCONSULTORATD = FORNECEDORCONSULTORATD.IDFORNECEDORCONSULTORATD (+)
            AND USUARIO.IDSITECONSULTORATD = SITECONSULTORATD.IDSITECONSULTORATD (+)
			AND USUARIO.NMLOGINUSUARIO = :cAuxLogin;

		EXEC SQL OPEN CursorUsuarioListaLogin;

		if(sqlca.sqlcode)
		{
			strcpy( cErro, "Falha na pesquisa de LOGIN" );
			ULOG_END("CUsr::ListLogin()");
			return 0;
		}

		for(iCont = 0;;iCont++)
		{
			memset( &stRegUsuario, 0, sizeof(stRegUsuario) );
			EXEC SQL FETCH CursorUsuarioListaLogin INTO :stRegUsuario:stindicatorRegUsuario;
			
			Add( (char*)stRegUsuario.stidUsuario.arr
			    ,(char*)stRegUsuario.stnome.arr
			    ,(char*)stRegUsuario.stlogin.arr
			    ,(char*)stRegUsuario.stloginCti.arr
			    ,(char*)stRegUsuario.stloginChefe.arr
			    ,(char*)stRegUsuario.stinConsultor.arr 
			    ,(char*)stRegUsuario.stidStatusAtual.arr 
			    ,(char*)stRegUsuario.stsiglaStatusAtual.arr 
			    ,(char*)stRegUsuario.stdescricaoStatusAtual.arr 
			    ,(char*)stRegUsuario.stidPerfilConsultorAtd.arr
			    ,(char*)stRegUsuario.stidFornecedorConsultorAtd.arr
			    ,(char*)stRegUsuario.stidSiteConsultorAtd.arr
                ,(char*)stRegUsuario.stdsLoginRoteamento.arr
                ,(char*)stRegUsuario.stdsFornecedorConsultorAtd.arr
                ,(char*)stRegUsuario.stdsSiteConsultorAtd.arr
				);
		}//for(iCont = 0;;iCont++)
		EXEC SQL CLOSE CursorUsuarioListaLogin;
	}
	catch(...)
	{
		throw;
	}
	if( iCont <= 0 )
	{
		sprintf( cErro, "LOGIN [%s] não foi encontrado", cLogin );
		ULOG_END("CUsr::ListLogin()");
		return 0;
	}
	else
		sprintf( cErro, "[%s]: %s", cLogin, Registro()->cdescricaoStatusAtual );
    ULOG_END("CUsr::ListLogin()");
	return iCont;

ErrorListLogin:
	throw TuxBasicOraException(sqlca.sqlcode);

}

bool CUsr::VerificaRebaixamentoPerfil(const char* cLogin, const char *cidPerfilConsultorAtdAtual)
{
	ULOG_START("CUsr::VerificaRebaixamentoPerfil()");

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	    const char* cAuxLogin = cLogin;
        const char* cAuxIdPerfilConsultorAtdAtual = cidPerfilConsultorAtdAtual;

        int varOraCount=0;

	EXEC SQL END DECLARE SECTION;
	          
	try       
	{
	
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorRbxYN;

		sqlca.sqlcode=0;

        EXEC SQL
            SELECT
                COUNT(1)
            INTO
                :varOraCount
            FROM
                ACESSO.USUARIO USUARIO,
                APOIO.PERFILCONSULTORATD PERFILCONSULTORATD,
                APOIO.PERFILCONSULTORATD PERFILCONSULTORATD2
            WHERE
                USUARIO.IDPESSOAUSUARIO = :cAuxLogin
            AND NVL(USUARIO.IDPERFILCONSULTORATD,'VIVO') = PERFILCONSULTORATD.IDPERFILCONSULTORATD
            AND PERFILCONSULTORATD2.IDPERFILCONSULTORATD = :cAuxIdPerfilConsultorAtdAtual
            AND PERFILCONSULTORATD2.NRPESOHIERARQUIA >= PERFILCONSULTORATD.NRPESOHIERARQUIA;

        // se o perfil esta sendo "rebaixado" então verifica se tem alguém abaixo do usuário
        if ( varOraCount == 0 )
        {
            EXEC SQL
                SELECT
                    COUNT(1)
                INTO
                    :varOraCount
                FROM
                    ACESSO.USUARIOHIERARQUIA USUARIOHIERARQUIA
                WHERE
                    USUARIOHIERARQUIA.IDPESSOAUSUARIOCHEFE = :cAuxLogin
                AND USUARIOHIERARQUIA.IDPESSOAUSUARIOCHEFE <> USUARIOHIERARQUIA.IDPESSOAUSUARIO
                AND ROWNUM < 2;
            
            if ( varOraCount > 0 ) return false; // não pode rebaixar o usuario pq tem gente abaixo dele
        }
	}
	catch(...)
	{
		throw;
	}

	ULOG_END("CUsr::VerificaRebaixamentoPerfil()");

	return true;  // pode rebaixar o usuario pq não tem gente abaixo dele

ErrorRbxYN:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CUsr::ListLogin( char* cLogin, char* cidUsuario )
{
	ULOG_START("CUsr::ListLogin()");
	struct sqlca sqlca;
	long iCont = 0;
	EXEC SQL BEGIN DECLARE SECTION;
	char* cAuxLogin = cLogin;
	char* cAuxidUsuario = cidUsuario;
	//Estrutura pra recuperar um registro
		struct {
			VARCHAR stidUsuario[21+1];
			VARCHAR stnome[255+1];
			VARCHAR stlogin[255+1];
			VARCHAR stloginCti[255+1];
			VARCHAR stloginChefe[255+1];
			VARCHAR stinConsultor[21+1];
			VARCHAR stidPerfilConsultorAtd[10+1];
			VARCHAR stidFornecedorConsultorAtd[10+1];
			VARCHAR stidSiteConsultorAtd[10+1];
            VARCHAR stdsLoginRoteamento[10+1];
		} stRegUsuario;
		struct {                
			short iidUsuario;   
			short inome;        
			short ilogin;                     
			short iloginCti;                  
			short iloginChefe;
			short iinConsultor;
			short iidPerfilConsultorAtd;
			short iidFornecedorConsultorAtd;
			short iidSiteConsultorAtd;
            short idsLoginRoteamento;
		} stindicatorRegUsuario;              
	EXEC SQL END DECLARE SECTION;
	          
	try       
	{
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorListLogin2;
		sqlca.sqlcode=0;
		
		//Retorna todas as pessoas que sao usuario
		EXEC SQL
			DECLARE
				CursorUsuarioListaLogin2 CURSOR FOR
			SELECT DISTINCT
			     PESSOA.IDPESSOA
			    ,PESSOA.NMPESSOA
			    ,USUARIO.NMLOGINUSUARIO
			    ,USUARIO.NMLOGINUSUARIOCTI
			    ,USUARIOCHEFE.NMLOGINUSUARIO NMLOGINUSUARIOCHEFE
			    ,USUARIO.INCONSULTOR
			    ,USUARIO.IDPERFILCONSULTORATD
			    ,USUARIO.IDFORNECEDORCONSULTORATD
			    ,USUARIO.IDSITECONSULTORATD
                ,USUARIO.DSLOGINROTEAMENTO
			FROM 
			  	ACESSO.USUARIO USUARIO,
				CUSTOMER.PESSOA PESSOA,
                ACESSO.USUARIO USUARIOCHEFE,
                ACESSO.USUARIOHIERARQUIA USUARIOHIERARQUIA
			WHERE
				USUARIO.IDPESSOAUSUARIO = PESSOA.IDPESSOA
            AND
                USUARIO.IDPESSOAUSUARIO = USUARIOHIERARQUIA.IDPESSOAUSUARIO (+)
            AND
                USUARIOHIERARQUIA.IDPESSOAUSUARIOCHEFE = USUARIOCHEFE.IDPESSOAUSUARIO (+)
			AND
		   		USUARIO.NMLOGINUSUARIO = :cAuxLogin
			AND
				USUARIO.IDPESSOAUSUARIO <> :cAuxidUsuario;
		   		
		EXEC SQL OPEN CursorUsuarioListaLogin2;

		if(sqlca.sqlcode)
		{
			strcpy( cErro, "Falha na pesquisa de LOGIN" );
			ULOG_END("CUsr::ListLogin()");
			return 0;
		}
	
		for(iCont = 0;;)
		{
			memset( &stRegUsuario, 0, sizeof(stRegUsuario) );
			EXEC SQL FETCH CursorUsuarioListaLogin2 INTO :stRegUsuario:stindicatorRegUsuario;
			
			Add( (char*)stRegUsuario.stidUsuario.arr
			    ,(char*)stRegUsuario.stnome.arr
			    ,""
			    ,""
			    ,""
			    ,""
			    ,""
			    ,(char*)stRegUsuario.stlogin.arr
			    ,(char*)stRegUsuario.stloginCti.arr
			    ,""
			    ,""
			    ,""
			    ,""
			    ,""
			    ,""
			    ,""
			    ,""
			    ,(char*)stRegUsuario.stloginChefe.arr
			    ,""
			    ,""
			    ,""
			    ,""
			    ,""
			    ,(char*)stRegUsuario.stinConsultor.arr
				,""
				,(char*)stRegUsuario.stidPerfilConsultorAtd.arr
				,(char*)stRegUsuario.stidFornecedorConsultorAtd.arr
				,(char*)stRegUsuario.stidSiteConsultorAtd.arr
                ,(char*)stRegUsuario.stdsLoginRoteamento.arr);

				iCont++;
		}//for(iCont = 0;;)
		EXEC SQL CLOSE CursorUsuarioListaLogin2;
	}
	catch(...)
	{
		throw;
	}
	if( iCont <= 0 )
		sprintf( cErro, "LOGIN [%s] não foi encontrado", cLogin );

	ULOG_END("CUsr::ListLogin()");
	return iCont;

ErrorListLogin2:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CUsr::ListDoc( char* cnrDocumento )
{
	return 0;
}

int CUsr::ListCpf( char* cnrDocumento )
{
	return 0;
}

void CUsr::Zerar( void )
{
    ULOG_START("CUsr::Zerar()");
	memset( cErro, 0 , sizeof( cErro ) );
	memset( cContadorPagina, 0 , sizeof( cContadorPagina ) );
	iProximaPagina = 0;
	iTamanhoPagina = 0;
	ZeraUsuario();
	ULOG_END("CUsr::Zerar()");
}

int CUsr::InsertPessoa( char* cidUF
		               ,char* cnome
					   ,char* cnomemeio
		               ,char* csobrenome
					   ,char* cidUser )
{
	ULOG_START("CUsr::InsertPessoa()");
	struct sqlca sqlca;
	long    iRet = 0;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR stidPessoa[255+1];
		VARCHAR stidPessoaDePara[21+1];
		VARCHAR stidSistemaOrigem[255+1];
		VARCHAR stidTipoPessoa[255+1];
		VARCHAR stidTipoCarteira[21+1];

        char cAuxNmPessoa[256];
		char* cAuxidUF      = cidUF;
		char* cAuxnome      = cnome;
		char* cAuxnomemeio  = cnomemeio;
		char* cAuxsobrenome = csobrenome;
		char* cLogUser	    = cidUser;
	EXEC SQL END DECLARE SECTION;

	Zerar();

	memset( cErro, 0, sizeof( cErro ) );
	memset( &stidPessoa, 0, sizeof( stidPessoa ) );
	memset( &stidTipoPessoa, 0, sizeof( stidTipoPessoa ) );
	memset( &stidSistemaOrigem, 0, sizeof( stidSistemaOrigem ) );
	memset( &stidTipoCarteira, 0, sizeof( stidTipoCarteira ) );
	memset( &stidPessoaDePara, 0, sizeof( stidPessoaDePara ) );

    strcpy(cAuxNmPessoa,cnome);

    if ( cnomemeio && *cnomemeio )
    {
        strcat(cAuxNmPessoa," ");
        strcat(cAuxNmPessoa,cnomemeio);
    }

    if ( csobrenome && *csobrenome )
    {
        strcat(cAuxNmPessoa," ");
        strcat(cAuxNmPessoa,csobrenome);
    }

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO ErrorInsertPessoa;
	
	//Recupera o id de sistema origem
	EXEC SQL
		SELECT
			SISTEMAORIGEM.IDSISTEMAORIGEM 
		INTO
			:stidSistemaOrigem
		FROM
			APOIO.SISTEMAORIGEM SISTEMAORIGEM
		WHERE
			SISTEMAORIGEM.SGSISTEMAORIGEM = 'CACS';
	
	if(sqlca.sqlcode)
	{
		strcpy( cErro, "Não foi possível achar o APOIO.SISTEMAORIGEM: CACS" );
		ULOG( cErro ); 
		ULOG_END("CUsr::InsertPessoa()");
		return 0;
	}

	//Recupera o id de tipo de pessoa
	EXEC SQL
		SELECT 
			TIPOPESSOA.IDTIPOPESSOA
		INTO
			:stidTipoPessoa
		FROM
			APOIO.TIPOPESSOA TIPOPESSOA
		WHERE
			TIPOPESSOA.SGTIPOPESSOA = 'PF';
	
	if(sqlca.sqlcode)
	{
		strcpy( cErro, "Não foi possível achar APOIO.TIPOPESSOA: PF" );
		ULOG( cErro ); 
		ULOG_END("CUsr::InsertPessoa()");
		return 0;
	}
	
	EXEC SQL
	SELECT
		CUSTOMER.PESSOASQ.NEXTVAL
	INTO
		:stidPessoa
	FROM DUAL;
			
	if( ( sqlca.sqlcode) || ( stidPessoa.len <= 0 ) )
	{
		strcpy( cErro, "Falha na recuperação de sequência de CUSTOMER.PESSOA" );
		ULOG( cErro ); 
		ULOG_END("CUsr::InsertPessoa()");
		return 0;
	}
	
	//Recupera o id de tipo de carteira (nao classificado)
	ULOG( "Pesquisando UPPER(APOIO.TIPOCARTEIRA.SGTIPOCARTEIRA) = 'NC'" ); 

	EXEC SQL
	    SELECT
		    IDTIPOCARTEIRA
	    INTO
		    :stidTipoCarteira
	    FROM
		    APOIO.TIPOCARTEIRA
	    WHERE
		    UPPER(SGTIPOCARTEIRA) = 'NC'
	    AND
		    ROWNUM <= 1;

	if( stidTipoCarteira.len < 0 )
	{
		strcpy( (char*)stidTipoCarteira.arr, "0" );
		stidTipoCarteira.len = 1;
		ULOG( "Não foi achado SGTIPOCARTEIRA = 'NC'. Assumindo IDTIPOCARTEIRA = 0" ); 
	}

	//Insere a pessoa
	ULOG("Vai inserir em CUSTOMER.PESSOA.");

	EXEC SQL
	INSERT INTO CUSTOMER.PESSOA
	( 
		IDPESSOA
	   ,IDSISTEMAORIGEM
	   ,NMPESSOA
	   ,NMNOME
	   ,NMNOMEMEIO
	   ,NMSOBRENOME
	   ,DTCADASTRO
	   ,INFALECIMENTOINFORMADO
	   ,IDTIPOPESSOA
	   ,IDTIPOCARTEIRA
	   ,IDUF
       ,IDPROBINADIMPLENCIA
       ,IDCHURNPROBABILIDADE
       ,IDPESSOASISTEMAORIGEM
	   ,IDUSUARIOALTERACAO
	   ,DTULTIMAALTERACAO
	)
	VALUES
	( 
		:stidPessoa
	   ,:stidSistemaOrigem
	   ,SUBSTR(TRIM(:cAuxNmPessoa),1,255)
	   ,SUBSTR(TRIM(:cAuxnome),1,255)
	   ,SUBSTR(TRIM(:cAuxnomemeio),1,255)
	   ,SUBSTR(TRIM(:cAuxsobrenome),1,255)
	   ,SYSDATE //DTCADASTRO
	   ,0 //INFALECIMENTOINFORMADO
	   ,:stidTipoPessoa
	   ,:stidTipoCarteira //IDTIPOCARTEIRA
	   ,:cAuxidUF
	   ,0 //IDPROBINADIMPLENCIA
	   ,0 //IDCHURNPROBABILIDADE
	   ,:stidPessoa
	   ,TO_NUMBER(:cLogUser)
	   ,SYSDATE
	);

	ULOG("Vai obter sequence em CUSTOMER.PESSOADEPARA.");

	EXEC SQL
	SELECT
		CUSTOMER.PESSOADEPARASQ.NEXTVAL
	INTO
		:stidPessoaDePara
	FROM DUAL;

	if( ( sqlca.sqlcode) || ( stidPessoaDePara.len <= 0 ) )
	{
		strcpy( cErro, "Falha na recuperação de sequência de CUSTOMER.PESSOADEPARA" );
		ULOG( cErro );
		ULOG_END("CUsr::InsertPessoa()"); 
		return 0;
	}

	ULOG("Vai inserir em CUSTOMER.PESSOADEPARA.");
	//Insere em PessoaDePara
	EXEC SQL
	INSERT INTO 
		CUSTOMER.PESSOADEPARA
	( 
		IDPESSOADEPARA
	   ,IDPESSOA
	   ,IDPESSOAORIGEM
	   ,IDUSUARIOALTERACAO
	   ,DTULTIMAALTERACAO
	)
	VALUES
	( 
		:stidPessoaDePara
	   ,:stidPessoa
	   ,:stidPessoa
	   ,TO_NUMBER(:cLogUser)
	   ,SYSDATE
	);

	Add( (char*)stidPessoa.arr  // idUsuario
		,(char*)cAuxnome        // nome
		,(char*)cAuxsobrenome   // sobrenome
		,""                     // email
		,""                     // idDDD
		,""                     // dsDDD
		,""                     // Telefone
		,""                     // login
		,""                     // loginCti
		,""                     // idStatusAtual
		,""                     // descricaoStatusAtual
		,""                     // idMotivo
		,""                     // dsMotivo
		,""                     // dtInicio
		,""                     // dtRetorno
		,""                     // idCargoAtual
		,""                     // descricaoCargoAtual
		,""                     // loginChefe
		,""                     // nomeChefe
		,""                     // idUF
		,""                     // nmUF
		,""                     // dtInclusao
		,""                     // dtExclusao
		,""                     // inConsultor
		,""                     // idUFOperadora
		,""                     // idPerfilConsultorAtd
		,""                     // idFornecedorConsultorAtd
		,""                     // idSiteConsultorAtd
		,""                     // dsLoginRoteamento
	   );

	ULOG("Inserções executadas com sucesso.");

    ULOG_END("CUsr::InsertPessoa()");
	return 1;
	
ErrorInsertPessoa:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::EditPessoa( char* cidPessoa
					 ,char* cidUF
		             ,char* cnome
		             ,char* cnomemeio
		             ,char* csobrenome
					 ,char* cidUser )
{
	ULOG_START("CUsr::EditPessoa()");
	struct sqlca sqlca;
	long    iRet = 0;
	EXEC SQL BEGIN DECLARE SECTION;
        char cAuxNmPessoa[256];
		char* cAuxidPessoa  = cidPessoa;
		char* cAuxidUF      = cidUF;
		char* cAuxnome      = cnome;
		char* cNmNomeMeioAux  = cnomemeio;
		char* cAuxsobrenome = csobrenome;
		char* cLogUser	    = cidUser;
	EXEC SQL END DECLARE SECTION;

	Zerar();
	
	memset( cErro, 0, sizeof( cErro ) );

    strcpy(cAuxNmPessoa,cnome);

    if ( cnomemeio && *cnomemeio )
    {
        strcat(cAuxNmPessoa," ");
        strcat(cAuxNmPessoa,cnomemeio);
    }

    if ( csobrenome && *csobrenome )
    {
        strcat(cAuxNmPessoa," ");
        strcat(cAuxNmPessoa,csobrenome);
    }

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO ErrorEditPessoa;
	
	//Atualiza a pessoa
	EXEC SQL
	UPDATE CUSTOMER.PESSOA
	SET
		NMPESSOA = SUBSTR(TRIM(:cAuxNmPessoa),1,255)
	   ,NMNOME = SUBSTR(TRIM(:cAuxnome),1,255)
	   ,NMNOMEMEIO = SUBSTR(TRIM(:cNmNomeMeioAux),1,255)
	   ,NMSOBRENOME = SUBSTR(TRIM(:cAuxsobrenome),1,255)
	   ,IDUF = :cAuxidUF
	   ,IDUSUARIOALTERACAO = TO_NUMBER(:cLogUser)
	   ,DTULTIMAALTERACAO = SYSDATE
	WHERE
		IDPESSOA = :cAuxidPessoa;

    // Mantém nome do usuário sincronizado
	EXEC SQL
	UPDATE ACESSO.USUARIO
	SET
	    NMNOME = SUBSTR(TRIM(:cAuxnome),1,255)
	   ,NMNOMEMEIO = SUBSTR(TRIM(:cNmNomeMeioAux),1,255)
	   ,NMULTIMONOME = SUBSTR(TRIM(:cAuxsobrenome),1,255)
	   ,IDUSUARIOALTERACAO = TO_NUMBER(:cLogUser)
	   ,DTULTIMAALTERACAO = SYSDATE
	WHERE
		IDPESSOAUSUARIO = :cAuxidPessoa;

	Add( cAuxidPessoa       // idUsuario
		,cAuxnome           // nome
		,cAuxsobrenome      // sobrenome
		,""                 // email
		,""                 // idDDD
		,""                 // dsDDD
		,""                 // Telefone
		,""                 // login
		,""                 // loginCti
		,""                 // idStatusAtual
		,""                 // descricaoStatusAtual
		,""                 // idMotivo
		,""                 // dsMotivo
		,""                 // dtInicio
		,""                 // dtRetorno
		,""                 // idCargoAtual
		,""                 // descricaoCargoAtual
		,""                 // loginChefe
		,""                 // nomeChefe
		,""                 // idUF
		,""                 // nmUF
		,""                 // dtInclusao
		,""                 // dtExclusao
		,""                 // inConsultor
		,""                 // idUFOperadora
		,""                 // idPerfilConsultorAtd
		,""                 // idFornecedorConsultorAtd
		,""                 // idSiteConsultorAtd
		,""                 // dsLoginRoteamento
	   );
	ULOG_END("CUsr::EditPessoa()");
	return 1;
	
ErrorEditPessoa:
	throw TuxBasicOraException(sqlca.sqlcode);
}

void CUsr::GetXml( char* cNomeTag, XMLGen*xml )
{
	ULOG_START("CUsr::GetXml()");
	if( Quantidade() > 0 )
	{
		for( long x = 0; x < Quantidade(); x++ )
		{
			if( strlennull( cNomeTag ) > 0 )
			{
				xml->createTag(cNomeTag);
				xml->addProp(	"xmlns", "usuario.fo.vivo.com.br/vo" );
			}
			if( Registro( x ) != NULL )
			{
				xml->addItem("idUsuario", Registro(x)->cidUsuario );
				xml->addItem("nome", Registro(x)->cnome );
				xml->addItem("sobrenome", Registro(x)->csobrenome );
				xml->addItem("email", Registro(x)->cemail );
				xml->addItem("idDDD", Registro(x)->cidDDD );
				xml->addItem("dsDDD", Registro(x)->cdsDDD );
				xml->addItem("Telefone", Registro(x)->cTelefone );
				xml->addItem("login", Registro(x)->clogin );
				xml->addItem("loginCti", Registro(x)->cloginCti );
				xml->addItem("idStatusAtual", Registro(x)->cidStatusAtual );
				xml->addItem("descricaoStatusAtual", Registro(x)->cdescricaoStatusAtual);
				xml->addItem("idMotivo", Registro(x)->cidMotivo );
				xml->addItem("dsMotivo", Registro(x)->cdsMotivo );
				xml->addItem("dtInicio", Registro(x)->cdtInicio );
				xml->addItem("dtRetorno", Registro(x)->cdtRetorno );
				xml->addItem("idCargoAtual", Registro(x)->cidCargoAtual );
				xml->addItem("descricaoCargoAtual", Registro(x)->cdescricaoCargoAtual );
				xml->addItem("loginChefe", Registro(x)->cloginChefe );
				xml->addItem("nomeChefe", Registro(x)->cnomeChefe );
				xml->addItem("idUF", Registro(x)->cidUF );
				xml->addItem("nmUF", Registro(x)->cnmUF );
				xml->addItem("dtInclusao", Registro(x)->cdtInclusao );
				xml->addItem("dtExclusao", Registro(x)->cdtExclusao);
				xml->addItem("inConsultor", Registro(x)->cinConsultor);
			}
			if( strlennull( cNomeTag ) > 0 )           
				xml->closeTag();                       
		}                                              
	}
	ULOG_END("CUsr::GetXml()");                                                  
}                                                      
                                                       
int CUsr::InsertUsuario( char* cidUsuario
                        ,char* cemail
	                    ,char* cidDDD
	                    ,char* cTelefone
	                    ,char* clogin
	                    ,char* cloginCti
	                    ,char* cidStatusAtual
	                    ,char* cidMotivo
	                    ,char* cloginChefe
	                    ,char* cindisponivelWF
	                    ,char* cinConsultor
						,char* cidUFOperadora
				        ,char* cidUser
                        ,char* cidPerfilConsultorAtd
                        ,char* cidFornecedorConsultorAtd
                        ,char* cidSiteConsultorAtd
                        ,char* cdsLoginRoteamento
                        ,char* cnome
					    ,char* cnomemeio
		                ,char* csobrenome
                       )
{
	ULOG_START("CUsr::InsertUsuario()");
	struct sqlca sqlca;                                
	EXEC SQL BEGIN DECLARE SECTION;                    
		VARCHAR stidStatusAtual[21+1];

		char* cAuxidUsuario                = cidUsuario;
		char* cAuxemail                    = cemail;
	    char* cAuxidDDD                    = cidDDD;
	    char* cAuxlogin                    = clogin;
	    char* cAuxloginCti                 = cloginCti;
	    char* cAuxidMotivo                 = cidMotivo;
	    char* cAuxindisponivelWF           = cindisponivelWF;
		char* cAuxidUser                   = cidUser;
		char* cAuxidUFOperadora            = cidUFOperadora;
        char* cAuxidPerfilConsultorAtd     = cidPerfilConsultorAtd;
        char* cAuxidFornecedorConsultorAtd = cidFornecedorConsultorAtd;
        char* cAuxidSiteConsultorAtd       = cidSiteConsultorAtd;
        char* cAuxdsLoginRoteamento        = cdsLoginRoteamento;
		char* cAuxnome                     = cnome;
		char* cAuxnomemeio                 = cnomemeio;
		char* cAuxsobrenome                = csobrenome;
        
        int   inDisponivel;

        char  cAuxNmPessoa[256];
	    char  cAuxTelefone[21+1];
		char  cAuxinConsultor[21+1];
		long  iStatus = 0;
		short sStatus = 0;
        short cStatidPerfilConsultorAtd = cAuxidPerfilConsultorAtd==0?-1:0;
        short cStatidFornecedorConsultorAtd = cAuxidFornecedorConsultorAtd==0?-1:0;
        short cStatidSiteConsultorAtd = cAuxidSiteConsultorAtd==0?-1:0;
        short cStatdsLoginRoteamento = cAuxdsLoginRoteamento==0?-1:0;
	EXEC SQL END DECLARE SECTION;
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO ErrorInsertUsuario;

	Zerar();
	memset( cAuxinConsultor, 0, sizeof( cAuxinConsultor ) );
	memset( cAuxTelefone, 0, sizeof( cAuxTelefone ) );
	memset( &stidStatusAtual, 0, sizeof( stidStatusAtual ) );

    strcpy(cAuxNmPessoa,cnome);

    if ( cnomemeio && *cnomemeio )
    {
        strcat(cAuxNmPessoa," ");
        strcat(cAuxNmPessoa,cnomemeio);
    }

    if ( csobrenome && *csobrenome )
    {
        strcat(cAuxNmPessoa," ");
        strcat(cAuxNmPessoa,csobrenome);
    }

	RemoveNaoNumero( cAuxTelefone, cTelefone );

	if( strlennull( cinConsultor ) <= 0 )
		strcpy( cAuxinConsultor, "0" );
	else
		strcpy( cAuxinConsultor, cinConsultor );
	
	//Na insercao o status eh sempre inativo
    inDisponivel = ( cindisponivelWF[0] == 'S' ) ? 1 : 0 ;
	iStatus = 0;
	EXEC SQL
		SELECT
			IDSTATUSUSUARIO
		INTO
			:stidStatusAtual:sStatus
        FROM
            APOIO.STATUSUSUARIO
		WHERE
			UPPER(SGSTATUSUSUARIO) = 'INATIVO';

	 ULOG("                cAuxidUsuario=%s",cAuxidUsuario);
	 ULOG("                    cAuxlogin=%s",cAuxlogin);
	 ULOG("                 cAuxloginCti=%s",cAuxloginCti);
	 ULOG("              stidStatusAtual=%s",stidStatusAtual.arr);
	 ULOG("                      iStatus=%d",iStatus);
	 ULOG("                   cAuxidUser=%s",cAuxidUser);
	 ULOG("                    cAuxemail=%s",cAuxemail);
	 ULOG("                 cAuxTelefone=%s",cAuxTelefone);
	 ULOG("                    cAuxidDDD=%s",cAuxidDDD);
	 ULOG("                    cAuxlogin=%s",cAuxlogin);
	 ULOG("              cAuxinConsultor=%s",cAuxinConsultor);
	 ULOG("            cAuxidUFOperadora=%s",cAuxidUFOperadora);
	 ULOG("     cAuxidPerfilConsultorAtd=%s",cAuxidPerfilConsultorAtd);
	 ULOG(" cAuxidFornecedorConsultorAtd=%s",cAuxidFornecedorConsultorAtd);
	 ULOG("       cAuxidSiteConsultorAtd=%s",cAuxidSiteConsultorAtd);
	 ULOG("        cAuxdsLoginRoteamento=%s",cAuxdsLoginRoteamento);
	 ULOG("    cStatidPerfilConsultorAtd=%d",cStatidPerfilConsultorAtd);
	 ULOG("cStatidFornecedorConsultorAtd=%d",cStatidFornecedorConsultorAtd);
	 ULOG("      cStatidSiteConsultorAtd=%d",cStatidSiteConsultorAtd);
	 ULOG("       cStatdsLoginRoteamento=%d",cStatdsLoginRoteamento);
	 ULOG("                        cnome=%s",cAuxnome);
	 ULOG("                    cnomemeio=%s",cAuxnomemeio);
	 ULOG("                   csobrenome=%s",cAuxsobrenome);

	//Insere usuario
	EXEC SQL 
		INSERT INTO ACESSO.USUARIO 
		  (IDPESSOAUSUARIO
		  ,NMLOGINUSUARIO
		  ,INREINICIALIZASENHA
		  ,NMLOGINUSUARIOCTI
		  ,INPRONTOATENDER
		  ,INATRIBUICAOPROCESSOS
		  ,IDSTATUSUSUARIO
		  ,DTSTATUSUSUARIO
		  ,INDISPONIVELWF
		  ,IDUSUARIOALTERACAO
		  ,DTULTIMAALTERACAO
		  ,DSEMAIL
		  ,NRTELEFONE
		  ,IDAREAREGISTRO
		  ,SGSENHAUSUARIO
		  ,INCONSULTOR
		  ,IDUFOPERADORA
		  ,IDPERFILCONSULTORATD
		  ,IDFORNECEDORCONSULTORATD
		  ,IDSITECONSULTORATD 
          ,DSLOGINROTEAMENTO
          ,NMNOME
	      ,NMNOMEMEIO
	      ,NMULTIMONOME
          )
		VALUES
			(
			  :cAuxidUsuario
			 ,SUBSTR(TRIM(:cAuxlogin),1,255)
			 ,1
			 ,SUBSTR(TRIM(:cAuxloginCti),1,255)
			 ,0
			 ,0
			 ,:stidStatusAtual
			 ,SYSDATE
			 /* ,:iStatus  */
             ,:inDisponivel
			 ,TO_NUMBER(:cAuxidUser)
			 ,SYSDATE
			 ,SUBSTR(TRIM(:cAuxemail),1,255)
			 ,:cAuxTelefone
			 ,:cAuxidDDD
			 ,:cAuxlogin
			 ,:cAuxinConsultor
			 ,:cAuxidUFOperadora
			 ,:cAuxidPerfilConsultorAtd:cStatidPerfilConsultorAtd
			 ,:cAuxidFornecedorConsultorAtd:cStatidFornecedorConsultorAtd
			 ,:cAuxidSiteConsultorAtd:cStatidSiteConsultorAtd
			 ,:cAuxdsLoginRoteamento:cStatdsLoginRoteamento
             ,SUBSTR(TRIM(:cAuxnome),1,255)
             ,SUBSTR(TRIM(:cAuxnomemeio),1,255)
             ,SUBSTR(TRIM(:cAuxsobrenome),1,255)
			);
			
	if( InsertChefeLogin( cAuxidUsuario
		                 ,cloginChefe
		                 ,cidUser ) != 0 )
	{
		ULOG_END("CUsr::InsertUsuario()");
		return 0;//Este metodo ja gera uma mensagem de erro
	}
    ULOG_END("CUsr::InsertUsuario()");
	return 1;
	
ErrorInsertUsuario:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::InsertChefeId( char* cidUsuario
		                ,char* cidChefe
		                ,char* cidUser )
{
	ULOG_START("CUsr::InsertChefeId()");
	struct sqlca sqlca;                                
	EXEC SQL BEGIN DECLARE SECTION;                    
		char* cAuxidUsuario = cidUsuario;
		char* cAuxidChefe   = cidChefe;
		char* cAuxidUser    = cidUser;                  
	EXEC SQL END DECLARE SECTION;
	
	try
	{
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorInsertChefeId;
		sqlca.sqlcode=0;
	
		//Insere usuario			
		EXEC SQL
			INSERT INTO ACESSO.USUARIOHIERARQUIA 
			  (IDPESSOAUSUARIO
			  ,IDPESSOAUSUARIOCHEFE
			  ,IDUSUARIOALTERACAO
			  ,DTULTIMAALTERACAO
			  )
			VALUES
				(
				  :cAuxidUsuario
				 ,:cAuxidChefe
				 ,TO_NUMBER(:cAuxidUser)
				 ,SYSDATE
				);

	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CUsr::InsertChefeId()");
	if(sqlca.sqlcode)
	{
		strcpy( cErro, "Falha na inclusão de LOGIN DO CHEFE" );
		return 0;
	}
	else
		return 1;
	
ErrorInsertChefeId:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::InsertChefeLogin( const char* cidUsuario
		                   ,const char* cloginChefe
		                   ,const char* cidUser )
{
	ULOG_START("CUsr::InsertChefeLogin()");
	struct sqlca sqlca;                                
	EXEC SQL BEGIN DECLARE SECTION;                    
		VARCHAR stidUsuarioChefe[21+1];
		const char* cAuxidUsuario  = cidUsuario;
		const char* cAuxloginChefe = cloginChefe;
		const char* cAuxidUser     = cidUser;                  
	EXEC SQL END DECLARE SECTION;
	
	memset( &stidUsuarioChefe, 0, sizeof( stidUsuarioChefe ) );

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO ErrorInsertChefeLogin;
	sqlca.sqlcode=0;

    ULOG( "cAuxidUsuario [%s]", cAuxidUsuario);
    ULOG( "cAuxloginChefe [%s]", cAuxloginChefe);
    ULOG( "cAuxidUser [%s]", cAuxidUser);
	EXEC SQL
		SELECT 
			USUARIO.IDPESSOAUSUARIO	
		INTO
			:stidUsuarioChefe
		FROM
			ACESSO.USUARIO USUARIO
		WHERE
			USUARIO.NMLOGINUSUARIO = :cAuxloginChefe;
			//UPPER(USUARIO.NMLOGINUSUARIO) = UPPER(:cAuxloginChefe);
			
	if(sqlca.sqlcode)
	{
		sprintf( cErro, "LOGIN de usuário [%s] não foi encontrado", cAuxloginChefe );
		ULOG_END("CUsr::InsertChefeLogin()");
		return 1;
	}
	
	//Se existe um login de chefe, entao tenta apagar alguma relacao ja existente
	EXEC SQL
		DELETE
			ACESSO.USUARIOHIERARQUIA
		WHERE
			IDPESSOAUSUARIO = :cAuxidUsuario;
		
	sqlca.sqlcode=0;

	//Insere a relacao que indica o login do chefe
	EXEC SQL
		INSERT INTO ACESSO.USUARIOHIERARQUIA 
		  (IDPESSOAUSUARIO
		  ,IDPESSOAUSUARIOCHEFE
		  ,IDUSUARIOALTERACAO
		  ,DTULTIMAALTERACAO
		  )
		VALUES
			(:cAuxidUsuario
			 ,:stidUsuarioChefe
			 ,TO_NUMBER(:cAuxidUser)
			 ,SYSDATE
			);
    ULOG_END("CUsr::InsertChefeLogin()");
	return 0;
	
ErrorInsertChefeLogin:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::ListPar( 	char* cnmnome,
				    char* cnmnomemeio,
					char* cnmsobrenome,
					char* cidUFOperadora,
					char* clogin,
					char* cloginCti,
					char* cidStatusAtual,
					char* cidCargoAtual,
					char* cloginChefe,
					char* csgTipoDocAtual,
					char* cdsDocAtual,
					char* cinConsultor,
					char* cpaginaAtual,
					char* cregistrosPPagina,
					char* cIdNivel,
					char* cIdCargo,
					char* cIdOrganizacao,
					char* cIdDepartamento)
{
	ULOG_START("CUsr::ListPar()");
	
	int iNome = 0;
	int iUsuario = 0;
	int iDocumento = 0;
	int iOrganograma = 0;
	int iCount = 0;

	if( strlennull( cnmnome ) > 0 )
		iNome = 1;
	if( strlennull( cnmnomemeio ) > 0 )
		iNome = 1;
	if( strlennull( cnmsobrenome ) > 0 )
		iNome = 1;
	if( strlennull( cidUFOperadora ) > 0 )
		iUsuario = 1;
	if( strlennull( clogin ) > 0 )
		iUsuario = 1;
	if( strlennull( cloginCti ) > 0 )
		iUsuario = 1;
	if( strlennull( cidStatusAtual ) > 0 )
		iUsuario = 1;
	if( strlennull( cidCargoAtual ) > 0 )
		iUsuario = 1;
	if( strlennull( cloginChefe ) > 0 )
		iUsuario = 1;
	if( strlennull( csgTipoDocAtual ) > 0 )
		iDocumento = 1;
	if( strlennull( cdsDocAtual ) > 0 )
		iDocumento = 1;
	if( strlennull( cinConsultor ) > 0 )
		iUsuario = 1;
	if( strlennull( cIdNivel ) > 0 )
		iOrganograma = 1;
	if( strlennull( cIdCargo ) > 0 )
		iOrganograma = 1;
	if( strlennull( cIdOrganizacao ) > 0 )
		iOrganograma = 1;
	if( strlennull( cIdDepartamento ) > 0 )
		iOrganograma = 1;
		
	//Se vier qualquer dado de usuario, pesquisa por usuario
	if( iOrganograma )
	{
	         ULOG("ListComOrganograma(\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s)", 
		                cnmnome,
		                cnmnomemeio,
						cnmsobrenome,
						cidUFOperadora,
						clogin,
						cloginCti,
						cidStatusAtual,
						cidCargoAtual,
						cloginChefe,
						csgTipoDocAtual,
						cdsDocAtual,
						cinConsultor,
						cpaginaAtual,
						cregistrosPPagina,
						cIdNivel,
						cIdCargo,
						cIdOrganizacao,
						cIdDepartamento 
		); 
		iCount = ListComOrganograma( 	
			            cnmnome,
		                cnmnomemeio,
						cnmsobrenome,
						cidUFOperadora,
						clogin,
						cloginCti,
						cidStatusAtual,
						cidCargoAtual,
						cloginChefe,
						csgTipoDocAtual,
						cdsDocAtual,
						cinConsultor,
						cpaginaAtual,
						cregistrosPPagina,
						cIdNivel,
						cIdCargo,
						cIdOrganizacao,
						cIdDepartamento );
	}
	else if( iUsuario )
	{
		ULOG("ListComDadosUsuario(\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s)", 
									  cnmnome,
									  cnmnomemeio,
						              cnmsobrenome,
									  cidUFOperadora,
									  clogin,
									  cloginCti,
									  cidStatusAtual,
									  cidCargoAtual,
									  cloginChefe,
									  csgTipoDocAtual,
									  cdsDocAtual,
								      cinConsultor,
									  cpaginaAtual,
									  cregistrosPPagina); 

		iCount = ListComDadosUsuario( cnmnome,
		                              cnmnomemeio,
						              cnmsobrenome,
									  cidUFOperadora,
									  clogin,
									  cloginCti,
									  cidStatusAtual,
									  cidCargoAtual,
									  cloginChefe,
									  csgTipoDocAtual,
									  cdsDocAtual,
								      cinConsultor,
									  cpaginaAtual,
									  cregistrosPPagina );
	}
	else if( iDocumento )
	{
		ULOG("ListComDocumento(\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s)", 
								   cnmnome,
		                           cnmnomemeio,
						           cnmsobrenome,
						           csgTipoDocAtual,
						           cdsDocAtual,
						           cpaginaAtual,
						           cregistrosPPagina); 
		iCount = ListComDocumento( cnmnome,
		                           cnmnomemeio,
						           cnmsobrenome,
						           csgTipoDocAtual,
						           cdsDocAtual,
						           cpaginaAtual,
						           cregistrosPPagina );
	}
	else if( iNome )
	{
        ULOG("ListComNome(\n%s,\n%s,\n%s,\n%s,\n%s)", 
					       cnmnome,
		                   cnmnomemeio,
					       cnmsobrenome,
					       cpaginaAtual,
					       cregistrosPPagina); 
		iCount = ListComNome( cnmnome,
		                      cnmnomemeio,
					          cnmsobrenome,
					          cpaginaAtual,
					          cregistrosPPagina );
	}
	else
	{
        ULOG("ListSemParametro(\n%s,\n%s) ==> DESATIVADA", 
				           cpaginaAtual,
				           cregistrosPPagina); 

		//iCount = ListSemParametro( cpaginaAtual,
		//			               cregistrosPPagina );
	}
	ULOG_END("CUsr::ListPar()");
	return iCount;
}

int CUsr::ListComDadosUsuario( char* cnmnome,
		                       char* cnmnomemeio,
						       char* cnmsobrenome,
							   char* cidUFOperadora,
							   char* clogin,
							   char* cloginCti,
							   char* cidStatusAtual,
							   char* cidCargoAtual,
							   char* cloginChefe,
							   char* csgTipoDocAtual,
							   char* cdsDocAtual,
						       char* cinConsultor,
							   char* cpaginaAtual,
							   char* cregistrosPPagina )
{
	ULOG_START("CUsr::ListComDadosUsuario()");
	struct sqlca sqlca;
	long iCont = 0;
	EXEC SQL BEGIN DECLARE SECTION;
		long ipaginaAtual;
		long iregistrosPPagina;
		long nTotalLinhas = TotalLinhasPorPesquisa();
		long iIni;
		long iFim;
	//Dados para pesquisa
		struct 
		{
			char cAuxnmnome[512+1];
			char cAuxnmnomemeio[255+1];
			char cAuxnmsobrenome[255+1];
			char cAuxidUFOperadora[21+1];
			char cAuxlogin[256+1];
			char cAuxloginCti[256+1];
			char cAuxidStatusAtual[21+1];
			char cAuxidCargoAtual[21+1];
			char cAuxloginChefe[256+1];
			char cAuxsgTipoDocAtual[21+1];
			char cAuxdsDocAtual[256+1];
			char cAuxinConsultor[21+1];
		} stUsuario1;
	//Estrutura pra recuperar um registro
		struct {
			VARCHAR stidUsuario[21+1];
			VARCHAR stnome[255+1];
			VARCHAR stsobrenome[255+1];
			VARCHAR stemail[255+1];
			VARCHAR stidDDD[21+1];
			VARCHAR stdsDDD[255+1];
			VARCHAR stTelefone[255+1];
			VARCHAR stlogin[255+1];
			VARCHAR stloginCti[255+1];
			VARCHAR stidStatusAtual[21+1];
			VARCHAR stdescricaoStatusAtual[255+1];
			VARCHAR stidMotivo[21+1];
			VARCHAR stdsMotivo[255+1];
			VARCHAR stdtInicio[255+1];
			VARCHAR stdtRetorno[255+1];
			VARCHAR stidCargoAtual[21+1];
			VARCHAR stdescricaoCargoAtual[255+1];
			VARCHAR stloginChefe[255+1];
			VARCHAR stnomeChefe[255+1];
			VARCHAR stidUF[21+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stdtInclusao[255+1];
			VARCHAR stdtExclusao[255+1];
			VARCHAR stinConsultor[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stidPerfilConsultorAtd[10+1];
			VARCHAR stidFornecedorConsultorAtd[10+1];
			VARCHAR stidSiteConsultorAtd[10+1];
            VARCHAR stdsLoginRoteamento[10+1];
		} stRegUsuario;
		struct {                
			short iidUsuario;   
			short inome;        
			short isobrenome;                 
			short iemail;                     
			short iidDDD;                     
			short idsDDD;                     
			short iTelefone;                  
			short ilogin;                     
			short iloginCti;                  
			short iidStatusAtual;             
			short idescricaoStatusAtual;      
			short iidMotivo;                  
			short idsMotivo;                  
			short idtInicio;                  
			short idtRetorno;                 
			short iidCargoAtual;              
			short idescricaoCargoAtual;       
			short iloginChefe;                
			short inomeChefe;                 
			short iidUF;                    
			short inmUF;                    
			short idtInclusao;                
			short idtExclusao;                
			short iinConsultor;
			short iidUFOperadora;
			short iidPerfilConsultorAtd;
			short iidFornecedorConsultorAtd;
			short iidSiteConsultorAtd;
            short idsLoginRoteamento;
		} stindicatorRegUsuario;              
		int iNomeVazio = 0;
	EXEC SQL END DECLARE SECTION;
	          
	memset( &stUsuario1, 0, sizeof( stUsuario1 ) );
	
	if( strlennull( cpaginaAtual ) <= 0 )
		ipaginaAtual = 0;
	else
		ipaginaAtual = atoi( cpaginaAtual )-1;
		
	if( ipaginaAtual < 0 )
		ipaginaAtual = 0;

	if( strlennull( cregistrosPPagina ) <= 0 )
		iregistrosPPagina = 100;
	else
		iregistrosPPagina = atoi( cregistrosPPagina );
	
	if( ( iregistrosPPagina <= 0 ) || ( iregistrosPPagina > 100 ) )
		iregistrosPPagina = 100;
		
	iIni = ipaginaAtual*iregistrosPPagina;
	iFim = iIni+iregistrosPPagina+1;
	
	//Metodo desta clase
	iTamanhoPagina = iregistrosPPagina;
	
	if( strlennull( cnmnome ) > 0 )
	{
		strcpy( stUsuario1.cAuxnmnome, cnmnome );
		strcat( stUsuario1.cAuxnmnome, "%" );
	}
	if( strlennull( cnmnomemeio ) > 0 )
	{
		if( strlennull( cnmnome ) <= 0 )
		{
			strcpy( stUsuario1.cAuxnmnomemeio, cnmnomemeio );
			strcpy( stUsuario1.cAuxnmnomemeio, "%" );
		}
		else
		{
			strcat( stUsuario1.cAuxnmnome, cnmnomemeio );
			strcat( stUsuario1.cAuxnmnome, "%" );
		}
	}
	else
	{
		strcpy( stUsuario1.cAuxnmnomemeio, "-1" );
	}
	if( strlennull( cnmsobrenome ) > 0 )
	{
		if( strlennull( cnmnome ) <= 0 )
		{
			strcpy( stUsuario1.cAuxnmsobrenome, cnmsobrenome );
			strcpy( stUsuario1.cAuxnmsobrenome, "%" );
		}
		else
			strcat( stUsuario1.cAuxnmnome, cnmsobrenome );
	}
	else
	{
		strcpy( stUsuario1.cAuxnmsobrenome, "-1" );
	}
	if( strlennull( stUsuario1.cAuxnmnome ) <= 0 )
	{
		strcpy( stUsuario1.cAuxnmnome, "-1" );
		iNomeVazio = 1;
	}

	if( strlennull( cidUFOperadora ) <= 0 )
		strcpy( stUsuario1.cAuxidUFOperadora, "-1" );
	else
		strcpy( stUsuario1.cAuxidUFOperadora, cidUFOperadora );
	
	if( strlennull( clogin ) <= 0 )
		strcpy( stUsuario1.cAuxlogin, "-1" );
	else
		sprintf( stUsuario1.cAuxlogin, "%s%%", clogin );

	if( strlennull( cloginCti ) <= 0 )
		strcpy( stUsuario1.cAuxloginCti, "-1" );
	else
		sprintf( stUsuario1.cAuxloginCti, "%s%%", cloginCti );

	if( strlennull( cidStatusAtual ) <= 0 )
		strcpy( stUsuario1.cAuxidStatusAtual, "-1" );
	else
		strcpy( stUsuario1.cAuxidStatusAtual, cidStatusAtual );

	if( strlennull( cidCargoAtual ) <= 0 )
		strcpy( stUsuario1.cAuxidCargoAtual, "-1" );
	else
		strcpy( stUsuario1.cAuxidCargoAtual, cidCargoAtual );

	if( strlennull( cloginChefe ) <= 0 )
		strcpy( stUsuario1.cAuxloginChefe, "-1" );
	else
		sprintf( stUsuario1.cAuxloginChefe, "%s%%", cloginChefe );

	if( strlennull( csgTipoDocAtual ) <= 0 )
		strcpy( stUsuario1.cAuxsgTipoDocAtual, "-1" );
	else
		strcpy( stUsuario1.cAuxsgTipoDocAtual, csgTipoDocAtual );

	if( strlennull( cdsDocAtual ) <= 0 )
		strcpy( stUsuario1.cAuxdsDocAtual, "-1" );
	else
	{
		if( strcmp( csgTipoDocAtual, "CPF" ) == 0 )
			RemoveNaoNumero( stUsuario1.cAuxdsDocAtual, cdsDocAtual );
		else
			strcpy( stUsuario1.cAuxdsDocAtual, cdsDocAtual );
	}
	if( strlennull( cinConsultor ) <= 0 )
		strcpy( stUsuario1.cAuxinConsultor, "-1" );
	else
		strcpy( stUsuario1.cAuxinConsultor, cinConsultor );

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListComDadosUsuario;
	sqlca.sqlcode=0;

	//Se nome vazio eh porque  nao tem nome (mas pode ter nomemeio e sobrenome)
	if( iNomeVazio )
	{
		EXEC SQL
		DECLARE 
	   		CursorListComDadosUsuarioSemNome CURSOR FOR
		SELECT DISTINCT
			 IDPESSOA
			,NMNOME
			,NMSOBRENOME
			,DSEMAIL
			,IDAREAREGISTRO
			,CDAREAREGISTRO
			,NRTELEFONE
			,NMLOGINUSUARIO
			,NMLOGINUSUARIOCTI
			,IDSTATUSUSUARIO
			,DSSTATUSUSUARIO
			,0  IDMOTIVO
			,'' DSMOTIVO
			,DTCADASTRO
			,DTSTATUSUSUARIO
			,0  IDCARGO
			,'' NMCARGO
			,NMLOGINUSUARIOCHEFE
			,NMPESSOACHEFE
			,IDUF
			,NMUF
			,DTINICIO
			,DTEXCLUSAO
			,INCONSULTOR
			,IDUFOPERADORA
            ,IDPERFILCONSULTORATD
            ,IDFORNECEDORCONSULTORATD
            ,IDSITECONSULTORATD
            ,DSLOGINROTEAMENTO
		FROM 
		(
			SELECT
				 PESSOA.IDPESSOA
				,PESSOA.NMPESSOA NMNOME
				,PESSOA.NMSOBRENOME
				,USUARIO.DSEMAIL
				,USUARIO.IDAREAREGISTRO
				,AREAREGISTRO.CDAREAREGISTRO
				,USUARIO.NRTELEFONE
				,USUARIO.NMLOGINUSUARIO
				,USUARIO.NMLOGINUSUARIOCTI
				,USUARIO.IDSTATUSUSUARIO
				,STATUSUSUARIO.DSSTATUSUSUARIO
				,PESSOA.DTCADASTRO
				,USUARIO.DTSTATUSUSUARIO
                ,USUARIOCHEFE.NMLOGINUSUARIO AS NMLOGINUSUARIOCHEFE
				,PESSOACHEFE.NMPESSOA NMPESSOACHEFE
				,UF.IDUF
				,UF.NMUF
				,PESSOA.DTCADASTRO DTINICIO
				,USUARIO.DTSTATUSUSUARIO DTEXCLUSAO
				,USUARIO.INCONSULTOR
				,USUARIO.IDUFOPERADORA
                ,USUARIO.IDPERFILCONSULTORATD
                ,USUARIO.IDFORNECEDORCONSULTORATD
                ,USUARIO.IDSITECONSULTORATD
                ,USUARIO.DSLOGINROTEAMENTO
			FROM 
				CUSTOMER.PESSOA PESSOA,
				CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
				CUSTOMER.DOCUMENTO DOCUMENTO,
				ACESSO.USUARIO USUARIO,
				ACESSO.USUARIOHIERARQUIA USUARIOHIERARQUIA,
				ACESSO.USUARIO USUARIOCHEFE,
				CUSTOMER.PESSOA PESSOACHEFE,
				APOIO.UF UF,
				APOIO.TIPODOCUMENTO TIPODOCUMENTO,
				APOIO.STATUSUSUARIO STATUSUSUARIO,
				APOIO.AREAREGISTRO AREAREGISTRO
			WHERE
				PESSOA.IDPESSOA = USUARIO.IDPESSOAUSUARIO
			AND USUARIO.IDSTATUSUSUARIO = STATUSUSUARIO.IDSTATUSUSUARIO
			AND USUARIO.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
			AND PESSOA.IDPESSOA = PESSOADOCUMENTO.IDPESSOA
			AND PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
			AND DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
			AND PESSOA.IDUF = UF.IDUF
			AND USUARIO.IDPESSOAUSUARIO = USUARIOHIERARQUIA.IDPESSOAUSUARIO(+)
			AND USUARIOHIERARQUIA.IDPESSOAUSUARIOCHEFE = USUARIOCHEFE.IDPESSOAUSUARIO(+)
			AND USUARIOCHEFE.IDPESSOAUSUARIO = PESSOACHEFE.IDPESSOA(+)
			AND 
			(
				TIPODOCUMENTO.SGCLASSIFICACAO = 'CPF'
			OR 
				TIPODOCUMENTO.SGTIPODOCUMENTO = 'RG'
			OR 
				TIPODOCUMENTO.SGTIPODOCUMENTO = 'RE' 
			)
			AND
			(
					TIPODOCUMENTO.SGTIPODOCUMENTO = :stUsuario1.cAuxsgTipoDocAtual
				OR
					'-1' = :stUsuario1.cAuxsgTipoDocAtual
			)
			AND
			(
					DOCUMENTO.NRDOCUMENTO = :stUsuario1.cAuxdsDocAtual
				OR
					'-1' = :stUsuario1.cAuxdsDocAtual
			)
			AND
			(
					UPPER(USUARIO.NMLOGINUSUARIO) LIKE UPPER(:stUsuario1.cAuxlogin)
				OR
					'-1' = :stUsuario1.cAuxlogin
			)
			AND 
			( 
					UPPER(USUARIO.NMLOGINUSUARIOCTI) LIKE UPPER(:stUsuario1.cAuxloginCti) 
		 		OR 
					'-1'  = :stUsuario1.cAuxloginCti
			)
			AND 
			( 
					USUARIO.IDSTATUSUSUARIO = :stUsuario1.cAuxidStatusAtual
				OR 
					'-1' = :stUsuario1.cAuxidStatusAtual
			)
			AND 
			( 
					UPPER(USUARIOCHEFE.NMLOGINUSUARIO) LIKE UPPER(:stUsuario1.cAuxloginChefe) 
		 		OR 
					'-1' = :stUsuario1.cAuxloginChefe
			)
			AND 
			( 
					USUARIO.INCONSULTOR = :stUsuario1.cAuxinConsultor
				OR 
					'-1' = :stUsuario1.cAuxinConsultor
			)
			AND 
			( 
					USUARIO.IDUFOPERADORA = :stUsuario1.cAuxidUFOperadora
		 		OR 
					'-1' = :stUsuario1.cAuxidUFOperadora
			)
			AND
			( 
		 			UPPER(PESSOA.NMNOMEMEIO) LIKE UPPER(:stUsuario1.cAuxnmnomemeio)
				OR 
					'-1' = :stUsuario1.cAuxnmnomemeio
			)
			AND
			( 
		 			UPPER(PESSOA.NMSOBRENOME) LIKE UPPER(:stUsuario1.cAuxnmsobrenome)
				OR 
					'-1' = :stUsuario1.cAuxnmsobrenome
			)
			AND
				ROWNUM <= :nTotalLinhas * 3
		);
	}//if( iNomeVazio )
	else
	{
		EXEC SQL
		DECLARE 
	   		CursorListComDadosUsuario CURSOR FOR
		SELECT DISTINCT
			 IDPESSOA
			,NMNOME
			,NMSOBRENOME
			,DSEMAIL
			,IDAREAREGISTRO
			,CDAREAREGISTRO
			,NRTELEFONE
			,NMLOGINUSUARIO
			,NMLOGINUSUARIOCTI
			,IDSTATUSUSUARIO
			,DSSTATUSUSUARIO
			,0  IDMOTIVO
			,'' DSMOTIVO
			,DTCADASTRO
			,DTSTATUSUSUARIO
			,0  IDCARGO
			,'' NMCARGO
			,NMLOGINUSUARIOCHEFE
			,NMPESSOACHEFE
			,IDUF
			,NMUF
			,DTINICIO
			,DTEXCLUSAO
			,INCONSULTOR
			,IDUFOPERADORA
            ,IDPERFILCONSULTORATD
            ,IDFORNECEDORCONSULTORATD
            ,IDSITECONSULTORATD
            ,DSLOGINROTEAMENTO
		FROM 
		(
			SELECT
				 PESSOA.IDPESSOA
				,PESSOA.NMPESSOA NMNOME
				,PESSOA.NMSOBRENOME
				,USUARIO.DSEMAIL
				,USUARIO.IDAREAREGISTRO
				,AREAREGISTRO.CDAREAREGISTRO
				,USUARIO.NRTELEFONE
				,USUARIO.NMLOGINUSUARIO
				,USUARIO.NMLOGINUSUARIOCTI
				,USUARIO.IDSTATUSUSUARIO
				,STATUSUSUARIO.DSSTATUSUSUARIO
				,PESSOA.DTCADASTRO
				,USUARIO.DTSTATUSUSUARIO
				,USUARIOCHEFE.NMLOGINUSUARIO NMLOGINUSUARIOCHEFE
				,PESSOACHEFE.NMPESSOA NMPESSOACHEFE
				,UF.IDUF
				,UF.NMUF
				,PESSOA.DTCADASTRO DTINICIO
				,USUARIO.DTSTATUSUSUARIO DTEXCLUSAO
				,USUARIO.INCONSULTOR
				,USUARIO.IDUFOPERADORA
                ,USUARIO.IDPERFILCONSULTORATD
                ,USUARIO.IDFORNECEDORCONSULTORATD
                ,USUARIO.IDSITECONSULTORATD
                ,USUARIO.DSLOGINROTEAMENTO
			FROM 
				CUSTOMER.PESSOA PESSOA,
				CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
				CUSTOMER.DOCUMENTO DOCUMENTO,
				ACESSO.USUARIO USUARIO,
				ACESSO.USUARIOHIERARQUIA USUARIOHIERARQUIA,
				ACESSO.USUARIO USUARIOCHEFE,
				CUSTOMER.PESSOA PESSOACHEFE,
				APOIO.UF UF,
				APOIO.TIPODOCUMENTO TIPODOCUMENTO,
				APOIO.STATUSUSUARIO STATUSUSUARIO,
				APOIO.AREAREGISTRO AREAREGISTRO
			WHERE
				PESSOA.IDPESSOA = USUARIO.IDPESSOAUSUARIO
			AND
				USUARIO.IDSTATUSUSUARIO = STATUSUSUARIO.IDSTATUSUSUARIO
			AND
				USUARIO.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
			AND
				PESSOA.IDPESSOA = PESSOADOCUMENTO.IDPESSOA
			AND
				PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
			AND
				DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
			AND
				PESSOA.IDUF = UF.IDUF
			AND
				USUARIO.IDPESSOAUSUARIO = USUARIOHIERARQUIA.IDPESSOAUSUARIO(+)
			AND
				USUARIOHIERARQUIA.IDPESSOAUSUARIOCHEFE = USUARIOCHEFE.IDPESSOAUSUARIO(+)
			AND
				USUARIOCHEFE.IDPESSOAUSUARIO = PESSOACHEFE.IDPESSOA(+)
			AND 
			(
				TIPODOCUMENTO.SGCLASSIFICACAO = 'CPF'
			OR 
				TIPODOCUMENTO.SGTIPODOCUMENTO = 'RG'
			OR 
				TIPODOCUMENTO.SGTIPODOCUMENTO = 'RE' 
			)
			AND
			(
					TIPODOCUMENTO.SGTIPODOCUMENTO = :stUsuario1.cAuxsgTipoDocAtual
				OR
					'-1' = :stUsuario1.cAuxsgTipoDocAtual
			)
			AND
			(
					DOCUMENTO.NRDOCUMENTO = :stUsuario1.cAuxdsDocAtual
				OR
					'-1' = :stUsuario1.cAuxdsDocAtual
			)
			AND
			(
					UPPER(USUARIO.NMLOGINUSUARIO) LIKE UPPER(:stUsuario1.cAuxlogin)
				OR
					'-1' = :stUsuario1.cAuxlogin
			)
			AND 
			( 
					UPPER(USUARIO.NMLOGINUSUARIOCTI) LIKE UPPER(:stUsuario1.cAuxloginCti) 
		 		OR 
					'-1'  = :stUsuario1.cAuxloginCti
			)
			AND 
			( 
					USUARIO.IDSTATUSUSUARIO = :stUsuario1.cAuxidStatusAtual
				OR 
					'-1' = :stUsuario1.cAuxidStatusAtual
			)
			AND 
			( 
					UPPER(USUARIOCHEFE.NMLOGINUSUARIO) LIKE UPPER(:stUsuario1.cAuxloginChefe) 
		 		OR 
					'-1' = :stUsuario1.cAuxloginChefe
			)
			AND 
			( 
					USUARIO.INCONSULTOR = :stUsuario1.cAuxinConsultor
				OR 
					'-1' = :stUsuario1.cAuxinConsultor
			)
			AND 
			( 
					USUARIO.IDUFOPERADORA = :stUsuario1.cAuxidUFOperadora
		 		OR 
					'-1' = :stUsuario1.cAuxidUFOperadora
			)
			AND
			( 
		 			UPPER(PESSOA.NMPESSOA) LIKE UPPER(:stUsuario1.cAuxnmnome)
				OR 
					'-1' = :stUsuario1.cAuxnmnome
			)
			AND
				ROWNUM < :nTotalLinhas * 3
		);
	}//else if( iNomeVazio )

	if( iNomeVazio )
	{
		EXEC SQL OPEN CursorListComDadosUsuarioSemNome;
	}
	else
	{
		EXEC SQL OPEN CursorListComDadosUsuario;
	}

	//Por default, zero indica nao haver mais paginas
	iProximaPagina = 0;
	for(iCont=1;;iCont++)
	{
		memset( &stRegUsuario, 0, sizeof(stRegUsuario) );
		if( iNomeVazio )
		{
			EXEC SQL FETCH CursorListComDadosUsuarioSemNome INTO :stRegUsuario:stindicatorRegUsuario;
		}
		else
		{
			EXEC SQL FETCH CursorListComDadosUsuario INTO :stRegUsuario:stindicatorRegUsuario;
		}
		
		if( iCont > iIni && iCont <  iFim )
		{
			Add( (char*)stRegUsuario.stidUsuario.arr
			    ,(char*)stRegUsuario.stnome.arr
			    ,(char*)stRegUsuario.stsobrenome.arr
			    ,(char*)stRegUsuario.stemail.arr
			    ,(char*)stRegUsuario.stidDDD.arr
			    ,(char*)stRegUsuario.stdsDDD.arr
			    ,(char*)stRegUsuario.stTelefone.arr
			    ,(char*)stRegUsuario.stlogin.arr
			    ,(char*)stRegUsuario.stloginCti.arr
			    ,(char*)stRegUsuario.stidStatusAtual.arr
			    ,(char*)stRegUsuario.stdescricaoStatusAtual.arr
			    ,(char*)stRegUsuario.stidMotivo.arr
			    ,(char*)stRegUsuario.stdsMotivo.arr
			    ,(char*)stRegUsuario.stdtInicio.arr
			    ,(char*)stRegUsuario.stdtRetorno.arr
			    ,(char*)stRegUsuario.stidCargoAtual.arr
			    ,(char*)stRegUsuario.stdescricaoCargoAtual.arr
			    ,(char*)stRegUsuario.stloginChefe.arr
			    ,(char*)stRegUsuario.stnomeChefe.arr
			    ,(char*)stRegUsuario.stidUF.arr
			    ,(char*)stRegUsuario.stnmUF.arr
			    ,(char*)stRegUsuario.stdtInclusao.arr
			    ,(char*)stRegUsuario.stdtExclusao.arr
			    ,(char*)stRegUsuario.stinConsultor.arr
				,(char*)stRegUsuario.stidUFOperadora.arr
                ,(char*)stRegUsuario.stidPerfilConsultorAtd.arr
                ,(char*)stRegUsuario.stidFornecedorConsultorAtd.arr
                ,(char*)stRegUsuario.stidSiteConsultorAtd.arr
                ,(char*)stRegUsuario.stdsLoginRoteamento.arr
			);
		}//if( iCont > iIni && iCont <  iFim )
	}//for(;;iContador++)
	if( iNomeVazio )
	{
		EXEC SQL CLOSE CursorListComDadosUsuarioSemNome;
	}
	else
	{
		EXEC SQL CLOSE CursorListComDadosUsuario;
	}

	if( iCont > iFim )
		iProximaPagina = 1;

	if( iCont > nTotalLinhas )
		sprintf( cContadorPagina, "mais de %d página(s)", (iCont/iregistrosPPagina)+1 );
	else
		sprintf( cContadorPagina, "%d página(s)", (iCont/iregistrosPPagina)+1 );

	ULOG_END("CUsr::ListComDadosUsuario()");
	return iCont-1;

GotoListComDadosUsuario:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CUsr::ListComDocumento( char* cnmnome,
		                    char* cnmnomemeio,
						    char* cnmsobrenome,
							char* csgTipoDocAtual,
							char* cdsDocAtual,
							char* cpaginaAtual,
							char* cregistrosPPagina )
{
	ULOG_START("CUsr::ListComDocumento()");
	struct sqlca sqlca;
	long iCont = 0;
	EXEC SQL BEGIN DECLARE SECTION;
		char cPesquisa[2000];
		long ipaginaAtual;
		long iregistrosPPagina;
		long nTotalLinhas = TotalLinhasPorPesquisa();
		char cTotalLinhas[21+1];
		long iIni;
		long iFim;
		char cIni[21+1];
		char cFim[21+1];
	//Dados para pesquisa
		struct 
		{
			char cAuxnmnome[512+1];
			char cAuxsgTipoDocAtual[21+1];
			char cAuxdsDocAtual[256+1];
		} stUsuario2;
	//Estrutura pra recuperar um registro
		struct {
			VARCHAR stidUsuario[21+1];
			VARCHAR stnome[255+1];
			VARCHAR stsobrenome[255+1];
			VARCHAR stemail[255+1];
			VARCHAR stidDDD[21+1];
			VARCHAR stdsDDD[255+1];
			VARCHAR stTelefone[255+1];
			VARCHAR stlogin[255+1];
			VARCHAR stloginCti[255+1];
			VARCHAR stidStatusAtual[21+1];
			VARCHAR stdescricaoStatusAtual[255+1];
			VARCHAR stidMotivo[21+1];
			VARCHAR stdsMotivo[255+1];
			VARCHAR stdtInicio[255+1];
			VARCHAR stdtRetorno[255+1];
			VARCHAR stidCargoAtual[21+1];
			VARCHAR stdescricaoCargoAtual[255+1];
			VARCHAR stloginChefe[255+1];
			VARCHAR stnomeChefe[255+1];
			VARCHAR stidUF[21+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stdtInclusao[255+1];
			VARCHAR stdtExclusao[255+1];
			VARCHAR stinConsultor[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stidPerfilConsultorAtd[10+1];
			VARCHAR stidFornecedorConsultorAtd[10+1];
			VARCHAR stidSiteConsultorAtd[10+1];
            VARCHAR stdsLoginRoteamento[10+1];
		} stRegUsuario;
		struct {                
			short iidUsuario;   
			short inome;        
			short isobrenome;                 
			short iemail;                     
			short iidDDD;                     
			short idsDDD;                     
			short iTelefone;                  
			short ilogin;                     
			short iloginCti;                  
			short iidStatusAtual;             
			short idescricaoStatusAtual;      
			short iidMotivo;                  
			short idsMotivo;                  
			short idtInicio;                  
			short idtRetorno;                 
			short iidCargoAtual;              
			short idescricaoCargoAtual;       
			short iloginChefe;                
			short inomeChefe;                 
			short iidUF;                    
			short inmUF;                    
			short idtInclusao;                
			short idtExclusao;                
			short iinConsultor;
			short iidUFOperadora;
			short iidPerfilConsultorAtd;
			short iidFornecedorConsultorAtd;
			short iidSiteConsultorAtd;
            short idsLoginRoteamento;
		} stindicatorRegUsuario;              
	EXEC SQL END DECLARE SECTION;
	          
	memset( &stUsuario2, 0, sizeof( stUsuario2 ) );
	memset( &cPesquisa, 0, sizeof( cPesquisa ) );
	memset( &cIni, 0, sizeof( cIni ) );
	memset( &cFim, 0, sizeof( cFim ) );
	memset( &cTotalLinhas, 0, sizeof( cTotalLinhas ) );

	sprintf( cTotalLinhas, "%ld", nTotalLinhas );

	if( strlennull( cpaginaAtual ) <= 0 )
		ipaginaAtual = 0;
	else
		ipaginaAtual = atoi( cpaginaAtual )-1;
		
	if( ipaginaAtual < 0 )
		ipaginaAtual = 0;

	if( strlennull( cregistrosPPagina ) <= 0 )
		iregistrosPPagina = 100;
	else
		iregistrosPPagina = atoi( cregistrosPPagina );
	
	if( ( iregistrosPPagina <= 0 ) || ( iregistrosPPagina > 100 ) )
		iregistrosPPagina = 100;
		
	iIni = ipaginaAtual*iregistrosPPagina;
	iFim = iIni+iregistrosPPagina+1;
	
	//Metodo desta clase
	iTamanhoPagina = iregistrosPPagina;
	
	if( strlennull( cnmnome ) > 0 )
	{
		strcpy( stUsuario2.cAuxnmnome, cnmnome );
		strcat( stUsuario2.cAuxnmnome, "%" );
	}
	if( strlennull( cnmnomemeio ) > 0 )
	{
		if( strlennull( cnmnome ) <= 0 )
			strcpy( stUsuario2.cAuxnmnome, "%" );

		strcat( stUsuario2.cAuxnmnome, cnmnomemeio );
		strcat( stUsuario2.cAuxnmnome, "%" );
	}
	if( strlennull( cnmsobrenome ) > 0 )
	{
		if( strlennull( stUsuario2.cAuxnmnome ) <= 0 )
			strcpy( stUsuario2.cAuxnmnome, "%" );
		strcat( stUsuario2.cAuxnmnome, cnmsobrenome );
	}
	if( strlennull( stUsuario2.cAuxnmnome ) <= 0 )
		strcpy( stUsuario2.cAuxnmnome, "" );

	if( strlennull( csgTipoDocAtual ) <= 0 )
		strcpy( stUsuario2.cAuxsgTipoDocAtual, "" );
	else
		strcpy( stUsuario2.cAuxsgTipoDocAtual, csgTipoDocAtual );

	if( strlennull( cdsDocAtual ) <= 0 )
		strcpy( stUsuario2.cAuxdsDocAtual, "" );
	else
	{
		if( strcmp( csgTipoDocAtual, "CPF" ) == 0 )
			RemoveNaoNumero( stUsuario2.cAuxdsDocAtual, cdsDocAtual );
		else
			strcpy( stUsuario2.cAuxdsDocAtual, cdsDocAtual );
	}

	sprintf( cIni,"%d", iIni );
	sprintf( cFim,"%d", iFim );
	EXEC SQL WHENEVER SQLERROR GOTO GotoListComDocumento;
	sqlca.sqlcode=0;
	
	//Retorna todas as pessoas que sao usuario
	strcpy( cPesquisa, 
	" SELECT DISTINCT"
	     " IDPESSOA"
	    " ,NMPESSOA"
	    " ,NMSOBRENOME"
	    " ,DTCADASTRO" 
	    " ,IDUF"
	    " ,NMUF"
	    " ,DTINICIO"
	" FROM"
	"("
	"	SELECT /* INDEX ( PESSOA, PESSOAIE2 )*/"
		     " PESSOA.IDPESSOA"
		    " ,PESSOA.NMPESSOA"
		    " ,PESSOA.NMSOBRENOME"
		    " ,PESSOA.DTCADASTRO"
		    " ,UF.IDUF"
		    " ,UF.NMUF"
		    " ,PESSOA.DTCADASTRO DTINICIO"
		" FROM "
		    " CUSTOMER.PESSOA PESSOA,"
		    " APOIO.UF UF,"
		    " CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,"
		    " CUSTOMER.DOCUMENTO,"
		    " APOIO.TIPODOCUMENTO"
		" WHERE"
		    " PESSOA.IDPESSOA = PESSOADOCUMENTO.IDPESSOA"
		" AND"
		    " PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO"
		" AND"
		    " DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO"
		" AND "
		    " PESSOA.IDUF = UF.IDUF"
		" AND " \
		    " ROWNUM < " );
		strcat( cPesquisa, cTotalLinhas );
		strcat( cPesquisa, " * 3 " );

	//Só monta esta clausula se existir um nome
	if( strlennull( cnmnome ) > 0 )
	{
		if( strlen( stUsuario2.cAuxnmnome ) > 0 )
		{
			strcat( cPesquisa, 
			" AND" \
				" UPPER(PESSOA.NMPESSOA) LIKE UPPER('" );
			strcat( cPesquisa, stUsuario2.cAuxnmnome );
			strcat( cPesquisa, "')" );
		}
	}
	else
	{
		if( strlennull( cnmnomemeio ) > 0 )
		{
			strcat( cPesquisa, 
			" AND" \
				" UPPER(PESSOA.NMNOMEMEIO) LIKE UPPER('" );
			strcat( cPesquisa, cnmnomemeio );
			strcat( cPesquisa, "')" );
		}
		if( strlennull( cnmsobrenome ) > 0 )
		{
			strcat( cPesquisa, 
			" AND" \
				" UPPER(PESSOA.NMSOBRENOME) LIKE UPPER('" );
			strcat( cPesquisa, cnmsobrenome );
			strcat( cPesquisa, "')" );
		}
	}
	//Só monta esta clausula se existir um tipo de documento
	if( strlen( stUsuario2.cAuxsgTipoDocAtual ) > 0 )
	{
		strcat( cPesquisa, 
		" AND" \
	        " TIPODOCUMENTO.SGTIPODOCUMENTO = '" );
		strcat( cPesquisa, stUsuario2.cAuxsgTipoDocAtual );
		strcat( cPesquisa, "' " );
	}
	//Só monta esta clausula se existir um numero de documento
	if( strlen( stUsuario2.cAuxdsDocAtual ) > 0 )
	{
		strcat( cPesquisa, 
		" AND" \
	        " DOCUMENTO.NRDOCUMENTO = '" );
		strcat( cPesquisa, stUsuario2.cAuxdsDocAtual );
		strcat( cPesquisa, "' " );
	}
	strcat( cPesquisa, 
	" ) PESQUISADOCUMENTO" );

	ULOG("Query:[%s]", cPesquisa);

	EXEC SQL PREPARE qPesquisa FROM :cPesquisa;
	EXEC SQL DECLARE CursorListComDocumento CURSOR FOR qPesquisa;

	
	EXEC SQL OPEN CursorListComDocumento;

	//Por default, zero indica nao haver mais paginas
	iProximaPagina = 0;
	for(iCont=1;;iCont++)
	{
		EXEC SQL WHENEVER NOT FOUND DO break;
		memset( &stRegUsuario, 0, sizeof(stRegUsuario) );
		EXEC SQL 
		FETCH 
			CursorListComDocumento 
		INTO 
			:stRegUsuario.stidUsuario :stindicatorRegUsuario.iidUsuario,
			:stRegUsuario.stnome      :stindicatorRegUsuario.inome,
			:stRegUsuario.stsobrenome :stindicatorRegUsuario.isobrenome,
			:stRegUsuario.stdtInicio  :stindicatorRegUsuario.idtInicio,
			:stRegUsuario.stidUF      :stindicatorRegUsuario.iidUF,
			:stRegUsuario.stnmUF      :stindicatorRegUsuario.inmUF,
			:stRegUsuario.stdtInclusao:stindicatorRegUsuario.idtInclusao;
			
		if( iCont > iIni && iCont <  iFim )
		{
			EXEC SQL WHENEVER NOT FOUND CONTINUE;
			EXEC SQL
			SELECT
				 USUARIO.DSEMAIL
				,USUARIO.IDAREAREGISTRO
				,AREAREGISTRO.CDAREAREGISTRO
				,USUARIO.NRTELEFONE
				,USUARIO.NMLOGINUSUARIO
				,USUARIO.NMLOGINUSUARIOCTI
				,USUARIO.IDSTATUSUSUARIO
				,STATUSUSUARIO.DSSTATUSUSUARIO
				,0  IDMOTIVO
				,'' DSMOTIVO
				,USUARIO.DTSTATUSUSUARIO
				,0  IDCARGO
				,'' DSCARGO
                ,USUARIOCHEFE.NMLOGINUSUARIO AS NMLOGINUSUARIOCHEFE
				,PESSOACHEFE.NMPESSOA NMPESSOACHEFE
				,USUARIO.DTSTATUSUSUARIO DTEXCLUSAO
				,USUARIO.INCONSULTOR
				,USUARIO.IDUFOPERADORA
                ,USUARIO.IDPERFILCONSULTORATD
                ,USUARIO.IDFORNECEDORCONSULTORATD
                ,USUARIO.IDSITECONSULTORATD
                ,USUARIO.DSLOGINROTEAMENTO
			INTO
				:stRegUsuario.stemail                    :stindicatorRegUsuario.iemail,
				:stRegUsuario.stidDDD                    :stindicatorRegUsuario.iidDDD,
				:stRegUsuario.stdsDDD                    :stindicatorRegUsuario.idsDDD,
				:stRegUsuario.stTelefone                 :stindicatorRegUsuario.iTelefone,
				:stRegUsuario.stlogin                    :stindicatorRegUsuario.ilogin,
				:stRegUsuario.stloginCti                 :stindicatorRegUsuario.iloginCti,
				:stRegUsuario.stidStatusAtual            :stindicatorRegUsuario.iidStatusAtual,
				:stRegUsuario.stdescricaoStatusAtual     :stindicatorRegUsuario.idescricaoStatusAtual,
				:stRegUsuario.stidMotivo                 :stindicatorRegUsuario.iidMotivo,
				:stRegUsuario.stdsMotivo                 :stindicatorRegUsuario.idsMotivo,
				:stRegUsuario.stdtRetorno                :stindicatorRegUsuario.idtRetorno,
				:stRegUsuario.stidCargoAtual             :stindicatorRegUsuario.iidCargoAtual,
				:stRegUsuario.stdescricaoCargoAtual      :stindicatorRegUsuario.idescricaoCargoAtual,
				:stRegUsuario.stloginChefe               :stindicatorRegUsuario.iloginChefe,
				:stRegUsuario.stnomeChefe                :stindicatorRegUsuario.inomeChefe,
				:stRegUsuario.stdtExclusao               :stindicatorRegUsuario.idtExclusao,
				:stRegUsuario.stinConsultor              :stindicatorRegUsuario.iinConsultor,
				:stRegUsuario.stidUFOperadora            :stindicatorRegUsuario.iidUFOperadora,
				:stRegUsuario.stidPerfilConsultorAtd     :stindicatorRegUsuario.iidPerfilConsultorAtd,
				:stRegUsuario.stidFornecedorConsultorAtd :stindicatorRegUsuario.iidFornecedorConsultorAtd,
				:stRegUsuario.stidSiteConsultorAtd       :stindicatorRegUsuario.iidSiteConsultorAtd,
				:stRegUsuario.stdsLoginRoteamento        :stindicatorRegUsuario.idsLoginRoteamento
			FROM 
				ACESSO.USUARIO USUARIO,
				ACESSO.USUARIOHIERARQUIA USUARIOHIERARQUIA,
				ACESSO.USUARIO USUARIOCHEFE,
				CUSTOMER.PESSOA PESSOACHEFE,
				APOIO.STATUSUSUARIO STATUSUSUARIO,
				APOIO.AREAREGISTRO AREAREGISTRO
			WHERE
				USUARIO.IDSTATUSUSUARIO = STATUSUSUARIO.IDSTATUSUSUARIO
			AND
				USUARIO.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
			AND
				USUARIO.IDPESSOAUSUARIO = USUARIOHIERARQUIA.IDPESSOAUSUARIO(+)
			AND
				USUARIOHIERARQUIA.IDPESSOAUSUARIOCHEFE = USUARIOCHEFE.IDPESSOAUSUARIO(+)
			AND
				USUARIOCHEFE.IDPESSOAUSUARIO = PESSOACHEFE.IDPESSOA(+)
			AND
				USUARIO.IDPESSOAUSUARIO = :stRegUsuario.stidUsuario;
			
			Add( (char*)stRegUsuario.stidUsuario.arr
			    ,(char*)stRegUsuario.stnome.arr
			    ,(char*)stRegUsuario.stsobrenome.arr
			    ,(char*)stRegUsuario.stemail.arr
			    ,(char*)stRegUsuario.stidDDD.arr
			    ,(char*)stRegUsuario.stdsDDD.arr
			    ,(char*)stRegUsuario.stTelefone.arr
			    ,(char*)stRegUsuario.stlogin.arr
			    ,(char*)stRegUsuario.stloginCti.arr
			    ,(char*)stRegUsuario.stidStatusAtual.arr
			    ,(char*)stRegUsuario.stdescricaoStatusAtual.arr
			    ,(char*)stRegUsuario.stidMotivo.arr
			    ,(char*)stRegUsuario.stdsMotivo.arr
			    ,(char*)stRegUsuario.stdtInicio.arr
			    ,(char*)stRegUsuario.stdtRetorno.arr
			    ,(char*)stRegUsuario.stidCargoAtual.arr
			    ,(char*)stRegUsuario.stdescricaoCargoAtual.arr
			    ,(char*)stRegUsuario.stloginChefe.arr
			    ,(char*)stRegUsuario.stnomeChefe.arr
			    ,(char*)stRegUsuario.stidUF.arr
			    ,(char*)stRegUsuario.stnmUF.arr
			    ,(char*)stRegUsuario.stdtInclusao.arr
			    ,(char*)stRegUsuario.stdtExclusao.arr
			    ,(char*)stRegUsuario.stinConsultor.arr
				,(char*)stRegUsuario.stidUFOperadora.arr
                ,(char*)stRegUsuario.stidPerfilConsultorAtd.arr
                ,(char*)stRegUsuario.stidFornecedorConsultorAtd.arr
                ,(char*)stRegUsuario.stidSiteConsultorAtd.arr
                ,(char*)stRegUsuario.stdsLoginRoteamento.arr
			);
		}//if( iCont > iIni && iCont <  iFim )
	}//for(;;iContador++)
	EXEC SQL CLOSE CursorListComDocumento;

	if( iCont > iFim )
		iProximaPagina = 1;

	if( iCont > nTotalLinhas )
		sprintf( cContadorPagina, "mais de %d página(s)", (iCont/iregistrosPPagina)+1 );
	else
		sprintf( cContadorPagina, "%d página(s)", (iCont/iregistrosPPagina)+1 );

	ULOG_END("CUsr::ListComDocumento()");
	return iCont-1;

GotoListComDocumento:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CUsr::ListComNome( char* cnmnome,
                       char* cnmnomemeio,
					   char* cnmsobrenome,
					   char* cpaginaAtual,
					   char* cregistrosPPagina )
{                              
	ULOG_START("CUsr::ListComNome()");
	struct sqlca sqlca;        
	long iCont = 0;            
	EXEC SQL BEGIN DECLARE SECTION;
		long ipaginaAtual;     
		long iregistrosPPagina;
		long nTotalLinhas = TotalLinhasPorPesquisa();
		long iIni;
		long iFim;
		char cIni[21+1];
		char cFim[21+1];
		char cTotalLinhas[21+1];
		char cPesquisa[2000];
	//Dados para pesquisa      
		struct
		{
			char cAuxnmnome[255+1];
			char cAuxnmnomemeio[255+1];
			char cAuxnmsobrenome[255+1];
		} stUsuario6;
	//Estrutura pra recuperar um registro
		struct {
			VARCHAR stidUsuario[21+1];
			VARCHAR stnome[255+1];
			VARCHAR stsobrenome[255+1];
			VARCHAR stemail[255+1];
			VARCHAR stidDDD[21+1];
			VARCHAR stdsDDD[255+1];
			VARCHAR stTelefone[255+1];
			VARCHAR stlogin[255+1];
			VARCHAR stloginCti[255+1];
			VARCHAR stidStatusAtual[21+1];
			VARCHAR stdescricaoStatusAtual[255+1];
			VARCHAR stidMotivo[21+1];
			VARCHAR stdsMotivo[255+1];
			VARCHAR stdtInicio[255+1];
			VARCHAR stdtRetorno[255+1];
			VARCHAR stidCargoAtual[21+1];
			VARCHAR stdescricaoCargoAtual[255+1];
			VARCHAR stloginChefe[255+1];
			VARCHAR stnomeChefe[255+1];
			VARCHAR stidUF[21+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stdtInclusao[255+1];
			VARCHAR stdtExclusao[255+1];
			VARCHAR stinConsultor[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stidPerfilConsultorAtd[10+1];
			VARCHAR stidFornecedorConsultorAtd[10+1];
			VARCHAR stidSiteConsultorAtd[10+1];
            VARCHAR stdsLoginRoteamento[10+1];
		} stRegUsuario;        
		struct {
			short iidUsuario;   
			short inome;        
			short isobrenome;                 
			short iemail;                     
			short iidDDD;                     
			short idsDDD;                     
			short iTelefone;                  
			short ilogin;                     
			short iloginCti;                  
			short iidStatusAtual;             
			short idescricaoStatusAtual;      
			short iidMotivo;                  
			short idsMotivo;                  
			short idtInicio;                  
			short idtRetorno;                 
			short iidCargoAtual;              
			short idescricaoCargoAtual;       
			short iloginChefe;                
			short inomeChefe;                 
			short iidUF;                    
			short inmUF;                    
			short idtInclusao;                
			short idtExclusao;                
			short iinConsultor;
			short iidUFOperadora;
			short iidPerfilConsultorAtd;
			short iidFornecedorConsultorAtd;
			short iidSiteConsultorAtd;
            short idsLoginRoteamento;
		} stindicatorRegUsuario;              
	EXEC SQL END DECLARE SECTION;

	memset( &stUsuario6, 0, sizeof( stUsuario6) );
	memset( &cIni, 0, sizeof( cIni ) );
	memset( &cFim, 0, sizeof( cFim ) );
	memset( &cPesquisa, 0, sizeof( cPesquisa) );
	memset( &cTotalLinhas, 0, sizeof( cTotalLinhas ) );

	if( strlennull( cpaginaAtual ) <= 0 )
		ipaginaAtual = 0;
	else
		ipaginaAtual = atoi( cpaginaAtual )-1;
		                       
	if( ipaginaAtual < 0 )
		ipaginaAtual = 0;

	if( strlennull( cregistrosPPagina ) <= 0 )
		iregistrosPPagina = 100;
	else
		iregistrosPPagina = atoi( cregistrosPPagina );
	                           
	if( ( iregistrosPPagina <= 0 ) || ( iregistrosPPagina > 100 ) )
		iregistrosPPagina = 100;

	iIni = ipaginaAtual*iregistrosPPagina;
	iFim = iIni+iregistrosPPagina+1;

	//Metodo desta clase       
	iTamanhoPagina = iregistrosPPagina;

	if( strlennull( cnmnome ) > 0 )
	{                          
		strcpy( stUsuario6.cAuxnmnome, cnmnome );
		strcat( stUsuario6.cAuxnmnome, "%" );
	}
	if( strlennull( cnmnomemeio ) > 0 )
	{
		strcat( stUsuario6.cAuxnmnomemeio, cnmnomemeio );
		strcat( stUsuario6.cAuxnmnomemeio, "%" );
	}
	if( strlennull( cnmsobrenome ) > 0 )
	{                          
		strcat( stUsuario6.cAuxnmsobrenome, cnmsobrenome );
		strcat( stUsuario6.cAuxnmsobrenome, "%" );
	}

	EXEC SQL WHENEVER SQLERROR GOTO GotoListComNome;
	sqlca.sqlcode=0;

	sprintf( cIni,"%d", iIni );
	sprintf( cFim,"%d", iFim );
	sprintf( cTotalLinhas, "%ld", nTotalLinhas );

	//Retorna todas as pessoas que sao OU nao usuarios
	strcpy( cPesquisa,
	" SELECT DISTINCT"
		" IDPESSOA,"
		" NMNOME,"
		" NMSOBRENOME,"
		" DTCADASTRO,"
		" IDUF,"
		" NMUF,"
		" DTINICIO"
	" FROM"
	" ("
		" SELECT "
			" IDPESSOA,"
			" NMNOME,"
			" NMSOBRENOME,"
			" DTCADASTRO,"
			" IDUF,"
			" NMUF,"
			" DTINICIO"
		" FROM"
		" (" );
			if( strlennull( cnmnome ) > 0 )
			{
				strcat( cPesquisa, 
			" SELECT /*+ INDEX (PESSOA PESSOAIE1) INDEX (pessoadocumento PESSOADOCUMENTOIE1) */" );
			}
			else
			{
				if( strlennull( cnmnomemeio ) > 0 )
				{
					strcat( cPesquisa, 
			" SELECT  /*+ INDEX (PESSOA PESSOAIE5)*/" );
				}
				else
				{
					strcat( cPesquisa, 
			" SELECT  /*+ INDEX (PESSOA PESSOAIE4)*/" );
				}
			}
			strcat( cPesquisa, 
				" PESSOA.IDPESSOA,"
				" PESSOA.NMPESSOA NMNOME,"
				" PESSOA.NMSOBRENOME,"
				" PESSOA.DTCADASTRO,"
				" PESSOA.IDUF,"
                " ( SELECT NMUF FROM APOIO.UF WHERE PESSOA.IDUF = UF.IDUF ) AS NMUF, "
				" PESSOA.DTCADASTRO DTINICIO"
			" FROM"
				" CUSTOMER.PESSOA PESSOA,"
				" CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO "
			" WHERE"
				" PESSOA.IDPESSOA = PESSOADOCUMENTO.IDPESSOA"
			" AND "
                "PESSOADOCUMENTO.IDDOCUMENTO = "
                "( "
                    "SELECT "
                        "IDDOCUMENTO "
                    "FROM "
                        "CUSTOMER.DOCUMENTO "
                    "WHERE "
                        "DOCUMENTO.IDDOCUMENTO = PESSOADOCUMENTO.IDDOCUMENTO "
                    "AND "
                        "DOCUMENTO.IDTIPODOCUMENTO IN "
                    	"("
                        	"SELECT "
                        		"IDTIPODOCUMENTO "
                        	"FROM "
                        		"APOIO.TIPODOCUMENTO "
                        	"WHERE "
                        		"(SGTIPODOCUMENTO IN( 'CPF', 'RG', 'RE' ) OR SGCLASSIFICACAO = 'CPF')"
                    	") "
                ") "
			" AND "
				" ROWNUM <= 100" ); //estava dando TPTIME em produção após Sanity-GA Abril/2007
			//strcat( cPesquisa, cTotalLinhas );
			//strcat( cPesquisa, " * 3 " );
			if( strlennull( stUsuario6.cAuxnmnome ) > 0 )
			{
				strcat( cPesquisa, 
				" AND"
					" UPPER( PESSOA.NMNOME ) LIKE UPPER('" );
				strcat( cPesquisa, stUsuario6.cAuxnmnome );
				strcat( cPesquisa, "%')" );
			}
			if( strlennull( stUsuario6.cAuxnmnomemeio ) > 0 )
			{
				strcat( cPesquisa, 
				" AND" \
					" UPPER(PESSOA.NMNOMEMEIO) LIKE UPPER('" );
				strcat( cPesquisa, stUsuario6.cAuxnmnomemeio );
				strcat( cPesquisa, "%')" );
			}
			if( strlennull( stUsuario6.cAuxnmsobrenome ) > 0 )
			{
				strcat( cPesquisa, 
				" AND" \
					" UPPER(PESSOA.NMSOBRENOME) LIKE UPPER('" );
				strcat( cPesquisa, stUsuario6.cAuxnmsobrenome );
				strcat( cPesquisa, "%')" );
			}
	strcat( cPesquisa,
		" )"
	" )" 
	);

	ULOG("Query:[%s]", cPesquisa);

	EXEC SQL PREPARE qPesquisa FROM :cPesquisa;
	EXEC SQL DECLARE CursorListComNome CURSOR FOR qPesquisa;
	EXEC SQL OPEN CursorListComNome;
                               
	//Por default, zero indica nao haver mais paginas
	iProximaPagina = 0;        
	for(iCont = 1;;iCont++)                    
	{                          
		EXEC SQL WHENEVER NOT FOUND DO break;
		memset( &stRegUsuario, 0, sizeof(stRegUsuario) );
		EXEC SQL               
		FETCH                  
			CursorListComNome  
		INTO                   
			:stRegUsuario.stidUsuario :stindicatorRegUsuario.iidUsuario,
			:stRegUsuario.stnome      :stindicatorRegUsuario.inome,
			:stRegUsuario.stsobrenome :stindicatorRegUsuario.isobrenome,
			:stRegUsuario.stdtInicio  :stindicatorRegUsuario.idtInicio,
			:stRegUsuario.stidUF      :stindicatorRegUsuario.iidUF,
			:stRegUsuario.stnmUF      :stindicatorRegUsuario.inmUF,
			:stRegUsuario.stdtInclusao:stindicatorRegUsuario.idtInclusao;
			                   
		if( iCont > iIni && iCont <  iFim )
		{
			//Para cada pessoa encontrada, eh necessário verificar se existe um usuario
			EXEC SQL WHENEVER NOT FOUND CONTINUE;
			EXEC SQL               
			SELECT                 
				 USUARIO.DSEMAIL   
				,USUARIO.IDAREAREGISTRO
				,AREAREGISTRO.CDAREAREGISTRO
				,USUARIO.NRTELEFONE
				,USUARIO.NMLOGINUSUARIO
				,USUARIO.NMLOGINUSUARIOCTI
				,USUARIO.IDSTATUSUSUARIO
				,STATUSUSUARIO.DSSTATUSUSUARIO
				,0  IDMOTIVO       
				,'' DSMOTIVO       
				,USUARIO.DTSTATUSUSUARIO
				,0  IDCARGO        
				,'' DSCARGO        
                ,USUARIOCHEFE.NMLOGINUSUARIO AS NMLOGINUSUARIOCHEFE
				,PESSOACHEFE.NMPESSOA NMPESSOACHEFE
				,USUARIO.DTSTATUSUSUARIO DTEXCLUSAO
				,USUARIO.INCONSULTOR
				,USUARIO.IDUFOPERADORA
                ,USUARIO.IDPERFILCONSULTORATD
                ,USUARIO.IDFORNECEDORCONSULTORATD
                ,USUARIO.IDSITECONSULTORATD
                ,USUARIO.DSLOGINROTEAMENTO
			INTO                   
				:stRegUsuario.stemail                    :stindicatorRegUsuario.iemail,
				:stRegUsuario.stidDDD                    :stindicatorRegUsuario.iidDDD,
				:stRegUsuario.stdsDDD                    :stindicatorRegUsuario.idsDDD,
				:stRegUsuario.stTelefone                 :stindicatorRegUsuario.iTelefone,
				:stRegUsuario.stlogin                    :stindicatorRegUsuario.ilogin,
				:stRegUsuario.stloginCti                 :stindicatorRegUsuario.iloginCti,
				:stRegUsuario.stidStatusAtual            :stindicatorRegUsuario.iidStatusAtual,
				:stRegUsuario.stdescricaoStatusAtual     :stindicatorRegUsuario.idescricaoStatusAtual,
				:stRegUsuario.stidMotivo                 :stindicatorRegUsuario.iidMotivo,
				:stRegUsuario.stdsMotivo                 :stindicatorRegUsuario.idsMotivo,
				:stRegUsuario.stdtRetorno                :stindicatorRegUsuario.idtRetorno,
				:stRegUsuario.stidCargoAtual             :stindicatorRegUsuario.iidCargoAtual,
				:stRegUsuario.stdescricaoCargoAtual      :stindicatorRegUsuario.idescricaoCargoAtual,
				:stRegUsuario.stloginChefe               :stindicatorRegUsuario.iloginChefe,
				:stRegUsuario.stnomeChefe                :stindicatorRegUsuario.inomeChefe,
				:stRegUsuario.stdtExclusao               :stindicatorRegUsuario.idtExclusao,
				:stRegUsuario.stinConsultor              :stindicatorRegUsuario.iinConsultor,
				:stRegUsuario.stidUFOperadora            :stindicatorRegUsuario.iidUFOperadora,
				:stRegUsuario.stidPerfilConsultorAtd     :stindicatorRegUsuario.iidPerfilConsultorAtd,
				:stRegUsuario.stidFornecedorConsultorAtd :stindicatorRegUsuario.iidFornecedorConsultorAtd,
				:stRegUsuario.stidSiteConsultorAtd       :stindicatorRegUsuario.iidSiteConsultorAtd,
				:stRegUsuario.stdsLoginRoteamento        :stindicatorRegUsuario.idsLoginRoteamento
			FROM                   
				ACESSO.USUARIO USUARIO,
				ACESSO.USUARIOHIERARQUIA USUARIOHIERARQUIA,
				ACESSO.USUARIO USUARIOCHEFE,
				CUSTOMER.PESSOA PESSOACHEFE,
				APOIO.STATUSUSUARIO STATUSUSUARIO,
				APOIO.AREAREGISTRO AREAREGISTRO
			WHERE                  
				USUARIO.IDSTATUSUSUARIO = STATUSUSUARIO.IDSTATUSUSUARIO
			AND                    
				USUARIO.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
			AND                    
				USUARIO.IDPESSOAUSUARIO = USUARIOHIERARQUIA.IDPESSOAUSUARIO(+)
			AND                    
				USUARIOHIERARQUIA.IDPESSOAUSUARIOCHEFE = USUARIOCHEFE.IDPESSOAUSUARIO(+)
			AND                    
				USUARIOCHEFE.IDPESSOAUSUARIO = PESSOACHEFE.IDPESSOA(+)
			AND                    
				USUARIO.IDPESSOAUSUARIO = :stRegUsuario.stidUsuario;
			                               
			Add( (char*)stRegUsuario.stidUsuario.arr
			    ,(char*)stRegUsuario.stnome.arr
			    ,(char*)stRegUsuario.stsobrenome.arr
			    ,(char*)stRegUsuario.stemail.arr
			    ,(char*)stRegUsuario.stidDDD.arr
			    ,(char*)stRegUsuario.stdsDDD.arr
			    ,(char*)stRegUsuario.stTelefone.arr
			    ,(char*)stRegUsuario.stlogin.arr
			    ,(char*)stRegUsuario.stloginCti.arr
			    ,(char*)stRegUsuario.stidStatusAtual.arr
			    ,(char*)stRegUsuario.stdescricaoStatusAtual.arr
			    ,(char*)stRegUsuario.stidMotivo.arr
			    ,(char*)stRegUsuario.stdsMotivo.arr
			    ,(char*)stRegUsuario.stdtInicio.arr
			    ,(char*)stRegUsuario.stdtRetorno.arr
			    ,(char*)stRegUsuario.stidCargoAtual.arr
			    ,(char*)stRegUsuario.stdescricaoCargoAtual.arr
			    ,(char*)stRegUsuario.stloginChefe.arr
			    ,(char*)stRegUsuario.stnomeChefe.arr
			    ,(char*)stRegUsuario.stidUF.arr
			    ,(char*)stRegUsuario.stnmUF.arr
			    ,(char*)stRegUsuario.stdtInclusao.arr
			    ,(char*)stRegUsuario.stdtExclusao.arr
			    ,(char*)stRegUsuario.stinConsultor.arr
				,(char*)stRegUsuario.stidUFOperadora.arr
                ,(char*)stRegUsuario.stidPerfilConsultorAtd.arr
                ,(char*)stRegUsuario.stidFornecedorConsultorAtd.arr
                ,(char*)stRegUsuario.stidSiteConsultorAtd.arr
                ,(char*)stRegUsuario.stdsLoginRoteamento.arr
			);                             
		}//if( iCont > iIni && iCont <  iFim )
	}//for(;;iContador++)                  
	EXEC SQL CLOSE CursorListComNome;      

	if( iCont > iFim )
		iProximaPagina = 1;

	if( iCont > nTotalLinhas )
		sprintf( cContadorPagina, "mais de %d página(s)", (iCont/iregistrosPPagina)+1 );
	else
		sprintf( cContadorPagina, "%d página(s)", (iCont/iregistrosPPagina)+1 );

	ULOG_END("CUsr::ListComNome()");
	return iCont-1;                          
                                           
GotoListComNome:                           
	throw TuxBasicOraException(sqlca.sqlcode);
                                           
}                                          

int CUsr::ListSemParametro( char* cpaginaAtual,
					        char* cregistrosPPagina )
{
	ULOG_START("CUsr::ListSemParametro()");
	struct sqlca sqlca;
	long iCont = 0;
	EXEC SQL BEGIN DECLARE SECTION;
		long ipaginaAtual;
		long iregistrosPPagina;
		long nTotalLinhas = TotalLinhasPorPesquisa();
		long iIni;
		long iFim;
	//Dados para pesquisa
		struct 
		{
			char cAuxnmnome[512+1];
		} stUsuario;
	//Estrutura pra recuperar um registro
		struct {
			VARCHAR stidUsuario[21+1];
			VARCHAR stnome[255+1];
			VARCHAR stsobrenome[255+1];
			VARCHAR stemail[255+1];
			VARCHAR stidDDD[21+1];
			VARCHAR stdsDDD[255+1];
			VARCHAR stTelefone[255+1];
			VARCHAR stlogin[255+1];
			VARCHAR stloginCti[255+1];
			VARCHAR stidStatusAtual[21+1];
			VARCHAR stdescricaoStatusAtual[255+1];
			VARCHAR stidMotivo[21+1];
			VARCHAR stdsMotivo[255+1];
			VARCHAR stdtInicio[255+1];
			VARCHAR stdtRetorno[255+1];
			VARCHAR stidCargoAtual[21+1];
			VARCHAR stdescricaoCargoAtual[255+1];
			VARCHAR stloginChefe[255+1];
			VARCHAR stnomeChefe[255+1];
			VARCHAR stidUF[21+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stdtInclusao[255+1];
			VARCHAR stdtExclusao[255+1];
			VARCHAR stinConsultor[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stidPerfilConsultorAtd[10+1];
			VARCHAR stidFornecedorConsultorAtd[10+1];
			VARCHAR stidSiteConsultorAtd[10+1];
            VARCHAR stdsLoginRoteamento[10+1];
		} stRegUsuario;
		struct {                
			short iidUsuario;   
			short inome;        
			short isobrenome;                 
			short iemail;                     
			short iidDDD;                     
			short idsDDD;                     
			short iTelefone;                  
			short ilogin;                     
			short iloginCti;                  
			short iidStatusAtual;             
			short idescricaoStatusAtual;      
			short iidMotivo;                  
			short idsMotivo;                  
			short idtInicio;                  
			short idtRetorno;                 
			short iidCargoAtual;              
			short idescricaoCargoAtual;       
			short iloginChefe;                
			short inomeChefe;                 
			short iidUF;                    
			short inmUF;                    
			short idtInclusao;                
			short idtExclusao;                
			short iinConsultor;
			short iidUFOperadora;
			short iidPerfilConsultorAtd;
			short iidFornecedorConsultorAtd;
			short iidSiteConsultorAtd;
            short idsLoginRoteamento;
		} stindicatorRegUsuario;              
	EXEC SQL END DECLARE SECTION;
	          
	memset( &stUsuario, 0, sizeof( stUsuario) );
	
	if( strlennull( cpaginaAtual ) <= 0 )
		ipaginaAtual = 0;
	else
		ipaginaAtual = atoi( cpaginaAtual )-1;
		
	if( ipaginaAtual < 0 )
		ipaginaAtual = 0;

	if( strlennull( cregistrosPPagina ) <= 0 )
		iregistrosPPagina = 100;
	else
		iregistrosPPagina = atoi( cregistrosPPagina );
	
	if( ( iregistrosPPagina <= 0 ) || ( iregistrosPPagina > 100 ) )
		iregistrosPPagina = 100;
		
	iIni = ipaginaAtual*iregistrosPPagina;
	iFim = iIni+iregistrosPPagina+1;
	
	//Metodo desta clase
	iTamanhoPagina = iregistrosPPagina;
	
	EXEC SQL WHENEVER SQLERROR GOTO GotoListSemParametro;
	sqlca.sqlcode=0;
	
	//Retorna todas as pessoas que sao usuario
	EXEC SQL
	DECLARE 
	   	CursorListSemParametro CURSOR FOR
	SELECT DISTINCT
	     IDPESSOA
	    ,NMNOME
	    ,NMSOBRENOME
	    ,DTCADASTRO
	    ,IDUF
	    ,NMUF
	    ,DTINICIO
	FROM
	(
		SELECT
			 IDPESSOA
			,NMNOME
			,NMSOBRENOME
			,DTCADASTRO
			,IDUF
			,NMUF
			,DTINICIO
		FROM
		(
			SELECT
		     PESSOA.IDPESSOA
		    ,PESSOA.NMPESSOA NMNOME
		    ,PESSOA.NMSOBRENOME
		    ,PESSOA.DTCADASTRO
		    ,UF.IDUF
		    ,UF.NMUF
		    ,PESSOA.DTCADASTRO DTINICIO
		FROM 
		    CUSTOMER.PESSOA,
		    CUSTOMER.PESSOADOCUMENTO,
		    APOIO.UF UF,
		    (
		        SELECT
		            DOCUMENTO.IDDOCUMENTO
		        FROM
		            CUSTOMER.DOCUMENTO,
		            APOIO.TIPODOCUMENTO
		        WHERE
		            DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
		        AND 
		        (
		            TIPODOCUMENTO.SGCLASSIFICACAO = 'CPF'
		            OR
		            TIPODOCUMENTO.SGTIPODOCUMENTO = 'RG'
		            OR
		            TIPODOCUMENTO.SGTIPODOCUMENTO = 'RE'
		        )
				AND 
					ROWNUM <= ( :nTotalLinhas * 4 )
		    ) DOCUMENTOFILTRADO
		WHERE
		    PESSOA.IDPESSOA = PESSOADOCUMENTO.IDPESSOA
		AND
		    PESSOA.IDUF = UF.IDUF
		AND
		    PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTOFILTRADO.IDDOCUMENTO
		)
	);

	EXEC SQL OPEN CursorListSemParametro;

	//Por default, zero indica nao haver mais paginas
	iProximaPagina = 0;
	for(iCont=1;;iCont++)
	{
		EXEC SQL WHENEVER NOT FOUND DO break;
		memset( &stRegUsuario, 0, sizeof(stRegUsuario) );
		EXEC SQL 
		FETCH 
			CursorListSemParametro 
		INTO 
			:stRegUsuario.stidUsuario :stindicatorRegUsuario.iidUsuario,
			:stRegUsuario.stnome      :stindicatorRegUsuario.inome,
			:stRegUsuario.stsobrenome :stindicatorRegUsuario.isobrenome,
			:stRegUsuario.stdtInicio  :stindicatorRegUsuario.idtInicio,
			:stRegUsuario.stidUF      :stindicatorRegUsuario.iidUF,
			:stRegUsuario.stnmUF      :stindicatorRegUsuario.inmUF,
			:stRegUsuario.stdtInclusao:stindicatorRegUsuario.idtInclusao;
			
		if( iCont > iIni && iCont <  iFim )
		{
			//Para cada pessoa encontrada, eh necessário verificar se existe um usuario
			EXEC SQL WHENEVER NOT FOUND CONTINUE;
			EXEC SQL
			SELECT
				 USUARIO.DSEMAIL
				,USUARIO.IDAREAREGISTRO
				,AREAREGISTRO.CDAREAREGISTRO
				,USUARIO.NRTELEFONE
				,USUARIO.NMLOGINUSUARIO
				,USUARIO.NMLOGINUSUARIOCTI
				,USUARIO.IDSTATUSUSUARIO
				,STATUSUSUARIO.DSSTATUSUSUARIO
				,0  IDMOTIVO
				,'' DSMOTIVO
				,USUARIO.DTSTATUSUSUARIO
				,0  IDCARGO
				,'' DSCARGO
                ,USUARIOCHEFE.NMLOGINUSUARIO AS NMLOGINUSUARIOCHEFE
				,PESSOACHEFE.NMPESSOA NMPESSOACHEFE
				,USUARIO.DTSTATUSUSUARIO DTEXCLUSAO
				,USUARIO.INCONSULTOR
				,USUARIO.IDUFOPERADORA
                ,USUARIO.IDPERFILCONSULTORATD
                ,USUARIO.IDFORNECEDORCONSULTORATD
                ,USUARIO.IDSITECONSULTORATD
                ,USUARIO.DSLOGINROTEAMENTO
			INTO
				:stRegUsuario.stemail                    :stindicatorRegUsuario.iemail,
				:stRegUsuario.stidDDD                    :stindicatorRegUsuario.iidDDD,
				:stRegUsuario.stdsDDD                    :stindicatorRegUsuario.idsDDD,
				:stRegUsuario.stTelefone                 :stindicatorRegUsuario.iTelefone,
				:stRegUsuario.stlogin                    :stindicatorRegUsuario.ilogin,
				:stRegUsuario.stloginCti                 :stindicatorRegUsuario.iloginCti,
				:stRegUsuario.stidStatusAtual            :stindicatorRegUsuario.iidStatusAtual,
				:stRegUsuario.stdescricaoStatusAtual     :stindicatorRegUsuario.idescricaoStatusAtual,
				:stRegUsuario.stidMotivo                 :stindicatorRegUsuario.iidMotivo,
				:stRegUsuario.stdsMotivo                 :stindicatorRegUsuario.idsMotivo,
				:stRegUsuario.stdtRetorno                :stindicatorRegUsuario.idtRetorno,
				:stRegUsuario.stidCargoAtual             :stindicatorRegUsuario.iidCargoAtual,
				:stRegUsuario.stdescricaoCargoAtual      :stindicatorRegUsuario.idescricaoCargoAtual,
				:stRegUsuario.stloginChefe               :stindicatorRegUsuario.iloginChefe,
				:stRegUsuario.stnomeChefe                :stindicatorRegUsuario.inomeChefe,
				:stRegUsuario.stdtExclusao               :stindicatorRegUsuario.idtExclusao,
				:stRegUsuario.stinConsultor              :stindicatorRegUsuario.iinConsultor,
				:stRegUsuario.stidUFOperadora            :stindicatorRegUsuario.iidUFOperadora,
				:stRegUsuario.stidPerfilConsultorAtd     :stindicatorRegUsuario.iidPerfilConsultorAtd,
				:stRegUsuario.stidFornecedorConsultorAtd :stindicatorRegUsuario.iidFornecedorConsultorAtd,
				:stRegUsuario.stidSiteConsultorAtd       :stindicatorRegUsuario.iidSiteConsultorAtd,
				:stRegUsuario.stdsLoginRoteamento        :stindicatorRegUsuario.idsLoginRoteamento
			FROM 
				ACESSO.USUARIO USUARIO,
				ACESSO.USUARIOHIERARQUIA USUARIOHIERARQUIA,
				ACESSO.USUARIO USUARIOCHEFE,
				CUSTOMER.PESSOA PESSOACHEFE,
				APOIO.STATUSUSUARIO STATUSUSUARIO,
				APOIO.AREAREGISTRO AREAREGISTRO
			WHERE
				USUARIO.IDSTATUSUSUARIO = STATUSUSUARIO.IDSTATUSUSUARIO
			AND
				USUARIO.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
			AND
				USUARIO.IDPESSOAUSUARIO = USUARIOHIERARQUIA.IDPESSOAUSUARIO(+)
			AND
				USUARIOHIERARQUIA.IDPESSOAUSUARIOCHEFE = USUARIOCHEFE.IDPESSOAUSUARIO(+)
			AND
				USUARIOCHEFE.IDPESSOAUSUARIO = PESSOACHEFE.IDPESSOA(+)
			AND
				USUARIO.IDPESSOAUSUARIO = :stRegUsuario.stidUsuario;
			
			Add( (char*)stRegUsuario.stidUsuario.arr
			    ,(char*)stRegUsuario.stnome.arr
			    ,(char*)stRegUsuario.stsobrenome.arr
			    ,(char*)stRegUsuario.stemail.arr
			    ,(char*)stRegUsuario.stidDDD.arr
			    ,(char*)stRegUsuario.stdsDDD.arr
			    ,(char*)stRegUsuario.stTelefone.arr
			    ,(char*)stRegUsuario.stlogin.arr
			    ,(char*)stRegUsuario.stloginCti.arr
			    ,(char*)stRegUsuario.stidStatusAtual.arr
			    ,(char*)stRegUsuario.stdescricaoStatusAtual.arr
			    ,(char*)stRegUsuario.stidMotivo.arr
			    ,(char*)stRegUsuario.stdsMotivo.arr
			    ,(char*)stRegUsuario.stdtInicio.arr
			    ,(char*)stRegUsuario.stdtRetorno.arr
			    ,(char*)stRegUsuario.stidCargoAtual.arr
			    ,(char*)stRegUsuario.stdescricaoCargoAtual.arr
			    ,(char*)stRegUsuario.stloginChefe.arr
			    ,(char*)stRegUsuario.stnomeChefe.arr
			    ,(char*)stRegUsuario.stidUF.arr
			    ,(char*)stRegUsuario.stnmUF.arr
			    ,(char*)stRegUsuario.stdtInclusao.arr
			    ,(char*)stRegUsuario.stdtExclusao.arr
			    ,(char*)stRegUsuario.stinConsultor.arr
				,(char*)stRegUsuario.stidUFOperadora.arr
                ,(char*)stRegUsuario.stidPerfilConsultorAtd.arr
                ,(char*)stRegUsuario.stidFornecedorConsultorAtd.arr
                ,(char*)stRegUsuario.stidSiteConsultorAtd.arr
                ,(char*)stRegUsuario.stdsLoginRoteamento.arr
			);
		}//if( iCont > iIni && iCont <  iFim )
	}//for(;;iContador++)
	EXEC SQL CLOSE CursorListSemParametro;

	if( iCont > iFim )
		iProximaPagina = 1;

	if( iCont > nTotalLinhas )
		sprintf( cContadorPagina, "mais de %d página(s)", (iCont/iregistrosPPagina)+1 );
	else
		sprintf( cContadorPagina, "%d página(s)", (iCont/iregistrosPPagina)+1 );

	ULOG_END("CUsr::ListSemParametro()");
	return iCont-1;

GotoListSemParametro:
	throw TuxBasicOraException(sqlca.sqlcode);

}


/**
Pesquisa desenvolvida para busca de usuários quando indicado uma chave
do módulo de organograma com filtro.
*/
int CUsr::ListComOrganograma( 	
                char* cnmnome,
                char* cnmnomemeio,
				char* cnmsobrenome,
				char* cidUFOperadora,
				char* clogin,
				char* cloginCti,
				char* cidStatusAtual,
				char* cidCargoAtual,
				char* cloginChefe,
				char* csgTipoDocAtual,
				char* cdsDocAtual,
				char* cinConsultor,
				char* cpaginaAtual,
				char* cregistrosPPagina,
				char* cIdNivel,
				char* cIdCargo,
				char* cIdOrganizacao,
				char* cIdDepartamento )
{

	ULOG_START("CUsr::ListComOrganograma()");
	int iUsuario = 0;
	int iPessoa = 0;
	int iCount = 0;

	if( strlennull( cnmnome ) > 0 )
		iPessoa = 1;
	if( strlennull( cnmnomemeio ) > 0 )
		iPessoa = 1;
	if( strlennull( cnmsobrenome ) > 0 )
		iPessoa = 1;
	if( strlennull( csgTipoDocAtual ) > 0 )
		iPessoa = 1;
	if( strlennull( cdsDocAtual ) > 0 )
		iPessoa = 1;
	if( strlennull( cIdNivel ) > 0 )
		iPessoa = 1;
	if( strlennull( cIdCargo ) > 0 )
		iPessoa = 1;
	if( strlennull( cIdOrganizacao ) > 0 )
		iPessoa = 1;
	if( strlennull( cIdDepartamento ) > 0 )
		iPessoa = 1;


	if( strlennull( cidUFOperadora ) > 0 )
		iUsuario = 1;
	if( strlennull( clogin ) > 0 )
		iUsuario = 1;
	if( strlennull( cloginCti ) > 0 )
		iUsuario = 1;
	if( strlennull( cidStatusAtual ) > 0 )
		iUsuario = 1;
	if( strlennull( cidCargoAtual ) > 0 )
		iUsuario = 1;
	if( strlennull( cloginChefe ) > 0 )
		iUsuario = 1;
	if( strlennull( cinConsultor ) > 0 )
		iUsuario = 1;



	ULOG("\n**********************"); 
    ULOG("\n**ListComOrganograma**"); 
    ULOG("\n**********************"); 

	ULOG("ListComOrganograma(\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s", 
		                cnmnome,
		                cnmnomemeio,
						cnmsobrenome,
						cidUFOperadora,
						clogin,
						cloginCti,
						cidStatusAtual,
						cidCargoAtual,
						cloginChefe,
						csgTipoDocAtual,
						cdsDocAtual,
						cinConsultor,
						cpaginaAtual,
						cregistrosPPagina,
						cIdNivel,
						cIdCargo,
						cIdOrganizacao,
						cIdDepartamento 
		); 

    ULOG("\n iPessoa [%d]",iPessoa); 
    ULOG("\n iUsuario [%d]",iUsuario); 

    if (iUsuario)
        iCount = ListComOrganogramaUsuario( cnmnome,
		                                   cnmnomemeio,
				                           cnmsobrenome,
				                           cidUFOperadora,
				                           clogin,
				                           cloginCti,
				                           cidStatusAtual,
				                           cidCargoAtual,
				                           cloginChefe,
				                           csgTipoDocAtual,
				                           cdsDocAtual,
				                           cinConsultor,
				                           cpaginaAtual,
				                           cregistrosPPagina,
				                           cIdNivel,
				                           cIdCargo,
				                           cIdOrganizacao,
				                           cIdDepartamento );
    else if (iPessoa)
       iCount =  ListComOrganogramaPessoa( cnmnome,
		                                   cnmnomemeio,
				                           cnmsobrenome,
				                           cidUFOperadora,
				                           clogin,
				                           cloginCti,
				                           cidStatusAtual,
				                           cidCargoAtual,
				                           cloginChefe,
				                           csgTipoDocAtual,
				                           cdsDocAtual,
				                           cinConsultor,
				                           cpaginaAtual,
				                           cregistrosPPagina,
				                           cIdNivel,
				                           cIdCargo,
				                           cIdOrganizacao,
				                           cIdDepartamento );
	
	ULOG_END("CUsr::ListComOrganograma()");
	return iCount;
}



int CUsr::InsertUsuarioUFOperadora( char* cidUsuario
		                           ,char* cidUFOperadora
		                           ,char* cidUser )
{
	ULOG_START("CUsr::InsertUsuarioUFOperadora()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidUsuario = cidUsuario;
		char* cAuxidUFOperadora = cidUFOperadora;
		char* cAuxidUser = cidUser;
		long   iCount = 0;
	EXEC SQL END DECLARE SECTION;
	
	if( strlennull( cidUsuario ) <= 0 )
	{
		strcpy( cErro, "cidUsuario está nulo" );
		ULOG_END("CUsr::InsertUsuarioUFOperadora()");
		return 0;
	}
	if( strlennull( cidUFOperadora ) <= 0 )
	{
		strcpy( cErro, "idUFOperadora está nulo" );
		ULOG_END("CUsr::InsertUsuarioUFOperadora()");
		return 0;
	}

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUsuarioUFOperadora;
	sqlca.sqlcode=0;
	
	//Caso ja exista a relacao deste usuario com a operadora, nao faz nada
	EXEC SQL
		SELECT
			COUNT( IDPESSOAUSUARIO )
		INTO
			:iCount
		FROM
			ACESSO.USUARIOUFOPERADORA
		WHERE
			IDPESSOAUSUARIO = :cAuxidUsuario
		AND
			IDUFOPERADORA = :cAuxidUFOperadora;

	if( iCount <= 0 )
	{
		//Insere a relacao Usuario Cargo
		EXEC SQL
			INSERT INTO ACESSO.USUARIOUFOPERADORA
			  (IDUSUARIOUFOPERADORA,
			   IDPESSOAUSUARIO,
			   IDUFOPERADORA,
			   IDUSUARIOALTERACAO,
			   DTULTIMAALTERACAO)
			VALUES
			  ( ACESSO.USUARIOUFOPERADORASQ.NEXTVAL
			   ,:cAuxidUsuario
			   ,:cAuxidUFOperadora
			   ,TO_NUMBER(:cAuxidUser)
			   ,SYSDATE);

		if(sqlca.sqlcode)
		{
			ULOG_END("CUsr::InsertUsuarioUFOperadora()");
			return 0;
		}
	}

	ULOG_END("CUsr::InsertUsuarioUFOperadora()");
	return 1;

GotoUsuarioUFOperadora:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::FindIdUser( char* cidUsuario )
{
	ULOG_START("CUsr::FindIdUser()");
	if( Quantidade() > 0 )
	{
		for(long x=0; x < Quantidade(); x++ )
		{
			if( strcmp( Registro(x)->cidUsuario, cidUsuario ) == 0 )
			{
				ULOG_END("CUsr::FindIdUser()");
				return 1;
			}
		}
	}
	ULOG_END("CUsr::FindIdUser()");
	return 0;
}
//------------
int CUsr::AltStatusUsu(DOMNode*dnode,XMLGen*xml_g)
{
	ULOG_START("CUsr::AltStatusUsu()");
	struct sqlca sqlca;
	char *pcidUsuario=NULL;
	char *pcidStatus=NULL;
	char *pcidGrupo=NULL;
	CSafePointer oSafePointer;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidUsuario;
		char* cAuxidStatus;
		char* cAuxidGrupo;
	EXEC SQL END DECLARE SECTION;

	//Recupera informacao do xml de entrada
	pcidUsuario = oSafePointer.getTag(dnode,"idUsuario",0);
	pcidStatus  = oSafePointer.getTag(dnode,"inSupervisor",0);
	pcidGrupo   = oSafePointer.getTag(dnode,"idGrupo",0);

	ULOGI("AltStatusUsu - Valores [%s] [%s] [%s]",	pcidUsuario,pcidStatus,pcidGrupo);

	//Consiste
	if(pcidUsuario==NULL || strlen(pcidUsuario)==0)
	{
	    ULOG_END("CUsr::AltStatusUsu()");
		return(2);
	}
	if(pcidStatus==NULL || strlen(pcidStatus)==0)
	{
		ULOG_END("CUsr::AltStatusUsu()");
		return(2);
	}
	if(pcidGrupo==NULL || strlen(pcidGrupo)==0)
    {
		ULOG_END("CUsr::AltStatusUsu()");
		return(2);		
	}

	//Atualiza variaveis
	cAuxidUsuario=pcidUsuario;
	cAuxidStatus=pcidStatus;
	cAuxidGrupo=pcidGrupo;

	EXEC SQL WHENEVER NOT FOUND goto GotoUsuarioStatus;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUsuarioStatus;

	EXEC SQL
		update ACESSO.USUARIOGRUPO 
		set 
			INSUPERVISOR = :cAuxidStatus,
			DTULTIMAALTERACAO = sysdate
		where 
			IDGRUPO = :cAuxidGrupo 
		and 
			idpessoausuario = :cAuxidUsuario;

    ULOG_END("CUsr::AltStatusUsu()");
	return(0);

GotoUsuarioStatus:
	ULOGI("AltStatusUsu - Saindo com erro");
	ULOG_END("CUsr::AltStatusUsu()");
	return(10);
}

int CUsr::ExisteDocumento( char* cidUsuario
			              ,char* cnrDocumento
						  ,char* cidTipoDocumento )
{
	ULOG_START("CUsr::ExisteDocumento()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidUsuario = cidUsuario;
		char* cAuxnrDocumento = cnrDocumento;
		char* cAuxidTipoDocumento = cidTipoDocumento;
		long   iCount = 0;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoExisteDocumento;
	sqlca.sqlcode=0;
	
	//Verifica se existem mais pessoas, que seja usuarias, com o mesmo documento
	if( strlennull( cidUsuario ) > 0 )
	{
		//Havendo o IDPESSOAUSUARIO, verifica se existe o documento outras pessoas
		EXEC SQL
		SELECT
			COUNT(1)
		INTO
			:iCount
		FROM
			CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
			CUSTOMER.DOCUMENTO DOCUMENTO,
            CUSTOMER.PESSOA PESSOA,
			ACESSO.USUARIO USUARIO
		WHERE
			PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
        AND
            PESSOADOCUMENTO.IDPESSOA = PESSOA.IDPESSOA
		AND
			PESSOA.IDPESSOA = USUARIO.IDPESSOAUSUARIO
		AND
			DOCUMENTO.NRDOCUMENTO = :cAuxnrDocumento
		AND
			DOCUMENTO.IDTIPODOCUMENTO = :cAuxidTipoDocumento
		AND
			PESSOADOCUMENTO.IDPESSOA <> :cAuxidUsuario;
	}
	else
	{
		//Nao havendo o IDPESSOAUSUARIO, verifica se existe para qualquer pessoa
		EXEC SQL
		SELECT
			COUNT(1)
		INTO
			:iCount
		FROM
			CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
			CUSTOMER.DOCUMENTO DOCUMENTO,
            CUSTOMER.PESSOA PESSOA,
			ACESSO.USUARIO USUARIO
		WHERE
			PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
        AND
            PESSOADOCUMENTO.IDPESSOA = PESSOA.IDPESSOA
		AND
			PESSOA.IDPESSOA = USUARIO.IDPESSOAUSUARIO
		AND
			DOCUMENTO.NRDOCUMENTO = :cAuxnrDocumento
		AND
			DOCUMENTO.IDTIPODOCUMENTO = :cAuxidTipoDocumento;
	}
	ULOG_END("CUsr::ExisteDocumento()");
	return iCount;
GotoExisteDocumento:
	throw TuxBasicOraException(sqlca.sqlcode);
}

void CUsr::removeAtendimentos(const char *cLogUserOra,const char* pzcidPessoaUsuario)
{
	ULOG_START("CUsr::removeAtendimentos()");

    /* cWFAtdGerarXMLDPR cwfatdgerarxmldpr; */
	struct sqlca sqlca;

    // SM324--DPR--FEV/2007--Cassio
    // INSERT/UPDATE/DELETE em ATENDIMENTOUSUARIOATUAL é monitorado pelo DPR

    // EXEC SQL BEGIN DECLARE SECTION;
	// 	char* cAuxidPessoaUsuario = pzcidPessoaUsuario;
   	// EXEC SQL END DECLARE SECTION;

	// memset( &sqlca, 0, sizeof( sqlca ) );

	// EXEC SQL WHENEVER SQLERROR GOTO GotoRemoveAtendimentos;
	// EXEC SQL WHENEVER NOT FOUND CONTINUE;

	// EXEC SQL
	// 	DELETE FROM
	// 		ATENDIMENTO.ATENDIMENTOUSUARIOATUAL
	// 	WHERE
	// 		IDPESSOAUSUARIO = :cAuxidPessoaUsuario;

    EXEC SQL BEGIN DECLARE SECTION;

        const char *idUsuarioAlteracao = cLogUserOra;
        const char *cAuxidPessoaUsuario = pzcidPessoaUsuario;

        VARCHAR idAtendimento[21];
        VARCHAR idAgrupamentoEstadoTpProc[21];

        short i_idAtendimento;
        short i_idAgrupamentoEstadoTpProc;

   	EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR GOTO GotoRemoveAtendimentos;

    ULOG("idUsuarioAlteracao=%s",idUsuarioAlteracao);
    ULOG("cAuxidPessoaUsuario=%s",cAuxidPessoaUsuario);

	// EXEC SQL WHENEVER NOT FOUND DO BREAK;
    // EXEC SQL DECLARE curUsuAtual CURSOR FOR 
    //     SELECT 
    //          IDATENDIMENTO,
    //          IDAGRUPAMENTOESTADOTPPROC
    //       FROM
    //          ATENDIMENTO.ATENDIMENTO
    //      WHERE
    //          IDPESSOAUSUARIOATUAL = :cAuxidPessoaUsuario;

    // EXEC SQL OPEN curUsuAtual;

    // while (true)
    // {
    //     i_idAtendimento = i_idAgrupamentoEstadoTpProc = -1;
    // 
    //     EXEC SQL 
    //         FETCH
    //             curUsuAtual 
    //         INTO 
    //             :idAtendimento:i_idAtendimento,
    //             :idAgrupamentoEstadoTpProc:i_idAgrupamentoEstadoTpProc;
    // 
    //     idAtendimento.arr[i_idAtendimento == -1?0:idAtendimento.len] = 0;
    //     idAgrupamentoEstadoTpProc.arr[i_idAgrupamentoEstadoTpProc == -1?0:idAgrupamentoEstadoTpProc.len] = 0;
    // 
    //     /* XMLDPR *xmlDpr = new XMLDPR; */
    // 
    //     /*
    //     if ( xmlDpr && atoi((char*)idAgrupamentoEstadoTpProc.arr) >= 14 )
    //     { // monitora pelo DPR se o processo for técnico
    //         
    //         AtendimentoUsuarioAtualDPR atendimentousuarioatualdpr;
    // 
    //         atendimentousuarioatualdpr.setIdAtendimento(atoi((char*)idAtendimento.arr));
    //         atendimentousuarioatualdpr.setIdPessoaUsuario(atoi(cAuxidPessoaUsuario));
    //         atendimentousuarioatualdpr.setOpCode(OPCODE_DELETE);
    // 
    //         xmlDpr->atendimentousuarioatualvo.inserir(&atendimentousuarioatualdpr);
    //         xmlDpr->idAtendimento = (char*)idAtendimento.arr;
    // 
    //         xmlDpr->idUser = atoi(idUsuarioAlteracao);
    //         xmlDpr->nomeServico = "UsrEditar";
    // 
    //         cwfatdgerarxmldpr.persistirDadosDPRContatoTecnico(xmlDpr);
    //     }
    //     */
    // 
    //     /* delete xmlDpr;xmlDpr=0; */
    // }
    // 
    // EXEC SQL CLOSE curUsuAtual;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;

    // Desassocia todos os processos em aberto que estiverem com o usuário
    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTO
        SET
            IDPESSOAUSUARIOATUAL = NULL,
            DTULTIMAALTERACAO = SYSDATE,
            IDUSUARIOALTERACAO = TO_NUMBER(:idUsuarioAlteracao)
        WHERE
            IDATENDIMENTO IN
            (
                SELECT
                    ATD.IDATENDIMENTO
                FROM
                    ATENDIMENTO.ATENDIMENTOPRIORIZACAO ATD
                WHERE
                    IDPESSOAUSUARIOATUAL = :cAuxidPessoaUsuario
            );

    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        SET
            IDPESSOAUSUARIOATUAL = NULL,
            DTULTIMAALTERACAO = SYSDATE,
            IDUSUARIOALTERACAO = TO_NUMBER(:idUsuarioAlteracao)
        WHERE
            IDPESSOAUSUARIOATUAL = :cAuxidPessoaUsuario;

    // faz a função da operação removeUsuarioDevolucao() abaixo
    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        SET
            IDPESSOAUSUARIOANTERIOR = NULL,
            DTULTIMAALTERACAO = SYSDATE,
            IDUSUARIOALTERACAO = TO_NUMBER(:idUsuarioAlteracao)
        WHERE
            IDPESSOAUSUARIOANTERIOR = :cAuxidPessoaUsuario
        AND SGFLUXOATENDIMENTO <> 'MC2';

    // Desassocia os processos do consultor de relacionamento
    EXEC SQL
        UPDATE ATENDIMENTO.ATENDIMENTO ATENDIMENTO
        SET ATENDIMENTO.IDPESSOACONTA = NULL,
            ATENDIMENTO.DTULTIMAALTERACAO = SYSDATE,
            ATENDIMENTO.IDUSUARIOALTERACAO = TO_NUMBER(:idUsuarioAlteracao)
        WHERE ATENDIMENTO.IDATENDIMENTO IN
            (
                SELECT ATD.IDATENDIMENTO
                FROM
                    ATENDIMENTO.ATENDIMENTO ATD,
                    CUSTOMER.PESSOACONTA PESSOACONTA,
                    CUSTOMER.PESSOADEPARA PESSOADEPARA
                    //CUSTOMER.PESSOA PESSOA
                WHERE
                    ATD.IDPESSOACONTA = PESSOACONTA.IDPESSOACONTA
                AND PESSOACONTA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA
                AND PESSOADEPARA.IDPESSOA = :cAuxidPessoaUsuario
                //AND PESSOADEPARA.IDPESSOA = PESSOA.IDPESSOA
                //AND PESSOA.IDPESSOA = :cAuxidPessoaUsuario
            );

    EXEC SQL
        UPDATE ATENDIMENTO.ATENDIMENTOPRIORIZACAO ATENDIMENTOPRIORIZACAO
        SET ATENDIMENTOPRIORIZACAO.IDPESSOACONTA = NULL,
            ATENDIMENTOPRIORIZACAO.DTULTIMAALTERACAO = SYSDATE,
            ATENDIMENTOPRIORIZACAO.IDUSUARIOALTERACAO = TO_NUMBER(:idUsuarioAlteracao)
        WHERE ATENDIMENTOPRIORIZACAO.IDATENDIMENTO IN
            (
                SELECT ATD.IDATENDIMENTO
                FROM
                    ATENDIMENTO.ATENDIMENTOPRIORIZACAO ATD,
                    CUSTOMER.PESSOACONTA PESSOACONTA,
                    CUSTOMER.PESSOADEPARA PESSOADEPARA
                    //CUSTOMER.PESSOA PESSOA
                WHERE
                    ATD.IDPESSOACONTA = PESSOACONTA.IDPESSOACONTA
                AND PESSOACONTA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA
                AND PESSOADEPARA.IDPESSOA = :cAuxidPessoaUsuario
                //AND PESSOADEPARA.IDPESSOA = PESSOA.IDPESSOA
                //AND PESSOA.IDPESSOA = :cAuxidPessoaUsuario
            );

	ULOG_END("CUsr::removeAtendimentos()");

	return;

GotoRemoveAtendimentos:
	throw TuxBasicOraException(sqlca.sqlcode);
}

// void CUsr::removeUsuarioDevolucao(char *cLogUserOra,char* pzcidPessoaUsuario)
// {
// 	ULOG_START("CUsr::removeUsuarioDevolucao()");
// 
// 	struct sqlca sqlca;
// 
//    	EXEC SQL BEGIN DECLARE SECTION;
//         char *idUsuarioAlteracao = cLogUserOra;
// 		char *cAuxidPessoaUsuario = pzcidPessoaUsuario;
//    	EXEC SQL END DECLARE SECTION;
// 
// 	memset( &sqlca, 0, sizeof( sqlca ) );
// 
// 	EXEC SQL WHENEVER SQLERROR GOTO GotoremoveUsuarioDevolucao;
// 	EXEC SQL WHENEVER NOT FOUND CONTINUE;
// 
// 	ULOG("Removendo ligacoes de usuario com usuarioDevolucao...");
// 
//     // Remodelagem de Atendimento - Fev/2007 - Cassio
// 	// EXEC SQL
// 	// 	DELETE FROM
// 	// 		ATENDIMENTO.ATENDIMENTOUSUARIODEVOLUCAO
// 	// 	WHERE
// 	// 		IDPESSOAUSUARIO = :cAuxidPessoaUsuario;
// 
// 	ULOG_END("CUsr::removeUsuarioDevolucao()");
// 
// 	return;
// 
// GotoremoveUsuarioDevolucao:
// 	throw TuxBasicOraException(sqlca.sqlcode);
// }


int CUsr::VerificaGrupo( char* cidUsuario )
{
	ULOG_START("CUsr::VerificaGrupo()");
	struct sqlca sqlca;
   	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidUsuario = cidUsuario;
		long   nCont = 0;
   	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	EXEC SQL WHENEVER SQLERROR GOTO GotoVerificaGrupo;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
	SELECT 
		COUNT(1) 
	INTO
		:nCont
	FROM 
		ACESSO.USUARIOGRUPO 
	WHERE 
		IDPESSOAUSUARIO = :cAuxidUsuario;

	ULOG_END("CUsr::VerificaGrupo()");
	return nCont;

GotoVerificaGrupo:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::VerificaRegionais( char* cidUsuario )
{
	ULOG_START("CUsr::VerificaRegionais()");
	struct sqlca sqlca;
   	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidUsuario = cidUsuario;
		long   nCont = 0;
   	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	EXEC SQL WHENEVER SQLERROR GOTO GotoVerificaRegionais;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
	SELECT 
		COUNT(1) 
	INTO
		:nCont
	FROM 
		ACESSO.USUARIOUFOPERADORA 
	WHERE 
		IDPESSOAUSUARIO = :cAuxidUsuario;

	ULOG_END("CUsr::VerificaRegionais()");
	return nCont;

GotoVerificaRegionais:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::MesmoStatus( char* cidUsuario, char* cidStatus )
{
	ULOG_START("CUsr::MesmoStatus()");
	struct sqlca sqlca;
   	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidUsuario = cidUsuario;
		char* cAuxidStatus = cidStatus;
		long   nCont = 0;
   	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	EXEC SQL WHENEVER SQLERROR GOTO GotoVerificaRegionais;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
	SELECT 
		COUNT(1) 
	INTO
		:nCont
	FROM 
		ACESSO.USUARIO 
	WHERE 
		IDPESSOAUSUARIO = :cAuxidUsuario
	AND
		IDSTATUSUSUARIO = :cAuxidStatus;

	ULOG_END("CUsr::MesmoStatus()");
	return nCont;

GotoVerificaRegionais:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::MesmoStatusSigla( char* cidUsuario, char* csgStatus )
{
	ULOG_START("CUsr::MesmoStatusSigla()");
	struct sqlca sqlca;
   	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidUsuario = cidUsuario;
		char* cAuxsgStatus = csgStatus;
		long   nCont = 0;
   	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	EXEC SQL WHENEVER SQLERROR GOTO GotoVerificaRegionais;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
	SELECT 
		COUNT(1) 
	INTO
		:nCont
	FROM 
		ACESSO.USUARIO USUARIO,
		APOIO.STATUSUSUARIO USUARIOSTATUS
	WHERE 
		USUARIO.IDSTATUSUSUARIO = USUARIOSTATUS.IDSTATUSUSUARIO
	AND
		IDPESSOAUSUARIO = :cAuxidUsuario
	AND
		UPPER(SGSTATUSUSUARIO) = UPPER(:cAuxsgStatus);

    ULOG_END("CUsr::MesmoStatusSigla()");
	return nCont;

GotoVerificaRegionais:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUsr::CopiaPessoa( char* cidUsuario
					  ,char* cidUser )
{
	ULOG_START("CUsr::CopiaPessoa()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidUsuario = cidUsuario;
		char* cAuxidUser = cidUser;
		struct
		{
			VARCHAR stnmNome[21+1];
			VARCHAR stnmNomeMeio[21+1];
			VARCHAR stnmSobrenome[21+1];
			VARCHAR stidUF[21+1];
		} stPessoa;
		struct
		{
			short inmNome;
			short inmNomeMeio;
			short inmSobrenome;
			short iidUF;
		} stPessoaInd;
	EXEC SQL END DECLARE SECTION;
	
	if( strlennull( cidUsuario ) <= 0 )
	{
		strcpy( cErro, "cidUsuario está nulo" );
		ULOG_END("CUsr::CopiaPessoa()");
		return 0;
	}
	if( strlennull( cidUser ) <= 0 )
	{
		strcpy( cErro, "cidUser está nulo" );
		ULOG_END("CUsr::CopiaPessoa()");
		return 0;
	}

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoCopiaPessoa;
	sqlca.sqlcode=0;

	memset( &stPessoa, 0, sizeof( stPessoa ) );
	EXEC SQL
	SELECT
		 NMNOME
		,NMNOMEMEIO
		,NMSOBRENOME
		,IDUF
	INTO
		:stPessoa:stPessoaInd
	FROM
		CUSTOMER.PESSOA
	WHERE
		IDPESSOA = :cAuxidUsuario;

	InsertPessoa( 
				  (char*)stPessoa.stidUF.arr
				, (char*)stPessoa.stnmNome.arr
				, (char*)stPessoa.stnmNomeMeio.arr
				, (char*)stPessoa.stnmSobrenome.arr
				, cidUser 
	);

	ULOG_END("CUsr::CopiaPessoa()");
	return 1;

GotoCopiaPessoa:
	throw TuxBasicOraException(sqlca.sqlcode);
		   
}
/**
Pesquisa desenvolvida para busca de usuários quando indicado uma chave
do módulo de organograma com filtro.
*/
int CUsr::ListComOrganogramaPessoa(
                                    char* cnmnome,
                                    char* cnmnomemeio,
				                    char* cnmsobrenome,
				                    char* cidUFOperadora,
				                    char* clogin,
				                    char* cloginCti,
				                    char* cidStatusAtual,
				                    char* cidCargoAtual,
				                    char* cloginChefe,
				                    char* csgTipoDocAtual,
				                    char* cdsDocAtual,
				                    char* cinConsultor,
				                    char* cpaginaAtual,
				                    char* cregistrosPPagina,
				                    char* cIdNivel,
				                    char* cIdCargo,
				                    char* cIdOrganizacao,
				                    char* cIdDepartamento
                                    )
{
	ULOG_START("CUsr::ListComOrganogramaPessoa()");
	
	struct sqlca sqlca;
	long iCont = 0;

	ULOG("  ->> ListComOrganogramaPessoa -->> (\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s", 
		                cnmnome,
						cnmsobrenome,
						cidUFOperadora,
						clogin,
						cloginCti,
						cidStatusAtual,
						cidCargoAtual,
						cloginChefe,
						csgTipoDocAtual,
						cdsDocAtual,
						cinConsultor,
						cpaginaAtual,
						cregistrosPPagina,
						cIdNivel,
						cIdCargo,
						cIdOrganizacao,
						cIdDepartamento 
		); 

	EXEC SQL BEGIN DECLARE SECTION;
		long ipaginaAtual;
		long iregistrosPPagina;
		long nTotalLinhas = TotalLinhasPorPesquisa();
		long iIni;
		long iFim;
        
		//Dados para pesquisa
		struct 
		{
			char cAuxnmnome[255+1];
			char cAuxnmnomemeio[255+1];
			char cAuxnmsobrenome[255+1];
			char cAuxidUFOperadora[21+1];
			char cAuxlogin[256+1];
			char cAuxloginCti[256+1];
			char cAuxidStatusAtual[21+1];
			char cAuxidCargoAtual[21+1];
			char cAuxloginChefe[256+1];
			char cAuxsgTipoDocAtual[21+1];
			char cAuxdsDocAtual[256+1];
			char cAuxinConsultor[21+1];
			char cAuxIdNivel[21+1];
			char cAuxIdCargo[21+1];
			char cAuxIdOrganizacao[21+1];
			char cAuxIdDepartamento[21+1];		
		} stUsuario3;
	//Estrutura pra recuperar um registro
		struct {
			VARCHAR stidUsuario[21+1];
			VARCHAR stnome[255+1];
			VARCHAR stsobrenome[255+1];
			VARCHAR stemail[255+1];
			VARCHAR stidDDD[21+1];
			VARCHAR stdsDDD[255+1];
			VARCHAR stTelefone[255+1];
			VARCHAR stlogin[255+1];
			VARCHAR stloginCti[255+1];
			VARCHAR stidStatusAtual[21+1];
			VARCHAR stdescricaoStatusAtual[255+1];
			VARCHAR stidMotivo[21+1];
			VARCHAR stdsMotivo[255+1];
			VARCHAR stdtInicio[255+1];
			VARCHAR stdtRetorno[255+1];
			VARCHAR stidCargoAtual[21+1];
			VARCHAR stdescricaoCargoAtual[255+1];
			VARCHAR stloginChefe[255+1];
			VARCHAR stnomeChefe[255+1];
			VARCHAR stidUF[21+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stdtInclusao[255+1];
			VARCHAR stdtExclusao[255+1];
			VARCHAR stinConsultor[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stidPerfilConsultorAtd[10+1];
			VARCHAR stidFornecedorConsultorAtd[10+1];
			VARCHAR stidSiteConsultorAtd[10+1];
            VARCHAR stdsLoginRoteamento[10+1];
		} stRegUsuario;
		struct {                
			short iidUsuario;   
			short inome;        
			short isobrenome;                 
			short iemail;                     
			short iidDDD;                     
			short idsDDD;                     
			short iTelefone;                  
			short ilogin;                     
			short iloginCti;                  
			short iidStatusAtual;             
			short idescricaoStatusAtual;      
			short iidMotivo;                  
			short idsMotivo;                  
			short idtInicio;                  
			short idtRetorno;                 
			short iidCargoAtual;              
			short idescricaoCargoAtual;       
			short iloginChefe;                
			short inomeChefe;                 
			short iidUF;                    
			short inmUF;                    
			short idtInclusao;                
			short idtExclusao;                
			short iinConsultor;
			short iidUFOperadora;
			short iidPerfilConsultorAtd;
			short iidFornecedorConsultorAtd;
			short iidSiteConsultorAtd;
            short idsLoginRoteamento;
		} stindicatorRegUsuario;              
	EXEC SQL END DECLARE SECTION;
	          
	memset( &stUsuario3, 0, sizeof( stUsuario3 ) );
	
	if( strlennull( cpaginaAtual ) <= 0 )
		ipaginaAtual = 0;
	else
		ipaginaAtual = atoi( cpaginaAtual )-1;
		
	if( ipaginaAtual < 0 )
		ipaginaAtual = 0;

	if( strlennull( cregistrosPPagina ) <= 0 )
		iregistrosPPagina = 100;
	else
		iregistrosPPagina = atoi( cregistrosPPagina );
	
	if( ( iregistrosPPagina <= 0 ) || ( iregistrosPPagina > 100 ) )
		iregistrosPPagina = 100;
		
	iIni = ipaginaAtual*iregistrosPPagina;
	iFim = iIni+iregistrosPPagina+1;
	
	//Metodo desta clase
	iTamanhoPagina = iregistrosPPagina;
	
	if( strlennull( cnmnome ) > 0 )
	{
		strcpy( stUsuario3.cAuxnmnome, cnmnome );
		strcat( stUsuario3.cAuxnmnome, "%" );
	}
	else
		strcpy( stUsuario3.cAuxnmnome, "-1" );


	if( strlennull( cnmsobrenome ) > 0 )
	{
		strcpy( stUsuario3.cAuxnmsobrenome, cnmsobrenome );
		strcat( stUsuario3.cAuxnmsobrenome, "%" );
	}
	else
		strcpy( stUsuario3.cAuxnmsobrenome, "-1" );

	if( strlennull( cnmnomemeio ) > 0 )
	{
		strcpy( stUsuario3.cAuxnmnomemeio, cnmnomemeio );
		strcat( stUsuario3.cAuxnmnomemeio, "%" );
	}
	else
		strcpy( stUsuario3.cAuxnmnomemeio, "-1" );

	if( strlennull( csgTipoDocAtual ) <= 0 )
		strcpy( stUsuario3.cAuxsgTipoDocAtual, "-1" );
	else
		strcpy( stUsuario3.cAuxsgTipoDocAtual, csgTipoDocAtual );

	if( strlennull( cdsDocAtual ) <= 0 )
		strcpy( stUsuario3.cAuxdsDocAtual, "-1" );
	else
	{
		if( strcmp( csgTipoDocAtual, "CPF" ) == 0 )
			RemoveNaoNumero( stUsuario3.cAuxdsDocAtual, cdsDocAtual );
		else
			strcpy( stUsuario3.cAuxdsDocAtual, cdsDocAtual );
	}

	if( strlennull( cIdNivel ) <= 0 )
		strcpy( stUsuario3.cAuxIdNivel, "-1" );
	else
		strcpy( stUsuario3.cAuxIdNivel, cIdNivel );

	// Verificacao dos dados de Organograma.

	if( strlennull( cIdCargo ) <= 0 )
		strcpy( stUsuario3.cAuxIdCargo, "-1" );
	else
		strcpy( stUsuario3.cAuxIdCargo, cIdCargo );

	if( strlennull( cIdOrganizacao ) <= 0 )
		strcpy( stUsuario3.cAuxIdOrganizacao, "-1" );
	else
		strcpy( stUsuario3.cAuxIdOrganizacao, cIdOrganizacao );

	if( strlennull( cIdDepartamento ) <= 0 )
		strcpy( stUsuario3.cAuxIdDepartamento, "-1" );
	else
		strcpy( stUsuario3.cAuxIdDepartamento, cIdDepartamento );

    // dados da tabela usuario

	if( strlennull( cidCargoAtual ) <= 0 )
		strcpy( stUsuario3.cAuxidCargoAtual, "-1" );
	else
		strcpy( stUsuario3.cAuxidCargoAtual, cidCargoAtual );

	if( strlennull( cidUFOperadora ) <= 0 )
		strcpy( stUsuario3.cAuxidUFOperadora, "-1" );
	else
		strcpy( stUsuario3.cAuxidUFOperadora, cidUFOperadora );
	
	if( strlennull( clogin ) <= 0 )
		strcpy( stUsuario3.cAuxlogin, "-1" );
	else
		sprintf( stUsuario3.cAuxlogin, "%s%%", clogin );

	if( strlennull( cloginCti ) <= 0 )
		strcpy( stUsuario3.cAuxloginCti, "-1" );
	else
		sprintf( stUsuario3.cAuxloginCti, "%s%%", cloginCti );

	if( strlennull( cidStatusAtual ) <= 0 )
		strcpy( stUsuario3.cAuxidStatusAtual, "-1" );
	else
		strcpy( stUsuario3.cAuxidStatusAtual, cidStatusAtual );

	if( strlennull( cloginChefe ) <= 0 )
		strcpy( stUsuario3.cAuxloginChefe, "-1" );
	else
		sprintf( stUsuario3.cAuxloginChefe, "%s%%", cloginChefe );

	if( strlennull( cinConsultor ) <= 0 )
		strcpy( stUsuario3.cAuxinConsultor, "-1" );
	else
		strcpy( stUsuario3.cAuxinConsultor, cinConsultor );
    

	EXEC SQL WHENEVER SQLERROR GOTO GotoListComOrganogramaPessoa;
	sqlca.sqlcode=0;
	
	//Retorna todas as pessoas que sao usuario
	EXEC SQL
	DECLARE 
	   	CursorListComOrganogramaPessoa CURSOR FOR
	SELECT 
	     IDPESSOA
	    ,NMPESSOA
	    ,NMSOBRENOME
	    ,DTCADASTRO
	    ,IDUF
	    ,NMUF
	    ,DTINICIO
	FROM 
	(
		SELECT /*+ INDEX ( PESSOA, PESSOAIE2 )*/
		     PESSOA.IDPESSOA
		    ,PESSOA.NMPESSOA
		    ,PESSOA.NMSOBRENOME
		    ,PESSOA.DTCADASTRO
		    ,UF.IDUF
		    ,UF.NMUF
		    ,PESSOA.DTCADASTRO DTINICIO
		FROM 
		    CUSTOMER.PESSOA PESSOA,
            APOIO.UF UF,
		    CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
		    CUSTOMER.DOCUMENTO DOCUMENTO,
            APOIO.TIPODOCUMENTO TIPODOCUMENTO,
		    ORGANOGRAMA.HIERARQUIADEPTOPESSOA HDP,
		    ORGANOGRAMA.ORGANIZACAODEPARTAMENTO OD,
		    ORGANOGRAMA.NIVELCARGO NC
		WHERE
		    PESSOA.IDPESSOA = HDP.IDPESSOA
		AND
		    HDP.IDORGANIZACAODEPARTAMENTO = OD.IDORGANIZACAODEPARTAMENTO
		AND
		    HDP.IDNIVELCARGO = NC.IDNIVELCARGO
		AND
		    PESSOA.IDPESSOA = PESSOADOCUMENTO.IDPESSOA
		AND
		    PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
		AND
		    DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
		AND
		    PESSOA.IDUF = UF.IDUF
		AND 
		(
			TIPODOCUMENTO.SGCLASSIFICACAO = 'CPF'
		OR 
			TIPODOCUMENTO.SGTIPODOCUMENTO = 'RG'
		OR 
			TIPODOCUMENTO.SGTIPODOCUMENTO = 'RE' 
		)
		AND
		(
		        NC.IDNIVEL = :stUsuario3.cAuxIdNivel
		    OR
		        '-1' = :stUsuario3.cAuxIdNivel
		)
		AND
		(
		        NC.IDCARGO = :stUsuario3.cAuxIdCargo
		    OR
		        '-1' = :stUsuario3.cAuxIdCargo
		)
		AND
		(
		        OD.IDORGANIZACAO = :stUsuario3.cAuxIdOrganizacao
		    OR
		        '-1' = :stUsuario3.cAuxIdOrganizacao
		)
		AND
		(
		        OD.IDDEPARTAMENTO = :stUsuario3.cAuxIdDepartamento
		    OR
		        '-1' = :stUsuario3.cAuxIdDepartamento
		)
		AND
		(
		        TIPODOCUMENTO.SGTIPODOCUMENTO = :stUsuario3.cAuxsgTipoDocAtual
		    OR
		        '-1' = :stUsuario3.cAuxsgTipoDocAtual
		)
		AND
		(
		        DOCUMENTO.NRDOCUMENTO = :stUsuario3.cAuxdsDocAtual
		    OR
		        '-1' = :stUsuario3.cAuxdsDocAtual
		)
		AND
		( 
		 	    UPPER(PESSOA.NMNOME) LIKE UPPER(:stUsuario3.cAuxnmnome)
		    OR 
		        '-1' = :stUsuario3.cAuxnmnome
		)
		AND
		( 
		 	    UPPER(PESSOA.NMNOMEMEIO) LIKE UPPER(:stUsuario3.cAuxnmnomemeio)
		    OR 
		        '-1' = :stUsuario3.cAuxnmnomemeio
		)
		AND
		( 
		 	    UPPER(PESSOA.NMSOBRENOME) LIKE UPPER(:stUsuario3.cAuxnmsobrenome)
		    OR 
		        '-1' = :stUsuario3.cAuxnmsobrenome
		)
		AND
			ROWNUM < :nTotalLinhas * 3
	);

	EXEC SQL OPEN CursorListComOrganogramaPessoa;

	EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR GOTO GotoListComOrganogramaPessoa;
	sqlca.sqlcode=0;
	
	//Por default, zero indica nao haver mais paginas
	iProximaPagina = 0;
	for(iCont = 1;;iCont++)
	{

		memset( &stRegUsuario, 0, sizeof(stRegUsuario) );
		EXEC SQL 
		FETCH 
			CursorListComOrganogramaPessoa 
		INTO 
			:stRegUsuario.stidUsuario :stindicatorRegUsuario.iidUsuario,       //   IDPESSOA       
			:stRegUsuario.stnome      :stindicatorRegUsuario.inome,            //  ,NMNOME         
			:stRegUsuario.stsobrenome :stindicatorRegUsuario.isobrenome,       //  ,NMSOBRENOME    
			:stRegUsuario.stdtInicio  :stindicatorRegUsuario.idtInicio,        //  ,DTCADASTRO     
			:stRegUsuario.stidUF      :stindicatorRegUsuario.iidUF,            //  ,IDUF           
			:stRegUsuario.stnmUF      :stindicatorRegUsuario.inmUF,            //  ,NMUF           
			:stRegUsuario.stdtInclusao:stindicatorRegUsuario.idtInclusao;      //  ,DTINICIO       
			
		if( iCont > iIni && iCont <  iFim )
		{
			//Para cada pessoa encontrada, eh necessário verificar se existe um usuario
			EXEC SQL WHENEVER NOT FOUND CONTINUE;
			EXEC SQL
			SELECT
				 USUARIO.DSEMAIL
				,USUARIO.IDAREAREGISTRO
				,AREAREGISTRO.CDAREAREGISTRO
				,USUARIO.NRTELEFONE
				,USUARIO.NMLOGINUSUARIO
				,USUARIO.NMLOGINUSUARIOCTI
				,USUARIO.IDSTATUSUSUARIO
				,STATUSUSUARIO.DSSTATUSUSUARIO
				,0  IDMOTIVO
				,'' DSMOTIVO
				,USUARIO.DTSTATUSUSUARIO
				,0  IDCARGO
				,'' DSCARGO
                ,USUARIOCHEFE.NMLOGINUSUARIO AS NMLOGINUSUARIOCHEFE
				,PESSOACHEFE.NMPESSOA NMPESSOACHEFE
				,USUARIO.DTSTATUSUSUARIO DTEXCLUSAO
				,USUARIO.INCONSULTOR
				,USUARIO.IDUFOPERADORA
                ,USUARIO.IDPERFILCONSULTORATD
                ,USUARIO.IDFORNECEDORCONSULTORATD
                ,USUARIO.IDSITECONSULTORATD
                ,USUARIO.DSLOGINROTEAMENTO
			INTO
				:stRegUsuario.stemail                    :stindicatorRegUsuario.iemail,
				:stRegUsuario.stidDDD                    :stindicatorRegUsuario.iidDDD,
				:stRegUsuario.stdsDDD                    :stindicatorRegUsuario.idsDDD,
				:stRegUsuario.stTelefone                 :stindicatorRegUsuario.iTelefone,
				:stRegUsuario.stlogin                    :stindicatorRegUsuario.ilogin,
				:stRegUsuario.stloginCti                 :stindicatorRegUsuario.iloginCti,
				:stRegUsuario.stidStatusAtual            :stindicatorRegUsuario.iidStatusAtual,
				:stRegUsuario.stdescricaoStatusAtual     :stindicatorRegUsuario.idescricaoStatusAtual,
				:stRegUsuario.stidMotivo                 :stindicatorRegUsuario.iidMotivo,
				:stRegUsuario.stdsMotivo                 :stindicatorRegUsuario.idsMotivo,
				:stRegUsuario.stdtRetorno                :stindicatorRegUsuario.idtRetorno,
				:stRegUsuario.stidCargoAtual             :stindicatorRegUsuario.iidCargoAtual,
				:stRegUsuario.stdescricaoCargoAtual      :stindicatorRegUsuario.idescricaoCargoAtual,
				:stRegUsuario.stloginChefe               :stindicatorRegUsuario.iloginChefe,
				:stRegUsuario.stnomeChefe                :stindicatorRegUsuario.inomeChefe,
				:stRegUsuario.stdtExclusao               :stindicatorRegUsuario.idtExclusao,
				:stRegUsuario.stinConsultor              :stindicatorRegUsuario.iinConsultor,
				:stRegUsuario.stidUFOperadora            :stindicatorRegUsuario.iidUFOperadora,
				:stRegUsuario.stidPerfilConsultorAtd     :stindicatorRegUsuario.iidPerfilConsultorAtd,
				:stRegUsuario.stidFornecedorConsultorAtd :stindicatorRegUsuario.iidFornecedorConsultorAtd,
				:stRegUsuario.stidSiteConsultorAtd       :stindicatorRegUsuario.iidSiteConsultorAtd,
				:stRegUsuario.stdsLoginRoteamento        :stindicatorRegUsuario.idsLoginRoteamento
			FROM 
				ACESSO.USUARIO USUARIO,
				ACESSO.USUARIOHIERARQUIA USUARIOHIERARQUIA,
				ACESSO.USUARIO USUARIOCHEFE,
				CUSTOMER.PESSOA PESSOACHEFE,
				APOIO.STATUSUSUARIO STATUSUSUARIO,
				APOIO.AREAREGISTRO AREAREGISTRO
			WHERE
				USUARIO.IDSTATUSUSUARIO = STATUSUSUARIO.IDSTATUSUSUARIO
			AND
				USUARIO.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
			AND
				USUARIO.IDPESSOAUSUARIO = USUARIOHIERARQUIA.IDPESSOAUSUARIO(+)
			AND
				USUARIOHIERARQUIA.IDPESSOAUSUARIOCHEFE = USUARIOCHEFE.IDPESSOAUSUARIO(+)
			AND
				USUARIOCHEFE.IDPESSOAUSUARIO = PESSOACHEFE.IDPESSOA(+)
			AND
				USUARIO.IDPESSOAUSUARIO = :stRegUsuario.stidUsuario;
		
			Add( (char*)stRegUsuario.stidUsuario.arr
			    ,(char*)stRegUsuario.stnome.arr
			    ,(char*)stRegUsuario.stsobrenome.arr
			    ,(char*)stRegUsuario.stemail.arr
			    ,(char*)stRegUsuario.stidDDD.arr
			    ,(char*)stRegUsuario.stdsDDD.arr
			    ,(char*)stRegUsuario.stTelefone.arr
			    ,(char*)stRegUsuario.stlogin.arr
			    ,(char*)stRegUsuario.stloginCti.arr
			    ,(char*)stRegUsuario.stidStatusAtual.arr
			    ,(char*)stRegUsuario.stdescricaoStatusAtual.arr
			    ,(char*)stRegUsuario.stidMotivo.arr
			    ,(char*)stRegUsuario.stdsMotivo.arr
			    ,(char*)stRegUsuario.stdtInicio.arr
			    ,(char*)stRegUsuario.stdtRetorno.arr
			    ,(char*)stRegUsuario.stidCargoAtual.arr
			    ,(char*)stRegUsuario.stdescricaoCargoAtual.arr
			    ,(char*)stRegUsuario.stloginChefe.arr
			    ,(char*)stRegUsuario.stnomeChefe.arr
			    ,(char*)stRegUsuario.stidUF.arr
			    ,(char*)stRegUsuario.stnmUF.arr
			    ,(char*)stRegUsuario.stdtInclusao.arr
			    ,(char*)stRegUsuario.stdtExclusao.arr
			    ,(char*)stRegUsuario.stinConsultor.arr
				,(char*)stRegUsuario.stidUFOperadora.arr
                ,(char*)stRegUsuario.stidPerfilConsultorAtd.arr
                ,(char*)stRegUsuario.stidFornecedorConsultorAtd.arr
                ,(char*)stRegUsuario.stidSiteConsultorAtd.arr
                ,(char*)stRegUsuario.stdsLoginRoteamento.arr
			);
		}//if( iCont > iIni && iCont <  iFim )
    }//for(;;iContador++)
	EXEC SQL CLOSE CursorListComOrganogramaPessoa;

	if( iCont > iFim )
		iProximaPagina = 1;

	if( iCont > nTotalLinhas )
		sprintf( cContadorPagina, "mais de %d página(s)", (iCont/iregistrosPPagina)+1 );
	else
		sprintf( cContadorPagina, "%d página(s)", (iCont/iregistrosPPagina)+1 );

	ULOG_END("CUsr::ListComOrganogramaPessoa()");
	return iCont-1;

GotoListComOrganogramaPessoa:
	throw TuxBasicOraException(sqlca.sqlcode);

}


/**
Pesquisa desenvolvida para busca de usuários quando indicado uma chave
do módulo de organograma com filtro.
*/
int CUsr::ListComOrganogramaUsuario(
                                    char* cnmnome,
                                    char* cnmnomemeio,
				                    char* cnmsobrenome,
				                    char* cidUFOperadora,
				                    char* clogin,
				                    char* cloginCti,
				                    char* cidStatusAtual,
				                    char* cidCargoAtual,
				                    char* cloginChefe,
				                    char* csgTipoDocAtual,
				                    char* cdsDocAtual,
				                    char* cinConsultor,
				                    char* cpaginaAtual,
				                    char* cregistrosPPagina,
				                    char* cIdNivel,
				                    char* cIdCargo,
				                    char* cIdOrganizacao,
				                    char* cIdDepartamento
				                    )
{                                       
	ULOG_START("CUsr::ListComOrganogramaUsuario()");
	
	struct sqlca sqlca;
	long iCont = 0;

	ULOG("  ->> ListComOrganogramaUsuario -->> (\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s,\n%s", 
		                cnmnome,
						cnmsobrenome,
						cidUFOperadora,
						clogin,
						cloginCti,
						cidStatusAtual,
						cidCargoAtual,
						cloginChefe,
						csgTipoDocAtual,
						cdsDocAtual,
						cinConsultor,
						cpaginaAtual,
						cregistrosPPagina,
						cIdNivel,
						cIdCargo,
						cIdOrganizacao,
						cIdDepartamento 
	); 

    long linhasAux = 0;
	EXEC SQL BEGIN DECLARE SECTION;
        char * query;
        char buffer[256];
	    
		long ipaginaAtual;
		long iregistrosPPagina;
		long nTotalLinhas = TotalLinhasPorPesquisa();

		long iIni;
		long iFim;
	//Dados para pesquisa
		struct 
		{
			char cAuxnmnome[255+1];
			char cAuxnmnomemeio[255+1];
			char cAuxnmsobrenome[255+1];
			char cAuxidUFOperadora[21+1];
			char cAuxlogin[256+1];
			char cAuxloginCti[256+1];
			char cAuxidStatusAtual[21+1];
			char cAuxidCargoAtual[21+1];
			char cAuxloginChefe[256+1];
			char cAuxsgTipoDocAtual[21+1];
			char cAuxdsDocAtual[256+1];
			char cAuxinConsultor[21+1];
			char cAuxIdNivel[21+1];
			char cAuxIdCargo[21+1];
			char cAuxIdOrganizacao[21+1];
			char cAuxIdDepartamento[21+1];		
		} stUsuario4;
	//Estrutura pra recuperar um registro
		struct {
			VARCHAR stidUsuario[21+1];
			VARCHAR stnome[255+1];
			VARCHAR stsobrenome[255+1];
			VARCHAR stemail[255+1];
			VARCHAR stidDDD[21+1];
			VARCHAR stdsDDD[255+1];
			VARCHAR stTelefone[255+1];
			VARCHAR stlogin[255+1];
			VARCHAR stloginCti[255+1];
			VARCHAR stidStatusAtual[21+1];
			VARCHAR stdescricaoStatusAtual[255+1];
			VARCHAR stidMotivo[21+1];
			VARCHAR stdsMotivo[255+1];
			VARCHAR stdtInicio[255+1];
			VARCHAR stdtRetorno[255+1];
			VARCHAR stidCargoAtual[21+1];
			VARCHAR stdescricaoCargoAtual[255+1];
			VARCHAR stloginChefe[255+1];
			VARCHAR stnomeChefe[255+1];
			VARCHAR stidUF[21+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stdtInclusao[255+1];
			VARCHAR stdtExclusao[255+1];
			VARCHAR stinConsultor[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stidPerfilConsultorAtd[10+1];
			VARCHAR stidFornecedorConsultorAtd[10+1];
			VARCHAR stidSiteConsultorAtd[10+1];
            VARCHAR stdsLoginRoteamento[10+1];
		} stRegUsuario;
		struct {                
			short iidUsuario;   
			short inome;        
			short isobrenome;                 
			short iemail;                     
			short iidDDD;                     
			short idsDDD;                     
			short iTelefone;                  
			short ilogin;                     
			short iloginCti;                  
			short iidStatusAtual;             
			short idescricaoStatusAtual;      
			short iidMotivo;                  
			short idsMotivo;                  
			short idtInicio;                  
			short idtRetorno;                 
			short iidCargoAtual;              
			short idescricaoCargoAtual;       
			short iloginChefe;                
			short inomeChefe;                 
			short iidUF;                    
			short inmUF;                    
			short idtInclusao;                
			short idtExclusao;                
			short iinConsultor;
			short iidUFOperadora;
			short iidPerfilConsultorAtd;
			short iidFornecedorConsultorAtd;
			short iidSiteConsultorAtd;
            short idsLoginRoteamento;
		} stindicatorRegUsuario;              
	EXEC SQL END DECLARE SECTION;
	          
    ULOG( "*** nTotalLinhas [%ld]", nTotalLinhas );
    
    sprintf( buffer, "%ld", nTotalLinhas );
    
    linhasAux = atol(buffer);
    ULOG( "*** linhasAux [%ld]", linhasAux );

	string stmt;
	          
	memset( &stUsuario4, 0, sizeof( stUsuario4 ) );
	
	if( strlennull( cpaginaAtual ) <= 0 )
		ipaginaAtual = 0;
	else
		ipaginaAtual = atoi( cpaginaAtual )-1;
		
	if( ipaginaAtual < 0 )
		ipaginaAtual = 0;

	if( strlennull( cregistrosPPagina ) <= 0 )
		iregistrosPPagina = 100;
	else
		iregistrosPPagina = atoi( cregistrosPPagina );
	
	if( ( iregistrosPPagina <= 0 ) || ( iregistrosPPagina > 100 ) )
		iregistrosPPagina = 100;
		
	iIni = ipaginaAtual*iregistrosPPagina;
	iFim = iIni+iregistrosPPagina+1;
	
	//Metodo desta clase dados usuario
	iTamanhoPagina = iregistrosPPagina;
	if( strlennull( cnmnome ) > 0 )
	{
		strcpy( stUsuario4.cAuxnmnome, cnmnome );
		strcat( stUsuario4.cAuxnmnome, "%" );
	}
	else
		strcpy( stUsuario4.cAuxnmnome, "-1" );

	if( strlennull( cnmnomemeio ) > 0 )
	{
		strcpy( stUsuario4.cAuxnmnomemeio, cnmnomemeio );
		strcat( stUsuario4.cAuxnmnomemeio, "%" );
	}
	else
		strcpy( stUsuario4.cAuxnmnomemeio, "-1" );

	if( strlennull( cnmsobrenome ) <= 0 )
	{
		strcpy( stUsuario4.cAuxnmsobrenome, cnmsobrenome );
		strcat( stUsuario4.cAuxnmsobrenome, "%" );
	}
	else
		strcpy( stUsuario4.cAuxnmsobrenome, "-1" );

	if( strlennull( csgTipoDocAtual ) <= 0 )
		strcpy( stUsuario4.cAuxsgTipoDocAtual, "-1" );
	else
		strcpy( stUsuario4.cAuxsgTipoDocAtual, csgTipoDocAtual );

	if( strlennull( cdsDocAtual ) <= 0 )
		strcpy( stUsuario4.cAuxdsDocAtual, "-1" );
	else
	{
		if( strcmp( csgTipoDocAtual, "CPF" ) == 0 )
			RemoveNaoNumero( stUsuario4.cAuxdsDocAtual, cdsDocAtual );
		else
			strcpy( stUsuario4.cAuxdsDocAtual, cdsDocAtual );
	}

	if( strlennull( cIdNivel ) <= 0 )
		strcpy( stUsuario4.cAuxIdNivel, "-1" );
	else
		strcpy( stUsuario4.cAuxIdNivel, cIdNivel );

	// Verificacao dos dados de Organograma.

	if( strlennull( cIdCargo ) <= 0 )
		strcpy( stUsuario4.cAuxIdCargo, "-1" );
	else
		strcpy( stUsuario4.cAuxIdCargo, cIdCargo );

	if( strlennull( cIdOrganizacao ) <= 0 )
		strcpy( stUsuario4.cAuxIdOrganizacao, "-1" );
	else
		strcpy( stUsuario4.cAuxIdOrganizacao, cIdOrganizacao );

	if( strlennull( cIdDepartamento ) <= 0 )
		strcpy( stUsuario4.cAuxIdDepartamento, "-1" );
	else
		strcpy( stUsuario4.cAuxIdDepartamento, cIdDepartamento );

    // dados da tabela usuario

	if( strlennull( cidCargoAtual ) <= 0 )
		strcpy( stUsuario4.cAuxidCargoAtual, "-1" );
	else
		strcpy( stUsuario4.cAuxidCargoAtual, cidCargoAtual );

	if( strlennull( cidUFOperadora ) <= 0 )
		strcpy( stUsuario4.cAuxidUFOperadora, "-1" );
	else
		strcpy( stUsuario4.cAuxidUFOperadora, cidUFOperadora );
	
	if( strlennull( clogin ) <= 0 )
		strcpy( stUsuario4.cAuxlogin, "-1" );
	else
		sprintf( stUsuario4.cAuxlogin, "%s%%", clogin );

	if( strlennull( cloginCti ) <= 0 )
		strcpy( stUsuario4.cAuxloginCti, "-1" );
	else
		sprintf( stUsuario4.cAuxloginCti, "%s%%", cloginCti );

	if( strlennull( cidStatusAtual ) <= 0 )
		strcpy( stUsuario4.cAuxidStatusAtual, "-1" );
	else
		strcpy( stUsuario4.cAuxidStatusAtual, cidStatusAtual );

	if( strlennull( cloginChefe ) <= 0 )
		strcpy( stUsuario4.cAuxloginChefe, "-1" );
	else
		sprintf( stUsuario4.cAuxloginChefe, "%s%%", cloginChefe );

	if( strlennull( cinConsultor ) <= 0 )
		strcpy( stUsuario4.cAuxinConsultor, "-1" );
	else
		strcpy( stUsuario4.cAuxinConsultor, cinConsultor );

    ULOG("  ->> ListComOrganogramaUsuario ->> Montando a pesquisa"); 

	stmt = 
	"SELECT DISTINCT "
	"	  IDPESSOA "
	"	 ,NMNOME "
	"	 ,NMSOBRENOME "
	"	 ,DSEMAIL "
	"	 ,IDAREAREGISTRO "
	"	 ,CDAREAREGISTRO "
	"	 ,NRTELEFONE "
	"	 ,NMLOGINUSUARIO "
	"	 ,NMLOGINUSUARIOCTI "
	"	 ,IDSTATUSUSUARIO "
	"	 ,DSSTATUSUSUARIO "
	"	 ,0  IDMOTIVO "
	"	 ,'' DSMOTIVO "
	"	 ,DTCADASTRO "
	"	 ,DTSTATUSUSUARIO "
	"	 ,0  IDCARGO "
	"	 ,'' NMCARGO "
	"	 ,NMLOGINUSUARIOCHEFE "
	"	 ,NMPESSOACHEFE "
	"	 ,IDUF "
	"	 ,NMUF "
	"	 ,DTINICIO "
	"	 ,DTEXCLUSAO "
	"	 ,INCONSULTOR "
	" 	 ,IDUFOPERADORA "
    "    ,IDPERFILCONSULTORATD "
    "    ,IDFORNECEDORCONSULTORATD "
    "    ,IDSITECONSULTORATD "
    "    ,DSLOGINROTEAMENTO "
	" FROM "
	" ( "
	"SELECT "
	"	     PESSOA.IDPESSOA "
	"    ,PESSOA.NMPESSOA  AS  NMNOME "
	"	    ,PESSOA.NMSOBRENOME "
	"	    ,USUARIO.DSEMAIL "
	"	    ,USUARIO.IDAREAREGISTRO "
	"	    ,AREAREGISTRO.CDAREAREGISTRO "
	"	    ,USUARIO.NRTELEFONE "
	"	    ,USUARIO.NMLOGINUSUARIO "
	"	    ,USUARIO.NMLOGINUSUARIOCTI "
	"	    ,USUARIO.IDSTATUSUSUARIO "
	"	    ,STATUSUSUARIO.DSSTATUSUSUARIO "
	"	    ,PESSOA.DTCADASTRO "
	"	    ,USUARIO.DTSTATUSUSUARIO "
    "        ,USUARIOCHEFE.NMLOGINUSUARIO AS NMLOGINUSUARIOCHEFE "
	"	    ,PESSOACHEFE.NMPESSOA NMPESSOACHEFE "
	"	    ,UF.IDUF "
	"	    ,UF.NMUF "
	"    ,PESSOA.DTCADASTRO AS DTINICIO "
	"    ,USUARIO.DTSTATUSUSUARIO AS DTEXCLUSAO "
	"	    ,USUARIO.INCONSULTOR "
	"	    ,USUARIO.IDUFOPERADORA "
    "       ,USUARIO.IDPERFILCONSULTORATD "
    "       ,USUARIO.IDFORNECEDORCONSULTORATD "
    "        ,USUARIO.IDSITECONSULTORATD "
    "        ,USUARIO.DSLOGINROTEAMENTO "
	"	FROM "
	"	    CUSTOMER.PESSOA PESSOA, "
	"	    CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO, "
	"	    CUSTOMER.DOCUMENTO DOCUMENTO, "
	"	    ACESSO.USUARIO USUARIO, "
	"	    ACESSO.USUARIOHIERARQUIA USUARIOHIERARQUIA, "
	"	    ACESSO.USUARIO USUARIOCHEFE, "
	"	    CUSTOMER.PESSOA PESSOACHEFE, "
	"	    APOIO.UF UF, "
	"	    APOIO.TIPODOCUMENTO TIPODOCUMENTO, "
	"	    APOIO.STATUSUSUARIO STATUSUSUARIO, "
	"	    APOIO.AREAREGISTRO AREAREGISTRO, "
	"	    ORGANOGRAMA.HIERARQUIADEPTOPESSOA HDP, "
	"	    ORGANOGRAMA.ORGANIZACAODEPARTAMENTO OD, "
	"	    ORGANOGRAMA.NIVELCARGO NC "
	"	WHERE "
	"	    USUARIO.IDPESSOAUSUARIO = USUARIOHIERARQUIA.IDPESSOAUSUARIO(+) "
	"	AND "
	"	    USUARIOHIERARQUIA.IDPESSOAUSUARIOCHEFE = USUARIOCHEFE.IDPESSOAUSUARIO(+) "
	"	AND "
	"	    USUARIOCHEFE.IDPESSOAUSUARIO = PESSOACHEFE.IDPESSOA "
	"	AND "
	"	    PESSOA.IDPESSOA = USUARIO.IDPESSOAUSUARIO "
	"	AND "
	"	    PESSOA.IDPESSOA = HDP.IDPESSOA "
	"	AND "
	"	    HDP.IDORGANIZACAODEPARTAMENTO = OD.IDORGANIZACAODEPARTAMENTO "
	"	AND "
	"	    HDP.IDNIVELCARGO = NC.IDNIVELCARGO "
	"	AND "
	"	    USUARIO.IDSTATUSUSUARIO = STATUSUSUARIO.IDSTATUSUSUARIO "
	"	AND "
	"	    USUARIO.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO "
	"	AND "
	"	    PESSOA.IDPESSOA = PESSOADOCUMENTO.IDPESSOA "
	"	AND "
	"	    PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO "
	"	AND "
	"	    DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO "
	"	AND "
	"	    PESSOA.IDUF = UF.IDUF "
	"	AND "
	"	( "
	"		(TIPODOCUMENTO.SGTIPODOCUMENTO IN ( 'CPF', 'RG', 'RE' ) OR TIPODOCUMENTO.SGCLASSIFICACAO = 'CPF') "
	"	) ";

	if ( strcmp(stUsuario4.cAuxlogin, "-1") )
	{
		stmt += " AND UPPER(USUARIO.NMLOGINUSUARIO) LIKE UPPER( '" ;
		sprintf( buffer,"%s",(char*)stUsuario4.cAuxlogin );
		stmt += buffer ;
		stmt += "' ) " ;
	}
	
	if ( strcmp(stUsuario4.cAuxloginCti, "-1") )
	{
		stmt += " AND UPPER(USUARIO.NMLOGINUSUARIOCTI) LIKE UPPER( '";
		sprintf( buffer,"%s",(char*)stUsuario4.cAuxloginCti );
		stmt += buffer ;
	    stmt += "' ) ";
	}
	
	if ( strcmp(stUsuario4.cAuxidStatusAtual, "-1") )
	{
		stmt += " AND USUARIO.IDSTATUSUSUARIO = ";
		sprintf( buffer,"%s",(char*)stUsuario4.cAuxidStatusAtual );
		stmt += buffer ;
    }
	
	if ( strcmp(stUsuario4.cAuxloginChefe, "-1") )
	{
	    stmt += " AND UPPER(USUARIOCHEFE.NMLOGINUSUARIO) LIKE UPPER( '";
		sprintf( buffer,"%s",(char*)stUsuario4.cAuxloginChefe );
		stmt += buffer ;
	    stmt += "' ) ";
	} 

	if ( strcmp(stUsuario4.cAuxinConsultor, "-1") )
	{
        stmt += " AND USUARIO.INCONSULTOR = ";
		sprintf( buffer,"%s",(char*)stUsuario4.cAuxinConsultor );
		stmt += buffer ;
    }

	if ( strcmp(stUsuario4.cAuxidUFOperadora, "-1") )
	{
        stmt += " AND USUARIO.IDUFOPERADORA = ";
		sprintf( buffer,"%s",(char*)stUsuario4.cAuxidUFOperadora );
		stmt += buffer ;
    }

	if ( strcmp(stUsuario4.cAuxIdNivel, "-1") )
	{
		stmt += " AND NC.IDNIVEL = ";
		sprintf( buffer,"%s",(char*)stUsuario4.cAuxIdNivel );
		stmt += buffer ;
    }

	if ( strcmp(stUsuario4.cAuxIdCargo, "-1") )
	{
		stmt += " AND NC.IDCARGO = ";
		sprintf( buffer,"%s",(char*)stUsuario4.cAuxIdCargo );
		stmt += buffer ;
    }

	if ( strcmp(stUsuario4.cAuxIdOrganizacao, "-1") )
	{
		stmt += " AND OD.IDORGANIZACAO = ";
		sprintf( buffer,"%s",(char*)stUsuario4.cAuxIdOrganizacao );
		stmt += buffer ;
	}
	
	if ( strcmp(stUsuario4.cAuxIdDepartamento,"-1") )
	{
		stmt += " AND OD.IDDEPARTAMENTO = ";
		sprintf( buffer,"%s",(char*)stUsuario4.cAuxIdDepartamento );
		stmt += buffer ;
	}
	
	if ( strcmp(stUsuario4.cAuxsgTipoDocAtual, "-1") )
	{
		stmt += " AND TIPODOCUMENTO.SGTIPODOCUMENTO = '";
		sprintf( buffer,"%s",(char*)stUsuario4.cAuxsgTipoDocAtual );
		stmt += buffer ;
        stmt += "' ";
	}

	if ( strcmp(stUsuario4.cAuxdsDocAtual,"-1") )
	{
		stmt += " AND DOCUMENTO.NRDOCUMENTO = '";
		sprintf( buffer,"%s",(char*)stUsuario4.cAuxdsDocAtual );
		stmt += buffer ;
        stmt += "' ";
    }
    
	if ( strcmp(stUsuario4.cAuxnmnome,"-1") )
	{
		stmt += " AND UPPER(PESSOA.NMNOME) LIKE UPPER( '";
		sprintf( buffer,"%s",(char*)stUsuario4.cAuxnmnome );
		stmt += buffer ;
		stmt += "' ) ";
	}
	
	if ( strcmp(stUsuario4.cAuxnmnomemeio,"-1") )
	{
		stmt += " AND UPPER(PESSOA.NMNOMEMEIO) LIKE UPPER( '";
		sprintf( buffer,"%s",(char*)stUsuario4.cAuxnmnomemeio );
		stmt += buffer ;
		stmt += "' ) ";
    }

	if ( strcmp(stUsuario4.cAuxnmsobrenome,"-1") )
	{
		stmt += " AND UPPER(PESSOA.NMSOBRENOME) LIKE UPPER( '";
		sprintf( buffer,"%s",(char*)stUsuario4.cAuxnmsobrenome );
		stmt += buffer ;
		stmt += "' ) ";
	}
	
	stmt += " AND ROWNUM <= ";
    memset( buffer, 0x0, sizeof(buffer) );
    ULOG( ">>> nTotalLinhas [%ld]", nTotalLinhas );
    sprintf( buffer, "%ld", linhasAux );
    ULOG( ">>> buffer [%s]", buffer );
	stmt += buffer ;
	stmt += " * 3 ) ";
	
    query = (char*)stmt.c_str();

    ULOG("query [%s]\n", query);
    
	EXEC SQL WHENEVER SQLERROR GOTO GotoListComOrganogramaUsuario;
    EXEC SQL PREPARE recebeQuery FROM :query;
    EXEC SQL DECLARE CursorListComOrganogramaUsuario CURSOR FOR recebeQuery;
	 
	EXEC SQL WHENEVER NOT FOUND DO break;
	sqlca.sqlcode=0;

	//Retorna todas as pessoas que sao usuario
	//EXEC SQL
	//DECLARE 
	//   	CursorListComOrganogramaUsuario CURSOR FOR
	//SELECT DISTINCT
	//	 IDPESSOA
	//	,NMNOME
	//	,NMSOBRENOME
	//	,DSEMAIL
	//	,IDAREAREGISTRO
	//	,CDAREAREGISTRO
	//	,NRTELEFONE
	//	,NMLOGINUSUARIO
	//	,NMLOGINUSUARIOCTI
	//	,IDSTATUSUSUARIO
	//	,DSSTATUSUSUARIO
	//	,0  IDMOTIVO
	//	,'' DSMOTIVO
	//	,DTCADASTRO
	//	,DTSTATUSUSUARIO
	//	,0  IDCARGO
	//	,'' NMCARGO
	//	,NMLOGINUSUARIOCHEFE
	//	,NMPESSOACHEFE
	//	,IDUF
	//	,NMUF
	//	,DTINICIO
	//	,DTEXCLUSAO
	//	,INCONSULTOR
	//	,IDUFOPERADORA
    //    ,IDPERFILCONSULTORATD
    //    ,IDFORNECEDORCONSULTORATD
    //    ,IDSITECONSULTORATD
    //    ,DSLOGINROTEAMENTO
	//FROM 
	//(
	//	SELECT
	//	     PESSOA.IDPESSOA
	//	    ,PESSOA.NMPESSOA NMNOME
	//	    ,PESSOA.NMSOBRENOME
	//	    ,USUARIO.DSEMAIL
	//	    ,USUARIO.IDAREAREGISTRO
	//	    ,AREAREGISTRO.CDAREAREGISTRO
	//	    ,USUARIO.NRTELEFONE
	//	    ,USUARIO.NMLOGINUSUARIO
	//	    ,USUARIO.NMLOGINUSUARIOCTI
	//	    ,USUARIO.IDSTATUSUSUARIO
	//	    ,STATUSUSUARIO.DSSTATUSUSUARIO
	//	    ,PESSOA.DTCADASTRO
	//	    ,USUARIO.DTSTATUSUSUARIO
    //        ,USUARIOCHEFE.NMLOGINUSUARIO AS NMLOGINUSUARIOCHEFE
	//	    ,PESSOACHEFE.NMPESSOA NMPESSOACHEFE
	//	    ,UF.IDUF
	//	    ,UF.NMUF
	//	    ,PESSOA.DTCADASTRO DTINICIO
	//	    ,USUARIO.DTSTATUSUSUARIO DTEXCLUSAO
	//	    ,USUARIO.INCONSULTOR
	//	    ,USUARIO.IDUFOPERADORA
    //        ,USUARIO.IDPERFILCONSULTORATD
    //        ,USUARIO.IDFORNECEDORCONSULTORATD
    //        ,USUARIO.IDSITECONSULTORATD
    //        ,USUARIO.DSLOGINROTEAMENTO
	//	FROM 
	//	    CUSTOMER.PESSOA PESSOA,
	//	    CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
	//	    CUSTOMER.DOCUMENTO DOCUMENTO,
	//	    ACESSO.USUARIO USUARIO,
	//	    ACESSO.USUARIOHIERARQUIA USUARIOHIERARQUIA,
	//	    ACESSO.USUARIO USUARIOCHEFE,
	//	    CUSTOMER.PESSOA PESSOACHEFE,
	//	    APOIO.UF UF,
	//	    APOIO.TIPODOCUMENTO TIPODOCUMENTO,
	//	    APOIO.STATUSUSUARIO STATUSUSUARIO,
	//	    APOIO.AREAREGISTRO AREAREGISTRO,
	//	    ORGANOGRAMA.HIERARQUIADEPTOPESSOA HDP,
	//	    ORGANOGRAMA.ORGANIZACAODEPARTAMENTO OD,
	//	    ORGANOGRAMA.NIVELCARGO NC
	//	WHERE
	//	    USUARIO.IDPESSOAUSUARIO = USUARIOHIERARQUIA.IDPESSOAUSUARIO(+)
	//	AND
	//	    USUARIOHIERARQUIA.IDPESSOAUSUARIOCHEFE = USUARIOCHEFE.IDPESSOAUSUARIO(+)
	//	AND
	//	    USUARIOCHEFE.IDPESSOAUSUARIO = PESSOACHEFE.IDPESSOA
	//	AND 
	//	    PESSOA.IDPESSOA = USUARIO.IDPESSOAUSUARIO
	//	AND
	//	    PESSOA.IDPESSOA = HDP.IDPESSOA
	//	AND
	//	    HDP.IDORGANIZACAODEPARTAMENTO = OD.IDORGANIZACAODEPARTAMENTO
	//	AND
	//	    HDP.IDNIVELCARGO = NC.IDNIVELCARGO
	//	AND
	//	    USUARIO.IDSTATUSUSUARIO = STATUSUSUARIO.IDSTATUSUSUARIO
	//	AND
	//	    USUARIO.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
	//	AND
	//	    PESSOA.IDPESSOA = PESSOADOCUMENTO.IDPESSOA
	//	AND
	//	    PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
	//	AND
	//	    DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
	//	AND
	//	    PESSOA.IDUF = UF.IDUF
	//	AND
	//	(
	//		TIPODOCUMENTO.SGCLASSIFICACAO = 'CPF'
	//	OR 
	//		TIPODOCUMENTO.SGTIPODOCUMENTO = 'RG'
	//	OR 
	//		TIPODOCUMENTO.SGTIPODOCUMENTO = 'RE' 
	//	)
    //    AND
	//	(
	//	        UPPER(USUARIO.NMLOGINUSUARIO) LIKE UPPER(:stUsuario4.cAuxlogin)
	//	    OR
	//	        '-1' = :stUsuario4.cAuxlogin
	//	)
	//	AND 
	//	( 
	//	        UPPER(USUARIO.NMLOGINUSUARIOCTI) LIKE UPPER(:stUsuario4.cAuxloginCti) 
	//	 	OR 
	//	        '-1'  = :stUsuario4.cAuxloginCti
	//	)
	//	AND 
	//	( 
	//	        USUARIO.IDSTATUSUSUARIO = :stUsuario4.cAuxidStatusAtual
	//	    OR 
	//	        '-1' = :stUsuario4.cAuxidStatusAtual
	//	)
	//	AND 
	//	( 
	//	        UPPER(USUARIOCHEFE.NMLOGINUSUARIO) LIKE UPPER(:stUsuario4.cAuxloginChefe) 
	//	 	OR 
	//	        '-1' = :stUsuario4.cAuxloginChefe
	//	)
	//	AND 
	//	( 
	//	        USUARIO.INCONSULTOR = :stUsuario4.cAuxinConsultor
	//	    OR 
	//	        '-1' = :stUsuario4.cAuxinConsultor
	//	)
	//	AND 
	//	( 
	//	        USUARIO.IDUFOPERADORA = :stUsuario4.cAuxidUFOperadora
	//	 	OR 
	//	        '-1' = :stUsuario4.cAuxidUFOperadora
	//	)
    //    AND
	//	(
	//	        NC.IDNIVEL = :stUsuario4.cAuxIdNivel
	//	    OR
	//	        '-1' = :stUsuario4.cAuxIdNivel
	//	)
	//	AND
	//	(
	//	        NC.IDCARGO = :stUsuario4.cAuxIdCargo
	//	    OR
	//	        '-1' = :stUsuario4.cAuxIdCargo
	//	)
	//	AND
	//	(
	//	        OD.IDORGANIZACAO = :stUsuario4.cAuxIdOrganizacao
	//	    OR
	//	        '-1' = :stUsuario4.cAuxIdOrganizacao
	//	)
	//	AND
	//	(
	//	        OD.IDDEPARTAMENTO = :stUsuario4.cAuxIdDepartamento
	//	    OR
	//	        '-1' = :stUsuario4.cAuxIdDepartamento
	//	)
	//	AND
	//	(
	//	        TIPODOCUMENTO.SGTIPODOCUMENTO = :stUsuario4.cAuxsgTipoDocAtual
	//	    OR
	//	        '-1' = :stUsuario4.cAuxsgTipoDocAtual
	//	)
	//	AND
	//	(
	//	        DOCUMENTO.NRDOCUMENTO = :stUsuario4.cAuxdsDocAtual
	//	    OR
	//	        '-1' = :stUsuario4.cAuxdsDocAtual
	//	)
	//	AND
	//	( 
	//	 	    UPPER(PESSOA.NMNOME) LIKE UPPER(:stUsuario4.cAuxnmnome)
	//	    OR 
	//	        '-1' = :stUsuario4.cAuxnmnome
	//	)
	//	AND
	//	( 
	//	 	    UPPER(PESSOA.NMNOMEMEIO) LIKE UPPER(:stUsuario4.cAuxnmnomemeio)
	//	    OR 
	//	        '-1' = :stUsuario4.cAuxnmnomemeio
	//	)
	//	AND
	//	( 
	//	 	    UPPER(PESSOA.NMSOBRENOME) LIKE UPPER(:stUsuario4.cAuxnmsobrenome)
	//	    OR 
	//	        '-1' = :stUsuario4.cAuxnmsobrenome
	//	)
	//	AND
	//		ROWNUM <= :nTotalLinhas * 3
	//);

    ULOG("  ->> ListComOrganogramaUsuario ->> Abrindo o Cursor"); 
	EXEC SQL OPEN CursorListComOrganogramaUsuario;

    ULOG("  ->> ListComOrganogramaUsuario ->> Cursor aberto"); 

	//Por default, zero indica nao haver mais paginas
	iProximaPagina = 0;
	for(iCont=1;;iCont++)
	{
		memset( &stRegUsuario, 0, sizeof(stRegUsuario) );
		EXEC SQL FETCH CursorListComOrganogramaUsuario INTO :stRegUsuario:stindicatorRegUsuario;
		
		if( iCont > iIni && iCont <  iFim )
		{
			Add( (char*)stRegUsuario.stidUsuario.arr
				,(char*)stRegUsuario.stnome.arr
				,(char*)stRegUsuario.stsobrenome.arr
				,(char*)stRegUsuario.stemail.arr
				,(char*)stRegUsuario.stidDDD.arr
				,(char*)stRegUsuario.stdsDDD.arr
				,(char*)stRegUsuario.stTelefone.arr
				,(char*)stRegUsuario.stlogin.arr
				,(char*)stRegUsuario.stloginCti.arr
				,(char*)stRegUsuario.stidStatusAtual.arr
				,(char*)stRegUsuario.stdescricaoStatusAtual.arr
				,(char*)stRegUsuario.stidMotivo.arr
				,(char*)stRegUsuario.stdsMotivo.arr
				,(char*)stRegUsuario.stdtInicio.arr
				,(char*)stRegUsuario.stdtRetorno.arr
				,(char*)stRegUsuario.stidCargoAtual.arr
				,(char*)stRegUsuario.stdescricaoCargoAtual.arr
				,(char*)stRegUsuario.stloginChefe.arr
				,(char*)stRegUsuario.stnomeChefe.arr
				,(char*)stRegUsuario.stidUF.arr
				,(char*)stRegUsuario.stnmUF.arr
				,(char*)stRegUsuario.stdtInclusao.arr
				,(char*)stRegUsuario.stdtExclusao.arr
				,(char*)stRegUsuario.stinConsultor.arr
				,(char*)stRegUsuario.stidUFOperadora.arr
                ,(char*)stRegUsuario.stidPerfilConsultorAtd.arr
                ,(char*)stRegUsuario.stidFornecedorConsultorAtd.arr
                ,(char*)stRegUsuario.stidSiteConsultorAtd.arr
                ,(char*)stRegUsuario.stdsLoginRoteamento.arr
			);
		}//if( iCont > iIni && iCont <  iFim )
	}//for(;;iContador++)
	EXEC SQL CLOSE CursorListComOrganogramaUsuario;


    ULOG("\n **************************************"); 
    ULOG("\n FIM DA CRIACAO DO XML ListComOrganogramaUsuario "); 
    ULOG("sqlca.sqlcode(%d)", sqlca.sqlcode);


	if( iCont > iFim )
		iProximaPagina = 1;

	if( iCont > nTotalLinhas )
		sprintf( cContadorPagina, "mais de %d página(s)", (iCont/iregistrosPPagina)+1 );
	else
		sprintf( cContadorPagina, "%d página(s)", (iCont/iregistrosPPagina)+1 );

    ULOG("  ->> ListComOrganogramaUsuario ->> Pesquisa finalizada indo para a montagem de XML"); 
    ULOG_END("CUsr::ListComOrganogramaUsuario()");
	return iCont-1;

GotoListComOrganogramaUsuario:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CUsr::ListUsuariosSuperiores( const char* idPessoaUsuarioWeb,
                                  const char* pszidPerfilConsultorAtdAtual,
                                  const char* pszLogin,
                                  const char* cpaginaAtual,
                                  const char* cregistrosPPagina
                                )
{
	ULOG_START("CUsr::ListUsuariosSuperiores()");

	struct sqlca sqlca;
	long iCont = 0;

	EXEC SQL BEGIN DECLARE SECTION;
		const char *varOraIdPerfilConsultorAtdAtual = pszidPerfilConsultorAtdAtual;
        const char *varOraIdPessoaUsuarioWeb = idPessoaUsuarioWeb;
        const char *varOraLogin = pszLogin;
		int varOraNrPesoHierarquia;
		short statOraNrPesoHierarquia;
		
		VARCHAR varOraIdPerfilConsultorAtd[11];
		short statOraIdPerfilConsultorAtd = -1;

		long ipaginaAtual;
		long iregistrosPPagina;
		long nTotalLinhas = TotalLinhasPorPesquisa();
		long iIni;
		long iFim;

		//Estrutura pra recuperar um registro
		struct
		{
			VARCHAR stidUsuario[21+1];
			VARCHAR stnome[255+1];
			VARCHAR stnomeMeio[255+1];
			VARCHAR stsobrenome[255+1];
			VARCHAR stlogin[255+1];
			VARCHAR stidPerfilConsultorAtd[10+1];
			VARCHAR stidFornecedorConsultorAtd[10+1];
			VARCHAR stidSiteConsultorAtd[10+1];
		} stRegUsuario;

		struct
		{
			short iidUsuario;
			short inome;
			short inomeMeio;
			short isobrenome;
			short ilogin;
			short iidPerfilConsultorAtd;
			short iidFornecedorConsultorAtd;
			short iidSiteConsultorAtd;
		} stindicatorRegUsuario;
	EXEC SQL END DECLARE SECTION;
	          
	if( strlennull( cpaginaAtual ) <= 0 )
		ipaginaAtual = 1;
	else
		ipaginaAtual = atoi( cpaginaAtual );
		
	if( ipaginaAtual < 0 )
		ipaginaAtual = 1;

	if( strlennull( cregistrosPPagina ) <= 0 )
		iregistrosPPagina = 100;
	else
		iregistrosPPagina = atoi( cregistrosPPagina );
	
	if( ( iregistrosPPagina <= 0 ) || ( iregistrosPPagina > 100 ) )
		iregistrosPPagina = 100;
		
	iIni = (ipaginaAtual-1)*iregistrosPPagina+1;
	iFim = iIni+iregistrosPPagina;
	
	iTamanhoPagina = iregistrosPPagina;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL WHENEVER SQLERROR GOTO GotoListUsuariosSuperiores;

	EXEC SQL
		SELECT
			NRPESOHIERARQUIA
		INTO
			:varOraNrPesoHierarquia:statOraNrPesoHierarquia
		FROM
			APOIO.PERFILCONSULTORATD
		WHERE
			IDPERFILCONSULTORATD = :varOraIdPerfilConsultorAtdAtual;

	if ( sqlca.sqlcode ) { goto GotoListUsuariosSuperiores; }

    if ( varOraNrPesoHierarquia > 4 ) varOraNrPesoHierarquia = 4;
    
    varOraNrPesoHierarquia++;

	EXEC SQL
		SELECT
			IDPERFILCONSULTORATD
		INTO
			:varOraIdPerfilConsultorAtd:statOraIdPerfilConsultorAtd
		FROM
			APOIO.PERFILCONSULTORATD
		WHERE
			NRPESOHIERARQUIA = :varOraNrPesoHierarquia;

	if ( sqlca.sqlcode ) { goto GotoListUsuariosSuperiores; }

    CONVIND(varOraIdPerfilConsultorAtd,statOraIdPerfilConsultorAtd);

    ULOG("idPerfilConsultorAtdAtual = %s",pszidPerfilConsultorAtdAtual);
    ULOG("                    login = %s",varOraLogin);
    ULOG("              paginaAtual = %d",ipaginaAtual);
    ULOG("         registrosPPagina = %s",cregistrosPPagina);
    ULOG("                     iIni = %d",iIni);
    ULOG("                     iFim = %d",iFim);

    ULOG("         nrPesoHierarquia = %d",varOraNrPesoHierarquia);
    ULOG("     idPerfilConsultorAtd = %s",varOraIdPerfilConsultorAtd.arr);
    ULOG("       idPessoaUsuarioWeb = %s",varOraIdPessoaUsuarioWeb);

	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL
	DECLARE 
	   	CursorLstUsuariosSuperiores CURSOR FOR
	SELECT
		 IDPESSOAUSUARIO
		,NMNOME
		,NMNOMEMEIO
		,NMULTIMONOME
		,NMLOGINUSUARIO
		,IDPERFILCONSULTORATD
		,IDFORNECEDORCONSULTORATD
		,IDSITECONSULTORATD
	FROM 
	(
		SELECT
			 IDPESSOAUSUARIO
			,NMNOME
			,NMNOMEMEIO
			,NMULTIMONOME
			,NMLOGINUSUARIO
			,IDPERFILCONSULTORATD
			,IDFORNECEDORCONSULTORATD
			,IDSITECONSULTORATD
			,ROWNUM AS NLIN
		FROM 
		(
			SELECT
				 USUARIO.IDPESSOAUSUARIO
				,USUARIO.NMNOME
				,USUARIO.NMNOMEMEIO
				,USUARIO.NMULTIMONOME
				,USUARIO.NMLOGINUSUARIO
				,USUARIO.IDPERFILCONSULTORATD
				,USUARIO.IDFORNECEDORCONSULTORATD
				,USUARIO.IDSITECONSULTORATD
			FROM 
				ACESSO.USUARIO USUARIO,
				APOIO.STATUSUSUARIO STATUSUSUARIO
			WHERE
			    USUARIO.IDSTATUSUSUARIO = STATUSUSUARIO.IDSTATUSUSUARIO
			AND STATUSUSUARIO.SGSTATUSUSUARIO = 'ATIVO'
			AND NVL(USUARIO.IDPERFILCONSULTORATD,'VIVO') = :varOraIdPerfilConsultorAtd
            AND USUARIO.IDPESSOAUSUARIO <> :varOraIdPessoaUsuarioWeb
            AND USUARIO.NMLOGINUSUARIO = :varOraLogin
			ORDER BY
				USUARIO.NMLOGINUSUARIO
		)
	)
    WHERE NLIN >= :iIni AND NLIN <= :iFim;

	iProximaPagina = 0; //Por default, zero indica nao haver mais paginas

	EXEC SQL OPEN CursorLstUsuariosSuperiores;

	for(iCont=1;;iCont++)
	{
		memset( &stRegUsuario, 0, sizeof(stRegUsuario) );
		memset( &stindicatorRegUsuario, 0, sizeof(stindicatorRegUsuario) );

		EXEC SQL FETCH CursorLstUsuariosSuperiores INTO :stRegUsuario:stindicatorRegUsuario;
		
		if( iCont <= iregistrosPPagina )
		{
			Add( (char*)stRegUsuario.stidUsuario.arr
				,(char*)stRegUsuario.stnome.arr
				,(char*)stRegUsuario.stsobrenome.arr
				,"" // email
				,"" // idDDD
				,"" // dsDDD
				,"" // Telefone
				,(char*)stRegUsuario.stlogin.arr
				,"" // loginCti
				,"" // idStatusAtual
				,"" // descricaoStatusAtual
				,"" // idMotivo
				,"" // dsMotivo
				,"" // dtInicio
				,"" // dtRetorno
				,"" // idCargoAtual
				,"" // descricaoCargoAtual
				,"" // loginChefe
				,(char*)stRegUsuario.stnomeMeio.arr // usei a posição do 'nomeChefe'
				,"" // idUF                            para não ter de alterar a estrutura
				,"" // nmUF                            STUsuarioRegistro em todo lugar em
				,"" // dtInclusao                      que é usada.
				,"" // dtExclusao
				,"" // inConsultor
				,"" // idUFOperadora
				,(char*)stRegUsuario.stidPerfilConsultorAtd.arr
				,(char*)stRegUsuario.stidFornecedorConsultorAtd.arr
				,(char*)stRegUsuario.stidSiteConsultorAtd.arr
				,"" // dsLoginRoteamento
			);
		}//if( iCont <= iregistrosPPagina )

	} //for(;;iContador++)

	EXEC SQL CLOSE CursorLstUsuariosSuperiores;

	if( iCont > iregistrosPPagina )
		iProximaPagina = 1;

	if( iCont > nTotalLinhas )
		sprintf( cContadorPagina, "mais de %d página(s)", (iCont/iregistrosPPagina)+1 );
	else
		sprintf( cContadorPagina, "%d página(s)", (iCont/iregistrosPPagina)+1 );

    ULOG("           iProximaPagina = %d",iProximaPagina);
    ULOG("                    iCont = %d",iCont);
    ULOG("           ContadorPagina = %s",cContadorPagina);

	ULOG_END("CUsr::ListUsuariosSuperiores()");

	return iCont-1;

GotoListUsuariosSuperiores:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CUsr::TotalLinhasPorPesquisa( void )
{
	ULOG_START("CUsr::TotalLinhasPorPesquisa()");
	
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		int   iTotalLinhas = 0;
		short sTotalLinhas;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoTotalLinhasPorPesquisa;

	EXEC SQL
	SELECT
		TO_NUMBER(DSVALORPARAMETRO)
	INTO
		:iTotalLinhas:sTotalLinhas
	FROM
		APOIO.PARAMETRO
	WHERE
		CDPARAMETRO = 'TOTAL_PAGINAS_PESQUISA_USUARIO';
		
	ULOG_END("CUsr::TotalLinhasPorPesquisa()");
	return iTotalLinhas;

GotoTotalLinhasPorPesquisa:
	throw TuxBasicOraException(sqlca.sqlcode);
}



int CUsr::ValidaUsuario( char * nrDocumentoPrm , 
                         char * nmLoginPrm , 
                         char * nmPrimeiroPrm , 
                         char * nmMeioPrm ,  
                         char * nmUltimoPrm , 
                         char * idUFPrm ,
                         char * cAuxloginCtiPrm ,
                         char * inDisponivelPrm ,
                         char * cAuxemailPrm ,
                         char * cAuxTelefonePrm ,
                         char * cAuxidDDDPrm ,
                         char * cAuxinConsultorPrm ,
                         char * cAuxidPerfilConsultorAtdPrm ,
                         char * cAuxidFornecedorConsultorAtdPrm ,
                         char * cAuxidSiteConsultorAtdPrm ,
                         char * cAuxdsLoginRoteamentoPrm ,
                         char * cloginChefePrm ,
                         char * idUsuarioPrm )
{
    ULOG_START( "CUsr::ValidaUsuario()" );
    
    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;
    
        char * nrDocumento = nrDocumentoPrm;
        char * nmLogin = nmLoginPrm;
        char * nmPrimeiro = nmPrimeiroPrm;
        char * nmMeio = nmMeioPrm;
        char * nmUltimo = nmUltimoPrm;
        char * idUF = idUFPrm;
        
        char * cAuxloginCti = cAuxloginCtiPrm ;
        char * inDisponivel = inDisponivelPrm ;
        char * cAuxemail = cAuxemailPrm ;
        char * cAuxTelefone = cAuxTelefonePrm ;
        char * cAuxidDDD = cAuxidDDDPrm ;
        char * cAuxinConsultor = cAuxinConsultorPrm ;
        char * cAuxidPerfilConsultorAtd = cAuxidPerfilConsultorAtdPrm ;
        char * cAuxidFornecedorConsultorAtd = cAuxidFornecedorConsultorAtdPrm ;
        char * cAuxidSiteConsultorAtd = cAuxidSiteConsultorAtdPrm ;
        char * cAuxdsLoginRoteamento = cAuxdsLoginRoteamentoPrm ;
        char * cloginChefe = cloginChefePrm ;
        
        char buffer[256];

        VARCHAR   idPessoaUsuario[256];
        short     i_idPessoaUsuario = -1;
        int       iDocNaBase;
        int       iUsuarioExiste;
        int       inUsuarioAtivo;
        int       idStatusUsuario;
        short     i_idStatusUsuario = -1;
        VARCHAR   nmPessoa[256];
        short     i_nmPessoa = -1;
        VARCHAR   nmAux[256];
        short     i_nmAux = -1;
        int idx;
        int existe;
        
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL WHENEVER SQLERROR GOTO GotoValidaUsuario;
    
    sqlca.sqlcode=0;
    memset( &idPessoaUsuario, 0x0, sizeof(idPessoaUsuario) );
    memset( &nmPessoa       , 0x0, sizeof(nmPessoa) );
    
    EXEC SQL
    SELECT
       IDPESSOAUSUARIO
    INTO
       :idPessoaUsuario:i_idPessoaUsuario
    FROM
       ACESSO.USUARIO
    WHERE
       UPPER(NMLOGINUSUARIO) = UPPER(:nmLogin) ;
    
    CONVIND( idPessoaUsuario, i_idPessoaUsuario );
    
    EXEC SQL
    SELECT
      COUNT(*)
    INTO :iDocNaBase
    FROM
      ACESSO.USUARIO     USU ,
      CUSTOMER.DOCUMENTO DOC ,
      CUSTOMER.PESSOADOCUMENTO PD
    WHERE
      DOC.NRDOCUMENTO = :nrDocumento
    AND DOC.IDDOCUMENTO = PD.IDDOCUMENTO
    AND USU.IDPESSOAUSUARIO = PD.IDPESSOA ;

    
    if ( i_idPessoaUsuario == -1 && !iDocNaBase )   // Login e CPF nao encontrado na base
    {   // Cenario 6 - RMS Vivonet V6.5
        ULOG( "!!! Login e CPF nao encontrado na base" );
        ULOG_END( "CUsr::ValidaUsuario()" );
        return 0 ;
    }
    
    strcpy( idUsuarioPrm, (char*)idPessoaUsuario.arr );

    if ( !iDocNaBase )   // CPF nao encontrado na base
    {
        if ( i_idPessoaUsuario != -1 ) 
        {
            EXEC SQL
            SELECT
               USU.IDSTATUSUSUARIO
            INTO
               :idStatusUsuario:i_idStatusUsuario
            FROM
               ACESSO.USUARIO USU
            WHERE
               USU.IDPESSOAUSUARIO = :idPessoaUsuario ;
               
            if ( idStatusUsuario == 1 )   // Usuario ATIVO
            {
                ULOG( "!!! Usuario ativo na base" );
                ULOG_END( "CUsr::ValidaUsuario()" );
                return 30 ;  // Cenario 5 - Informa que Usuario estah ATIVO
            }
            else   // Usuario INATIVO
            {
                for ( idx=0;;++idx )
                {
                    sprintf( buffer, "%s_OLD%d", nmLogin, idx );
                ULOG( "buffer [%s]", buffer );
                    EXEC SQL
                    SELECT count(*) into :existe FROM ACESSO.USUARIO WHERE NMLOGINUSUARIO = :buffer ;
                    if ( existe == 0 ) 
                       break;
                }
                EXEC SQL
                UPDATE ACESSO.USUARIO
                SET NMLOGINUSUARIO = :buffer ,
                    IDSTATUSUSUARIO = 2
                WHERE IDPESSOAUSUARIO = :idPessoaUsuario ;
                
                ULOG( "!!! Usuario inativo na base" );
                ULOG_END( "CUsr::ValidaUsuario()" );
                return 35 ;  // Cenario 4 - Informa que Usuario estah INATIVO
            }
            
        }
        
    }

    if ( i_idPessoaUsuario == -1 )   // Login nao encontrado na base
    {
        if ( iDocNaBase )   // CPF encontrado na base
        {
            EXEC SQL
            SELECT
               count(1)
            INTO
               :inUsuarioAtivo
            FROM
               ACESSO.USUARIO   USU
            WHERE
               USU.IDSTATUSUSUARIO = 1  // Usuario Ativo
            AND IDPESSOAUSUARIO IN
            (
               SELECT
                  IDPESSOA
               FROM
                  CUSTOMER.DOCUMENTO DOC ,
                  CUSTOMER.PESSOADOCUMENTO PD
               WHERE
                  DOC.NRDOCUMENTO = :nrDocumento
               AND DOC.IDDOCUMENTO = PD.IDDOCUMENTO
            ) ;   
            
            if ( inUsuarioAtivo )  // CPF Ativo para atendimento
            {
                ULOG( "!!! CPF ativo na base" );
                ULOG_END( "CUsr::ValidaUsuario()" );
                return 15 ;  // Cenario 3 - Informa que o CPF estah ativo na base
            }
            else
            {
                ULOG( "!!! CPF inativo na base" );
                ULOG_END( "CUsr::ValidaUsuario()" );
                return 20 ;  // Cenario 2 - Informa que o CPF estah inativo na base
            }

        }
    }

    // Cenario 1 - RMS Vivonet V6.5
    EXEC SQL
    SELECT
       COUNT(1)
    INTO
       :iUsuarioExiste
    FROM
       ACESSO.USUARIO   USU
    WHERE
       USU.NMLOGINUSUARIO = :nmLogin
    AND IDPESSOAUSUARIO IN
    (
       SELECT
          IDPESSOA
       FROM
          CUSTOMER.DOCUMENTO DOC ,
          CUSTOMER.PESSOADOCUMENTO PD
       WHERE
          DOC.NRDOCUMENTO = :nrDocumento
       AND DOC.IDDOCUMENTO = PD.IDDOCUMENTO
    ) ;   
    
    if ( iUsuarioExiste )
    {
        //Atualiza a pessoa
        EXEC SQL
        SELECT TRIM(:nmPrimeiro) || ' ' || TRIM(:nmMeio) || ' ' || TRIM(:nmUltimo) INTO :nmPessoa:i_nmPessoa FROM DUAL;
        CONVIND( nmPessoa, i_nmPessoa );
        
        EXEC SQL
        UPDATE CUSTOMER.PESSOA
        SET
            NMPESSOA = :nmPessoa
           ,NMNOME = TRIM(:nmPrimeiro)
           ,NMNOMEMEIO = TRIM(:nmMeio)
           ,NMSOBRENOME = TRIM(:nmUltimo)
           ,IDUF = :idUF
           ,IDUSUARIOALTERACAO = 1
           ,DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDPESSOA = :idPessoaUsuario;

        // Se nao for informado o login do chefe, mantem o chefe anterior
        if ( cloginChefe[0] != 0x0 )
        {
            InsertChefeLogin( (char *)idPessoaUsuario.arr
                             ,cloginChefe
                             , "1" );  // adminfo
        }
        
        // Atualiza usuario com informacoes atuais
        EXEC SQL
        UPDATE ACESSO.USUARIO
        SET
            NMNOME = SUBSTR(TRIM(:nmPrimeiro),1,255)
           ,NMNOMEMEIO = SUBSTR(TRIM(:nmMeio),1,255)
           ,NMULTIMONOME = SUBSTR(TRIM(:nmUltimo),1,255)
           ,IDSTATUSUSUARIO = 2   // INATIVO
           ,IDUSUARIOALTERACAO = 1   // adminfo
           ,DTULTIMAALTERACAO = SYSDATE
		  ,INREINICIALIZASENHA = 1
		  ,NMLOGINUSUARIOCTI = SUBSTR(TRIM(:cAuxloginCti),1,255)
		  ,INPRONTOATENDER = 0
		  ,INATRIBUICAOPROCESSOS = 0
		  ,DTSTATUSUSUARIO = SYSDATE
		  ,INDISPONIVELWF = decode(:inDisponivel,'N',0,1)
		  ,DSEMAIL = SUBSTR(TRIM(:cAuxemail),1,255)
		  ,NRTELEFONE = :cAuxTelefone
		  ,IDAREAREGISTRO = :cAuxidDDD
		  ,SGSENHAUSUARIO = :nmLogin
		  ,INCONSULTOR = :cAuxinConsultor
		  ,IDUFOPERADORA = :idUF
		  ,IDPERFILCONSULTORATD = :cAuxidPerfilConsultorAtd
		  ,IDFORNECEDORCONSULTORATD = :cAuxidFornecedorConsultorAtd
		  ,IDSITECONSULTORATD = :cAuxidSiteConsultorAtd
          ,DSLOGINROTEAMENTO = :cAuxdsLoginRoteamento
        WHERE
            IDPESSOAUSUARIO = :idPessoaUsuario ;
        
        ULOG( "!!! Login e CPF ja cadastrados na base, apenas atualizacao de dados" );
        ULOG_END( "CUsr::ValidaUsuario()" );
        return 11;  // Login e CPF ja cadastrados na base, apenas atualizacao de dados
    }  // FIM CENARIO 1
    else
    {
        ULOG( "!!! Login existente para CPF diferente do passado como parametro" );
        ULOG_END( "CUsr::ValidaUsuario()" );
        return 40 ;   // // Cenario 7 - RMS Vivonet V6.5 - Login existente para CPF diferente do parametro
    }
    

GotoValidaUsuario:
    throw TuxBasicOraException(sqlca.sqlcode);
}
