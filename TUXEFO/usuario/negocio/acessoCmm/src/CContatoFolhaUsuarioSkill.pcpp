#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
#include "CContatoFolhaUsuarioSkill.h"

CContatoFolhaUsuarioSkill::CContatoFolhaUsuarioSkill()
{
}

CContatoFolhaUsuarioSkill::~CContatoFolhaUsuarioSkill()
{
}

int CContatoFolhaUsuarioSkill::ListId(
					 char* cidGrupoSkill
	 )
{
	
	ULOG_START("CContatoFolhaUsuarioSkill::ListId()");
	
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidGrupoSkillAux = cidGrupoSkill;
		struct
		{
			VARCHAR stidGrupoSkill[21+1];
			VARCHAR stidContatoFolhaUsuario[21+1];
		} stRegistro;
		struct
		{
			short iidGrupoSkill;
			short iidContatoFolhaUsuario;
		} stIndicator;
	EXEC SQL END DECLARE SECTION;

	//Zera a estrutura da classe
	ZeraContatoFolhaUsuarioSkill();
	memset( &sqlca, 0, sizeof( sqlca ) );
	memset( &stRegistro, 0, sizeof(stRegistro) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListId;

	//Declara um cursor para listar os IDs
	EXEC SQL 
	SELECT
		 IDGRUPOSKILL
		,IDCONTATOFOLHAUSUARIO
	INTO 
		:stRegistro:stIndicator
	FROM 
		ACESSO.CONTATOFOLHAUSUARIOSKILL
	WHERE 
		IDGRUPOSKILL = :cidGrupoSkillAux;

	Add(
		 (char*)stRegistro.stidGrupoSkill.arr
		,(char*)stRegistro.stidContatoFolhaUsuario.arr
	);

	ULOG_END("CContatoFolhaUsuarioSkill::ListId()");
	return Quantidade();

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoFolhaUsuarioSkill::ListAll( void )
{
	ULOG_START("CContatoFolhaUsuarioSkill::ListAll()");
	
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidGrupoSkill[21+1];
			VARCHAR stidContatoFolhaUsuario[21+1];
		} stRegistro;
		struct
		{
			short iidGrupoSkill;
			short iidContatoFolhaUsuario;
		} stIndicator;
	EXEC SQL END DECLARE SECTION;

	//Zera a estrutura da classe
	ZeraContatoFolhaUsuarioSkill();
	memset( &sqlca, 0, sizeof( sqlca ) );
	memset( &stRegistro, 0, sizeof(stRegistro) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;

	//Declara um cursor para listar todos os registros
	EXEC SQL 
	DECLARE 
   		CursorListAll CURSOR FOR
	SELECT
		 IDGRUPOSKILL
		,IDCONTATOFOLHAUSUARIO
	FROM 
		ACESSO.CONTATOFOLHAUSUARIOSKILL
	WHERE
		IDGRUPOSKILL > 0;

   //Abre o cursor
   EXEC SQL OPEN CursorListAll;

	//Caso inexista registros sair do loop
	EXEC SQL WHENEVER NOT FOUND DO break;
	for(;;)
	{
		//Zera a estrutura de restorno
		memset( &stRegistro, 0, sizeof(stRegistro) );
		//Pega um registro no CURSOR
		EXEC SQL FETCH CursorListAll INTO :stRegistro:stIndicator;
		//Adiciona a classe
		Add(
			 (char*)stRegistro.stidGrupoSkill.arr
			,(char*)stRegistro.stidContatoFolhaUsuario.arr
		);
	}
	//Fecha o cursor
	EXEC SQL CLOSE CursorListAll;

	ULOG_END("CContatoFolhaUsuarioSkill::ListAll( )");
	return Quantidade();

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);
}

void CContatoFolhaUsuarioSkill::GetXml( char* cNomeTag, XMLGen*xml )
{
	ULOG_START("CContatoFolhaUsuarioSkill::GetXml(  )");
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			xml->createTag(cNomeTag);
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idGrupoSkill", Registro(x)->cidGrupoSkill);
				xml->addItem("idContatoFolhaUsuario", Registro(x)->cidContatoFolhaUsuario);
			}
			//So fecha um tag se abriu anteriormente
			xml->closeTag();
		}
	}
	ULOG_END("CContatoFolhaUsuarioSkill::GetXml( )");
}

int CContatoFolhaUsuarioSkill::Insert(
				 	 char* cidGrupoSkill
					,char* cidContatoFolhaUsuario
					,char* cidUser
	 )
{
	
	ULOG_START("CContatoFolhaUsuarioSkill::Insert()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidUserAux = cidUser;
		char* cidContatoFolhaUsuarioAux = cidContatoFolhaUsuario;
		char* cidGrupoSkillAux = cidGrupoSkill;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;

	//Insere um registro
	EXEC SQL 
	INSERT INTO ACESSO.CONTATOFOLHAUSUARIOSKILL
	( 
		 IDGRUPOSKILL
		,IDCONTATOFOLHAUSUARIO
		,IDUSUARIOALTERACAO
		,DTULTIMAALTERACAO
	)
	VALUES 
	( 
		 :cidGrupoSkillAux
		,:cidContatoFolhaUsuarioAux
		,:cidUserAux
		,SYSDATE 
	);

	//Salva o registro na estrutura interna
	Add(
		 cidGrupoSkillAux
		,cidContatoFolhaUsuario
	);

	ULOG_END("CContatoFolhaUsuarioSkill::Insert()");
	return 1;

GotoInsert:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoFolhaUsuarioSkill::Update(
					 char* cidGrupoSkill
					,char* cidContatoFolhaUsuario
					,char* cidUser
	 ) 
{
	ULOG_START("CContatoFolhaUsuarioSkill::Update()");
	
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidUserAux = cidUser;
		char* cidGrupoSkillAux = cidGrupoSkill;
		char* cidContatoFolhaUsuarioAux = cidContatoFolhaUsuario;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;

	//Atualiza um registro
	EXEC SQL 
	UPDATE 
		ACESSO.CONTATOFOLHAUSUARIOSKILL
	SET 
		 IDGRUPOSKILL = :cidGrupoSkillAux
		,IDUSUARIOALTERACAO = :cidUserAux
		,DTULTIMAALTERACAO = SYSDATE
	WHERE
		IDCONTATOFOLHAUSUARIO = :cidContatoFolhaUsuarioAux;

	//Salva o registro na estrutura interna
	Add(
		 cidGrupoSkill
		,cidContatoFolhaUsuario
	);

	ULOG_END("CContatoFolhaUsuarioSkill::Update()");
	return 1;

GotoUpdate:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoFolhaUsuarioSkill::Delete( 
					 char* cidGrupoSkill
				  ) 
{
	ULOG_START("CContatoFolhaUsuarioSkill::Delete()");
	
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidGrupoSkillAux = cidGrupoSkill;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;

	//Apaga um registro
	EXEC SQL 
	DELETE FROM 
		ACESSO.CONTATOFOLHAUSUARIOSKILL
	WHERE 
		IDGRUPOSKILL = :cidGrupoSkillAux;

	ULOG_END("CContatoFolhaUsuarioSkill::Delete()");
	return 1;

GotoDelete:
	throw TuxBasicOraException(sqlca.sqlcode);
}