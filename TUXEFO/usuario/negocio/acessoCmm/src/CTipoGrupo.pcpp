#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
#include "CTipoGrupo.h"

CTipoGrupo::CTipoGrupo()
{
}

CTipoGrupo::~CTipoGrupo()
{
}

int CTipoGrupo::ListId(
					 char* cidTipoGrupo
	 )
{
	ULOG_START("CTipoGrupo::ListId()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidTipoGrupoAux = cidTipoGrupo;
		struct
		{
			VARCHAR stidTipoGrupo[21+1];
			VARCHAR stsgTipoGrupo[255+1];
			VARCHAR stdsTipoGrupo[255+1];
		} stRegistro;
		struct
		{
			short iidTipoGrupo;
			short isgTipoGrupo;
			short idsTipoGrupo;
		} stIndicator;
	EXEC SQL END DECLARE SECTION;

	//Zera a estrutura da classe
	ZeraTipoGrupo();
	memset( &sqlca, 0, sizeof( sqlca ) );
	memset( &stRegistro, 0, sizeof(stRegistro) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListId;

	//Declara um cursor para listar os IDs
	EXEC SQL 
	SELECT
		 IDTIPOGRUPO
		,SGTIPOGRUPO
		,DSTIPOGRUPO
	INTO 
		:stRegistro:stIndicator
	FROM 
		APOIO.TIPOGRUPO
	WHERE 
		IDTIPOGRUPO = :cidTipoGrupoAux;

	Add(
		 (char*)stRegistro.stidTipoGrupo.arr
		,(char*)stRegistro.stsgTipoGrupo.arr
		,(char*)stRegistro.stdsTipoGrupo.arr
	);

	ULOG_END("CTipoGrupo::ListId()");
	return Quantidade();

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CTipoGrupo::ListAll( void )
{
	ULOG_START("CTipoGrupo::ListAll()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidTipoGrupo[21+1];
			VARCHAR stsgTipoGrupo[255+1];
			VARCHAR stdsTipoGrupo[255+1];
		} stRegistro;
		struct
		{
			short iidTipoGrupo;
			short isgTipoGrupo;
			short idsTipoGrupo;
		} stIndicator;
	EXEC SQL END DECLARE SECTION;

	//Zera a estrutura da classe
	ZeraTipoGrupo();
	memset( &sqlca, 0, sizeof( sqlca ) );
	memset( &stRegistro, 0, sizeof(stRegistro) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;

	//Declara um cursor para listar todos os registros
	EXEC SQL 
	DECLARE 
   		CursorListAll CURSOR FOR
	SELECT
		 IDTIPOGRUPO
		,SGTIPOGRUPO
		,DSTIPOGRUPO
	FROM 
		APOIO.TIPOGRUPO
	WHERE
		IDTIPOGRUPO > 0;

   //Abre o cursor
   EXEC SQL OPEN CursorListAll;

	//Caso inexista registros sair do loop
	EXEC SQL WHENEVER NOT FOUND DO break;
	for(;;)
	{
		//Zera a estrutura de restorno
		memset( &stRegistro, 0, sizeof(stRegistro) );
		//Pega um registro no CURSOR
		EXEC SQL FETCH CursorListAll INTO :stRegistro:stIndicator;
		//Adiciona a classe
		Add(
			 (char*)stRegistro.stidTipoGrupo.arr
			,(char*)stRegistro.stsgTipoGrupo.arr
			,(char*)stRegistro.stdsTipoGrupo.arr
		);
	}
	//Fecha o cursor
	EXEC SQL CLOSE CursorListAll;

	ULOG_END("CTipoGrupo::ListAll()");
	return Quantidade();

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);
}

void CTipoGrupo::GetXml( char* cNomeTag, XMLGen*xml )
{
	ULOG_START("CTipoGrupo::GetXml()");
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			xml->createTag(cNomeTag);
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idTipoGrupo", Registro(x)->cidTipoGrupo);
//				xml->addItem("sgTipoGrupo", Registro(x)->csgTipoGrupo);
				xml->addItem("dsTipoGrupo", Registro(x)->cdsTipoGrupo);
			}
			//So fecha um tag se abriu anteriormente
			xml->closeTag();
		}
	}
	ULOG_END("CTipoGrupo::GetXml()");
}

int CTipoGrupo::Insert(
					 char* csgTipoGrupo
					,char* cdsTipoGrupo
					,char* cidUser
	 )
{
	ULOG_START("CTipoGrupo::Insert()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidUserAux = cidUser;
		VARCHAR stidTipoGrupo[21+1];
		char* csgTipoGrupoAux = csgTipoGrupo;
		char* cdsTipoGrupoAux = cdsTipoGrupo;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );
	memset( &stidTipoGrupo, 0, sizeof( stidTipoGrupo ) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;

	//Recupera um id unico
	EXEC SQL
	SELECT 
		APOIO.TIPOGRUPOSQ.NEXTVAL
	INTO
		:stidTipoGrupo
	FROM
		DUAL;

	//Insere um registro
	EXEC SQL 
	INSERT INTO APOIO.TIPOGRUPO
	( 
		 IDTIPOGRUPO
		,SGTIPOGRUPO
		,DSTIPOGRUPO
		,IDUSUARIOALTERACAO
		,DTULTIMAALTERACAO
	)
	VALUES 
	( 
		:stidTipoGrupo
		,:csgTipoGrupoAux
		,:cdsTipoGrupoAux
		,:cidUserAux
		,SYSDATE 
	);

	//Salva o registro na estrutura interna
	Add(
		 (char*)stidTipoGrupo.arr
		,csgTipoGrupo
		,cdsTipoGrupo
	);

    ULOG_END("CTipoGrupo::Insert()");
	return 1;

GotoInsert:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CTipoGrupo::Update(
					 char* cidTipoGrupo
					,char* csgTipoGrupo
					,char* cdsTipoGrupo
					,char* cidUser
	 ) 
{
	ULOG_START("CTipoGrupo::Update()");
	
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidUserAux = cidUser;
		char* cidTipoGrupoAux = cidTipoGrupo;
		char* csgTipoGrupoAux = csgTipoGrupo;
		char* cdsTipoGrupoAux = cdsTipoGrupo;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;

	//Atualiza um registro
	EXEC SQL 
	UPDATE 
		APOIO.TIPOGRUPO
	SET 
		 SGTIPOGRUPO = :csgTipoGrupoAux
		,DSTIPOGRUPO = :cdsTipoGrupoAux
		,IDUSUARIOALTERACAO = :cidUserAux
		,DTULTIMAALTERACAO = SYSDATE
	WHERE
		IDTIPOGRUPO = :cidTipoGrupoAux;

	//Salva o registro na estrutura interna
	Add(
		 cidTipoGrupo
		,csgTipoGrupo
		,cdsTipoGrupo
	);
    ULOG_END("CTipoGrupo::Update()");
	return 1;

GotoUpdate:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CTipoGrupo::Delete( 
					 char* cidTipoGrupo
				  ) 
{
	ULOG_START("CTipoGrupo::Delete()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidTipoGrupoAux = cidTipoGrupo;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;

	//Apaga um registro
	EXEC SQL 
	DELETE FROM 
		APOIO.TIPOGRUPO
	WHERE 
		IDTIPOGRUPO = :cidTipoGrupoAux;
    
    ULOG_END("CTipoGrupo::Delete()");
	return 1;

GotoDelete:
	throw TuxBasicOraException(sqlca.sqlcode);
}