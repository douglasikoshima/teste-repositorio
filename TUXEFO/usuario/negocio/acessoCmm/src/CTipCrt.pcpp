#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "CTipCrt.h"

CTipCrt::CTipCrt()
{
}

CTipCrt::~CTipCrt()
{
}

int CTipCrt::ListId( char* cid )
{
	ULOG_START("CTipCrt::ListId()");
	
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidOra = cid;
		struct
		{
			VARCHAR stId[21+1];
			VARCHAR stSigla[255+1];
			VARCHAR stDescricao[255+1];
			VARCHAR stvlPeso[21+1];
		} stTipoCarteiraRegistro;
		struct
		{
			short iId;
			short iSigla;
			short iDescricao;
			short iIndisponibilidade;
		} stTipoCarteiraIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{
		ZeraTipoCarteira();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;
	
	   	EXEC SQL DECLARE CursorTipoCarteiraId CURSOR FOR
			SELECT IDTIPOCARTEIRA, 
			       SGTIPOCARTEIRA, 
			       DSTIPOCARTEIRA, 
			       VLPESO 
			  FROM APOIO.TIPOCARTEIRA
			 WHERE IDTIPOCARTEIRA = :cidOra;
	
		EXEC SQL OPEN CursorTipoCarteiraId;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CTipCrt::ListId()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stTipoCarteiraRegistro, 0, sizeof(stTipoCarteiraRegistro) );
				EXEC SQL FETCH CursorTipoCarteiraId INTO :stTipoCarteiraRegistro:stTipoCarteiraIndicator;
	
				Add( (char*)stTipoCarteiraRegistro.stId.arr, (char*)stTipoCarteiraRegistro.stSigla.arr, (char*)stTipoCarteiraRegistro.stDescricao.arr, (char*)stTipoCarteiraRegistro.stvlPeso.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorTipoCarteiraId;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CTipCrt::ListId()");
	return iCont;

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CTipCrt::ListAll( void )
{
	ULOG_START("CTipCrt::ListAll()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stId[21+1];
			VARCHAR stSigla[255+1];
			VARCHAR stDescricao[255+1];
			VARCHAR stvlPeso[21+1];
		} stTipoCarteiraRegistro;
		struct
		{
			short iId;
			short iSigla;
			short iDescricao;
			short iIndisponibilidade;
		} stTipoCarteiraIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{
		ZeraTipoCarteira();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;
	
	   	EXEC SQL DECLARE CursorTipoCarteiraAll CURSOR FOR
			SELECT IDTIPOCARTEIRA, 
			       SGTIPOCARTEIRA, 
			       DSTIPOCARTEIRA, 
			       VLPESO 
			  FROM APOIO.TIPOCARTEIRA;
	
		EXEC SQL OPEN CursorTipoCarteiraAll;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CTipCrt::ListAll()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stTipoCarteiraRegistro, 0, sizeof(stTipoCarteiraRegistro) );
				EXEC SQL FETCH CursorTipoCarteiraAll INTO :stTipoCarteiraRegistro:stTipoCarteiraIndicator;
	
				Add( (char*)stTipoCarteiraRegistro.stId.arr, (char*)stTipoCarteiraRegistro.stSigla.arr, (char*)stTipoCarteiraRegistro.stDescricao.arr, (char*)stTipoCarteiraRegistro.stvlPeso.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorTipoCarteiraAll;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CTipCrt::ListAll()");
	return iCont;

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CTipCrt::GetXml( char* cNomeTag, XMLGen*xml )
{
	ULOG_START("CTipCrt::GetXml()");
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			xml->addProp(	"xmlns", "usuario.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{
				xml->addItem("idTipoCarteira"  , Registro(x)->cidTipoCarteira   );
				xml->addItem("sgTipoCarteira"  , Registro(x)->csgTipoCarteira   );
				xml->addItem("dsTipoCarteira"  , Registro(x)->cdsTipoCarteira   );
				xml->addItem("indisponibilidade", Registro(x)->cvlPeso );
			}
			xml->closeTag();
		}
	}
	ULOG_END("CTipCrt::GetXml()");
}