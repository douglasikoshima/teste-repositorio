/*****************************************************************************
 *
 * Modulo:    CSrv
 * Arquivo:   CSrv.cpp
 * Proposito: Funcao de Negocios 
 * Historico:
 * Data        Autor                 Descricao
 * ----------  --------------------  -----------------------------------------
 * 18/05/2004  C_RECOliveira         Criacao
 * 18/05/2004  C_EDMartins           Criacao
 *
 ****************************************************************************/
/**************************************************************************
 * Notas:
 *
 **************************************************************************/

//Definicao Global
#define CSrvCPP

//Header
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <tuxfw.h>
#include "CSrv.h"
#include "CSafePointer.h"

char* CSrv::RTrim(char *pszString)
{
    ULOG_START("CSrv::RTrim()");
    int iLen;

    iLen=strlen(pszString);

    for(;;)
    {
        if(pszString[iLen-1] != ' ')
            break;

        iLen--;

        if(iLen == 0)
            break;
    }
    pszString[iLen] = 0x00;
    ULOG_END("CSrv::RTrim()");
	return pszString;
}

//Classe:
int CSrv::SrvInserir(DOMNode*dnode,XMLGen*xml_g,
				     char* cLogUser)
{
	ULOG_START("CSrv::SrvInserir()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;

		struct 
		{ 
			VARCHAR stidHost[21+1];
			char    cnmHost[255+1];
		} stRegistro;

		int iAcumulador;

	EXEC SQL END DECLARE SECTION;

	//Declara variaveis auxiliares
	char *pc;
	try
	{
		memset( &stRegistro, 0, sizeof(stRegistro) );
	
		//Se a DESCRICAO nao existir entao retornar com codigo de erro
		pc = oSafePointer.getTag(dnode,"dsServidor",0); 
		if ( pc == NULL )
		{
			ULOG_END("CSrv::SrvInserir()");
			return 2;
		}

		strcpy( stRegistro.cnmHost, pc ); 

		sqlca.sqlcode=0;

		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;

		//Conta os casos de ja existentes de descricao 
		EXEC SQL
			SELECT 
				COUNT(IDHOST) 
			INTO 
				:iAcumulador
			FROM 
				ACESSO.HOST
			WHERE 
				UPPER(NMHOST) = UPPER(:stRegistro.cnmHost);

		//Se nao houver o caso desta descricao entao pode Inserir
		if (iAcumulador==0) 
		{
			//Pega um ID único 
			EXEC SQL
				SELECT 
					ACESSO.HOSTSQ.NEXTVAL
				INTO 
					:stRegistro.stidHost
				FROM DUAL;

			//Insere o ID novo
			EXEC SQL 
				INSERT INTO ACESSO.HOST 
				( 
					  IDHOST
					, NMHOST
					, IDUSUARIOALTERACAO
					, DTULTIMAALTERACAO 
				)
				VALUES
				( 
					  :stRegistro.stidHost
					, TRIM(SUBSTR(:stRegistro.cnmHost,1,255))
					, :cLogUserOra
					, SYSDATE 
				);
				setIdHost( (char*)stRegistro.stidHost.arr );
				setDsHost( stRegistro.cnmHost );
		}
		else
		{
			ULOG_END("CSrv::SrvInserir()");
			return 3;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSrv::SrvInserir()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSrv::SrvEditar(DOMNode*dnode,XMLGen*xml_g,
				    char* cLogUser)
{
	ULOG_START("CSrv::SrvEditar()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;
		char* pcid;
		char* pcnm;
		int   iAcumulador;
	EXEC SQL END DECLARE SECTION;
	try
	{
		//Se o ID ou DESCRICAO nao existir entao retornar com codigo de erro
		if( ( pcid = oSafePointer.getTag(dnode,"idServidor",0) ) == NULL )
		{
			ULOG_END("CSrv::SrvEditar()");
			return 1;
		}
	
		if( ( pcnm = oSafePointer.getTag(dnode,"dsServidor",0) ) == NULL )
		{
			ULOG_END("CSrv::SrvEditar()");
			return 2;
		}
	
		sqlca.sqlcode=0;
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	
		//Conta os casos de ja existentes de descricao 
		EXEC SQL
			SELECT
				COUNT(idHost) 
			INTO
				:iAcumulador
			FROM
				acesso.Host
			WHERE 
				UPPER(nmHost) = UPPER(:pcnm)
			AND
				IDHOST <> :pcid;
			

		//Se nao houver o caso desta descricao entao pode Inserir
		if (iAcumulador==0) 
		{
			//Altera a descricao do Host
			EXEC SQL 
				UPDATE
					acesso.Host 
				SET 
					NMHOST = :pcnm,
					IDUSUARIOALTERACAO = :cLogUserOra, 
					DTULTIMAALTERACAO  = SYSDATE
				WHERE
					idHost = :pcid;

			setIdHost( pcid );
			setDsHost( pcnm );
		}
		else
		{
			ULOG_END("CSrv::SrvEditar()");
			return 3;	
		}
		//Se houver erro na operacao de Update desfazer tudo e retornar com erro
		if(sqlca.sqlcode)
		{
			ULOG_END("CSrv::SrvEditar()");
			return 4; 
		}
	}
	catch(...)
	{
		throw;
	}
	
	ULOG_END("CSrv::SrvEditar()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSrv::SrvRemover(DOMNode*dnode, XMLGen*xml_g,
				     char* cLogUser)
{
	ULOG_START("CSrv::SrvRemover()");
	
	// Declarar Estruturas
	struct sqlca sqlca; 
	
	// Declarar Objetos
	CSafePointer oSafePointer;

	// Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		int idHost;
	EXEC SQL END DECLARE SECTION;

	//Declara variaveis auxiliares
	char *pc;
	//Se o ID nao for numerico entao retornar com codigo de erro
	pc = oSafePointer.getTag(dnode,"idServidor",0);
	if ( pc == NULL )
	{
		ULOG_END("CSrv::SrvRemover()");
		return 3;
	}

	//Le o ID
	if ( ( idHost = atoi( pc ) ) == 0 )
	{
		ULOG_END("CSrv::SrvRemover()");
		return 2;
	}

	sqlca.sqlcode=0;

	EXEC SQL WHENEVER SQLERROR GOTO ErrorF;

	EXEC SQL
	DELETE FROM acesso.Host 
	WHERE idHost = :idHost;

	if(sqlca.sqlcode)
	{
		ULOG_END("CSrv::SrvRemover()");
		return 4; 
	}
    ULOG_END("CSrv::SrvRemover()");
	return 0;

// Tratamento de Exception
ErrorF:
	ULOG_END("CSrv::SrvRemover()");
	if( sqlca.sqlcode == -2292 )
		return 5;
	else
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CSrv::SrvLista(char* cdsServidor, XMLGen*xml_g)
{
	ULOG_START("CSrv::SrvLista()");
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 
		char cAuxdsServidor[255+1];
		struct Tstruct {
			int idHost; 
			char cnmHost[256];
		} tstruct;

		struct Tstructindicator {
			short sidHost, snmHost;
		} tstructindicator;

	EXEC SQL END DECLARE SECTION;
	try
	{
			
		memset( &tstruct, 0, sizeof(Tstruct));
		memset( &tstructindicator, 0, sizeof(Tstructindicator));
		memset( &cAuxdsServidor, 0, sizeof(cAuxdsServidor));
		sqlca.sqlcode=0;
		
		if( strlennull( cdsServidor ) <= 0 )
			strcpy( cAuxdsServidor, "-1" );
		else
			sprintf( cAuxdsServidor, "%s%%",cdsServidor );

		EXEC SQL 
			DECLARE 
				CusorSrvLista CURSOR FOR
			SELECT 
				IDHOST
			   ,NMHOST 
			FROM 
				ACESSO.HOST HOST
			WHERE
				UPPER(HOST.NMHOST) LIKE UPPER(:cAuxdsServidor)
			OR
				:cAuxdsServidor = '-1'
			ORDER BY 
				UPPER(NMHOST);
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL OPEN CusorSrvLista;
		
		if(sqlca.sqlcode)
		{
			ULOG_END("CSrv::SrvLista()");
			return 4;
		}
		else
		{
			xml_g->createTag("ListaServidoresVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				for(;;) {
				EXEC SQL FETCH CusorSrvLista INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("SistemaServidorExistenteUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idServidor",tstruct.idHost);
				xml_g->addItem("dsServidor",RTrim(tstruct.cnmHost));
				xml_g->closeTag();
			}
			xml_g->closeTag();
			EXEC SQL CLOSE CusorSrvLista;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSrv::SrvLista()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}


int CSrv::SrvListaId(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CSrv::SrvListaId()");
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;

		struct Tstruct {
			int idHost; 
			char cnmHost[256];
		} tstruct;

		struct Tstructindicator {
			short sidHost, snmHost;
		} tstructindicator;

		int iAuxiliar;

	EXEC SQL END DECLARE SECTION;

	char *pc;
	try
	{
		memset( &tstruct, 0, sizeof(Tstruct));
		memset( &tstructindicator, 0, sizeof(Tstructindicator));
	
		//Se o ID nao for numerico entao retornar com codigo de erro
		if ( ( pc = oSafePointer.getTag(dnode,"idServidor",0) ) == NULL ) {
			ULOG_END("CSrv::SrvListaId()");
			return 2;
		}
	
		//Se o ID estiver vazio entao retornar com codigo de erro
		if ( strlen( pc ) == 0 ) {
			ULOG_END("CSrv::SrvListaId()");
			return 3;
		}
	
		//Le a descricao de Host
		iAuxiliar = atoi( pc );
	
		sqlca.sqlcode=0;
	
		EXEC SQL 
			DECLARE 
				tcursor1 CURSOR FOR
			SELECT 
				IDHOST, 
				NMHOST 
			FROM 
				ACESSO.HOST
			WHERE 
				IDHOST = :iAuxiliar
			ORDER BY 
				UPPER(NMHOST);
	
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL OPEN tcursor1;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CSrv::SrvListaId()");
			return 4;
		}
		else
		{
			xml_g->createTag("ListaServidoresVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			EXEC SQL FETCH tcursor1 INTO :tstruct INDICATOR :tstructindicator;
			xml_g->createTag("SistemaServidorExistenteUsuarioVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			xml_g->addItem("idServidor",tstruct.idHost);
			xml_g->addItem("dsServidor",RTrim(tstruct.cnmHost));
			xml_g->closeTag();
			xml_g->closeTag();
			EXEC SQL CLOSE tcursor1;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSrv::SrvListaId()");
	return 0;


// Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSrv::SrvListaId(char* cidHost, XMLGen*xml_g)
{
	ULOG_START("CSrv::SrvListaId()");
	//Declarar Estruturas
	struct sqlca sqlca; 
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char *cAuxidHost = cidHost;
		struct 
		{
			VARCHAR stidHost[21+1]; 
			VARCHAR stnmHost[255+1];
		} stRegistro;

		struct Tstructindicator 
		{
			short sidHost;
			short snmHost;
		} stIndicator;
	EXEC SQL END DECLARE SECTION;

	try
	{
		memset( &stRegistro, 0, sizeof(stRegistro));
	
		sqlca.sqlcode=0;
	
		EXEC SQL 
			SELECT 
				IDHOST, 
				NMHOST
			INTO
				:stRegistro:stIndicator
			FROM 
				ACESSO.HOST
			WHERE 
				IDHOST = :cAuxidHost
			ORDER BY 
				UPPER(NMHOST);
	
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CSrv::SrvListaId()");
			return 4;
		}
		else
		{
			xml_g->createTag("ListaServidoresVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			xml_g->createTag("SistemaServidorExistenteUsuarioVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			xml_g->addItem("idServidor",(char*)stRegistro.stidHost.arr);
			xml_g->addItem("dsServidor",(char*)stRegistro.stnmHost.arr);
			xml_g->closeTag();
			xml_g->closeTag();
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSrv::SrvListaId()");
	return 0;


// Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSrv::SrvListaPar(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CSrv::SrvListaPar()");
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 

		struct Tstruct {
			int idHost; 
			char cnmHost[256];
		} tstruct;

		struct Tstructindicator {
			short sidHost, snmHost;
		} tstructindicator;

		char vcLike[256];

	EXEC SQL END DECLARE SECTION;

	memset( &tstruct, 0, sizeof(Tstruct));
	memset( &tstructindicator, 0, sizeof(Tstructindicator));

	char *pc = oSafePointer.getTag(dnode,"dsServidor",0);
	if ( pc == NULL ) {
		strcpy( tstruct.cnmHost, "" );
	} else {	
		strcpy( tstruct.cnmHost, pc);
	}
	
	sqlca.sqlcode=0;
	
	if ( strlen(tstruct.cnmHost)==0 ) {
		SrvListaPar(dnode,xml_g);
	} else {
		sprintf( vcLike, "%s%%", tstruct.cnmHost ); 
	
		EXEC SQL 
			DECLARE 
				tsqlcursor CURSOR FOR
			SELECT 
				IDHOST, 
				NMHOST 
			FROM 
				ACESSO.HOST
			WHERE 
				UPPER(NMHOST) LIKE UPPER(:vcLike)
			ORDER BY 
				UPPER(NMHOST);

		EXEC SQL OPEN tsqlcursor;
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		
		if(sqlca.sqlcode)
		{
			ULOG_END("CSrv::SrvListaPar()");
			return 4;
		}
		else
		{
			xml_g->createTag("ListaServidoresVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			for(;;) {
				EXEC SQL FETCH tsqlcursor INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("SistemaServidorExistenteUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idServidor",tstruct.idHost);
				xml_g->addItem("dsServidor",RTrim(tstruct.cnmHost));
				xml_g->closeTag();
			}
			xml_g->closeTag();
			EXEC SQL CLOSE tsqlcursor;
			ULOG_END("CSrv::SrvListaPar()");
			return 0;
		}
	}

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

void CSrv::setIdHost( char* pzcidHost )
{
	ULOG_START("CSrv::setIdHost()");
	if( strlennull( pzcidHost ) > 0 )
	{
		memset( cidHost, 0, sizeof( cidHost ) );
		if( strlennull( pzcidHost ) > 21 )
			strcpy( cidHost, pzcidHost );
		else
			strncpy( cidHost, &pzcidHost[0], 21 );
	}
	ULOG_END("CSrv::setIdHost()");
}

void CSrv::setDsHost( char* pzcdsHost )
{
	ULOG_START("CSrv::setDsHost()");	
	if( strlennull( pzcdsHost ) > 0 )
	{
		memset( cdsHost, 0, sizeof( cdsHost ) );
		if( strlennull( pzcdsHost ) > 255 )
			strcpy( cdsHost, pzcdsHost );
		else
			strncpy( cdsHost, &pzcdsHost[0], 255 );
	}
	ULOG_END("CSrv::setDsHost()");	
}
