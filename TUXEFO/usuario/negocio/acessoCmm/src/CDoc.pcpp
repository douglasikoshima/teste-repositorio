#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "CDoc.h"

CDocumento::CDocumento()
{
}

CDocumento::~CDocumento()
{
}

int CDocumento::ListIdUser( char* cidUsuario )
{
	ULOG_START(" CDocumento::ListIdUser(  )");
	
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidOra = cidUsuario;
		struct
		{
			VARCHAR stidDocumento[21+1];
			VARCHAR stcdCpfCnpjBase[255+1];
			VARCHAR stcdCnpjFilial[255+1];
			VARCHAR stcdCpfCnpjControle[255+1];
			VARCHAR stnrDocumento[255+1];
			VARCHAR stsgOrgaoExpedidor[255+1];
			VARCHAR stdtEmissao[12+1];
			VARCHAR stidPais[21+1];
			VARCHAR stsgPais[255+1];
			VARCHAR stnmPais[255+1];
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stidTipoDocumento[21+1];
			VARCHAR stsgTipoDocumento[255+1];
			VARCHAR stdsTipoDocumento[255+1];
		} stDocumentoRegistro;
		struct
		{
			short iidDocumento;
			short icdCpfCnpjBase;
			short icdCnpjFilial;
			short icdCpfCnpjControle;
			short inrDocumento;
			short isgOrgaoExpedidor;
			short idtEmissao;
			short iidPais;
			short isgPais;
			short inmPais;
			short iidUF;
			short isgUF;
			short inmUF;
			short iidTipoDocumento;
			short isgTipoDocumento;
			short idsTipoDocumento;
		} stDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListIdUser;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE CursorDocumentoIdUser CURSOR FOR
				SELECT 
				     DOCUMENTO.IDDOCUMENTO
				    ,DOCUMENTO.CDCPFCNPJBASE
				    ,DOCUMENTO.CDCNPJFILIAL
				    ,DOCUMENTO.CDCPFCNPJCONTROLE
				    ,DOCUMENTO.NRDOCUMENTO
				    ,DOCUMENTO.SGORGAOEXPEDIDOR
				    ,DOCUMENTO.DTEMISSAO
				    ,PAIS.IDPAIS
				    ,PAIS.SGPAIS
				    ,PAIS.NMPAIS
				    ,UF.IDUF
				    ,UF.SGUF
				    ,UF.NMUF
				    ,TIPODOCUMENTO.IDTIPODOCUMENTO
				    ,TIPODOCUMENTO.SGTIPODOCUMENTO
				    ,TIPODOCUMENTO.DSTIPODOCUMENTO
				FROM 
				    CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
				    CUSTOMER.DOCUMENTO DOCUMENTO,
				    APOIO.UF UF,
				    APOIO.TIPODOCUMENTO TIPODOCUMENTO,
				    APOIO.PAIS PAIS
				WHERE PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
				AND   DOCUMENTO.IDUF = UF.IDUF
				AND   DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
				AND   DOCUMENTO.IDPAIS = PAIS.IDPAIS
				AND   PESSOADOCUMENTO.IDPESSOA = :cidOra;
	
		EXEC SQL OPEN CursorDocumentoIdUser;
	
		if(sqlca.sqlcode)
		{
		    ULOG_END(" CDocumento::ListIdUser( )");
		    return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stDocumentoRegistro, 0, sizeof(stDocumentoRegistro) );
				EXEC SQL FETCH CursorDocumentoIdUser INTO :stDocumentoRegistro:stDocumentoIndicator;
	
				Add( (char*)stDocumentoRegistro.stidDocumento.arr
				    ,(char*)stDocumentoRegistro.stcdCpfCnpjBase.arr
				    ,(char*)stDocumentoRegistro.stcdCnpjFilial.arr
				    ,(char*)stDocumentoRegistro.stcdCpfCnpjControle.arr
				    ,(char*)stDocumentoRegistro.stnrDocumento.arr
				    ,(char*)stDocumentoRegistro.stsgOrgaoExpedidor.arr
				    ,(char*)stDocumentoRegistro.stdtEmissao.arr
				    ,(char*)stDocumentoRegistro.stidPais.arr
				    ,(char*)stDocumentoRegistro.stsgPais.arr
				    ,(char*)stDocumentoRegistro.stnmPais.arr
				    ,(char*)stDocumentoRegistro.stidUF.arr 
				    ,(char*)stDocumentoRegistro.stsgUF.arr 
				    ,(char*)stDocumentoRegistro.stnmUF.arr 
				    ,(char*)stDocumentoRegistro.stidTipoDocumento.arr 
				    ,(char*)stDocumentoRegistro.stsgTipoDocumento.arr 
				    ,(char*)stDocumentoRegistro.stdsTipoDocumento.arr 
				   );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorDocumentoIdUser;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CDocumento::ListIdUser( )");
	return iCont;

GotoListIdUser:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CDocumento::ListId( char* cidDocumento )
{
	ULOG_START(" CDocumento::ListId(  )");
	
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidDocumento = cidDocumento;
		struct
		{
			VARCHAR stidDocumento[21+1];
			VARCHAR stcdCpfCnpjBase[255+1];
			VARCHAR stcdCnpjFilial[255+1];
			VARCHAR stcdCpfCnpjControle[255+1];
			VARCHAR stnrDocumento[255+1];
			VARCHAR stsgOrgaoExpedidor[255+1];
			VARCHAR stdtEmissao[12+1];
			VARCHAR stidPais[21+1];
			VARCHAR stsgPais[255+1];
			VARCHAR stnmPais[255+1];
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stidTipoDocumento[21+1];
			VARCHAR stsgTipoDocumento[255+1];
			VARCHAR stdsTipoDocumento[255+1];
		} stDocumentoRegistro;
		struct
		{
			short iidDocumento;
			short icdCpfCnpjBase;
			short icdCnpjFilial;
			short icdCpfCnpjControle;
			short inrDocumento;
			short isgOrgaoExpedidor;
			short idtEmissao;
			short iidPais;
			short isgPais;
			short inmPais;
			short iidUF;
			short isgUF;
			short inmUF;
			short iidTipoDocumento;
			short isgTipoDocumento;
			short idsTipoDocumento;
		} stDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE CursorDocumentoId CURSOR FOR
				SELECT 
				     DOCUMENTO.IDDOCUMENTO
				    ,DOCUMENTO.CDCPFCNPJBASE
				    ,DOCUMENTO.CDCNPJFILIAL
				    ,DOCUMENTO.CDCPFCNPJCONTROLE
				    ,DOCUMENTO.NRDOCUMENTO
				    ,DOCUMENTO.SGORGAOEXPEDIDOR
				    ,DOCUMENTO.DTEMISSAO
				    ,PAIS.IDPAIS
				    ,PAIS.SGPAIS
				    ,PAIS.NMPAIS
				    ,UF.IDUF
				    ,UF.SGUF
				    ,UF.NMUF
				    ,TIPODOCUMENTO.IDTIPODOCUMENTO
				    ,TIPODOCUMENTO.SGTIPODOCUMENTO
				    ,TIPODOCUMENTO.DSTIPODOCUMENTO
				FROM 
				    CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
				    CUSTOMER.DOCUMENTO DOCUMENTO,
				    APOIO.UF UF,
				    APOIO.TIPODOCUMENTO TIPODOCUMENTO,
				    APOIO.PAIS PAIS
				WHERE PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
				AND   DOCUMENTO.IDUF = UF.IDUF
				AND   DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
				AND   DOCUMENTO.IDPAIS = PAIS.IDPAIS
				AND   DOCUMENTO.IDDOCUMENTO = :cAuxidDocumento;
	
		EXEC SQL OPEN CursorDocumentoId;
	
		if(sqlca.sqlcode)
		{
		    ULOG_END(" CDocumento::ListId( )");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stDocumentoRegistro, 0, sizeof(stDocumentoRegistro) );
				EXEC SQL FETCH CursorDocumentoId INTO :stDocumentoRegistro:stDocumentoIndicator;
	
				Add( (char*)stDocumentoRegistro.stidDocumento.arr
				    ,(char*)stDocumentoRegistro.stcdCpfCnpjBase.arr
				    ,(char*)stDocumentoRegistro.stcdCnpjFilial.arr
				    ,(char*)stDocumentoRegistro.stcdCpfCnpjControle.arr
				    ,(char*)stDocumentoRegistro.stnrDocumento.arr
				    ,(char*)stDocumentoRegistro.stsgOrgaoExpedidor.arr
				    ,(char*)stDocumentoRegistro.stdtEmissao.arr
				    ,(char*)stDocumentoRegistro.stidPais.arr
				    ,(char*)stDocumentoRegistro.stsgPais.arr
				    ,(char*)stDocumentoRegistro.stnmPais.arr
				    ,(char*)stDocumentoRegistro.stidUF.arr 
				    ,(char*)stDocumentoRegistro.stsgUF.arr 
				    ,(char*)stDocumentoRegistro.stnmUF.arr 
				    ,(char*)stDocumentoRegistro.stidTipoDocumento.arr 
				    ,(char*)stDocumentoRegistro.stsgTipoDocumento.arr 
				    ,(char*)stDocumentoRegistro.stdsTipoDocumento.arr 
				   );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorDocumentoId;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END(" CDocumento::ListId(  )");
	return iCont;

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CDocumento::ListAll( void )
{
    ULOG_START("CDocumento::ListAll(  )");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidDocumento[21+1];
			VARCHAR stcdCpfCnpjBase[255+1];
			VARCHAR stcdCnpjFilial[255+1];
			VARCHAR stcdCpfCnpjControle[255+1];
			VARCHAR stnrDocumento[255+1];
			VARCHAR stsgOrgaoExpedidor[255+1];
			VARCHAR stdtEmissao[12+1];
			VARCHAR stidPais[21+1];
			VARCHAR stsgPais[255+1];
			VARCHAR stnmPais[255+1];
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stidTipoDocumento[21+1];
			VARCHAR stsgTipoDocumento[255+1];
			VARCHAR stdsTipoDocumento[255+1];
		} stDocumentoRegistro;
		struct
		{
			short iidDocumento;
			short icdCpfCnpjBase;
			short icdCnpjFilial;
			short icdCpfCnpjControle;
			short inrDocumento;
			short isgOrgaoExpedidor;
			short idtEmissao;
			short iidPais;
			short isgPais;
			short inmPais;
			short iidUF;
			short isgUF;
			short inmUF;
			short iidTipoDocumento;
			short isgTipoDocumento;
			short idsTipoDocumento;
		} stDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE CursorDocumentoAll CURSOR FOR
				SELECT 
				     DOCUMENTO.IDDOCUMENTO
				    ,DOCUMENTO.CDCPFCNPJBASE
				    ,DOCUMENTO.CDCNPJFILIAL
				    ,DOCUMENTO.CDCPFCNPJCONTROLE
				    ,DOCUMENTO.NRDOCUMENTO
				    ,DOCUMENTO.SGORGAOEXPEDIDOR
				    ,DOCUMENTO.DTEMISSAO
				    ,PAIS.IDPAIS
				    ,PAIS.SGPAIS
				    ,PAIS.NMPAIS
				    ,UF.IDUF
				    ,UF.SGUF
				    ,UF.NMUF
				    ,TIPODOCUMENTO.IDTIPODOCUMENTO
				    ,TIPODOCUMENTO.SGTIPODOCUMENTO
				    ,TIPODOCUMENTO.DSTIPODOCUMENTO
				FROM 
				    CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
				    CUSTOMER.DOCUMENTO DOCUMENTO,
				    APOIO.UF UF,
				    APOIO.TIPODOCUMENTO TIPODOCUMENTO,
				    APOIO.PAIS PAIS
				WHERE PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
				AND   DOCUMENTO.IDUF = UF.IDUF
				AND   DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
				AND   DOCUMENTO.IDPAIS = PAIS.IDPAIS
				AND   DOCUMENTO.IDDOCUMENTO > 0;
				 
				 
	
		EXEC SQL OPEN CursorDocumentoAll;
	
		if(sqlca.sqlcode)
		{
		    ULOG_END(" CDocumento::ListAll(  )");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stDocumentoRegistro, 0, sizeof(stDocumentoRegistro) );
				EXEC SQL FETCH CursorDocumentoAll INTO :stDocumentoRegistro:stDocumentoIndicator;
	
				Add( (char*)stDocumentoRegistro.stidDocumento.arr
				    ,(char*)stDocumentoRegistro.stcdCpfCnpjBase.arr
				    ,(char*)stDocumentoRegistro.stcdCnpjFilial.arr
				    ,(char*)stDocumentoRegistro.stcdCpfCnpjControle.arr
				    ,(char*)stDocumentoRegistro.stnrDocumento.arr
				    ,(char*)stDocumentoRegistro.stsgOrgaoExpedidor.arr
				    ,(char*)stDocumentoRegistro.stdtEmissao.arr
				    ,(char*)stDocumentoRegistro.stidPais.arr
				    ,(char*)stDocumentoRegistro.stsgPais.arr
				    ,(char*)stDocumentoRegistro.stnmPais.arr
				    ,(char*)stDocumentoRegistro.stidUF.arr 
				    ,(char*)stDocumentoRegistro.stsgUF.arr 
				    ,(char*)stDocumentoRegistro.stnmUF.arr 
				    ,(char*)stDocumentoRegistro.stidTipoDocumento.arr 
				    ,(char*)stDocumentoRegistro.stsgTipoDocumento.arr 
				    ,(char*)stDocumentoRegistro.stdsTipoDocumento.arr 
				   );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorDocumentoAll;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END(" CDocumento::ListAll(  )");
	return iCont;

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);


}

int CDocumento::ListDocSiglaTipo( char* cnrDoc, char* csgTipo )
{
	ULOG_START(" CDocumento::ListDocSiglaTipo(  )");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char cnrDocumento[255+1];
		char* csgTipoDocumento = csgTipo;
		struct
		{
			VARCHAR stidDocumento[21+1];
			VARCHAR stcdCpfCnpjBase[255+1];
			VARCHAR stcdCnpjFilial[255+1];
			VARCHAR stcdCpfCnpjControle[255+1];
			VARCHAR stnrDocumento[255+1];
			VARCHAR stsgOrgaoExpedidor[255+1];
			VARCHAR stdtEmissao[12+1];
			VARCHAR stidPais[21+1];
			VARCHAR stsgPais[255+1];
			VARCHAR stnmPais[255+1];
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stidTipoDocumento[21+1];
			VARCHAR stsgTipoDocumento[255+1];
			VARCHAR stdsTipoDocumento[255+1];
		} stDocumentoRegistro;
		struct
		{
			short iidDocumento;
			short icdCpfCnpjBase;
			short icdCnpjFilial;
			short icdCpfCnpjControle;
			short inrDocumento;
			short isgOrgaoExpedidor;
			short idtEmissao;
			short iidPais;
			short isgPais;
			short inmPais;
			short iidUF;
			short isgUF;
			short inmUF;
			short iidTipoDocumento;
			short isgTipoDocumento;
			short idsTipoDocumento;
		} stDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraDocumento();
		memset( &cnrDocumento, 0, sizeof(cnrDocumento) );
		
		if( strlennull( cnrDoc ) <= 0 )
		{
		     ULOG_END(" CDocumento::ListDocSiglaTipo(  )");
			 return 0;
		}
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListDoc;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE CursorListDocTipo CURSOR FOR
            SELECT 
			     DOCUMENTO.IDDOCUMENTO
			    ,DOCUMENTO.CDCPFCNPJBASE
			    ,DOCUMENTO.CDCNPJFILIAL
			    ,DOCUMENTO.CDCPFCNPJCONTROLE
			    ,DOCUMENTO.NRDOCUMENTO
			    ,DOCUMENTO.SGORGAOEXPEDIDOR
			    ,DOCUMENTO.DTEMISSAO
			    ,PAIS.IDPAIS
			    ,PAIS.SGPAIS
			    ,PAIS.NMPAIS
			    ,UF.IDUF
			    ,UF.SGUF
			    ,UF.NMUF
			    ,TIPODOCUMENTO.IDTIPODOCUMENTO
			    ,TIPODOCUMENTO.SGTIPODOCUMENTO
			    ,TIPODOCUMENTO.DSTIPODOCUMENTO
			FROM 
			    CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
			    CUSTOMER.DOCUMENTO DOCUMENTO,
			    APOIO.UF UF,
			    APOIO.TIPODOCUMENTO TIPODOCUMENTO,
			    APOIO.PAIS PAIS
			WHERE PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
			AND   DOCUMENTO.IDUF = UF.IDUF
			AND   DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
			AND   DOCUMENTO.IDPAIS = PAIS.IDPAIS
			AND TRIM(DOCUMENTO.NRDOCUMENTO) = TRIM(:cnrDocumento)
			AND TIPODOCUMENTO.SGTIPODOCUMENTO = :csgTipoDocumento;                  
                   
                   
           	
		EXEC SQL OPEN CursorListDocTipo;
	
		if(sqlca.sqlcode)
		{
		    ULOG_END(" CDocumento::ListDocSiglaTipo(  )");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stDocumentoRegistro, 0, sizeof(stDocumentoRegistro) );
				EXEC SQL FETCH CursorListDocTipo INTO :stDocumentoRegistro:stDocumentoIndicator;
	
				Add( (char*)stDocumentoRegistro.stidDocumento.arr
				    ,(char*)stDocumentoRegistro.stcdCpfCnpjBase.arr
				    ,(char*)stDocumentoRegistro.stcdCnpjFilial.arr
				    ,(char*)stDocumentoRegistro.stcdCpfCnpjControle.arr
				    ,(char*)stDocumentoRegistro.stnrDocumento.arr
				    ,(char*)stDocumentoRegistro.stsgOrgaoExpedidor.arr
				    ,(char*)stDocumentoRegistro.stdtEmissao.arr
				    ,(char*)stDocumentoRegistro.stidPais.arr
				    ,(char*)stDocumentoRegistro.stsgPais.arr
				    ,(char*)stDocumentoRegistro.stnmPais.arr
				    ,(char*)stDocumentoRegistro.stidUF.arr 
				    ,(char*)stDocumentoRegistro.stsgUF.arr 
				    ,(char*)stDocumentoRegistro.stnmUF.arr 
				    ,(char*)stDocumentoRegistro.stidTipoDocumento.arr 
				    ,(char*)stDocumentoRegistro.stsgTipoDocumento.arr 
				    ,(char*)stDocumentoRegistro.stdsTipoDocumento.arr 
				   );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorListDocTipo;
		}
	}
	catch(...)
	{
		throw;
	}
	
	ULOG_END(" CDocumento::ListDocSiglaTipo(  )");
	return iCont;

GotoListDoc:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CDocumento::ListDocIdTipo( char* cnrDoc, char* cidTipo )
{
	ULOG_START(" CDocumento::ListDocIdTipo(  )");
	
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cnrDocumento = cnrDoc;
		char* cidTipoDocumento = cidTipo;
		struct
		{
			VARCHAR stidDocumento[21+1];
			VARCHAR stcdCpfCnpjBase[255+1];
			VARCHAR stcdCnpjFilial[255+1];
			VARCHAR stcdCpfCnpjControle[255+1];
			VARCHAR stnrDocumento[255+1];
			VARCHAR stsgOrgaoExpedidor[255+1];
			VARCHAR stdtEmissao[12+1];
			VARCHAR stidPais[21+1];
			VARCHAR stsgPais[255+1];
			VARCHAR stnmPais[255+1];
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stidTipoDocumento[21+1];
			VARCHAR stsgTipoDocumento[255+1];
			VARCHAR stdsTipoDocumento[255+1];
		} stDocumentoRegistro;
		struct
		{
			short iidDocumento;
			short icdCpfCnpjBase;
			short icdCnpjFilial;
			short icdCpfCnpjControle;
			short inrDocumento;
			short isgOrgaoExpedidor;
			short idtEmissao;
			short iidPais;
			short isgPais;
			short inmPais;
			short iidUF;
			short isgUF;
			short inmUF;
			short iidTipoDocumento;
			short isgTipoDocumento;
			short idsTipoDocumento;
		} stDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraDocumento();
		if( strlennull( cnrDoc ) <= 0 )
		{
		    ULOG_END(" CDocumento::ListDocIdTipo(  )");
			return 0;
		}
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListIdDoc;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE CursorListDocIdTipo CURSOR FOR
		SELECT 
			 DOCUMENTO.IDDOCUMENTO
			,DOCUMENTO.CDCPFCNPJBASE
			,DOCUMENTO.CDCNPJFILIAL
			,DOCUMENTO.CDCPFCNPJCONTROLE
			,DOCUMENTO.NRDOCUMENTO
			,DOCUMENTO.SGORGAOEXPEDIDOR
			,DOCUMENTO.DTEMISSAO
			,PAIS.IDPAIS
			,PAIS.SGPAIS
			,PAIS.NMPAIS
			,UF.IDUF
			,UF.SGUF
			,UF.NMUF
			,TIPODOCUMENTO.IDTIPODOCUMENTO
			,TIPODOCUMENTO.SGTIPODOCUMENTO
			,TIPODOCUMENTO.DSTIPODOCUMENTO
		FROM 
			 CUSTOMER.DOCUMENTO DOCUMENTO,
			 APOIO.UF UF,
			 APOIO.PAIS PAIS,
			 APOIO.TIPODOCUMENTO TIPODOCUMENTO
		WHERE 
		   DOCUMENTO.IDUF = UF.IDUF
		AND
		   DOCUMENTO.IDPAIS = PAIS.IDPAIS
		AND
		   DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
		AND
			UPPER(DOCUMENTO.NRDOCUMENTO) = UPPER(TRIM(:cnrDocumento))
		AND 
			DOCUMENTO.IDTIPODOCUMENTO = :cidTipoDocumento;
           	
		EXEC SQL OPEN CursorListDocIdTipo;
	
		if(sqlca.sqlcode)
		{
		    ULOG_END(" CDocumento::ListDocIdTipo(  )");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stDocumentoRegistro, 0, sizeof(stDocumentoRegistro) );
				EXEC SQL FETCH CursorListDocIdTipo INTO :stDocumentoRegistro:stDocumentoIndicator;
	
				Add( (char*)stDocumentoRegistro.stidDocumento.arr
				    ,(char*)stDocumentoRegistro.stcdCpfCnpjBase.arr
				    ,(char*)stDocumentoRegistro.stcdCnpjFilial.arr
				    ,(char*)stDocumentoRegistro.stcdCpfCnpjControle.arr
				    ,(char*)stDocumentoRegistro.stnrDocumento.arr
				    ,(char*)stDocumentoRegistro.stsgOrgaoExpedidor.arr
				    ,(char*)stDocumentoRegistro.stdtEmissao.arr
				    ,(char*)stDocumentoRegistro.stidPais.arr
				    ,(char*)stDocumentoRegistro.stsgPais.arr
				    ,(char*)stDocumentoRegistro.stnmPais.arr
				    ,(char*)stDocumentoRegistro.stidUF.arr 
				    ,(char*)stDocumentoRegistro.stsgUF.arr 
				    ,(char*)stDocumentoRegistro.stnmUF.arr 
				    ,(char*)stDocumentoRegistro.stidTipoDocumento.arr 
				    ,(char*)stDocumentoRegistro.stsgTipoDocumento.arr 
				    ,(char*)stDocumentoRegistro.stdsTipoDocumento.arr 
				   );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorListDocIdTipo;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END(" CDocumento::ListDocIdTipo(  )");
	return iCont;

GotoListIdDoc:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CDocumento::ListDoc( char* cnrDoc )
{
	ULOG_START(" CDocumento::ListDoc(  )");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cnrDocumento = cnrDoc;
		struct
		{
			VARCHAR stidDocumento[21+1];
			VARCHAR stcdCpfCnpjBase[255+1];
			VARCHAR stcdCnpjFilial[255+1];
			VARCHAR stcdCpfCnpjControle[255+1];
			VARCHAR stnrDocumento[255+1];
			VARCHAR stsgOrgaoExpedidor[255+1];
			VARCHAR stdtEmissao[12+1];
			VARCHAR stidPais[21+1];
			VARCHAR stsgPais[255+1];
			VARCHAR stnmPais[255+1];
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stidTipoDocumento[21+1];
			VARCHAR stsgTipoDocumento[255+1];
			VARCHAR stdsTipoDocumento[255+1];
		} stDocumentoRegistro;
		struct
		{
			short iidDocumento;
			short icdCpfCnpjBase;
			short icdCnpjFilial;
			short icdCpfCnpjControle;
			short inrDocumento;
			short isgOrgaoExpedidor;
			short idtEmissao;
			short iidPais;
			short isgPais;
			short inmPais;
			short iidUF;
			short isgUF;
			short inmUF;
			short iidTipoDocumento;
			short isgTipoDocumento;
			short idsTipoDocumento;
		} stDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraDocumento();
		memset( &cnrDocumento, 0, sizeof(cnrDocumento) );
		
		if( strlennull( cnrDoc ) <= 0 )
		{
		    ULOG_END(" CDocumento::ListDoc( )");
			return 0;
		}
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListDoc;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE CursorListDoc CURSOR FOR
                SELECT 
				     DOCUMENTO.IDDOCUMENTO
				    ,DOCUMENTO.CDCPFCNPJBASE
				    ,DOCUMENTO.CDCNPJFILIAL
				    ,DOCUMENTO.CDCPFCNPJCONTROLE
				    ,DOCUMENTO.NRDOCUMENTO
				    ,DOCUMENTO.SGORGAOEXPEDIDOR
				    ,DOCUMENTO.DTEMISSAO
				    ,PAIS.IDPAIS
				    ,PAIS.SGPAIS
				    ,PAIS.NMPAIS
				    ,UF.IDUF
				    ,UF.SGUF
				    ,UF.NMUF
				    ,TIPODOCUMENTO.IDTIPODOCUMENTO
				    ,TIPODOCUMENTO.SGTIPODOCUMENTO
				    ,TIPODOCUMENTO.DSTIPODOCUMENTO
				FROM 
				    CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
				    CUSTOMER.DOCUMENTO DOCUMENTO,
				    APOIO.UF UF,
				    APOIO.TIPODOCUMENTO TIPODOCUMENTO,
				    APOIO.PAIS PAIS
				WHERE PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
				AND   DOCUMENTO.IDUF = UF.IDUF
				AND   DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
				AND   DOCUMENTO.IDPAIS = PAIS.IDPAIS
				AND TRIM(DOCUMENTO.NRDOCUMENTO) = TRIM(:cnrDocumento);

                 
           	
		EXEC SQL OPEN CursorListDoc;
	
		if(sqlca.sqlcode)
	    {
		    ULOG_END(" CDocumento::ListDoc(  )");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stDocumentoRegistro, 0, sizeof(stDocumentoRegistro) );
				EXEC SQL FETCH CursorListDoc INTO :stDocumentoRegistro:stDocumentoIndicator;
	
				Add( (char*)stDocumentoRegistro.stidDocumento.arr
				    ,(char*)stDocumentoRegistro.stcdCpfCnpjBase.arr
				    ,(char*)stDocumentoRegistro.stcdCnpjFilial.arr
				    ,(char*)stDocumentoRegistro.stcdCpfCnpjControle.arr
				    ,(char*)stDocumentoRegistro.stnrDocumento.arr
				    ,(char*)stDocumentoRegistro.stsgOrgaoExpedidor.arr
				    ,(char*)stDocumentoRegistro.stdtEmissao.arr
				    ,(char*)stDocumentoRegistro.stidPais.arr
				    ,(char*)stDocumentoRegistro.stsgPais.arr
				    ,(char*)stDocumentoRegistro.stnmPais.arr
				    ,(char*)stDocumentoRegistro.stidUF.arr 
				    ,(char*)stDocumentoRegistro.stsgUF.arr 
				    ,(char*)stDocumentoRegistro.stnmUF.arr 
				    ,(char*)stDocumentoRegistro.stidTipoDocumento.arr 
				    ,(char*)stDocumentoRegistro.stsgTipoDocumento.arr 
				    ,(char*)stDocumentoRegistro.stdsTipoDocumento.arr 
				   );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorListDoc;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END(" CDocumento::ListDoc(  )");
	return iCont;

GotoListDoc:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CDocumento::ListDocPorIdPesssoa( char* cidPessoa, char* cidTipo )
{
	ULOG_START(" CDocumento::ListDocPorIdPesssoa(  )");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidPessoaAux = cidPessoa;
		char* cidTipoDocumento = cidTipo;
		struct
		{
			VARCHAR stidDocumento[21+1];
			VARCHAR stcdCpfCnpjBase[255+1];
			VARCHAR stcdCnpjFilial[255+1];
			VARCHAR stcdCpfCnpjControle[255+1];
			VARCHAR stnrDocumento[255+1];
			VARCHAR stsgOrgaoExpedidor[255+1];
			VARCHAR stdtEmissao[12+1];
			VARCHAR stidPais[21+1];
			VARCHAR stsgPais[255+1];
			VARCHAR stnmPais[255+1];
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stidTipoDocumento[21+1];
			VARCHAR stsgTipoDocumento[255+1];
			VARCHAR stdsTipoDocumento[255+1];
		} stDocumentoRegistro;
		struct
		{
			short iidDocumento;
			short icdCpfCnpjBase;
			short icdCnpjFilial;
			short icdCpfCnpjControle;
			short inrDocumento;
			short isgOrgaoExpedidor;
			short idtEmissao;
			short iidPais;
			short isgPais;
			short inmPais;
			short iidUF;
			short isgUF;
			short inmUF;
			short iidTipoDocumento;
			short isgTipoDocumento;
			short idsTipoDocumento;
		} stDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraDocumento();
		
		if( ( strlennull( cidPessoa ) <= 0 ) || ( strlennull( cidTipo ) <= 0 ) )
		{
		    ULOG_END(" CDocumento::ListDocPorIdPesssoa(  )");
			return 0;
		}

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListDocPorIdPesssoa;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE CursorListDocPorIdPesssoa CURSOR FOR
                SELECT 
				     DOCUMENTO.IDDOCUMENTO
				    ,DOCUMENTO.CDCPFCNPJBASE
				    ,DOCUMENTO.CDCNPJFILIAL
				    ,DOCUMENTO.CDCPFCNPJCONTROLE
				    ,DOCUMENTO.NRDOCUMENTO
				    ,DOCUMENTO.SGORGAOEXPEDIDOR
				    ,DOCUMENTO.DTEMISSAO
				    ,PAIS.IDPAIS
				    ,PAIS.SGPAIS
				    ,PAIS.NMPAIS
				    ,UF.IDUF
				    ,UF.SGUF
				    ,UF.NMUF
				    ,TIPODOCUMENTO.IDTIPODOCUMENTO
				    ,TIPODOCUMENTO.SGTIPODOCUMENTO
				    ,TIPODOCUMENTO.DSTIPODOCUMENTO
				FROM 
				    CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
				    CUSTOMER.DOCUMENTO DOCUMENTO,
				    APOIO.UF UF,
				    APOIO.TIPODOCUMENTO TIPODOCUMENTO,
				    APOIO.PAIS PAIS
				WHERE PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
				AND   DOCUMENTO.IDUF = UF.IDUF
				AND   DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
				AND   DOCUMENTO.IDPAIS = PAIS.IDPAIS
				AND   PESSOADOCUMENTO.IDPESSOA = :cidPessoaAux
				AND DOCUMENTO.IDTIPODOCUMENTO = :cidTipoDocumento;  
                   
           	
		EXEC SQL OPEN CursorListDocPorIdPesssoa;
	
		if(sqlca.sqlcode)
		{
			ULOG_END(" CDocumento::ListDocPorIdPesssoa(  )");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stDocumentoRegistro, 0, sizeof(stDocumentoRegistro) );
				EXEC SQL FETCH CursorListDocPorIdPesssoa INTO :stDocumentoRegistro:stDocumentoIndicator;
	
				Add( (char*)stDocumentoRegistro.stidDocumento.arr
				    ,(char*)stDocumentoRegistro.stcdCpfCnpjBase.arr
				    ,(char*)stDocumentoRegistro.stcdCnpjFilial.arr
				    ,(char*)stDocumentoRegistro.stcdCpfCnpjControle.arr
				    ,(char*)stDocumentoRegistro.stnrDocumento.arr
				    ,(char*)stDocumentoRegistro.stsgOrgaoExpedidor.arr
				    ,(char*)stDocumentoRegistro.stdtEmissao.arr
				    ,(char*)stDocumentoRegistro.stidPais.arr
				    ,(char*)stDocumentoRegistro.stsgPais.arr
				    ,(char*)stDocumentoRegistro.stnmPais.arr
				    ,(char*)stDocumentoRegistro.stidUF.arr 
				    ,(char*)stDocumentoRegistro.stsgUF.arr 
				    ,(char*)stDocumentoRegistro.stnmUF.arr 
				    ,(char*)stDocumentoRegistro.stidTipoDocumento.arr 
				    ,(char*)stDocumentoRegistro.stsgTipoDocumento.arr 
				    ,(char*)stDocumentoRegistro.stdsTipoDocumento.arr 
				   );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorListDocPorIdPesssoa;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END(" CDocumento::ListDocPorIdPesssoa(  )");
	return iCont;

GotoListDocPorIdPesssoa:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CDocumento::FindDocumento( char* cnrDocumento, char* cidTipoDocumento )
{
	ULOG_START(" CDocumento::FindDocumento(  )");
	int iRet = 0;
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			if( ( strcmp( cnrDocumento, Registro(x)->cnrDocumento ) == 0 )
			 && ( strcmp( cidTipoDocumento, Registro(x)->cidTipoDocumento ) == 0 ) )
			{
				iRet = 1;
				break;
			}

		}
	}
	ULOG_END(" CDocumento::FindDocumento( )");
	return iRet;
}

void CDocumento::GetXml( char* cNomeTag, XMLGen*xml )
{
	ULOG_START(" CDocumento::GetXml(  )");
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			xml->addProp(	"xmlns", "usuario.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{
				xml->addItem("idDocumento",Registro(x)->cidDocumento);
				xml->addItem("cdCpfCnpjBase",Registro(x)->ccdCpfCnpjBase);
				xml->addItem("cdCnpjFilial",Registro(x)->ccdCnpjFilial);
				xml->addItem("cdCpfCnpjControle",Registro(x)->ccdCpfCnpjControle);
				xml->addItem("nrDocumento",Registro(x)->cnrDocumento);
				xml->addItem("sgOrgaoExpedidor",Registro(x)->csgOrgaoExpedidor);
				xml->addItem("dtEmissao",Registro(x)->cdtEmissao);
				xml->addItem("idPais",Registro(x)->cidPais);
				xml->addItem("sgPais",Registro(x)->csgPais);
				xml->addItem("nmPais",Registro(x)->cnmPais);
				xml->addItem("idUF",Registro(x)->cidUF);
				xml->addItem("sgUF",Registro(x)->csgUF);
				xml->addItem("nmUF",Registro(x)->cnmUF);
				xml->addItem("idTipoDocumento",Registro(x)->cidTipoDocumento);
				xml->addItem("sgTipoDocumento",Registro(x)->csgTipoDocumento);
				xml->addItem("dsTipoDocumento",Registro(x)->cdsTipoDocumento);
			}
			xml->closeTag();
		}
	}
	ULOG_END(" CDocumento::GetXml(  )");
}

int CDocumento::Insert( char* ccdCpfCnpjBase
	                   ,char* ccdCnpjFilial
	                   ,char* ccdCpfCnpjControle
	                   ,char* cnrDocumento
	                   ,char* csgOrgaoExpedidor
	                   ,char* cdtEmissao
	                   ,char* cidPais
	                   ,char* cidUF
	                   ,char* cidTipoDocumento
	                   ,char* cidUser )
{
	ULOG_START(" CDocumento::Insert( )");
	
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR stidDocumento[21+1];
		char* cAuxidUser = cidUser;
		char* cAuxcdCpfCnpjBase = ccdCpfCnpjBase;
		char* cAuxcdCnpjFilial = ccdCnpjFilial;
		char* cAuxcdCpfCnpjControle = ccdCpfCnpjControle;
		char* cAuxnrDocumento = cnrDocumento;
		char* cAuxsgOrgaoExpedidor = csgOrgaoExpedidor;
		char* cAuxdtEmissao = cdtEmissao;
		char* cAuxidPais = cidPais;
		char* cAuxidUF = cidUF;
		char* cAuxidTipoDocumento = cidTipoDocumento;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraDocumento();

		memset( &stidDocumento, 0, sizeof(stidDocumento) );
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsertId;
		sqlca.sqlcode=0;
		
		//Soh insere se nao achar na base
		if( !ListDocIdTipo( cnrDocumento, cidTipoDocumento ) )
		{
		
			//Recupera uma UD unica
			EXEC SQL
				SELECT CUSTOMER.DOCUMENTOSQ.NEXTVAL
				  INTO :stidDocumento
				  FROM DUAL;
			
			//Insere um documento
			EXEC SQL
				INSERT INTO CUSTOMER.DOCUMENTO
				  (IDDOCUMENTO
				  ,CDCPFCNPJBASE
				  ,CDCNPJFILIAL
				  ,CDCPFCNPJCONTROLE
				  ,NRDOCUMENTO
				  ,SGORGAOEXPEDIDOR
				  ,DTEMISSAO
				  ,IDPAIS
				  ,IDUF
				  ,IDTIPODOCUMENTO
				  ,IDUSUARIOALTERACAO
				  ,DTULTIMAALTERACAO)
				VALUES
				  (:stidDocumento
				  ,:cAuxcdCpfCnpjBase
				  ,:cAuxcdCnpjFilial
				  ,:cAuxcdCpfCnpjControle
				  ,:cAuxnrDocumento
				  ,:cAuxsgOrgaoExpedidor
				  ,TO_DATE(:cAuxdtEmissao, 'DD/MM/YYYY' )
				  ,:cAuxidPais
				  ,:cAuxidUF
				  ,:cAuxidTipoDocumento
				  ,:cAuxidUser
				  ,SYSDATE);		
		
			if(sqlca.sqlcode)
			{
				ULOG_END(" CDocumento::Insert( )");
				return 0;
			}
		
			Add( (char*)stidDocumento.arr
			    ,cAuxcdCpfCnpjBase
			    ,cAuxcdCnpjFilial
			    ,cAuxcdCpfCnpjControle
			    ,cAuxnrDocumento
			    ,cAuxsgOrgaoExpedidor
			    ,cdtEmissao
			    ,cAuxidPais
			    ,""
			    ,""
			    ,cAuxidUF
			    ,""
			    ,""
			    ,cAuxidTipoDocumento
			    ,""
			    ,""
			   );
		}//if( !ListDocIdTipo( cnrDocumento, cidTipoDocumento ) )
	}
	catch(...)
	{
		throw;
	}
	ULOG_END(" CDocumento::Insert( )");
	return 1;

GotoInsertId:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CDocumento::Update( char* cidDocumento
	                   ,char* ccdCpfCnpjBase
	                   ,char* ccdCnpjFilial
	                   ,char* ccdCpfCnpjControle
	                   ,char* cnrDocumento
	                   ,char* csgOrgaoExpedidor
	                   ,char* cdtEmissao
	                   ,char* cidPais
	                   ,char* cidUF
	                   ,char* cidTipoDocumento
	                   ,char* cidUser )
{
	ULOG_START(" CDocumento::Update()");
        
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidDocumento = cidDocumento;
		char* cAuxidUser = cidUser;
		char* cAuxcdCpfCnpjBase = ccdCpfCnpjBase;
		char* cAuxcdCnpjFilial = ccdCnpjFilial;
		char* cAuxcdCpfCnpjControle = ccdCpfCnpjControle;
		char* cAuxnrDocumento = cnrDocumento;
		char* cAuxsgOrgaoExpedidor = csgOrgaoExpedidor;
		char* cAuxdtEmissao = cdtEmissao;
		char* cAuxidPais = cidPais;
		char* cAuxidUF = cidUF;
		char* cAuxidTipoDocumento = cidTipoDocumento;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraDocumento();
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsertId;
		sqlca.sqlcode=0;
		
		//Insere um documento
		EXEC SQL
			UPDATE CUSTOMER.DOCUMENTO
			   SET CDCPFCNPJBASE = :cAuxidDocumento
			      ,CDCNPJFILIAL = :cAuxcdCnpjFilial
			      ,CDCPFCNPJCONTROLE = :cAuxcdCpfCnpjControle
			      ,NRDOCUMENTO = :cAuxnrDocumento
			      ,SGORGAOEXPEDIDOR = :cAuxsgOrgaoExpedidor
			      ,DTEMISSAO = :cAuxdtEmissao
			      ,IDPAIS = :cAuxidPais
			      ,IDUF = :cAuxidUF
			      ,IDTIPODOCUMENTO = :cAuxidTipoDocumento
			      ,IDUSUARIOALTERACAO = :cAuxidUser
			      ,DTULTIMAALTERACAO = SYSDATE
			 WHERE IDDOCUMENTO = :cAuxidDocumento;
	
		if(sqlca.sqlcode)
		{
			ULOG_END(" CDocumento::Update( )");
			return 0;
		}
	
		Add( cAuxidDocumento
		    ,cAuxcdCpfCnpjBase
		    ,cAuxcdCnpjFilial
		    ,cAuxcdCpfCnpjControle
		    ,cAuxnrDocumento
		    ,cAuxsgOrgaoExpedidor
		    ,cdtEmissao
		    ,cAuxidPais
		    ,""
		    ,""
		    ,cAuxidUF
		    ,""
		    ,""
		    ,cAuxidTipoDocumento
		    ,""
		    ,""
		   );

	}
	catch(...)
	{
		throw;
	}
	ULOG_END(" CDocumento::Update(  )");
	return 1;

GotoInsertId:
	throw TuxBasicOraException(sqlca.sqlcode);
}
