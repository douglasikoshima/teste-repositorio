#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "CGrupoUsuario.h"

CGrupoUsuario::CGrupoUsuario()
{
}

CGrupoUsuario::~CGrupoUsuario()
{
}

/*******************************************************************************************************/
void CGrupoUsuario::insereUsuarioEmprestado(char *pDtInicial, char *pDtFinal, char *pIdPessoaUsuarioEfetuado, char *pIdUsuarioAlteracao, char *pIdPessoaUsuario, char *pIdGrupo)
{
    ULOG_START("void CGrupoUsuario::insereUsuarioEmprestado(char *pDtInicial, char *pDtFinal, char *pIdPessoaUsuarioEfetuado, char *pIdUsuarioAlteracao, char *pIdPessoaUsuario, char *pIdGrupo)");
    
    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdUsuarioGrupoEmprestado[21 + 1];
        char *opDtInicial=pDtInicial;
        char *opDtFinal=pDtFinal;
        char *opIdPessoaUsuarioEfetuado=pIdPessoaUsuarioEfetuado;
        char *opIdUsuarioAlteracao=pIdUsuarioAlteracao;
        char *opIdPessoaUsuario=pIdPessoaUsuario;
        char *opIdGrupo=pIdGrupo;
    EXEC SQL END DECLARE SECTION;


    try
    {
        ULOG("pDtInicial[%s] pDtFinal[%s] pIdPessoaUsuarioEfetuado[%s] pIdUsuarioAlteracao[%s] pIdPessoaUsuario[%s] pIdGrupo[%s]",
                pDtInicial, pDtFinal, pIdPessoaUsuarioEfetuado, pIdUsuarioAlteracao, pIdPessoaUsuario, pIdGrupo);

        EXEC SQL WHENEVER SQLERROR GOTO GotoListId;

        EXEC SQL SELECT acesso.usuariogrupoemprestadosq.nextval
                   INTO :oszIdUsuarioGrupoEmprestado
                   FROM DUAL;

        ULOG("Sequence->oszIdUsuarioGrupoEmprestado.arr[%.*s]", oszIdUsuarioGrupoEmprestado.len, oszIdUsuarioGrupoEmprestado.arr);


        EXEC SQL INSERT INTO acesso.usuariogrupoemprestado
            (
                idusuariogrupoemprestado,
                dtinicial,
                dtfinal,
                idpessoausuarioefetuado,
                idusuarioalteracao,
                dtultimaalteracao,
                idpessoausuario,
                idgrupo
            )
            VALUES
            (
                :oszIdUsuarioGrupoEmprestado,
                TO_DATE(:opDtInicial, 'DD/MM/YYYY'),
                TO_DATE(:opDtFinal, 'DD/MM/YYYY'),
                :opIdPessoaUsuarioEfetuado,
                :opIdUsuarioAlteracao,
                SYSDATE,
                :opIdPessoaUsuario,
                :opIdGrupo
            );

        ULOG("sqlca.sqlcode(%d)", sqlca.sqlcode);
        ULOG_END("void CGrupoUsuario::insereUsuarioEmprestado(char *pDtInicial, char *pDtFinal, char *pIdPessoaUsuarioEfetuado, char *pIdUsuarioAlteracao, char *pIdPessoaUsuario, char *pIdGrupo)");
        return;

    }
    catch(...)
    {
        throw;
    }

GotoListId:
    throw TuxBasicOraException(sqlca.sqlcode);
}

/*******************************************************************************************************/
void CGrupoUsuario::carregaListaUsuarioEmprestado(XMLGen* xml_g, char *pIdGrupo)
{
    ULOG_START("void CGrupoUsuario::carregaListaUsuarioEmprestado(XMLGen* xml_g, char *pIdGrupo)");
    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;
        char *opIdGrupo=pIdGrupo;
        struct
        {
            VARCHAR oszIdPessoa[21 + 1];
            VARCHAR oszNmPessoa[255 + 1];
            VARCHAR oszIdGrupo[21 + 1];
            VARCHAR oszNmGrupo[255 + 1];
            VARCHAR oszDtInicial[12 + 1];
            VARCHAR oszDtFinal[12 + 1];
            VARCHAR oszNmLoginUsuario[255 + 1];
        } stGrupoUsuarioEmprestado;
        struct
        {
            short oiIdPessoa;
            short oiNmPessoa;
            short oiIdGrupo;
            short oiNmGrupo;
            short oiDtInicial;
            short oiDtFinal;
            short oiNmLoginUsuario;
        } stGrupoUsuarioEmprestadoIndicator;
    EXEC SQL END DECLARE SECTION;

    try
    {
        ULOG("pIdGrupo[%s]", pIdGrupo);

        EXEC SQL WHENEVER NOT FOUND DO break;
        EXEC SQL WHENEVER SQLERROR GOTO GotoListId;

        EXEC SQL DECLARE CursorGrupoUsuarioEmprestado CURSOR for
            SELECT
                pessoa.idpessoa,
                usuario.nmloginusuario,
                grupo.idgrupo,
                grupo.nmgrupo,
                TO_CHAR(usuariogrupoemprestado.dtinicial, 'DD/MM/YYYY'),
                TO_CHAR(usuariogrupoemprestado.dtfinal, 'DD/MM/YYYY'),
                usuarioefetuado.nmloginusuario
            FROM 
                acesso.usuariogrupoemprestado usuariogrupoemprestado,
                acesso.usuario usuario,
                customer.pessoa pessoa,
                acesso.usuario usuarioefetuado,
                acesso.grupo grupo
            WHERE
                usuario.idpessoausuario = usuariogrupoemprestado.idpessoausuario
            AND
                usuario.idpessoausuario = pessoa.idpessoa
            AND
                grupo.idgrupo = usuariogrupoemprestado.idgrupo
            AND
                usuarioefetuado.idpessoausuario = usuariogrupoemprestado.idpessoausuarioefetuado
            AND
                usuario.idpessoausuario IN ( SELECT idpessoausuario FROM acesso.usuariogrupo WHERE usuariogrupo.idgrupo = TO_NUMBER(:opIdGrupo) )
            AND
                TO_CHAR(usuariogrupoemprestado.dtfinal, 'YYYYMMDD') >= TO_CHAR(SYSDATE, 'YYYYMMDD');



        EXEC SQL OPEN CursorGrupoUsuarioEmprestado;
    
        for(;;)
        {
            memset(&stGrupoUsuarioEmprestado, 0x00, sizeof(stGrupoUsuarioEmprestado));
            EXEC SQL FETCH CursorGrupoUsuarioEmprestado INTO :stGrupoUsuarioEmprestado:stGrupoUsuarioEmprestadoIndicator;
            ULOG("sqlca.sqlcode(%d)", sqlca.sqlcode);


            ULOG("(char *)&stGrupoUsuarioEmprestado.oszIdPessoa.arr[%s]", (char *)&stGrupoUsuarioEmprestado.oszIdPessoa.arr);
            ULOG("(char *)&stGrupoUsuarioEmprestado.oszNmPessoa.arr[%s]", (char *)&stGrupoUsuarioEmprestado.oszNmPessoa.arr);
            ULOG("(char *)&stGrupoUsuarioEmprestado.oszIdGrupo.arr[%s]", (char *)&stGrupoUsuarioEmprestado.oszIdGrupo.arr);
            ULOG("(char *)&stGrupoUsuarioEmprestado.oszNmGrupo.arr[%s]", (char *)&stGrupoUsuarioEmprestado.oszNmGrupo.arr);
            ULOG("(char *)&stGrupoUsuarioEmprestado.oszDtInicial.arr[%s]", (char *)&stGrupoUsuarioEmprestado.oszDtInicial.arr);
            ULOG("(char *)&stGrupoUsuarioEmprestado.oszDtFinal.arr[%s]", (char *)&stGrupoUsuarioEmprestado.oszDtFinal.arr);
            ULOG("(char *)&stGrupoUsuarioEmprestado.oszNmLoginUsuario.arr[%s]", (char *)&stGrupoUsuarioEmprestado.oszNmLoginUsuario.arr);

            xml_g->createTag("usuarioDestino");
            xml_g->addItem("idUsuario", (char *)&stGrupoUsuarioEmprestado.oszIdPessoa.arr);
            xml_g->addItem("dsUsuario", (char *)&stGrupoUsuarioEmprestado.oszNmPessoa.arr);
            xml_g->addItem("idGrupoOrigem", "");
            xml_g->addItem("dsGrupoOrigem", "");
            xml_g->addItem("idGrupoDestino", (char *)&stGrupoUsuarioEmprestado.oszIdGrupo.arr);
            xml_g->addItem("dsGrupoDestino", (char *)&stGrupoUsuarioEmprestado.oszNmGrupo.arr);
            xml_g->addItem("dtInicio", (char *)&stGrupoUsuarioEmprestado.oszDtInicial.arr);
            xml_g->addItem("dtFim", (char *)&stGrupoUsuarioEmprestado.oszDtFinal.arr);
            xml_g->addItem("dsLogin", (char *)&stGrupoUsuarioEmprestado.oszNmLoginUsuario.arr);
            xml_g->closeTag();
        }

        ULOG_END("void CGrupoUsuario::carregaListaUsuarioEmprestado(XMLGen* xml_g, char *pIdGrupo)");
        return;

    }
    catch(...)
    {
        throw;
    }

GotoListId:
    throw TuxBasicOraException(sqlca.sqlcode);
}

/*******************************************************************************************************/
void CGrupoUsuario::carregaComboGrupo(XMLGen* xml_g)
{
    ULOG_START("void CGrupoUsuario::carregaComboGrupo(XMLGen* xml_g)");
    bool bFlagRegFound = false;
    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;
        struct
        {
            VARCHAR stIdGrupo[21+1];
            VARCHAR stNmGrupo[255+1];
        } stGrupo;
        struct
        {
            short iIdGrupo;
            short iNmGrupo;
        } stGrupoIndicator;
    EXEC SQL END DECLARE SECTION;

    try
    {
        
        EXEC SQL WHENEVER NOT FOUND DO break;
        EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
    
        EXEC SQL DECLARE CursorGrupoUsuario CURSOR FOR
            SELECT DISTINCT
                grupo.idgrupo,
                grupo.nmgrupo
            FROM
                acesso.grupo grupo,
                acesso.usuario usuario,
                acesso.usuariogrupo usuariogrupo
            WHERE
                grupo.idgrupo = usuariogrupo.idgrupo
            AND
                usuariogrupo.idpessoausuario = usuario.idpessoausuario
            AND
                grupo.dtexclusao is NULL
            ORDER BY
                grupo.nmgrupo;

    
        EXEC SQL OPEN CursorGrupoUsuario;
    
        for(;;)
        {
            memset( &stGrupo, 0x00, sizeof(stGrupo));
            EXEC SQL FETCH CursorGrupoUsuario INTO :stGrupo:stGrupoIndicator;
            ULOG("sqlca.sqlcode(%d)", sqlca.sqlcode);

            ULOG("(char *)&stGrupo.stIdGrupo.arr[%s] stGrupoIndicator.iIdGrupo(%d)", (char *)&stGrupo.stIdGrupo.arr, stGrupoIndicator.iIdGrupo);
            ULOG("(char *)&stGrupo.stNmGrupo.arr[%s] stGrupoIndicator.iNmGrupo(%d)", (char *)&stGrupo.stNmGrupo.arr, stGrupoIndicator.iNmGrupo);

            if(bFlagRegFound == false) {
                xml_g->createTag("AdmEmprestimoUsuariosVO");
                xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo");
                bFlagRegFound = true;
            }

            xml_g->createTag("listaGruposOrigem");
                xml_g->addItem("idGrupoOrigem", (char *)&stGrupo.stIdGrupo.arr);
                xml_g->addItem("dsGrupoOrigem", (char *)&stGrupo.stNmGrupo.arr);
            xml_g->closeTag();
        }

        if(bFlagRegFound == true) {
            xml_g->closeTag();
            bFlagRegFound = false;
        }
        else {
            this->retornoVazio(xml_g);
        }

        EXEC SQL CLOSE CursorGrupoUsuario;

        ULOG_END("void CGrupoUsuario::carregaComboGrupo(XMLGen* xml_g)");
        return;
    }
    catch(...)
    {
        throw;
    }

GotoListId:
    throw TuxBasicOraException(sqlca.sqlcode);
}

/*******************************************************************************************************/
void CGrupoUsuario::carregaListaUsuario(XMLGen* xml_g, char *pIdGrupo)
{
    ULOG_START("void CGrupoUsuario::carregaListaUsuario(XMLGen* xml_g, char *pIdGrupo)");
    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;
        char *opIdGrupo = pIdGrupo;
        struct
        {
            VARCHAR oszIdPessoaUsuario[21+1];
            VARCHAR oszNmLoginUsuario[255+1];
            VARCHAR oszIdGrupo[21+1];
            VARCHAR oszNmGrupo[255+1];
            VARCHAR oszNmLoginUsuarioCti[255+1];
        } stUsuario;
        struct
        {
            short oiIdPessoaUsuario;
            short oiNmLoginUsuario;
            short oiIdGrupo;
            short oiNmGrupo;
            short oiNmLoginUsuarioCti;
        } stUsuarioIndicator;
    EXEC SQL END DECLARE SECTION;

    try
    {
        
        ULOG("pIdGrupo[%s]", pIdGrupo);

        EXEC SQL WHENEVER NOT FOUND DO break;
        EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
    
        EXEC SQL DECLARE CursorUsuario CURSOR FOR
            SELECT
                usuario.idpessoausuario,
                usuario.nmloginusuariocti,
                grupo.idgrupo,
                grupo.nmgrupo,
                usuario.nmloginusuariocti
            FROM
                acesso.usuario usuario,
                acesso.grupo grupo,
                acesso.usuariogrupo usuariogrupo
            WHERE
                usuario.idpessoausuario = usuariogrupo.idpessoausuario
            AND
                usuariogrupo.idgrupo = grupo.idgrupo
            AND
                usuario.idpessoausuario NOT IN ( SELECT idpessoausuario FROM acesso.usuariogrupoemprestado WHERE TO_CHAR(usuariogrupoemprestado.dtfinal, 'YYYYMMDD') >= TO_CHAR(SYSDATE, 'YYYYMMDD') )
            AND
               grupo.idgrupo = TO_NUMBER(:opIdGrupo);

    
        EXEC SQL OPEN CursorUsuario;
    

        for(;;)
        {
            memset(&stUsuario, 0x00, sizeof(stUsuario));
            EXEC SQL FETCH CursorUsuario INTO :stUsuario:stUsuarioIndicator;
            ULOG("sqlca.sqlcode(%d)", sqlca.sqlcode);

            ULOG("(char *)&stUsuario.oszIdPessoaUsuario.arr[%s] stUsuarioIndicator.oiIdPessoaUsuario(%d)", (char *)&stUsuario.oszIdPessoaUsuario.arr, stUsuarioIndicator.oiIdPessoaUsuario);
            ULOG("(char *)&stUsuario.oszNmLoginUsuario.arr[%s] stUsuarioIndicator.oiNmLoginUsuario(%d)", (char *)&stUsuario.oszNmLoginUsuario.arr, stUsuarioIndicator.oiNmLoginUsuario);
            ULOG("(char *)&stUsuario.oszIdGrupo.arr[%s] stUsuarioIndicator.oiIdGrupo(%d)", (char *)&stUsuario.oszIdGrupo.arr, stUsuarioIndicator.oiIdGrupo);
            ULOG("(char *)&stUsuario.oszNmGrupo.arr[%s] stUsuarioIndicator.oiNmGrupo(%d)", (char *)&stUsuario.oszNmGrupo.arr, stUsuarioIndicator.oiNmGrupo);
            ULOG("(char *)&stUsuario.oszNmLoginUsuarioCti.arr[%s] stUsuarioIndicator.oiNmLoginUsuarioCti(%d)", (char *)&stUsuario.oszNmLoginUsuarioCti.arr, stUsuarioIndicator.oiNmLoginUsuarioCti);


            xml_g->createTag("usuarioOrigem");
            xml_g->addItem("idUsuario", (char *)&stUsuario.oszIdPessoaUsuario.arr);
            xml_g->addItem("dsUsuario", (char *)&stUsuario.oszNmLoginUsuario.arr);
            xml_g->addItem("idGrupoOrigem", (char *)&stUsuario.oszIdGrupo.arr);
            xml_g->addItem("dsGrupoOrigem", (char *)&stUsuario.oszNmGrupo.arr);
            xml_g->addItem("dsLogin", (char *)&stUsuario.oszNmLoginUsuarioCti.arr);
            xml_g->closeTag();
        }

        EXEC SQL CLOSE CursorUsuario;

        ULOG_END("void CGrupoUsuario::carregaListaUsuario(XMLGen* xml_g, char *pIdGrupo)");
        return;
    }
    catch(...)
    {
        throw;
    }

GotoListId:
    throw TuxBasicOraException(sqlca.sqlcode);
}

/*******************************************************************************************************/
void CGrupoUsuario::retornoVazio(XMLGen *xml_g)
{
    ULOG_START("void CGrupoUsuario::retornoVazio(XMLGen *xml_g)");
    
    xml_g->createTag("AdmEmprestimoUsuariosVO");
    xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo");
        xml_g->createTag("listaGruposOrigem");
        xml_g->closeTag();
    xml_g->closeTag();
    
    ULOG_END("void CGrupoUsuario::retornoVazio(XMLGen *xml_g)");    
}
/*******************************************************************************************************/
void CGrupoUsuario::apagaUsuarioEmprestado(char *pIdPessoaUsuario)
{
    ULOG_START("void CGrupoUsuario::apagaUsuarioEmprestado(char *pIdPessoaUsuario)");
    
    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;
        char *opIdPessoaUsuario=pIdPessoaUsuario;
    EXEC SQL END DECLARE SECTION;

    try
    {
        ULOG("pIdPessoaUsuario[%s]", pIdPessoaUsuario);

		EXEC SQL WHENEVER NOT FOUND goto notFound;
        EXEC SQL WHENEVER SQLERROR GOTO GotoListId;

        EXEC SQL 
            DELETE FROM 
                acesso.usuariogrupoemprestado
            WHERE 
                idpessoausuario = TO_NUMBER(:opIdPessoaUsuario);

        ULOG("Registro deletado com sucesso");
        ULOG_END("void CGrupoUsuario::apagaUsuarioEmprestado(char *pIdPessoaUsuario)");
        return;

    }
    catch(...)
    {
        throw;
    }

notFound:
    ULOG("Nenhum registro deletado");
    ULOG("Final CGrupoUsuario::apagaUsuarioEmprestado");
    return;

GotoListId:
    throw TuxBasicOraException(sqlca.sqlcode);
}

