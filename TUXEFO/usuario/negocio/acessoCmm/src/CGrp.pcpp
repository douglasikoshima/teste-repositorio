/*****************************************************************************
 *
 * Modulo:    CGrp
 * Arquivo:   CGrp.cpp
 * Proposito: Funcao de Negocios 
 * Historico:
 * Data        Autor                 Descricao
 * ----------  --------------------  -----------------------------------------
 * 18/05/2004  C_RECOliveira         Criacao
 * 18/05/2004  C_EDMartins           Criacao
 * 21/07/2005  C_CMSantos            Modificacao
 *
 ****************************************************************************/
/**************************************************************************
 * Notas:
 *
 **************************************************************************/

//Definicao Global
#define CGrpCPP

//Header
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <tuxfw.h>
#include "CGrp.h"
#include "CSafePointer.h"

#define CONVIND(O,I) \
{ \
	if (I == -1) { \
		##O.arr[0]=0; \
	} else { \
		##O.arr[##O.len]=0; \
	} \
}


char* CGrp::RTrim(char *pszString)
{
    ULOG_START("CGrp::RTrim()");
   
    int iLen;
    iLen=strlen(pszString);
    for(;;)
    {
        if(pszString[iLen-1] != ' ')
            break;

        iLen--;

        if(iLen == 0)
            break;
    }
    pszString[iLen] = 0x00;
	
	ULOG_END("CGrp::RTrim()");
	return pszString;
}

//Classe:
int CGrp::GrpListaId(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("int CGrp::GrpListaId(DOMNode*dnode, XMLGen*xml_g)");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		struct 
		{
			VARCHAR stidGrupo[21+1]; 
			VARCHAR stnmGrupo[256];
			VARCHAR stidTipoGrupo[256];
			VARCHAR stsgTipoGrupo[256];
			VARCHAR stdsTipoGrupo[256];
		} stRegistro;
		struct 
		{
			short sidGrupo;
			short snmGrupo;
			short idTipoGrupo;
			short sgTipoGrupo;
			short dsTipoGrupo;
		} stIndicator;
		char* cidGrupo;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	memset( &stRegistro, 0, sizeof(stRegistro));
	memset( &stIndicator, 0, sizeof(stIndicator));

	//Se o ID nao for numerico entao retornar com codigo de erro
	cidGrupo = oSafePointer.getTag(dnode,"idGrupo",0);
	if( cidGrupo == NULL ) 
	{
		ULOG_END(" CGrp::GrpListaId()");
		return 3;
	}

	//Se o ID estiver vazio entao retornar com codigo de erro
	if ( strlen( cidGrupo ) == 0 )
	{
		ULOG_END(" CGrp::GrpListaId()");
		return 2;
	}

	sqlca.sqlcode=0;
	EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL 
	SELECT 
		IDGRUPO, 
		NMGRUPO,
		TIPOGRUPO.IDTIPOGRUPO,
		TIPOGRUPO.CDTIPOGRUPO,
		TIPOGRUPO.DSTIPOGRUPO
	INTO
		:stRegistro:stIndicator
	FROM
		ACESSO.GRUPO GRUPO,
		APOIO.TIPOGRUPO TIPOGRUPO
	WHERE
		GRUPO.IDTIPOGRUPO = TIPOGRUPO.IDTIPOGRUPO
	AND
		IDGRUPO = :cidGrupo
	AND 
		DTEXCLUSAO IS NULL;

	xml_g->createTag("GruposUsuarioVO");
	xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );

	xml_g->createTag("GrupoUsuarioVO");
	xml_g->addItem("idGrupo",(char*)stRegistro.stidGrupo.arr);
	xml_g->addItem("dsGrupo",(char*)stRegistro.stnmGrupo.arr);
	xml_g->addItem("idTipoGrupoSelecionado",(char*)stRegistro.stidTipoGrupo.arr);
	xml_g->addItem("dsTipoGrupoSelecionado",(char*)stRegistro.stdsTipoGrupo.arr);
	xml_g->closeTag();//GrupoUsuarioVO

	xml_g->closeTag();//GruposUsuarioVO

	ULOG_END("CGrp::GrpListaId()");
	return 0;

//Tratamento de Exception
ErrorF:
	if( sqlca.sqlcode == -2292 )
	{
		ULOG_END("CGrp::GrpListaId()");
		return 5;
	}
	else
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int CGrp::GrpImnRelacao(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CGrp::GrpImnRelacao()");
	
	//Declarar Estruturas
	struct sqlca sqlca;

	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidGrupo;
		char* cidSubSistema;
		struct
		{
			int idItemMenu;
			char cnmItem[255+1];
		} ItemMenuRegistro;

		struct 
		{
			short sidItemMenu, snmItem;
		} ItemMenuRegistroInd;

	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	memset( &ItemMenuRegistro, 0, sizeof(ItemMenuRegistro));
	memset( &ItemMenuRegistroInd, 0, sizeof(ItemMenuRegistroInd));

	cidGrupo = oSafePointer.getTag(dnode,"idGrupo",0);
	cidSubSistema = oSafePointer.getTag(dnode,"idSubSistema",0);

	//Se o ID estiver vazio entao retornar com codigo de erro
	if( strlennull( cidGrupo ) <= 0 )
	{
		ULOG_END(" CGrp::GrpImnRelacao()");
		return 1;
	}
	if( strlennull( cidSubSistema ) <= 0 )
	{
		ULOG_END(" CGrp::GrpImnRelacao()");
		return 2;
	}

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	sqlca.sqlcode=0;

//Nao sei porque os itens existentes e relacionados estao invertidos, mas por hora ficaram assim (Eder)
	
	EXEC SQL 
		DECLARE 
			tvcursorexistentes1 CURSOR FOR
		SELECT 
			ITEMMENUPAGINA.IDITEMMENU, 
			ITEMMENUPAGINA.NMITEM
		FROM 
			ACESSO.ITEMMENUPAGINAV02 ITEMMENUPAGINA
		WHERE 
			ITEMMENUPAGINA.INVISIBILIDADE = 1
		AND
			ITEMMENUPAGINA.IDGRUPO = :cidGrupo
		AND 
			ITEMMENUPAGINA.IDSUBSISTEMA = :cidSubSistema
		ORDER BY 
			ITEMMENUPAGINA.NMITEM;


	EXEC SQL 
		DECLARE 
			tvcursorrelacionados1 CURSOR FOR
    	SELECT 
			ITEMMENU.IDITEMMENU, 
			ITEMMENU.NMITEM
		FROM 
			ACESSO.ITEMMENUPAGINAV01 ITEMMENU
		WHERE 
			ITEMMENU.INVISIBILIDADE = 1
		AND
			ITEMMENU.IDSUBSISTEMA = :cidSubSistema
		AND 
			ITEMMENU.IDITEMMENU 
		NOT IN 
		(
			SELECT 
				GRUPOITEMMENU.IDITEMMENU
			FROM 
				ACESSO.ITEMMENUPAGINAV02 GRUPOITEMMENU
			WHERE 
				GRUPOITEMMENU.INVISIBILIDADE = 1
			AND
				GRUPOITEMMENU.IDGRUPO = :cidGrupo
			AND 
				GRUPOITEMMENU.IDSUBSISTEMA = :cidSubSistema
	    )
		ORDER BY 
			ITEMMENU.NMITEM;
	
	xml_g->createTag("ListaItensMenuVO");
	xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" ); 
	EXEC SQL OPEN tvcursorexistentes1;
	xml_g->createTag("ItensExistentes");
	for(;;) 
	{
		EXEC SQL FETCH tvcursorexistentes1 INTO :ItemMenuRegistro:ItemMenuRegistroInd;
		xml_g->createTag("ItemMenuExistentesVO");
		xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
		xml_g->addItem("idItemMenu",ItemMenuRegistro.idItemMenu);
		xml_g->addItem("nmMenu",RTrim(ItemMenuRegistro.cnmItem));
		xml_g->closeTag();
	}
	xml_g->closeTag();
	EXEC SQL CLOSE tvcursorexistentes1;
	EXEC SQL OPEN tvcursorrelacionados1;
	xml_g->createTag("ItensMenuRelacionados");
	for(;;) 
	{
		EXEC SQL FETCH tvcursorrelacionados1 INTO :ItemMenuRegistro:ItemMenuRegistroInd;
		xml_g->createTag("ItemMenuExistentesVO");
		xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
		xml_g->addItem("idItemMenu",ItemMenuRegistro.idItemMenu);
		xml_g->addItem("nmMenu",RTrim(ItemMenuRegistro.cnmItem));
		xml_g->closeTag();
	}
	xml_g->closeTag();
	EXEC SQL CLOSE tvcursorrelacionados1;
	xml_g->closeTag();

	ULOG_END(" CGrp::GrpImnRelacao()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int CGrp::GrpPrfRelaciona(DOMNode*dnode, XMLGen*xml_g,
				          char* cLogUser)
{
	ULOG_START("CGrp::GrpPrfRelaciona()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;

		struct Tstruct {
			int idGrupoRole;
			int idGrupo;
			int idRole;
		} tstruct;

		struct Tstruct2 {
			int idRole;
			char cnmRole[256];
		} tstruct2;

		struct Tstructindicator {
			short sidGrupoRole, sidGrupo, sidRole;
		} tstructindicator;

		struct Tstructindicator2 {
			short sidRole, snmRole;
		} tstructindicator2;

		int iAcumulador;

	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
			
		memset( &tstruct, 0, sizeof(Tstruct) );
		memset( &tstruct2, 0, sizeof(Tstruct2) );
		memset( &tstructindicator, 0, sizeof(Tstructindicator) );
		memset( &tstructindicator2, 0, sizeof(Tstructindicator2) );
	
		//Pega o idGrupo que sera utilizado na ralacao
		if ( ( tstruct.idGrupo = atoi( oSafePointer.getTag( dnode, "idGrupo", 0  ) ) )  <= 0 ) 
		{
			ULOG_END("CGrp::GrpPrfRelaciona()");
			return 3;//idGrupo esta nulo
		}
	
		sqlca.sqlcode=0;
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
		EXEC SQL 
		SELECT COUNT(idGrupo)
		INTO :iAcumulador
		FROM acesso.GrupoRole
		WHERE idGrupo = :tstruct.idGrupo;
	
		//Antes de inserir as novas relacoes, deve-se apagar todas, se existirem
		if (iAcumulador>0) {
			EXEC SQL 
			DELETE FROM acesso.GrupoRole 
			WHERE idGrupo = :tstruct.idGrupo;
		}
	
		//Verifica se o comando DELETE obteve sucesso
		if(sqlca.sqlcode == 0 )
		{
			char* pc;
	
			//Pega todos os idRole que existem no XML e insere
			for(int indice=0;;indice++) 
			{
				pc = oSafePointer.getTag( dnode, "idPerfil", indice );
				if ( strlen( pc ) == 0 )
					break;
	
				tstruct.idRole = atoi( pc );
	
				sqlca.sqlcode=0;
	
				EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
				//Pega um id unico e sequencia para a insercao
				EXEC SQL
				SELECT acesso.GrupoRolesq.nextval
				INTO :tstruct.idGrupoRole
				FROM dual;
	
				//Insere item a item
				EXEC SQL 
					INSERT INTO ACESSO.GRUPOROLE 
					( 
						  IDGRUPOROLE
						, IDGRUPO
						, IDROLE
						, IDUSUARIOALTERACAO
						, DTULTIMAALTERACAO 
					)
				VALUES
					( 
						  :tstruct.idGrupoRole
						, :tstruct.idGrupo
						, :tstruct.idRole
						, :cLogUserOra
						, SYSDATE 
					);
	
				//Se der algum erro, desfaz tudo
				if(sqlca.sqlcode)
				{
				    ULOG_END(" CGrp::GrpPrfRelaciona()");
					return 2;//Falha ao tentar inserir os perfis relacionados
				}
			}//for( indice=1;;indice++) 
		}// if(sqlca.sqlcode == 0 )
		else
		{
		    ULOG_END("CGrp::GrpPrfRelaciona()");
			return 1;//Falha ao tentar limpar os perfis relacionados
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CGrp::GrpPrfRelaciona()");
	return 0;//Sucesso

//Tratamento de Exception
ErrorF:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int CGrp::GrpPrfRelacao(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CGrp::GrpPrfRelacao()");
	
	//Declarar Estruturas
	struct sqlca sqlca;

	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;

		int idGrupo;
		VARCHAR stnmGrupo[255+1];
		struct Tstruct {
			int idRole;
			char cnmRole[256];
		} tstruct;

		struct Tstructindicator {
			short sidRole, snmRole;
		} tstructindicator;
	EXEC SQL END DECLARE SECTION;

	char *pc;

	try
	{
			
		//Se o ID nao for numerico entao retornar com codigo de erro
		if ( ( pc = oSafePointer.getTag(dnode,"idGrupo",0) ) == NULL ) {
			ULOG_END("CGrp::GrpPrfRelacao()");
			return 2;
		}
	
		//Se o ID estiver vazio entao retornar com codigo de erro
		if ( strlen( pc ) == 0 ) {
			ULOG_END("CGrp::GrpPrfRelacao()");
			return 3;
		}
	
		//Le a descricao de Grupo
		idGrupo = atoi( pc );
	
		sqlca.sqlcode=0;
	
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		memset( &stnmGrupo, 0, sizeof( stnmGrupo ) );
		EXEC SQL
			SELECT NMGRUPO
			  INTO :stnmGrupo
			  FROM ACESSO.GRUPO
			 WHERE IDGRUPO = :idGrupo;
	
		EXEC SQL DECLARE tvcursorrelacionados2 CURSOR FOR
		SELECT gr.idrole, r.nmrole
		FROM apoio.tipogrupo tg, 
		     acesso.grupo g, 
		     acesso.role r,	
		     acesso.gruporole gr
		WHERE tg.idtipogrupo = g.idtipogrupo
		  AND g.idgrupo = gr.idgrupo
		  AND r.idrole = gr.idrole
		  AND g.idGrupo = :idGrupo
		  ORDER BY r.nmRole;
		
		
	
		EXEC SQL DECLARE tvcursorexistentes2 CURSOR FOR
		SELECT acesso.Role.idRole, acesso.Role.nmRole
		FROM acesso.Role
		WHERE acesso.Role.idRole	
							NOT IN (
									  SELECT gr.idrole                
									  FROM apoio.tipogrupo tg,
									       acesso.grupo g,
									       acesso.role r,
									       acesso.gruporole gr
									  WHERE tg.idtipogrupo = g.idtipogrupo
									        AND g.idgrupo = gr.idgrupo
									        AND r.idrole = gr.idrole
									        AND g.idGrupo = :idGrupo
							  )
		ORDER BY acesso.Role.nmRole; 
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	
		if(sqlca.sqlcode)
		{
		    ULOG_END("CGrp::GrpPrfRelacao()");
			return 4;
		}
		else
		{
			EXEC SQL WHENEVER NOT FOUND DO break;
	
			xml_g->createTag("RelacionarGrupoPerfilVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" ); 
			xml_g->addItem("idGrupo",idGrupo);
			xml_g->addItem("dsGrupo",(char*)stnmGrupo.arr);
	
			EXEC SQL OPEN tvcursorexistentes2;
			xml_g->createTag("PerfisExistentes");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
	
			for(;;) {
				memset( &tstruct, 0, sizeof(Tstruct));
				EXEC SQL FETCH tvcursorexistentes2 INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("PerfilUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idPerfil",tstruct.idRole);
				xml_g->addItem("dsPerfil",RTrim(tstruct.cnmRole));
				xml_g->closeTag();
			}
			xml_g->closeTag();
			EXEC SQL CLOSE tvcursorexistentes2;
	
			EXEC SQL OPEN tvcursorrelacionados2;
	
			xml_g->createTag("PerfisRelacionados");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
	
			for(;;) {
				memset( &tstruct, 0, sizeof(Tstruct));
				EXEC SQL FETCH tvcursorrelacionados2 INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("PerfilUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idPerfil",tstruct.idRole);
				xml_g->addItem("dsPerfil",RTrim(tstruct.cnmRole));
				xml_g->closeTag();
			}
			EXEC SQL CLOSE tvcursorrelacionados2;
			xml_g->closeTag();
	
			xml_g->closeTag();
		}
	}
	catch(...)
	{
		throw;
	}
	
	ULOG_END("CGrp::GrpPrfRelacao()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int CGrp::GrpInserir(DOMNode*dnode,XMLGen*xml_g,
				     char* cLogUser)
{
	ULOG_START("CGrp::GrpInserir()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;

		struct 
		{ 
			VARCHAR stidGrupo[21+1];
			VARCHAR stnmGrupo[255+1];
			char    cidTIPOGRUPO[21+1];
		} stRegistro;

		int iAcumulador=0;
		int iAcumulador_cms=0;
        VARCHAR cdsTIPOGRUPO[256];
        int inCRI;

	EXEC SQL END DECLARE SECTION;

	//Processamento Principal

	//Declara variaveis auxiliares
	char *pzcdsGrupo;
	char *pzcidTIPOGRUPO;

	try
	{
			
		ZeraGrupo();

		//Se nao encontrar a proxima TAG entao acabaram os registros para alterar
		for( int indice=0; ; indice++ ) { 
	
			memset( &stRegistro, 0, sizeof(stRegistro) );
		
			//Se a DESCRICAO nao existir entao retornar com codigo de erro
			pzcdsGrupo = oSafePointer.getTag(dnode,"dsGrupo",indice); 
			
			if ( strlennull( pzcdsGrupo ) <= 0 )
				break;
	
			strcpy( (char*)stRegistro.stnmGrupo.arr, pzcdsGrupo ); 
			stRegistro.stnmGrupo.len = strlen( pzcdsGrupo );

            pzcidTIPOGRUPO = oSafePointer.getTag(dnode,"idTipoGrupoSelecionado",indice); 
			if( strlennull( pzcidTIPOGRUPO ) > 0 )
				strcpy( stRegistro.cidTIPOGRUPO, pzcidTIPOGRUPO );
			
			sqlca.sqlcode=0;
			EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
			EXEC SQL WHENEVER NOT FOUND CONTINUE;
			
			//Provisoriamente estamos utilizando a flag incri, que dever ser removida logo em breve
			EXEC SQL
			SELECT
				COUNT(1)
			INTO
				:inCRI
			FROM
				APOIO.TIPOGRUPO TIPOGRUPO
			WHERE
				UPPER(TIPOGRUPO.CDTIPOGRUPO) = 'CRI'
			AND
				TIPOGRUPO.IDTIPOGRUPO = :stRegistro.cidTIPOGRUPO;
	
			//Conta os casos ja existentes de descricao 
			EXEC SQL
				SELECT 
					COUNT(IDGRUPO) 
				INTO 
					:iAcumulador
				FROM 
					ACESSO.GRUPO
				WHERE 
					UPPER(NMGRUPO) = UPPER(TRIM(:stRegistro.stnmGrupo)) 
				AND                           
					DTEXCLUSAO IS NULL;
					
					
			//Conta os casos ja existentes de descricao 
			EXEC SQL
				SELECT 
					COUNT(IDGRUPO) 
				INTO 
					:iAcumulador_cms
				FROM 
					ACESSO.GRUPO
				WHERE 
					UPPER(NMGRUPO) = UPPER(TRIM(:stRegistro.stnmGrupo));
					
	
			//Se nao houver o caso desta descricao entao pode Inserir
			if ((iAcumulador == 0) && (iAcumulador_cms == 0)) 
			{
				//Pega um ID único 
				EXEC SQL
					SELECT 
						ACESSO.GRUPOSQ.NEXTVAL
					INTO 
						:stRegistro.stidGrupo
					FROM DUAL;
	
				//Insere o ID novo
				EXEC SQL 
					INSERT INTO ACESSO.GRUPO 
					( 
						  IDGRUPO
						, NMGRUPO
						, IDTIPOGRUPO
						, IDUSUARIOALTERACAO
						, DTULTIMAALTERACAO 
					)
				VALUES
					( 
						  :stRegistro.stidGrupo
						, TRIM(SUBSTR(:stRegistro.stnmGrupo,1,255))
						, :stRegistro.cidTIPOGRUPO
						, :cLogUserOra
						, SYSDATE 
					);

                // recupera a descricao do tipo do grau    
				memset( &cdsTIPOGRUPO, 0, sizeof(cdsTIPOGRUPO) );

                EXEC SQL 
                SELECT 
                    DSTIPOGRUPO 
                INTO
                    :cdsTIPOGRUPO
                FROM 
                    APOIO.TIPOGRUPO 
                WHERE 
                    IDTIPOGRUPO = :stRegistro.cidTIPOGRUPO ;

				Add( 	
					(char*)stRegistro.stidGrupo.arr,
					(char*)stRegistro.stnmGrupo.arr,
                    (char*)cdsTIPOGRUPO.arr,
                    (char*)stRegistro.cidTIPOGRUPO,
                    0
				);
			}
			else
			{
				if ((iAcumulador == 0) && (iAcumulador_cms > 0))
				{
                    //
					//Altera a descricao do Grupo POSSUI ERRO 
					EXEC SQL 
						UPDATE 
							ACESSO.GRUPO
						SET 
							DTEXCLUSAO = NULL
						WHERE 
							UPPER(NMGRUPO) = UPPER(TRIM(SUBSTR(:stRegistro.stnmGrupo,1,255)));

					ULOG_END("int CGrp::GrpInserir(DOMNode*dnode,XMLGen*xml_g, char* cLogUser)");
					return 0;		
				}
				else
				{
				   ULOG_END(" CGrp::GrpInserir()");
				   return 5;//Nome ja existe
				}
			}
			if(sqlca.sqlcode) { 
				ULOG_END(" CGrp::GrpInserir()");
				return 4; 
			} 
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END(" CGrp::GrpInserir()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int CGrp::GrpLista(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START(" CGrp::GrpLista()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 
		struct 
		{
			VARCHAR stidGrupo[21+1]; 
			VARCHAR stnmGrupo[255+1];
			VARCHAR stidTipoGrupo[255+1];
			VARCHAR stsgTipoGrupo[255+1];
			VARCHAR stdsTipoGrupo[255+1];
		} stRegistro;
		struct 
		{
			short sidGrupo;
			short snmGrupo;
			short idTipoGrupo;
			short sgTipoGrupo;
			short dsTipoGrupo;
		} stIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	memset( &stRegistro, 0, sizeof(stRegistro));

	EXEC SQL WHENEVER SQLERROR GOTO GotoGrpLista;
	EXEC SQL WHENEVER NOT FOUND DO break;
	sqlca.sqlcode=0;
	
	EXEC SQL 
	DECLARE 
		CursorGrpLista CURSOR FOR
	SELECT 
		IDGRUPO
	  , NMGRUPO 
	  , TIPOGRUPO.IDTIPOGRUPO
	  , TIPOGRUPO.CDTIPOGRUPO
	  , TIPOGRUPO.DSTIPOGRUPO
	FROM 
		ACESSO.GRUPO GRUPO,
		APOIO.TIPOGRUPO TIPOGRUPO
	WHERE
		GRUPO.IDTIPOGRUPO = TIPOGRUPO.IDTIPOGRUPO
	AND
		IDGRUPO > 0
	AND
		DTEXCLUSAO IS NULL
	ORDER BY 
		UPPER(NMGRUPO);

	EXEC SQL OPEN CursorGrpLista;
	
	xml_g->createTag("GruposUsuarioVO");
	xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
	for(;;) {
		EXEC SQL FETCH CursorGrpLista INTO :stRegistro:stIndicator;
		xml_g->createTag("GrupoUsuarioVO");
		xml_g->addItem("idGrupo", (char*)stRegistro.stidGrupo.arr);
		xml_g->addItem("dsGrupo", (char*)stRegistro.stnmGrupo.arr);
		xml_g->addItem("idTipoGrupoSelecionado", (char*)stRegistro.stidTipoGrupo.arr);
		xml_g->addItem("dsTipoGrupoSelecionado", (char*)stRegistro.stdsTipoGrupo.arr);
		xml_g->closeTag();
	}
	xml_g->closeTag();
	EXEC SQL CLOSE CursorGrpLista;
    
    ULOG_END("CGrp::GrpInserir()");
	return 0;

//Tratamento de Exception
GotoGrpLista:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int CGrp::GrpListaPar(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CGrp::GrpListaPar()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 
		struct 
		{
			VARCHAR stidGrupo[21+1]; 
			VARCHAR stnmGrupo[256];
			VARCHAR stidTipoGrupo[256];
			VARCHAR stsgTipoGrupo[256];
			VARCHAR stdsTipoGrupo[256];
		} stRegistro;
		struct 
		{
			short sidGrupo;
			short snmGrupo;
			short idTipoGrupo;
			short sgTipoGrupo;
			short dsTipoGrupo;
		} stIndicator;
		char* pc;
		char  vcLike[256];
		char  cidTipoGrupo[21+1];
        char  csgTipoGrupo[256];
        char  cinTipo[21+1];
        char  cidUsuario[21+1];
	EXEC SQL END DECLARE SECTION;


	//Processamento Principal
    memset( cidUsuario  , 0, sizeof(cidUsuario)   );
    memset( cidTipoGrupo, 0, sizeof(cidTipoGrupo) );
	memset( csgTipoGrupo, 0, sizeof(csgTipoGrupo) );
	memset( cinTipo     , 0, sizeof(cinTipo)      );
	memset( &stRegistro , 0, sizeof(stRegistro)   );
	memset( &stIndicator, 0, sizeof(stIndicator)  );

	EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	EXEC SQL WHENEVER NOT FOUND DO break;
	sqlca.sqlcode=0;

	pc = oSafePointer.getTag(dnode,"inTipo",0);
	if( strlennull( pc ) > 0 )
		strcpy( cinTipo, pc );
	else 
		strcpy( cinTipo, "0" );

	if( strcmp( cinTipo, "1" ) == 0 )
	{
		EXEC SQL 
		DECLARE 
			CursorGrpListaParInTipo CURSOR for
		SELECT 
			0  IDGRUPO,
			'' NMGRUPO,
			TIPOGRUPO.IDTIPOGRUPO,
			TIPOGRUPO.CDTIPOGRUPO,
			TIPOGRUPO.DSTIPOGRUPO
		FROM 
			APOIO.TIPOGRUPO TIPOGRUPO
		ORDER BY 
			UPPER(TIPOGRUPO.DSTIPOGRUPO);

		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL WHENEVER NOT FOUND DO break;

		EXEC SQL OPEN CursorGrpListaParInTipo;

		xml_g->createTag("GrupoUsuarioVO");
		xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );

		for(;;) 
		{
			EXEC SQL 
			FETCH 
				CursorGrpListaParInTipo 
			INTO 
				:stRegistro:stIndicator;

			xml_g->createTag("TiposGrupo");

				xml_g->addItem("idTipoGrupo",(char*)stRegistro.stidTipoGrupo.arr);
				xml_g->addItem("dsTipoGrupo",(char*)stRegistro.stdsTipoGrupo.arr);

			xml_g->closeTag();//TiposGrupo

			memset( &stRegistro, 0, sizeof(stRegistro));
		}
		xml_g->closeTag();//GrupoUsuarioVO

		EXEC SQL CLOSE CursorGrpListaParInTipo;
	}//if( strcmp( cinTipo, "1" )
	else
	{

		pc = oSafePointer.getTag(dnode,"idUsuario",0);
		if( strlennull( pc ) > 0 )
			strcpy( cidUsuario, pc );
		else
			strcpy( cidUsuario, "-1" );

		pc = oSafePointer.getTag(dnode,"dsGrupo",0);
		if( strlennull( pc ) > 0 )
			sprintf( vcLike, "%s%%", pc );
		else 
			strcpy( vcLike, "-1" );

		pc = oSafePointer.getTag(dnode,"idTipoGrupoSelecionado",0);
		if( strlennull( pc ) > 0 )
			strcpy( cidTipoGrupo, pc );
		else
			strcpy( cidTipoGrupo, "-1" );

		//Embora a TAG seja de sescricao, o conteudo eh uma sigla (apenas nesta pesquisa)
		pc = oSafePointer.getTag(dnode,"dsTipoGrupoSelecionado",0);
		if( strlennull( pc ) > 0 )
			strcpy( csgTipoGrupo, pc );
		else
			strcpy( csgTipoGrupo, "-1" );
			
		if( strcmp( cidUsuario ,"-1") == 0 )
		{
			EXEC SQL 
			DECLARE 
				CursorGrpListaPar CURSOR for
			SELECT 
				G.IDGRUPO, 
				G.NMGRUPO,
				T.IDTIPOGRUPO,
				T.CDTIPOGRUPO,
				T.DSTIPOGRUPO
			FROM 
				ACESSO.GRUPO     G,
				APOIO.TIPOGRUPO  T
			WHERE 
				( G.IDTIPOGRUPO = T.IDTIPOGRUPO )
			AND		
				G.IDGRUPO > 0
			AND
				G.DTEXCLUSAO IS NULL
			AND
				( UPPER(G.NMGRUPO) LIKE UPPER(:vcLike) OR :vcLike = '-1' )
			AND
				( G.IDTIPOGRUPO = :cidTipoGrupo OR :cidTipoGrupo = '-1' )
			AND
				( UPPER(T.CDTIPOGRUPO) = :csgTipoGrupo OR :csgTipoGrupo = '-1' )
			ORDER BY 
				UPPER(G.NMGRUPO);
	
			EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
			EXEC SQL WHENEVER NOT FOUND DO break;
	
			EXEC SQL OPEN CursorGrpListaPar;
	
			xml_g->createTag("GruposUsuarioVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			for(;;) 
			{
				EXEC SQL 
				FETCH 
					CursorGrpListaPar 
				INTO 
					:stRegistro:stIndicator;
	
				xml_g->createTag("GrupoUsuarioVO");
	
					xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
					xml_g->addItem("idGrupo",(char*)stRegistro.stidGrupo.arr);
					xml_g->addItem("dsGrupo",(char*)stRegistro.stnmGrupo.arr);
					xml_g->addItem("idTipoGrupoSelecionado",(char*)stRegistro.stidTipoGrupo.arr);
					xml_g->addItem("dsTipoGrupoSelecionado",(char*)stRegistro.stdsTipoGrupo.arr);
	
				xml_g->closeTag();//GrupoUsuarioVO
				memset( &stRegistro, 0, sizeof(stRegistro));
			}
			xml_g->closeTag();
	
			EXEC SQL CLOSE CursorGrpListaPar;
		}//if( strlennull( cidUsuario ) <= 0 )
		else
		{
			EXEC SQL 
			DECLARE 
				CursorGrpListaParUsuario CURSOR for
			SELECT 
				GRUPO.IDGRUPO, 
				GRUPO.NMGRUPO,
				TIPOGRUPO.IDTIPOGRUPO,
				TIPOGRUPO.CDTIPOGRUPO,
				TIPOGRUPO.DSTIPOGRUPO
			FROM 
				ACESSO.USUARIOGRUPO USUARIOGRUPO,
				ACESSO.GRUPO        GRUPO,
				APOIO.TIPOGRUPO     TIPOGRUPO
			WHERE 
				GRUPO.IDGRUPO = USUARIOGRUPO.IDGRUPO
			AND
				GRUPO.IDTIPOGRUPO = TIPOGRUPO.IDTIPOGRUPO
			AND
				GRUPO.IDGRUPO > 0
			AND
				GRUPO.DTEXCLUSAO IS NULL
			AND
				( USUARIOGRUPO.IDPESSOAUSUARIO = :cidUsuario OR :cidUsuario = '-1' )
			AND
				( UPPER(GRUPO.NMGRUPO) LIKE UPPER(:vcLike) OR :vcLike = '-1' )
			AND
				( GRUPO.IDTIPOGRUPO = :cidTipoGrupo OR :cidTipoGrupo = '-1' )
			AND
				( UPPER(TIPOGRUPO.CDTIPOGRUPO) = :csgTipoGrupo OR :csgTipoGrupo = '-1' )
			ORDER BY 
				UPPER(GRUPO.NMGRUPO);
	
			EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
			EXEC SQL WHENEVER NOT FOUND DO break;
	
			EXEC SQL OPEN CursorGrpListaParUsuario;
	
			xml_g->createTag("GruposUsuarioVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			for(;;) 
			{
				EXEC SQL 
				FETCH 
					CursorGrpListaParUsuario 
				INTO 
					:stRegistro:stIndicator;
	
				xml_g->createTag("GrupoUsuarioVO");
	
					xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
					xml_g->addItem("idGrupo",(char*)stRegistro.stidGrupo.arr);
					xml_g->addItem("dsGrupo",(char*)stRegistro.stnmGrupo.arr);
					xml_g->addItem("idTipoGrupoSelecionado",(char*)stRegistro.stidTipoGrupo.arr);
					xml_g->addItem("dsTipoGrupoSelecionado",(char*)stRegistro.stdsTipoGrupo.arr);
	
				xml_g->closeTag();//GrupoUsuarioVO
				memset( &stRegistro, 0, sizeof(stRegistro));
			}
			xml_g->closeTag();
	
			EXEC SQL CLOSE CursorGrpListaParUsuario;
		}//else if( strlennull( cidUsuario ) <= 0 )
	}//else if( strcmp( cinTipo, "1" )
    ULOG_END(" CGrp::GrpListaPar()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int CGrp::GrpCnlRelaciona(DOMNode*dnode, XMLGen*xml_g,
				          char* cLogUser)
{
	ULOG_START(" CGrp::GrpCnlRelaciona()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;

		struct Tstruct {
			int idGrupoCanal;
			int idGrupo;
			int idCanal;
		} tstruct;

		struct Tstruct2 {
			int idCanal;
			char cnmCanal[256];
		} tstruct2;

		struct Tstructindicator {
			short sidGrupoCanal, sidGrupo, sidCanal;
		} tstructindicator;

		struct Tstructindicator2 {
			short sidCanal, snmCanal;
		} tstructindicator2;

		int iAcumulador;

	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
			
		memset( &tstruct, 0, sizeof(Tstruct) );
		memset( &tstruct2, 0, sizeof(Tstruct2) );
		memset( &tstructindicator, 0, sizeof(Tstructindicator) );
		memset( &tstructindicator2, 0, sizeof(Tstructindicator2) );
	
		//Pega o idGrupo que sera utilizado na ralacao
		if ( ( tstruct.idGrupo = atoi( oSafePointer.getTag( dnode, "idGrupo", 0  ) ) )  <= 0 ) 
		{
		    ULOG_END("CGrp::GrpCnlRelaciona()");
			return 3;//idGrupo esta nulo
		}
	
		sqlca.sqlcode=0;
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
	
		EXEC SQL 
		SELECT COUNT(1)
		INTO :iAcumulador
		FROM ACESSO.GRUPOCANAL
		WHERE IDGRUPO = :tstruct.idGrupo;
	
		//Antes de inserir as novas relacoes, deve-se apagar todas, se existirem
		if (iAcumulador>0) {
			EXEC SQL 
			DELETE FROM ACESSO.GRUPOCANAL 
			WHERE IDGRUPO = :tstruct.idGrupo;
		}
	
		//Verifica se o comando DELETE obteve sucesso
		if(sqlca.sqlcode == 0 )
		{
			char* pc;
	
			//Pega todos os idCanal que existem no XML e insere
			for(int indice=0;;indice++) 
			{
	
				//Se tstruct.idCanal for igual a zero, entao acabou os ids
				pc = oSafePointer.getTag( dnode, "idCanal", indice  );
				if ( strlen( pc ) == 0 ) 
					break;
	
				tstruct.idCanal = atoi( pc );
	
				sqlca.sqlcode=0;
	
				//Pega um id unico e sequencia para a insercao
				EXEC SQL
				SELECT acesso.GrupoCanalsq.nextval
				INTO :tstruct.idGrupoCanal
				FROM dual;
	
				//Insere item a item
				EXEC SQL 
					INSERT INTO ACESSO.GRUPOCANAL 
					( 
						  IDGRUPOCANAL
						, IDGRUPO
						, IDCANAL
						, IDUSUARIOALTERACAO
						, DTULTIMAALTERACAO 
					)
				VALUES
					( 
						  :tstruct.idGrupoCanal
						, :tstruct.idGrupo
						, :tstruct.idCanal
						, :cLogUserOra
						, SYSDATE 
					);
	
				//Se der algum erro, desfaz tudo
				if(sqlca.sqlcode)
				{
				    ULOG_END("CGrp::GrpCnlRelaciona()");
					return 2;//Falha ao tentar inserir os canais relacionados
				}
			}//for( indice=1;;indice++) 
		}// if(sqlca.sqlcode == 0 )
		else
		{
		    ULOG_END("CGrp::GrpCnlRelaciona()");
			return 1;//Falha ao tentar limpar os canais relacionados
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CGrp::GrpCnlRelaciona()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int CGrp::GrpImnRelaciona(DOMNode*dnode, XMLGen*xml_g, char* cLogUser)
{
	ULOG_START("CGrp::GrpImnRelaciona()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;
		char* cidGrupo;
		char* cidSubSistema;
		char* cidItemMenu;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Pega o idGrupo e o idSubSistema que serao utilizados na ralacao
		cidGrupo = oSafePointer.getTag( dnode, "idGrupo", 0  );
		cidSubSistema = oSafePointer.getTag(dnode,"idSubSistema",0);

		if( strlennull( cidGrupo ) <= 0 )
		{
		    ULOG_END(" CGrp::GrpImnRelaciona()");
			return 1;
		}
		if( strlennull( cidSubSistema ) <= 0 )
		{
			ULOG_END(" CGrp::GrpImnRelaciona()");
			return 2;
		}
	
		sqlca.sqlcode=0;
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
		EXEC SQL 
		DELETE FROM 
			ACESSO.GRUPOITEMMENU
		WHERE 
			IDGRUPOITEMMENU IN
			(
				SELECT 
					GRUPOITEMMENU.IDGRUPOITEMMENU
				FROM
					ACESSO.GRUPOITEMMENU GRUPOITEMMENU,
					ACESSO.ITEMMENU ITEMMENU
				WHERE
					GRUPOITEMMENU.IDITEMMENU = ITEMMENU.IDITEMMENU
				AND
					GRUPOITEMMENU.IDGRUPO = :cidGrupo
				AND
					ITEMMENU.IDSUBSISTEMA = :cidSubSistema
			);
		sqlca.sqlcode=0;
	
		//Pega todos os idItemMenu que existem no XML e insere
		for(int indice=0;;indice++) 
		{

			cidItemMenu = oSafePointer.getTag( dnode, "idItemMenu", indice  );
			if ( strlennull( cidItemMenu ) <= 0 )
				break;

			sqlca.sqlcode=0;

			EXEC SQL WHENEVER SQLERROR GOTO ErrorF;

			//Insere item a item
			EXEC SQL 
				INSERT INTO ACESSO.GRUPOITEMMENU 
				( 
					  IDGRUPOITEMMENU
					, IDGRUPO
					, IDITEMMENU
					, IDUSUARIOALTERACAO
					, DTULTIMAALTERACAO 
				)
			VALUES
				( 
					  ACESSO.GRUPOITEMMENUSQ.NEXTVAL
					, :cidGrupo
					, :cidItemMenu
					, :cLogUserOra
					, SYSDATE 
				);
		}//for( indice=1;;indice++) 
	}
	catch(...)
	{
		throw;
	}
    ULOG_END("CGrp::GrpImnRelaciona()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int CGrp::GrpEditar(DOMNode*dnode,XMLGen*xml_g,
				    char* cLogUser)
{
	ULOG_START("CGrp::GrpEditar()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
        
        char * cdParametro;
		VARCHAR stidGrupo1[21+1];
		VARCHAR stidGrupo2[21+1];
		VARCHAR stidGrupo3[21+1];

        short statIdGrupo1 = -1;
        short statIdGrupo2 = -1;
        short statIdGrupo3 = -1;

		char* cLogUserOra = cLogUser;
		struct 
		{ 
			VARCHAR stidGrupo[21+1];
			VARCHAR stnmGrupo[255+1];
			char    cidTIPOGRUPO[21+1];
		} stRegistro;
		int iAcumulador;

   		VARCHAR stdsTipoGrupo[256];
		short   idsTipoGrupo;
		VARCHAR stidTipoGrupo[21+1];
		short   iidTipoGrupo;
		int     iMesmoTipo = 0;
		short   sMesmoTipo;
		int inCRI;
		int inCRIAtual = 0;
		int inAlteracaoTipoGrupo = 0;
        int flagMsg = 0;                // Indica qual mensagem de aviso serah exibida
	EXEC SQL END DECLARE SECTION;

	//Declara variaveis auxiliares
	char *pcid;
	char *pcnm;
	char* pzcidTIPOGRUPO;

	ZeraGrupo();
	
	//Se nao encontrar a proxima TAG entao acabaram os registros para alterar
	for(int indice=0; ; indice++ ) 
	{ 
		memset( &stRegistro, 0, sizeof(stRegistro));
		memset( &stdsTipoGrupo, 0, sizeof(stdsTipoGrupo));
		memset( &stidTipoGrupo, 0, sizeof(stidTipoGrupo));

		//Se o ID ou DESCRICAO nao existir entao retornar com codigo de erro
		if ( ( ( pcid = oSafePointer.getTag(dnode,"idGrupo",indice) ) == NULL ) ||
			 ( ( pcnm = oSafePointer.getTag(dnode,"dsGrupo",indice) ) == NULL ) ) 
		{
			break;
		}

		//Se o ID ou DESCRICAO estiver vazio entao retornar com codigo de erro
		if ( strlen( pcid ) == 0 )
		{
	        ULOG_END(" CGrp::GrpEditar()");
			return 1;//idGrupo esta nulo
		}
		if ( strlen( pcnm ) == 0 )
		{
			ULOG_END(" CGrp::GrpEditar()");
			return 2;//dsGrupo esta nulo
		}

		strcpy((char*)stRegistro.stidGrupo.arr, pcid);
		stRegistro.stidGrupo.len = strlen( pcid );
		strcpy((char*)stRegistro.stnmGrupo.arr, pcnm);
		stRegistro.stnmGrupo.len = strlen( pcnm );

		
        pzcidTIPOGRUPO = oSafePointer.getTag( dnode, "idTipoGrupoSelecionado", indice );
		if( strlennull( pzcidTIPOGRUPO ) > 0 )
		    strcpy( stRegistro.cidTIPOGRUPO, pzcidTIPOGRUPO );
		
		sqlca.sqlcode=0;

		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		
		//Provisoriamente estamos utilizando a flag incri, que dever ser removida logo em breve
		EXEC SQL
		SELECT
			COUNT(1)
		INTO
			:inCRI
		FROM
			APOIO.TIPOGRUPO TIPOGRUPO
		WHERE
			UPPER(TIPOGRUPO.CDTIPOGRUPO) = 'CRI'
		AND
			TIPOGRUPO.IDTIPOGRUPO = :stRegistro.cidTIPOGRUPO;

		//Verifica se o grupo tem atendimento atendimento
		EXEC SQL
		SELECT
			GRUPO.IDTIPOGRUPO,
			DECODE( GRUPO.IDTIPOGRUPO, :stRegistro.cidTIPOGRUPO, 1, 0 ),
			DECODE( GRUPO.IDTIPOGRUPO, NULL, 0, 1 )
		INTO
			:stidTipoGrupo:iidTipoGrupo,
			:iMesmoTipo:sMesmoTipo,
            :flagMsg
		FROM 
			ANDAMENTO.ANDAMENTO ANDAMENTO,
			ACESSO.GRUPO GRUPO
		WHERE
			ANDAMENTO.IDGRUPO = GRUPO.IDGRUPO
		AND
			ANDAMENTO.IDGRUPO = :stRegistro.stidGrupo
		AND
			ROWNUM < 2;
		//Na pesquisa acima utilizamos "ROWNUM < 2" para questao de velocidade, 
		//sendo que soh preciso saber se o grupo tem atendimento ou nao
		
        //
        //   Validacao para alteracao do grupo para CRI.
        //
        if ( flagMsg == 0 )
        {  
            EXEC SQL 
    		SELECT
    			GRUPO.IDTIPOGRUPO,
    			DECODE( GRUPO.IDTIPOGRUPO, :stRegistro.cidTIPOGRUPO, 1, 0 ),
    			DECODE( GRUPO.IDTIPOGRUPO, NULL, 0, 2 )
    		INTO
    			:stidTipoGrupo:iidTipoGrupo,
    			:iMesmoTipo:sMesmoTipo,
                :flagMsg
            FROM 
                Contatoadm.Contatogrupo CONTATOGRUPO,
    			ACESSO.GRUPO GRUPO
            WHERE
                CONTATOGRUPO.idGrupo = GRUPO.idGrupo
            AND
                GRUPO.idGrupo = :stRegistro.stidGrupo
            AND
                ROWNUM < 2;
    
            if ( flagMsg == 0 )
            {
                EXEC SQL 
        		SELECT
        			GRUPO.IDTIPOGRUPO,
        			DECODE( GRUPO.IDTIPOGRUPO, :stRegistro.cidTIPOGRUPO, 1, 0 ),
        			DECODE( GRUPO.IDTIPOGRUPO, NULL, 0, 3 )
        		INTO
        			:stidTipoGrupo:iidTipoGrupo,
        			:iMesmoTipo:sMesmoTipo,
                    :flagMsg
                FROM
                    contatoadm.grupoperfil GRUPOPERFIL,
                    ACESSO.GRUPO GRUPO
                WHERE
                    GRUPOPERFIL.IDGRUPO = GRUPO.IDGRUPO
                AND
                    GRUPO.idGrupo = :stRegistro.stidGrupo
                AND
                    GRUPOPERFIL.DTEXPIRACAO IS NULL
                AND
                    ROWNUM < 2;
        
                if ( flagMsg == 0 )
                {
                    EXEC SQL 
            		SELECT
            			GRUPO.IDTIPOGRUPO,
            			DECODE( GRUPO.IDTIPOGRUPO, :stRegistro.cidTIPOGRUPO, 1, 0 ),
            			DECODE( GRUPO.IDTIPOGRUPO, NULL, 0, 4 )
            		INTO
            			:stidTipoGrupo:iidTipoGrupo,
            			:iMesmoTipo:sMesmoTipo,
                        :flagMsg
                    FROM 
                        Customer.LinhaTelefonicagrupo FONEGRUPO,
                        ACESSO.GRUPO GRUPO
                    WHERE
                        FONEGRUPO.IDGRUPO = GRUPO.IDGRUPO
                    AND
                        GRUPO.idGrupo = :stRegistro.stidGrupo
                    AND
                        FONEGRUPO.DTEXCLUSAO IS NULL
                    AND
                        ROWNUM < 2;
                }
            }
        }


		//Conta os casos de ja existentes de descricao
		EXEC SQL
			SELECT 
				COUNT(IDGRUPO) 
			INTO 
				:iAcumulador
			FROM 
				ACESSO.GRUPO
			WHERE 
				UPPER(NMGRUPO) = UPPER(TRIM(:stRegistro.stnmGrupo))
			AND 
				IDGRUPO <> :stRegistro.stidGrupo
			AND
				DTEXCLUSAO IS NULL;

		//Se nao houver o caso desta descricao entao pode atualizar
		if( iAcumulador == 0 ) 
		{
			//Verifica se achou em atendimento o Grupo (na verdade eu busquei por grupo
			//mas para evitar fazer outra pesquisa eu ja retornei o idTipoGrupo
			if( stidTipoGrupo.len > 0 )
			{
				//Verifica se o tipo eh o mesmo, se for pode alterar na boa
				if( iMesmoTipo == 0 )
				{
					//Se o tipo de grupo nao eh o mesmo, edita o grupo, mas nao muda o idTipoGrupo
					strcpy( stRegistro.cidTIPOGRUPO, (char*)stidTipoGrupo.arr );
					stRegistro.cidTIPOGRUPO[stidTipoGrupo.len] = 0;
					//Se entrou aqui, entao iMesmoTipo fica com valor 0, exibindo um popup de aviso
				}
			}//if( stidTipoGrupo.len > 0 )
			else
			{
				//Se nao achou idTipoGrupo em atendimento eh porque o grupo nao tem atendimento

				//Se nao tem grupo em atendimento nao da mensagem de aviso, eu utilizo a variavel
				//iMesmoTipo para dar aviso, caso ela seja 0, entao como nao tem atendimento
				//ela passa para 1 e o aviso nao ocorre
				iMesmoTipo = 1;
				
			}//else if( stidTipoGrupo.len > 0 )

			//Verifica se houve mudanca no tipo de grupo
			//Se o idtipogrupo mais o idgrupo nao retornarem nada, entao mudou o tipo
			//Lembrando que verificamos primeiro se tem atendimento, isto porque se tem
			//atendimento entao o idtipogrupo fica igual ao do grupo, sobrepondo o que
			//veio no parametro
			EXEC SQL
			SELECT
				DECODE( COUNT(1), 0, 1, 0 )
			INTO
				:inAlteracaoTipoGrupo
			FROM
				ACESSO.GRUPO
			WHERE
				IDGRUPO = :stRegistro.stidGrupo
			AND
				IDTIPOGRUPO = :stRegistro.cidTIPOGRUPO;

			//Verifica se houve mudanca no tipo do grupo
			if( inAlteracaoTipoGrupo  )
			{
				EXEC SQL
				SELECT
					COUNT(IDTIPOGRUPO)
				INTO
					:inCRIAtual
				FROM
					ACESSO.GRUPO
				WHERE
					IDGRUPO = :stRegistro.stidGrupo
				AND
					IDTIPOGRUPO = ( SELECT IDTIPOGRUPO FROM APOIO.TIPOGRUPO WHERE UPPER(CDTIPOGRUPO) = 'CRI' );
					
				//Entra aqui se o grupo era CRI e esta sendo modificado
				//entao tem apagar as relacoes com contato e dar aviso
				//Tambem apaga relacoes com linhas
				if( inCRIAtual )
				{
					//Apaga a relacao de grupoperfil com contato
					EXEC SQL
					DELETE 
						CONTATOADM.CONTATOPERFIL
					WHERE
						IDGRUPOPERFIL IN 
						(
							SELECT 
	                            IDGRUPOPERFIL
							FROM
								CONTATOADM.GRUPOPERFIL
							WHERE
								IDGRUPO = :stRegistro.stidGrupo
						);
	
					//Apaga o grupoperfil
					EXEC SQL
					DELETE FROM
						CONTATOADM.GRUPOPERFIL
					WHERE
						IDGRUPO = :stRegistro.stidGrupo;
						
			        //Apaga a relacao de grupo com linha
			        EXEC SQL
			        UPDATE CUSTOMER.LINHATELEFONICAGRUPO
			        SET
			            DTEXCLUSAO = SYSDATE,
			            DTULTIMAALTERACAO = SYSDATE,
			            IDUSUARIOALTERACAO = :cLogUserOra
			        WHERE
			            IDGRUPO = :stRegistro.stidGrupo
			        AND
			            DTEXCLUSAO IS NULL;

				}//if( inCRIAtual )
			}//if( !iMesmoTipo  )

            // Grupos atrelados a retenção são parametrizados e troca de nome
            // precisa manter parâmetro atualizado -- Set/08 -- Cassio
			EXEC SQL 
                SELECT
                    IDGRUPO
                INTO
                    :stidGrupo1:statIdGrupo1
                FROM
                    ACESSO.GRUPO
                WHERE
                    UPPER(NMGRUPO) = (SELECT UPPER(DSVALORPARAMETRO) 
                                        FROM APOIO.PARAMETRO
                                       WHERE CDPARAMETRO = 'PORTABILIDADE_GRUPO_PJ_PMES');
			EXEC SQL 
                SELECT
                    IDGRUPO
                INTO
                    :stidGrupo2:statIdGrupo2
                FROM
                    ACESSO.GRUPO
                WHERE
                    UPPER(NMGRUPO) = (SELECT UPPER(DSVALORPARAMETRO) 
                                        FROM APOIO.PARAMETRO
                                       WHERE CDPARAMETRO = 'PORTABILIDADE_GRUPO_PJ_GCN');
			EXEC SQL 
                SELECT
                    IDGRUPO
                INTO
                    :stidGrupo3:statIdGrupo3
                FROM
                    ACESSO.GRUPO
                WHERE
                    UPPER(NMGRUPO) = (SELECT UPPER(DSVALORPARAMETRO) 
                                        FROM APOIO.PARAMETRO
                                       WHERE CDPARAMETRO = 'PORTABILIDADE_GRUPO_PF_TODAS');

            CONVIND(stidGrupo1,statIdGrupo1);
            CONVIND(stidGrupo2,statIdGrupo2);
            CONVIND(stidGrupo3,statIdGrupo3);

            ULOG("(1) idGrupoUpdate=%s",stRegistro.stidGrupo.arr);
            ULOG("(1)      idGrupo1=%s",stidGrupo1.arr);
            ULOG("(1)      idGrupo2=%s",stidGrupo2.arr);
            ULOG("(1)      idGrupo3=%s",stidGrupo3.arr);

			//Altera a descricao do Grupo
			EXEC SQL 
			UPDATE 
				ACESSO.GRUPO
			SET 
				NMGRUPO = UPPER(TRIM(SUBSTR(:stRegistro.stnmGrupo,1,255))),
				IDTIPOGRUPO = :stRegistro.cidTIPOGRUPO,
				IDUSUARIOALTERACAO = :cLogUserOra, 
				DTULTIMAALTERACAO  = SYSDATE
			WHERE 
				IDGRUPO = :stRegistro.stidGrupo;
            //
            // Atualiza o parâmetro correspondente ao grupo alterado
            if ( strcmp((char*)stidGrupo1.arr,(char*)stRegistro.stidGrupo.arr)==0 )
            {
                cdParametro = "PORTABILIDADE_GRUPO_PJ_PMES";
                ULOG("CDPARAMETRO=%s",cdParametro);
				EXEC SQL
                    UPDATE APOIO.PARAMETRO
                    SET DSVALORPARAMETRO = UPPER(:stRegistro.stnmGrupo)
                    WHERE CDPARAMETRO = :cdParametro;
            }
            else if ( strcmp((char*)stidGrupo2.arr,(char*)stRegistro.stidGrupo.arr)==0 )
            {
                cdParametro = "PORTABILIDADE_GRUPO_PJ_GCN";
                ULOG("CDPARAMETRO=%s",cdParametro);
				EXEC SQL
                    UPDATE APOIO.PARAMETRO
                    SET DSVALORPARAMETRO = UPPER(:stRegistro.stnmGrupo)
                    WHERE CDPARAMETRO = :cdParametro;
            }
            else if ( strcmp((char*)stidGrupo3.arr,(char*)stRegistro.stidGrupo.arr)==0 )
            {
                cdParametro = "PORTABILIDADE_GRUPO_PF_TODAS";
                ULOG("CDPARAMETRO=%s",cdParametro);
				EXEC SQL
                    UPDATE APOIO.PARAMETRO
                    SET DSVALORPARAMETRO = UPPER(:stRegistro.stnmGrupo)
                    WHERE CDPARAMETRO = :cdParametro;
            }

            // pega a descricao do tipo do grupo
            EXEC SQL 
            SELECT 
                DSTIPOGRUPO 
            INTO
				:stdsTipoGrupo:idsTipoGrupo
            FROM 
                APOIO.TIPOGRUPO 
            WHERE 
                IDTIPOGRUPO = :stRegistro.cidTIPOGRUPO;

			Add( (char*)stRegistro.stidGrupo.arr,
				 (char*)stRegistro.stnmGrupo.arr,
				 (char*)stdsTipoGrupo.arr,
				 (char*)stRegistro.cidTIPOGRUPO,
				 0
			);
		}
		else
		{
			ULOG_END(" CGrp::GrpEditar()");
			return 4;//O nome passado como parametro ja existe na base
		}
	}//for(int indice=0; ; indice++ )

	if( iMesmoTipo )
	{
		if( inCRIAtual )
		{
		    ULOG_END("int CGrp::GrpEditar(DOMNode*dnode,XMLGen*xml_g,char* cLogUser)");
			return 6;//O GRUPO era CRI sem processos e tinha relacoes com contato, as relacoes foram apagadas, tem que avisar
		}
		else
		{
		    ULOG_END(" CGrp::GrpEditar()");
			return 0;//Sucesso
		}
	}
	else
    {
        if ( flagMsg == 1 )
        {
		    ULOG_END(" CGrp::GrpEditar()");
		    return 5;//Aviso de grupo em atendimento, nao pode mudar o idTipoAtendimento
		}
        else if ( flagMsg == 2 )
             {
        	      ULOG_END(" CGrp::GrpEditar()");
        	      return 7;//Aviso de grupo associado a contatogrupo
        	 }
        else if ( flagMsg == 3 )
             {
                 ULOG_END(" CGrp::GrpEditar()");
                 return 8;//Aviso de grupo associado a contatoperfil
             }
        else
        {
            ULOG_END(" CGrp::GrpEditar()");
            return 9;//Aviso de grupo associado a linhatelefonicagrupo
        }
       
    }

//Tratamento de Exception
ErrorF:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int CGrp::GrpRemover(DOMNode*dnode, XMLGen*xml_g,
				     char* cLogUser)
{
	ULOG_START(" CGrp::GrpRemover()");
	
	// Declarar Estruturas
	struct sqlca sqlca; 
	
	// Declarar Objetos
	CSafePointer oSafePointer;

	// Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		long idGrupo;
		int  iCount;
		VARCHAR stidTipoSequencia[21+1];
		char* cLogUserAux = cLogUser;
	EXEC SQL END DECLARE SECTION;

	//Declara variaveis auxiliares
	char *pc;
	//Se o ID nao for numerico entao retornar com codigo de erro
	pc = oSafePointer.getTag(dnode,"idGrupo",0);
	if ( pc == NULL )
	{
	    ULOG_END(" CGrp::GrpRemover()");   
		return 1;//idgrupo nulo
	}

	//Verifica se o ID eh valido
	if ( ( idGrupo = atol( pc ) ) == 0 )
	{
		ULOG_END(" CGrp::GrpRemover()");
		return 2;//idgrupo invalido
	}

	sqlca.sqlcode=0;

	EXEC SQL WHENEVER SQLERROR GOTO GotoGrpRemover;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	//Verifica se o grupo existe e esta ativo
	EXEC SQL
	SELECT
		COUNT(1)
	INTO
		:iCount
	FROM
		ACESSO.GRUPO
	WHERE
		IDGRUPO = :idGrupo
	AND
		DTEXCLUSAO IS NULL;
	
	if( iCount == 0 )
	{
	    ULOG_END(" CGrp::GrpRemover()");
		return 3;//Grupo não existe ou previamente deletado
	}

	//Verifica se existe algum atendimento em andamento
	EXEC SQL
	SELECT
		COUNT(1)
	INTO
		:iCount
	FROM
		ANDAMENTO.ANDAMENTO
	WHERE
		IDGRUPO = :idGrupo
    AND ROWNUM < 2; // se existir ao menos um já é suficiente para impedir a exclusão
    
    //=============================================================================
    // Verificar em andamento já é suficiente para impedir a exclusao de um grupo
    // Out/2005 - Cassio
    //
	//EXEC SQL
	//SELECT
	//	COUNT(1)
	//INTO
	//	:iCount
	//FROM
	//	ATENDIMENTO.ATENDIMENTOGRUPOATUAL
	//WHERE
	//	IDGRUPO = :idGrupo;
    //=============================================================================

	if( iCount > 0 )
	{
	    ULOG_END(" CGrp::GrpRemover()");
		return 4;//Grupo pertence a um atendimento em andamento
    }
    //=============================================================================
    // Verificar em andamento já é suficiente para impedir a exclusao de um grupo
    // Out/2005 - Cassio
    //
	//Verifica se existe algum atendimento em andamento
	//EXEC SQL
	//SELECT
	//	COUNT(1)
	//INTO
	//	:iCount
	//FROM
	//	ATENDIMENTO.ATENDIMENTOGRUPODEVOLUCAO
	//WHERE
	//	IDGRUPO = :idGrupo;
    //
	//if( iCount > 0 )
	//	return 4;//Grupo pertence a um atendimento em andamento
    //=============================================================================

	//Pesquisa todos os tipos de sequencia que um grupo tem
	EXEC SQL 
	DECLARE 
		CursorGrpRemover CURSOR FOR
	SELECT DISTINCT
		S1.IDTIPOSEQUENCIA
	FROM
		CONTATOADM.CONTATOGRUPO G1,
		CONTATOADM.SEQUENCIA    S1
	WHERE
		G1.IDGRUPO = :idGrupo
	AND
		G1.IDCONTATOGRUPO = S1.IDCONTATOGRUPO;

	EXEC SQL OPEN CursorGrpRemover;

	iCount = 0;
	for(;;)
	{
		EXEC SQL WHENEVER NOT FOUND DO BREAK;
		memset( &stidTipoSequencia, 0, sizeof( stidTipoSequencia ) );
		EXEC SQL
		FETCH 
			CursorGrpRemover
		INTO
			:stidTipoSequencia;

		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		//Verifica se algum contato tem este grupo com unico grupo para um certo
		//tipo de sequencia
		EXEC SQL
		SELECT
			MIN(COUNT(G2.IDGRUPO)) AS GRUPO
		INTO
			:iCount
		FROM
			CONTATOADM.CONTATOGRUPO G1,
			CONTATOADM.CONTATOGRUPO G2,
			CONTATOADM.SEQUENCIA    S1
		WHERE
			G1.IDCONTATO = G2.IDCONTATO
		AND
			G2.IDCONTATOGRUPO = S1.IDCONTATOGRUPO
		AND
			G1.IDGRUPO = :idGrupo
		AND
			S1.IDTIPOSEQUENCIA = :stidTipoSequencia
		GROUP BY
			G2.IDCONTATO;

		//Se iCount == 1 entao o grupo eh unico para um certo contato e
		//nao pode ser apagado
		if( iCount == 1 )
			break;
	}//for(;;)
	EXEC SQL CLOSE CursorGrpRemover;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	if( iCount == 1 )
	{
	    ULOG_END(" CGrp::GrpRemover()");
		return 5;//Este grupo não pode ser apagado, pois existem contatos configurados somente com este grupo
    }
	//Apaga LOGICAMENTE o grupo
	EXEC SQL
	UPDATE ACESSO.GRUPO
		SET DTEXCLUSAO = SYSDATE
	WHERE 
		IDGRUPO = :idGrupo;

	//Apaga a relacao com USUARIO
	EXEC SQL
	DELETE
		ACESSO.USUARIOGRUPO
	WHERE 
		IDGRUPO = :idGrupo;

	//Apaga a relacao com MENU
	EXEC SQL
	DELETE
		ACESSO.GRUPOITEMMENU
	WHERE 
		IDGRUPO = :idGrupo;

	//Apaga a relacao com PERFIL
	EXEC SQL
	DELETE
		ACESSO.GRUPOROLE
	WHERE 
		IDGRUPO = :idGrupo;

	//Apaga HIERARQUIA de sequencia
	EXEC SQL
	DELETE
		CONTATOADM.NIVELSEQUENCIA
	WHERE 
		IDNIVELSEQUENCIA IN
		(
			SELECT 
				IDNIVELSEQUENCIA 
			FROM
				CONTATOADM.CONTATOGRUPO CONTATOGRUPO,
				CONTATOADM.SEQUENCIA SEQUENCIA,
				CONTATOADM.NIVELSEQUENCIA NIVELSEQUENCIA
			WHERE
				CONTATOGRUPO.IDGRUPO = :idGrupo
			AND
				CONTATOGRUPO.IDCONTATOGRUPO = SEQUENCIA.IDCONTATOGRUPO
			AND
				SEQUENCIA.IDSEQUENCIA = NIVELSEQUENCIA.IDSEQUENCIA
		);

	//Apaga a relacao com TIPORETORNOSEQUENCIA
	EXEC SQL
	DELETE
		CONTATOADM.TIPORETORNOSEQUENCIA
	WHERE 
		IDTIPORETORNOSEQUENCIA IN
		(
			SELECT 
				TIPORETORNOSEQUENCIA.IDTIPORETORNOSEQUENCIA 
			FROM
				CONTATOADM.CONTATOGRUPO CONTATOGRUPO,
				CONTATOADM.SEQUENCIA SEQUENCIA,
				CONTATOADM.TIPORETORNOSEQUENCIA TIPORETORNOSEQUENCIA
			WHERE
				CONTATOGRUPO.IDGRUPO = :idGrupo
			AND
				CONTATOGRUPO.IDCONTATOGRUPO = SEQUENCIA.IDCONTATOGRUPO
			AND
				SEQUENCIA.IDSEQUENCIA = TIPORETORNOSEQUENCIA.IDSEQUENCIA
		);

	//Apaga a relacao com SEQUENCIA
	EXEC SQL
	DELETE
		CONTATOADM.SEQUENCIA
	WHERE 
		IDSEQUENCIA IN
		(
			SELECT 
				IDSEQUENCIA 
			FROM
				CONTATOADM.CONTATOGRUPO CONTATOGRUPO,
				CONTATOADM.SEQUENCIA SEQUENCIA
			WHERE
				CONTATOGRUPO.IDGRUPO = :idGrupo
			AND
				CONTATOGRUPO.IDCONTATOGRUPO = SEQUENCIA.IDCONTATOGRUPO
		);

	//Apaga a relacao com CONTATO
	EXEC SQL
	DELETE
		CONTATOADM.CONTATOGRUPO
	WHERE 
		IDGRUPO = :idGrupo;

	//Apaga a relacao com FASEGRUPOFECHAMENTO
	EXEC SQL
	DELETE
		CONTATOADM.FASEGRUPOFECHAMENTO
	WHERE 
		IDGRUPO = :idGrupo;

	//Apaga a relacao com CANAL
	EXEC SQL
	DELETE
		CONTATOADM.CANALGRUPO
	WHERE 
		IDGRUPO = :idGrupo;

	//Apaga a relacao com GRUPOABERTURAGRUPO
	EXEC SQL
	DELETE
		CONTATOADM.GRUPOABERTURAGRUPO
	WHERE 
		IDGRUPO = :idGrupo;

	//Apaga a relacao com PROCEDENCIA
	EXEC SQL
	DELETE
		CONTATOADM.PROCEDENCIAGRUPO
	WHERE 
		IDGRUPO = :idGrupo;

	//Apaga a relacao com TIPOCARTEIRA
	EXEC SQL
	DELETE
		CONTATOADM.TIPOCARTEIRAGRUPO
	WHERE 
		IDGRUPO = :idGrupo;

	//Apaga a relacao com SEGMENTACAO
	EXEC SQL
	DELETE
		CONTATOADM.SEGMENTACAOGRUPO
	WHERE 
		IDGRUPO = :idGrupo;

	//Apaga a relacao com TIPOLINHA
	EXEC SQL
	DELETE
		CONTATOADM.TIPOLINHAGRUPO
	WHERE 
		IDGRUPO = :idGrupo;

	//Apaga a relacao com TIPOPESSOA
	EXEC SQL
	DELETE
		CONTATOADM.TIPOPESSOAGRUPO
	WHERE 
		IDGRUPO = :idGrupo;

	//Apaga a relacao com TIPORELACIONAMENTO
	EXEC SQL
	DELETE
		CONTATOADM.TIPORELACIONAMENTOGRUPO
	WHERE 
		IDGRUPO = :idGrupo;

    //Apaga os relacionamentos criados com CRI a partir daqui

	//Apaga a relacao com CONTATOPERFIL
	EXEC SQL
	DELETE
		CONTATOADM.CONTATOPERFIL
	WHERE 
		IDGRUPOPERFIL IN
		(
			SELECT
				IDGRUPOPERFIL
			FROM		
				CONTATOADM.GRUPOPERFIL
			WHERE 
				IDGRUPO = :idGrupo
		);

	//Apaga a relacao com GRUPOPERFIL
	EXEC SQL
	DELETE
		CONTATOADM.GRUPOPERFIL
	WHERE 
		IDGRUPO = :idGrupo;

	//Apaga a relacao com PERFILGRUPOABERTURA
	EXEC SQL
	DELETE
		CONTATOADM.PERFILGRUPOABERTURA
	WHERE 
		IDGRUPO = :idGrupo;
		
    //Apaga a relacao de grupo com linha
    EXEC SQL
    UPDATE CUSTOMER.LINHATELEFONICAGRUPO
    SET
        DTEXCLUSAO = SYSDATE,
        DTULTIMAALTERACAO = SYSDATE,
        IDUSUARIOALTERACAO = :cLogUserAux
    WHERE
        IDGRUPO = :idGrupo
    AND
        DTEXCLUSAO IS NULL;

	xml_g->createTag("GruposUsuarioVO");
	xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
	xml_g->closeTag();//GruposUsuarioVO

	ULOG_END(" CGrp::GrpRemover()");
	return 0;

// Tratamento de Exception
GotoGrpRemover:
	if( sqlca.sqlcode == -2292 )
	{
	    ULOG_END(" CGrp::GrpRemover()");
		return 6;//Alguma coisa de errado, nao deveria entrar aqui
	}
	else
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int CGrp::GrpCnlRelacao(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START(" CGrp::GrpCnlRelacao()");
	
	//Declarar Estruturas
	struct sqlca sqlca;

	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		int idGrupo;
		VARCHAR stnmGrupo[255+1];
		struct Tstruct {
			int idCanal;
			char cnmCanal[256];
			char ccdCanal[256];
		} tstruct;

		struct Tstructindicator {
			short sidCanal, snmCanal, scdCanal;
		} tstructindicator;

	EXEC SQL END DECLARE SECTION;

	//Se o ID nao for numerico entao retornar com codigo de erro
	try
	{
			
		char *pc = oSafePointer.getTag(dnode,"idGrupo",0);
	
		//Se o ID estiver vazio entao retornar com codigo de erro
		if ( strlen( pc ) <= 0 ) {
			ULOG_END(" CGrp::GrpCnlRelacao()");
			return 3;
		}
	
		//Le a descricao de Grupo
		idGrupo = atoi( pc );
	
		sqlca.sqlcode=0;
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		memset( &stnmGrupo, 0, sizeof( stnmGrupo ) );
		EXEC SQL
			SELECT NMGRUPO
			  INTO :stnmGrupo
			  FROM ACESSO.GRUPO
			 WHERE IDGRUPO = :idGrupo;
	
		EXEC SQL DECLARE tvcursorrelacionados3 CURSOR FOR
		SELECT GRUPOCANAL.IDCANAL,
               CANAL.NMCANAL,
               CANAL.CDCANAL
        FROM APOIO.CANAL,
             APOIO.TIPOGRUPO,
             ACESSO.GRUPO,
             ACESSO.GRUPOCANAL
        WHERE TIPOGRUPO.IDTIPOGRUPO = GRUPO.IDTIPOGRUPO
          AND CANAL.IDCANAL = GRUPOCANAL.IDCANAL
          AND GRUPO.IDGRUPO = GRUPOCANAL.IDGRUPO
          AND GRUPOCANAL.IDGRUPO = :idGrupo;		
		
		
	
		EXEC SQL DECLARE tvcursorexistentes3 CURSOR FOR
	    SELECT 
          CANAL.IDCANAL, 
          CANAL.NMCANAL,
		  CANAL.CDCANAL
        FROM  APOIO.CANAL CANAL
        WHERE CANAL.IDCANAL	
  		NOT IN (
                 SELECT GRUPOCANAL.IDCANAL
                 FROM  APOIO.CANAL CANAL2,
                       APOIO.TIPOGRUPO TIPOGRUPO,
                       ACESSO.GRUPO GRUPO,
                       ACESSO.GRUPOCANAL GRUPOCANAL
                 WHERE TIPOGRUPO.IDTIPOGRUPO = GRUPO.IDTIPOGRUPO
                       AND CANAL2.IDCANAL = GRUPOCANAL.IDCANAL
                       AND GRUPO.IDGRUPO = GRUPOCANAL.IDGRUPO
                       AND GRUPOCANAL.IDGRUPO = :idGrupo
        	   );
	    
	    
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CGrp::GrpCnlRelacao()");
			return 4;
		}
		else
		{
			xml_g->createTag("RelacionarGrupoCanalVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" ); 
			xml_g->addItem("idGrupo",idGrupo);
			xml_g->addItem("dsGrupo",(char*)stnmGrupo.arr);
	
			xml_g->createTag("CanaisExistentes");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			EXEC SQL OPEN tvcursorexistentes3;
			for(;;) {
				memset( &tstruct, 0, sizeof( tstruct ) );
				EXEC SQL FETCH tvcursorexistentes3 INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("CanalUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idCanal",tstruct.idCanal);
				xml_g->addItem("nmCanal",RTrim(tstruct.cnmCanal));
				xml_g->addItem("cdCanal",RTrim(tstruct.ccdCanal));
				xml_g->closeTag();
			}
			EXEC SQL CLOSE tvcursorexistentes3;
			xml_g->closeTag();
	
			xml_g->createTag("CanaisRelacionados");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			EXEC SQL OPEN tvcursorrelacionados3;
			for(;;) {
				memset( &tstruct, 0, sizeof( tstruct ) );
				EXEC SQL FETCH tvcursorrelacionados3 INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("CanalUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idCanal",tstruct.idCanal);
				xml_g->addItem("nmCanal",RTrim(tstruct.cnmCanal));
				xml_g->addItem("cdCanal",RTrim(tstruct.ccdCanal));
				xml_g->closeTag();
			}
			EXEC SQL CLOSE tvcursorrelacionados3;
			xml_g->closeTag();
	
			xml_g->closeTag();
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END(" CGrp::GrpCnlRelacao()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}



int CGrp::GrupoUsuarioRelacao( char* cidUsuario )
{
	ULOG_START("CGrp::GrupoUsuarioRelacao(  )");
	
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidUsuario = cidUsuario;
		struct
		{
			VARCHAR stidUsuarioGrupo[21+1];
			VARCHAR stidPessoaUsuario[21+1];
			VARCHAR stidGrupo[21+1];
			VARCHAR stinSupervisor[21+1];
		} stRegistro;
		struct
		{
			short iidUsuarioGrupo;
			short iidPessoaUsuario;
			short iidGrupo;
			short iinSupervisor;
		} stIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraGrupo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoGrupoUsuarioRelacao;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL 
   			DECLARE 
   				CursorGrupoUsuarioRelacao CURSOR FOR
			SELECT 
				USUARIOGRUPO.IDUSUARIOGRUPO,
			    USUARIOGRUPO.IDPESSOAUSUARIO,
			    USUARIOGRUPO.IDGRUPO,
			    USUARIOGRUPO.INSUPERVISOR
			FROM 
				ACESSO.USUARIOGRUPO USUARIOGRUPO,
				ACESSO.GRUPO GRUPO
			WHERE
				USUARIOGRUPO.IDGRUPO = GRUPO.IDGRUPO
			AND
				USUARIOGRUPO.IDPESSOAUSUARIO = :cAuxidUsuario;

		//Abre o cursor
		EXEC SQL OPEN CursorGrupoUsuarioRelacao;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRegistro, 0, sizeof(stRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorGrupoUsuarioRelacao INTO :stRegistro:stIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRegistro.stidUsuarioGrupo.arr,
				(char*)stRegistro.stidPessoaUsuario.arr, 
				(char*)stRegistro.stidGrupo.arr, 
				(char*)stRegistro.stinSupervisor.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o cursor
		EXEC SQL CLOSE CursorGrupoUsuarioRelacao;
	}
	catch(...)
	{
		throw;
	}
	//Retorna a quantidade de registros
	ULOG_END("CGrp::GrupoUsuarioRelacao(  )");
	return iCont;

GotoGrupoUsuarioRelacao:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int CGrp::GrupoUsuarioInsert( char* cidPessoaUsuario
                             ,char* cidGrupo
                             ,char* cidUsuario )
{
	ULOG_START("CGrp::GrupoUsuarioInsert( )");
	
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidPessoaUsuario = cidPessoaUsuario;
		char* cAuxidGrupo = cidGrupo;
		char* cAuxidUsuario = cidUsuario;
		VARCHAR stidUsuarioGrupo[21+1];
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		memset( &stidUsuarioGrupo, 0, sizeof(stidUsuarioGrupo) );
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoGrupoUsuarioInsert;
		
		EXEC SQL
			SELECT
				ACESSO.USUARIOGRUPOSQ.NEXTVAL
			INTO
				:stidUsuarioGrupo
			FROM DUAL;

		//Realiza o insert
		EXEC SQL 
			INSERT INTO ACESSO.USUARIOGRUPO
		    (
		    	IDUSUARIOGRUPO,
			    IDPESSOAUSUARIO,
			    IDGRUPO,
			    IDUSUARIOALTERACAO,
			    DTULTIMAALTERACAO,
			    INSUPERVISOR
			)
			VALUES
		    (
		    	:stidUsuarioGrupo,
		     	:cAuxidPessoaUsuario,
		     	:cAuxidGrupo,
		     	:cAuxidUsuario,
		     	SYSDATE,
		     	0
		    );

		Add( 	
			(char*)stidUsuarioGrupo.arr,
			cAuxidPessoaUsuario, 
			cAuxidGrupo, 
			"0"
		);

        ULOG_END("CGrp::GrupoUsuarioInsert( )");
		return 0;//Sucesso
	}
	catch(...)
	{
		throw;
	}
	
GotoGrupoUsuarioInsert:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
	
}


int CGrp::Find( char* cidGrupo )
{
	ULOG_START(" CGrp::Find(  )");
	int iRet = -1;
	for( int x = 0; x < Quantidade(); x++ )
	{
		if( strcmp( cidGrupo, Registro(x)->cidGrupo ) == 0 )
		{
			iRet = x;
			break;
		}
	}
	ULOG_END("CGrp::Find(  )");
	return iRet;
}

int CGrp::TemAtendimentosAbertos( char* cidGrupo, char* cidPessoaUsuario)
{
	ULOG_START("CGrp::TemAtendimentosAbertos( )");
	
	INITIALIZE_SQL;

	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidGrupo = cidGrupo;
		char* cAuxidPessoaUsuario = cidPessoaUsuario;
        int iCount = 0;
	EXEC SQL END DECLARE SECTION;

    ULOG("Verificando Abertos para idGrupo [%s] e idPessoaUsuario [%s]\n", cidGrupo, cidPessoaUsuario );

	EXEC SQL WHENEVER SQLERROR GOTO UndefinedError; 

    // ==> Remodelagem Atendimento--Fev/2007--Cassio 
	// EXEC SQL 
	// 	SELECT 
	// 		COUNT(1)
	// 	INTO  
	// 		:iCount
	// 	FROM 
	// 			atendimento.atendimentoPriorizacao ap,
	// 			atendimento.atendimentoGrupoAtual  aga,
	// 			atendimento.atendimentoUsuarioAtual aua
	// 	WHERE 
	// 			aua.idPessoaUsuario = :cAuxidPessoaUsuario
	// 	AND
	// 	   		aua.idatendimento = aga.idAtendimento
	// 	AND 
	// 			aga.idGrupo = :cAuxidGrupo
	// 	AND 
	// 			ap.idAtendimento = aga.idAtendimento;

	EXEC SQL 
		SELECT 
			COUNT(1)
		INTO  
			:iCount
		FROM 
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO ATENDIMENTOPRIORIZACAO
		WHERE 
            ATENDIMENTOPRIORIZACAO.IDPESSOAUSUARIOATUAL = :cAuxidPessoaUsuario
		AND ATENDIMENTOPRIORIZACAO.IDGRUPOATUAL = :cAuxidGrupo
        AND ROWNUM < 2;

    ULOG("Qtd atendimentos [%d] \n", iCount);

	ULOG_START("CGrp::TemAtendimentosAbertos( )");
	return iCount;

UndefinedError:
    throw new TuxBasicOraException(  sqlca.sqlcode
                                    ,sqlca.sqlerrm.sqlerrmc
                                    ,sqlca.sqlerrm.sqlerrml
                                  );
}

int CGrp::GrupoUsuarioInativoDelete( char* cidPessoaUsuario
									 ,char* cidGrupo )
{
	ULOG_START("CGrp::GrupoUsuarioInativoDelete( )");
	
	// Declarar Estruturas
	struct sqlca sqlca;
	
	// Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char*  cAuxidGrupo = cidGrupo;
		char*  cAuxidPessoaUsuario = cidPessoaUsuario;
	EXEC SQL END DECLARE SECTION;

	sqlca.sqlcode=0;
	EXEC SQL WHENEVER SQLERROR GOTO GotoGrupoUsuarioInativoDelete;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
	DELETE FROM 
		ACESSO.USUARIOGRUPOINATIVO 
	WHERE 
		IDGRUPO = :cAuxidGrupo
	AND
		IDPESSOAUSUARIO = :cAuxidPessoaUsuario;
    
    ULOG_END(" CGrp::GrupoUsuarioInativoDelete( )");
	return 0;

GotoGrupoUsuarioInativoDelete:
	if( sqlca.sqlcode == -2292 )
	{
	    ULOG_END("CGrp::GrupoUsuarioInativoDelete(  )");
		return 1;
	}
	else
		throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

int CGrp::GrupoUsuarioInativoInsert(  char* cidPessoaUsuario
									 ,char* cidGrupo
									 ,char* cidUsuario )
{
	ULOG_START("CGrp::GrupoUsuarioInativoInsert(  )");
	
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidPessoaUsuario = cidPessoaUsuario;
		char* cAuxidGrupo = cidGrupo;
		char* cAuxidUsuario = cidUsuario;
		VARCHAR stidUsuarioGrupoInativo[21+1];
		int iCount=0;
	EXEC SQL END DECLARE SECTION;

		try
		{
			memset( &stidUsuarioGrupoInativo, 0, sizeof(stidUsuarioGrupoInativo) );
			
			EXEC SQL WHENEVER NOT FOUND CONTINUE;
			EXEC SQL WHENEVER SQLERROR GOTO GotoGrupoUsuarioInativoInsert;

			EXEC SQL
			SELECT 
				COUNT(1)
			INTO  
				:iCount
			FROM 
					ACESSO.USUARIOGRUPOINATIVO ugi
			WHERE 
					ugi.idPessoaUsuario = :cAuxidPessoaUsuario
			AND 
					ugi.idGrupo = :cAuxidGrupo;

			if(iCount == 0){

				EXEC SQL
					SELECT
						ACESSO.USUARIOGRUPOINATIVOSQ.NEXTVAL
					INTO
						:stidUsuarioGrupoInativo
					FROM DUAL;

				EXEC SQL 
					INSERT INTO ACESSO.USUARIOGRUPOINATIVO
					(
		    			IDUSUARIOGRUPOINATIVO,
						IDPESSOAUSUARIO,
						IDGRUPO,
						IDUSUARIOALTERACAO,
						DTULTIMAALTERACAO
					)
					VALUES
					(
		    			:stidUsuarioGrupoInativo,
		     			:cAuxidPessoaUsuario,
		     			:cAuxidGrupo,
		     			:cAuxidUsuario,
						SYSDATE
					);
			}

		ULOG_END("CGrp::GrupoUsuarioInativoInsert(   )");
		return 0;//Sucesso
	}
	catch(...)
	{
		throw;
	}
	
GotoGrupoUsuarioInativoInsert:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
	
}

int CGrp::GrupoUsuarioDelete( char* cidUsuarioGrupo )
{
	ULOG_START(" CGrp::GrupoUsuarioDelete(  )");
	
	// Declarar Estruturas
	struct sqlca sqlca; 
	
	// Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char*  cAuxidUsuarioGrupo = cidUsuarioGrupo;
	EXEC SQL END DECLARE SECTION;

	sqlca.sqlcode=0;
	EXEC SQL WHENEVER SQLERROR GOTO GotoGrupoUsuarioDelete;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
	DELETE FROM 
		ACESSO.USUARIOGRUPOSKILL
	WHERE
		IDGRUPOSKILL IN ( SELECT IDGRUPOSKILL FROM ACESSO.GRUPOSKILL WHERE IDGRUPO = ( SELECT IDGRUPO FROM ACESSO.USUARIOGRUPO WHERE  IDUSUARIOGRUPO = :cAuxidUsuarioGrupo ) )
	AND
		IDPESSOAUSUARIO = ( SELECT IDPESSOAUSUARIO FROM ACESSO.USUARIOGRUPO WHERE  IDUSUARIOGRUPO = :cAuxidUsuarioGrupo );

	EXEC SQL
	DELETE FROM 
		ACESSO.USUARIOGRUPO 
	WHERE 
		IDUSUARIOGRUPO = :cAuxidUsuarioGrupo;
    
    ULOG_END(" CGrp::GrupoUsuarioDelete(  )");
	return 0;

// Tratamento de Exception
GotoGrupoUsuarioDelete:
	if( sqlca.sqlcode == -2292 )
	{
		ULOG_END(" CGrp::GrupoUsuarioDelete( )");
		return 1;
	}
	else
		throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

void CGrp::GrupoUsuarioInsertFalso( char* cidPessoaUsuario
                                   ,char* cidGrupo )
{
		ULOG_START(" CGrp::GrupoUsuarioInsertFalso( )");
		Add( 	
			"",
			cidPessoaUsuario, 
			cidGrupo, 
			""
		);
		ULOG_END(" CGrp::GrupoUsuarioInsertFalso(  )");
}

void CGrp::getXml( char* cNomeTag, char* cNomeTagInterna, XMLGen*xml )
{
    ULOG_START(" CGrp::getXml(  )");

	if( strlennull( cNomeTag ) > 0 )
	{
		xml->createTag(cNomeTag);
		xml->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
	}

	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			if( strlennull( cNomeTagInterna ) > 0 )
				xml->createTag(cNomeTagInterna);

			if( Registro( x ) != NULL )
			{ 
				xml->addItem("idGrupo", Registro(x)->cidGrupo );
				xml->addItem("dsGrupo", Registro(x)->cnmGrupo );
				xml->addItem("idTipoGrupoSelecionado", Registro(x)->cidTIPOGRUPO );  
				xml->addItem("dsTipoGrupoSelecionado", Registro(x)->cdsTIPOGRUPO );  
			}

			if( strlennull( cNomeTagInterna ) > 0 )
				xml->closeTag();//cNomeTagInterna
		}
	}

	if( strlennull( cNomeTag ) > 0 )
		xml->closeTag();//cNomeTag
		
	ULOG_END(" CGrp::getXml( )");
}


int CGrp::GrpListaTodos( void )
{
	ULOG_START(" CGrp::GrpListaTodos(  )");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 
		struct 
		{
			VARCHAR stidGrupo[21+1]; 
			VARCHAR stnmGrupo[255+1];
			VARCHAR stidTipoGrupo[255+1];
		} stRegistro;
		struct 
		{
			short sidGrupo;
			short snmGrupo;
			short idTipoGrupo;
		} stIndicator;
	EXEC SQL END DECLARE SECTION;

	//Apaga a estrutura interna
	ZeraGrupo();

	EXEC SQL WHENEVER SQLERROR GOTO GotoGrpListaTodos;
	EXEC SQL WHENEVER NOT FOUND DO break;
	sqlca.sqlcode=0;
	
	EXEC SQL 
	DECLARE 
		CursorGrpListaTodos CURSOR FOR
	SELECT 
		IDGRUPO
	  , NMGRUPO 
	  , IDTIPOGRUPO
	FROM 
		ACESSO.GRUPO GRUPO
	WHERE
		IDGRUPO > 0
	AND
		DTEXCLUSAO IS NULL
	ORDER BY 
		UPPER(NMGRUPO);

	EXEC SQL OPEN CursorGrpListaTodos;
	
	for(;;) 
	{
		memset( &stRegistro, 0, sizeof(stRegistro));
		EXEC SQL
		FETCH 
			CursorGrpListaTodos
		INTO
			:stRegistro:stIndicator;

		Add(	
			 (char*)stRegistro.stidGrupo.arr
			,(char*)stRegistro.stnmGrupo.arr
			,(char*)stRegistro.stidTipoGrupo.arr
		);
	}//for(;;) 

	EXEC SQL CLOSE CursorGrpListaTodos;

	ULOG_END(" CGrp::GrpListaTodos(  )");
	return 0;

//Tratamento de Exception
GotoGrpListaTodos:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}


int CGrp::GrpListaGrupoSkill( char* pzcidGrupo )
{
	ULOG_START(" CGrp::GrpListaGrupoSkill( )");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 
		struct 
		{
			VARCHAR stidGrupoSkill[21+1]; 
			VARCHAR stnmGrupoSkill[255+1];
		} stRegistro;
		struct 
		{
			short sidGrupoSkill;
			short snmGrupoSkill;
		} stIndicator;
		char* pzcidGrupoAux = pzcidGrupo;
	EXEC SQL END DECLARE SECTION;

	//Apaga a estrutura interna
	ZeraGrupo();

	//Processamento Principal
	memset( &stRegistro, 0, sizeof(stRegistro));

	EXEC SQL WHENEVER SQLERROR GOTO GotoGrpListaGrupoSkill;
	EXEC SQL WHENEVER NOT FOUND DO break;
	sqlca.sqlcode=0;
	
	EXEC SQL 
	DECLARE 
		CursorGrpListaGrupoSkill CURSOR FOR
	SELECT 
		IDGRUPOSKILL
	  , DSGRUPOSKILL
	FROM 
		ACESSO.GRUPOSKILL GRUPOSKILL
	WHERE
		IDGRUPOSKILL > 0
	AND
		IDGRUPO = :pzcidGrupoAux
	ORDER BY 
		UPPER(DSGRUPOSKILL);

	EXEC SQL OPEN CursorGrpListaGrupoSkill;
	
	for(;;) 
	{
		memset( &stRegistro, 0, sizeof(stRegistro));
		EXEC SQL
		FETCH 
			CursorGrpListaGrupoSkill
		INTO
			:stRegistro:stIndicator;

		Add(	
			 (char*)stRegistro.stidGrupoSkill.arr
			,(char*)stRegistro.stnmGrupoSkill.arr
		);
	}//for(;;) 

	EXEC SQL CLOSE CursorGrpListaGrupoSkill;
    ULOG_END(" CGrp::GrpListaGrupoSkill(  )");
	return 0;

//Tratamento de Exception
GotoGrpListaGrupoSkill:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}




//
// Estas funcoes foram alteradas para dar suporte a paginacao na consulta de usuarios por grupo
// e evitar o estouro no tamanho do xml de retorno
//
int CGrp::GrpListaUsuario( char* pzcidGrupo, int iOperacao, int iPagina, int &iQtdeRegistros )
{
    ULOG_START(" CGrp::GrpListaUsuario(  )");

	if( iOperacao == 0 )
	{
	    ULOG_END(" CGrp::GrpListaUsuario( )");
		return GrpListaUsuarioParcial( pzcidGrupo, iPagina, iQtdeRegistros );
	}
	else
	{
		ULOG_END(" CGrp::GrpListaUsuario(  )"); 
		return GrpListaUsuarioTodos( pzcidGrupo, iPagina, iQtdeRegistros  );
	}
}

int CGrp::GrpListaUsuario( char* pzcidGrupo, char* pzclogin, int iOperacao, int iPagina, int &iQtdeRegistros )
{
	ULOG_START(" CGrp::GrpListaUsuario(  )");
	
	if( iOperacao == 0 )
	{
	    ULOG_END(" CGrp::GrpListaUsuario( )");
		return GrpListaUsuarioParcial( pzcidGrupo, pzclogin, iPagina, iQtdeRegistros );
	}
	else
	{
		ULOG_END(" CGrp::GrpListaUsuario( )");
		return GrpListaUsuarioTodos( pzcidGrupo, pzclogin, iPagina, iQtdeRegistros );
	}
}

int CGrp::GrpListaUsuarioParcial( char* pzcidGrupo, int iPagina, int &iQtdeRegistros )
{
	ULOG_START(" CGrp::GrpListaUsuarioParcial( )");
	//Declarar Estruturas
	struct sqlca sqlca; 
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 
		struct 
		{
			VARCHAR stidUsuario[21+1]; 
			VARCHAR stnmUsuario[255+1];
		} stRegistro;
		struct 
		{
			short sidUsuario;
			short snmUsuario;
		} stIndicator;
		char* pzcidGrupoAux = pzcidGrupo;
		int	iRegistroInicio = 0; 
		int iRegistroFim = 0;
	EXEC SQL END DECLARE SECTION;

	//Apaga a estrutura interna
	ZeraGrupo();

	//Processamento Principal
	memset( &stRegistro, 0, sizeof(stRegistro));

	EXEC SQL WHENEVER SQLERROR GOTO GrpListaUsuarioParcialPaginado;
	EXEC SQL WHENEVER NOT FOUND DO break;
	sqlca.sqlcode=0;
	
	// Calcula o inicio e fim de paginacao
	iRegistroFim = iPagina * iQtdeRegistros;
	if(iRegistroFim > 0)
		iRegistroInicio = iRegistroFim - iQtdeRegistros;

	
	EXEC SQL 
	DECLARE 
		CursorGrpListaUsuarioP CURSOR FOR
	SELECT 
		IDPESSOAUSUARIO
		,NMLOGINUSUARIO
	FROM (
		SELECT
			IDPESSOAUSUARIO
			,NMLOGINUSUARIO
			,ROWNUM NUMLINHA
		FROM (
			SELECT
				  USUARIO.*
			FROM 
				ACESSO.USUARIO USUARIO,
				ACESSO.USUARIOGRUPO USUARIOGRUPO
			WHERE
				USUARIO.IDPESSOAUSUARIO = USUARIOGRUPO.IDPESSOAUSUARIO
			AND
				USUARIO.IDSTATUSUSUARIO = 1
			AND
				IDGRUPO = :pzcidGrupoAux
			AND
				USUARIO.IDPESSOAUSUARIO NOT IN 
				(
	        		SELECT 
	        			IDPESSOAUSUARIO 
	        		FROM
	        			ACESSO.CONTATOFOLHAUSUARIO 
	        		WHERE
	        			IDGRUPOSKILL IN 
	        			( 
	        				SELECT 
	        					IDGRUPOSKILL
	        				FROM 
	        					ACESSO.GRUPOSKILL
	        				WHERE
	        					IDGRUPO = :pzcidGrupoAux 
	        			)
				)
			ORDER BY 
				UPPER(NMLOGINUSUARIO)
		)
	)
	WHERE 
		  NUMLINHA > :iRegistroInicio
		  AND NUMLINHA <= :iRegistroFim;

	EXEC SQL OPEN CursorGrpListaUsuarioP;
	
	// Zera a quantidade de registros para retornar o numero de linhas selecionadas
	iQtdeRegistros = 0;

	for(;;) 
	{
		memset( &stRegistro, 0, sizeof(stRegistro));
		EXEC SQL
		FETCH 
			CursorGrpListaUsuarioP
		INTO
			:stRegistro:stIndicator;

		Add(
			 (char*)stRegistro.stidUsuario.arr
			,(char*)stRegistro.stnmUsuario.arr
		);

		iQtdeRegistros++;

	}//for(;;) 

	EXEC SQL CLOSE CursorGrpListaUsuarioP;
    
    ULOG_END(" CGrp::GrpListaUsuarioParcial(  )");
	return 0;

//Tratamento de Exception
GrpListaUsuarioParcialPaginado:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}


int CGrp::GrpListaUsuarioParcial( char* pzcidGrupo, char* pzclogin, int iPagina, int &iQtdeRegistros )
{
	ULOG_START(" CGrp::GrpListaUsuarioParcial( )");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 
		struct 
		{
			VARCHAR stidUsuario[21+1]; 
			VARCHAR stnmUsuario[255+1];
		} stRegistro;
		struct 
		{
			short sidUsuario;
			short snmUsuario;
		} stIndicator;
		char* pzcidGrupoAux = pzcidGrupo;
		char cloginAux[255+1];
		int	iRegistroInicio = 0; 
		int iRegistroFim = 0;
	EXEC SQL END DECLARE SECTION;

	//Apaga a estrutura interna
	ZeraGrupo();

	//Processamento Principal
	memset( cloginAux, 0, sizeof(cloginAux));
	if( strlennull( pzclogin ) > 0 )
		sprintf( cloginAux, "%s%%", pzclogin );
	else
		strcpy(cloginAux, "%" );

	// Calcula o inicio e fim de paginacao
	iRegistroFim = iPagina * iQtdeRegistros;
	if(iRegistroFim > 0)
		iRegistroInicio = iRegistroFim - iQtdeRegistros;


	EXEC SQL WHENEVER SQLERROR GOTO GotoGrpListaUsuario2;
	EXEC SQL WHENEVER NOT FOUND DO break;
	sqlca.sqlcode=0;
	

	EXEC SQL 
	DECLARE 
		CursorGrpListaUsuario2 CURSOR FOR
	SELECT 
		IDPESSOAUSUARIO
		,NMLOGINUSUARIO
	FROM (
		SELECT
			IDPESSOAUSUARIO
			,NMLOGINUSUARIO
			,ROWNUM NUMLINHA
		FROM (
			SELECT 
				USUARIO.*
			FROM 
				ACESSO.USUARIO USUARIO,
				ACESSO.USUARIOGRUPO USUARIOGRUPO
			WHERE
				USUARIO.IDPESSOAUSUARIO = USUARIOGRUPO.IDPESSOAUSUARIO
			AND
				USUARIO.IDSTATUSUSUARIO = 1
			AND
				IDGRUPO = :pzcidGrupoAux
			AND
				UPPER(NMLOGINUSUARIO) LIKE UPPER(:cloginAux)
		    AND
		        USUARIO.IDPESSOAUSUARIO NOT IN
		        (
		        	SELECT 
		        		IDPESSOAUSUARIO 
		        	FROM
		        		ACESSO.CONTATOFOLHAUSUARIO 
		        	WHERE
		        		IDGRUPOSKILL IN 
		        		( 
		        			SELECT 
		        				IDGRUPOSKILL
		        			FROM 
		        				ACESSO.GRUPOSKILL
		        			WHERE
		        				IDGRUPO = :pzcidGrupoAux 
		        		)
		        )
			ORDER BY 
				UPPER(NMLOGINUSUARIO)
		)
	)
	WHERE 
		  NUMLINHA > :iRegistroInicio
		  AND NUMLINHA <= :iRegistroFim;


	EXEC SQL OPEN CursorGrpListaUsuario2;
	
	// Zera a quantidade de registros para retornar o numero de linhas selecionadas
	iQtdeRegistros = 0;
	
	for(;;) 
	{
		memset( &stRegistro, 0, sizeof(stRegistro));
		EXEC SQL
		FETCH 
			CursorGrpListaUsuario2
		INTO
			:stRegistro:stIndicator;

		Add(
			 (char*)stRegistro.stidUsuario.arr
			,(char*)stRegistro.stnmUsuario.arr
		);

		iQtdeRegistros++;

	}//for(;;) 

	EXEC SQL CLOSE CursorGrpListaUsuario2;

    ULOG_END(" CGrp::GrpListaUsuarioParcial( )");
	return 0;

//Tratamento de Exception
GotoGrpListaUsuario2:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}


int CGrp::GrpListaUsuarioTodos( char* pzcidGrupo, int iPagina, int &iQtdeRegistros )
{
	ULOG_START(" CGrp::GrpListaUsuarioTodos(  )");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 
		struct 
		{
			VARCHAR stidUsuario[21+1]; 
			VARCHAR stnmUsuario[255+1];
		} stRegistro;
		struct 
		{
			short sidUsuario;
			short snmUsuario;
		} stIndicator;
		char* pzcidGrupoAux = pzcidGrupo;
		int	iRegistroInicio = 0; 
		int iRegistroFim = 0;
	EXEC SQL END DECLARE SECTION;

	//Apaga a estrutura interna
	ZeraGrupo();

	//Processamento Principal
	memset( &stRegistro, 0, sizeof(stRegistro));

	EXEC SQL WHENEVER SQLERROR GOTO GotoGrpListaUsuarioTodos;
	EXEC SQL WHENEVER NOT FOUND DO break;
	sqlca.sqlcode=0;

	// Calcula o inicio e fim da paginacao de registros
	iRegistroFim = iPagina * iQtdeRegistros;
	if(iRegistroFim > 0)
		iRegistroInicio = iRegistroFim - iQtdeRegistros;
	
	EXEC SQL 
	DECLARE 
		CursorGrpListaUsuarioTodos CURSOR FOR
	SELECT 
		IDPESSOAUSUARIO
		,NMLOGINUSUARIO
	FROM (
		SELECT
			IDPESSOAUSUARIO
			,NMLOGINUSUARIO
			,ROWNUM NUMLINHA
		FROM (
			SELECT 
				USUARIO.*
			FROM 
				ACESSO.USUARIO USUARIO,
				ACESSO.USUARIOGRUPO USUARIOGRUPO
			WHERE
				USUARIO.IDPESSOAUSUARIO = USUARIOGRUPO.IDPESSOAUSUARIO
			AND
				USUARIO.IDSTATUSUSUARIO = 1
			AND
				IDGRUPO = :pzcidGrupoAux
			ORDER BY 
				UPPER(NMLOGINUSUARIO)
		)
	)
	WHERE 
		  NUMLINHA > :iRegistroInicio
		  AND NUMLINHA <= :iRegistroFim;
	

	EXEC SQL OPEN CursorGrpListaUsuarioTodos;
	
	// Zera a quantidade de registros para retornar o numero de linhas selecionadas
	iQtdeRegistros = 0;
	
	for(;;) 
	{
		memset( &stRegistro, 0, sizeof(stRegistro));
		EXEC SQL
		FETCH 
			CursorGrpListaUsuarioTodos
		INTO
			:stRegistro:stIndicator;

		Add(
			 (char*)stRegistro.stidUsuario.arr
			,(char*)stRegistro.stnmUsuario.arr
		);

		iQtdeRegistros++;

	}//for(;;) 

	EXEC SQL CLOSE CursorGrpListaUsuarioTodos;

	ULOG_END(" CGrp::GrpListaUsuarioTodos(  )");
	return 0;

//Tratamento de Exception
GotoGrpListaUsuarioTodos:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}


int CGrp::GrpListaUsuarioTodos( char* pzcidGrupo, char* pzclogin, int iPagina, int &iQtdeRegistros )
{
	ULOG_START(" CGrp::GrpListaUsuarioTodos(  )");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 
		struct 
		{
			VARCHAR stidUsuario[21+1]; 
			VARCHAR stnmUsuario[255+1];
		} stRegistro;
		struct 
		{
			short sidUsuario;
			short snmUsuario;
		} stIndicator;
		char* pzcidGrupoAux = pzcidGrupo;
		char cloginAux[255+1];
		int	iRegistroInicio = 0; 
		int iRegistroFim = 0;
	EXEC SQL END DECLARE SECTION;

	//Apaga a estrutura interna
	ZeraGrupo();

	//Processamento Principal
	memset( cloginAux, 0, sizeof(cloginAux));
	if( strlennull( pzclogin ) > 0 )
		sprintf( cloginAux, "%s%%", pzclogin );
	else
		strcpy(cloginAux, "%" );

	// Calcula o inicio e fim da paginacao de registros
	iRegistroFim = iPagina * iQtdeRegistros;
	if(iRegistroFim > 0)
		iRegistroInicio = iRegistroFim - iQtdeRegistros;


	EXEC SQL WHENEVER SQLERROR GOTO GotoGrpListaUsuarioTodos2;
	EXEC SQL WHENEVER NOT FOUND DO break;
	sqlca.sqlcode=0;
	
	EXEC SQL 
	DECLARE 
		CursorGrpListaUsuarioTodos2 CURSOR FOR
	SELECT 
		IDPESSOAUSUARIO
		,NMLOGINUSUARIO
	FROM (
		SELECT
			IDPESSOAUSUARIO
			,NMLOGINUSUARIO
			,ROWNUM NUMLINHA
		FROM (
			SELECT 
				USUARIO.*
			FROM 
				ACESSO.USUARIO USUARIO,
				ACESSO.USUARIOGRUPO USUARIOGRUPO
			WHERE
				USUARIO.IDPESSOAUSUARIO = USUARIOGRUPO.IDPESSOAUSUARIO
			AND
				USUARIO.IDSTATUSUSUARIO = 1
			AND
				IDGRUPO = :pzcidGrupoAux
			AND
				UPPER(NMLOGINUSUARIO) LIKE UPPER(:cloginAux)
			ORDER BY 
				UPPER(NMLOGINUSUARIO)
		)
	)
	WHERE 
		  NUMLINHA > :iRegistroInicio
		  AND NUMLINHA <= :iRegistroFim;

	EXEC SQL OPEN CursorGrpListaUsuarioTodos2;
	
	// Zera a quantidade de registros para retornar o numero de linhas selecionadas
	iQtdeRegistros = 0;
	
	for(;;) 
	{
		memset( &stRegistro, 0, sizeof(stRegistro));
		EXEC SQL
		FETCH 
			CursorGrpListaUsuarioTodos2
		INTO
			:stRegistro:stIndicator;

		Add(
			 (char*)stRegistro.stidUsuario.arr
			,(char*)stRegistro.stnmUsuario.arr
		);

		iQtdeRegistros++;

	}//for(;;) 

	EXEC SQL CLOSE CursorGrpListaUsuarioTodos2;
    
    ULOG_END(" CGrp::GrpListaUsuarioTodos(  )");
	return 0;

//Tratamento de Exception
GotoGrpListaUsuarioTodos2:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

/*****************************************************************************************/
/*****************************************************************************************/
//Usuario -Skill

int CGrp::GrpListaUsuariosAssociadosSkill( char* pzcidGrupoSkill, int iPagina, int &iQtdeRegistros )
{
	ULOG_START(" CGrp::GrpListaUsuariosAssociadosSkill( )");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 
		struct 
		{
			VARCHAR stidUsuario[21+1]; 
			VARCHAR stnmUsuario[255+1];
		} stRegistro;
		struct 
		{
			short sidUsuario;
			short snmUsuario;
		} stIndicator;
		char* pzcidGrupoSkillAux = pzcidGrupoSkill;
		int	iRegistroInicio = 0; 
		int iRegistroFim = 0;
	EXEC SQL END DECLARE SECTION;

	//Apaga a estrutura interna
	ZeraGrupo();

	//Processamento Principal
	memset( &stRegistro, 0, sizeof(stRegistro));

	EXEC SQL WHENEVER SQLERROR GOTO TratGrpListaUsuarioAssociadosSkill;
	EXEC SQL WHENEVER NOT FOUND DO break;
	sqlca.sqlcode=0;
	
	// Calcula o inicio e fim de paginacao
	iRegistroFim = iPagina * iQtdeRegistros;
	if(iRegistroFim > 0)
		iRegistroInicio = iRegistroFim - iQtdeRegistros;

	
	EXEC SQL 
	DECLARE 
		CursorGrpListaUsuariosAssociadosSkill CURSOR FOR

     SELECT IDPESSOAUSUARIO, NMLOGINUSUARIO
     FROM ( 
		        SELECT  A.IDPESSOAUSUARIO, A.NMLOGINUSUARIO, ROWNUM AS LINHA 
		        FROM (
		                  SELECT USUARIO.IDPESSOAUSUARIO, USUARIO.NMLOGINUSUARIO
		                  FROM 
		                           ACESSO.USUARIOGRUPOSKILL  USUARIOGRUPOSKILL
		                          ,ACESSO.USUARIO            USUARIO
		                  WHERE
		                           USUARIO.IDPESSOAUSUARIO = USUARIOGRUPOSKILL.IDPESSOAUSUARIO
		                         AND
		                           USUARIOGRUPOSKILL.IDGRUPOSKILL = :pzcidGrupoSkillAux
		                  ORDER BY USUARIO.NMLOGINUSUARIO      
		             ) A           
          )
     WHERE LINHA > :iRegistroInicio AND LINHA <= :iRegistroFim; 
 
	EXEC SQL OPEN CursorGrpListaUsuariosAssociadosSkill;
	
	// Zera a quantidade de registros para retornar o numero de linhas selecionadas
	iQtdeRegistros = 0;

	for(;;) 
	{
		memset( &stRegistro, 0, sizeof(stRegistro));
		EXEC SQL
		FETCH 
			CursorGrpListaUsuariosAssociadosSkill
		INTO
			:stRegistro:stIndicator;

		Add(
			 (char*)stRegistro.stidUsuario.arr
			,(char*)stRegistro.stnmUsuario.arr
		);

		iQtdeRegistros++;

	}//for(;;) 

	EXEC SQL CLOSE CursorGrpListaUsuariosAssociadosSkill;

	ULOG_END("CGrp::GrpListaUsuariosAssociadosSkill(  )");
	return 0;

//Tratamento de Exception
TratGrpListaUsuarioAssociadosSkill:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

/*********************************************************************************************/

int CGrp::GrpListaUsuariosNaoAssociadosSkill( char* pzcidGrupoSkill, int iPagina, int &iQtdeRegistros )
{
	ULOG_START(" CGrp::GrpListaUsuariosNaoAssociadosSkill( )");
	//Declarar Estruturas
	struct sqlca sqlca; 
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 
		struct 
		{
			VARCHAR stidUsuario[21+1]; 
			VARCHAR stnmUsuario[255+1];
		} stRegistro;
		struct 
		{
			short sidUsuario;
			short snmUsuario;
		} stIndicator;
		char* pzcidGrupoSkillAux = pzcidGrupoSkill;
		int	iRegistroInicio = 0; 
		int iRegistroFim = 0;
	EXEC SQL END DECLARE SECTION;

	//Apaga a estrutura interna
	ZeraGrupo();

	//Processamento Principal
	memset( &stRegistro, 0, sizeof(stRegistro));

	EXEC SQL WHENEVER SQLERROR GOTO TratGrpListaUsuarioNaoAssociadosSkill;
	EXEC SQL WHENEVER NOT FOUND DO break;
	sqlca.sqlcode=0;
	
	// Calcula o inicio e fim de paginacao
	iRegistroFim = iPagina * iQtdeRegistros;
	if(iRegistroFim > 0)
		iRegistroInicio = iRegistroFim - iQtdeRegistros;

	
	EXEC SQL 
	DECLARE 
		CursorGrpListaUsuariosNaoAssociadosSkill CURSOR FOR
	SELECT
		IDPESSOAUSUARIO, 
		NMLOGINUSUARIO
	FROM
	(
		SELECT  
			A.IDPESSOAUSUARIO, 
			A.NMLOGINUSUARIO, 
			ROWNUM AS LINHA 
		FROM 
		(
			SELECT  
				USUARIO.IDPESSOAUSUARIO, 
				USUARIO.NMLOGINUSUARIO
			FROM 
				ACESSO.USUARIO USUARIO,
				ACESSO.USUARIOGRUPO USUARIOGRUPO
			WHERE
				USUARIO.IDPESSOAUSUARIO = USUARIOGRUPO.IDPESSOAUSUARIO
			AND
				USUARIO.IDSTATUSUSUARIO = ( SELECT IDSTATUSUSUARIO FROM APOIO.STATUSUSUARIO	WHERE SGSTATUSUSUARIO LIKE UPPER('ATIVO')  )
			AND
				USUARIOGRUPO.IDGRUPO = ( SELECT IDGRUPO FROM ACESSO.GRUPOSKILL WHERE IDGRUPOSKILL = :pzcidGrupoSkillAux )
			AND
				USUARIO.IDPESSOAUSUARIO NOT IN
				(
					SELECT 
						UGSKILL.IDPESSOAUSUARIO 
					FROM
						ACESSO.USUARIOGRUPOSKILL UGSKILL
					WHERE 
						UGSKILL.IDGRUPOSKILL IN( SELECT IDGRUPOSKILL FROM ACESSO.GRUPOSKILL WHERE IDGRUPO = USUARIOGRUPO.IDGRUPO )
					AND
						UGSKILL.IDPESSOAUSUARIO = USUARIO.IDPESSOAUSUARIO            
				)
			ORDER BY USUARIO.NMLOGINUSUARIO
		) A
	)
	WHERE 
		LINHA > :iRegistroInicio AND LINHA <= :iRegistroFim;

	EXEC SQL OPEN CursorGrpListaUsuariosNaoAssociadosSkill;
	
	// Zera a quantidade de registros para retornar o numero de linhas selecionadas
	iQtdeRegistros = 0;

	for(;;) 
	{
		memset( &stRegistro, 0, sizeof(stRegistro));
		EXEC SQL
		FETCH 
			CursorGrpListaUsuariosNaoAssociadosSkill
		INTO
			:stRegistro:stIndicator;

		Add(
			 (char*)stRegistro.stidUsuario.arr
			,(char*)stRegistro.stnmUsuario.arr
		);

		iQtdeRegistros++;

	}//for(;;) 

	EXEC SQL CLOSE CursorGrpListaUsuariosNaoAssociadosSkill;
    ULOG_END(" CGrp::GrpListaUsuariosNaoAssociadosSkill(  )");
	return 0;

//Tratamento de Exception
TratGrpListaUsuarioNaoAssociadosSkill:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

/**********************************************************************************************/

int CGrp::GrpListaUsuariosNaoAssociadosSkillPorLogin( char* pzcidGrupoSkill, char* pzclogin, int iPagina, int &iQtdeRegistros )
{
	ULOG_START(" CGrp::GrpListaUsuariosNaoAssociadosSkillPorLogin(  )");
	//Declarar Estruturas
	struct sqlca sqlca; 
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 
		struct 
		{
			VARCHAR stidUsuario[21+1]; 
			VARCHAR stnmUsuario[255+1];
		} stRegistro;
		struct 
		{
			short sidUsuario;
			short snmUsuario;
		} stIndicator;
		char* pzcidGrupoSkillAux = pzcidGrupoSkill;
		char cloginAux[255+1];
		int	iRegistroInicio = 0; 
		int iRegistroFim = 0;
	EXEC SQL END DECLARE SECTION;

	//Apaga a estrutura interna
	ZeraGrupo();

	//Processamento Principal
	memset( &stRegistro, 0, sizeof(stRegistro));
	if( strlennull( pzclogin ) > 0 )
		sprintf( cloginAux, "%s%%", pzclogin );
	else
		strcpy(cloginAux, "%" );

	EXEC SQL WHENEVER SQLERROR GOTO TratGrpListaUsuarioNaoAssociadosSkill2;
	EXEC SQL WHENEVER NOT FOUND DO break;
	sqlca.sqlcode=0;
	
	// Calcula o inicio e fim de paginacao
	iRegistroFim = iPagina * iQtdeRegistros;
	if(iRegistroFim > 0)
		iRegistroInicio = iRegistroFim - iQtdeRegistros;

	
	EXEC SQL 
	DECLARE 
		CursorGrpListaUsuariosNaoAssociadosSkill2 CURSOR FOR
	SELECT
		IDPESSOAUSUARIO, 
		NMLOGINUSUARIO
	FROM
	(
		SELECT  
			A.IDPESSOAUSUARIO, 
			A.NMLOGINUSUARIO, 
			ROWNUM AS LINHA 
		FROM 
		(
			SELECT
				USUARIO.IDPESSOAUSUARIO, 
				USUARIO.NMLOGINUSUARIO
			FROM 
				ACESSO.USUARIO USUARIO,
				ACESSO.USUARIOGRUPO USUARIOGRUPO
			WHERE
				USUARIO.IDPESSOAUSUARIO = USUARIOGRUPO.IDPESSOAUSUARIO
			AND
				USUARIO.IDSTATUSUSUARIO = ( SELECT IDSTATUSUSUARIO FROM APOIO.STATUSUSUARIO WHERE SGSTATUSUSUARIO LIKE UPPER('ATIVO') )
			AND
				USUARIOGRUPO.IDGRUPO = ( SELECT IDGRUPO FROM ACESSO.GRUPOSKILL WHERE IDGRUPOSKILL = :pzcidGrupoSkillAux )
			AND
				UPPER(USUARIO.NMLOGINUSUARIO) LIKE UPPER(:cloginAux) 
			AND
				USUARIO.IDPESSOAUSUARIO NOT IN
				(
					SELECT 
						UGSKILL.IDPESSOAUSUARIO 
					FROM
						ACESSO.USUARIOGRUPOSKILL UGSKILL
					WHERE 
						UGSKILL.IDGRUPOSKILL IN( SELECT IDGRUPOSKILL FROM ACESSO.GRUPOSKILL WHERE IDGRUPO = USUARIOGRUPO.IDGRUPO )
					AND
						UGSKILL.IDPESSOAUSUARIO = USUARIO.IDPESSOAUSUARIO            
				)
			ORDER BY USUARIO.NMLOGINUSUARIO
		) A
	)
	WHERE 
		LINHA > :iRegistroInicio 
	AND
		LINHA <= :iRegistroFim;

	EXEC SQL OPEN CursorGrpListaUsuariosNaoAssociadosSkill2;
	
	// Zera a quantidade de registros para retornar o numero de linhas selecionadas
	iQtdeRegistros = 0;

	for(;;) 
	{
		memset( &stRegistro, 0, sizeof(stRegistro));
		EXEC SQL
		FETCH 
			CursorGrpListaUsuariosNaoAssociadosSkill2
		INTO
			:stRegistro:stIndicator;

		Add(
			 (char*)stRegistro.stidUsuario.arr
			,(char*)stRegistro.stnmUsuario.arr
		);

		iQtdeRegistros++;

	}//for(;;) 

	EXEC SQL CLOSE CursorGrpListaUsuariosNaoAssociadosSkill2;
    
    ULOG_END(" CGrp::GrpListaUsuariosNaoAssociadosSkillPorLogin( )");
	return 0;

//Tratamento de Exception
TratGrpListaUsuarioNaoAssociadosSkill2:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}


/*****************************************************************************************/
/*****************************************************************************************/
// Contato - Skill

int CGrp::GrpListaContatosAssociadosSkill( char* pzcidGrupoSkill, int iPagina, int &iQtdeRegistros )
{
	ULOG_START(" CGrp::GrpListaContatosAssociadosSkill()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 
		struct 
		{
			VARCHAR stidContato[21+1]; 
			VARCHAR stnmPath[255+1];
		} stRegistro;
		struct 
		{
			short sidContato;
			short snmPath;
		} stIndicator;
		char* pzcidGrupoSkillAux = pzcidGrupoSkill;
		int	iRegistroInicio = 0; 
		int iRegistroFim = 0;
	EXEC SQL END DECLARE SECTION;

	//Apaga a estrutura interna
	ZeraGrupo();

	//Processamento Principal
	memset( &stRegistro, 0, sizeof(stRegistro));

	EXEC SQL WHENEVER SQLERROR GOTO TratGrpListaContatosAssociadosSkill;
	EXEC SQL WHENEVER NOT FOUND DO break;
	sqlca.sqlcode=0;
	
	// Calcula o inicio e fim de paginacao
	iRegistroFim = iPagina * iQtdeRegistros;
	if(iRegistroFim > 0)
		iRegistroInicio = iRegistroFim - iQtdeRegistros;

	
	EXEC SQL 
	DECLARE 
		CursorGrpListaContatosAssociadosSkill CURSOR FOR
     SELECT IDCONTATO, NMPATH
     FROM (
            SELECT A.IDCONTATO, A.NMPATH, rownum as linha
            FROM (
                   SELECT 
                         CONTATO.IDCONTATO, 
                         CONTATO.NMPATH
                   FROM 
                         CONTATOADM.CONTATO CONTATO,
                         CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
                         ACESSO.CONTATOGRUPOSKILL CONTATOGRUPOSKILL
                   WHERE
                         CONTATOFOLHA.IDCONTATO = CONTATO.IDCONTATO
                       AND
                         CONTATO.IDCONTATO = CONTATOGRUPOSKILL.IDCONTATO
                       AND
                         CONTATOGRUPOSKILL.IDGRUPOSKILL = :pzcidGrupoSkillAux
                   ORDER BY CONTATO.NMPATH    
                 ) A
          )
      WHERE LINHA > :iRegistroInicio AND LINHA <= :iRegistroFim;

	EXEC SQL OPEN CursorGrpListaContatosAssociadosSkill;
	
	// Zera a quantidade de registros para retornar o numero de linhas selecionadas
	iQtdeRegistros = 0;

	for(;;) 
	{
		memset( &stRegistro, 0, sizeof(stRegistro));
		EXEC SQL
		FETCH 
			CursorGrpListaContatosAssociadosSkill
		INTO
			:stRegistro:stIndicator;

		Add(
			 (char*)stRegistro.stidContato.arr
			,(char*)stRegistro.stnmPath.arr
		);

		iQtdeRegistros++;

	}//for(;;) 

	EXEC SQL CLOSE CursorGrpListaContatosAssociadosSkill;
    
    ULOG_END("CGrp::GrpListaContatosAssociadosSkill(  )");
	return 0;

//Tratamento de Exception
TratGrpListaContatosAssociadosSkill:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

/*********************************************************************************************/

int CGrp::GrpListaContatosNaoAssociadosSkill( char* pzcidGrupoSkill, int iPagina, int &iQtdeRegistros )
{
	ULOG_START("CGrp::GrpListaContatosNaoAssociadosSkill( )");
	//Declarar Estruturas
	struct sqlca sqlca; 
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 
		struct 
		{
			VARCHAR stidContato[21+1]; 
			VARCHAR stnmPath[255+1];
		} stRegistro;
		struct 
		{
			short sidContato;
			short snmPath;
		} stIndicator;
		char* pzcidGrupoSkillAux = pzcidGrupoSkill;
		int	iRegistroInicio = 0; 
		int iRegistroFim = 0;
	EXEC SQL END DECLARE SECTION;

	//Apaga a estrutura interna
	ZeraGrupo();

	//Processamento Principal
	memset( &stRegistro, 0, sizeof(stRegistro));

	EXEC SQL WHENEVER SQLERROR GOTO TratGrpListaContatosNaoAssociadosSkill;
	EXEC SQL WHENEVER NOT FOUND DO break;
	sqlca.sqlcode=0;
	
	// Calcula o inicio e fim de paginacao
	iRegistroFim = iPagina * iQtdeRegistros;
	if(iRegistroFim > 0)
		iRegistroInicio = iRegistroFim - iQtdeRegistros;

	
	EXEC SQL 
	DECLARE 
		CursorGrpListaContatosNaoAssociadosSkill CURSOR FOR
      
      SELECT  IDCONTATO, NMPATH
			FROM (
						SELECT  A.IDCONTATO, A.NMPATH, rownum as linha
						FROM (  
        					SELECT CONTATO.IDCONTATO, CONTATO.NMPATH
        					FROM 
            					CONTATOADM.CONTATO CONTATO,
            					CONTATOADM.CONTATOFOLHA CONTATOFOLHA
        					WHERE
            					CONTATOFOLHA.IDCONTATO = CONTATOFOLHA.IDCONTATO
        					AND
            					CONTATOFOLHA.IDCONTATO = 
            					( 
                					SELECT IDCONTATO 
                					FROM CONTATOADM.CONTATOGRUPO 
                					WHERE IDCONTATO = CONTATO.IDCONTATO 
					                AND   IDGRUPO = ( SELECT IDGRUPO FROM ACESSO.GRUPOSKILL WHERE IDGRUPOSKILL = :pzcidGrupoSkillAux )
					                AND   ROWNUM < 2 
                      )
                  AND
					            CONTATOFOLHA.IDCONTATO = 
					            ( 
					                SELECT IDCONTATO 
					                FROM CONTATOADM.CONTATOTIPOCARTEIRA CTC,  ACESSO.TIPOCARTEIRAGRUPOSKILL TCS
					                WHERE CTC.IDTIPOCARTEIRA = TCS.IDTIPOCARTEIRA
					                AND   TCS.IDGRUPOSKILL = :pzcidGrupoSkillAux
					                AND   CTC.IDCONTATO = CONTATOFOLHA.IDCONTATO
					                AND   ROWNUM < 2
					            )
					        AND
					            CONTATOFOLHA.IDCONTATO = 
					            ( 
					                SELECT IDCONTATO 
					                FROM CONTATOADM.CONTATOTIPOLINHA CTL,  ACESSO.TIPOLINHAGRUPOSKILL TLS
					                WHERE CTL.IDTIPOLINHA = TLS.IDTIPOLINHA
					                AND   TLS.IDGRUPOSKILL = :pzcidGrupoSkillAux
					                AND   CTL.IDCONTATO = CONTATOFOLHA.IDCONTATO
					                AND   ROWNUM < 2
					            )
					        AND
					            CONTATOFOLHA.IDCONTATO = 
					            ( 
					                SELECT IDCONTATO 
					                FROM CONTATOADM.CONTATOSEGMENTACAO CS,  ACESSO.SEGMENTACAOGRUPOSKILL SS
					                WHERE CS.IDSEGMENTACAO = SS.IDSEGMENTACAO
					                AND   SS.IDGRUPOSKILL = :pzcidGrupoSkillAux
					                AND   CS.IDCONTATO = CONTATOFOLHA.IDCONTATO
					                AND   ROWNUM < 2
					            )
					        AND
					            CONTATOFOLHA.IDCONTATO = 
					            ( 
					                SELECT IDCONTATO 
					                FROM CONTATOADM.CONTATOTIPORELACIONAMENTO CTR,  ACESSO.TPRELACIONAMENTOGRUPOSKILL STR
					                WHERE CTR.IDTIPORELACIONAMENTO = STR.IDTIPORELACIONAMENTO
					                AND   STR.IDGRUPOSKILL = :pzcidGrupoSkillAux
					                AND   CTR.IDCONTATO = CONTATOFOLHA.IDCONTATO
					                AND   ROWNUM < 2
					            )
					        AND
					            CONTATOFOLHA.IDCONTATO = 
					            ( 
					                SELECT IDCONTATO 
					                FROM CONTATOADM.CONTATOUFOPERADORA CUO,  ACESSO.UFOPERADORAGRUPOSKILL SUO
					                WHERE CUO.IDUFOPERADORA = SUO.IDUFOPERADORA
					                AND   SUO.IDGRUPOSKILL = :pzcidGrupoSkillAux
					                AND   CUO.IDCONTATO = CONTATOFOLHA.IDCONTATO
					                AND   ROWNUM < 2
					            )
					        AND
					           CONTATOFOLHA.IDCONTATO NOT IN
					           (
					                SELECT
					                    IDCONTATO
					                FROM
					                    ACESSO.CONTATOGRUPOSKILL CGS
					                WHERE
					                    CGS.IDCONTATO = CONTATOFOLHA.IDCONTATO
					                AND
					                    CGS.IDGRUPOSKILL = :pzcidGrupoSkillAux
					                AND
					                    ROWNUM < 2 
					            )
					        ORDER BY UPPER(CONTATO.NMPATH)    
		            ) A
           )
      WHERE  LINHA > :iRegistroInicio AND LINHA <=  :iRegistroFim;
      
 
	EXEC SQL OPEN CursorGrpListaContatosNaoAssociadosSkill;
	
	// Zera a quantidade de registros para retornar o numero de linhas selecionadas
	iQtdeRegistros = 0;

	for(;;) 
	{
		memset( &stRegistro, 0, sizeof(stRegistro));
		EXEC SQL
		FETCH 
			CursorGrpListaContatosNaoAssociadosSkill
		INTO
			:stRegistro:stIndicator;

		Add(
			 (char*)stRegistro.stidContato.arr
			,(char*)stRegistro.stnmPath.arr
		);

		iQtdeRegistros++;

	}//for(;;) 

	EXEC SQL CLOSE CursorGrpListaContatosNaoAssociadosSkill;
    
    ULOG_END(" CGrp::GrpListaContatosNaoAssociadosSkill( )");
	return 0;

//Tratamento de Exception
TratGrpListaContatosNaoAssociadosSkill:
	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}