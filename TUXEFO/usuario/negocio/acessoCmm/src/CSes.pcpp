#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "CSes.h"

CSes::CSes()
{
}

CSes::~CSes()
{
}

char* CSes::RTrim(char *pszString)
{
    ULOG_START("CSes::RTrim()");
    
    int iLen;

    iLen=strlen(pszString);

    for(;;)
    {
        if(pszString[iLen-1] != ' ')
            break;

        iLen--;

        if(iLen == 0)
            break;
    }
    pszString[iLen] = 0x00;
	
	ULOG_END("CSes::RTrim()");
	return pszString;
}

int CSes::Insert( char* cdsSessao )
{
	ULOG_START("CSes::Insert()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cAuxidSessao[21+1];
		char* cAuxdsSessao  = cdsSessao;
	EXEC SQL END DECLARE SECTION;
	
	try
	{
		ZeraSessao();
		
		memset( &cAuxidSessao, 0, sizeof(cAuxidSessao) );
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
		sqlca.sqlcode=0;
		
		//Pega um id unico e sequencia para a insercao
		EXEC SQL
			SELECT C_EMARINS.SESSAOSQ.NEXTVAL
			INTO :cAuxidSessao
			FROM DUAL;
	
		EXEC SQL 
			INSERT INTO C_EMARINS.SESSAO
			  (IDSESSAO, 
			   DSSESSAO )
			VALUES
			  (:cAuxidSessao, 
			   :cAuxidSessao );
	
	}
	catch(...)
	{
		throw;
	}
	
	ULOG_END("CSes::Insert()");
	if( sqlca.sqlcode == 0 )
		return 1;
	else
		return 0;

GotoInsert:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CSes::Update( char* cidSessao, 
				  char* cdsSessao )
{
	ULOG_START("CSes::Update()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidSessao  = cidSessao;
		char* cAuxdsSessao  = cdsSessao;
	EXEC SQL END DECLARE SECTION;
	
	try
	{
		ZeraSessao();
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
		sqlca.sqlcode=0;
		
		EXEC SQL 
			UPDATE C_EMARINS.SESSAO
			   SET DSSESSAO = :cAuxdsSessao
			 WHERE IDSESSAO = :cAuxidSessao;  
	
	}
	catch(...)
	{
		throw;
	}
	
	ULOG_END("CSes::Update()");
	if( sqlca.sqlcode == 0 )
		return 1;
	else
		return 0;

GotoUpdate:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CSes::ListId( char* cid )
{
	ULOG_START("CSes::ListId()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidOra = cid;
		struct
		{
			VARCHAR stidSessao[21+1];
			VARCHAR stdsSessao[255+1];
		} stSessao;
		struct
		{
			short iidSessao;
			short idsSessao;
		} stSessaoInd;
	EXEC SQL END DECLARE SECTION;

	try
	{
		ZeraSessao();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;
	
	   	EXEC SQL DECLARE CursorSessaoListId CURSOR FOR
			SELECT IDSESSAO, 
			       DSSESSAO 
			  FROM C_EMARINS.SESSAO
			 WHERE IDSESSAO = :cidOra;
	
		EXEC SQL OPEN CursorSessaoListId;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CSes::ListId()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stSessao, 0, sizeof(stSessao) );
				EXEC SQL FETCH CursorSessaoListId INTO :stSessao:stSessaoInd;
	
				Add( (char*)stSessao.stidSessao.arr, (char*)stSessao.stdsSessao.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorSessaoListId;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSes::ListId()");
	return iCont;

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CSes::ListAll( void )
{
	ULOG_START("CSes::ListAll()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidSessao[21+1];
			VARCHAR stdsSessao[255+1];
		} stSessao;
		struct
		{
			short iidSessao;
			short idsSessao;
		} stSessaoInd;
	EXEC SQL END DECLARE SECTION;

	try
	{
		ZeraSessao();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;
	
	   	EXEC SQL DECLARE CursorSessaoListAll CURSOR FOR
			SELECT IDSESSAO, 
			       DSSESSAO 
			  FROM C_EMARINS.SESSAO;
	
		EXEC SQL OPEN CursorSessaoListAll;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CSes::ListAll()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stSessao, 0, sizeof(stSessao) );
				EXEC SQL FETCH CursorSessaoListAll INTO :stSessao:stSessaoInd;
	
				Add( (char*)stSessao.stidSessao.arr, (char*)stSessao.stdsSessao.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorSessaoListAll;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSes::ListAll()");
	return iCont;

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CSes::GetXml( char* cNomeTag, XMLGen*xml )
{
	ULOG_START("CSes::GetXml()");
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			xml->addProp(	"xmlns", "usuario.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{
				xml->addItem("idSessao"   , Registro(x)->cidSessao   );
				xml->addItem("dsSessao"   , Registro(x)->cdsSessao   );
			}
			xml->closeTag();
		}
	}
	ULOG_END("CSes::GetXml()");
}
