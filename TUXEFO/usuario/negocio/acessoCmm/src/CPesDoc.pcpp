#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
#include<ctype.h>

#include "CPesDoc.h"

CPesDoc::CPesDoc()
{
}

CPesDoc::~CPesDoc()
{
}

int CPesDoc::ListId( char* cid )
{
	ULOG_START("CPesDoc::ListId()");	
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidOra = cid;
		struct
		{
			VARCHAR stidPessoaDocumento[21+1];
			VARCHAR stidPessoa[255+1];
			VARCHAR stidDocumento[255+1];
			VARCHAR sttsSincronismo[255+1];
			VARCHAR stsqSincronismo[255+1];
			VARCHAR stidSistemaOrigem[12+1];
			VARCHAR stidDocumentoSistemaOrigem[21+1];
			VARCHAR stdtexpiracao[21+1];
		} stPessoaDocumentoRegistro;
		struct
		{
			short iidPessoaDocumento;
			short iidPessoa;
			short iidDocumento;
			short itsSincronismo;
			short isqSincronismo;
			short iidSistemaOrigem;
			short iidDocumentoSistemaOrigem;
			short idtexpiracao;
		} stPessoaDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraPessoaDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE CursorPessoaDocumentoId CURSOR FOR
				SELECT PESSOADOCUMENTO.IDPESSOADOCUMENTO
					  ,PESSOADOCUMENTO.IDPESSOA
					  ,PESSOADOCUMENTO.IDDOCUMENTO
					  ,PESSOADOCUMENTO.TSSINCRONISMO
					  ,PESSOADOCUMENTO.SQSINCRONISMO
					  ,PESSOADOCUMENTO.IDSISTEMAORIGEM
					  ,PESSOADOCUMENTO.IDDOCUMENTOSISTEMAORIGEM
					  ,PESSOADOCUMENTO.DTEXPIRACAO
			     FROM CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO
			    WHERE PESSOADOCUMENTO.IDPESSOADOCUMENTO = :cidOra;
	
		EXEC SQL OPEN CursorPessoaDocumentoId;
	
		if(sqlca.sqlcode)
		{
		    ULOG_END("CPesDoc::ListId()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stPessoaDocumentoRegistro, 0, sizeof(stPessoaDocumentoRegistro) );
				EXEC SQL FETCH CursorPessoaDocumentoId INTO :stPessoaDocumentoRegistro:stPessoaDocumentoIndicator;
	
				Add( (char*)stPessoaDocumentoRegistro.stidPessoaDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.stidPessoa.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.sttsSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stsqSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stidSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumentoSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stdtexpiracao.arr 
				   );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorPessoaDocumentoId;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CPesDoc::ListId()");
	return iCont;

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CPesDoc::ListAll( void )
{
	ULOG_START("CPesDoc::ListAll()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidPessoaDocumento[21+1];
			VARCHAR stidPessoa[255+1];
			VARCHAR stidDocumento[255+1];
			VARCHAR sttsSincronismo[255+1];
			VARCHAR stsqSincronismo[255+1];
			VARCHAR stidSistemaOrigem[12+1];
			VARCHAR stidDocumentoSistemaOrigem[21+1];
			VARCHAR stdtexpiracao[21+1];
		} stPessoaDocumentoRegistro;
		struct
		{
			short iidPessoaDocumento;
			short iidPessoa;
			short iidDocumento;
			short itsSincronismo;
			short isqSincronismo;
			short iidSistemaOrigem;
			short iidDocumentoSistemaOrigem;
			short idtexpiracao;
		} stPessoaDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraPessoaDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE CursorPessoaDocumentoAll CURSOR FOR
				SELECT PESSOADOCUMENTO.IDPESSOADOCUMENTO
					  ,PESSOADOCUMENTO.IDPESSOA
					  ,PESSOADOCUMENTO.IDDOCUMENTO
					  ,PESSOADOCUMENTO.TSSINCRONISMO
					  ,PESSOADOCUMENTO.SQSINCRONISMO
					  ,PESSOADOCUMENTO.IDSISTEMAORIGEM
					  ,PESSOADOCUMENTO.IDDOCUMENTOSISTEMAORIGEM
					  ,PESSOADOCUMENTO.DTEXPIRACAO
			     FROM CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO
				WHERE PESSOADOCUMENTO.IDPESSOADOCUMENTO > 0;
	
		EXEC SQL OPEN CursorPessoaDocumentoAll;
	
		if(sqlca.sqlcode)
		{
		    ULOG_END("CPesDoc::ListAll()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stPessoaDocumentoRegistro, 0, sizeof(stPessoaDocumentoRegistro) );
				EXEC SQL FETCH CursorPessoaDocumentoAll INTO :stPessoaDocumentoRegistro:stPessoaDocumentoIndicator;
	
				Add( (char*)stPessoaDocumentoRegistro.stidPessoaDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.stidPessoa.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.sttsSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stsqSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stidSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumentoSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stdtexpiracao.arr
				   );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorPessoaDocumentoAll;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CPesDoc::ListAll()");
	return iCont;

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CPesDoc::ListDoc( char* cidPessoa )
{
	ULOG_START("CPesDoc::ListDoc()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidPessoa = cidPessoa;
		struct
		{
			VARCHAR stidPessoaDocumento[21+1];
			VARCHAR stidPessoa[21+1];
			VARCHAR stidDocumento[21+1];
			VARCHAR sttsSincronismo[21+1];
			VARCHAR stsqSincronismo[21+1];
			VARCHAR stidSistemaOrigem[21+1];
			VARCHAR stidDocumentoSistemaOrigem[255+1];
			VARCHAR stdtexpiracao[12+1];
		} stPessoaDocumentoRegistro;
		struct
		{
			short iidPessoaDocumento;
			short iidPessoa;
			short iidDocumento;
			short itsSincronismo;
			short isqSincronismo;
			short iidSistemaOrigem;
			short iidDocumentoSistemaOrigem;
			short idtexpiracao;
		} stPessoaDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraPessoaDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListDoc;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE CursorListDocTipo CURSOR FOR
				SELECT PESSOADOCUMENTO.IDPESSOADOCUMENTO
					  ,PESSOADOCUMENTO.IDPESSOA
					  ,PESSOADOCUMENTO.IDDOCUMENTO
					  ,PESSOADOCUMENTO.TSSINCRONISMO
					  ,PESSOADOCUMENTO.SQSINCRONISMO
					  ,PESSOADOCUMENTO.IDSISTEMAORIGEM
					  ,PESSOADOCUMENTO.IDDOCUMENTOSISTEMAORIGEM
					  ,PESSOADOCUMENTO.DTEXPIRACAO
	 			  FROM CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO
                 WHERE PESSOADOCUMENTO.IDPESSOADOCUMENTO = :cAuxidPessoa;
           	
		EXEC SQL OPEN CursorListDocTipo;
	
		if(sqlca.sqlcode)
		{
		    ULOG_END("CPesDoc::ListDoc()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stPessoaDocumentoRegistro, 0, sizeof(stPessoaDocumentoRegistro) );
				EXEC SQL FETCH CursorListDocTipo INTO :stPessoaDocumentoRegistro:stPessoaDocumentoIndicator;
	
				Add( (char*)stPessoaDocumentoRegistro.stidPessoaDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.stidPessoa.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.sttsSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stsqSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stidSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumentoSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stdtexpiracao.arr
				   );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorListDocTipo;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CPesDoc::ListDoc()");
	return iCont;

GotoListDoc:
	throw TuxBasicOraException(sqlca.sqlcode);

}


int CPesDoc::ListPessoa( char* cnrDocumento )
{
	ULOG_START("CPesDoc::ListPessoa()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxnrDocumento = cnrDocumento;
		struct
		{
			VARCHAR stidPessoaDocumento[21+1];
			VARCHAR stidPessoa[21+1];
			VARCHAR stidDocumento[21+1];
			VARCHAR sttsSincronismo[21+1];
			VARCHAR stsqSincronismo[21+1];
			VARCHAR stidSistemaOrigem[21+1];
			VARCHAR stidDocumentoSistemaOrigem[255+1];
			VARCHAR stdtexpiracao[12+1];
		} stPessoaDocumentoRegistro;
		struct
		{
			short iidPessoaDocumento;
			short iidPessoa;
			short iidDocumento;
			short itsSincronismo;
			short isqSincronismo;
			short iidSistemaOrigem;
			short iidDocumentoSistemaOrigem;
			short idtexpiracao;
		} stPessoaDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraPessoaDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListPessoa;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE CursorListPessoa CURSOR FOR
				SELECT 
				     PESSOADOCUMENTO.IDPESSOADOCUMENTO
				    ,PESSOADOCUMENTO.IDPESSOA    
				    ,DOCUMENTO.IDDOCUMENTO
				    ,PESSOADOCUMENTO.TSSINCRONISMO
				    ,PESSOADOCUMENTO.SQSINCRONISMO
				    ,PESSOADOCUMENTO.IDSISTEMAORIGEM
				    ,PESSOADOCUMENTO.IDDOCUMENTOSISTEMAORIGEM
				    ,PESSOADOCUMENTO.DTEXPIRACAO   
				FROM 
				    CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
				    CUSTOMER.DOCUMENTO DOCUMENTO,
				    APOIO.UF UF,
				    APOIO.TIPODOCUMENTO TIPODOCUMENTO,
				    APOIO.PAIS PAIS
				WHERE PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
				AND   DOCUMENTO.IDUF = UF.IDUF
				AND   DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
				AND   DOCUMENTO.IDPAIS = PAIS.IDPAIS
				AND   DOCUMENTO.NRDOCUMENTO = :cAuxnrDocumento;
           	
		EXEC SQL OPEN CursorListPessoa;
	
		if(sqlca.sqlcode)
		{
		    ULOG_END("CPesDoc::ListPessoa()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stPessoaDocumentoRegistro, 0, sizeof(stPessoaDocumentoRegistro) );
				EXEC SQL FETCH CursorListPessoa INTO :stPessoaDocumentoRegistro:stPessoaDocumentoIndicator;
	
				Add( (char*)stPessoaDocumentoRegistro.stidPessoaDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.stidPessoa.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.sttsSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stsqSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stidSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumentoSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stdtexpiracao.arr
				   );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorListPessoa;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CPesDoc::ListPessoa()");
	return iCont;

GotoListPessoa:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CPesDoc::ListPessoa( char* cnrDocumento, char* cidTipoDocumento )
{
	ULOG_START("CPesDoc::ListPessoa()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxnrDocumento = cnrDocumento;
		char* cAuxidTipoDocumento = cidTipoDocumento;
		struct
		{
			VARCHAR stidPessoaDocumento[21+1];
			VARCHAR stidPessoa[21+1];
			VARCHAR stidDocumento[21+1];
			VARCHAR sttsSincronismo[21+1];
			VARCHAR stsqSincronismo[21+1];
			VARCHAR stidSistemaOrigem[21+1];
			VARCHAR stidDocumentoSistemaOrigem[255+1];
			VARCHAR stdtexpiracao[12+1];
			VARCHAR stnmPessoa[255+1];
			VARCHAR stnmNome[255+1];
			VARCHAR stnmNomemeio[255+1];
			VARCHAR stnmSobrenome[255+1];
		} stPessoaDocumentoRegistro;
		struct
		{
			short iidPessoaDocumento;
			short iidPessoa;
			short iidDocumento;
			short itsSincronismo;
			short isqSincronismo;
			short iidSistemaOrigem;
			short iidDocumentoSistemaOrigem;
			short idtexpiracao;
			short inmPessoa;
			short inmNome;
			short inmNomemeio;
			short inmSobrenome;
		} stPessoaDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListPessoaTipoDocumento;
		sqlca.sqlcode=0;
	
	   	//Nao retorna pessoas com ids zeradas (documento, pessoadocumento, nem pessoa)
		EXEC SQL 
	   		DECLARE 
				CursorListPessoaTipoDocumento CURSOR FOR			
			SELECT PESSOADOCUMENTO.IDPESSOADOCUMENTO,
			       PESSOADOCUMENTO.IDPESSOA,
			       DOCUMENTO.IDDOCUMENTO,
			       PESSOADOCUMENTO.TSSINCRONISMO,
			       PESSOADOCUMENTO.SQSINCRONISMO,
			       PESSOADOCUMENTO.IDSISTEMAORIGEM,
			       PESSOADOCUMENTO.IDDOCUMENTOSISTEMAORIGEM,
			       PESSOADOCUMENTO.DTEXPIRACAO,
			       PESSOA.NMPESSOA,
			       PESSOA.NMNOME,
			       TRIM(PESSOA.NMNOME)||' '|| TRIM(PESSOA.NMNOMEMEIO) NMNOMECOMPLETO,
			       PESSOA.NMSOBRENOME
			FROM   CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
			       CUSTOMER.DOCUMENTO DOCUMENTO,
			       CUSTOMER.PESSOA
			WHERE  PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
			       AND PESSOA.IDPESSOA = PESSOADOCUMENTO.IDPESSOA
			       AND DOCUMENTO.NRDOCUMENTO = :cAuxnrDocumento
			  	   AND DOCUMENTO.IDTIPODOCUMENTO = :cAuxidTipoDocumento
				   AND PESSOADOCUMENTO.IDPESSOADOCUMENTO > 0
				   AND PESSOADOCUMENTO.IDPESSOA > 0
				   AND DOCUMENTO.IDDOCUMENTO > 0; 
			
           	
		EXEC SQL OPEN CursorListPessoaTipoDocumento;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CPesDoc::ListPessoa()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stPessoaDocumentoRegistro, 0, sizeof(stPessoaDocumentoRegistro) );
				EXEC SQL FETCH CursorListPessoaTipoDocumento INTO :stPessoaDocumentoRegistro:stPessoaDocumentoIndicator;
	
				Add( (char*)stPessoaDocumentoRegistro.stidPessoaDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.stidPessoa.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.sttsSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stsqSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stidSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumentoSistemaOrigem.arr
					,(char*)stPessoaDocumentoRegistro.stdtexpiracao.arr
					,(char*)stPessoaDocumentoRegistro.stnmPessoa.arr
					,(char*)stPessoaDocumentoRegistro.stnmNome.arr
					,(char*)stPessoaDocumentoRegistro.stnmNomemeio.arr
					,(char*)stPessoaDocumentoRegistro.stnmSobrenome.arr
					);
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorListPessoaTipoDocumento;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CPesDoc::ListPessoa()");
	return iCont;

GotoListPessoaTipoDocumento:
	throw TuxBasicOraException(sqlca.sqlcode);

}


int CPesDoc::ListPessoaUsuario( char* cnrDocumento, char* cidTipoDocumento )
{
	ULOG_START("CPesDoc::ListPessoaUsuario()");
	
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxnrDocumento = cnrDocumento;
		char* cAuxidTipoDocumento = cidTipoDocumento;
		struct
		{
			VARCHAR stidPessoaDocumento[21+1];
			VARCHAR stidPessoa[21+1];
			VARCHAR stidDocumento[21+1];
			VARCHAR sttsSincronismo[21+1];
			VARCHAR stsqSincronismo[21+1];
			VARCHAR stidSistemaOrigem[21+1];
			VARCHAR stidDocumentoSistemaOrigem[255+1];
			VARCHAR stdtexpiracao[12+1];
			VARCHAR stnmPessoa[255+1];
			VARCHAR stnmNome[255+1];
			VARCHAR stnmNomemeio[255+1];
			VARCHAR stnmSobrenome[255+1];
		} stPessoaDocumentoRegistro;
		struct
		{
			short iidPessoaDocumento;
			short iidPessoa;
			short iidDocumento;
			short itsSincronismo;
			short isqSincronismo;
			short iidSistemaOrigem;
			short iidDocumentoSistemaOrigem;
			short idtexpiracao;
			short inmPessoa;
			short inmNome;
			short inmNomemeio;
			short inmSobrenome;
		} stPessoaDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListPessoaUsuarioTipoDocumento;
	sqlca.sqlcode=0;

	//Nao retorna pessoas com ids zeradas (documento, pessoadocumento, nem pessoa)
	EXEC SQL 
	DECLARE 
		CursorListPessoaUsuarioTipoDocumento CURSOR FOR
	SELECT 
		PESSOADOCUMENTO.IDPESSOADOCUMENTO
	   ,PESSOADOCUMENTO.IDPESSOA
	   ,PESSOADOCUMENTO.IDDOCUMENTO
	   ,PESSOADOCUMENTO.TSSINCRONISMO
	   ,PESSOADOCUMENTO.SQSINCRONISMO
	   ,PESSOADOCUMENTO.IDSISTEMAORIGEM
	   ,PESSOADOCUMENTO.IDDOCUMENTOSISTEMAORIGEM
	   ,PESSOADOCUMENTO.DTEXPIRACAO
	   ,PESSOA.NMPESSOA
	   ,PESSOA.NMNOME
	   ,TRIM(PESSOA.NMNOME)||' '||TRIM(PESSOA.NMNOMEMEIO) NMNOMECOMPLETO
	   ,PESSOA.NMSOBRENOME
	FROM 
        CUSTOMER.DOCUMENTO DOCUMENTO,
		CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
        CUSTOMER.PESSOA PESSOA,
        ACESSO.USUARIO USUARIO
    WHERE 
        DOCUMENTO.IDDOCUMENTO = PESSOADOCUMENTO.IDDOCUMENTO
    AND
        PESSOADOCUMENTO.IDPESSOA = PESSOA.IDPESSOA
    AND
        PESSOA.IDPESSOA = USUARIO.IDPESSOAUSUARIO
	AND
		PESSOA.IDPESSOA > 0
	AND
		PESSOADOCUMENTO.IDPESSOADOCUMENTO > 0
	AND
		DOCUMENTO.IDDOCUMENTO > 0
	AND
		DOCUMENTO.NRDOCUMENTO = :cAuxnrDocumento
	AND 
		DOCUMENTO.IDTIPODOCUMENTO = :cAuxidTipoDocumento;
        
	EXEC SQL OPEN CursorListPessoaUsuarioTipoDocumento;

	for(;;)
	{
		memset( &stPessoaDocumentoRegistro, 0, sizeof(stPessoaDocumentoRegistro) );
		EXEC SQL FETCH CursorListPessoaUsuarioTipoDocumento INTO :stPessoaDocumentoRegistro:stPessoaDocumentoIndicator;

		Add( 
			 (char*)stPessoaDocumentoRegistro.stidPessoaDocumento.arr
			,(char*)stPessoaDocumentoRegistro.stidPessoa.arr
			,(char*)stPessoaDocumentoRegistro.stidDocumento.arr
			,(char*)stPessoaDocumentoRegistro.sttsSincronismo.arr
			,(char*)stPessoaDocumentoRegistro.stsqSincronismo.arr
			,(char*)stPessoaDocumentoRegistro.stidSistemaOrigem.arr
			,(char*)stPessoaDocumentoRegistro.stidDocumentoSistemaOrigem.arr
			,(char*)stPessoaDocumentoRegistro.stdtexpiracao.arr
			,(char*)stPessoaDocumentoRegistro.stnmPessoa.arr
			,(char*)stPessoaDocumentoRegistro.stnmNome.arr
			,(char*)stPessoaDocumentoRegistro.stnmNomemeio.arr
			,(char*)stPessoaDocumentoRegistro.stnmSobrenome.arr
		);

	}
	EXEC SQL CLOSE CursorListPessoaUsuarioTipoDocumento;

	ULOG_END("CPesDoc::ListPessoaUsuario()");
	return Quantidade();

GotoListPessoaUsuarioTipoDocumento:
	throw TuxBasicOraException(sqlca.sqlcode);

}


int CPesDoc::ListPessoaIdDoc( char* cidDocumento )
{
	ULOG_START("CPesDoc::ListPessoaIdDoc()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidDocumento = cidDocumento;
		struct
		{
			VARCHAR stidPessoaDocumento[21+1];
			VARCHAR stidPessoa[21+1];
			VARCHAR stidDocumento[21+1];
			VARCHAR sttsSincronismo[21+1];
			VARCHAR stsqSincronismo[21+1];
			VARCHAR stidSistemaOrigem[21+1];
			VARCHAR stidDocumentoSistemaOrigem[255+1];
			VARCHAR stdtexpiracao[12+1];
		} stPessoaDocumentoRegistro;
		struct
		{
			short iidPessoaDocumento;
			short iidPessoa;
			short iidDocumento;
			short itsSincronismo;
			short isqSincronismo;
			short iidSistemaOrigem;
			short iidDocumentoSistemaOrigem;
			short idtexpiracao;
		} stPessoaDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraPessoaDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListPessoaIdDoc;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE CursorListDocIdTipo CURSOR FOR
				SELECT PESSOADOCUMENTO.IDPESSOADOCUMENTO
					  ,PESSOADOCUMENTO.IDPESSOA
					  ,PESSOADOCUMENTO.IDDOCUMENTO
					  ,PESSOADOCUMENTO.TSSINCRONISMO
					  ,PESSOADOCUMENTO.SQSINCRONISMO
					  ,PESSOADOCUMENTO.IDSISTEMAORIGEM
					  ,PESSOADOCUMENTO.IDDOCUMENTOSISTEMAORIGEM
					  ,PESSOADOCUMENTO.DTEXPIRACAO
	 			  FROM CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO
                 WHERE PESSOADOCUMENTO.IDDOCUMENTO = :cAuxidDocumento;
           	
		EXEC SQL OPEN CursorListDocIdTipo;
	
		if(sqlca.sqlcode)
        {
		    ULOG_END("CPesDoc::ListPessoaIdDoc()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stPessoaDocumentoRegistro, 0, sizeof(stPessoaDocumentoRegistro) );
				EXEC SQL FETCH CursorListDocIdTipo INTO :stPessoaDocumentoRegistro:stPessoaDocumentoIndicator;
	
				Add( (char*)stPessoaDocumentoRegistro.stidPessoaDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.stidPessoa.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.sttsSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stsqSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stidSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumentoSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stdtexpiracao.arr
				   );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorListDocIdTipo;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CPesDoc::ListPessoaIdDoc()");
	return iCont;

GotoListPessoaIdDoc:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CPesDoc::VerificaPessoaIdDoc( char* cidPessoa, char* cidDocumento )
{
	ULOG_START("CPesDoc::VerificaPessoaIdDoc()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidDocumento = cidDocumento;
		char* cAuxidPessoa = cidPessoa;
		struct
		{
			VARCHAR stidPessoaDocumento[21+1];
			VARCHAR stidPessoa[21+1];
			VARCHAR stidDocumento[21+1];
			VARCHAR sttsSincronismo[21+1];
			VARCHAR stsqSincronismo[21+1];
			VARCHAR stidSistemaOrigem[21+1];
			VARCHAR stidDocumentoSistemaOrigem[255+1];
			VARCHAR stdtexpiracao[12+1];
		} stPessoaDocumentoRegistro;
		struct
		{
			short iidPessoaDocumento;
			short iidPessoa;
			short iidDocumento;
			short itsSincronismo;
			short isqSincronismo;
			short iidSistemaOrigem;
			short iidDocumentoSistemaOrigem;
			short idtexpiracao;
		} stPessoaDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraPessoaDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoVerificaPessoaIdDoc;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE CursorVerificaPessoaIdDoc CURSOR FOR
				SELECT 
					 PESSOADOCUMENTO.IDPESSOADOCUMENTO
					,PESSOADOCUMENTO.IDPESSOA
					,PESSOADOCUMENTO.IDDOCUMENTO
					,PESSOADOCUMENTO.TSSINCRONISMO
					,PESSOADOCUMENTO.SQSINCRONISMO
					,PESSOADOCUMENTO.IDSISTEMAORIGEM
					,PESSOADOCUMENTO.IDDOCUMENTOSISTEMAORIGEM
					,PESSOADOCUMENTO.DTEXPIRACAO
	 			  FROM 
	 			  	CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO
                 WHERE 
                 	PESSOADOCUMENTO.IDDOCUMENTO = :cAuxidDocumento
                   AND
                 	PESSOADOCUMENTO.IDPESSOA = :cAuxidPessoa;
                   	
           	
		EXEC SQL OPEN CursorVerificaPessoaIdDoc;
	
		if(sqlca.sqlcode)
		{
		    ULOG_END("CPesDoc::VerificaPessoaIdDoc()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stPessoaDocumentoRegistro, 0, sizeof(stPessoaDocumentoRegistro) );
				EXEC SQL FETCH CursorVerificaPessoaIdDoc INTO :stPessoaDocumentoRegistro:stPessoaDocumentoIndicator;
	
				Add( (char*)stPessoaDocumentoRegistro.stidPessoaDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.stidPessoa.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.sttsSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stsqSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stidSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumentoSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stdtexpiracao.arr
				   );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorVerificaPessoaIdDoc;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CPesDoc::VerificaPessoaIdDoc()");
	return iCont;

GotoVerificaPessoaIdDoc:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CPesDoc::VerificaPessoaDoc( char* cidPessoa, char* cnrDocumento )
{
	ULOG_START("CPesDoc::VerificaPessoaDoc()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxnrDocumento = cnrDocumento;
		char* cAuxidPessoa = cidPessoa;
		struct
		{
			VARCHAR stidPessoaDocumento[21+1];
			VARCHAR stidPessoa[21+1];
			VARCHAR stidDocumento[21+1];
			VARCHAR sttsSincronismo[21+1];
			VARCHAR stsqSincronismo[21+1];
			VARCHAR stidSistemaOrigem[21+1];
			VARCHAR stidDocumentoSistemaOrigem[255+1];
			VARCHAR stdtexpiracao[12+1];
		} stPessoaDocumentoRegistro;
		struct
		{
			short iidPessoaDocumento;
			short iidPessoa;
			short iidDocumento;
			short itsSincronismo;
			short isqSincronismo;
			short iidSistemaOrigem;
			short iidDocumentoSistemaOrigem;
			short idtexpiracao;
		} stPessoaDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraPessoaDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoVerificaPessoaDoc;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE CursorVerificaPessoaDoc CURSOR FOR
                 SELECT PESSOADOCUMENTO.IDPESSOADOCUMENTO,
				       PESSOADOCUMENTO.IDPESSOA,
				       DOCUMENTO.IDDOCUMENTO,
				       PESSOADOCUMENTO.TSSINCRONISMO,
				       PESSOADOCUMENTO.SQSINCRONISMO,
				       PESSOADOCUMENTO.IDSISTEMAORIGEM,
				       PESSOADOCUMENTO.IDDOCUMENTOSISTEMAORIGEM,
				       PESSOADOCUMENTO.DTEXPIRACAO
				FROM   CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
				       CUSTOMER.DOCUMENTO DOCUMENTO,
				       CUSTOMER.PESSOA
				WHERE  PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
				       AND PESSOA.IDPESSOA = PESSOADOCUMENTO.IDPESSOA
				       AND DOCUMENTO.NRDOCUMENTO = :cAuxnrDocumento
					   AND PESSOADOCUMENTO.IDPESSOA = :cAuxidPessoa;
                   	
           	
		EXEC SQL OPEN CursorVerificaPessoaDoc;
	
		if(sqlca.sqlcode)
		{
		    ULOG_END("CPesDoc::VerificaPessoaDoc()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stPessoaDocumentoRegistro, 0, sizeof(stPessoaDocumentoRegistro) );
				EXEC SQL FETCH CursorVerificaPessoaDoc INTO :stPessoaDocumentoRegistro:stPessoaDocumentoIndicator;
	
				Add( (char*)stPessoaDocumentoRegistro.stidPessoaDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.stidPessoa.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.sttsSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stsqSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stidSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumentoSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stdtexpiracao.arr
				   );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorVerificaPessoaDoc;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CPesDoc::VerificaPessoaDoc()");
	return iCont;

GotoVerificaPessoaDoc:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CPesDoc::VerificaPessoaDocIdTipo( char* cidPessoa, char* cnrDocumento, char* cidTipo )
{
	ULOG_START("CPesDoc::VerificaPessoaDocIdTipo()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxnrDocumento = cnrDocumento;
		char* cAuxidPessoa = cidPessoa;
		char* cAuxidTipo = cidTipo;
		struct
		{
			VARCHAR stidPessoaDocumento[21+1];
			VARCHAR stidPessoa[21+1];
			VARCHAR stidDocumento[21+1];
			VARCHAR sttsSincronismo[21+1];
			VARCHAR stsqSincronismo[21+1];
			VARCHAR stidSistemaOrigem[21+1];
			VARCHAR stidDocumentoSistemaOrigem[255+1];
			VARCHAR stdtexpiracao[12+1];
		} stPessoaDocumentoRegistro;
		struct
		{
			short iidPessoaDocumento;
			short iidPessoa;
			short iidDocumento;
			short itsSincronismo;
			short isqSincronismo;
			short iidSistemaOrigem;
			short iidDocumentoSistemaOrigem;
			short idtexpiracao;
		} stPessoaDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraPessoaDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoVerificaPessoaDocIdTipo;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE CursorVerificaPessoaDocIdTipo CURSOR FOR
                    SELECT PESSOADOCUMENTO.IDPESSOADOCUMENTO,
					       PESSOADOCUMENTO.IDPESSOA,
					       DOCUMENTO.IDDOCUMENTO,
					       PESSOADOCUMENTO.TSSINCRONISMO,
					       PESSOADOCUMENTO.SQSINCRONISMO,
					       PESSOADOCUMENTO.IDSISTEMAORIGEM,
					       PESSOADOCUMENTO.IDDOCUMENTOSISTEMAORIGEM,
					       PESSOADOCUMENTO.DTEXPIRACAO
					FROM   CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
					       CUSTOMER.DOCUMENTO DOCUMENTO,
					       CUSTOMER.PESSOA
					WHERE  PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
					       AND PESSOA.IDPESSOA = PESSOADOCUMENTO.IDPESSOA
					       AND DOCUMENTO.NRDOCUMENTO = :cAuxnrDocumento
						   AND PESSOADOCUMENTO.IDPESSOA = :cAuxidPessoa
					       AND DOCUMENTO.IDTIPODOCUMENTO = :cAuxidTipo;
                   	
           	
		EXEC SQL OPEN CursorVerificaPessoaDocIdTipo;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CPesDoc::VerificaPessoaDocIdTipo()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stPessoaDocumentoRegistro, 0, sizeof(stPessoaDocumentoRegistro) );
				EXEC SQL FETCH CursorVerificaPessoaDocIdTipo INTO :stPessoaDocumentoRegistro:stPessoaDocumentoIndicator;
	
				Add( (char*)stPessoaDocumentoRegistro.stidPessoaDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.stidPessoa.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.sttsSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stsqSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stidSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumentoSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stdtexpiracao.arr
				   );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorVerificaPessoaDocIdTipo;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CPesDoc::VerificaPessoaDocIdTipo()");
	return iCont;

GotoVerificaPessoaDocIdTipo:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CPesDoc::VerificaPessoaDocSiglaTipo( char* cidPessoa, char* cnrDocumento, char* csgTipo )
{
	ULOG_START("CPesDoc::VerificaPessoaDocSiglaTipo()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxnrDocumento = cnrDocumento;
		char* cAuxidPessoa = cidPessoa;
		char* cAuxsgTipo = csgTipo;
		struct
		{
			VARCHAR stidPessoaDocumento[21+1];
			VARCHAR stidPessoa[21+1];
			VARCHAR stidDocumento[21+1];
			VARCHAR sttsSincronismo[21+1];
			VARCHAR stsqSincronismo[21+1];
			VARCHAR stidSistemaOrigem[21+1];
			VARCHAR stidDocumentoSistemaOrigem[255+1];
			VARCHAR stdtexpiracao[12+1];
		} stPessoaDocumentoRegistro;
		struct
		{
			short iidPessoaDocumento;
			short iidPessoa;
			short iidDocumento;
			short itsSincronismo;
			short isqSincronismo;
			short iidSistemaOrigem;
			short iidDocumentoSistemaOrigem;
			short idtexpiracao;
		} stPessoaDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{
		ZeraPessoaDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoVerificaPessoaDocSiglaTipo;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE CursorVerificaPessoaDocSiglaTipo CURSOR FOR
	              	SELECT PESSOADOCUMENTO.IDPESSOADOCUMENTO,
					       PESSOADOCUMENTO.IDPESSOA,
					       DOCUMENTO.IDDOCUMENTO,
					       PESSOADOCUMENTO.TSSINCRONISMO,
					       PESSOADOCUMENTO.SQSINCRONISMO,
					       PESSOADOCUMENTO.IDSISTEMAORIGEM,
					       PESSOADOCUMENTO.IDDOCUMENTOSISTEMAORIGEM,
					       PESSOADOCUMENTO.DTEXPIRACAO
					FROM   CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
					       CUSTOMER.DOCUMENTO DOCUMENTO,
					       CUSTOMER.PESSOA,
					       APOIO.TIPODOCUMENTO
					WHERE  PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
					       AND PESSOA.IDPESSOA = PESSOADOCUMENTO.IDPESSOA
					       AND TIPODOCUMENTO.IDTIPODOCUMENTO = DOCUMENTO.IDTIPODOCUMENTO
					       AND DOCUMENTO.NRDOCUMENTO = :cAuxnrDocumento
					       AND PESSOADOCUMENTO.IDPESSOA = :cAuxidPessoa
					       AND TIPODOCUMENTO.SGTIPODOCUMENTO = :cAuxsgTipo;
      
                   	
           	
		EXEC SQL OPEN CursorVerificaPessoaDocSiglaTipo;
	
		if(sqlca.sqlcode)
		{
		    ULOG_END("CPesDoc::VerificaPessoaDocSiglaTipo()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stPessoaDocumentoRegistro, 0, sizeof(stPessoaDocumentoRegistro) );
				EXEC SQL FETCH CursorVerificaPessoaDocSiglaTipo INTO :stPessoaDocumentoRegistro:stPessoaDocumentoIndicator;
	
				Add( (char*)stPessoaDocumentoRegistro.stidPessoaDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.stidPessoa.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumento.arr
				    ,(char*)stPessoaDocumentoRegistro.sttsSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stsqSincronismo.arr
				    ,(char*)stPessoaDocumentoRegistro.stidSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stidDocumentoSistemaOrigem.arr
				    ,(char*)stPessoaDocumentoRegistro.stdtexpiracao.arr
				   );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorVerificaPessoaDocSiglaTipo;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CPesDoc::VerificaPessoaDocSiglaTipo()");
	return iCont;

GotoVerificaPessoaDocSiglaTipo:
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CPesDoc::GetXml( char* cNomeTag, XMLGen*xml )
{
	ULOG_START("CPesDoc::GetXml()");
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			xml->addProp(	"xmlns", "usuario.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{
				xml->addItem("idPessoaDocumento" , Registro(x)->cidPessoaDocumento);
				xml->addItem("idPessoa" , Registro(x)->cidPessoa);
				xml->addItem("idDocumento" , Registro(x)->cidDocumento);
				xml->addItem("tsSincronismo" , Registro(x)->ctsSincronismo);
				xml->addItem("sqSincronismo" , Registro(x)->csqSincronismo);
				xml->addItem("idSistemaOrigem" , Registro(x)->cidSistemaOrigem);
				xml->addItem("idDocumentoSistemaOrigem" , Registro(x)->cidDocumentoSistemaOrigem);
				xml->addItem("dtexpiracao" , Registro(x)->cdtexpiracao );
			}
			xml->closeTag();
		}
	}
	ULOG_END("CPesDoc::GetXml()");
}

int CPesDoc::InsertId( char* cidPessoa
			          ,char* cidDocumento
			          ,char* cidUser )
{
	ULOG_START("CPesDoc::InsertId()");
	
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR stidPessoaDocumento[21+1];
		VARCHAR stidSistemaOrigem[21+1];
		VARCHAR stidDocumentoSistemaOrigem[255+1];
		char* cAuxidUser = cidUser;
		char* cAuxidPessoa = cidPessoa;
		char* cAuxidDocumento = cidDocumento;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraPessoaDocumento();
		memset( &stidPessoaDocumento, 0, sizeof(stidPessoaDocumento) );
		memset( &stidSistemaOrigem, 0, sizeof(stidSistemaOrigem) );
		memset( &stidDocumentoSistemaOrigem, 0, sizeof(stidDocumentoSistemaOrigem) );
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsertId;
		sqlca.sqlcode=0;

		//Recupera o id do sistemas origem, no caso, Front Office
		EXEC SQL
		SELECT
			SISTEMAORIGEM.IDSISTEMAORIGEM
		INTO
			:stidSistemaOrigem
		FROM
			APOIO.SISTEMAORIGEM SISTEMAORIGEM
		WHERE
			UPPER(SISTEMAORIGEM.SGSISTEMAORIGEM) = 'FO';

		//Definicao da VIVO:
		//	gravar a sigla de tipo de documento em idDocumentoSistemaOrigem em pessoadocumento
		EXEC SQL
		SELECT
			SGTIPODOCUMENTO
		INTO
			:stidDocumentoSistemaOrigem
		FROM
			CUSTOMER.DOCUMENTO DOCUMENTO,
			APOIO.TIPODOCUMENTO TIPODOCUMENTO
		WHERE
			DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
		AND
			IDDOCUMENTO = :cAuxidDocumento;

		if(sqlca.sqlcode)
		{
		    ULOG_END("CPesDoc::InsertId()");
			return 0;
		}
		
		//Recupera uma UD unica
		EXEC SQL
			SELECT CUSTOMER.PESSOADOCUMENTOSQ.NEXTVAL
			  INTO :stidPessoaDocumento
			  FROM DUAL;
		
		//Insere um documento
		EXEC SQL
			INSERT INTO CUSTOMER.PESSOADOCUMENTO
			  (IDPESSOADOCUMENTO
			  ,IDPESSOA
			  ,IDDOCUMENTO
			  ,IDSISTEMAORIGEM
			  ,IDDOCUMENTOSISTEMAORIGEM
			  ,IDUSUARIOALTERACAO
			  ,DTULTIMAALTERACAO)
			VALUES
			  (:stidPessoaDocumento
			  ,:cAuxidPessoa
			  ,:cAuxidDocumento
			  ,:stidSistemaOrigem
			  ,:stidDocumentoSistemaOrigem
			  ,:cAuxidUser
			  ,SYSDATE);		
	
		if(sqlca.sqlcode)
		{
		    ULOG_END("CPesDoc::InsertId()");
			return 0;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CPesDoc::InsertId()");
	return 1;

GotoInsertId:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CPesDoc::RemoveRelacaoComPessoa( char* cidPessoa )
{
	ULOG_START("CPesDoc::RemoveRelacaoComPessoa()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidPessoaAux = cidPessoa;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoRemoveRelacaoComPessoa;
	sqlca.sqlcode=0;

	EXEC SQL
	DELETE FROM 
		CUSTOMER.PESSOADOCUMENTO
	WHERE
		IDPESSOA = :cidPessoaAux;

	ULOG_END("CPesDoc::RemoveRelacaoComPessoa()");
	return 1;//Sempre retornar 1, para uso futuro

GotoRemoveRelacaoComPessoa:
	throw TuxBasicOraException(sqlca.sqlcode);
}

char* CPesDoc::toUpper( char* cText )
{
	ULOG_START("CPesDoc::toUpper()");
	int iSize = strlennull( cText );
	if( iSize > 300 )
		iSize = 300;
	memset( cTexto, 0, sizeof( cTexto ) );
	for( int x=0; x<iSize; x++ )
		cText[x] = toupper(cText[x]);
	ULOG_END("CPesDoc::toUpper()");
	return &cText[0];
}

char* CPesDoc::toLower( char* cText )
{
	ULOG_START("CPesDoc::toLower()");
	int iSize = strlennull( cText );
	if( iSize > 300 )
		iSize = 300;
	memset( cTexto, 0, sizeof( cTexto ) );
	for( int x=0; x<iSize; x++ )
		cText[x] = tolower(cText[x]);
	ULOG_END("CPesDoc::toLower()");
	return &cText[0];
}
