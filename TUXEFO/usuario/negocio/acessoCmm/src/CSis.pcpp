/*****************************************************************************
 *
 * Modulo:    CSis
 * Arquivo:   CSis.cpp
 * Proposito: Funcao de Negocios 
 * Historico:
 * Data        Autor                 Descricao
 * ----------  --------------------  -----------------------------------------
 * 18/05/2004  C_RECOliveira         Criacao
 * 18/05/2004  C_EDMartins           Criacao
 *
 ****************************************************************************/
/**************************************************************************
 * Notas:
 *
 **************************************************************************/

//Definicao Global
#define CSisCPP

//Header
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <tuxfw.h>
#include "CSis.h"
#include "CSafePointer.h"

char* CSis::RTrim(char *pszString)
{
    ULOG_START("CSis::RTrim()");
    
    int iLen;

    iLen=strlen(pszString);

    for(;;)
    {
        if(pszString[iLen-1] != ' ')
            break;

        iLen--;

        if(iLen == 0)
            break;
    }
    pszString[iLen] = 0x00;
	
	ULOG_END("CSis::RTrim()");
	return pszString;
}


//Classe:
int CSis::SisRemover(DOMNode*dnode, XMLGen*xml_g,
				     char* cLogUser)
{
	ULOG_START("CSis::SisRemover()");
	// Declarar Estruturas
	struct sqlca sqlca; 
	
	// Declarar Objetos
	CSafePointer oSafePointer;

	// Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		int idSistema;
	EXEC SQL END DECLARE SECTION;

	//Declara variaveis auxiliares
	char *pc;
	//Se o ID nao for numerico entao retornar com codigo de erro
	pc = oSafePointer.getTag(dnode,"idSistema",0);
	if ( pc == NULL )
	{
	    ULOG_END("CSis::SisRemover()");
		return 3;
	}

	//Le o ID
	if ( ( idSistema = atoi( pc ) ) == 0 )
	{
		ULOG_END("CSis::SisRemover()");
		return 2;
	}

	sqlca.sqlcode=0;

	EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
	DELETE FROM acesso.Sistema 
	WHERE idSistema = :idSistema;

	if(sqlca.sqlcode)
	{
		ULOG_END("CSis::SisRemover()");
		return 4; 
	}

    ULOG_END("CSis::SisRemover()");
	return 0;

// Tratamento de Exception
ErrorF:
	ULOG_END("CSis::SisRemover()");
	if( sqlca.sqlcode == -2292 )
		return 5;
	else
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CSis::SisEditar(DOMNode*dnode,XMLGen*xml_g,
				    char* cLogUser)
{
	ULOG_START("CSis::SisEditar()");
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;
		int   iCont;

		struct Tstruct {
			int idSistema;
			char csgSistemaOperacional[256];
			char cnmSistemaOperacional[256];
			char cnmUrlBase[256];
			char* cinAcessoControlado;
		} tstruct;

	EXEC SQL END DECLARE SECTION;

	/************************************************************************
	 * Processamento Principal
	 ************************************************************************/
	try
	{
		memset( &tstruct, 0, sizeof(Tstruct) );
		
		if ( ( tstruct.idSistema = atoi( oSafePointer.getTag( dnode, "idSistema", 0 ) ) )<=0 ) 
		{
			ULOG_END("CSis::SisEditar()");
			return 1;
		}
	
		strcpy(tstruct.csgSistemaOperacional, oSafePointer.getTag(dnode,"sgSistema",0) );
		if ( strlen ( tstruct.csgSistemaOperacional ) == 0 ) 
		{
			ULOG_END("CSis::SisEditar()");
			return 2;
		}
	
		strcpy(tstruct.cnmSistemaOperacional , oSafePointer.getTag(dnode,"dsSistema",0) );
		if ( strlen ( tstruct.cnmSistemaOperacional ) == 0 ) 
		{
			ULOG_END("CSis::SisEditar()");
			return 3;
		}
	
		strcpy(tstruct.cnmUrlBase , oSafePointer.getTag(dnode,"nmUrlBase",0) );
		if ( strlen ( tstruct.cnmUrlBase ) == 0 ) 
	    {
			ULOG_END("CSis::SisEditar()");
			return 4;
		}
	
		if( strlennull( (tstruct.cinAcessoControlado = oSafePointer.getTag( dnode, "inAcessoControlado", 0 ) ) ) <= 0 )
		{
			ULOG_END("CSis::SisEditar()");
			return 5;
		}
	
		sqlca.sqlcode=0;
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		
		EXEC SQL
			SELECT
				COUNT( IDSISTEMA )
			INTO
				:iCont
			FROM
				ACESSO.SISTEMA
			WHERE
				UPPER(NMSISTEMAOPERACIONAL) = UPPER(:tstruct.cnmSistemaOperacional)
			AND
				IDSISTEMA != :tstruct.idSistema;

		if( iCont > 0 )
		{
			ULOG_END("CSis::SisEditar()");
			return 6;//Nome duplicado			
		}
	
		EXEC SQL
			SELECT
				COUNT( IDSISTEMA )
			INTO
				:iCont
			FROM
				ACESSO.SISTEMA
			WHERE
				UPPER(SGSISTEMAOPERACIONAL) = UPPER(:tstruct.csgSistemaOperacional)
			AND
				IDSISTEMA != :tstruct.idSistema;

		if( iCont > 0 )
		{
			ULOG_END("CSis::SisEditar()");
			return 7;//Sigla duplicada
		}
	
		EXEC SQL 
		UPDATE 	acesso.Sistema 
	    SET 	sgSistemaOperacional = :tstruct.csgSistemaOperacional,
	        	nmSistemaOperacional = :tstruct.cnmSistemaOperacional,
	        	nmUrlBase = :tstruct.cnmUrlBase,
	        	inAcessoControlado = :tstruct.cinAcessoControlado,
				IDUSUARIOALTERACAO = :cLogUserOra, 
				DTULTIMAALTERACAO  = SYSDATE
		WHERE 	idSistema = :tstruct.idSistema;
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSis::SisEditar()");
	if(sqlca.sqlcode)
		return 8; 
	else
		return 0;


/************************************************************************
 * Tratamento de Exception
 ************************************************************************/

ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSis::SisInserir(DOMNode*dnode,XMLGen*xml_g,
				     char* cLogUser)
{
	ULOG_START("CSis::SisInserir()");

	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;
		int iCont;

		struct Tstruct {
			int idSistema;
			char csgSistemaOperacional[256];
			char cnmSistemaOperacional[256];
			char cnmUrlBase[256];
			int inAcessoControlado;
		} tstruct;

	EXEC SQL END DECLARE SECTION;

	/************************************************************************
	 * Processamento Principal
	 ************************************************************************/
	try
	{
		memset( &tstruct, 0, sizeof(Tstruct) );
	
		strcpy(tstruct.csgSistemaOperacional, oSafePointer.getTag(dnode,"sgSistema",0) );
		if ( strlen ( tstruct.csgSistemaOperacional ) == 0 ) 
		{
			ULOG_END("CSis::SisInserir()");
			return 2;
		}
	
		strcpy(tstruct.cnmSistemaOperacional , oSafePointer.getTag(dnode,"dsSistema",0) );
		if ( strlen ( tstruct.cnmSistemaOperacional ) == 0 ) 
		{
			ULOG_END("CSis::SisInserir()");
			return 3;
		}
	
		strcpy(tstruct.cnmUrlBase , oSafePointer.getTag(dnode,"nmUrlBase",0) );
		if ( strlen ( tstruct.cnmUrlBase ) == 0 ) 
		{
			ULOG_END("CSis::SisInserir()");
			return 4;
		}
	
		if ( ( tstruct.inAcessoControlado = atoi ( oSafePointer.getTag( dnode, "inAcessoControlado", 0 ) ) )<0 ) 
		{
			ULOG_END("CSis::SisInserir()");
			return 5;
		}
	
		sqlca.sqlcode=0;
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		
		EXEC SQL
			SELECT
				COUNT( IDSISTEMA )
			INTO
				:iCont
			FROM
				ACESSO.SISTEMA
			WHERE
				UPPER(NMSISTEMAOPERACIONAL) = UPPER(:tstruct.cnmSistemaOperacional);

		if( iCont > 0 )
		{
			ULOG_END("CSis::SisInserir()");
			return 6;//Nome duplicado			
		}
	
		EXEC SQL
			SELECT
				COUNT( IDSISTEMA )
			INTO
				:iCont
			FROM
				ACESSO.SISTEMA
			WHERE
				UPPER(SGSISTEMAOPERACIONAL) = UPPER(:tstruct.csgSistemaOperacional);

		if( iCont > 0 )
		{
			ULOG_END("CSis::SisInserir()");
			return 7;//Sigla duplicada		
		}
	
		EXEC SQL
		SELECT acesso.sistemasq.nextval
		INTO :tstruct.idSistema
		FROM dual;
	
		EXEC SQL 
			INSERT INTO ACESSO.SISTEMA  
			( 
				IDSISTEMA
			   ,SGSISTEMAOPERACIONAL
			   ,NMSISTEMAOPERACIONAL
			   ,NMURLBASE
			   ,INACESSOCONTROLADO
			   ,IDUSUARIOALTERACAO
			   ,DTULTIMAALTERACAO 
			)
		VALUES 
			(
				:tstruct.idSistema
			   ,TRIM(SUBSTR(:tstruct.csgSistemaOperacional,1,255))
			   ,TRIM(SUBSTR(:tstruct.cnmSistemaOperacional,1,255))
			   ,TRIM(SUBSTR(:tstruct.cnmUrlBase,1,255))
			   ,:tstruct.inAcessoControlado
			   ,:cLogUserOra
			   ,SYSDATE 
			);
	}
	catch(...)
	{
		throw;
	}

    ULOG_END("CSis::SisInserir()");
	if(sqlca.sqlcode)
		return 8; 
	else
		return 0;


/************************************************************************
 * Tratamento de Exception
 ************************************************************************/

ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSis::SisSrvRelacao(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CSis::SisSrvRelacao()");
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;

		char* cidSistema;

		struct Tstruct {
			int idHost;
			char cnmHost[256];
		} tstruct;

		struct Tstructindicator {
			short sidHost, snmHost;
		} tstructindicator;

	EXEC SQL END DECLARE SECTION;

	/************************************************************************
	 * Processamento Principal
	 ************************************************************************/
	try
	{
		memset( &tstruct, 0, sizeof(Tstruct));
		memset( &tstructindicator, 0, sizeof(Tstructindicator));
	
		cidSistema = oSafePointer.getTag(dnode,"idSistema",0);
	
		//Se o ID estiver vazio entao retornar com codigo de erro
		if ( strlen( cidSistema ) == 0 ) {
			ULOG_END("CSis::SisSrvRelacao()");
			return 3;
		}
	
		sqlca.sqlcode=0;
	
		EXEC SQL 
		DECLARE 
			tvcursorrelacionados CURSOR FOR
		SELECT  SISTEMAHOST.IDHOST,
		        HOST.NMHOST
		FROM    ACESSO.HOST,
		        ACESSO.SISTEMA,
		        ACESSO.SISTEMAHOST
		WHERE 
		        HOST.IDHOST = SISTEMAHOST.IDHOST
		    AND SISTEMA.IDSISTEMA = SISTEMAHOST.IDSISTEMA
		    AND	SISTEMAHOST.IDSISTEMA = :cidSistema
		ORDER BY
			UPPER(HOST.NMHOST);
		
	
		EXEC SQL 
		DECLARE 
			tvcursorexistentes CURSOR FOR
		SELECT 
			IDHOST, 
			NMHOST
		FROM 
			ACESSO.HOST
		WHERE 
			IDHOST NOT IN 
			        	(        			    	     
		                      SELECT  SISTEMAHOST.IDHOST
		                              
		                      FROM    ACESSO.HOST,
		                              ACESSO.SISTEMA,
		                              ACESSO.SISTEMAHOST
		                      WHERE 
		                              HOST.IDHOST = SISTEMAHOST.IDHOST
		                          AND SISTEMA.IDSISTEMA = SISTEMAHOST.IDSISTEMA
		                          AND	SISTEMAHOST.IDSISTEMA = :cidSistema                        
			           	)
		ORDER BY
			     UPPER(NMHOST);
		
		
		
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL WHENEVER NOT FOUND DO break;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CSis::SisSrvRelacao()");
			return 4;
		}
		else
		{
			xml_g->createTag("RelacionarSistemaServidorVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" ); 
			xml_g->addItem("idSistema",cidSistema);
			EXEC SQL OPEN tvcursorexistentes;
			for(;;) {
				EXEC SQL FETCH tvcursorexistentes INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("SistemaServidorExistenteUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idServidor",tstruct.idHost);
				xml_g->addItem("dsServidor",RTrim(tstruct.cnmHost));
				xml_g->closeTag();
			}
			EXEC SQL CLOSE tvcursorexistentes;
			EXEC SQL OPEN tvcursorrelacionados;
			for(;;) {
				EXEC SQL FETCH tvcursorrelacionados INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("SistemaServidorRelacionadoUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idServidor",tstruct.idHost);
				xml_g->addItem("dsServidor",RTrim(tstruct.cnmHost));
				xml_g->closeTag();
			}
			EXEC SQL CLOSE tvcursorrelacionados;
			xml_g->closeTag();
		}
	}
	catch(...)
	{
		throw;
	}
    ULOG_END("CSis::SisSrvRelacao()");
	if(sqlca.sqlcode)
		return 4;
	else
		return 0;
/************************************************************************
 * Tratamento de Exception
 ************************************************************************/

ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSis::SisSrvRelaciona(DOMNode*dnode, XMLGen*xml_g,
				          char* cLogUser)
{
	ULOG_START("CSis::SisSrvRelaciona()");
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;
		char* cidSistema;
		struct Tstruct {
			int idSistemaHost;
			int idSistema;
			int idHost;
		} tstruct;

		struct Tstruct2 {
			int idHost;
			char cnmHost[256];
		} tstruct2;

		struct Tstructindicator {
			short sidSistemaHost, sidSistema, sidHost;
		} tstructindicator;

		struct Tstructindicator2 {
			short sidHost, snmHost;
		} tstructindicator2;

		int iAcumulador;

	EXEC SQL END DECLARE SECTION;

	/************************************************************************
	 * Processamento Principal
	 ************************************************************************/
	try
	{
		memset( &tstruct, 0, sizeof(Tstruct) );
		memset( &tstruct2, 0, sizeof(Tstruct2) );
		memset( &tstructindicator, 0, sizeof(Tstructindicator) );
		memset( &tstructindicator2, 0, sizeof(Tstructindicator2) );
		
		cidSistema = oSafePointer.getTag( dnode, "idSistema", 0  );
	
		//Pega o idSistema que sera utilizado na ralacao
		if ( strlen( cidSistema )  <= 0 ) 
		{
			ULOG_END("CSis::SisSrvRelaciona()");
			return 2;
		}
	
		sqlca.sqlcode=0;
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
		EXEC SQL 
		SELECT COUNT(idSistema)
		INTO :iAcumulador
		FROM acesso.SistemaHost
		WHERE idSistema = :cidSistema;
	
		//Antes de inserir as novas relacoes, deve-se apagar todas, se existirem
		if (iAcumulador>0) {
			EXEC SQL 
			DELETE FROM acesso.SistemaHost 
			WHERE idSistema = :cidSistema;
		}
	
		//Verifica se o comando DELETE obteve sucesso
		if(sqlca.sqlcode == 0 )
		{
			char* pc;
	
			//Pega todos os idHost que existem no XML e insere
			for(int indice=0;;indice++) 
			{
	
				//Se tstruct.idHost for igual a zero, entao acabou os ids
				pc = oSafePointer.getTag( dnode, "idServidor", indice  );
				//Se o ID estiver vazio, desfaz tudo e retornar com erro
				if ( strlen( pc ) <= 0 ) {
					//EXEC SQL ROLLBACK WORK; 
					break;
				}
	
				tstruct.idHost = atoi( pc );
	
				sqlca.sqlcode=0;
	
				EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	
				//Pega um id unico e sequencia para a insercao
				EXEC SQL
				SELECT acesso.SistemaHostsq.nextval
				INTO :tstruct.idSistemaHost
				FROM dual;
	
				//Insere item a item
				EXEC SQL 
					INSERT INTO ACESSO.SISTEMAHOST 
					( 
						  IDSISTEMAHOST
						, IDSISTEMA
						, IDHOST
						, IDUSUARIOALTERACAO
						, DTULTIMAALTERACAO 
					)
				VALUES
					( 
						  :tstruct.idSistemaHost
						, :cidSistema
						, :tstruct.idHost
						, :cLogUserOra
						, SYSDATE 
					);
	
				//Se der algum erro, desfaz tudo
				if(sqlca.sqlcode)
				{
					ULOG_END("CSis::SisSrvRelaciona()");
					return 4; 
				}
			}//for( indice=1;;indice++) 
		}// if(sqlca.sqlcode == 0 )
		else
		{
			ULOG_END("CSis::SisSrvRelaciona()");
			//Se o DELETE falhar, desfaz tudo e retornar com erro
			return 1;
		}// else if(sqlca.sqlcode == 0 )
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSis::SisSrvRelaciona()");
	return 0;

/************************************************************************
 * Tratamento de Exception
 ************************************************************************/

ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSis::SisListaPar(DOMNode*dnode,XMLGen*xml_g)
{
	ULOG_START("CSis::SisListaPar()");
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;

		struct
		{
			int  idSistema;
			char csgSistemaOperacional[256];
			char cnmSistemaOperacional[256];
			char cnmUrlBase[256];
			char cinAcessoControlado[256];
		} stSistema;

		struct 
		{
			short sidSistema
		   ,ssgSistemaOperacional
		   ,snmSistemaOperacional
		   ,snmUrlBase
		   ,sinAcessoControlado;
		} stSistemaIndicator;

	EXEC SQL END DECLARE SECTION;

	/************************************************************************
	 * Processamento Principal
	 ************************************************************************/
	try
		{
		memset( &stSistema, 0, sizeof(stSistema));
		memset( &stSistemaIndicator, 0, sizeof(stSistemaIndicator));
	
		strcpy( stSistema.csgSistemaOperacional, oSafePointer.getTag(dnode,"sgSistema",0) );
		if ( strlennull( stSistema.csgSistemaOperacional ) == 0 )
			strcpy(stSistema.csgSistemaOperacional , "-1" );
		else
			sprintf(stSistema.csgSistemaOperacional,"%s%%",stSistema.csgSistemaOperacional);
	
		strcpy( stSistema.cnmSistemaOperacional, oSafePointer.getTag(dnode,"dsSistema",0) );
		if ( strlennull( stSistema.cnmSistemaOperacional ) == 0 ) 
			strcpy(stSistema.cnmSistemaOperacional , "-1" );
		else
			sprintf(stSistema.cnmSistemaOperacional,"%s%%",stSistema.cnmSistemaOperacional);
	
		strcpy( stSistema.cnmUrlBase, oSafePointer.getTag(dnode,"nmUrlBase",0) );
		if ( strlennull( stSistema.cnmUrlBase ) == 0 )
			strcpy(stSistema.cnmUrlBase , "-1" );
		else
			sprintf(stSistema.cnmUrlBase,"%s%%",stSistema.cnmUrlBase);
	
		strcpy( stSistema.cinAcessoControlado, oSafePointer.getTag(dnode,"inAcessoControlado",0) );
		if ( strlennull( stSistema.cinAcessoControlado ) <= 0 ) 
			strcpy(stSistema.cinAcessoControlado , "-1" );
	
		sqlca.sqlcode=0;
	
		EXEC SQL 
		DECLARE 
			CursorSisListaPar CURSOR FOR
		SELECT 
			IDSISTEMA, 
			SGSISTEMAOPERACIONAL, 
			NMSISTEMAOPERACIONAL, 
			NMURLBASE, 
			INACESSOCONTROLADO 
		FROM ACESSO.SISTEMA
		WHERE 
			( UPPER(SGSISTEMAOPERACIONAL) LIKE UPPER(:stSistema.csgSistemaOperacional)
			OR 
			'-1' = :stSistema.csgSistemaOperacional )
		  AND 
		  	( UPPER(NMSISTEMAOPERACIONAL) LIKE UPPER(:stSistema.cnmSistemaOperacional)
		  	OR
		  	'-1' = :stSistema.cnmSistemaOperacional ) 
		  AND 
		  	( UPPER(NMURLBASE) LIKE UPPER(:stSistema.cnmUrlBase)
		  	OR 
		  	'-1' = :stSistema.cnmUrlBase ) 
		  AND
		  	( INACESSOCONTROLADO = :stSistema.cinAcessoControlado
		  	OR 
		  	'-1' = :stSistema.cinAcessoControlado)
	 	ORDER BY 
	 		UPPER(NMSISTEMAOPERACIONAL);

	
		EXEC SQL OPEN CursorSisListaPar;
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CSis::SisListaPar()");
			return 4;
		}
		else
		{
			xml_g->createTag("ListaSistemaUsuarioVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" ); 
			for(;;) {
				EXEC SQL FETCH CursorSisListaPar INTO :stSistema INDICATOR :stSistemaIndicator;
				xml_g->createTag("SistemaManterUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idSistema",stSistema.idSistema);
				xml_g->addItem("sgSistema",RTrim(stSistema.csgSistemaOperacional));
				xml_g->addItem("dsSistema",RTrim(stSistema.cnmSistemaOperacional));
				xml_g->addItem("nmUrlBase",RTrim(stSistema.cnmUrlBase));
				xml_g->addItem("inAcessoControlado",RTrim(stSistema.cinAcessoControlado));
				xml_g->closeTag();
				
			}
			xml_g->closeTag();
			EXEC SQL CLOSE CursorSisListaPar;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSis::SisListaPar()");
	return 0;


/************************************************************************
 * Tratamento de Exception
 ************************************************************************/

ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSis::SisListaId(DOMNode*dnode, XMLGen*xml_g)
{
    ULOG_START("CSis::SisListaId()");

	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidSistema;
		struct
		{
			VARCHAR stidSubSistema[21+1];
			VARCHAR stnmSubSistema[255+1];
		} stSubSistema;
		struct
		{
			VARCHAR stidPagina[21+1];
			VARCHAR stnmPagina[255+1];
		} stPagina;
	EXEC SQL END DECLARE SECTION;

	try
	{

		cidSistema = oSafePointer.getTag( dnode, "idSistema", 0  );
		if( strlen( cidSistema ) <= 0 )
		{
			ULOG_END("CSis::SisListaId()");
			return 1;
		}

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;

		EXEC SQL DECLARE CursorSubSistema CURSOR FOR
			SELECT SUBSISTEMA.IDSUBSISTEMA, 
				   SUBSISTEMA.NMSUBSISTEMA
			  FROM ACESSO.SUBSISTEMA SUBSISTEMA
			 WHERE SUBSISTEMA.IDSISTEMA = :cidSistema
			 ORDER BY UPPER(SUBSISTEMA.NMSUBSISTEMA);

		EXEC SQL DECLARE CursorPagina CURSOR FOR
			SELECT PAGINA.IDPAGINA,
				   PAGINA.NMPAGINA
			  FROM ACESSO.PAGINA PAGINA
			 WHERE PAGINA.IDSUBSISTEMA = :stSubSistema.stidSubSistema
			 ORDER BY UPPER(PAGINA.NMPAGINA);

		sqlca.sqlcode=0;
		EXEC SQL OPEN CursorSubSistema;

		if(sqlca.sqlcode)
		{
			ULOG_END("CSis::SisListaId()");
			return 2;
		}
		else
		{
			xml_g->createTag("ListaSubSistemasPaginasVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" ); 
			xml_g->addItem("idSistema", cidSistema);

			for(;;)
			{
				memset( &stSubSistema, 0, sizeof( stSubSistema ) );
				EXEC SQL FETCH CursorSubSistema INTO :stSubSistema;

				xml_g->createTag("SubSistemaPaginasVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" ); 
				xml_g->addItem("idSubSistema", (char*)stSubSistema.stidSubSistema.arr);
				xml_g->addItem("dsSubSistema", (char*)stSubSistema.stnmSubSistema.arr);

				EXEC SQL OPEN CursorPagina;
				for(;;)
				{
					memset( &stPagina, 0, sizeof( stPagina ) );
					EXEC SQL FETCH CursorPagina INTO :stPagina;

					xml_g->createTag("PaginaSimplVO");
					xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" ); 
					xml_g->addItem("idPagina", (char*)stPagina.stidPagina.arr);
					xml_g->addItem("nmPagina", (char*)stPagina.stnmPagina.arr);
					xml_g->closeTag();
				}
				EXEC SQL CLOSE CursorPagina;
				xml_g->closeTag();
			}
			EXEC SQL CLOSE CursorSubSistema;
			xml_g->closeTag();
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSis::SisListaId()");
	return 0;

ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}


int CSis::SisListaId(char* cidSistema, XMLGen*xml_g)
{
	ULOG_START("CSis::SisListaId()");
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidSistema = cidSistema;
		struct 
		{
			VARCHAR stidSistema[21+1];
			VARCHAR stsgSistemaOperacional[255+1];
			VARCHAR stnmSistemaOperacional[255+1];
			VARCHAR stnmUrlBase[255+1];
			VARCHAR stinAcessoControlado[21+1];
		} stRegistro;

		struct 
		{
			short sidSistema;
			short ssgSistemaOperacional;
			short snmSistemaOperacional;
			short snmUrlBase;
			short sinAcessoControlado;
		} stIndicator;

	EXEC SQL END DECLARE SECTION;

	/************************************************************************
	 * Processamento Principal
	 ************************************************************************/
	try
	{
		memset( &stRegistro, 0, sizeof(stRegistro));
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		sqlca.sqlcode=0;
	
		EXEC SQL 
			DECLARE 
				CursorSisListaId CURSOR FOR
			SELECT 
				IDSISTEMA
			   ,SGSISTEMAOPERACIONAL
			   ,NMSISTEMAOPERACIONAL
			   ,NMURLBASE
			   ,INACESSOCONTROLADO 
			FROM 
				ACESSO.SISTEMA
			WHERE
				IDSISTEMA = :cAuxidSistema;
	
		EXEC SQL OPEN CursorSisListaId;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CSis::SisListaId()");
			return 4;
		}
		else
		{
			xml_g->createTag("ListaSistemaUsuarioVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" ); 
			for(;;) {
				EXEC SQL FETCH CursorSisListaId INTO :stRegistro:stIndicator;
				xml_g->createTag("SistemaManterUsuarioVO");
				xml_g->addItem("idSistema"         ,(char*)stRegistro.stidSistema.arr);
				xml_g->addItem("sgSistema"         ,(char*)stRegistro.stsgSistemaOperacional.arr);
				xml_g->addItem("dsSistema"         ,(char*)stRegistro.stnmSistemaOperacional.arr);
				xml_g->addItem("nmUrlBase"         ,(char*)stRegistro.stnmUrlBase.arr);
				xml_g->addItem("inAcessoControlado",(char*)stRegistro.stinAcessoControlado.arr);
				xml_g->closeTag();
			}
			xml_g->closeTag();
			EXEC SQL CLOSE CursorSisListaId;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSis::SisListaId()");
	return 0;


/************************************************************************
 * Tratamento de Exception
 ************************************************************************/

ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSis::SisListaSigla( char* csgSistema )
{
	ULOG_START("CSis::SisListaSigla()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxsgSistema = csgSistema;
		VARCHAR stidSistema[21+1];
		short sidSistema;
	EXEC SQL END DECLARE SECTION;

	/************************************************************************
	 * Processamento Principal
	 ************************************************************************/
	memset( &stidSistema, 0, sizeof(stidSistema));

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	sqlca.sqlcode=0;

	EXEC SQL 
	SELECT 
		IDSISTEMA
	INTO
		:stidSistema:sidSistema
	FROM 
		ACESSO.SISTEMA
	WHERE
		UPPER( SGSISTEMAOPERACIONAL ) = UPPER(:cAuxsgSistema)
	AND
		ROWNUM < 2;

	if( stidSistema.len > 0 )
		setIdSistema( (char*)stidSistema.arr );

	ULOG_END("CSis::SisListaSigla()");
	return ( stidSistema.len > 0 ? 1 : 0 );

ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSis::SisLista(DOMNode*dnode,XMLGen*xml_g)
{
	ULOG_START("CSis::SisLista()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;

		struct Tstruct {
			int idSistema;
			char csgSistemaOperacional[256];
			char cnmSistemaOperacional[256];
			char cnmUrlBase[256];
			int inAcessoControlado;
		} tstruct;

		struct Tstructindicator {
			short sidSistema, ssgSistemaOperacional, snmSistemaOperacional, snmUrlBase, sinAcessoControlado;
		} tstructindicator;

	EXEC SQL END DECLARE SECTION;

	/************************************************************************
	 * Processamento Principal
	 ************************************************************************/
	try
	{
		memset( &tstruct, 0, sizeof(tstruct));
		memset( &tstructindicator, 0, sizeof(tstructindicator));
	
		sqlca.sqlcode=0;
	
		EXEC SQL 
			DECLARE 
				tsqlcursor CURSOR FOR
			SELECT 
				idSistema
			   ,sgSistemaOperacional
			   ,nmSistemaOperacional
			   ,nmUrlBase
			   ,inAcessoControlado 
			FROM 
				acesso.Sistema
		    ORDER BY 
		    	nmSistemaOperacional;
	
	
		EXEC SQL OPEN tsqlcursor;
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CSis::SisLista()");
			return 4;
		}
		else
		{
			xml_g->createTag("ListaSistemaUsuarioVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" ); 
			for(;;) {
				EXEC SQL FETCH tsqlcursor INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("SistemaManterUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idSistema",tstruct.idSistema);
				xml_g->addItem("sgSistema",RTrim(tstruct.csgSistemaOperacional));
				xml_g->addItem("dsSistema",RTrim(tstruct.cnmSistemaOperacional));
				xml_g->addItem("nmUrlBase",RTrim(tstruct.cnmUrlBase));
				xml_g->addItem("inAcessoControlado",tstruct.inAcessoControlado);
				xml_g->closeTag();
			}
			xml_g->closeTag();
			EXEC SQL CLOSE tsqlcursor;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSis::SisLista()");
	return 0;


/************************************************************************
 * Tratamento de Exception
 ************************************************************************/

ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

void CSis::setIdSistema( char* cidSistema )
{
	ULOG_START("CSis::setIdSistema()");
	if( strlennull( cidSistema ) > 0 )
	{
		memset( pzcidSistema, 0, sizeof( pzcidSistema ) );
		if( strlennull( cidSistema ) > 21 )
			strcpy( pzcidSistema, cidSistema );
		else
			strncpy( pzcidSistema, &cidSistema[0], 21 );
	}
	ULOG_END("CSis::setIdSistema()");
}

char* CSis::getIdSistema( void )
{
	ULOG_START("CSis::getIdSistema()");
	ULOG_END("CSis::getIdSistema()");
	return pzcidSistema;
}
