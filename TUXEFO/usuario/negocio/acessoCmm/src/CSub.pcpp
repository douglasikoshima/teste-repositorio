/*****************************************************************************
 *
 * Modulo:    CSub
 * Arquivo:   CSub.cpp
 * Proposito: Funcao de Negocios 
 * Historico:
 * Data        Autor                 Descricao
 * ----------  --------------------  -----------------------------------------
 * 18/05/2004  C_RECOliveira         Criacao
 * 18/05/2004  C_EDMartins           Criacao
 *
 ****************************************************************************/
/**************************************************************************
 * Notas:
 *
 **************************************************************************/

//Definicao Global
#define CSubCPP

//Header
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include<tuxfw.h>
#include "CSub.h"
#include "CSafePointer.h"

char* CSub::RTrim(char *pszString)
{
    ULOG_START("CSub::RTrim()");
    int iLen;

    iLen=strlen(pszString);

    for(;;)
    {
        if(pszString[iLen-1] != ' ')
            break;

        iLen--;

        if(iLen == 0)
            break;
    }
    pszString[iLen] = 0x00;
    ULOG_END("CSub::RTrim()");
	return pszString;
}

//Classe:
int CSub::SubRemover(DOMNode*dnode, XMLGen*xml_g,
				     char* cLogUser)
{
	ULOG_START("CSub::SubRemover()");
	
	// Declarar Estruturas
	struct sqlca sqlca; 
	
	// Declarar Objetos
	CSafePointer oSafePointer;

	// Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		int idSubSistema;
		int iCount;
	EXEC SQL END DECLARE SECTION;

	//Declara variaveis auxiliares
	char *pc;
	//Se o ID nao for numerico entao retornar com codigo de erro
	pc = oSafePointer.getTag(dnode,"idSubSistema",0);
	if ( pc == NULL )
	{
 		ULOG_END("CSub::SubRemover()");
 		return 3;
 	}

	//Le o ID
	if ( ( idSubSistema = atoi( pc ) ) == 0 )
	{
		ULOG_END("CSub::SubRemover()");
		return 2;
	}

	sqlca.sqlcode=0;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO ErrorF;

	//Verifica se existe algum menu, que não seja a raiz relacionada ao subsistema
	EXEC SQL
		SELECT 
			COUNT(IDITEMMENU)
		INTO
			:iCount
		FROM
			ACESSO.ITEMMENU
		WHERE
			IDSUBSISTEMA = :idSubSistema;

	//Se tiver mais que um item de menu, entao nao pode apagar
	//Se tiver um soh, entao eh a raiz, pode apagar
	if( iCount > 1 )
	{
		ULOG_END("CSub::SubRemover()");
		return 6;
	}
	
	//Verifica se existe algum menu, que não seja a raiz relacionada ao subsistema
	EXEC SQL
		SELECT 
			COUNT(IDPAGINA)
		INTO
			:iCount
		FROM
			ACESSO.PAGINA
		WHERE
			IDSUBSISTEMA = :idSubSistema;

	//Se tiver paginas, entao nao pode apagar
	if( iCount > 0 )
	{
		ULOG_END("CSub::SubRemover()");
		return 7;
	}

	//Tenta apagar um item de menu
	EXEC SQL
		DELETE FROM
			ACESSO.ITEMMENU
		WHERE
			IDSUBSISTEMA = :idSubSistema;

	EXEC SQL
		DELETE FROM 
			ACESSO.SUBSISTEMA 
		WHERE 
			IDSUBSISTEMA = :idSubSistema;
    ULOG_END("CSub::SubRemover()");
	return 0;

// Tratamento de Exception
ErrorF:
    ULOG_END("CSub::SubRemover()");
	if( sqlca.sqlcode == -2292 )
		return 5;
	else
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CSub::SubInserir(DOMNode*dnode,XMLGen*xml_g,
				     char* cLogUser)
{
	ULOG_START("CSub::SubInserir()");
	//Declarar Estruturas
	struct sqlca sqlca;

	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;
		int   iCont;

		struct Tstruct {
			int idSubSistema; 
			char cnmSubSistema[256];
			int idSistema;
		} tstruct;

	EXEC SQL END DECLARE SECTION;
	try
	{
		memset( &tstruct, 0, sizeof(Tstruct));
	
		strcpy(tstruct.cnmSubSistema , oSafePointer.getTag(dnode,"dsSubSistema",0) );
		if ( strlen( tstruct.cnmSubSistema ) == 0 )
		{
			ULOG_END("CSub::SubInserir()");
			return 1;
		}
	
		if ( ( tstruct.idSistema = atoi( oSafePointer.getTag( dnode, "idSistema", 0 ) ) )<=0 ) 
		{
			ULOG_END("CSub::SubInserir()");
			return 2;
		}
	
		sqlca.sqlcode=0;
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	
		EXEC SQL
			SELECT
				COUNT( IDSUBSISTEMA )
			INTO
				:iCont
			FROM
				ACESSO.SUBSISTEMA
			WHERE
				UPPER(NMSUBSISTEMA) = UPPER(:tstruct.cnmSubSistema)
			AND 
				IDSISTEMA = :tstruct.idSistema;

		if( iCont > 0 )
		{
			ULOG_END("CSub::SubInserir()");
			return 3;
		}

		EXEC SQL
			SELECT 
				acesso.SubSistemasq.nextval
			INTO 
				:tstruct.idSubSistema
			FROM DUAL;
	
		EXEC SQL 
			INSERT INTO ACESSO.SUBSISTEMA 
		  	(
		  		 IDSUBSISTEMA
		  		,NMSUBSISTEMA
		  		,IDSISTEMA
		  		,IDUSUARIOALTERACAO
		  		,DTULTIMAALTERACAO
		  	)
		VALUES
		  	(
		  		 :tstruct.idSubSistema
		  		,TRIM(SUBSTR(:tstruct.cnmSubSistema,1,255))
		  		,:tstruct.idSistema
		  		,:cLogUserOra
		  		,SYSDATE
		  	);

		//Insere a raiz em item de menu para este subsistema
		EXEC SQL 
			INSERT INTO ACESSO.ITEMMENU 
			  ( IDITEMMENU, 
				IDSUBSISTEMA, 
				NMITEM, 
				DSHINT, 
				SQAPRESENTACAO, 
				INVISIBILIDADE, 
				IDUSUARIOALTERACAO, 
				DTULTIMAALTERACAO)
			VALUES
			  (	 
			     ACESSO.ITEMMENUSQ.NEXTVAL
				,:tstruct.idSubSistema
				,TRIM(SUBSTR(:tstruct.cnmSubSistema,1,255))
				,TRIM(SUBSTR(:tstruct.cnmSubSistema,1,255))
				,0
				,1
				,:cLogUserOra
				,SYSDATE
			  );


	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSub::SubInserir()");
	if(sqlca.sqlcode)
		return 4; 
	else
		return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSub::SubEditar(DOMNode*dnode,XMLGen*xml_g,
				    char* cLogUser)
{
	ULOG_START("CSub::SubEditar()");
	//Declarar Estruturas
	struct sqlca sqlca;

	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;
		int   iCont;

		struct Tstruct {
			int idSubSistema; 
			char cnmSubSistema[256];
			int idSistema;
		} tstruct;

	EXEC SQL END DECLARE SECTION;
	try
	{
		memset( &tstruct, 0, sizeof(Tstruct));
		
		if ( ( tstruct.idSubSistema = atoi( oSafePointer.getTag( dnode, "idSubSistema", 0 ) ) )<=0 ) 
		{
			ULOG_END("CSub::SubEditar()");
			return 1;
		}
	
		strcpy(tstruct.cnmSubSistema , oSafePointer.getTag(dnode,"dsSubSistema",0) );
		if ( strlen( tstruct.cnmSubSistema ) == 0 )
		{
		    ULOG_END("CSub::SubEditar()");
			return 2;
	    }
		sqlca.sqlcode=0;
	
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		
		EXEC SQL
			SELECT
				COUNT( IDSUBSISTEMA )
			INTO
				:iCont
			FROM
				ACESSO.SUBSISTEMA
			WHERE
				UPPER(NMSUBSISTEMA) = UPPER(:tstruct.cnmSubSistema)
			AND
				IDSUBSISTEMA <> :tstruct.idSubSistema;

		if( iCont > 0 )
		{
			ULOG_END("CSub::SubEditar()");
			return 5;			
		}
	
		EXEC SQL 
			UPDATE
				acesso.SubSistema 
			SET 
				nmSubSistema = :tstruct.cnmSubSistema,
				IDUSUARIOALTERACAO = :cLogUserOra, 
				DTULTIMAALTERACAO  = SYSDATE
			WHERE
				idSubSistema = :tstruct.idSubSistema;
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSub::SubEditar()");
	if(sqlca.sqlcode)
	{
		return 3; 
	}
	else
	{
		if( sqlca.sqlerrd[2] > 0 )
			return 0;
		else 
			return 4;
	}

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSub::SubListaTodos(DOMNode*dnode,XMLGen*xml_g)
{
	ULOG_START("CSub::SubListaTodos()");
	//Declarar Estruturas
	struct sqlca sqlca;

	//Declarar Objetos
	//CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;

		struct Tstruct {
			int idSubSistema; 
			char cnmSubSistema[256];
			int idSistema;
		} tstruct;

		struct Tstructindicator {
			short sidSubSistema, snmSubSistema, sidSistema;
		} tstructindicator;

	EXEC SQL END DECLARE SECTION;

	try
	{
		memset( &tstruct, 0, sizeof(Tstruct));
		memset( &tstructindicator, 0, sizeof(Tstructindicator));
	
		sqlca.sqlcode=0;
	
		//idSistema = tstruct.idSistema;
		
		EXEC SQL DECLARE tsqlcursor CURSOR FOR
		SELECT idSubSistema, nmSubSistema, idSistema 
		FROM acesso.SubSistema
		ORDER BY nmSubSistema;
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL OPEN tsqlcursor;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CSub::SubListaTodos()");
			return 4;
		}
		else
		{
			xml_g->createTag("SubSistemasUsuarioVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			for(;;) {
				EXEC SQL FETCH tsqlcursor INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("SubSistemaUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idSubSistema",tstruct.idSubSistema);
				xml_g->addItem("dsSubSistema",RTrim(tstruct.cnmSubSistema));
				xml_g->closeTag();
			}
			EXEC SQL CLOSE tsqlcursor;
	
			xml_g->closeTag();
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSub::SubListaTodos()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSub::SubListaTodos( char* cidSistema )
{
	ULOG_START("CSub::SubListaTodos()");
	//Declarar Estruturas
	struct sqlca sqlca;
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidSistema = cidSistema;
		struct
		{
			VARCHAR stidSubSistema[21+1];
			VARCHAR stnmSubSistema[255+1];
		}stRegistro;
		struct
		{
			short sidSubSistema;
			short snmSubSistema;
		}stIndicator;

	EXEC SQL END DECLARE SECTION;

	try
	{
		memset( &sqlca, 0, sizeof(sqlca));
		
		EXEC SQL 
		DECLARE 
			CursorSubListaTodos CURSOR FOR
		SELECT
			IDSUBSISTEMA,
			NMSUBSISTEMA
		FROM
		(
			SELECT
				SUBSISTEMA.IDSUBSISTEMA, 
				SUBSISTEMA.NMSUBSISTEMA, 
				SUBSISTEMA.IDSISTEMA,
                ITEMMENU.SQAPRESENTACAO
			FROM 
				ACESSO.SUBSISTEMA SUBSISTEMA,
                ACESSO.ITEMMENU ITEMMENU
            WHERE
                ITEMMENU.IDSUBSISTEMA = SUBSISTEMA.IDSUBSISTEMA
            AND
                SUBSISTEMA.IDSISTEMA = :cAuxidSistema
            AND
                ITEMMENU.IDITEMMENU NOT IN
                (
                    SELECT 
                        IDITEMMENU
                    FROM
                        ACESSO.ITEMMENUHIERARQUIA ITEMMENUHIERARQUIA
                )
			ORDER BY
                ITEMMENU.SQAPRESENTACAO
        );

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL OPEN CursorSubListaTodos;
	
		for(;;) 
		{
			memset( &stRegistro, 0, sizeof(stRegistro));
			EXEC SQL FETCH CursorSubListaTodos INTO :stRegistro:stIndicator;
			Add(
				 (char*)stRegistro.stidSubSistema.arr,
				 (char*)stRegistro.stnmSubSistema.arr,
				 cAuxidSistema
			   );
		}
		EXEC SQL CLOSE CursorSubListaTodos;
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSub::SubListaTodos()");
	return Quantidade();

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSub::SubLista(DOMNode*dnode,XMLGen*xml_g)
{
	ULOG_START("CSub::SubLista()");
	//Declarar Estruturas
	struct sqlca sqlca;

	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;

		struct Tstruct {
			int idSubSistema; 
			char cnmSubSistema[256];
			int idSistema;
		} tstruct;

		struct Tstructindicator {
			short sidSubSistema, snmSubSistema, sidSistema;
		} tstructindicator;

		int idSistema;
		int iContador;

	EXEC SQL END DECLARE SECTION;

	memset( &tstruct, 0, sizeof(Tstruct));
	memset( &tstructindicator, 0, sizeof(Tstructindicator));

	if ( ( tstruct.idSistema = atoi( oSafePointer.getTag( dnode, "idSistema", 0 ) ) )<=0 ) 
	{
		ULOG_END("CSub::SubLista()");
		return 2;
	}
		
	sqlca.sqlcode=0;

	idSistema = tstruct.idSistema;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL SELECT count(idSubSistema)
	INTO :iContador 
	FROM acesso.SubSistema
	WHERE idSistema = :idSistema;
	
	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO ErrorF;

	EXEC SQL DECLARE tsqlcursor5 CURSOR FOR
	SELECT idSubSistema, nmSubSistema, idSistema 
	FROM acesso.SubSistema
	WHERE idSistema = :idSistema
	ORDER BY nmSubSistema;

	EXEC SQL OPEN tsqlcursor5;

	if(sqlca.sqlcode)
	{
		ULOG_END("CSub::SubLista()");
		return 4;
	}
	else
	{
		xml_g->createTag("SubSistemasUsuarioVO");
		xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );

		if (iContador>0) {
			xml_g->createTag("SistemaIDVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			xml_g->addItem("idSistema",tstruct.idSistema);
			xml_g->closeTag();
		}

		for(;;) {
			EXEC SQL FETCH tsqlcursor5 INTO :tstruct INDICATOR :tstructindicator;
			xml_g->createTag("SubSistemaUsuarioVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			xml_g->addItem("idSubSistema",tstruct.idSubSistema);
			xml_g->addItem("dsSubSistema",RTrim(tstruct.cnmSubSistema));
			xml_g->closeTag();
		}
		EXEC SQL CLOSE tsqlcursor5;

		xml_g->closeTag();
	}
	ULOG_END("CSub::SubLista()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSub::SubListaId(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CSub::SubListaId()");
	//Declarar Estruturas
    struct sqlca sqlca;

	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;

		struct Tstruct {
			int idSubSistema; 
			char cnmSubSistema[256];
			int idSistema;
		} tstruct;

		struct Tstructindicator {
			short sidSubSistema, snmSubSistema, sidSistema;
		} tstructindicator;

		int idSubSistema;

	EXEC SQL END DECLARE SECTION;
	try
	{
		memset( &tstruct, 0, sizeof(Tstruct));
		memset( &tstructindicator, 0, sizeof(Tstructindicator));
	
		if ( ( tstruct.idSubSistema = atoi( oSafePointer.getTag( dnode, "idSubSistema", 0 ) ) )<=0 ) 
		{
			ULOG_END("CSub::SubListaId()");
			return 2;
		}
	
		sqlca.sqlcode=0;
	
		idSubSistema = tstruct.idSubSistema;
	
		EXEC SQL DECLARE tcursor1 CURSOR FOR
		SELECT idSubSistema, nmSubSistema, idSistema 
		FROM acesso.SubSistema
		WHERE idSubSistema = :idSubSistema;
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL OPEN tcursor1;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CSub::SubListaId()");
			return 4;
		}
		else
		{
			xml_g->createTag("SubSistemasUsuarioVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			for(;;) {
				EXEC SQL FETCH tcursor1 INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("SubSistemaUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo");
				xml_g->addItem("idSubSistema",tstruct.idSubSistema);
				xml_g->addItem("dsSubSistema",RTrim(tstruct.cnmSubSistema));
				xml_g->closeTag();
			}
			EXEC SQL CLOSE tcursor1;
	
			xml_g->closeTag();
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSub::SubListaId()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSub::SubListaIdSis(DOMNode*dnode,XMLGen*xml_g)
{
	ULOG_START("CSub::SubListaIdSis()");
	//Declarar Estruturas
	struct sqlca sqlca;

	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;

		struct Tstruct {
			int idSubSistema;
			char cnmSubSistema[256];
			int idSistema;
		} tstruct;

		struct Tstructindicator {
			short sidSubSistema, snmSubSistema, sidSistema;
		} tstructindicator;
		char cdsSubSistema[255+1];
		char* pzcdsSubSistema;
	EXEC SQL END DECLARE SECTION;

	memset( &cdsSubSistema, 0, sizeof(cdsSubSistema));
	memset( &tstruct, 0, sizeof(Tstruct));
	memset( &tstructindicator, 0, sizeof(Tstructindicator));

	char *pc = oSafePointer.getTag(dnode,"idSistema",0);
	if ( strlennull( pc ) <= 0 )
	{
		ULOG_END("CSub::SubListaIdSis()");
		return 1;//Verificar o erro, pois eh obrigado a receber um ID
	}

	tstruct.idSistema = atoi( pc );
	
	pzcdsSubSistema = oSafePointer.getTag(dnode,"dsSubSistema",0);
	if( strlennull( pzcdsSubSistema ) < 0 )
		strcpy( cdsSubSistema, "-1" );
	else
		sprintf( cdsSubSistema, "%s%%", pzcdsSubSistema );

	sqlca.sqlcode=0;
	
	EXEC SQL 
		DECLARE 
			tsqlcursor4 CURSOR FOR
		SELECT 
			IDSUBSISTEMA
		   ,NMSUBSISTEMA
		   ,IDSISTEMA 
		FROM 
			ACESSO.SUBSISTEMA
		WHERE 
			idSistema = :tstruct.idSistema
		AND
			UPPER(NMSUBSISTEMA) LIKE( UPPER(:cdsSubSistema) ) OR :cdsSubSistema = '-1'
		ORDER BY 
			nmSubSistema;


	EXEC SQL OPEN tsqlcursor4;
	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO ErrorF;

	xml_g->createTag("SubSistemasUsuarioVO");
	xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
	
	xml_g->createTag("SistemaIDVO");
	xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
	xml_g->addItem("idSistema",tstruct.idSistema);
	xml_g->closeTag();
	
	for(;;) {
		EXEC SQL FETCH tsqlcursor4 INTO :tstruct INDICATOR :tstructindicator;
		xml_g->createTag("SubSistemaUsuarioVO");
		xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
		xml_g->addItem("idSubSistema",tstruct.idSubSistema);
		xml_g->addItem("dsSubSistema",RTrim(tstruct.cnmSubSistema));
		xml_g->closeTag();
	}
	EXEC SQL CLOSE tsqlcursor4;
	
	xml_g->closeTag();

	ULOG_END("CSub::SubListaIdSis()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}


int CSub::SubListaPar(DOMNode*dnode,XMLGen*xml_g)
{
	ULOG_START("CSub::SubListaPar()");
	//Declarar Estruturas
	struct sqlca sqlca;

	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;

		struct Tstruct {
			int idSubSistema; 
			char cnmSubSistema[256];
			int idSistema;
		} tstruct;

		struct Tstructindicator {
			short sidSubSistema, snmSubSistema, sidSistema;
		} tstructindicator;

		char vcLike[255];

	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		memset( &tstruct, 0, sizeof(Tstruct));
		memset( &tstructindicator, 0, sizeof(Tstructindicator));
	
		char *pc = oSafePointer.getTag(dnode,"dsSubSistema",0);
		if ( strlen( pc ) == 0 ) {
			strcpy( tstruct.cnmSubSistema, "-1" );
			strcpy( vcLike, "" );
		} else {
			strcpy( vcLike, pc );
			strcat( vcLike, "%" );
			strcpy( tstruct.cnmSubSistema, vcLike );
		}
		
		pc = oSafePointer.getTag(dnode,"idSistema",0);
		if ( strlen( pc ) == 0 ) {
			ULOG_END("CSub::SubListaPar()");
			return 4;//Verificar o erro, pois eh obrigado a receber um ID
		} 
		tstruct.idSistema = atoi( pc );
	
		sqlca.sqlcode=0;
		
		EXEC SQL DECLARE tsqlcursor2 CURSOR FOR
		SELECT idSubSistema, nmSubSistema, idSistema 
		FROM acesso.SubSistema
		WHERE ( UPPER(nmSubSistema) LIKE( UPPER(:vcLike) ) OR ( :tstruct.cnmSubSistema = '-1' ) )
		AND idSistema = :tstruct.idSistema
		ORDER BY nmSubSistema;
	
		EXEC SQL OPEN tsqlcursor2;
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CSub::SubListaPar()");
			return 4;
		}
		else
		{
			xml_g->createTag("SubSistemasUsuarioVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			
			xml_g->createTag("SistemaIDVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			xml_g->addItem("idSistema",tstruct.idSistema);
			xml_g->closeTag();
			
			for(;;) {
				EXEC SQL FETCH tsqlcursor2 INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("SubSistemaUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idSubSistema",tstruct.idSubSistema);
				xml_g->addItem("dsSubSistema",RTrim(tstruct.cnmSubSistema));
				xml_g->closeTag();
			}
			EXEC SQL CLOSE tsqlcursor2;
			
			xml_g->closeTag();
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CSub::SubListaPar()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}
