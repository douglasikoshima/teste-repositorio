#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "CTipDoc.h"

CTipDoc::CTipDoc()
{
}

CTipDoc::~CTipDoc()
{
}

int CTipDoc::ListId( char* cid )
{
	ULOG_START("CTipDoc::ListId()");
	
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidOra = cid;
		struct
		{
			VARCHAR stId[21+1];
			VARCHAR stSigla[255+1];
			VARCHAR stDescricao[255+1];
			VARCHAR stidTipoPessoa[21+1];
		} stTipoDocumentoRegistro;
		struct
		{
			short iId;
			short iSigla;
			short iDescricao;
			short iIdTipoPessoa;
		} stTipoDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;

	try
	{
		ZeraTipoDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;
	
	   	EXEC SQL DECLARE CursorTipoDocumentoId CURSOR FOR
			SELECT IDTIPODOCUMENTO, 
			       SGTIPODOCUMENTO, 
			       DSTIPODOCUMENTO, 
			       IDTIPOPESSOA 
			  FROM APOIO.TIPODOCUMENTO
			 WHERE IDTIPOCARTEIRA = :cidOra;
	
		EXEC SQL OPEN CursorTipoDocumentoId;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CTipDoc::ListId()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stTipoDocumentoRegistro, 0, sizeof(stTipoDocumentoRegistro) );
				EXEC SQL FETCH CursorTipoDocumentoId INTO :stTipoDocumentoRegistro:stTipoDocumentoIndicator;
	
				Add( (char*)stTipoDocumentoRegistro.stId.arr, (char*)stTipoDocumentoRegistro.stSigla.arr, (char*)stTipoDocumentoRegistro.stDescricao.arr, (char*)stTipoDocumentoRegistro.stidTipoPessoa.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorTipoDocumentoId;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CTipDoc::ListId()");
	return iCont;

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CTipDoc::ListAll( void )
{
	ULOG_START("CTipDoc::ListAll()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stId[21+1];
			VARCHAR stSigla[255+1];
			VARCHAR stDescricao[255+1];
			VARCHAR stidTipoPessoa[21+1];
		} stTipoDocumentoRegistro;
		struct
		{
			short iId;
			short iSigla;
			short iDescricao;
			short iIdTipoPessoa;
		} stTipoDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;

	try
	{
		ZeraTipoDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;
	
	   	EXEC SQL DECLARE CursorTipoDocumentoAll CURSOR FOR
			SELECT IDTIPODOCUMENTO, 
			       SGTIPODOCUMENTO, 
			       DSTIPODOCUMENTO, 
			       IDTIPOPESSOA 
			  FROM APOIO.TIPODOCUMENTO;
	
		EXEC SQL OPEN CursorTipoDocumentoAll;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CTipDoc::ListAll()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stTipoDocumentoRegistro, 0, sizeof(stTipoDocumentoRegistro) );
				EXEC SQL FETCH CursorTipoDocumentoAll INTO :stTipoDocumentoRegistro:stTipoDocumentoIndicator;
	
				Add( (char*)stTipoDocumentoRegistro.stId.arr, (char*)stTipoDocumentoRegistro.stSigla.arr, (char*)stTipoDocumentoRegistro.stDescricao.arr, (char*)stTipoDocumentoRegistro.stidTipoPessoa.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorTipoDocumentoAll;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CTipDoc::ListAll()");
	return iCont;

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);

}


int CTipDoc::ListFiltrado( void )
{
	ULOG_START("CTipDoc::ListFiltrado()");
	
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stId[21+1];
			VARCHAR stSigla[255+1];
			VARCHAR stDescricao[255+1];
			VARCHAR stidTipoPessoa[21+1];
		} stTipoDocumentoRegistro;
		struct
		{
			short iId;
			short iSigla;
			short iDescricao;
			short iIdTipoPessoa;
		} stTipoDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;

	try
	{
		ZeraTipoDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListFiltrado;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
			DECLARE 
				CursorListFiltrado CURSOR FOR
			SELECT 
				IDTIPODOCUMENTO, 
				SGTIPODOCUMENTO, 
				DSTIPODOCUMENTO, 
				IDTIPOPESSOA 
			FROM 
				APOIO.TIPODOCUMENTO
			WHERE
				SGTIPODOCUMENTO IN ( 'CPF', 'RG', 'RE' )
			ORDER BY
				SGTIPODOCUMENTO;
	
		EXEC SQL OPEN CursorListFiltrado;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CTipDoc::ListFiltrado()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stTipoDocumentoRegistro, 0, sizeof(stTipoDocumentoRegistro) );
				EXEC SQL FETCH CursorListFiltrado INTO :stTipoDocumentoRegistro:stTipoDocumentoIndicator;
	
				Add( (char*)stTipoDocumentoRegistro.stId.arr, 
				     (char*)stTipoDocumentoRegistro.stSigla.arr, 
				     (char*)stTipoDocumentoRegistro.stDescricao.arr, 
				     (char*)stTipoDocumentoRegistro.stidTipoPessoa.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorListFiltrado;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CTipDoc::ListFiltrado()");
	return iCont;

GotoListFiltrado:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CTipDoc::ListSigla( char* csgTipoDocumento )
{
	ULOG_START("CTipDoc::ListSigla()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxsgTipoDocumento = csgTipoDocumento;
		struct
		{
			VARCHAR stId[21+1];
			VARCHAR stSigla[255+1];
			VARCHAR stDescricao[255+1];
			VARCHAR stidTipoPessoa[21+1];
		} stTipoDocumentoRegistro;
		struct
		{
			short iId;
			short iSigla;
			short iDescricao;
			short iIdTipoPessoa;
		} stTipoDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;

	try
	{
		ZeraTipoDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListSigla;
		sqlca.sqlcode=0;
	
	   	EXEC SQL DECLARE CursorTipoDocumentoSigla CURSOR FOR
			SELECT IDTIPODOCUMENTO, 
			       SGTIPODOCUMENTO, 
			       DSTIPODOCUMENTO, 
			       IDTIPOPESSOA 
			  FROM APOIO.TIPODOCUMENTO
			 WHERE SGTIPODOCUMENTO = :cAuxsgTipoDocumento;
	
		EXEC SQL OPEN CursorTipoDocumentoSigla;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CTipDoc::ListSigla()");
			return 0;
	    }	
		else
		{
			for(;;)
			{
				memset( &stTipoDocumentoRegistro, 0, sizeof(stTipoDocumentoRegistro) );
				EXEC SQL FETCH CursorTipoDocumentoSigla INTO :stTipoDocumentoRegistro:stTipoDocumentoIndicator;
	
				Add( (char*)stTipoDocumentoRegistro.stId.arr
				    ,(char*)stTipoDocumentoRegistro.stSigla.arr
				    ,(char*)stTipoDocumentoRegistro.stDescricao.arr
				    ,(char*)stTipoDocumentoRegistro.stidTipoPessoa.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorTipoDocumentoSigla;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CTipDoc::ListSigla()");
	return iCont;

GotoListSigla:
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CTipDoc::GetXml( char* cNomeTag, XMLGen*xml )
{
	ULOG_START("CTipDoc::GetXml()");
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			xml->addProp(	"xmlns", "usuario.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{
				xml->addItem("idTipoDocumento"  , Registro(x)->cidTipoDocumento   );
				xml->addItem("sgTipoDocumento"  , Registro(x)->csgTipoDocumento   );
				xml->addItem("dsTipoDocumento"  , Registro(x)->cdsTipoDocumento   );
				xml->addItem("indisponibilidade", Registro(x)->cidTipoPessoa );
			}
			xml->closeTag();
		}
	}
	ULOG_END("CTipDoc::GetXml()");
}