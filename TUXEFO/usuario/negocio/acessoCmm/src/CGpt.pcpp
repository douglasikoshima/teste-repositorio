/*****************************************************************************
 *
 * Modulo:    CGpt
 * Arquivo:   CGpt.cpp
 * Proposito: Funcao de Negocios 
 * Historico:
 * Data        Autor                 Descricao
 * ----------  --------------------  -----------------------------------------
 * 29/05/2004  C_RECOliveira         Criacao
 * 29/05/2004  C_EDMartins           Criacao
 *
 ****************************************************************************/
/**************************************************************************
 * Notas:
 *
 **************************************************************************/

//Definicao Global
#define CGptCPP 

//Header
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <tuxfw.h>
#include "CGpt.h"
#include "CSafePointer.h"


#include<CTipoGrupo.h>

CGpt::CGpt( void )
{
	ULOG_START("CGpt::CGpt( void )");
	Zerar();
	ULOG_END("CGpt::CGpt( void )");
}

CGpt::~CGpt( void )
{
}


char* CGpt::RTrim(char *pszString)
{
    ULOG_START("CGpt::RTrim()");
    int iLen;

    iLen=strlen(pszString);

    for(;;)
    {
        if(pszString[iLen-1] != ' ')
            break;

        iLen--;

        if(iLen == 0)
            break;
    }
    pszString[iLen] = 0x00;
    ULOG_END("CGpt::RTrim()");
	return pszString;
}


//Servico
int CGpt::GptRemover(DOMNode*dnode, XMLGen*xml_g,
				     char* cLogUser)
{
	ULOG_START(" CGpt::GptRemover()");
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;

		int idGrupamento;
		int iAcumulador;

	EXEC SQL END DECLARE SECTION;

	//Processamento Principal

	//Declara variaveis auxiliares
	char *pc;

	//Se o ID nao for numerico entao retornar com codigo de erro
	pc = oSafePointer.getTag(dnode,"idGrupamento",0);
	if ( pc == NULL )
	{
	    ULOG_END(" CGpt::GptRemover()");
		return 3;
	}

	//Le o ID
	if ( ( idGrupamento = atoi( pc ) ) == 0 )
	{
	    ULOG_END("CGpt::GptRemover()");
		return 2;
	}

	sqlca.sqlcode=0;
	
	

	EXEC SQL WHENEVER SQLERROR GOTO ErrorF;

    //Consulta para verificar se exite grupamento com role caso exista retorna erro worning
    
    /*
     modificacoes charles
     tabelas 
     ACESSO.GRUPAMENTOUNIDADE (Idgrupamento)  GRUPAMENTOUNIDADEFK1
     ACESSO.ROLEGRUPAMENTO (Idgrupamento)  ROLEGRUPAMENTOFK2
    */
	EXEC SQL
		SELECT 
			COUNT(IDGRUPAMENTO) 
		INTO 
			:iAcumulador
		FROM 
			ACESSO.ROLEGRUPAMENTO
		WHERE 
			IDGRUPAMENTO = :idGrupamento;

    //Se existir registro na tabela  ACESSO.ROLEGRUPAMENTO o Grupamento nao poderar se apagado 
	if (iAcumulador > 0)
	{ 
	    ULOG_END("CGpt::GptRemover()");
	    return 5;
	}

   	EXEC SQL
		DELETE FROM acesso.GRUPAMENTOUNIDADE 
		WHERE idGrupamento = :idGrupamento;

	EXEC SQL
		DELETE FROM acesso.Grupamento 
		WHERE idGrupamento = :idGrupamento;

	ULOG_END("CGpt::GptRemover()");
	return 0;

//Tratamento de Exception
ErrorF:
	if( sqlca.sqlcode == -2292 )
	{
	    ULOG_END("CGpt::GptRemover()");
		return 5;
	}
	else
		throw TuxBasicOraException(sqlca.sqlcode);
}


int CGpt::GptSisLista(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CGpt::GptSisLista()");
	//Declarar Estruturas
	struct sqlca sqlca; 
	//Declarar Objetos
	CSafePointer oSafePointer;
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 
		struct
		{
			char cidGrupamento[21+1];
			char cdsGrupamento[255+1];
		} stGrupamento;
		struct
		{
			char cidSistema[21+1];
			char cdsSistema[255+1];
		} stSistema;
		struct
		{
			char cidSubSistema[21+1];
			char cdsSubSistema[255+1];
		} stSubSistema;
		struct
		{
			short iidGrupamento;
			short idsGrupamento;
		}stiGrupamento;
		struct
		{
			short iidSistema;
			short idsSistema;
		}stiSistema;
		struct
		{
			short iidSubSistema;
			short idsSubSistema;
		}stiSubSistema;
	EXEC SQL END DECLARE SECTION;
	
	try
	{

		memset( &stGrupamento, 0, sizeof(stGrupamento));
		memset( &stSistema, 0, sizeof(stSistema));
		memset( &stSubSistema, 0, sizeof(stSubSistema));
	
		//Selecao de grupamentos
		EXEC SQL DECLARE GptSisListaGrupamento CURSOR FOR
			SELECT IDGRUPAMENTO, 
				   NMGRUPAMENTO
			  FROM ACESSO.GRUPAMENTO;
	
		//Selecao de Sistemas
		EXEC SQL DECLARE GptSisListaSistema CURSOR FOR
			SELECT IDSISTEMA, 
				   NMSISTEMAOPERACIONAL 
			  FROM ACESSO.SISTEMA
			  ORDER BY UPPER(NMSISTEMAOPERACIONAL);
	
		//Selecao de Subsistemas
		EXEC SQL DECLARE GptSisListaSubSistema CURSOR FOR
			SELECT IDSUBSISTEMA, 
				   NMSUBSISTEMA 
			  FROM ACESSO.SUBSISTEMA
			 WHERE IDSISTEMA = :stSistema.cidSistema
			 ORDER BY UPPER(NMSUBSISTEMA);
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	
		sqlca.sqlcode=0;
	
		EXEC SQL OPEN GptSisListaGrupamento;
	
		//Loop de grupamento
		xml_g->createTag("ListaParamGrupamUnidVO");
	
		xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
		for(;;)
		{
			memset( &stGrupamento, 0, sizeof(stGrupamento));
			EXEC SQL FETCH GptSisListaGrupamento INTO :stGrupamento:stiGrupamento;
			xml_g->createTag("GrupamentosExistentesUsuarioVO");
	
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			xml_g->addItem("idGrupamento", RTrim( stGrupamento.cidGrupamento ) );
			xml_g->addItem("dsGrupamento", RTrim( stGrupamento.cdsGrupamento ) );
	
			xml_g->closeTag();
		}//for(;;)
		EXEC SQL CLOSE GptSisListaGrupamento;
	
		EXEC SQL OPEN GptSisListaSistema;
		//Loop de sistema
		for(;;)
		{
			memset( &stSistema, 0, sizeof(stSistema));
			EXEC SQL FETCH GptSisListaSistema INTO :stSistema:stiSistema;
			xml_g->createTag("SistemasSubSistPaginasVO");
	
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			xml_g->addItem("idSistema", RTrim( stSistema.cidSistema ) );
			xml_g->addItem("dsSistema", RTrim( stSistema.cdsSistema ) );
	
			EXEC SQL OPEN GptSisListaSubSistema;
			for(;;)
			{
				memset( &stSubSistema, 0, sizeof(stSubSistema));
				EXEC SQL FETCH GptSisListaSubSistema INTO :stSubSistema:stiSubSistema;
				xml_g->createTag("SubSistemaPaginasVO");
	
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idSubSistema", RTrim( stSubSistema.cidSubSistema ) );
				xml_g->addItem("dsSubSistema", RTrim( stSubSistema.cdsSubSistema ) );
	
				xml_g->closeTag();
	
			}
			EXEC SQL CLOSE GptSisListaSubSistema;
			xml_g->closeTag();
		}//for(;;)
		xml_g->closeTag();
		EXEC SQL CLOSE GptSisListaSistema;
	}
	catch(...)
	{
		throw;
	}

	ULOG_END("CGpt::GptSisLista()");
	return 0;//Sucesso

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CGpt::GptListaPar(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CGpt::GptListaPar()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 

		struct Tstruct {
			int idGrupamento; 
			char cnmGrupamento[256];
		} tstruct;

		struct Tstructindicator {
			short sidGrupamento, snmGrupamento;
		} tstructindicator;

		char vcLike[256];

	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
        // modificao do eder
        int finTipo=0 ;
		char *pcn ;
        pcn = oSafePointer.getTag(dnode,"inTipo",0);
		//Se o ID ou DESCRICAO estiver vazio entao retornar com codigo de erro
		if ( strlennull( pcn ) <= 0 )
		   if ( strcmp(pcn,"1") == 0  ) 
                finTipo = 1;
        if (finTipo) 
        {
            CTipoGrupo oCTipoGrupo;
            oCTipoGrupo.ListAll();

			// criando o xml de saida

			xml_g->createTag("GrupoUsuarioVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
			xml_g->closeTag();
            oCTipoGrupo.GetXml("TiposGrupo",xml_g) ;


/*            
<xs:element name="GrupoUsuarioVO">
		<xs:annotation>
			<xs:documentation>Comment describing your root element</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element name="idGrupo" type="xs:string" minOccurs="0"/>
				<xs:element name="dsGrupo" type="xs:string" minOccurs="0"/>
				<xs:element name="inCRI" type="xs:string" minOccurs="0"/>
				<xs:element name="inSupervisor" type="xs:string" minOccurs="0"/>
				<xs:element name="idTipoGrupoSelecionado" type="xs:string" minOccurs="0"/>
				<xs:element name="TiposGrupo" minOccurs="0" maxOccurs="unbounded">
					<xs:complexType>
						<xs:sequence>
							<xs:element name="idTipoGrupo" type="xs:string"/>
							<xs:element name="dsTipoGrupo" type="xs:string"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
*/
        }
        else 
        {   
		    memset( &tstruct, 0, sizeof(Tstruct));
		    memset( &tstructindicator, 0, sizeof(Tstructindicator));
	        
		    char *pc = oSafePointer.getTag(dnode,"dsGrupamento",0);
		    if ( pc == 0 )
		    {
		    	strcpy( tstruct.cnmGrupamento, "" );
		    } 
		    else 
		    {
		    	strcpy( tstruct.cnmGrupamento, pc);
		    }
		    
		    sqlca.sqlcode=0;
		    
		    if ( strlen(tstruct.cnmGrupamento)==0 ) 
		    {
	        
		    	EXEC SQL 
		    	DECLARE 
		    		tsqlcursor2 CURSOR FOR
		    	SELECT 
		    		IDGRUPAMENTO, 
		    		NMGRUPAMENTO 
		    	FROM 
		    		ACESSO.GRUPAMENTO
		    	ORDER BY 
		    		UPPER(NMGRUPAMENTO);
	        
		    	EXEC SQL OPEN tsqlcursor2;
		    	EXEC SQL WHENEVER NOT FOUND DO break;
		    	EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		    	
		    	if(sqlca.sqlcode)
		    	{
		    	    ULOG_END("CGpt::GptListaPar()");
		    		return 4;
		    	}
		    	else
		    	{
		    		xml_g->createTag("ListaGrupamentosUsuarioVO");
		    		xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
		    		for(;;)
		    		{
		    			EXEC SQL FETCH tsqlcursor2 INTO :tstruct INDICATOR :tstructindicator;
		    			xml_g->createTag("GrupamentosExistentesUsuarioVO");
		    			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
		    			xml_g->addItem("idGrupamento",tstruct.idGrupamento);
		    			xml_g->addItem("dsGrupamento",RTrim(tstruct.cnmGrupamento));
		    			xml_g->closeTag();
		    		}
		    		xml_g->closeTag();
		    		EXEC SQL CLOSE tsqlcursor2;
		    	}
	        
		    } 
		    else 
		    {
		    	sprintf( vcLike, "%s%s", tstruct.cnmGrupamento, "%" ); 
		    
		    	EXEC SQL 
		    	DECLARE 
		    		tsqlcursor CURSOR FOR
		    	SELECT 
		    		IDGRUPAMENTO, 
		    		NMGRUPAMENTO 
		    	FROM 
		    		ACESSO.GRUPAMENTO
		    	WHERE 
		    		UPPER(NMGRUPAMENTO) LIKE UPPER(:vcLike)
		    	ORDER BY 
		    		UPPER(NMGRUPAMENTO);
	        
		    	EXEC SQL OPEN tsqlcursor;
		    	EXEC SQL WHENEVER NOT FOUND DO break;
		    	EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		    	
		    	if(sqlca.sqlcode)
		    	{
		    	    ULOG_END("CGpt::GptListaPar()");
		    		return 4;
		    	}
		    	else
		    	{
		    		xml_g->createTag("ListaGrupamentosUsuarioVO");
		    		xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
		    		for(;;) 
		    		{
		    			EXEC SQL FETCH tsqlcursor INTO :tstruct INDICATOR :tstructindicator;
		    			xml_g->createTag("GrupamentosExistentesUsuarioVO");
		    			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
		    			xml_g->addItem("idGrupamento",tstruct.idGrupamento);
		    			xml_g->addItem("dsGrupamento",RTrim(tstruct.cnmGrupamento));
		    			xml_g->closeTag();
		    		}
		    		xml_g->closeTag();
		    		EXEC SQL CLOSE tsqlcursor;
		    	}
		    }
        }
	}
	catch(...)
	{
		throw;
	}

	ULOG_END("CGpt::GptListaPar()");
	return 0;
	
//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}



int CGpt::GptEditar(DOMNode*dnode,XMLGen*xml_g,
				    char* cLogUser)
{
	ULOG_START("CGpt::GptEditar()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;

		struct Tstruct { 
			int idGrupamento;
			char cnmGrupamento[256];
		} tstruct;

		struct Tstructindicator {
			short sidGrupamento, snmGrupamento;
		} tstructindicator;

		int iAcumulador;

	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{

		memset( &tstruct, 0, sizeof(Tstruct));
		memset( &tstructindicator, 0, sizeof(Tstructindicator));
	
		//Declara variaveis auxiliares
		char *pcid;
		char *pcnm;
		
		//Se nao encontrar a proxima TAG entao acabaram os registros para alterar
		memset( &tstruct, 0, sizeof(Tstruct) );

		//Se o ID ou DESCRICAO nao existir entao retornar com codigo de erro
		pcid = oSafePointer.getTag( dnode, "idGrupamento", 0 );
		pcnm = oSafePointer.getTag( dnode, "dsGrupamento", 0 );

		//Se o ID ou DESCRICAO estiver vazio entao retornar com codigo de erro
		if ( strlennull( pcid ) <= 0 )
		{
		    ULOG_END("CGpt::GptEditar()");
			return 1;//idGrupamento esta nulo
		}
		if ( strlennull( pcnm ) <= 0 )
		{
			ULOG_END("CGpt::GptEditar()");
			return 2;//dsGrupamento esta nulo
		}
		if ( ( tstruct.idGrupamento = atoi( pcid ) ) <= 0 )
		{
			ULOG_END("CGpt::GptEditar()");
			return 3;//idGrupamento invalido
		}

		strcpy(tstruct.cnmGrupamento, pcnm);

		setidGrupamento( pcid );
		setdsGrupamento( pcnm );

		sqlca.sqlcode=0;

		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;

		//Conta os casos de ja existentes de descricao
		EXEC SQL
			SELECT 
				COUNT(IDGRUPAMENTO) 
			INTO 
				:iAcumulador
			FROM 
				ACESSO.GRUPAMENTO
			WHERE 
				UPPER( NMGRUPAMENTO ) = UPPER(:tstruct.cnmGrupamento)
			AND 
				IDGRUPAMENTO <>:tstruct.idGrupamento;

		//Se nao houver o caso desta descricao entao pode Inserir
		if (iAcumulador==0) 
		{
			//Altera a descricao do Grupamento
			EXEC SQL 
				UPDATE 
					ACESSO.GRUPAMENTO 
				SET 
					NMGRUPAMENTO = :tstruct.cnmGrupamento,
					IDUSUARIOALTERACAO = :cLogUserOra, 
					DTULTIMAALTERACAO  = SYSDATE
				WHERE 
					IDGRUPAMENTO = :tstruct.idGrupamento;
		}
		else
		{
		    ULOG_END("CGpt::GptEditar()");
			return 5;//O nome passado como parametro ja existe na base
		}

	}

	
	catch(...)
	{
		throw;
	}
    
    ULOG_END("CGpt::GptEditar()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CGpt::GptLista(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CGpt::GptLista()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION; 

		struct Tstruct {
			int idGrupamento; 
			char cnmGrupamento[256];
		} tstruct;

		struct Tstructindicator {
			short sidGrupamento, snmGrupamento;
		} tstructindicator;
		char  cdsGrupamento[255+1];
		char* pzcdsGrupamento;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		memset( &cdsGrupamento, 0, sizeof(cdsGrupamento));
		memset( &tstruct, 0, sizeof(Tstruct));
		memset( &tstructindicator, 0, sizeof(Tstructindicator));
	
		pzcdsGrupamento = oSafePointer.getTag( dnode, "dsGrupamento", 0 );
		
		if( strlennull( pzcdsGrupamento ) <= 0 )
			strcpy( cdsGrupamento, "-1" );
		else
			sprintf( cdsGrupamento, "%s%%", pzcdsGrupamento );

		sqlca.sqlcode=0;
		
		EXEC SQL 
			DECLARE 
				tsqlcursor3 CURSOR FOR
			SELECT
				IDGRUPAMENTO
			   ,NMGRUPAMENTO 
			FROM
				ACESSO.GRUPAMENTO
			WHERE
				UPPER(NMGRUPAMENTO) LIKE( UPPER(:cdsGrupamento) ) OR :cdsGrupamento = '-1'
			ORDER BY 
				UPPER(NMGRUPAMENTO);
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		EXEC SQL OPEN tsqlcursor3;
		
		if(sqlca.sqlcode)
		{
		    ULOG_END("CGpt::GptLista()");
			return 4;
		}
		else
		{
			xml_g->createTag("ListaGrupamentosUsuarioVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				for(;;) {
				EXEC SQL FETCH tsqlcursor3 INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("GrupamentosExistentesUsuarioVO");
				xml_g->addItem("idGrupamento",tstruct.idGrupamento);
				xml_g->addItem("dsGrupamento",RTrim(tstruct.cnmGrupamento));
				xml_g->closeTag();
			}
			xml_g->closeTag();
			EXEC SQL CLOSE tsqlcursor3;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CGpt::GptLista()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CGpt::GptUniRelaciona(DOMNode*dnode, XMLGen*xml_g,
				          char* cLogUser)
{
	ULOG_START("CGpt::GptUniRelaciona()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;
		char* cidPagina;
		struct Tstruct {
			int idGrupamentoUnidade;
			int idGrupamento;
			int idUnidade;
		} tstruct;

		struct Tstruct2 {
			int idUnidade;
			char cnmUnidade[256];
		} tstruct2;

		struct Tstructindicator {
			short sidGrupamentoUnidade, sidGrupamento, sidUnidade;
		} tstructindicator;

		struct Tstructindicator2 {
			short sidUnidade, snmUnidade;
		} tstructindicator2;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		memset( &tstruct, 0, sizeof(Tstruct) );
		memset( &tstruct2, 0, sizeof(Tstruct2) );
		memset( &tstructindicator, 0, sizeof(Tstructindicator) );
		memset( &tstructindicator2, 0, sizeof(Tstructindicator2) );
	
		cidPagina = oSafePointer.getTag( dnode, "idPagina", 0  );
		if( strlennull( cidPagina ) <= 0 )
		{
			ULOG_END("CGpt::GptUniRelaciona()");
			return 4;
		}
		//Pega o idGrupamento que sera utilizado na ralacao
		if ( ( tstruct.idGrupamento = atoi( oSafePointer.getTag( dnode, "idGrupamento", 0  ) ) )  <= 0 ) 
		{
		    ULOG_END("CGpt::GptUniRelaciona()");
			return 3;//idGrupamento esta nulo
		}
		
	
		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	
		EXEC SQL 
			DELETE FROM 
				ACESSO.GRUPAMENTOUNIDADE 
			WHERE 
				IDGRUPAMENTO = :tstruct.idGrupamento
			AND
				IDUNIDADE IN
				(
					SELECT 
						IDUNIDADE
					FROM
						ACESSO.PAGINAUNIDADE
					WHERE
						IDPAGINA = :cidPagina
				);
	
		//Verifica se o comando DELETE obteve sucesso
		sqlca.sqlcode = 0;
		char* pc;

		//Pega todos os idUnidade que existem no XML e insere
		for(int indice=0;;indice++) 
		{

			pc = oSafePointer.getTag( dnode, "idUnidade", indice  );
			if( strlennull( pc ) <= 0 )
				break;

			tstruct.idUnidade = atoi( pc );

			sqlca.sqlcode=0;

			EXEC SQL WHENEVER SQLERROR GOTO ErrorF;

			//Pega um id unico e sequencia para a insercao
			EXEC SQL
				SELECT 
					acesso.GrupamentoUnidadesq.nextval
				INTO 
					:tstruct.idGrupamentoUnidade
				FROM DUAL;

			//Insere item a item
			EXEC SQL 
				INSERT INTO ACESSO.GRUPAMENTOUNIDADE 
				( 
					IDGRUPAMENTOUNIDADE, 
					IDGRUPAMENTO, 
					IDUNIDADE, 
					IDUSUARIOALTERACAO, 
					DTULTIMAALTERACAO 
				)
				VALUES
				( 
					:tstruct.idGrupamentoUnidade, 
					:tstruct.idGrupamento, 
					:tstruct.idUnidade, 
					:cLogUserOra, 
					 SYSDATE
				);

			//Se der algum erro, desfaz tudo
			if(sqlca.sqlcode)
			{ 
				ULOG_END("CGpt::GptUniRelaciona()");
				//EXEC SQL ROLLBACK WORK; 
				return 2; //Erro ao tentar inserir a relacao
			}
		}//for( indice=1;;indice++) 
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CGpt::GptUniRelaciona()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CGpt::GptUniRelacao(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CGpt::GptUniRelacao()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidGrupamento;
		char* cidPagina;
		char* cidSistema;
		char* cidSubSistema;
		char* cdefault = "-1";
		struct Tstruct {
			int idUnidade;
			char cnmUnidade[256];
		} tstruct;
		struct Tstructindicator {
			short sidUnidade, snmUnidade;
		} tstructindicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{

		memset( &tstruct, 0, sizeof(Tstruct));
		memset( &tstructindicator, 0, sizeof(Tstructindicator));
	
		cidGrupamento = oSafePointer.getTag(dnode,"idGrupamento",0);
		if( strlen(cidGrupamento) <= 0 )
		{
			ULOG_END("CGpt::GptUniRelacao()");
			return 1;
		}
		cidPagina = oSafePointer.getTag(dnode,"idPagina",0);
		if( strlen(cidPagina) <= 0 )
			cidPagina = cdefault;
		cidSistema = oSafePointer.getTag(dnode,"idSistema",0);
		if( strlen(cidSistema) <= 0 )
			cidSistema = cdefault;
		cidSubSistema = oSafePointer.getTag(dnode,"idSubSistema",0);
		if( strlen(cidSubSistema) <= 0 )
			cidSubSistema = cdefault;
	
		sqlca.sqlcode=0;
	
		EXEC SQL DECLARE tvcursorrelacionados CURSOR FOR
			SELECT GRUPAMENTOUNIDADEV01.IDUNIDADE, GRUPAMENTOUNIDADEV01.NMUNIDADE 
		      FROM ACESSO.GRUPAMENTOUNIDADEV01 GRUPAMENTOUNIDADEV01
			 WHERE ( GRUPAMENTOUNIDADEV01.IDSISTEMA =  :cidSistema OR :cidSistema = '-1' )
			   AND ( GRUPAMENTOUNIDADEV01.IDSUBSISTEMA = :cidSubSistema OR :cidSubSistema = '-1' )
			   AND ( GRUPAMENTOUNIDADEV01.IDPAGINA = :cidPagina OR :cidPagina = '-1' )
			   AND GRUPAMENTOUNIDADEV01.IDGRUPAMENTO = :cidGrupamento
			   ORDER BY UPPER(GRUPAMENTOUNIDADEV01.NMUNIDADE);
	
		EXEC SQL DECLARE tvcursorexistentes CURSOR FOR
			SELECT PAGINAUNIDADE.IDUNIDADE,
			       UNIDADE.NMUNIDADE
			FROM   ACESSO.PAGINAUNIDADE,
			       ACESSO.UNIDADE,
			       ACESSO.PAGINA
			WHERE  UNIDADE.IDUNIDADE = PAGINAUNIDADE.IDUNIDADE
			       AND PAGINA.IDPAGINA = PAGINAUNIDADE.IDPAGINA
			       AND ( PAGINA.IDPAGINA = :cidPagina OR :cidPagina = '-1' )
			       AND PAGINAUNIDADE.IDUNIDADE NOT IN
			       (
			                     SELECT GRUPAMENTOUNIDADEV01.IDUNIDADE 
								 FROM ACESSO.GRUPAMENTOUNIDADEV01 GRUPAMENTOUNIDADEV01
								 WHERE ( GRUPAMENTOUNIDADEV01.IDSISTEMA =  :cidSistema OR :cidSistema = '-1' )
								   AND ( GRUPAMENTOUNIDADEV01.IDSUBSISTEMA = :cidSubSistema OR :cidSubSistema = '-1' )
								   AND ( GRUPAMENTOUNIDADEV01.IDPAGINA = :cidPagina OR :cidPagina = '-1' )
								   AND GRUPAMENTOUNIDADEV01.IDGRUPAMENTO = :cidGrupamento
			       )
			ORDER BY UPPER(UNIDADE.NMUNIDADE);
			
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	
		EXEC SQL OPEN tvcursorexistentes;
		EXEC SQL OPEN tvcursorrelacionados;
	
		if(sqlca.sqlcode) {
			ULOG_END("CGpt::GptUniRelacao()");
			return 5;
		}
		else {
			xml_g->createTag("ListaUnidadesGrupamentoVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" ); 
	
			xml_g->addItem("idGrupamento",cidGrupamento);
			for(;;) {
				EXEC SQL FETCH tvcursorexistentes INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("UnidadesExistentesUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idUnidade",tstruct.idUnidade);
				xml_g->addItem("dsUnidade",RTrim(tstruct.cnmUnidade));
				xml_g->closeTag();
			}
			EXEC SQL CLOSE tvcursorexistentes;
	
			for(;;) {
				EXEC SQL FETCH tvcursorrelacionados INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("UnidadesRelacionadasUsuarioVO");
				xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				xml_g->addItem("idUnidade",tstruct.idUnidade);
				xml_g->addItem("dsUnidade",RTrim(tstruct.cnmUnidade));
				xml_g->closeTag();
			}
			EXEC SQL CLOSE tvcursorrelacionados;
	
			xml_g->closeTag();
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END(" CGpt::GptUniRelacao()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CGpt::GptInserir(DOMNode*dnode,XMLGen*xml_g,
				     char* cLogUser)
{
	ULOG_START("CGpt::GptInserir()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cLogUserOra = cLogUser;

		struct Tstruct { 
			VARCHAR stidGrupamento[21+1];
			char cnmGrupamento[255+1];
		} tstruct;

		int iAcumulador;

	EXEC SQL END DECLARE SECTION;

	//Declara variaveis auxiliares
	char *pc;
	try
	{
	
		//Se nao encontrar a proxima TAG entao acabaram os registros para alterar
		for( int indice=0; ; indice++ ) { 
	
			memset( &tstruct, 0, sizeof(Tstruct) );
		
			//Se a DESCRICAO nao existir entao retornar com codigo de erro
			pc = oSafePointer.getTag(dnode,"dsGrupamento",indice); 
			if ( pc == NULL )
				break;
	
			//Se a DESCRICAO estiver vazio entao retornar com codigo de erro
			if ( ( strlen( pc ) == 0 ) )
			{
			    ULOG_END("CGpt::GptInserir()");
			    return 3;
			}
			strcpy( tstruct.cnmGrupamento, pc ); 
	
			sqlca.sqlcode=0;
	
			EXEC SQL WHENEVER NOT FOUND CONTINUE;
			EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	
			//Conta os casos de ja existentes de descricao 
			EXEC SQL
				SELECT 
					COUNT(idGrupamento) 
				INTO 
					:iAcumulador
				FROM 
					acesso.Grupamento
				WHERE 
					UPPER(nmGrupamento) = UPPER(:tstruct.cnmGrupamento);
	
			//Se nao houver o caso desta descricao entao pode Inserir
			if (iAcumulador==0) 
			{
	
				//Pega um ID único 
				EXEC SQL
					SELECT 
						ACESSO.GRUPAMENTOSQ.NEXTVAL
					INTO 
						:tstruct.stidGrupamento
					FROM DUAL;
	
				//Insere o ID novo
				EXEC SQL 
					INSERT INTO ACESSO.GRUPAMENTO 
					( 
						IDGRUPAMENTO, 
						NMGRUPAMENTO, 
						IDUSUARIOALTERACAO, 
						DTULTIMAALTERACAO 
					)
					VALUES
					( 
						 :tstruct.stidGrupamento
						,TRIM(SUBSTR(:tstruct.cnmGrupamento,1,255))
						,:cLogUserOra
						,SYSDATE 
					);

					setidGrupamento( (char*)tstruct.stidGrupamento.arr );
					setdsGrupamento( tstruct.cnmGrupamento );

			}
			else
			{
			    ULOG_END("CGpt::GptInserir()");
				return 2;//Nome ja existe
			}
	
			if(sqlca.sqlcode) { 
				ULOG_END("CGpt::GptInserir()");
				return 4; 
			} 
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CGpt::GptInserir()");
	return 0;

//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CGpt::GptListaId(DOMNode*dnode, XMLGen*xml_g)
{
	ULOG_START("CGpt::GptListaId()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;

		struct Tstruct {
			int idGrupamento; 
			char cnmGrupamento[256];
		} tstruct;

		struct Tstructindicator {
			short sidGrupamento, snmGrupamento;
		} tstructindicator;

	EXEC SQL END DECLARE SECTION;

	char *pc;
	try
	{
			
		memset( &tstruct, 0, sizeof(Tstruct));
		memset( &tstructindicator, 0, sizeof(Tstructindicator));
	
		//Se o ID nao for numerico entao retornar com codigo de erro
		if ( ( pc = oSafePointer.getTag(dnode,"idGrupamento",0) ) == NULL ) {
			ULOG_END(" CGpt::GptListaId()");
			return 2;
		}
	
		//Se o ID estiver vazio entao retornar com codigo de erro
		if ( strlen( pc ) == 0 ) {
			ULOG_END("CGpt::GptListaId()");
			return 3;
		}
	
		//Le a descricao de Grupamento
		tstruct.idGrupamento = atoi( pc );
	
		sqlca.sqlcode=0;
	
		EXEC SQL 
		DECLARE 
			tcursor1 CURSOR FOR
		SELECT 
			IDGRUPAMENTO, 
			NMGRUPAMENTO 
		FROM 
			ACESSO.GRUPAMENTO
		WHERE 
			IDGRUPAMENTO = :tstruct.idGrupamento;
	
		EXEC SQL OPEN tcursor1;
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	
		if(sqlca.sqlcode)
		{
		    ULOG_END("CGpt::GptListaId()");
			return 4;
		}
		else
		{
			xml_g->createTag("ListaGrupamentosUsuarioVO");
			xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
				for(;;) {
				EXEC SQL FETCH tcursor1 INTO :tstruct INDICATOR :tstructindicator;
				xml_g->createTag("GrupamentosExistentesUsuarioVO");
				xml_g->addItem("idGrupamento",tstruct.idGrupamento);
				xml_g->addItem("dsGrupamento",RTrim(tstruct.cnmGrupamento));
				xml_g->closeTag();
			}
			xml_g->closeTag();
			EXEC SQL CLOSE tcursor1;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CGpt::GptListaId()");
	return 0;


//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CGpt::GptListaId(char* cidGrupamento, XMLGen*xml_g)
{
	ULOG_START(" CGpt::GptListaId()");
	
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Objetos
	CSafePointer oSafePointer;

	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidGrupamento = cidGrupamento;
		struct 
		{
			VARCHAR stidGrupamento[21+1]; 
			VARCHAR stnmGrupamento[255+1];
		} stRegistro;

		struct 
		{
			short iidGrupamento;
			short inmGrupamento;
		} stIndicador;

	EXEC SQL END DECLARE SECTION;

	try
	{
			
		memset( &stRegistro, 0, sizeof(stRegistro));
	
		//Se o ID estiver vazio entao retornar com codigo de erro
		if( strlennull( cAuxidGrupamento ) <= 0 )
		{
		    ULOG_END(" CGpt::GptListaId()");
			return 3;
		}
	
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
		sqlca.sqlcode=0;
	
		EXEC SQL 
			SELECT 
				IDGRUPAMENTO, 
				NMGRUPAMENTO 
			INTO
				:stRegistro:stIndicador
			FROM 
				ACESSO.GRUPAMENTO
			WHERE 
				IDGRUPAMENTO = :cAuxidGrupamento;
	
		xml_g->createTag("ListaGrupamentosUsuarioVO");
		xml_g->addProp("xmlns", "usuario.fo.vivo.com.br/vo" );
		if( stRegistro.stidGrupamento.len > 0 )
		{
			xml_g->createTag("GrupamentosExistentesUsuarioVO");
			xml_g->addItem("idGrupamento",(char*)stRegistro.stidGrupamento.arr);
			xml_g->addItem("dsGrupamento",(char*)stRegistro.stnmGrupamento.arr);
			xml_g->closeTag();
		}
		xml_g->closeTag();
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CGpt::GptListaId()");
	return 0;


//Tratamento de Exception
ErrorF:
	throw TuxBasicOraException(sqlca.sqlcode);
}

void CGpt::Zerar( void )
{
	ULOG_START(" CGpt::Zerar(  )");
	memset( cidGrupamento, 0, sizeof( cidGrupamento ) );
	memset( cdsGrupamento, 0, sizeof( cdsGrupamento ) );
	ULOG_END(" CGpt::Zerar(  )");
}

char* CGpt::getidGrupamento(void)
{
	ULOG_START(" CGpt::getidGrupamento()");
	ULOG_END(" CGpt::getidGrupamento()");
	return &cidGrupamento[0];
}

char* CGpt::getdsGrupamento(void)
{
	ULOG_START(" CGpt::getdsGrupamento()");
	ULOG_END(" CGpt::getdsGrupamento()");
	return &cdsGrupamento[0];
}

void CGpt::setidGrupamento(char* pzcidGrupamento)
{
	ULOG_START(" CGpt::setidGrupamento()");
	memset( cidGrupamento, 0, sizeof( cidGrupamento ) );
	if( strlennull( pzcidGrupamento ) > 0 )
	{
		if( strlennull( pzcidGrupamento ) > 21 )
			strncpy( cidGrupamento, &pzcidGrupamento[0], 21 );
		else
			strcpy( cidGrupamento, pzcidGrupamento );
		
	}
	ULOG_END("CGpt::setidGrupamento()");
}

void CGpt::setdsGrupamento(char* pzcdsGrupamento)
{
	ULOG_START(" CGpt::setdsGrupamento()");
	memset( cdsGrupamento, 0, sizeof( cdsGrupamento ) );
	if( strlennull( pzcdsGrupamento ) > 0 )
	{
		if( strlennull( pzcdsGrupamento ) > 255 )
			strncpy( cdsGrupamento, &pzcdsGrupamento[0], 255 );
		else
			strcpy( cdsGrupamento, pzcdsGrupamento );
	}
	ULOG_END(" CGpt::setdsGrupamento()");
}
