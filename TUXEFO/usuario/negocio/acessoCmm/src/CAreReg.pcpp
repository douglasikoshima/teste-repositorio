#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "CAreReg.h"

CAreReg::CAreReg()
{
}

CAreReg::~CAreReg()
{
}

int CAreReg::ListId( char* cidAreaRegistro )
{
	ULOG_START("CAreReg::ListId( )");
	
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidAreaRegistro = cidAreaRegistro;
		struct
		{
			VARCHAR stidAreaRegistro[21+1];
			VARCHAR stcdAreaRegistro[255+1];
			VARCHAR stnmAreaRegistro[255+1];
			VARCHAR stidUFOperadora[21+1];
		} stAreaRegistroRegistro;
		struct
		{
			short iidAreaRegistro;
			short icdAreaRegistro;
			short inmAreaRegistro;
			short iidUFOperadora;
		} stAreaRegistroIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{

		ZeraAreaRegistro();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE 
	   			CursorAreaRegistroId CURSOR FOR
			SELECT 
			       AREAREGISTRO.IDAREAREGISTRO,
			       AREAREGISTRO.CDAREAREGISTRO,
			       AREAREGISTRO.NMAREAREGISTRO,
			       AREAREGISTRO.IDUFOPERADORA
			FROM 
			     APOIO.AREAREGISTRO AREAREGISTRO
			WHERE 
				AREAREGISTRO.IDAREAREGISTRO = :cAuxidAreaRegistro
			ORDER BY AREAREGISTRO.CDAREAREGISTRO;
	
		EXEC SQL OPEN CursorAreaRegistroId;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CAreReg::ListId( )");	
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stAreaRegistroRegistro, 0, sizeof(stAreaRegistroRegistro) );
				EXEC SQL FETCH CursorAreaRegistroId INTO :stAreaRegistroRegistro:stAreaRegistroIndicator;
	
				Add( (char*)stAreaRegistroRegistro.stidAreaRegistro.arr  
				    ,(char*)stAreaRegistroRegistro.stcdAreaRegistro.arr  
				    ,(char*)stAreaRegistroRegistro.stnmAreaRegistro.arr  
				    ,(char*)stAreaRegistroRegistro.stidUFOperadora.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorAreaRegistroId;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CAreReg::ListId( )");		
	return iCont;

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CAreReg::ListAll( void )
{
	ULOG_START("CAreReg::ListAll( )");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidAreaRegistro[21+1];
			VARCHAR stcdAreaRegistro[255+1];
			VARCHAR stnmAreaRegistro[255+1];
			VARCHAR stidUFOperadora[21+1];
		} stAreaRegistroRegistro;
		struct
		{
			short iidAreaRegistro;
			short icdAreaRegistro;
			short inmAreaRegistro;
			short iidUFOperadora;
		} stAreaRegistroIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{
		ZeraAreaRegistro();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE 
	   			CursorAreaRegistroAll CURSOR FOR
			SELECT 
				AREAREGISTRO.IDAREAREGISTRO,
			    AREAREGISTRO.CDAREAREGISTRO,
			    AREAREGISTRO.NMAREAREGISTRO,
			    AREAREGISTRO.IDUFOPERADORA
			FROM 
			    APOIO.AREAREGISTRO AREAREGISTRO
			WHERE 
				AREAREGISTRO.IDAREAREGISTRO > 0
			ORDER BY 
				AREAREGISTRO.CDAREAREGISTRO;
	
		EXEC SQL OPEN CursorAreaRegistroAll;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CAreReg::ListAll( )");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stAreaRegistroRegistro, 0, sizeof(stAreaRegistroRegistro) );
				EXEC SQL FETCH CursorAreaRegistroAll INTO :stAreaRegistroRegistro:stAreaRegistroIndicator;
	
				Add( (char*)stAreaRegistroRegistro.stidAreaRegistro.arr  
				    ,(char*)stAreaRegistroRegistro.stcdAreaRegistro.arr  
				    ,(char*)stAreaRegistroRegistro.stnmAreaRegistro.arr  
				    ,(char*)stAreaRegistroRegistro.stidUFOperadora.arr );
			}
			EXEC SQL CLOSE CursorAreaRegistroAll;
		}
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CAreReg::ListAll( )");
	return iCont;

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CAreReg::ListSigla( char* ccdAreaRegistro )
{
	ULOG_START("CAreReg::ListSigla()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxcdAreaRegistro = ccdAreaRegistro;
		struct
		{
			VARCHAR stidAreaRegistro[21+1];
			VARCHAR stcdAreaRegistro[255+1];
			VARCHAR stnmAreaRegistro[255+1];
			VARCHAR stidUFOperadora[21+1];
		} stAreaRegistroRegistro;
		struct
		{
			short iidAreaRegistro;
			short icdAreaRegistro;
			short inmAreaRegistro;
			short iidUFOperadora;
		} stAreaRegistroIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{
		ZeraAreaRegistro();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListSigla;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE 
	   			CursorListSigla CURSOR FOR
			SELECT 
			       AREAREGISTRO.IDAREAREGISTRO,
			       AREAREGISTRO.CDAREAREGISTRO,
			       AREAREGISTRO.NMAREAREGISTRO,
			       AREAREGISTRO.IDUFOPERADORA
			FROM 
			     APOIO.AREAREGISTRO AREAREGISTRO
			WHERE 
				TRIM(AREAREGISTRO.CDAREAREGISTRO) = TRIM(:cAuxcdAreaRegistro);
	
		EXEC SQL OPEN CursorListSigla;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CAreReg::ListSigla()");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stAreaRegistroRegistro, 0, sizeof(stAreaRegistroRegistro) );
				EXEC SQL FETCH CursorListSigla INTO :stAreaRegistroRegistro:stAreaRegistroIndicator;
	
				Add( (char*)stAreaRegistroRegistro.stidAreaRegistro.arr
				    ,(char*)stAreaRegistroRegistro.stcdAreaRegistro.arr
				    ,(char*)stAreaRegistroRegistro.stnmAreaRegistro.arr
				    ,(char*)stAreaRegistroRegistro.stidUFOperadora.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorListSigla;
		}
	}
	catch(...)
	{
		throw;
	}
	
	ULOG_END("CAreReg::ListSigla()");
	return iCont;

GotoListSigla:
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CAreReg::GetXml( char* cNomeTag, XMLGen*xml )
{
	
	ULOG_START("CAreReg::GetXml()");
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			xml->addProp(	"xmlns", "usuario.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{
				xml->addItem("idAreaRegistro", Registro(x)->cidAreaRegistro );
				xml->addItem("cdAreaRegistro", Registro(x)->ccdAreaRegistro );
				xml->addItem("nmAreaRegistro", Registro(x)->cnmAreaRegistro );
				xml->addItem("idUFOperadora" , Registro(x)->cidUFOperadora  );
			}
			xml->closeTag();
		}
	}
	ULOG_END("CAreReg::GetXml()");
}