#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "CNvlHie.h"

CNvlHie::CNvlHie()
{
}

CNvlHie::~CNvlHie()
{
}

char* CNvlHie::RTrim(char *pszString)
{
    ULOG_START("CNvlHie::RTrim()");
    
    int iLen;

    iLen=strlen(pszString);

    for(;;)
    {
        if(pszString[iLen-1] != ' ')
            break;

        iLen--;

        if(iLen == 0)
            break;
    }
    pszString[iLen] = 0x00;
    
    ULOG_END("CNvlHie::RTrim()");
	return pszString;
}

int CNvlHie::Insert( char* cidArea,
		             char* cidPessoaDeParaOperadora,
				     char* cLogUser )
{
	ULOG_START("CNvlHie::Insert()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cAuxidOperadoraDepto[21+1];
		char* cAuxidArea = cidArea;
		char* cAuxididPessoaDeParaOperadora  = cidPessoaDeParaOperadora;
	EXEC SQL END DECLARE SECTION;
	
	ZeraOperadoraDepto();
	
	memset( &cAuxidOperadoraDepto, 0, sizeof(cAuxidOperadoraDepto) );
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
	sqlca.sqlcode=0;
	
	//Pega um id unico e sequencia para a insercao
	EXEC SQL
		SELECT C_EMARINS.OPERADORADEPTOSQ.NEXTVAL
		INTO :cAuxidOperadoraDepto
		FROM DUAL;

	EXEC SQL 
		INSERT INTO C_EMARINS.OPERADORADEPTO
		  (IDOPERADORADEPTO, 
		   IDAREA,
		   IDPESSOADEPARAOPERADORA )
		VALUES
		  (:cAuxidOperadoraDepto, 
		   :cAuxidArea,
		   :cAuxididPessoaDeParaOperadora );
	
	ULOG_END("CNvlHie::Insert()");
	if( sqlca.sqlcode == 0 )
		return 1;
	else
		return 0;

GotoInsert:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CNvlHie::Update( char* cidOperadoraDepto, 
				     char* cidArea,
		             char* cidPessoaDeParaOperadora,
				     char* cLogUser )
{
	ULOG_START("CNvlHie::Update()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidOperadoraDepto  = cidOperadoraDepto;
		char* cAuxidArea  = cidArea;
		char* cAuxididPessoaDeParaOperadora  = cidPessoaDeParaOperadora;
	EXEC SQL END DECLARE SECTION;
	
	ZeraOperadoraDepto();
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
	sqlca.sqlcode=0;
	
	EXEC SQL 
		UPDATE C_EMARINS.OPERADORADEPTO
		   SET IDAREA = :cAuxidArea
		   SET IDPESSOADEPARAOPERADORA = :cAuxididPessoaDeParaOperadora
		 WHERE IDOPERADORADEPTO = :cAuxidOperadoraDepto;  
	
	ULOG_END("CNvlHie::Update()");
	if( sqlca.sqlcode == 0 )
		return 1;
	else
		return 0;

GotoUpdate:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CNvlHie::ListId( char* cid )
{
	ULOG_START("CNvlHie::ListId()");
	
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidOra = cid;
		struct
		{
			VARCHAR stidOperadoraDepto[21+1];
			VARCHAR stidArea[255+1];
			VARCHAR stidPessoaDeParaOperadora[255+1];
		} stOperadoraDepto;
		struct
		{
			short iidOperadoraDepto;
			short iidArea;
			short iidPessoaDeParaOperadora;
		} stOperadoraDeptoInd;
	EXEC SQL END DECLARE SECTION;

	ZeraOperadoraDepto();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
	sqlca.sqlcode=0;

   	EXEC SQL DECLARE CursorOperadoraDeptoListId CURSOR FOR
		SELECT IDOPERADORADEPTO, 
		       IDAREA,
		       IDPESSOADEPARAOPERADORA,
		  FROM C_EMARINS.OPERADORADEPTO
		 WHERE IDOPERADORADEPTO = :cidOra;

	EXEC SQL OPEN CursorOperadoraDeptoListId;

	if(sqlca.sqlcode)
	{
	    ULOG_END("CNvlHie::ListId()");
		return 0;
	}
	else
	{
		for(;;)
		{
			memset( &stOperadoraDepto, 0, sizeof(stOperadoraDepto) );
			EXEC SQL FETCH CursorOperadoraDeptoListId INTO :stOperadoraDepto:stOperadoraDeptoInd;

			Add( (char*)stOperadoraDepto.stidOperadoraDepto.arr, 
			     (char*)stOperadoraDepto.stidArea.arr,
			     (char*)stOperadoraDepto.stidPessoaDeParaOperadora.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorOperadoraDeptoListId;
	}
    ULOG_END("CNvlHie::ListId()");
	return iCont;

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CNvlHie::ListAll( void )
{
	ULOG_START("CNvlHie::ListAll()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidOperadoraDepto[21+1];
			VARCHAR stidArea[255+1];
			VARCHAR stidPessoaDeParaOperadora[255+1];
		} stOperadoraDepto;
		struct
		{
			short iidOperadoraDepto;
			short iidArea;
			short iidPessoaDeParaOperadora;
		} stOperadoraDeptoInd;
	EXEC SQL END DECLARE SECTION;

	ZeraOperadoraDepto();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
	sqlca.sqlcode=0;

   	EXEC SQL DECLARE CursorOperadoraDeptoListAll CURSOR FOR
		SELECT IDOPERADORADEPTO, 
		       IDAREA,
		       IDPESSOADEPARAOPERADORA
		  FROM C_EMARINS.OPERADORADEPTO;

	EXEC SQL OPEN CursorOperadoraDeptoListAll;

	if(sqlca.sqlcode)
	{
	    ULOG_END("CNvlHie::ListAll()");
		return 0;
	}
	else
	{
		for(;;)
		{
			memset( &stOperadoraDepto, 0, sizeof(stOperadoraDepto) );
			EXEC SQL FETCH CursorOperadoraDeptoListAll INTO :stOperadoraDepto:stOperadoraDeptoInd;

			Add( (char*)stOperadoraDepto.stidOperadoraDepto.arr, 
			     (char*)stOperadoraDepto.stidArea.arr,
			     (char*)stOperadoraDepto.stidPessoaDeParaOperadora.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorOperadoraDeptoListAll;
	}

	ULOG_END("CNvlHie::ListAll()");
	return iCont;

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CNvlHie::GetXml( char* cNomeTag, XMLGen*xml )
{
	ULOG_START("CNvlHie::GetXml()");
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			xml->addProp(	"xmlns", "usuario.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{
				xml->addItem("idOperadoraDepto", Registro(x)->cidOperadoraDepto );
				xml->addItem("idArea", Registro(x)->cidArea );
				xml->addItem("idPessoaDeParaOperadora", Registro(x)->cidPessoaDeParaOperadora );
			}
			xml->closeTag();
		}
	}
	ULOG_END("CNvlHie::GetXml()");
}
