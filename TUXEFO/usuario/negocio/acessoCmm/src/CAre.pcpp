#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "CAre.h"

CAre::CAre()
{
}

CAre::~CAre()
{
}

char* CAre::RTrim(char *pszString)
{
    ULOG_START("CAre::RTrim()");
    
    int iLen;

    iLen=strlen(pszString);

    for(;;)
    {
        if(pszString[iLen-1] != ' ')
            break;

        iLen--;

        if(iLen == 0)
            break;
    }
    pszString[iLen] = 0x00;
	
	ULOG_END("CAre::RTrim()");
	return pszString;
}

int CAre::Insert( char* cnmDepartamento, char* cLogUser )
{
    ULOG_START("CAre::Insert( )");

	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cAuxidArea[21+1];
		char* cAuxnmDepartamento  = cnmDepartamento;
	EXEC SQL END DECLARE SECTION;
	
	try
	{
		ZeraArea();
		
		memset( &cAuxidArea, 0, sizeof(cAuxidArea) );
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
		sqlca.sqlcode=0;
		
		//Pega um id unico e sequencia para a insercao
		EXEC SQL
			SELECT C_EMARINS.AREASQ.NEXTVAL
			INTO :cAuxidArea
			FROM DUAL;
	
		EXEC SQL 
			INSERT INTO C_EMARINS.AREA
			  (IDAREA, 
			   NMDEPARTAMENTO )
			VALUES
			  (:cAuxidArea, 
			   :cAuxidArea );
	}
	catch(...)
	{
		throw;
	}
	
	if( sqlca.sqlcode == 0 )
	{
		 ULOG_END("CAre::Insert(  )");
		return 1;
	}
	else
	{
		 ULOG_END("CAre::Insert(  )");
		return 0;
	}

GotoInsert:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CAre::Update( char* cidArea, 
				  char* cnmDepartamento,
				  char* cLogUser )
{
	ULOG_START("CAre::Update(  )");
	
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidArea  = cidArea;
		char* cAuxnmDepartamento  = cnmDepartamento;
	EXEC SQL END DECLARE SECTION;
	try
	{
		ZeraArea();
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
		sqlca.sqlcode=0;
		
		EXEC SQL 
			UPDATE C_EMARINS.AREA
			   SET NMDEPARTAMENTO = :cAuxnmDepartamento
			 WHERE IDAREA = :cAuxidArea;  
	}
	catch(...)
	{
		throw;
	}
	
	if( sqlca.sqlcode == 0 )
	{
	    ULOG_END("CAre::Update(  )");
		return 1;
	}
	else
	{
		ULOG_END("CAre::Update( )");
		return 0;
	}

GotoUpdate:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CAre::ListId( char* cid )
{
	ULOG_START("CAre::ListId( )");
	
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidOra = cid;
		struct
		{
			VARCHAR stidArea[21+1];
			VARCHAR stnmDepartamento[255+1];
		} stArea;
		struct
		{
			short iidArea;
			short inmDepartamento;
		} stAreaInd;
	EXEC SQL END DECLARE SECTION;
	try
	{
		ZeraArea();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;
	
	   	EXEC SQL DECLARE CursorAreaListId CURSOR FOR
			SELECT IDAREA, 
			       NMDEPARTAMENTO 
			  FROM C_EMARINS.AREA
			 WHERE IDAREA = :cidOra;
	
		EXEC SQL OPEN CursorAreaListId;
	
		if(sqlca.sqlcode)
		{
			ULOG_END("CAre::ListId( )");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stArea, 0, sizeof(stArea) );
				EXEC SQL FETCH CursorAreaListId INTO :stArea:stAreaInd;
	
				Add( (char*)stArea.stidArea.arr, (char*)stArea.stnmDepartamento.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorAreaListId;
		}
	}
	catch(...)
	{
		throw;
	}
    ULOG_END("CAre::ListId( )");
	return iCont;

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CAre::ListAll( void )
{
	ULOG_START("CAre::ListAll(  )");
	
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidArea[21+1];
			VARCHAR stnmDepartamento[255+1];
		} stArea;
		struct
		{
			short iidArea;
			short inmDepartamento;
		} stAreaInd;
	EXEC SQL END DECLARE SECTION;
	try
	{
		ZeraArea();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;
	
	   	EXEC SQL DECLARE CursorAreaListAll CURSOR FOR
			SELECT IDAREA, 
			       NMDEPARTAMENTO 
			  FROM C_EMARINS.AREA;
	
		EXEC SQL OPEN CursorAreaListAll;
	
		if(sqlca.sqlcode)
		{
		    ULOG_END("CAre::ListAll( )");
			return 0;
		}
		else
		{
			for(;;)
			{
				memset( &stArea, 0, sizeof(stArea) );
				EXEC SQL FETCH CursorAreaListAll INTO :stArea:stAreaInd;
	
				Add( (char*)stArea.stidArea.arr, (char*)stArea.stnmDepartamento.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorAreaListAll;
		}
	}
	catch(...)
	{
		throw;
	}

	ULOG_END("CAre::ListAll( )");
	return iCont;

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CAre::GetXml( char* cNomeTag, XMLGen*xml )
{
	ULOG_START("CAre::GetXml(  )");
	
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			xml->addProp(	"xmlns", "usuario.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{
				xml->addItem("idArea"   , Registro(x)->cidArea   );
				xml->addItem("nmDepartamento"   , Registro(x)->cnmDepartamento   );
			}
			xml->closeTag();
		}
	}
	
	ULOG_END("CAre::GetXml( )");
}
