/**
 * @modulo  Workflow
 * @usecase Workflow
 * @author
 * @version $Revision: 1.1.2.1.6.3 $
 * @CVS     $Author: a5114878 $ - $Date: 2013/02/06 12:36:44 $
 **/

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
#include<ctype.h>

#include "../include/cWFAtdPriorizacao.h"
#include "../../../commons/SmallString.h"
#include "../../../commons/queryMacro.h"


void sql_error_WFAtdPriorizacao(sqlca*sqlca);

// Declara as estruturas compatíveis ao ProC.
EXEC SQL BEGIN DECLARE SECTION;
	#include "../include/stWFAtdPriorizacao.h"
EXEC SQL END DECLARE SECTION;


int cWFAtendimentoPriorizacao::proCExcluirWFAtendimentoPriorizacao(st_AtendimentoPriorizacao* dados, st_vlAtendimentoPriorizacao* status)
{

    if ( 0 == dados || 0 == status )
    {
        SetarErro(0,"Ponteiro invalido");
        return 0;
    }

    if ( -1 == status->idAtendimento )
    {
        SetarErro(0,"'idAtendimento' obrigatorio e nao fornecido");
        return -1;
    }

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
		long idAtendimento = dados->idAtendimento;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtdPriorizacao(&sqlca);

	EXEC SQL 
		DELETE
			atendimento.AtendimentoPriorizacao
		WHERE
			idAtendimento = :idAtendimento;

	return 1;
}

int cWFAtendimentoPriorizacao::proCAlterarWFAtendimentoPriorizacao(st_AtendimentoPriorizacao* dados, st_vlAtendimentoPriorizacao* status)
{
    ULOG_START( "cWFAtendimentoPriorizacao::proCAlterarWFAtendimentoPriorizacao()" );

    if ( 0 == dados || 0 == status )
    {
        SetarErro(0,"Ponteiro invalido");
        return 0;
    }

    if ( -1 == status->idAtendimento )
    {
        SetarErro(0,"'idAtendimento' obrigatorio e nao fornecido");
        return -1;
    }

	struct sqlca sqlca;
	SmallString query;

    EXEC SQL BEGIN DECLARE SECTION;

		char *queryDec;

		struct st_AtendimentoPriorizacao oDados;
		struct st_vlAtendimentoPriorizacao oStatus;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtdPriorizacao(&sqlca);

	memcpy(&oDados, dados, sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

	query += "UPDATE atendimento.AtendimentoPriorizacao SET ";

	bool separa = false;

	if (status->dtAtualizacao != -1)
    {
		montarUpdate(query,"dtAtualizacao", oDados.dtAtualizacao, TIPO_DATAHORA);
    }

	if (status->nmCor != -1)
    {
		montarUpdate(query,"nmCor", oDados.nmCor, TIPO_CHAR);
    }

	if (status->idAlerta != -1)
    {
		montarUpdate(query,"idAlerta", oDados.idAlerta, TIPO_INT);
    }
	if (status->nrCriticidade != -1) 
    {
		montarUpdate(query,"nrCriticidade", oDados.nrCriticidade, TIPO_CHAR);
    }

	// if (status->nrTentativas != -1) 
    // {
	// 	montarUpdate(query,"nrTentativas", oDados.nrTentativas, TIPO_CHAR);
    // }


	separa = false;

	montarWhere(query,"idAtendimento", oDados.idAtendimento, WHERE_LONG);

    queryDec = (char*)query;

    ULOG( "QUERY [%s]",query );

	EXEC SQL EXECUTE IMMEDIATE :queryDec;

    ULOG_END( "cWFAtendimentoPriorizacao::proCAlterarWFAtendimentoPriorizacao()" );

	return 1;
}

int cWFAtendimentoPriorizacao::proCIncluirWFAtendimentoPriorizacao(st_AtendimentoPriorizacao* dados, st_vlAtendimentoPriorizacao* status)
{

    if ( 0 == dados || 0 == status )
    {
        SetarErro(0,"Ponteiro invalido");
        return 0;
    }

    if ( -1 == status->idAtendimento )
    {
        SetarErro(0,"'idAtendimento' obrigatorio e nao fornecido");
        return -1;
    }

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        struct st_AtendimentoPriorizacao oDados;
        struct st_vlAtendimentoPriorizacao oStatus;
    EXEC SQL END DECLARE SECTION;

    memcpy(&oDados,  dados,  sizeof(oDados));
    memcpy(&oStatus, status, sizeof(oStatus));

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtdPriorizacao(&sqlca);

	EXEC SQL 
		INSERT INTO
			atendimento.AtendimentoPriorizacao
			(
				dtAtualizacao,
				idAtendimento,
				nmCor,
				nrCriticidade
                // nrTentativas
			)
			VALUES
			(
                DECODE(:oStatus.dtAtualizacao,-1,NULL,TO_DATE(:oDados.dtAtualizacao,'DD/MM/YYYY HH24:MI:SS')),
				:oDados.idAtendimento,
				:oDados.nmCor,
				:oDados.nrCriticidade
				// :oDados.nrTentativas
			);


	return 1;
}

int cWFAtendimentoPriorizacao::proCConsultarWFAtendimentoPriorizacao(st_AtendimentoPriorizacao* dados, st_vlAtendimentoPriorizacao* status, char* order, XMLGen* saida)
{
    ULOG_START( "cWFAtendimentoPriorizacao::proCConsultarWFAtendimentoPriorizacao()" );

    if ( 0 == dados || 0 == status || 0 == saida )
    {
        SetarErro(0,"Ponteiro invalido");
        return 0;
    }

	bool separa = false;
	SmallString query;
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		char *queryDec;

	    long idAtendimento;
        VARCHAR nrCriticidade[16];

	    VARCHAR dtAtualizacao[24];
        VARCHAR nmCor[256];
	    // VARCHAR nrTentativas[16];


	    short i_dtAtualizacao;
        short i_nmCor;
	    short i_idAtendimento;
        short i_nrCriticidade;
        // short i_nrTentativas;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtdPriorizacao(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

    query = "SELECT TO_CHAR(dtAtualizacao,'dd/mm/yyyy hh24:mi'), "
                   "nmCor, "
                   "idAtendimento, "
                   "nrCriticidade, "
                   // "nrTentativas "
            "FROM atendimento.AtendimentoPriorizacao ";

	if (status->dtAtualizacao != -1)
    {
		montarWhere(query,"dtAtualizacao", dados->dtAtualizacao, WHERE_DATAHORA);
    }

	if (status->nmCor != -1) 
    {
		montarWhere(query,"nmCor", dados->nmCor, WHERE_CHAR);
    }

	if (status->idAtendimento != -1) 
    {
		montarWhere(query,"idAtendimento", dados->idAtendimento, WHERE_INT);
    }

	if (status->nrCriticidade != -1) 
    {
		montarWhere(query,"nrCriticidade", dados->nrCriticidade, WHERE_CHAR);
    }

	// if (status->nrTentativas != -1) 
    // {
	// 	montarWhere(query,"nrTentativas", dados->nrTentativas, WHERE_CHAR);
    // }


	if ( order && strlen(order) ) 
    {
		query += " ORDER BY ";
        query +=  order;
    }

    queryDec = (char*)query;

    ULOG( "QUERY [%s]",query );

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtdPriorizacao(&sqlca);

	EXEC SQL PREPARE consultaAtdPriorizacao FROM :queryDec;
	EXEC SQL DECLARE cursorAtdPriorizacao CURSOR FOR consultaAtdPriorizacao;

	EXEC SQL OPEN cursorAtdPriorizacao;

	saida->createTag("WFConsultaAtendimentoPriorizacaoVO");

	while (true)
	{
		EXEC SQL FETCH cursorAtdPriorizacao INTO 
                                    :dtAtualizacao:i_dtAtualizacao, 
                                    :nmCor:i_nmCor, 
                                    :idAtendimento:i_idAtendimento, 
									:nrCriticidade:i_nrCriticidade;
                                    // :nrTentativas:i_nrTentativas;

		CONVIND(nmCor,i_nmCor);
		CONVIND(dtAtualizacao,i_dtAtualizacao);
        CONVIND(nrCriticidade,i_nrCriticidade);
        // CONVIND(nrTentativas,i_nrTentativas)

		saida->createTag("WFAtendimentoPriorizacaoVO");
			saida->addItem("idAtendimento", idAtendimento);
			saida->addItem("dtAtualizacao", (char *)dtAtualizacao.arr);
			saida->addItem("nmCor", (char *)nmCor.arr);
			saida->addItem("nrCriticidade", (char*) nrCriticidade.arr);
			// saida->addItem("nrTentativas", (char*) nrTentativas.arr);
			saida->addItem("nrTentativas","");
		saida->closeTag();
	}

	saida->closeTag();

	EXEC SQL CLOSE cursorAtdPriorizacao;

    ULOG_END( "cWFAtendimentoPriorizacao::proCConsultarWFAtendimentoPriorizacao()" );

	return 1;
}

void sql_error_WFAtdPriorizacao( sqlca * sqlca )
{
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

    ULOGE("sql_error_WFAtdPriorizacao:sqlcode=%d,sqlerrmc=%.70s"
                            ,sqlca->sqlcode
                            ,sqlca->sqlerrm.sqlerrmc);

    throw new TuxBasicOraException(sqlca->sqlcode
                                  ,sqlca->sqlerrm.sqlerrmc
                                  ,sqlca->sqlerrm.sqlerrml);
}






