#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#define montaUpdate(dado, valor, tipo) \
{\
	if (separa) \
		sprintf(query,"%s ,", query); \
	if (tipo == 1) \
		sprintf(query, "%s %s = %i ", query, dado, valor); \
	else \
		sprintf(query, "%s %s = '%s' ", query, dado, valor); \
	separa = true; \
}

#define montaWhere(dado, valor, tipo) \
{\
	if (!separa) \
		sprintf(query,"%s WHERE ", query); \
	if (separa) \
		sprintf(query,"%s AND ", query); \
	if (tipo == 1) \
		sprintf(query, "%s %s = %i ", query, dado, valor); \
	else \
		sprintf(query, "%s %s LIKE '%s' ", query, dado, valor); \
	separa = true; \
}

#define CONV(O) \
{\
	##O.arr[##O.len]=0; \
}

#include <tuxfw.h>
#include "../include/cWFAgrupamentoEstado.h"
#include "../include/stWFAgrupamentoEstado.h"

void sql_error_WFAgrupamentoEstado(sqlca*sqlca);

	// Declara as estruturas compatíveis ao ProC.
    EXEC SQL BEGIN DECLARE SECTION;
		#include "../include/stWFAgrupamentoEstado.h"
    EXEC SQL END DECLARE SECTION;

bool proCIncluirWFAgrupamentoEstado(st_WFAgrupamentoEstado* dados, st_vlWFAgrupamentoEstado* status, XMLGen* saida)
{
   ULOG_START("proCIncluirWFAgrupamentoEstado()");
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_WFAgrupamentoEstado   oDados;
		struct st_vlWFAgrupamentoEstado oStatus;

	EXEC SQL END DECLARE SECTION;

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAgrupamentoEstado(&sqlca);

	// Obtem o valor do idEstado
	EXEC SQL SELECT workflow.AgrupamentoEstadosQ.NEXTVAL INTO :oDados.idAgrupamentoEstado FROM DUAL;

	EXEC SQL 
		INSERT INTO
			workflow.AgrupamentoEstado
			(
				idAgrupamentoEstado,
				idEstado,
				idSubEstado
			)
			VALUES
			(
				:oDados.idAgrupamentoEstado,
				:oDados.idEstado,
				:oDados.idSubEstado
			);

	saida->createTag("Registro");
		saida->addItem("idAgrupamentoEstado", oDados.idAgrupamentoEstado);
	saida->closeTag();
	
   ULOG_END("proCIncluirWFAgrupamentoEstado()");
   
	return true;
}

bool proCAlterarWFAgrupamentoEstado(st_WFAgrupamentoEstado* dados, st_vlWFAgrupamentoEstado* status, XMLGen* saida)
{
   ULOG_START("proCAlterarWFAgrupamentoEstado()");
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_WFAgrupamentoEstado   oDados;
		struct st_vlWFAgrupamentoEstado oStatus;

		char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAgrupamentoEstado(&sqlca);

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

	sprintf(query,"%s", "UPDATE workflow.AgrupamentoEstado SET ");

	bool separa = false;

	if (status->idEstado != -1) 
		montaUpdate("idEstado", oDados.idEstado, 1);

	if (status->idSubEstado != -1)
		montaUpdate("idSubEstado", oDados.idSubEstado, 1);

	sprintf(query, "%s WHERE idAgrupamentoEstado = %i", query, dados->idAgrupamentoEstado);

	EXEC SQL EXECUTE IMMEDIATE :query;
	
	ULOG_END("proCAlterarWFAgrupamentoEstado()");

	return true;
}

bool proCExcluirWFAgrupamentoEstado(st_WFAgrupamentoEstado* dados, st_vlWFAgrupamentoEstado* status, XMLGen* saida)
{
   ULOG_START("proCExcluirWFAgrupamentoEstado()");
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idAgrupamentoEstado = dados->idAgrupamentoEstado;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAgrupamentoEstado(&sqlca);

	EXEC SQL 
		DELETE
			workflow.AgrupamentoEstado
		WHERE
			idAgrupamentoEstado = :idAgrupamentoEstado;
			
   ULOG_END("proCExcluirWFAgrupamentoEstado()");
	return true;
}

bool proCConsultaWFAgrupamentoEstado(st_WFAgrupamentoEstado* dados, st_vlWFAgrupamentoEstado* status, char* order, XMLGen* saida)
{
   ULOG_START("proCConsultaWFAgrupamentoEstado()");
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idAgrupamentoEstado;
		int idEstado;
		int idSubEstado;

		char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAgrupamentoEstado(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	strcpy(query,"SELECT idAgrupamentoEstado, idEstado, idSubEstado FROM workflow.AgrupamentoEstado ");

	bool separa = false;

	if (status->idAgrupamentoEstado != -1) 
		montaWhere("idAgrupamentoEstado", dados->idAgrupamentoEstado, 1);

	if (status->idEstado != -1) 
		montaWhere("idEstado", dados->idEstado, 1);

	if (status->idSubEstado != -1)
		montaWhere("idSubEstado", dados->idSubEstado, 2);

	if (strlen(order) > 0) 
		sprintf( query, "%s ORDER BY %s ", query, order);

	EXEC SQL PREPARE consultaAgrupamentoEstado FROM :query;
	EXEC SQL DECLARE consulta CURSOR FOR consultaAgrupamentoEstado;

	EXEC SQL OPEN consulta;

	while (true)
	{
		EXEC SQL FETCH consulta INTO idAgrupamentoEstado, idEstado, idSubEstado;

		saida->createTag("resultado");
			saida->addItem("idAgrupamentoEstado", idAgrupamentoEstado);
			saida->addItem("idEstado", idEstado);
			saida->addItem("idSubEstado", idSubEstado);
		saida->closeTag();
	}

	EXEC SQL CLOSE consulta;
	
	ULOG_END("proCConsultaWFAgrupamentoEstado()");

	return true;

}

bool proCConsultaWFAgrupamentoEstadoDetalhado(st_WFAgrupamentoEstado* dados, st_vlWFAgrupamentoEstado* status, char* order, XMLGen* saida)
{
   
   ULOG_START("proCConsultaWFAgrupamentoEstadoDetalhado()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idAgrupamentoEstado;
		int idEstado;
		int idSubEstado;

		VARCHAR sgEstado[256];
		VARCHAR dsEstado[256];

		VARCHAR sgSubEstado[256];
		VARCHAR dsSubEstado[256];
		
		char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAgrupamentoEstado(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;


	strcpy(query,"SELECT AE.idAgrupamentoEstado, "
				 "AE.idEstado,"				 
				 "E.sgEstado, "
			     "E.dsEstado," 
				 "AE.idSubEstado, "
				 "SE.sgSubEstado," 
				 "SE.dsSubEstado "
				 "FROM workflow.AgrupamentoEstado AE,"
				 "workflow.ESTADO			E,"
				 "WORKFLOW.SUBESTADO			SE"
				 "WHERE AE.IDESTADO=E.IDESTADO"
				 "AND   AE.IDSUBESTADO=SE.IDSUBESTADO");

bool separa = false;

	if (status->idAgrupamentoEstado != -1) 
		montaWhere("AE.idAgrupamentoEstado", dados->idAgrupamentoEstado, 1);

	if (status->idEstado != -1) 
		montaWhere("AE.idEstado", dados->idEstado, 1);

	if (status->idSubEstado != -1)
		montaWhere("AE.idSubEstado", dados->idSubEstado, 1);

	if (strlen(order) > 0) 
		sprintf( query, "%s ORDER BY %s ", query, order);

	EXEC SQL PREPARE consultaAgrupamentoEstadoDetalhada FROM :query;
	EXEC SQL DECLARE consultaDetalhada CURSOR FOR consultaAgrupamentoEstadoDetalhada;

	EXEC SQL OPEN consultaDetalhada;

	while (true)
	{
		EXEC SQL FETCH 
			consultaDetalhada 
		INTO 
			idAgrupamentoEstado, 
			idEstado, 
			sgEstado,
			dsEstado,
			idSubEstado,
			sgSubEstado,
			dsSubEstado;

		CONV(sgEstado);
		CONV(dsEstado);
		CONV(sgSubEstado);
		CONV(dsSubEstado);

		saida->createTag("WFAgrupamentoEstadoVO");
			saida->addItem("idAgrupamentoEstado", idAgrupamentoEstado);
			saida->addItem("idEstado", idEstado);
			saida->addItem("sgEstado", (char*)sgEstado.arr);
			saida->addItem("dsEstado", (char*)dsEstado.arr);
			saida->addItem("idSubEstado", idSubEstado);
			saida->addItem("sgSubEstado", (char*)sgSubEstado.arr);
			saida->addItem("dsSubEstado", (char*)dsSubEstado.arr);
		saida->closeTag();
	}

	EXEC SQL CLOSE consultaDetalhada;
	
   ULOG_END("proCConsultaWFAgrupamentoEstadoDetalhado()");
   
	return true;

}

void sql_error_WFAgrupamentoEstado(sqlca*sqlca)
{
	throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
