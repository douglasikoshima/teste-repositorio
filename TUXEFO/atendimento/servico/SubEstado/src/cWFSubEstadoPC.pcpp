#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#define montaUpdate(dado, valor, tipo) \
{\
	if (separa) \
		sprintf(query,"%s ,", query); \
	if (tipo == 1) \
		sprintf(query, "%s %s = %i ", query, dado, valor); \
	else \
		sprintf(query, "%s %s = '%s' ", query, dado, valor); \
	separa = true; \
}

#define montaWhere(dado, valor, tipo) \
{\
	if (!separa) \
		sprintf(query,"%s WHERE ", query); \
	if (separa) \
		sprintf(query,"%s AND ", query); \
	if (tipo == 1) \
		sprintf(query, "%s %s = %i ", query, dado, valor); \
	else if (tipo == 2) \
		sprintf(query, "%s %s LIKE '%s' ", query, dado, valor); \
	else if (tipo == 3) \
		sprintf(query, "%s %s NOT LIKE '%s' ", query, dado, valor); \
	separa = true; \
}

#define CONV(O) \
{\
	##O.arr[##O.len]=0; \
}

#include "../include/cWFSubEstado.h"
#include "../include/stWFSubEstado.h"

void sql_error_WFSubEstado(sqlca*sqlca);

	// Declara as estruturas compatíveis ao ProC.
    EXEC SQL BEGIN DECLARE SECTION;
		#include "../include/stWFSubEstado.h"
    EXEC SQL END DECLARE SECTION;

bool proCIncluirWFSubEstado(st_WFSubEstado* dados, st_vlWFSubEstado* status, XMLGen* saida)
{
   ULOG_START("proCIncluirWFSubEstado()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_WFSubEstado   oDados;
		struct st_vlWFSubEstado oStatus;

	EXEC SQL END DECLARE SECTION;

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFSubEstado(&sqlca);

	// Obtem o valor do idSubEstado
	EXEC SQL SELECT workflow.SubEstadosQ.NEXTVAL INTO :oDados.idSubEstado FROM DUAL;

	EXEC SQL 
		INSERT INTO
			workflow.SubEstado
			(
				idSubEstado,
				sgSubEstado,
				dsSubEstado
			)
			VALUES
			(
				:oDados.idSubEstado,
				DECODE(:oStatus.sgSubEstado, -1, NULL, :oDados.sgSubEstado),
				DECODE(:oStatus.dsSubEstado, -1, NULL, :oDados.dsSubEstado)
			);

	saida->createTag("Registro");
		saida->addItem("idSubEstado", oDados.idSubEstado);
	saida->closeTag();
	
	ULOG_END("proCIncluirWFSubEstado()");

	return true;
}

bool proCAlterarWFSubEstado(st_WFSubEstado* dados, st_vlWFSubEstado* status, XMLGen* saida)
{
   ULOG_START("proCAlterarWFSubEstado()");
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_WFSubEstado   oDados;
		struct st_vlWFSubEstado oStatus;

		char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFSubEstado(&sqlca);

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

	sprintf(query,"%s", "UPDATE workflow.SubEstado SET ");

	bool separa = false;

	if (status->sgSubEstado != -1) 
		montaUpdate("sgSubEstado", oDados.sgSubEstado, 2);

	if (status->dsSubEstado != -1)
		montaUpdate("dsSubEstado", oDados.dsSubEstado, 2);

	sprintf(query, "%s WHERE idSubEstado = %i", query, dados->idSubEstado);

	EXEC SQL EXECUTE IMMEDIATE :query;

   ULOG_END("proCAlterarWFSubEstado()");
   
	return true;
}

bool proCExcluirWFSubEstado(st_WFSubEstado* dados, st_vlWFSubEstado* status, XMLGen* saida)
{
   ULOG_START("proCExcluirWFSubEstado()");
   
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idSubEstado = dados->idSubEstado;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFSubEstado(&sqlca);

	EXEC SQL 
		DELETE
			workflow.SubEstado
		WHERE
			idSubEstado = :idSubEstado;
			
	ULOG_END("proCExcluirWFSubEstado()");

	return true;
}

bool proCConsultaWFSubEstado(st_WFSubEstado* dados, st_vlWFSubEstado* status, char* order, XMLGen* saida)
{
   ULOG_START("proCConsultaWFSubEstado()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idSubEstado;
		VARCHAR sgSubEstado[256];
		VARCHAR dsSubEstado[256];

		char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFSubEstado(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	strcpy(query,"SELECT idSubEstado, sgSubEstado, dsSubEstado FROM workflow.SubEstado ");

	bool separa = false;

	if (status->idSubEstado != -1) 
		montaWhere("idSubEstado", dados->idSubEstado, 1);

	if (status->sgSubEstado != -1) 
		montaWhere("sgSubEstado", dados->sgSubEstado, 2);

	if (status->dsSubEstado != -1)
		montaWhere("dsSubEstado", dados->dsSubEstado, 2);

	montaWhere("dsSubEstado", "RCSE%", 3);

	if (strlen(order) > 0) 
		sprintf( query, "%s ORDER BY %s ", query, order);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFSubEstado(&sqlca);

	EXEC SQL PREPARE consultaSubEstado FROM :query;
	EXEC SQL DECLARE consulta CURSOR FOR consultaSubEstado;

	EXEC SQL OPEN consulta;

	while (true)
	{
		EXEC SQL FETCH consulta INTO :idSubEstado, :sgSubEstado, :dsSubEstado;

		CONV(sgSubEstado);
		CONV(dsSubEstado);

		saida->createTag("SubEstadoVO");
			saida->addItem("idSubEstado", idSubEstado);
			saida->addItem("sgSubEstado", (char *)sgSubEstado.arr);
			saida->addItem("dsSubEstado", (char *)dsSubEstado.arr);
		saida->closeTag();
	}

	EXEC SQL CLOSE consulta;
	
	ULOG_END("proCConsultaWFSubEstado()");

	return true;

}

bool proCConsultaWFSubEstadoEstado(int idEstado, XMLGen* saida)
{
   ULOG_START("proCConsultaWFSubEstadoEstado()");
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idestado = idEstado;
		int idSubEstado;

		VARCHAR sgSubEstado[256];
		VARCHAR dsSubEstado[256];

		short i_sgSubEstado;
		short i_dsSubEstado;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFSubEstado(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

  
	EXEC SQL DECLARE consultaEstado CURSOR FOR
        SELECT 
	          SE.IDSUBESTADO, 
	          SE.SGSUBESTADO, 
	          SE.DSSUBESTADO 
          FROM 
              WORKFLOW.ESTADO E,
              WORKFLOW.SUBESTADO SE,
	          WORKFLOW.AGRUPAMENTOESTADO AE
        WHERE AE.IDESTADO = :idestado
          AND AE.IDESTADO = E.IDESTADO
          AND AE.IDSUBESTADO = SE.IDSUBESTADO
          AND E.SGESTADO NOT LIKE 'RCE%';

	EXEC SQL OPEN consultaEstado;

	saida->createTag("WFSubEstados");

	while (true)
	{
		EXEC SQL FETCH 
			consultaEstado
		INTO 
			idSubEstado, 
			sgSubEstado:i_sgSubEstado,
			dsSubEstado:i_dsSubEstado;

		CONV(sgSubEstado);
		CONV(dsSubEstado);

		saida->createTag("WFSubEstadoVO");
			saida->addItem("idSubEstado", idSubEstado);
			saida->addItem("sgSubEstado", (char*)sgSubEstado.arr);
			saida->addItem("dsSubEstado", (char*)dsSubEstado.arr);
		saida->closeTag();
	}

	saida->closeTag();

	EXEC SQL CLOSE consultaEstado;
	
	ULOG_END("proCConsultaWFSubEstadoEstado()");

	return true;

}

void sql_error_WFSubEstado(sqlca*sqlca)
{
	throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
