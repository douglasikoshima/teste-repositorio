/**
 * 
 * @modulo  Workflow
 * @usecase Workflow
 * @author  Cassio M Garcia
 * @version $Revision: 1.1 $
 * @CVS     $Author: a5110702 $ - $Date: 2009/07/31 15:34:18 $
 **/

#undef SQLCA
#define SQLCA_NONE
#include <sqlca.h>
#include <sqlda.h>

#include "../../../commons/queryMacro.h"
#include "../../../commons/msgPadrao.h"

#include "../../AtendimentoCommonsRel/include/cWFComunsRelatorios.h"
#include "../include/cWFAtendimentoRel6EDet.h"

// Declara as estruturas compatíveis ao ProC.
EXEC SQL BEGIN DECLARE SECTION;
#define MAXCOLUNAS 3
EXEC SQL END DECLARE SECTION;

void MontarQuebra(string &nmColuna);

int proCObterQtdeRegsRel6eDet( st_AtendimentoRel *dados
                             , st_vlAtendimentoRel *status
                             , DOMNode *dnode )
{
    char valor[32];
    struct sqlca sqlca;
    string idColunas;
    string where;
    bool fim = false;

    if ( !dados )
    {
        ULOGE("%s",erroPonteiroInvalido());
        throw new TuxBasicSvcException("04E9999",erroPonteiroInvalido());
    }

    if ( !status )
    {
        ULOGE("%s",erroPonteiroInvalido());
        throw new TuxBasicSvcException("04E9999",erroPonteiroInvalido());
    }

    if ( !dnode )
    {
        ULOGE("%s",erroPonteiroInvalido());
        throw new TuxBasicSvcException("04E9999",erroPonteiroInvalido());
    }

    // Gera os filtros
    if( -1 != status->idUF )
    {
        sprintf(valor,"%d",dados->idUF);
        if (where.size()) where += " AND ";
        where += " idUFOperadora=" + (string)valor;
    }

    if( -1 != status->idGrupo )
    {
        sprintf(valor,"%d",dados->idGrupo);
        if (where.size()) where += " AND ";
        where += " idGrupo=" + (string)valor;
    }

    if( -1 != status->idRepresentante )
    {
        sprintf(valor,"%d",dados->idRepresentante);
        if (where.size()) where += " AND ";
        where += " idPessoaUsuario=" + (string)valor;
    }

    if( -1 != status->dtInicio )
    {
        if (where.size()) where += " AND ";
        where += " dtBaixa >= TO_DATE('" + (string)dados->dtInicio + "','DD-MM-YYYY')";
    }

    if( -1 != status->dtFim )
    {
        if (where.size()) where += " AND ";
        where += " dtBaixa <= TO_DATE('" + (string)dados->dtFim + "','DD-MM-YYYY')";
    }

    WFAtdRelCompletarWhere(where,dnode,"WFGrupoVO");
    WFAtdRelCompletarWhere(where,dnode,"WFEstadoVO");
    WFAtdRelCompletarWhere(where,dnode,"FiltroDetalhe");

    idColunas = "SELECT COUNT(1) "
                "FROM atendimento.TempoMedioTratRepreDetV01";

    if ( where.size() )
    {
        idColunas += " WHERE " + where;
    }

    if ( !idColunas.size() )
    {
        ULOGE(mensagemSimples("Query vazia"));
        throw new TuxBasicSvcException("04E9999",mensagemSimples("Query vazia"));
    }

    EXEC SQL BEGIN DECLARE SECTION;
        char *query;
        int totalRegs = 0;
        short itotalRegs = -1;
    EXEC SQL END DECLARE SECTION;

    query = (char*)idColunas.c_str();

    ULOG( "QUERY= [%s]",query );

    EXEC SQL WHENEVER SQLERROR DO WFAtdRelSqlErro(&sqlca);
    EXEC SQL PREPARE queryNumRegs FROM :query;
    EXEC SQL DECLARE cursorNumRegs CURSOR FOR queryNumRegs;

    EXEC SQL OPEN cursorNumRegs;

    EXEC SQL FETCH cursorNumRegs INTO :totalRegs:itotalRegs;

    EXEC SQL CLOSE cursorNumRegs;

    return totalRegs;
}

bool proCExecutarRelatorio6EDet( st_AtendimentoRel *dados
                               , st_vlAtendimentoRel *status
                               , XMLGen *saida
                               , DOMNode *dnode )
{
    char valor[32];
    struct sqlca sqlca;
    string idColunas;
    string where;
    string group;
    string nmColuna;
    int i;

    if ( !dados )
    {
        ULOGE("%s",erroPonteiroInvalido());
        throw new TuxBasicSvcException("04E9999",erroPonteiroInvalido());
    }

    if ( !status )
    {
        ULOGE("%s",erroPonteiroInvalido());
        throw new TuxBasicSvcException("04E9999",erroPonteiroInvalido());
    }

    if ( !saida )
    {
        ULOGE("%s",erroPonteiroInvalido());
        throw new TuxBasicSvcException("04E9999",erroPonteiroInvalido());
    }

    if ( !dnode )
    {
        ULOGE("%s",erroPonteiroInvalido());
        throw new TuxBasicSvcException("04E9999",erroPonteiroInvalido());
    }

    // Gera os filtros
    if( -1 != status->idOperadora )
    {
        sprintf(valor,"%d",dados->idOperadora);
        if (where.size()) where += " AND ";
        where += " idOperadora=" + (string)valor;
    }

    if( -1 != status->idUF )
    {
        sprintf(valor,"%d",dados->idUF);
        if (where.size()) where += " AND ";
        where += " idUFOperadora=" + (string)valor;
    }

    if( -1 != status->idGrupo )
    {
        sprintf(valor,"%d",dados->idGrupo);
        if (where.size()) where += " AND ";
        where += " idGrupo=" + (string)valor;
    }

    if( -1 != status->idRepresentante )
    {
        sprintf(valor,"%d",dados->idRepresentante);
        if (where.size()) where += " AND ";
        where += " idPessoaUsuario=" + (string)valor;
    }

    if( -1 != status->dtInicio )
    {
        if (where.size()) where += " AND ";
        where += " TRUNC(dtBaixa) >= TO_DATE('" + (string)dados->dtInicio + "','DD-MM-YYYY')";
    }

    if( -1 != status->dtFim )
    {
        if (where.size()) where += " AND ";
        where += " TRUNC(dtBaixa) <= TO_DATE('" + (string)dados->dtFim + "','DD-MM-YYYY')";
    }

    if( -1 != status->idAtendimento )
    {
        sprintf(valor,"%d",dados->idAtendimento);
        if (where.size()) where += " AND ";
        where += " idAtendimento=" + (string)valor;
    }

    WFAtdRelCompletarWhere(where,dnode,"WFGrupoVO");
    WFAtdRelCompletarWhere(where,dnode,"WFEstadoVO");
    WFAtdRelCompletarWhereDetalhe(where,dnode,"FiltroDetalhe");
   
    MontarQuebra(nmColuna);

    idColunas = "SELECT distinct nmPath,dsEstado,dsSubEstado "
                  "FROM (SELECT ROWNUM as nLin,nmPath,dsEstado,dsSubEstado "
                          "FROM (SELECT nmPath,dsEstado,dsSubEstado FROM atendimento.TempoMedioTratRepreV01";

    if ( where.size() )
    {
        idColunas += " WHERE " + where;
    }

    idColunas += " ORDER BY nmPath,dsEstado,dsSubEstado";

    char linIni[32],linFin[32];
    sprintf(linIni,"%d",dados->bloco * dados->qtdLinhasBloco + 1);
    sprintf(linFin,"%d",(dados->bloco+1) * dados->qtdLinhasBloco + 1); //+1 aqui é necessário para controle de fim de relatório

    idColunas += ")) WHERE nLin >= " + (string)linIni + " AND nLin <= " + (string)linFin;

    EXEC SQL BEGIN DECLARE SECTION;
        char *query;
        short i_colunas[MAXCOLUNAS];
        VARCHAR colunas[MAXCOLUNAS][256];
    EXEC SQL END DECLARE SECTION;

    query = (char*)idColunas.c_str();

    ULOG( "QUERY = [%s]",query );

    saida->createTag("WFRelatorioDinamicoVO");
    saida->addProp("xmlns","workflow.fo.vivo.com.br/vo");
    saida->addItem("dsTituloRelatorio","Detalhe de Tempo Médio de Tratamento do Processo");

    WFAtdRelGerarHeaderSaidaXML(nmColuna,saida,dnode);
    
    for ( i=0; i<MAXCOLUNAS;i++ )
    {
        colunas[i].arr[0] = 0;
        colunas[i].len = 0;
    }

    EXEC SQL WHENEVER SQLERROR DO WFAtdRelSqlErro(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL PREPARE recebeQuery FROM :query;
    EXEC SQL DECLARE consulta CURSOR FOR recebeQuery;

    EXEC SQL OPEN consulta;

    int nRegs = 0;

    while ( true ) 
    {
        nRegs++;

        EXEC SQL FETCH consulta INTO :colunas[ 0]:i_colunas[ 0],
                                     :colunas[ 1]:i_colunas[ 1],
                                     :colunas[ 2]:i_colunas[ 2];

        if ( nRegs > dados->qtdLinhasBloco )
        {
            break;
        }

        saida->createTag("ValoresRelatorio");

        for ( i=0;i<MAXCOLUNAS;i++ )
        {
            CONVIND(colunas[i],i_colunas[i]);
            WFAtdRelGerarDadosSaidaXML((VARCHAR*)&colunas[i],saida);
        }

        saida->closeTag();
    }

    saida->addItem("inFin", sqlca.sqlcode == 1403 ? true:false);

    saida->closeTag();

    EXEC SQL CLOSE consulta;

    return true;
}

void MontarQuebra(string &nmColuna)
{
    nmColuna += obterNomeColunaFixa(ID_PATH);
    nmColuna += ",";
    nmColuna += obterNomeColunaFixa(ID_ESTADO_PROCESSO);
    nmColuna += ",";
    nmColuna += obterNomeColunaFixa(ID_SUBEST_PROCESSO);

    ULOG( "colunas fixas=%s",nmColuna.c_str() );
}
