#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"
#include "../../../commons/msgPadrao.h"

#include <tuxfw.h>
#include "../include/cWFAtendimentoAndamentoAtual.h"
#include "../include/stWFAtendimentoAndamentoAtual.h"

void sql_error_WFAtendimentoAndamentoAtual(sqlca*sqlca);

    // Declara as estruturas compatíveis ao ProC.
    EXEC SQL BEGIN DECLARE SECTION;
        #include "../include/stWFAtendimentoAndamentoAtual.h"
    EXEC SQL END DECLARE SECTION;

long proCIncluirWFAtendimentoAndamentoAtual(st_AtendimentoAndamentoAtual* dados, st_vlAtendimentoAndamentoAtual* status)
{
    ULOG_START( "proCIncluirWFAtendimentoAndamentoAtual()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        struct st_AtendimentoAndamentoAtual   *oDados = dados;
        struct st_vlAtendimentoAndamentoAtual *oStatus = status;
        int numRegs;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoAndamentoAtual(&sqlca);

    // ==> Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
    // EXEC SQL 
    //     INSERT INTO
    //         atendimento.AtendimentoAndamentoAtual
    //         (
    //             idAtendimento,
    //             idAndamento,
    //             idUsuarioAlteracao,
    //             dtUltimaAlteracao
    //         )
    //         VALUES
    //         (
    //             :oDados->idAtendimento,
    //             :oDados->idAndamento,
    //             DECODE(:oStatus->idUsuarioAlteracao, -1, NULL, :oDados->idUsuarioAlteracao),
    //             //@cassio DECODE(:oStatus->dtUltimaAlteracao, -1, NULL, TO_DATE(:oDados->dtUltimaAlteracao,'DD/MM/YYYY HH24:MI:SS'))
    //             TO_DATE(DECODE(:oStatus->dtUltimaAlteracao, -1, NULL, :oDados->dtUltimaAlteracao),'DD/MM/YYYY HH24:MI:SS')
    //         );

    // Versão piloto. Nesta versão devido a data de entrega muito próxima
    // estou apenas atualizando os campos novos que foram desnormalizados
    // junto com as tabelas respectivas para em uma segunda versão, com mais
    // tempo poder criar métodos especificos e mais rápidos para a atualização
    // destes campos em objetos respectivos às tabelas sendo atualizadas.
    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTO
        SET
            IDANDAMENTOATUAL = :oDados->idAndamento,
            IDAGRUPAMENTOESTADOTPPROC = :oDados->idAgrupamentoEstadoTpProc,
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :oDados->idAtendimento;

    EXEC SQL 
        SELECT 
            COUNT(1)
        INTO
            :numRegs
        FROM
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        WHERE
            IDATENDIMENTO = :oDados->idAtendimento;

    if ( numRegs )
    {
        EXEC SQL
            UPDATE
                ATENDIMENTO.ATENDIMENTOPRIORIZACAO
            SET
                IDANDAMENTOATUAL = :oDados->idAndamento,
                IDAGRUPAMENTOESTADOTPPROC = :oDados->idAgrupamentoEstadoTpProc,
                DTULTIMAALTERACAO = SYSDATE
            WHERE
                IDATENDIMENTO = :oDados->idAtendimento;
    }
    // <== Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio

    ULOG_END( "proCIncluirWFAtendimentoAndamentoAtual()" );

    return oDados->idAtendimento;
}

bool proCAlterarWFAtendimentoAndamentoAtual(st_AtendimentoAndamentoAtual* dados, st_vlAtendimentoAndamentoAtual* status, XMLGen* saida)
{
    ULOG_START( "proCAlterarWFAtendimentoAndamentoAtual()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        struct st_AtendimentoAndamentoAtual   oDados;
        struct st_vlAtendimentoAndamentoAtual oStatus;

        char query[800] = "UPDATE atendimento.AtendimentoAndamentoAtual SET ";

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoAndamentoAtual(&sqlca);

    memcpy(&oDados,  dados,  sizeof(oDados));
    memcpy(&oStatus, status, sizeof(oStatus));

    bool separa = false;

    if (status->idAndamento != -1) 
        montaUpdate("idAndamento", oDados.idAndamento, 1);

    if (status->idUsuarioAlteracao != -1) 
        montaUpdate("idUsuarioAlteracao", oDados.idUsuarioAlteracao, TIPO_INT);

    if (status->dtUltimaAlteracao != -1) 
        montaUpdate("dtUltimaAlteracao", oDados.dtUltimaAlteracao, TIPO_DATAHORA);

    sprintf(query, "%s WHERE idAtendimento = %ld", query, dados->idAtendimento);

    ULOG( "QUERY [%s]",query );

    EXEC SQL EXECUTE IMMEDIATE :query;

    ULOG_END( "proCAlterarWFAtendimentoAndamentoAtual()" );

    return true;
}

bool proCExcluirWFAtendimentoAndamentoAtual(st_AtendimentoAndamentoAtual* dados, st_vlAtendimentoAndamentoAtual* status, XMLGen* saida)
{
    ULOG_START( "proCExcluirWFAtendimentoAndamentoAtual()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = dados->idAtendimento;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoAndamentoAtual(&sqlca);

    ULOG( "idAtendimento [%d]",idAtendimento );

    // ==> Remodelagem Atendimento--Fev/2007--Cassio
    // EXEC SQL 
    //     DELETE
    //         atendimento.AtendimentoAndamentoAtual
    //     WHERE
    //         idAtendimento = :idAtendimento;
    //
    // Esta tabela não é usada no sistema de FO, existem apenas
    // rotinas e métodos que executam INSERT/DELETE/UPDATE
    // nesta tabela, mas os dados persistidos nunca são usados
    //
    // EXEC SQL 
    //     DELETE
    //         atendimento.AtendimentoContatoLinha
    //     WHERE
    //         idAtendimento = :idAtendimento;

    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTO
        SET
            IDANDAMENTOATUAL = NULL,
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :idAtendimento;
    // <== Remodelagem Atendimento--Fev/2007--Cassio

    EXEC SQL 
        DELETE
            ANDAMENTO.ANDAMENTOTRANS
        WHERE
            IDATENDIMENTO = :idAtendimento;

    EXEC SQL 
        DELETE
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        WHERE
            IDATENDIMENTO = :idAtendimento;

    ULOG_END( "proCExcluirWFAtendimentoAndamentoAtual()" );

    return true;
}

bool proCConsultaWFAtendimentoAndamentoAtual(st_AtendimentoAndamentoAtual* dados, st_vlAtendimentoAndamentoAtual* status, char* order, XMLGen* saida)
{
    ULOG_START( "proCConsultaWFAtendimentoAndamentoAtual()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento;
        long idAndamento;
        int idUsuarioAlteracao;
        VARCHAR dtUltimaAlteracao[256];

        short i_idUsuarioAlteracao;
        short i_dtUltimaAlteracao;

        char query[800] = "SELECT idAtendimento, idAndamento, idUsuarioAlteracao, "
                                 "TO_CHAR( dtUltimaAlteracao, 'DD/MM/YYYY' ) "
                            "FROM atendimento.AtendimentoAndamentoAtual ";

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFEstado(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    bool separa = false;

    if (status->idAtendimento != -1) 
        montaWhere("idAtendimento", dados->idAtendimento, 1);

    if (status->idAndamento != -1)
        montaWhere("idAndamento", dados->idAndamento, 1);

    if (status->idUsuarioAlteracao != -1) 
        montaWhere("idUsuarioAlteracao", dados->idUsuarioAlteracao, TIPO_INT);

    if (status->dtUltimaAlteracao != -1) 
        montaWhere("dtUltimaAlteracao", dados->dtUltimaAlteracao, TIPO_DATAHORA);

    if (strlen(order) > 0) 
        sprintf( query, "%s ORDER BY %s ", query, order);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoAndamentoAtual(&sqlca);

    ULOG( "QUERY [%s]",query );

    EXEC SQL PREPARE consultaAtendimentoAndamentoAtual FROM :query;
    EXEC SQL DECLARE consulta CURSOR FOR consultaAtendimentoAndamentoAtual;

    EXEC SQL OPEN consulta;

    while (true)
    {
        EXEC SQL FETCH consulta INTO :idAtendimento, 
                                             :idAndamento,
                                             :idUsuarioAlteracao:i_idUsuarioAlteracao,
                                             :dtUltimaAlteracao:i_dtUltimaAlteracao;

        CONVIND(dtUltimaAlteracao,i_dtUltimaAlteracao)

        saida->createTag("WFAtendimentoAndamentoAtualVO");
            saida->addItem("idAtendimento", idAtendimento);
            saida->addItem("idAndamento", idAndamento);
            saida->addItem("idUsuarioAlteracao", idUsuarioAlteracao);
            saida->addItem("dtUltimaAlteracao", (char*)dtUltimaAlteracao.arr);
        saida->closeTag();
    }

    EXEC SQL CLOSE consulta;

    ULOG_END( "proCConsultaWFAtendimentoAndamentoAtual()" );

    return true;

}

void sql_error_WFAtendimentoAndamentoAtual(sqlca*sqlca)
{
    throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
