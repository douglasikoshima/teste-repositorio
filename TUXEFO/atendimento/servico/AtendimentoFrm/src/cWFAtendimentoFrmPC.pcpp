/**
 * @modulo  Workflow
 * @usecase Workflow
 * @author  Unknow
 * @version $Revision: 1.1.2.2.6.3 $
 * @CVS     $Author: a5114878 $ - $Date: 2013/02/06 12:35:55 $
 **/

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"
#include "../../../commons/msgPadrao.h"

#include "../include/cWFAtendimentoFrm.h"
#include "../include/stWFAtendimentoFrm.h"

void sql_error_WFAtendimentoFrm(sqlca*sqlca);
void pesquisaDominioCampo(int idCampo, int Prefixo, st_FormularioDinamico* dados, st_vlFormularioDinamico* status, XMLGen* saida);
void pesquisaDominioCampoQuery(char* dsQuery, XMLGen* saida);
void obtemDominioCampoQuery(char* dsQuery, char* prQuery, XMLGen* saida);

// SM448 e SM542
void proCBuscarPorNrLinha(char *pNrLin, XMLGen* saida);

// Declara as estruturas compatíveis ao ProC.
EXEC SQL BEGIN DECLARE SECTION;
	#include "../include/stWFAtendimentoFrm.h"

	#ifndef STPESQUISAFORMULARIO
		#define STPESQUISAFORMULARIO

	struct st_PesquisaFormulario
	{
		int idContatoFolhaCampo;
		int idContato;
		int idUFOperadora;
		int idTipoLinha;
		int idCampo;
		int sqOrdemApresentacao;
		int idFaseProcesso;
		int idAreaRegistro;
		int cdAreaRegistro;
		VARCHAR nmAreaRegistro[256];
		VARCHAR nmCampo[2001];
		int inObrigatorio;
		int idTipoDadoCampo;
		int idMascaraApresencaoCampo;
		int idLayoutApresentacaoCampo;
		int nrTamanho;
		int inDisponibilidade;
		int idClassificadorCampo;
		int inFiltro;
		int inPesquisa;
		VARCHAR sgTipoDadoCampo[256];
		VARCHAR nmTipoDadoCampo[256];
		int inDominio;
		VARCHAR sgMascaraApresencaoCampo[256];
		VARCHAR nmMascaraApresencaoCampo[256];
		VARCHAR nmLayoutApresentacaoCampo[256];
		VARCHAR sgLayoutApresentacaoCampo[256];
		VARCHAR nmClassificadorCampo[256];
	} ;

	struct st_vlPesquisaFormulario
	{
		short idContatoFolhaCampo;
		short idContato;
		short idUFOperadora;
		short idTipoLinha;
		short idCampo;
		short sqOrdemApresentacao;
		short idFaseProcesso;
		short idAreaRegistro;
		short cdAreaRegistro;
		short nmAreaRegistro;
		short nmCampo;
		short inObrigatorio;
		short idTipoDadoCampo;
		short idMascaraApresencaoCampo;
		short idLayoutApresentacaoCampo;
		short nrTamanho;
		short inDisponibilidade;
		short idClassificadorCampo;
		short inFiltro;
		short inPesquisa;
		short sgTipoDadoCampo;
		short nmTipoDadoCampo;
		short inDominio;
		short sgMascaraApresencaoCampo;
		short nmMascaraApresencaoCampo;
		short nmLayoutApresentacaoCampo;
		short sgLayoutApresentacaoCampo;
		short nmClassificadorCampo;
	} ;
	#endif

EXEC SQL END DECLARE SECTION;

long proCIncluirWFAtendimentoFrm(st_AtendimentoFrm* dados, st_vlAtendimentoFrm* status, XMLDPR *xmlDpr)
{
    ULOG_START("proCIncluirWFAtendimentoFrm()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AtendimentoFrm   *oDados = dados;
		struct st_vlAtendimentoFrm *oStatus = status;

	EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoFrm(&sqlca);

	EXEC SQL SELECT atendimento.AtendimentoFrmSQ.NEXTVAL INTO :oDados->idAtendimentoFrm FROM DUAL;

	EXEC SQL 
		INSERT INTO
			atendimento.AtendimentoFrm
			(
				idAtendimentoFrm,
				idAtendimento,
				idCampo,
				idUsuarioAlteracao,
				dtUltimaAlteracao
			)
			VALUES
			(
				:oDados->idAtendimentoFrm,
				:oDados->idAtendimento,
				:oDados->idCampo,
				DECODE(:oStatus->idUsuarioAlteracao, -1, NULL, :oDados->idUsuarioAlteracao),
                TO_DATE(DECODE(:oStatus->dtUltimaAlteracao, -1, NULL, :oDados->dtUltimaAlteracao),'DD/MM/YYYY HH24:MI:SS')
			);

    // ==> SM324--DPR--DEZ/2006--Cassio
    if ( xmlDpr )
    {
        AtendimentoFRMDPR atendimentofrmdpr;

        atendimentofrmdpr.setIdAtendimento(oDados->idAtendimento);
        atendimentofrmdpr.setIdAtendimentoFrm(oDados->idAtendimentoFrm);
        atendimentofrmdpr.setIdCampo(oDados->idCampo);
        atendimentofrmdpr.setOpCode(OPCODE_INSERT);
        xmlDpr->atendimentofrmvo.inserir(&atendimentofrmdpr);
    }
    // <== SM324--DPR--DEZ/2006--Cassio

    ULOG_END("proCIncluirWFAtendimentoFrm()");

	return oDados->idAtendimentoFrm;
}

bool proCAlterarWFAtendimentoFrm(st_AtendimentoFrm* dados, st_vlAtendimentoFrm* status, XMLGen* saida)
{
    ULOG_START("proCAlterarWFAtendimentoFrm()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AtendimentoFrm   *oDados = dados;
		struct st_vlAtendimentoFrm *oStatus = status;

		char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoFrm(&sqlca);

	sprintf(query,"%s", "UPDATE atendimento.AtendimentoFrm SET ");

	bool separa = false;

	if (status->idAtendimento != -1) 
		montaUpdate("idAtendimento", oDados->idAtendimento, 1);

	if (status->idCampo != -1) 
		montaUpdate("idCampo", oDados->idCampo, 1);

	if (status->idUsuarioAlteracao != -1) 
		montaUpdate("idUsuarioAlteracao", oDados->idUsuarioAlteracao, TIPO_INT);

	if (status->dtUltimaAlteracao != -1) 
		montaUpdate("dtUltimaAlteracao", oDados->dtUltimaAlteracao, TIPO_DATAHORA);

	sprintf(query, "%s WHERE idAtendimentoFrm = %ld", query, dados->idAtendimentoFrm);

	EXEC SQL EXECUTE IMMEDIATE :query;

    ULOG_END("proCAlterarWFAtendimentoFrm()");

	return true;
}

bool proCExcluirWFAtendimentoFrm(st_AtendimentoFrm* dados, st_vlAtendimentoFrm* status, XMLGen* saida)
{
    ULOG_START("proCExcluirWFAtendimentoFrm()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimentoFrm = dados->idAtendimentoFrm;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoFrm(&sqlca);

	EXEC SQL 
		DELETE
			atendimento.AtendimentoFrm
		WHERE
			idAtendimentoFrm = :idAtendimentoFrm;

    ULOG_END("proCExcluirWFAtendimentoFrm()");

	return true;
}

bool proCConsultaWFAtendimentoFrm(st_AtendimentoFrm* dados, st_vlAtendimentoFrm* status, char* order, XMLGen* saida)
{
    ULOG_START("proCConsultaWFAtendimentoFrm()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimentoFrm;
		long idAtendimento;
		int	idCampo;
		int idUsuarioAlteracao;
		VARCHAR	dtUltimaAlteracao[256];

		short i_idUsuarioAlteracao;
		short i_dtUltimaAlteracao;

		char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoFrm(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	sprintf(query,"SELECT idAtendimentoFrm, idAtendimento, idCampo, idUsuarioAlteracao, "
                         "TO_CHAR(dtUltimaAlteracao, 'DD/MM/YYYY HH24:MI') AS dtUltimaAlteracao "
                    "FROM atendimento.AtendimentoFrm ");

	bool separa = false;

	if (status->idAtendimentoFrm != -1) 
		montaWhere("idAtendimentoFrm", dados->idAtendimentoFrm, 1);

	if (status->idAtendimento != -1) 
		montaWhere("idAtendimento", dados->idAtendimento, 1);

	if (status->idCampo != -1) 
		montaWhere("idCampo", dados->idCampo, 1);

	if (status->idUsuarioAlteracao != -1) 
		montaWhere("idUsuarioAlteracao", dados->idUsuarioAlteracao, TIPO_INT);

	if (status->dtUltimaAlteracao != -1) 
		montaWhere("dtUltimaAlteracao", dados->dtUltimaAlteracao, TIPO_DATAHORA);

	if (strlen(order) > 0) 
		sprintf( query, "%s ORDER BY %s ", query, order);

	EXEC SQL PREPARE consultaAtendimentoFrm FROM :query;
	EXEC SQL DECLARE consulta CURSOR FOR consultaAtendimentoFrm;

	EXEC SQL OPEN consulta;

	while (true)
	{
		EXEC SQL FETCH consulta INTO :idAtendimentoFrm, 
									 :idAtendimento, 
									 :idCampo,
									 :idUsuarioAlteracao:i_idUsuarioAlteracao,
									 :dtUltimaAlteracao:i_dtUltimaAlteracao;

		CONVIND(dtUltimaAlteracao, i_dtUltimaAlteracao);

		saida->createTag("WFAtendimentoFrmVO");
			saida->addItem("idAtendimentoFrm", idAtendimentoFrm);
			saida->addItem("idAtendimento", idAtendimento);
			saida->addItem("idCampo", idCampo);
			saida->addItem("idUsuarioAlteracao", idUsuarioAlteracao);
			saida->addItem("dtUltimaAlteracao", (char*)dtUltimaAlteracao.arr);
		saida->closeTag();
	}

	EXEC SQL CLOSE consulta;

    ULOG_END("proCConsultaWFAtendimentoFrm()");

	return true;
}

bool proCObtemFormulario(st_FormularioDinamico* dados, st_vlFormularioDinamico* status, XMLGen* saida)
{
    ULOG_START( "proCObtemFormulario()" );

	struct sqlca sqlca;
    int iFlagCtrl=0;
    string query;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_FormularioDinamico *oDados = dados;

        char OraIdContato[25];
        char OraIdTipoLinha[25];
        char OraIdFaseProcesso[25];
        char OraPrefixo[25];

		int prefixo;
        int prefixoDominioCampo;

		struct st_PesquisaFormulario   oValor;
		struct st_vlPesquisaFormulario oIndicator;

		VARCHAR cidTipoFormulario[21+1];
		short i_idTipoFormulario = -1;

		VARCHAR cidSubFormulario[21+1];
		short i_idSubFormulario = -1;

        VARCHAR nmSubFormulario[60+1];
        short i_nmSubFormulario = -1;

        const char *pQuery;

    EXEC SQL END DECLARE SECTION;

	// Determina o DDD do telefone para determinar a operadora,
	// caso o telefone não seja enviado, será definido SP como 
	// operadora.
	if (status->nrTelefone != -1 && strlen(dados->nrTelefone) > 0)
	{
		char cConv[3];
		if ( dados->nrTelefone[0]=='0' ) 
		{
			strncpy(cConv,dados->nrTelefone+1,2);cConv[2]=0;
			prefixo = atoi(cConv);
		}
		else
		{
			strncpy(cConv,dados->nrTelefone,2);cConv[2]=0;
			prefixo = atoi(cConv);
		}
	}
	else
    {
		prefixo = 11;
    }

    sprintf(OraIdContato,"%d",oDados->idContato);
    sprintf(OraIdTipoLinha,"%d",oDados->idTipoLinha);
    sprintf(OraIdFaseProcesso,"%d",oDados->idFaseProcesso);
    sprintf(OraPrefixo,"%d",prefixo);

    ULOG("proCObtemFormulario:oDados->idContato[%d]", oDados->idContato);
    ULOG("proCObtemFormulario:prefixo[%d]", prefixo);
    ULOG("proCObtemFormulario:oDados->idTipoLinha[%d]", oDados->idTipoLinha);
    ULOG("proCObtemFormulario:oDados->idFaseProcesso[%d]", oDados->idFaseProcesso);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoFrm(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

    //
    // Devido a SM448 é para campos que não pertencem a um grupo
    // temos que marcar "ContatoFolhaCampo.IdSubFormulario is NULL"
    //
    EXEC SQL DECLARE formularioDinamico CURSOR FOR
		SELECT
			idContatoFolhaCampo, 
			idContato, 
			idUFOperadora, 
			idTipoLinha, 
			idCampo, 
			sqOrdemApresentacao, 
			idFaseProcesso, 
			idAreaRegistro, 
			cdAreaRegistro, 
			nmAreaRegistro, 
			nmCampo, 
			inObrigatorio,
			idTipoDadoCampo, 
			idMascaraApresencaoCampo, 
			idLayoutApresentacaoCampo, 
			nrTamanho, 
			inDisponibilidade, 
			idClassificadorCampo, 
			inFiltro, 
			inPesquisa, 
			sgTipoDadoCampo, 
			nmTipoDadoCampo, 
			inDominio, 
			sgMascaraApresencaoCampo, 
			nmMascaraApresencaoCampo, 
			nmLayoutApresentacaoCampo, 
			sgLayoutApresentacaoCampo, 
			nmClassificadorCampo 
		FROM
		(	
			SELECT
				cfc.idContatoFolhaCampo,
				cfc.idContato,
				cfc.idUFOperadora,
				cfc.idTipoLinha,
				cfc.idCampo,
				cfc.sqOrdemApresentacao,
				cfc.idFaseProcesso,
				ar.idAreaRegistro,
				ar.cdAreaRegistro,
				ar.nmAreaRegistro,
				c.nmCampo,
				c.inObrigatorio,
				c.idTipoDadoCampo,
				c.idMascaraApresencaoCampo,
				c.idLayoutApresentacaoCampo,
				c.nrTamanho,
				c.inDisponibilidade,
				c.idClassificadorCampo,
				c.inFiltro,
				c.inPesquisa,
				tdc.sgTipoDadoCampo,
				tdc.nmTipoDadoCampo,
				tdc.inDominio,
				mac.sgMascaraApresencaoCampo,
				mac.nmMascaraApresencaoCampo,
				lac.nmLayoutApresentacaoCampo,
				lac.sgLayoutApresentacaoCampo,
				cc.nmClassificadorCampo
			FROM
				contatoadm.ContatoFolhaCampo cfc,
				apoio.AreaRegistro ar,
				contatoadm.Campo c,
				apoio.TipoDadoCampo tdc,
				apoio.MascaraApresentacaoCampo mac,
				apoio.LayoutApresentacaoCampo lac,
				contatoadm.CampoClassificador cc
			WHERE
				    cfc.idUFOperadora = ar.idUFOperadora
				AND cfc.idCampo = c.idCampo
				AND c.idTipoDadoCampo = tdc.idTipoDadoCampo
				AND c.idMascaraApresencaoCampo = mac.idMascaraApresencaoCampo
				AND c.idLayoutApresentacaoCampo = lac.idLayoutApresentacaoCampo
				AND c.idClassificadorCampo = cc.idClassificadorCampo
				AND cfc.idsubformulario IS NULL
			ORDER BY
				cfc.sqOrdemApresentacao,
				c.nmCampo
		)
		WHERE
			    idContato      = :oDados->idContato
			AND cdAreaRegistro = :prefixo
			AND idTipoLinha    = :oDados->idTipoLinha
			AND idFaseProcesso = :oDados->idFaseProcesso;

	EXEC SQL OPEN formularioDinamico;

	while (true)
	{
		EXEC SQL FETCH formularioDinamico INTO :oValor:oIndicator;

		CONVIND(oValor.nmAreaRegistro,oIndicator.nmAreaRegistro)
		CONVIND(oValor.nmCampo,oIndicator.nmCampo)
		CONVIND(oValor.sgTipoDadoCampo,oIndicator.sgTipoDadoCampo)
		CONVIND(oValor.nmTipoDadoCampo,oIndicator.nmTipoDadoCampo)
		CONVIND(oValor.sgMascaraApresencaoCampo,oIndicator.sgMascaraApresencaoCampo)
		CONVIND(oValor.nmMascaraApresencaoCampo,oIndicator.nmMascaraApresencaoCampo)
		CONVIND(oValor.nmLayoutApresentacaoCampo,oIndicator.nmLayoutApresentacaoCampo)
		CONVIND(oValor.sgLayoutApresentacaoCampo,oIndicator.sgLayoutApresentacaoCampo)
		CONVIND(oValor.nmClassificadorCampo,oIndicator.nmClassificadorCampo)

		saida->createTag("FormularioCampoVO");
			saida->addItem("idContatoFolhaCampo", oValor.idContatoFolhaCampo);
			saida->addItem("idCampo", oValor.idCampo);
			saida->addItem("nmCampo", (char*)oValor.nmCampo.arr);
			saida->addItem("inObrigatorio", oValor.inObrigatorio); // Passara a retornar 0, para digitacao
			//saida->addItem("inObrigatorio", 0);
			saida->addItem("inPesquisa", oValor.inPesquisa);

			saida->createTag("TipoCampoVO");

				saida->addItem("nmTipoDadoCampo", (char*)oValor.nmTipoDadoCampo.arr);
				saida->addItem("sgLayoutApresentacaoCampo", (char*)oValor.sgLayoutApresentacaoCampo.arr);
				saida->addItem("sgMascaraApresentacaoCampo", (char*)oValor.sgMascaraApresencaoCampo.arr);
				saida->addItem("nrTamanho", oValor.nrTamanho);

			saida->closeTag();

			// Essa função tem como objetivo retornar o dominio de um determinado campo.
			if (oValor.inPesquisa != 1)
			{
				if (oValor.inDominio == 1)
					pesquisaDominioCampo(oValor.idCampo, prefixo, dados, status, saida);
			}

		saida->closeTag();
	}

	EXEC SQL CLOSE formularioDinamico;

    //
    // Carrega os grupos e campos de cada grupo conforme SM448
	// Vamos pegar Grupos, Grupos de Campos Dependentes de nível 1 e Funcionalidade: DADOS DE APARELHOS
    //
    ULOG("proCObtemFormulario:Carregando Grupos, "
         "Campos Dependentes de nivel 1 e Funcionalidade: DADOS DE APARELHOS.");

	EXEC SQL DECLARE frmDinGrupos CURSOR FOR
    SELECT DISTINCT
		   subform.idtiposubformulario,
	       subform.idsubformulario,
	       subform.nmsubformulario 
    FROM 
	       contatoadm.subformulario subform,
	       contatoadm.ContatoFolhaCampo cfc,
	       apoio.AreaRegistro ar
    WHERE
	       (subform.idtiposubformulario IN (1, 2) OR subform.nmsubformulario = 'DADOS DE APARELHOS')
	       AND subform.idsubformulario = cfc.idsubformulario
	       AND cfc.idcontato = :oDados->idContato
	       AND ar.idufoperadora = cfc.idufoperadora
	       AND ar.cdarearegistro = :prefixo
	       AND cfc.idtipolinha = :oDados->idTipoLinha
	       AND cfc.idfaseprocesso = :oDados->idFaseProcesso
	ORDER BY subform.idtiposubformulario;

	EXEC SQL OPEN frmDinGrupos;
	while (true)
	{
		EXEC SQL FETCH frmDinGrupos INTO :cidTipoFormulario:i_idTipoFormulario,
                                         :cidSubFormulario:i_idSubFormulario,
                                         :nmSubFormulario:i_nmSubFormulario;

		CONVIND(cidTipoFormulario, i_idTipoFormulario)
		CONVIND(cidSubFormulario, i_idSubFormulario)
		CONVIND(nmSubFormulario, i_nmSubFormulario)

        ULOG("cidTipoFormulario.arr[%.*s]iFlagCtrl(%d)",
            cidTipoFormulario.len, cidTipoFormulario.arr, iFlagCtrl);

        query = 
           "SELECT "
	           "CFC.IDCONTATOFOLHACAMPO, "
	           "CFC.IDCONTATO, "
	           "CFC.IDUFOPERADORA, "
	           "CFC.IDTIPOLINHA, "
	           "CFC.IDCAMPO, "
	           "CFC.SQORDEMAPRESENTACAO, "
	           "CFC.IDFASEPROCESSO, "
	           "AR.IDAREAREGISTRO, "
	           "AR.CDAREAREGISTRO, "
	           "AR.NMAREAREGISTRO, "
	           "C.NMCAMPO, "
	           "C.INOBRIGATORIO, "
	           "C.IDTIPODADOCAMPO, "
	           "C.IDMASCARAAPRESENCAOCAMPO, "
	           "C.IDLAYOUTAPRESENTACAOCAMPO, "
	           "C.NRTAMANHO, "
	           "C.INDISPONIBILIDADE, "
	           "C.IDCLASSIFICADORCAMPO, "
	           "C.INFILTRO, "
	           "C.INPESQUISA, "
	           "TDC.SGTIPODADOCAMPO, "
	           "TDC.NMTIPODADOCAMPO, "
	           "TDC.INDOMINIO, "
	           "MAC.SGMASCARAAPRESENCAOCAMPO, "
	           "MAC.NMMASCARAAPRESENCAOCAMPO, "
	           "LAC.NMLAYOUTAPRESENTACAOCAMPO, "
	           "LAC.SGLAYOUTAPRESENTACAOCAMPO, "
	           "CC.NMCLASSIFICADORCAMPO "
           "FROM "
	           "CONTATOADM.CONTATOFOLHACAMPO CFC, "
	           "APOIO.AREAREGISTRO AR, "
	           "CONTATOADM.CAMPO C, "
	           "APOIO.TIPODADOCAMPO TDC, "
	           "APOIO.MASCARAAPRESENTACAOCAMPO MAC, "
	           "APOIO.LAYOUTAPRESENTACAOCAMPO LAC, "
	           "CONTATOADM.CAMPOCLASSIFICADOR CC, "
	           "CONTATOADM.SUBFORMULARIOCAMPO SUBCAMPO, "
	           "CONTATOADM.SUBFORMULARIO SUBFORM "
           "WHERE "
		           "CFC.IDUFOPERADORA = AR.IDUFOPERADORA "
	           "AND CFC.IDCAMPO = C.IDCAMPO "
	           "AND C.IDTIPODADOCAMPO = TDC.IDTIPODADOCAMPO "
	           "AND C.IDMASCARAAPRESENCAOCAMPO = MAC.IDMASCARAAPRESENCAOCAMPO "
	           "AND C.IDLAYOUTAPRESENTACAOCAMPO = LAC.IDLAYOUTAPRESENTACAOCAMPO "
	           "AND C.IDCLASSIFICADORCAMPO = CC.IDCLASSIFICADORCAMPO "
	           "AND SUBCAMPO.IDCAMPO = C.IDCAMPO "
	           "AND SUBCAMPO.IDSUBFORMULARIO = CFC.IDSUBFORMULARIO "
	           "AND SUBFORM.IDSUBFORMULARIO = SUBCAMPO.IDSUBFORMULARIO "
               "AND SUBFORM.IDSUBFORMULARIO = "+(string)(char*)cidSubFormulario.arr;

        if ( 0 == memcmp(cidTipoFormulario.arr, "2", 1) )
        {
            query += 
            "AND SUBCAMPO.IDNIVELCAMPOVALOR = (SELECT MIN(IDNIVELCAMPOVALOR)  "
							             "FROM CONTATOADM.SUBFORMULARIOCAMPO SFC "
							             "WHERE SFC.IDSUBFORMULARIO = "
                                         +(string)(char*)cidSubFormulario.arr +")";
            // -1 indica que o tipo do formulário é de "Campos Dependentes"
            // OS566 -- Julho/2007 -- Cassio.
            prefixoDominioCampo = -1;
        }
        else
        {
            prefixoDominioCampo = prefixo;
        }

        query += 
	        " AND CFC.IDCONTATO = "+(string)OraIdContato+
	        " AND AR.CDAREAREGISTRO = "+(string)OraPrefixo+
	        " AND CFC.IDTIPOLINHA = "+(string)OraIdTipoLinha+
	        " AND CFC.IDFASEPROCESSO = "+(string)OraIdFaseProcesso+
           " ORDER BY "
	           "CFC.SQORDEMAPRESENTACAO, "
	           "C.NMCAMPO ";

        pQuery = query.c_str();

        ULOG("pQuery=[%s]",pQuery);

        EXEC SQL PREPARE frmDinCamposStat FROM :pQuery;
        EXEC SQL DECLARE frmDinCampos CURSOR FOR frmDinCamposStat;

        EXEC SQL OPEN frmDinCampos;

		saida->createTag("AdmGrupoCamposVO");

	    while (true)
	    {
            if(!memcmp(cidTipoFormulario.arr, "2", 1))
            {
                if(iFlagCtrl == 1)
                {
                    //ULOG("LocalA1");
                    iFlagCtrl=0;
                    break;
                }
                iFlagCtrl=1;
            }

		    EXEC SQL FETCH frmDinCampos INTO :oValor:oIndicator;

		    CONVIND(oValor.nmAreaRegistro, oIndicator.nmAreaRegistro)
		    CONVIND(oValor.nmCampo, oIndicator.nmCampo)
		    CONVIND(oValor.sgTipoDadoCampo, oIndicator.sgTipoDadoCampo)
		    CONVIND(oValor.nmTipoDadoCampo, oIndicator.nmTipoDadoCampo)
		    CONVIND(oValor.sgMascaraApresencaoCampo, oIndicator.sgMascaraApresencaoCampo)
		    CONVIND(oValor.nmMascaraApresencaoCampo, oIndicator.nmMascaraApresencaoCampo)
		    CONVIND(oValor.nmLayoutApresentacaoCampo, oIndicator.nmLayoutApresentacaoCampo)
		    CONVIND(oValor.sgLayoutApresentacaoCampo, oIndicator.sgLayoutApresentacaoCampo)
		    CONVIND(oValor.nmClassificadorCampo, oIndicator.nmClassificadorCampo)

		    saida->createTag("FormularioCampoVO");
			    saida->addItem("idContatoFolhaCampo", oValor.idContatoFolhaCampo);
			    saida->addItem("idCampo", oValor.idCampo);
			    saida->addItem("nmCampo", (char*)oValor.nmCampo.arr);
			    saida->addItem("inObrigatorio", oValor.inObrigatorio); // Passara a retornar 0, para digitacao
			    //saida->addItem("inObrigatorio", 0);
			    saida->addItem("inPesquisa", oValor.inPesquisa);
			    saida->addItem("nrNivel", "1");  // Estamos retornando apenas campos de nível 1/NULL

			    saida->createTag("TipoCampoVO");

				    saida->addItem("nmTipoDadoCampo", (char*)oValor.nmTipoDadoCampo.arr);
				    saida->addItem("sgLayoutApresentacaoCampo", (char*)oValor.sgLayoutApresentacaoCampo.arr);
				    saida->addItem("sgMascaraApresentacaoCampo", (char*)oValor.sgMascaraApresencaoCampo.arr);
				    saida->addItem("nrTamanho", oValor.nrTamanho);

			    saida->closeTag(); // TipoCampoVO

			    // Essa função tem como objetivo retornar o dominio de um determinado campo.
			    if (oValor.inPesquisa != 1)
			    {
				    if (oValor.inDominio == 1)
                    {
					    pesquisaDominioCampo(oValor.idCampo,prefixoDominioCampo, dados, status, saida);
                    }
			    }

		    saida->closeTag(); // FormularioCampoVO
	    }

	    EXEC SQL CLOSE frmDinCampos;

            saida->addItem("idTipoGrupo", (char*)cidTipoFormulario.arr);
            saida->addItem("idGrupoCampos", (char*)cidSubFormulario.arr);
            saida->addItem("nmGrupoCampos", (char*)nmSubFormulario.arr);

		saida->closeTag(); // AdmGrupoCamposVO
	}

	EXEC SQL CLOSE frmDinGrupos;


    //
    // Carrega funcionalidades e campos de cada funcionalidade SM448
    //
    ULOG("proCObtemFormulario:Carregando Funcionalidades e Campos.");
	EXEC SQL DECLARE frmFuncGrupos CURSOR FOR
    SELECT DISTINCT
	       subform.idsubformulario,
	       subform.nmsubformulario 
    FROM 
	       contatoadm.subformulario subform,
	       contatoadm.ContatoFolhaCampo cfc,
	       apoio.AreaRegistro ar
    WHERE
	       subform.idtiposubformulario = 3
	       AND subform.idsubformulario = cfc.idsubformulario
	       AND cfc.idcontato = :oDados->idContato
	       AND ar.idufoperadora = cfc.idufoperadora
	       AND ar.cdarearegistro = :prefixo
	       AND cfc.idtipolinha = :oDados->idTipoLinha
	       AND cfc.idfaseprocesso = :oDados->idFaseProcesso;



	EXEC SQL OPEN frmFuncGrupos;
	while (true)
	{
		EXEC SQL FETCH frmFuncGrupos INTO :cidSubFormulario:i_idSubFormulario,
                                          :nmSubFormulario:i_nmSubFormulario;

		CONVIND(cidSubFormulario, i_idSubFormulario)
		CONVIND(nmSubFormulario, i_nmSubFormulario)

        // Verificamos quais funcionalidades serão utilizadas
        if( stricmp((const char*)nmSubFormulario.arr, "ENDERECO") == 0 )
        {
            saida->addItem("inFuncionalidade", "ENDERECO");
        }
        else if( stricmp((const char*)nmSubFormulario.arr, "ENDERECO COMPLETO") == 0 )
        {
            saida->addItem("inFuncionalidade", "ENDERECOCOMPLETO");

            // Preenche EnderecoVO com os dados do Endereco, conforme consulta
            // utilizada na classe CPessoaEndereco::buscarPorNrLinha()
            proCBuscarPorNrLinha((char*)dados->nrTelefone, saida);
        }

	}
	EXEC SQL CLOSE frmFuncGrupos;
    
    
    ULOG_END( "proCObtemFormulario()" );

	return true;
}



bool proCObtemFormularioPreview(st_FormularioDinamico* dados, st_vlFormularioDinamico* status, int idUFOperadora, XMLGen* saida)
{
    ULOG_START( "proCObtemFormularioPreview()" );

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_FormularioDinamico *oDados = dados;

		int prefixo = 0;

		struct st_PesquisaFormulario   oValor;
		struct st_vlPesquisaFormulario oIndicator;

		VARCHAR cidTipoFormulario[21+1];
		short i_idTipoFormulario = -1;

		VARCHAR cidSubFormulario[21+1];
		short i_idSubFormulario = -1;

        VARCHAR nmSubFormulario[60+1];
        short i_nmSubFormulario = -1;

        int oraidUFOperadora = idUFOperadora;

    EXEC SQL END DECLARE SECTION;


    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoFrm(&sqlca);

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    // Precisamos de um prefixo para a seleção de domínio
    EXEC SQL SELECT cdarearegistro INTO :prefixo FROM apoio.AreaRegistro WHERE idufoperadora = 1 AND ROWNUM < 2;

    if( prefixo == 0 ) prefixo = 11;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    ULOG("proCObtemFormularioPreview:oDados->idContato[%d]", oDados->idContato);
    ULOG("proCObtemFormularioPreview:oDados->idTipoLinha[%d]", oDados->idTipoLinha);
    ULOG("proCObtemFormularioPreview:oDados->idFaseProcesso[%d]", oDados->idFaseProcesso);
    ULOG("proCObtemFormularioPreview:oDados->idUFOperadora[%d]", oraidUFOperadora);

    //
    // Devido a SM448 é para campos que não pertencem a um grupo
    // temos que marcar "ContatoFolhaCampo.IdSubFormulario is NULL"
    //
	EXEC SQL DECLARE frmDinamicoPreview CURSOR FOR
		SELECT
			CONTATOFOLHACAMPO.IDCONTATOFOLHACAMPO,
			CONTATOFOLHACAMPO.IDCONTATO,
			CONTATOFOLHACAMPO.IDUFOPERADORA,
			CONTATOFOLHACAMPO.IDTIPOLINHA,
			CONTATOFOLHACAMPO.IDCAMPO,
			CONTATOFOLHACAMPO.SQORDEMAPRESENTACAO,
			CONTATOFOLHACAMPO.IDFASEPROCESSO,
			NULL, 
			NULL, 
			NULL, 
			CAMPO.NMCAMPO,
			CAMPO.INOBRIGATORIO,
			CAMPO.IDTIPODADOCAMPO,
			CAMPO.IDMASCARAAPRESENCAOCAMPO,
			CAMPO.IDLAYOUTAPRESENTACAOCAMPO,
			CAMPO.NRTAMANHO,
			CAMPO.INDISPONIBILIDADE,
			CAMPO.IDCLASSIFICADORCAMPO,
			CAMPO.INFILTRO,
			CAMPO.INPESQUISA,
			TIPODADOCAMPO.SGTIPODADOCAMPO,
			TIPODADOCAMPO.NMTIPODADOCAMPO,
			TIPODADOCAMPO.INDOMINIO,
			MASCARAAPRESENTACAOCAMPO.SGMASCARAAPRESENCAOCAMPO,
			MASCARAAPRESENTACAOCAMPO.NMMASCARAAPRESENCAOCAMPO,
			LAYOUTAPRESENTACAOCAMPO.NMLAYOUTAPRESENTACAOCAMPO,
			LAYOUTAPRESENTACAOCAMPO.SGLAYOUTAPRESENTACAOCAMPO,
			CAMPOCLASSIFICADOR.NMCLASSIFICADORCAMPO
		FROM
			CONTATOADM.CONTATOFOLHACAMPO CONTATOFOLHACAMPO,
			CONTATOADM.CAMPO CAMPO,
			APOIO.TIPODADOCAMPO TIPODADOCAMPO,
			APOIO.MASCARAAPRESENTACAOCAMPO MASCARAAPRESENTACAOCAMPO,
			APOIO.LAYOUTAPRESENTACAOCAMPO LAYOUTAPRESENTACAOCAMPO,
			CONTATOADM.CAMPOCLASSIFICADOR CAMPOCLASSIFICADOR
			WHERE
				CONTATOFOLHACAMPO.IDUFOPERADORA = :oraidUFOperadora
			AND CONTATOFOLHACAMPO.IDCAMPO = CAMPO.IDCAMPO
			AND CAMPO.IDTIPODADOCAMPO = TIPODADOCAMPO.IDTIPODADOCAMPO
			AND CAMPO.IDMASCARAAPRESENCAOCAMPO = MASCARAAPRESENTACAOCAMPO.IDMASCARAAPRESENCAOCAMPO
			AND CAMPO.IDLAYOUTAPRESENTACAOCAMPO = LAYOUTAPRESENTACAOCAMPO.IDLAYOUTAPRESENTACAOCAMPO
			AND CAMPO.IDCLASSIFICADORCAMPO = CAMPOCLASSIFICADOR.IDCLASSIFICADORCAMPO
			AND CONTATOFOLHACAMPO.IDSUBFORMULARIO IS NULL
			AND CONTATOFOLHACAMPO.IDCONTATO = :oDados->idContato
			AND CONTATOFOLHACAMPO.IDTIPOLINHA = :oDados->idTipoLinha
			AND CONTATOFOLHACAMPO.IDFASEPROCESSO = :oDados->idFaseProcesso
			ORDER BY
			    CONTATOFOLHACAMPO.SQORDEMAPRESENTACAO,
			    UPPER(CAMPO.NMCAMPO);

	EXEC SQL OPEN frmDinamicoPreview;
    
	while (true)
	{
		EXEC SQL FETCH frmDinamicoPreview INTO :oValor:oIndicator;

		CONVIND(oValor.nmAreaRegistro,oIndicator.nmAreaRegistro)
		CONVIND(oValor.nmCampo,oIndicator.nmCampo)
		CONVIND(oValor.sgTipoDadoCampo,oIndicator.sgTipoDadoCampo)
		CONVIND(oValor.nmTipoDadoCampo,oIndicator.nmTipoDadoCampo)
		CONVIND(oValor.sgMascaraApresencaoCampo,oIndicator.sgMascaraApresencaoCampo)
		CONVIND(oValor.nmMascaraApresencaoCampo,oIndicator.nmMascaraApresencaoCampo)
		CONVIND(oValor.nmLayoutApresentacaoCampo,oIndicator.nmLayoutApresentacaoCampo)
		CONVIND(oValor.sgLayoutApresentacaoCampo,oIndicator.sgLayoutApresentacaoCampo)
		CONVIND(oValor.nmClassificadorCampo,oIndicator.nmClassificadorCampo)

		saida->createTag("FormularioCampoVO");
			saida->addItem("idContatoFolhaCampo", oValor.idContatoFolhaCampo);
			saida->addItem("idCampo", oValor.idCampo);
			saida->addItem("nmCampo", (char*)oValor.nmCampo.arr);
			 saida->addItem("inObrigatorio", oValor.inObrigatorio); // Passara a retornar 0, para digitacao
			//saida->addItem("inObrigatorio", 0);
			saida->addItem("inPesquisa", oValor.inPesquisa);

			saida->createTag("TipoCampoVO");

				saida->addItem("nmTipoDadoCampo", (char*)oValor.nmTipoDadoCampo.arr);
				saida->addItem("sgLayoutApresentacaoCampo", (char*)oValor.sgLayoutApresentacaoCampo.arr);
				saida->addItem("sgMascaraApresentacaoCampo", (char*)oValor.sgMascaraApresencaoCampo.arr);
				saida->addItem("nrTamanho", oValor.nrTamanho);

			saida->closeTag();

			// Essa função tem como objetivo retornar o dominio de um determinado campo.
			if (oValor.inPesquisa != 1)
			{
				if (oValor.inDominio == 1)
				{
					pesquisaDominioCampo(oValor.idCampo, prefixo, dados, status, saida);
				}
			}

		saida->closeTag();
	}

	EXEC SQL CLOSE frmDinamicoPreview;

    //
    // Carrega os grupos e campos de cada grupo conforme SM448
	// Vamos pegar Grupos, Grupos de Campos Dependentes de nível 1 e Funcionalidade: DADOS DE APARELHOS
    //
    ULOG("proCObtemFormularioPreview:Carregando Preview Grupos e Campos + Funcionalidade: DADOS DE APARELHOS.");
	EXEC SQL DECLARE frmDinGruposPreview CURSOR FOR
        SELECT DISTINCT
		       SUBFORMULARIO.IDTIPOSUBFORMULARIO,
	           SUBFORMULARIO.IDSUBFORMULARIO,
	           SUBFORMULARIO.NMSUBFORMULARIO 
        FROM 
	           CONTATOADM.SUBFORMULARIO SUBFORMULARIO,
	           CONTATOADM.CONTATOFOLHACAMPO CONTATOFOLHACAMPO,
	           APOIO.AREAREGISTRO AREAREGISTRO
        WHERE
	           (SUBFORMULARIO.IDTIPOSUBFORMULARIO IN (1,2)
                   OR SUBFORMULARIO.NMSUBFORMULARIO = 'DADOS DE APARELHOS')
	           AND SUBFORMULARIO.IDSUBFORMULARIO = CONTATOFOLHACAMPO.IDSUBFORMULARIO
	           AND AREAREGISTRO.IDUFOPERADORA = CONTATOFOLHACAMPO.IDUFOPERADORA
	           AND CONTATOFOLHACAMPO.IDCONTATO = :oDados->idContato
	           AND AREAREGISTRO.CDAREAREGISTRO = :prefixo
	           AND CONTATOFOLHACAMPO.IDTIPOLINHA = :oDados->idTipoLinha
	           AND CONTATOFOLHACAMPO.IDFASEPROCESSO = :oDados->idFaseProcesso
	    ORDER BY SUBFORMULARIO.IDTIPOSUBFORMULARIO;

	EXEC SQL OPEN frmDinGruposPreview;

	while (true)
	{
        EXEC SQL FETCH frmDinGruposPreview INTO :cidTipoFormulario:i_idTipoFormulario,
                                                :cidSubFormulario:i_idSubFormulario,
                                                :nmSubFormulario:i_nmSubFormulario;

		CONVIND(cidTipoFormulario, i_idTipoFormulario)
		CONVIND(cidSubFormulario, i_idSubFormulario)
		CONVIND(nmSubFormulario, i_nmSubFormulario)

		saida->createTag("AdmGrupoCamposVO");

        //
        // Loop interno para os campos
        //
        EXEC SQL DECLARE frmDinCamposPreview CURSOR FOR
            SELECT
                CONTATOFOLHACAMPO.IDCONTATOFOLHACAMPO,
                CONTATOFOLHACAMPO.IDCONTATO,
                CONTATOFOLHACAMPO.IDUFOPERADORA,
                CONTATOFOLHACAMPO.IDTIPOLINHA,
                CONTATOFOLHACAMPO.IDCAMPO,
                CONTATOFOLHACAMPO.SQORDEMAPRESENTACAO,
                CONTATOFOLHACAMPO.IDFASEPROCESSO,
                NULL A1,
                NULL A2,
                NULL A3,
                CAMPO.NMCAMPO,
                CAMPO.INOBRIGATORIO,
                CAMPO.IDTIPODADOCAMPO,
                CAMPO.IDMASCARAAPRESENCAOCAMPO,
                CAMPO.IDLAYOUTAPRESENTACAOCAMPO,
                CAMPO.NRTAMANHO,
                CAMPO.INDISPONIBILIDADE,
                CAMPO.IDCLASSIFICADORCAMPO,
                CAMPO.INFILTRO,
                CAMPO.INPESQUISA,
                TIPODADOCAMPO.SGTIPODADOCAMPO,
                TIPODADOCAMPO.NMTIPODADOCAMPO,
                TIPODADOCAMPO.INDOMINIO,
                MASCARAAPRESENTACAOCAMPO.SGMASCARAAPRESENCAOCAMPO,
                MASCARAAPRESENTACAOCAMPO.NMMASCARAAPRESENCAOCAMPO,
                LAYOUTAPRESENTACAOCAMPO.NMLAYOUTAPRESENTACAOCAMPO,
                LAYOUTAPRESENTACAOCAMPO.SGLAYOUTAPRESENTACAOCAMPO,
                CAMPOCLASSIFICADOR.NMCLASSIFICADORCAMPO
            FROM
                CONTATOADM.CONTATOFOLHACAMPO CONTATOFOLHACAMPO,
                CONTATOADM.CAMPO CAMPO,
                APOIO.TIPODADOCAMPO TIPODADOCAMPO,
                APOIO.MASCARAAPRESENTACAOCAMPO MASCARAAPRESENTACAOCAMPO,
                APOIO.LAYOUTAPRESENTACAOCAMPO LAYOUTAPRESENTACAOCAMPO,
                CONTATOADM.CAMPOCLASSIFICADOR CAMPOCLASSIFICADOR,
                CONTATOADM.SUBFORMULARIOCAMPO SUBFORMULARIOCAMPO,
                CONTATOADM.SUBFORMULARIO SUBFORMULARIO
            WHERE
                CONTATOFOLHACAMPO.IDUFOPERADORA = :oraidUFOperadora
            AND CONTATOFOLHACAMPO.IDCAMPO = CAMPO.IDCAMPO
            AND CAMPO.IDTIPODADOCAMPO = TIPODADOCAMPO.IDTIPODADOCAMPO
            AND CAMPO.IDMASCARAAPRESENCAOCAMPO = MASCARAAPRESENTACAOCAMPO.IDMASCARAAPRESENCAOCAMPO
            AND CAMPO.IDLAYOUTAPRESENTACAOCAMPO = LAYOUTAPRESENTACAOCAMPO.IDLAYOUTAPRESENTACAOCAMPO
            AND CAMPO.IDCLASSIFICADORCAMPO = CAMPOCLASSIFICADOR.IDCLASSIFICADORCAMPO
            AND SUBFORMULARIOCAMPO.IDCAMPO = CAMPO.IDCAMPO
            AND SUBFORMULARIOCAMPO.IDSUBFORMULARIO = CONTATOFOLHACAMPO.IDSUBFORMULARIO
            AND SUBFORMULARIO.IDSUBFORMULARIO = SUBFORMULARIOCAMPO.IDSUBFORMULARIO
            AND SUBFORMULARIO.IDSUBFORMULARIO = :cidSubFormulario
            AND CONTATOFOLHACAMPO.IDCONTATO = :oDados->idContato
            AND CONTATOFOLHACAMPO.IDTIPOLINHA = :oDados->idTipoLinha
            AND CONTATOFOLHACAMPO.IDFASEPROCESSO = :oDados->idFaseProcesso
            ORDER BY
                CONTATOFOLHACAMPO.SQORDEMAPRESENTACAO,
                UPPER(CAMPO.NMCAMPO);

        EXEC SQL OPEN frmDinCamposPreview;

        while (true)
        {
		        EXEC SQL FETCH frmDinCamposPreview INTO :oValor:oIndicator;

		        CONVIND(oValor.nmAreaRegistro, oIndicator.nmAreaRegistro)
		        CONVIND(oValor.nmCampo, oIndicator.nmCampo)
		        CONVIND(oValor.sgTipoDadoCampo, oIndicator.sgTipoDadoCampo)
		        CONVIND(oValor.nmTipoDadoCampo, oIndicator.nmTipoDadoCampo)
		        CONVIND(oValor.sgMascaraApresencaoCampo, oIndicator.sgMascaraApresencaoCampo)
		        CONVIND(oValor.nmMascaraApresencaoCampo, oIndicator.nmMascaraApresencaoCampo)
		        CONVIND(oValor.nmLayoutApresentacaoCampo, oIndicator.nmLayoutApresentacaoCampo)
		        CONVIND(oValor.sgLayoutApresentacaoCampo, oIndicator.sgLayoutApresentacaoCampo)
		        CONVIND(oValor.nmClassificadorCampo, oIndicator.nmClassificadorCampo)

		        saida->createTag("FormularioCampoVO");
			        saida->addItem("idContatoFolhaCampo", oValor.idContatoFolhaCampo);
			        saida->addItem("idCampo", oValor.idCampo);
			        saida->addItem("nmCampo", (char*)oValor.nmCampo.arr);
			        saida->addItem("inObrigatorio", oValor.inObrigatorio);  // Passara a retornar 0, para digitacao
			        //aida->addItem("inObrigatorio", 0);
			        saida->addItem("inPesquisa", oValor.inPesquisa);
			        saida->addItem("nrNivel", "1");  // Estamos retornando apenas campos de nível 1/NULL

			        saida->createTag("TipoCampoVO");

				        saida->addItem("nmTipoDadoCampo", (char*)oValor.nmTipoDadoCampo.arr);
				        saida->addItem("sgLayoutApresentacaoCampo", (char*)oValor.sgLayoutApresentacaoCampo.arr);
				        saida->addItem("sgMascaraApresentacaoCampo", (char*)oValor.sgMascaraApresencaoCampo.arr);
				        saida->addItem("nrTamanho", oValor.nrTamanho);

			        saida->closeTag(); // TipoCampoVO

			        // Essa função tem como objetivo retornar o dominio de um determinado campo.
			        if (oValor.inPesquisa != 1)
			        {
				        if (oValor.inDominio == 1)
                        {
					        pesquisaDominioCampo(oValor.idCampo, prefixo, dados, status, saida);
                        }
			        }

		        saida->closeTag(); // FormularioCampoVO
        } // while (true) cursor = frmDinCamposPreview

	    EXEC SQL CLOSE frmDinCamposPreview;

            saida->addItem("idTipoGrupo", (char*)cidTipoFormulario.arr);
            saida->addItem("idGrupoCampos", (char*)cidSubFormulario.arr);
            saida->addItem("nmGrupoCampos", (char*)nmSubFormulario.arr);

		saida->closeTag(); // AdmGrupoCamposVO
    } // while (true) cursor = frmDinGruposPreview

	EXEC SQL CLOSE frmDinGruposPreview;

    //
    // Carrega os Funcionalidades e campos de cada funcionalidades
    //
    ULOG("proCObtemFormularioPreview:Carregando Preview Funcionalidades e campos.");

	EXEC SQL DECLARE frmDinFuncPreview CURSOR FOR
        SELECT DISTINCT
	       SUBFORM.IDSUBFORMULARIO,
	       SUBFORM.NMSUBFORMULARIO
        FROM 
	       CONTATOADM.SUBFORMULARIO SUBFORM,
	       CONTATOADM.CONTATOFOLHACAMPO CFC
        WHERE
            SUBFORM.IDTIPOSUBFORMULARIO = 3
        AND SUBFORM.IDSUBFORMULARIO = CFC.IDSUBFORMULARIO
        AND CFC.IDCONTATO = :oDados->idContato
        AND CFC.IDUFOPERADORA = :oraidUFOperadora
        AND CFC.IDTIPOLINHA = :oDados->idTipoLinha
        AND CFC.IDFASEPROCESSO = :oDados->idFaseProcesso;

	EXEC SQL OPEN frmDinFuncPreview;

	while (true)
	{
		EXEC SQL FETCH frmDinFuncPreview INTO :cidSubFormulario:i_idSubFormulario,
                                              :nmSubFormulario:i_nmSubFormulario;

		CONVIND(cidSubFormulario, i_idSubFormulario)
		CONVIND(nmSubFormulario, i_nmSubFormulario)

        // Verificamos quais funcionalidades serão utilizadas
        if( stricmp((const char*)nmSubFormulario.arr, "ENDERECO") == 0 )
        {
            saida->addItem("inFuncionalidade", "ENDERECO");
        }
        else if( stricmp((const char*)nmSubFormulario.arr, "ENDERECO COMPLETO") == 0 )
        {
            saida->addItem("inFuncionalidade", "ENDERECOCOMPLETO");
        }
	}

	EXEC SQL CLOSE frmDinFuncPreview;

    ULOG_END( "proCObtemFormularioPreview()" );

	return true;
}

bool proCObtemFormularioMassa(st_FormularioDinamico* dados, st_vlFormularioDinamico* status, XMLGen* saida)
{
    ULOG_START( "proCObtemFormularioMassa()" );

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int prefixo;

        struct
        {
            int idCampo;
            VARCHAR nmCampo[2001];
            int nrTamanho;
            VARCHAR sgLayoutApresentacaoCampo[256];
            VARCHAR sgMascaraApresencaoCampo[256];
            VARCHAR nmTipoDadoCampo[256];
            int inDominio;
        } oValor;

        struct
        {
            short idCampo;
            short nmCampo;
            short nrTamanho;
            short sgLayoutApresentacaoCampo;
            short sgMascaraApresencaoCampo;
            short nmTipoDadoCampo;
            short inDominio;
        } oIndicator;

    EXEC SQL END DECLARE SECTION;

	// Determina o DDD do telefone para determinar a operadora,
	// caso o telefone não seja enviado, será definido SP como 
	// operadora.
	if (status->nrTelefone != -1 && strlen(dados->nrTelefone) > 0)
	{
		char cConv[3];
		if ( dados->nrTelefone[0]=='0' ) 
		{
			strncpy(cConv,dados->nrTelefone+1,2);cConv[2]=0;
			prefixo = atoi(cConv);
		}
		else
		{
			strncpy(cConv,dados->nrTelefone,2);cConv[2]=0;
			prefixo = atoi(cConv);
		}
	}
	else
    {
		prefixo = 11;
    }

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoFrm(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE formularioMassa CURSOR FOR
        SELECT DISTINCT
            CONTATOFOLHACAMPO.IDCAMPO, 
            CAMPO.NMCAMPO,
            CAMPO.NRTAMANHO,
            LAYOUTAPRESENTACAOCAMPO.SGLAYOUTAPRESENTACAOCAMPO,
            MASCARAAPRESENTACAOCAMPO.SGMASCARAAPRESENCAOCAMPO,
            TIPODADOCAMPO.NMTIPODADOCAMPO,
			TIPODADOCAMPO.INDOMINIO
        FROM
            CONTATOADM.CONTATOFOLHACAMPO CONTATOFOLHACAMPO,
            CONTATOADM.CAMPO CAMPO,
            APOIO.MASCARAAPRESENTACAOCAMPO MASCARAAPRESENTACAOCAMPO,
            APOIO.LAYOUTAPRESENTACAOCAMPO LAYOUTAPRESENTACAOCAMPO,
            APOIO.TIPODADOCAMPO TIPODADOCAMPO
        WHERE
            CAMPO.INPESQUISA = 2
        AND CONTATOFOLHACAMPO.IDCAMPO = CAMPO.IDCAMPO
        AND CAMPO.IDMASCARAAPRESENCAOCAMPO = MASCARAAPRESENTACAOCAMPO.IDMASCARAAPRESENCAOCAMPO
        AND CAMPO.IDLAYOUTAPRESENTACAOCAMPO = LAYOUTAPRESENTACAOCAMPO.IDLAYOUTAPRESENTACAOCAMPO
        AND CAMPO.IDTIPODADOCAMPO = TIPODADOCAMPO.IDTIPODADOCAMPO
        ORDER BY
            UPPER(CAMPO.NMCAMPO);

	EXEC SQL OPEN formularioMassa;

	while (true)
	{
        memset(&oValor,0,sizeof(oValor));
        memset(&oIndicator,-1,sizeof(oIndicator));

		EXEC SQL FETCH formularioMassa INTO :oValor:oIndicator;

		CONVIND(oValor.nmCampo,oIndicator.nmCampo)
		CONVIND(oValor.sgMascaraApresencaoCampo,oIndicator.sgMascaraApresencaoCampo)
		CONVIND(oValor.sgLayoutApresentacaoCampo,oIndicator.sgLayoutApresentacaoCampo)

		saida->createTag("FormularioCampoVO");
			saida->addItem("idContatoFolhaCampo", 1);
			saida->addItem("idCampo", oValor.idCampo);
			saida->addItem("nmCampo", (char*)oValor.nmCampo.arr);
			saida->addItem("inObrigatorio", 0); // 0 = NAO OBRIGATÓRIO
			saida->addItem("inPesquisa", 2); 

			saida->createTag("TipoCampoVO");
				saida->addItem("nmTipoDadoCampo", (char*)oValor.nmTipoDadoCampo.arr);
				saida->addItem("sgLayoutApresentacaoCampo", (char*)oValor.sgLayoutApresentacaoCampo.arr);
				saida->addItem("sgMascaraApresentacaoCampo", (char*)oValor.sgMascaraApresencaoCampo.arr);
				saida->addItem("nrTamanho", oValor.nrTamanho);
			saida->closeTag();

			// Essa função tem como objetivo retornar o dominio de um determinado campo.
			if (oValor.inDominio == 1)
            {
				pesquisaDominioCampo(oValor.idCampo, prefixo, dados, status, saida);
            }

		saida->closeTag();
	}

	EXEC SQL CLOSE formularioMassa;

    ULOG_END( "proCObtemFormularioMassa()" );

	return true;
}

/**
* Esse método é responsável por retornar os campos que fazem parte da pesquisa da fila.
**/
bool proCObtemFormularioPesquisa(XMLGen* saida)
{
    ULOG_START( "proCObtemFormularioPesquisa()" );

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_PesquisaFormulario   oValor;
		struct st_vlPesquisaFormulario oIndicator;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoFrm(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE formularioPesquisa CURSOR FOR
		SELECT
			idContatoFolhaCampo, 
			idContato, 
			idUFOperadora, 
			idTipoLinha, 
			idCampo, 
			sqOrdemApresentacao, 
			idFaseProcesso, 
			idAreaRegistro, 
			cdAreaRegistro, 
			nmAreaRegistro, 
			nmCampo, 
			idTipoDadoCampo, 
			idMascaraApresencaoCampo, 
			idLayoutApresentacaoCampo, 
			nrTamanho, 
			inDisponibilidade, 
			idClassificadorCampo, 
			inFiltro, 
            inPesquisa,
			sgTipoDadoCampo, 
			nmTipoDadoCampo, 
			inDominio, 
			sgMascaraApresencaoCampo, 
			nmMascaraApresencaoCampo, 
			nmLayoutApresentacaoCampo, 
			sgLayoutApresentacaoCampo, 
			nmClassificadorCampo 
		FROM	
			contatoadm.FormularioDinamicoV01
		WHERE
			inFiltro = 1;

	EXEC SQL OPEN formularioPesquisa;

	while (true)
	{
        memset(&oIndicator,-1,sizeof(oIndicator));

		EXEC SQL FETCH formularioPesquisa INTO :oValor:oIndicator;

		CONVIND(oValor.nmAreaRegistro,oIndicator.nmAreaRegistro)
		CONVIND(oValor.nmCampo,oIndicator.nmCampo)
		CONVIND(oValor.sgTipoDadoCampo,oIndicator.sgTipoDadoCampo)
		CONVIND(oValor.nmTipoDadoCampo,oIndicator.nmTipoDadoCampo)
		CONVIND(oValor.sgMascaraApresencaoCampo,oIndicator.sgMascaraApresencaoCampo)
		CONVIND(oValor.nmMascaraApresencaoCampo,oIndicator.nmMascaraApresencaoCampo)
		CONVIND(oValor.nmLayoutApresentacaoCampo,oIndicator.nmLayoutApresentacaoCampo)
		CONVIND(oValor.sgLayoutApresentacaoCampo,oIndicator.sgLayoutApresentacaoCampo)
		CONVIND(oValor.nmClassificadorCampo,oIndicator.nmClassificadorCampo)

		saida->createTag("FormularioCampoVO");
			saida->addItem("idContatoFolhaCampo", oValor.idContatoFolhaCampo);
			saida->addItem("idCampo", oValor.idCampo);
			saida->addItem("nmCampo", (char*)oValor.nmCampo.arr);
			saida->addItem("inObrigatorio", 0);

			saida->createTag("TipoCampoVO");

				saida->addItem("nmTipoDadoCampo", (char*)oValor.nmTipoDadoCampo.arr);
				saida->addItem("sgLayoutApresentacaoCampo", (char*)oValor.sgLayoutApresentacaoCampo.arr);
				saida->addItem("sgMascaraApresentacaoCampo", (char*)oValor.sgMascaraApresencaoCampo.arr);
				saida->addItem("nrTamanho", oValor.nrTamanho);

			saida->closeTag();

			// Essa função tem como objetivo retornar o dominio de um determinado campo.
			if (oValor.inDominio == 1)
            {
				pesquisaDominioCampo(oValor.idCampo, 999, NULL, NULL, saida);
            }

		saida->closeTag();
	}

	EXEC SQL CLOSE formularioPesquisa;

    ULOG_END( "proCObtemFormularioPesquisa()" );

	return true;
}

void pesquisaDominioCampo(int idCampo,int Prefixo,st_FormularioDinamico* dados
                         ,st_vlFormularioDinamico* status,XMLGen* saida)
{
    ULOG_START( "pesquisaDominioCampo()" );
	
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int cdAreaRegistro;
		int idTipoLinha;

		VARCHAR dsQuery[512];
		VARCHAR nmDominio[256];
		char cidTipoLinha[21+1];
		char ccdAreaRegistro[21+1];
		char cPesquisa[512];
		int idDominio;
		int OrainDisponibilidade;
		int OraidCampo = idCampo;

		short i_cdAreaRegistro=-1;
		short i_idTipoLinha=-1;
		short i_dsQuery=-1;
		short i_idDominio=-1;
		short i_nmDominio=-1;
        short i_OrainDisponibilidade = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoFrm(&sqlca);

    ULOG("idcampo=%d",idCampo);
    ULOG("Prefixo=%d",Prefixo);

	sprintf( cPesquisa, "SELECT "
			                "CDAREAREGISTRO, "
			                "IDTIPOLINHA, "
			                "DSQUERY, "
			                "IDDOMINIO, "
			                "NMDOMINIO "
		                "FROM "
			                "CONTATOADM.DOMINIOFORMULARIOV01 "
		                "WHERE "
			                "IDCAMPO = %d",idCampo);

	//Este 999 indica que sera pesquisa um campo unico, que nao tem varias configuraçoes
	if( Prefixo != 999 )
	{
        ULOG("vai verificar se campo é dinamico");

	    EXEC SQL WHENEVER NOT FOUND CONTINUE;
        EXEC SQL
            SELECT
                MAX(INDISPONIBILIDADE)
	        INTO
                :OrainDisponibilidade:i_OrainDisponibilidade
            FROM
                CONTATOADM.DOMINIOFORMULARIOV01 
            WHERE
                IDCAMPO = :OraidCampo;

        if ( sqlca.sqlcode ) { OrainDisponibilidade = 0; }

        ULOG("OrainDisponibilidade=%d",OrainDisponibilidade);

		memset( cidTipoLinha, 0, sizeof( cidTipoLinha ) );
		memset( ccdAreaRegistro, 0, sizeof( ccdAreaRegistro ) );
		
        // OrainDisponibilidade=3 indica que o formulário é de "Campos Dependentes" (OS566)
        // neste caso a tabela CONTATOADM.DOMINIO é populada apenas para 
        // IDUFOPERADORA=1 e IDTIPOLINHA=1 devido a problemas de performance.
        // Esta funcionalidade foi fechada pelo analista funcional Marcelo Novaes
        // Julho, 2007 -- Cassio.
        sprintf( cidTipoLinha, "%d", OrainDisponibilidade!=3?dados->idTipoLinha:1 );
        sprintf( ccdAreaRegistro, "%d", OrainDisponibilidade!=3?Prefixo:11 );

		strcat( cPesquisa, " AND ((IDTIPOLINHA = " );
		strcat( cPesquisa, cidTipoLinha );
		strcat( cPesquisa, " AND CDAREAREGISTRO = '" );
		strcat( cPesquisa, ccdAreaRegistro );
		strcat( cPesquisa, "' ) OR DSQUERY IS NOT NULL )" );
	}

	strcat( cPesquisa, "ORDER BY UPPER(NMDOMINIO)" );

    ULOG("cPesquisa:[%s]", cPesquisa);

	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	EXEC SQL PREPARE qPesquisa FROM :cPesquisa;
	EXEC SQL DECLARE dominioFormulario CURSOR FOR qPesquisa;
	EXEC SQL OPEN dominioFormulario;

	int contador = 0; // Variavel usada para manter performance no loop
					  // evitando que o teste de strlen seja executado toda vez
					  // que passar no if.
	while (true)
	{
        i_dsQuery = i_nmDominio = -1;

		EXEC SQL 
            FETCH dominioFormulario 
            INTO :cdAreaRegistro:i_cdAreaRegistro,
				 :idTipoLinha:i_idTipoLinha,
				 :dsQuery:i_dsQuery,
				 :idDominio:i_idDominio,
				 :nmDominio:i_nmDominio;

		CONVIND(dsQuery,i_dsQuery)
		CONVIND(nmDominio,i_nmDominio)

		if (contador == 0 && i_dsQuery != -1 && strlen((char*)dsQuery.arr) > 0)
		{
			pesquisaDominioCampoQuery((char*)dsQuery.arr, saida);
			break;
		}

		contador++;

		saida->createTag("FormularioCampoValorVO");
			saida->addItem("idFormularioCampoValor", idDominio);
			saida->addItem("valor", (char*)nmDominio.arr);
		saida->closeTag();
	}

	EXEC SQL CLOSE dominioFormulario;

    ULOG_END( "pesquisaDominioCampo()" );
}

bool proCObtemDominioCampo(int idCampo, char* prQuery, XMLGen* saida)
{
    ULOG_START( "proCObtemDominioCampo()" );

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idcampo = idCampo;

		VARCHAR dsQuery[512];

		short i_dsQuery;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoFrm(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

    ULOG("idCampo=%d", idCampo);

	EXEC SQL DECLARE queryCampo CURSOR FOR
		SELECT
			DSQUERY
		FROM	
			CONTATOADM.CAMPODOMINIO
		WHERE
			IDCAMPO = :idcampo;

	EXEC SQL OPEN queryCampo;

	saida->createTag("FormularioCampoVO");
	saida->addProp("xmlns","admsistemas.fo.vivo.com.br/vo");

	while (true)
	{
        i_dsQuery = -1;

		EXEC SQL FETCH queryCampo INTO :dsQuery:i_dsQuery;

		CONVIND(dsQuery,i_dsQuery)

        if ( i_dsQuery != -1 && dsQuery.arr[0] )
		{
			obtemDominioCampoQuery((char*)dsQuery.arr, prQuery, saida);
			break;
		}
	}

    saida->closeTag();

	EXEC SQL CLOSE queryCampo;

    ULOG_END( "proCObtemDominioCampo()" );

	return true;
}

void pesquisaDominioCampoQuery(char* dsQuery, XMLGen* saida)
{
    ULOG_START( "pesquisaDominioCampoQuery()" );

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		VARCHAR idDominio[256];
		VARCHAR dsDominio[256];

		short i_idDominio;
		short i_dsDominio;

		char *query = dsQuery;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoFrm(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

    ULOG("query = '%s'", query);

	EXEC SQL PREPARE dominioQuery FROM :query;
	EXEC SQL DECLARE consultaQuery CURSOR FOR dominioQuery;

	EXEC SQL OPEN consultaQuery;

	while (true)
	{
        i_idDominio = i_dsDominio = -1;

		EXEC SQL FETCH consultaQuery INTO :idDominio:i_idDominio, 
									      :dsDominio:i_dsDominio;

		CONVIND(idDominio, i_idDominio);
		CONVIND(dsDominio, i_dsDominio);

		saida->createTag("FormularioCampoValorVO");
			saida->addItem("valor", (char*)dsDominio.arr);
		saida->closeTag();
	}

	EXEC SQL CLOSE consultaQuery;

    ULOG_END( "pesquisaDominioCampoQuery()" );
}

void obtemDominioCampoQuery(char* dsQuery, char* prQuery, XMLGen* saida)
{
    ULOG_START("obtemDominioCampoQuery()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		VARCHAR idDominio[256];
		VARCHAR dsDominio[256];

		short i_idDominio;
		short i_dsDominio;

		char *query = dsQuery;
        char *par = prQuery ? prQuery : "";

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoFrm(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL PREPARE dominioRsQuery FROM :query;
	EXEC SQL DECLARE consultaRsQuery CURSOR FOR dominioRsQuery;

    ULOG("query = '%s'", query);
    ULOG("par = '%s'", par);

    if ( *par == 0 ) 
    {
	    EXEC SQL OPEN consultaRsQuery;
    }
    else
    {
        EXEC SQL OPEN consultaRsQuery USING :par;
    }

	while (true)
	{
        i_idDominio = i_dsDominio = -1;

		EXEC SQL FETCH consultaRsQuery INTO 
									:idDominio:i_idDominio, 
									:dsDominio:i_dsDominio;

		CONVIND(idDominio, i_idDominio);
		CONVIND(dsDominio, i_dsDominio);

		saida->createTag("FormularioCampoValorVO");
			saida->addItem("valor", (char*)dsDominio.arr);
		saida->closeTag();
	}

	EXEC SQL CLOSE consultaRsQuery;

    ULOG_END("obtemDominioCampoQuery()");
}

void sql_error_WFAtendimentoFrm(sqlca*sqlca)
{
	throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}


void proCBuscarPorNrLinha(char *pNrLin, XMLGen* saida)
{
    ULOG_START("proCBuscarPorNrLinha()");    
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        long lOraIdConta;
        short iOraIdConta_ora;
	    char cOraDDD[3];
	    char cOraFone[10];
        VARCHAR cOraidtipoendereco[256];
        VARCHAR cOranmtipologradouro[256];
        VARCHAR cOranmtitulologradouro[256];
        VARCHAR cOranmlogradouro[256];
        VARCHAR cOranmbairro[256];
        VARCHAR cOranmmunicipio[256];
        VARCHAR cOranrendereco[256];
        VARCHAR cOradsenderecocomplemento[256];
        VARCHAR cOranrcep[256];
        VARCHAR cOrasguf[256];
        VARCHAR cOranmpais[256];

        short iOraidtipoendereco = -1;
        short iOranmtipologradouro = -1;
        short iOranmtitulologradouro = -1;
        short iOranmlogradouro = -1;
        short iOranmbairro = -1;
        short iOranmmunicipio = -1;
        short iOranrendereco = -1;
        short iOradsenderecocomplemento = -1;
        short iOranrcep = -1;
        short iOrasguf = -1;
        short iOranmpais = -1;
    EXEC SQL END DECLARE SECTION;

	strncpy(cOraDDD, pNrLin, 2);
	cOraDDD[2]='\0';
	strcpy( cOraFone, (char*)&pNrLin[2] );

	// Marca ponto de controle de erro
    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoFrm(&sqlca);
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

    /* Recuperando o idConta da Linha Telefonica */
    EXEC SQL 
        SELECT MAX(idconta)
          INTO :lOraIdConta:iOraIdConta_ora
          FROM customer.linhaconta,
               linha.linhatelefonica,
               linha.linhabase,
               apoio.arearegistro
         WHERE linhatelefonica.idlinhatelefonica = linhaconta.idlinhatelefonica
           AND linhabase.idlinhabase             = linhatelefonica.idlinhabase
           AND arearegistro.idarearegistro       = linhabase.idarearegistro
           AND linhabase.nrlinha                 = :cOraFone
           AND arearegistro.cdarearegistro       = :cOraDDD;

	if (sqlca.sqlcode != 1403 && iOraIdConta_ora != -1)
    {
         // Declara e abre o cursor
         EXEC SQL 
            SELECT tipoendereco.idtipoendereco,
                   pessoaendereco.nmtipologradouro,
                   pessoaendereco.nmtitulologradouro,
                   pessoaendereco.nmlogradouro,
                   pessoaendereco.nmbairro,
                   pessoaendereco.nmmunicipio,
                   pessoaendereco.nrendereco,
                   pessoaendereco.dsenderecocomplemento,
                   pessoaendereco.nrcep,
                   uf.sguf,
                   pais.nmpais
             INTO   cOraidtipoendereco:iOraidtipoendereco,
                    cOranmtipologradouro:iOranmtipologradouro,
                    cOranmtitulologradouro:iOranmtitulologradouro,
                    cOranmlogradouro:iOranmlogradouro,
                    cOranmbairro:iOranmbairro,
                    cOranmmunicipio:iOranmmunicipio,
                    cOranrendereco:iOranrendereco,
                    cOradsenderecocomplemento:iOradsenderecocomplemento,
                    cOranrcep:iOranrcep,
                    cOrasguf:iOrasguf,
                    cOranmpais:iOranmpais
             FROM customer.conta,
                  customer.contaendereco,
                  customer.pessoaendereco,
                  apoio.tipoendereco,
                  apoio.uf,
                  apoio.pais
            WHERE conta.idconta                    = contaendereco.idconta
               AND pessoaendereco.idpessoaendereco = contaendereco.idpessoaendereco
               AND tipoendereco.idtipoendereco     = pessoaendereco.idtipoendereco
               AND uf.iduf                         = pessoaendereco.iduf
               AND pais.idpais                     = pessoaendereco.idpais
               AND ROWNUM                          = 1
               AND pessoaendereco.dtexpiracao IS NULL
               AND contaendereco.idtipoenderecocobranca = ( SELECT MAX( contaendereco1.idtipoenderecocobranca )
                                                              FROM customer.contaendereco  contaendereco1
                                                             WHERE contaendereco1.idconta     = :lOraIdConta )
               AND conta.idconta                   = :lOraIdConta;
    }


	CONVIND(cOraidtipoendereco, iOraidtipoendereco);
	CONVIND(cOranmtipologradouro, iOranmtipologradouro);
	CONVIND(cOranmtitulologradouro, iOranmtitulologradouro);
	CONVIND(cOranmlogradouro, iOranmlogradouro);
	CONVIND(cOranmbairro, iOranmbairro);
	CONVIND(cOranmmunicipio, iOranmmunicipio);
	CONVIND(cOranrendereco, iOranrendereco);
	CONVIND(cOradsenderecocomplemento, iOradsenderecocomplemento);
	CONVIND(cOranrcep, iOranrcep);
	CONVIND(cOrasguf, iOrasguf);
	CONVIND(cOranmpais, iOranmpais);

	saida->createTag("EnderecoVO");
   	saida->addProp("xmlns","cliente.fo.vivo.com.br/vo");

	    saida->createTag("TipoEnderecoVO");
		    saida->addItem("idTipoEndereco", (char*)cOraidtipoendereco.arr);
    	saida->closeTag();
	
        saida->addItem("nmTipoLogradouro", (char*)cOranmtipologradouro.arr);
		saida->addItem("nmTituloLogradouro", (char*)cOranmtitulologradouro.arr);
		saida->addItem("nmLogradouro", (char*)cOranmlogradouro.arr);
		saida->addItem("nmBairro", (char*)cOranmbairro.arr);
		saida->addItem("nmMunicipio", (char*)cOranmmunicipio.arr);
		saida->addItem("nrEndereco", (char*)cOranrendereco.arr);
		saida->addItem("dsEnderecoComplemento", (char*)cOradsenderecocomplemento.arr);
		saida->addItem("nrCEP", (char*)cOranrcep.arr);
	    
        saida->createTag("UFVO");
		    saida->addItem("sgUF", (char*)cOrasguf.arr);
    	saida->closeTag();

        saida->createTag("PaisVO");
		    saida->addItem("nmPais", (char*)cOranmpais.arr);
    	saida->closeTag();
	saida->closeTag();


	ULOG_END("proCBuscarPorNrLinha()");    
}
