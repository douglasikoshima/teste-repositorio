#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"
#include "../../../commons/msgPadrao.h"

#include "../include/cWFAgrupamentoEstadoTpProc.h"
#include "../include/stWFAgrupamentoEstadoTpProc.h"

void sql_error_WFAgrupamentoEstadoTpProc(sqlca*sqlca);

// Declara as estruturas compatíveis ao ProC.
EXEC SQL BEGIN DECLARE SECTION;
	#include "../include/stWFAgrupamentoEstadoTpProc.h"
EXEC SQL END DECLARE SECTION;

bool proCIncluirWFAgrupamentoEstadoTpProc(st_AgrupamentoEstadoTpProc* dados, st_vlAgrupamentoEstadoTpProc* status, XMLGen* saida)
{
    ULOG_START("proCIncluirWFAgrupamentoEstadoTpProc()");
    
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AgrupamentoEstadoTpProc   oDados;
		struct st_vlAgrupamentoEstadoTpProc oStatus;

	EXEC SQL END DECLARE SECTION;

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAgrupamentoEstadoTpProc(&sqlca);

	EXEC SQL 
		INSERT INTO
			workflow.AgrupamentoEstadoTpProc
			(
				idAgrupamentoEstadoTpProc,
				idTipoProcesso,
				idAgrupamentoEstado,
				inEstadoInicial,
				nmURLDados,
				idUsuarioAlteracao,
				dtUltimaAlteracao
			)
			VALUES
			(
				:oDados.idAgrupamentoEstadoTpProc,
				:oDados.idTipoProcesso,
				:oDados.idAgrupamentoEstado,
				:oDados.inEstadoInicial,
				:oDados.nmURLDados,
				DECODE(:oStatus.idUsuarioAlteracao,-1,NULL,:oDados.idUsuarioAlteracao),
                TO_DATE(DECODE(:oStatus.dtUltimaAlteracao,-1,SYSDATE,:oDados.dtUltimaAlteracao),'DD/MM/YYYY HH24:MI')
			);

	saida->createTag("WFAgrupamentoEstadoTpProcVO");
		saida->addItem("idAgrupamentoEstadoTpProc", oDados.idAgrupamentoEstadoTpProc);
	saida->closeTag();

    ULOG_END("proCIncluirWFAgrupamentoEstadoTpProc()");

	return true;
}

bool proCAlterarWFAgrupamentoEstadoTpProc(st_AgrupamentoEstadoTpProc* dados, st_vlAgrupamentoEstadoTpProc* status, XMLGen* saida)
{
    ULOG_START("proCAlterarWFAgrupamentoEstadoTpProc()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AgrupamentoEstadoTpProc   oDados;
		struct st_vlAgrupamentoEstadoTpProc oStatus;

		char query[800] = "UPDATE workflow.AgrupamentoEstadoTpProc SET ";

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAgrupamentoEstadoTpProc(&sqlca);

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

	bool separa = false;

	if (status->idTipoProcesso != -1)
		montaUpdate("idTipoProcesso", oDados.idTipoProcesso, 1);

	if (status->idAgrupamentoEstado != -1)
		montaUpdate("idAgrupamentoEstado", oDados.idAgrupamentoEstado, 1);

	if (status->inEstadoInicial != -1)
		montaUpdate("inEstadoInicial", oDados.inEstadoInicial, 1);

	if (status->nmURLDados != -1)
		montaUpdate("nmURLDados", oDados.nmURLDados, 1);

	if (status->idUsuarioAlteracao != -1)
		montaUpdate("idUsuarioAlteracao", oDados.idUsuarioAlteracao, TIPO_INT);

	if (status->dtUltimaAlteracao != -1)
		montaUpdate("dtUltimaAlteracao", oDados.dtUltimaAlteracao, TIPO_DATAHORA);

	sprintf(query, "%s WHERE idAgrupamentoEstadoTpProc = %i", query, dados->idAgrupamentoEstadoTpProc);

	EXEC SQL EXECUTE IMMEDIATE :query;

    ULOG_END("proCAlterarWFAgrupamentoEstadoTpProc()");

	return true;
}

bool proCExcluirWFAgrupamentoEstadoTpProc(st_AgrupamentoEstadoTpProc* dados, st_vlAgrupamentoEstadoTpProc* status, XMLGen* saida)
{
    ULOG_START("proCExcluirWFAgrupamentoEstadoTpProc()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idAgrupamentoEstadoTpProc = dados->idAgrupamentoEstadoTpProc;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAgrupamentoEstadoTpProc(&sqlca);

	EXEC SQL 
		DELETE
			workflow.AgrupamentoEstadoTpProc
		WHERE
			idAgrupamentoEstadoTpProc = :idAgrupamentoEstadoTpProc;

    ULOG_END("proCExcluirWFAgrupamentoEstadoTpProc()");
   
	return true;
}

int proCConsultaProximoAgrupamento(st_AgrupamentoEstadoTpProc* dados, st_vlAgrupamentoEstadoTpProc* status)
{
    ULOG_START("proCConsultaProximoAgrupamento()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AgrupamentoEstadoTpProc   oDados;
		struct st_vlAgrupamentoEstadoTpProc oStatus;

		int idAgrupamentoEstadoTpProc = -1;
        short i_idAgrupamentoEstadoTpProc = -1;

    EXEC SQL END DECLARE SECTION;

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

    ULOG("SELECT agrupamentoDestino "
           "FROM workflow.ProximoEstadoV01 "
          "WHERE idAtividade = %d "
            "AND agrupamentoOrigem = %d "
            "AND ROWNUM < 2"
        ,oDados.idAtividade
        ,oDados.idAgrupamentoEstadoTpProc);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAgrupamentoEstadoTpProc(&sqlca);

	EXEC SQL
	SELECT
		AGRUPAMENTODESTINO
	INTO
		:idAgrupamentoEstadoTpProc:i_idAgrupamentoEstadoTpProc
	FROM
		WORKFLOW.PROXIMOESTADOV01
	WHERE
	    IDATIVIDADE = :oDados.idAtividade
	AND
        AGRUPAMENTOORIGEM = :oDados.idAgrupamentoEstadoTpProc
    AND
        ROWNUM < 2;

    if ( -1 == idAgrupamentoEstadoTpProc )
    {
        ULOG("'agrupamentoDestino' nao encontrado");
    }
    else
    {
        ULOG("'agrupamentoDestino' encontrado = %d" ,idAgrupamentoEstadoTpProc);
    }

    ULOG_END("proCConsultaProximoAgrupamento()");

	return idAgrupamentoEstadoTpProc;
}

int proCObterProxAgrupamentoDif(st_AgrupamentoEstadoTpProc* dados, st_vlAgrupamentoEstadoTpProc* status)
{
    ULOG_START("proCObterProxAgrupamentoDif()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AgrupamentoEstadoTpProc   oDados;
		struct st_vlAgrupamentoEstadoTpProc oStatus;

		int idAgrupamentoEstadoTpProc = -1;
        short i_idAgrupamentoEstadoTpProc = -1;

    EXEC SQL END DECLARE SECTION;

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

    ULOG("SELECT agrupamentoDestino "
           "FROM workflow.ProximoEstadoV01 "
          "WHERE idAtividade = %d "
            "AND agrupamentoOrigem = %d"
            "AND agrupamentoOrigem <> agrupamentodestino"
            "AND ROWNUM < 2"
        ,oDados.idAtividade
        ,oDados.idAgrupamentoEstadoTpProc);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAgrupamentoEstadoTpProc(&sqlca);

	EXEC SQL
	SELECT 
		AGRUPAMENTODESTINO
	INTO
		:idAgrupamentoEstadoTpProc:i_idAgrupamentoEstadoTpProc
	FROM 
		WORKFLOW.PROXIMOESTADOV01
	WHERE
	    IDATIVIDADE = :oDados.idAtividade
	AND 
        AGRUPAMENTOORIGEM = :oDados.idAgrupamentoEstadoTpProc
    AND
        AGRUPAMENTOORIGEM <> AGRUPAMENTODESTINO
    AND
        ROWNUM < 2;
		
    if ( -1 == idAgrupamentoEstadoTpProc )
    {
        ULOG("'agrupamentoDestino' nao encontrado");
    }
    else
    {
        ULOG("'agrupamentoDestino' encontrado = %d",idAgrupamentoEstadoTpProc);
    }

    ULOG_END("proCObterProxAgrupamentoDif()");

	return idAgrupamentoEstadoTpProc;
}

bool proCConsultaWFAgrupamentoEstadoTpProc(st_AgrupamentoEstadoTpProc* dados, st_vlAgrupamentoEstadoTpProc* status, char* order, XMLGen* saida)
{
    ULOG_START("proCConsultaWFAgrupamentoEstadoTpProc()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idAgrupamentoEstadoTpProc;
		int idTipoProcesso;
		int idAgrupamentoEstado;
		int inEstadoInicial;
		int nmURLDados;
		int idUsuarioAlteracao;
		VARCHAR	dtUltimaAlteracao[256];

		short i_idUsuarioAlteracao;
		short i_dtUltimaAlteracao;

		char query[1024] = "SELECT idAgrupamentoEstadoTpProc,idTipoProcesso"
                                 ",idAgrupamentoEstado,inEstadoInicial,nmURLDados"
                                 ",idUsuarioAlteracao"
                                 ",TO_CHAR(dtUltimaAlteracao,'DD/MM/YYYY HH24:MI')"
                             "FROM workflow.AgrupamentoEstadoTpProc ";

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAgrupamentoEstadoTpProc(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	bool separa = false;

	if (status->idAgrupamentoEstadoTpProc != -1) 
		montaWhere("idAgrupamentoEstadoTpProc", dados->idAgrupamentoEstadoTpProc, 1);

	if (status->idTipoProcesso != -1) 
		montaWhere("idTipoProcesso", dados->idTipoProcesso, 1);

	if (status->idAgrupamentoEstado != -1) 
		montaWhere("idAgrupamentoEstado", dados->idAgrupamentoEstado, 1);

	if (status->inEstadoInicial != -1) 
		montaWhere("inEstadoInicial", dados->inEstadoInicial, 1);

	if (status->nmURLDados != -1) 
		montaWhere("nmURLDados", dados->nmURLDados, 1);

	if (status->idUsuarioAlteracao != -1) 
		montaWhere("idUsuarioAlteracao", dados->idUsuarioAlteracao, TIPO_INT);

	if (status->dtUltimaAlteracao != -1) 
		montaWhere("dtUltimaAlteracao", dados->dtUltimaAlteracao, TIPO_DATAHORA);

	EXEC SQL PREPARE consultaAgrupamentoEstadoTpProc FROM :query;
	EXEC SQL DECLARE consulta CURSOR FOR consultaAgrupamentoEstadoTpProc;

	EXEC SQL OPEN consulta;

	while (true)
	{
		EXEC SQL FETCH consulta INTO 
									:idAgrupamentoEstadoTpProc, 
									:idTipoProcesso, 
									:idAgrupamentoEstado, 
									:inEstadoInicial, 
									:nmURLDados,
									:idUsuarioAlteracao:i_idUsuarioAlteracao,
									:dtUltimaAlteracao:i_dtUltimaAlteracao;

		CONVIND(dtUltimaAlteracao, i_dtUltimaAlteracao);

		saida->createTag("WFAgrupamentoEstadoTpProcVO");
			saida->addItem("idAgrupamentoEstadoTpProc", idAgrupamentoEstadoTpProc);
			saida->addItem("idTipoProcesso", idTipoProcesso);
			saida->addItem("idAgrupamentoEstado", idAgrupamentoEstado);
			saida->addItem("inEstadoInicial", inEstadoInicial);
			saida->addItem("nmURLDados", nmURLDados);
			saida->addItem("idUsuarioAlteracao", idUsuarioAlteracao);
			saida->addItem("dtUltimaAlteracao", (char*)dtUltimaAlteracao.arr);
		saida->closeTag();
	}

	EXEC SQL CLOSE consulta;

    ULOG_END("proCConsultaWFAgrupamentoEstadoTpProc()");

	return true;
}

void sql_error_WFAgrupamentoEstadoTpProc(sqlca*sqlca)
{
	throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
