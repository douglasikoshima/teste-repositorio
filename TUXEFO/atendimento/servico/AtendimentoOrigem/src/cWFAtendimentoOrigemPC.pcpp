#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"


#include "../include/cWFAtendimentoOrigem.h"
#include "../include/stWFAtendimentoOrigem.h"

void sql_error_WFAtendimentoOrigem(sqlca*sqlca);

	// Declara as estruturas compatíveis ao ProC.
    EXEC SQL BEGIN DECLARE SECTION;
		#include "../include/stWFAtendimentoOrigem.h"
    EXEC SQL END DECLARE SECTION;

long proCIncluirWFAtendimentoOrigem(st_AtendimentoOrigem* dados, st_vlAtendimentoOrigem* status,XMLDPR *xmlDpr)
{
    ULOG_START( "proCIncluirWFAtendimentoOrigem()" );

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AtendimentoOrigem   oDados;
		struct st_vlAtendimentoOrigem oStatus;

	EXEC SQL END DECLARE SECTION;

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));
	
    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoOrigem(&sqlca);

    ULOG("oDados.idAtendimento            = [%ld]",oDados.idAtendimento);
    ULOG("oDados.idAtendimentoOrigem      = [%ld]",oDados.idAtendimentoOrigem);
    ULOG("oDados.idTipoReaberturaProcesso = [%d]",oDados.idTipoReaberturaProcesso);
    ULOG("oDados.idUsuarioAlteracao       = [%d]",oDados.idUsuarioAlteracao);
    ULOG("oDados.dtUltimaAlteracao        = [%s]",oDados.dtUltimaAlteracao);
    
	EXEC SQL 
		INSERT INTO
			atendimento.AtendimentoOrigem
			(
				idAtendimento,
				idAtendimentoOrigem,
				idTipoReaberturaProcesso,
				idUsuarioAlteracao,
				dtUltimaAlteracao
			)
			VALUES
			(
				:oDados.idAtendimento,
				:oDados.idAtendimentoOrigem,
				:oDados.idTipoReaberturaProcesso,
				DECODE(:oStatus.idUsuarioAlteracao, -1, NULL, :oDados.idUsuarioAlteracao),
                TO_DATE(DECODE(:oStatus.dtUltimaAlteracao, -1, NULL, :oDados.dtUltimaAlteracao),'DD/MM/YYYY HH24:MI:SS')
			);

    // ==> SM324--DPR--DEZ/2006--Cassio
    if ( xmlDpr )
    {
        AtendimentoOrigemDPR atendimentoorigemdpr;

        atendimentoorigemdpr.setIdAtendimento(oDados.idAtendimento);
        atendimentoorigemdpr.setIdAtendimentoOrigem(oDados.idAtendimentoOrigem);
        atendimentoorigemdpr.setOpCode(OPCODE_INSERT);

        xmlDpr->atendimentoorigemvo.inserir(&atendimentoorigemdpr);
    }
    // <== SM324--DPR--DEZ/2006--Cassio

    ULOG_END( "proCIncluirWFAtendimentoOrigem()" );
	
    return oDados.idAtendimento;
}

bool proCAlterarWFAtendimentoOrigem(st_AtendimentoOrigem* dados, st_vlAtendimentoOrigem* status, XMLGen* saida)
{

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AtendimentoOrigem   oDados;
		struct st_vlAtendimentoOrigem oStatus;

		char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoOrigem(&sqlca);

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

	sprintf(query,"%s", "UPDATE atendimento.AtendimentoOrigem SET ");

	bool separa = false;


	if (status->idAtendimentoOrigem != -1)
		montaUpdate("idAtendimentoOrigem", oDados.idAtendimentoOrigem, 1);

	if (status->idUsuarioAlteracao != -1) 
		montaUpdate("idUsuarioAlteracao", oDados.idUsuarioAlteracao, TIPO_INT);

	if (status->dtUltimaAlteracao != -1) 
		montaUpdate("dtUltimaAlteracao", oDados.dtUltimaAlteracao, TIPO_DATAHORA);

	if (status->idTipoReaberturaProcesso != -1) 
		montaUpdate("idTipoReaberturaProcesso", oDados.idTipoReaberturaProcesso, 1);

	sprintf(query, "%s WHERE idAtendimento = %ld", query, dados->idAtendimento);

	EXEC SQL EXECUTE IMMEDIATE :query;

	return true;
}

bool proCExcluirWFAtendimentoOrigem(st_AtendimentoOrigem* dados, st_vlAtendimentoOrigem* status, XMLGen* saida)
{

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimento = dados->idAtendimento;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoOrigem(&sqlca);

	EXEC SQL 
		DELETE
			atendimento.AtendimentoOrigem
		WHERE
			idAtendimento = :idAtendimento;

	return true;
}

long proCObterNumWFAtendimentoOrigem(long sIdAtendimento)
{

    struct sqlca sqlca;
   
    EXEC SQL BEGIN DECLARE SECTION;

	long idAtendimento = sIdAtendimento;

	long numAtendimentos;
	short i_numAtendimentos = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoOrigem(&sqlca);

	EXEC SQL 
		SELECT 
			COUNT(IDATENDIMENTO)
		INTO
			numAtendimentos:i_numAtendimentos
		FROM 
			ATENDIMENTO.ATENDIMENTOORIGEM
		START WITH IDATENDIMENTO = :idAtendimento
		CONNECT BY PRIOR IDATENDIMENTOORIGEM = IDATENDIMENTO;
	
	return numAtendimentos;
}



/*
 *
 * OS 1013 - Expurgo
 *
 */
long proCObterNumWFAtendimentoOrigemEx( long sIdAtendimento )
{

    struct sqlca sqlca;
   
    EXEC SQL BEGIN DECLARE SECTION;

	long idAtendimento = sIdAtendimento;

	long numAtendimentos;
	short i_numAtendimentos = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoOrigem(&sqlca);

	EXEC SQL 
		SELECT 
			COUNT(IDATENDIMENTO)
		INTO
			numAtendimentos:i_numAtendimentos
		FROM 
			FOHIST_OW.ATENDIMENTOORIGEM
		START WITH IDATENDIMENTO = :idAtendimento
		CONNECT BY PRIOR IDATENDIMENTOORIGEM = IDATENDIMENTO;
	
	return numAtendimentos;
}



bool proCConsultaWFAtendimentoOrigem(st_AtendimentoOrigem* dados, st_vlAtendimentoOrigem* status, char* order, XMLGen* saida)
{

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimento;
		long idAtendimentoOrigem;
		int idTipoReaberturaProcesso;

		char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFEstado(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	sprintf(query,"SELECT idAtendimento, idAtendimentoOrigem, idTipoReaberturaProcesso FROM atendimento.AtendimentoOrigem ");

	bool separa = false;

	if (status->idAtendimento != -1) 
		montaWhere("idAtendimento", dados->idAtendimento, 1);

	if (status->idAtendimentoOrigem != -1) 
		montaWhere("idAtendimentoOrigem", dados->idAtendimentoOrigem, 1);

	if (status->idTipoReaberturaProcesso != -1)
		montaWhere("idTipoReaberturaProcesso", dados->idTipoReaberturaProcesso, 1);

	if (status->idUsuarioAlteracao != -1) 
		montaWhere("idUsuarioAlteracao", dados->idUsuarioAlteracao, TIPO_INT);

	if (status->dtUltimaAlteracao != -1) 
		montaWhere("dtUltimaAlteracao", dados->dtUltimaAlteracao, TIPO_DATAHORA);

	if (strlen(order) > 0) 
		sprintf( query, "%s ORDER BY %s ", query, order);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoOrigem(&sqlca);

	EXEC SQL PREPARE consultaAtendimentoOrigem FROM :query;
	EXEC SQL DECLARE consulta CURSOR FOR consultaAtendimentoOrigem;

	EXEC SQL OPEN consulta;

	while (true)
	{
		EXEC SQL FETCH consulta INTO 
									:idAtendimento, 
									:idAtendimentoOrigem, 
									:idTipoReaberturaProcesso;

		saida->createTag("WFAtendimentoOrigemVO");
			saida->addItem("idAtendimento", idAtendimento);
			saida->addItem("idAtendimentoOrigem", idAtendimentoOrigem);
			saida->addItem("idTipoReaberturaProcesso", idTipoReaberturaProcesso);
		saida->closeTag();
	}

	EXEC SQL CLOSE consulta;

	return true;

}

void sql_error_WFAtendimentoOrigem(sqlca*sqlca)
{
	throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
