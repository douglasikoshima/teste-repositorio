/**
 * 
 * @modulo  Workflow
 * @usecase Workflow
 * @author  Cassio M Garcia
 * @version $Revision: 1.1.118.1 $
 * @CVS     $Author: a5114878 $ - $Date: 2013/02/06 12:36:44 $
 **/

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"
#include "../../../commons/msgPadrao.h"

#include "../../AtendimentoCommonsRel/include/cWFComunsRelatorios.h"
#include "../include/cWFAtendimentoRel7.h"
#include "../include/stWFAtendimentoRel7.h"

void GerarValoresRelatorio(XMLGen *saida,char *hora,char *sgUF,int qtHoje,int qtData1,int qtData2);
void AcumularHorasAnteriores(MAP_NVZR &mapNvZr,MAP_TTNZR &mapTtNZr);
void menor2Datas(char *data1,char *data2,string &menorData);

char * rtrim(char *bf);

void WFAtdRel7SqlErro(sqlca*sqlca);

void proCObterDataHoje(st_AtendimentoRel7 *dados,st_vlAtendimentoRel7 *status)
{
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
      VARCHAR ddmmyyyy[256];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO WFAtdRel7SqlErro(&sqlca);

    if (dados)
    {
        EXEC SQL SELECT TO_CHAR(SYSDATE, 'DD/MM/YYYY') into :ddmmyyyy FROM DUAL;

        CONV(ddmmyyyy);
        strcpy(dados->dataHoje,(char*)ddmmyyyy.arr);
        status->dataHoje = 1;
    }
}

void proCObterHora(st_AtendimentoRel7 *dados)
{
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
      VARCHAR hhmm[256];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO WFAtdRel7SqlErro(&sqlca);

    if (dados)
    {
        EXEC SQL SELECT TO_CHAR(SYSDATE, 'HH24MI') into :hhmm FROM DUAL;

        CONV(hhmm);
        strcpy(dados->horaAtual,(char*)hhmm.arr);
    }
}

bool proCObtemWFAtendimentoRel7N0(st_AtendimentoRel7 *dados
                                 ,st_vlAtendimentoRel7 *status
                                 ,MAP_NVZR &mapNvZr
                                 ,MAP_TTNZR &mapTtNZr
                                 ,XMLGen* saida
                                 ,Paginacao * pPagina )
{
    ULOG_START( "proCObtemWFAtendimentoRel7N0()" );

    int PosPagina;
    int RegInicial;
    int ctRegs = 0;
    int pagina = pPagina->pageNumber; // Pagina Inicial

    struct sqlca sqlca;
    char idGrupo[8];
    //char nmGrupo[256];
    char horaContato[5];
    string query0;
    string menorData;
    int ctLinhas = 0;
    AgrupamentoNivelZero anz;
    //TotaisAgrupamentoNivelZero tnz;
    string chave;
    MAP_NVZR::iterator itMapNvZr;
    MAP_TTNZR::iterator itMapTtNZr;

    EXEC SQL BEGIN DECLARE SECTION;

        VARCHAR data[14];
        VARCHAR hora[7];
        VARCHAR sgUF[4];
        int quantidade;

        char *query;

        short i_data;
        short i_sgUF;
        short i_hora;

    EXEC SQL END DECLARE SECTION;

    menor2Datas(dados->data1,dados->data2,menorData);

    query0 +=" SELECT " // /*+ NO_CPU_COSTING */
                "TO_CHAR(a.dtabertura, 'DD/MM/YYYY') data, "
                "TO_CHAR(a.dtabertura, 'HH24:MI') AS hora, "
                "uf.sgUF sgUF, "
                "SUM(a.qtpalitagem) AS quantidade "
            "FROM "
                "atendimento.auxatdpalitagem a, "
                "apoio.uf uf "
            "WHERE "
                "a.idUF = uf.idUF "
                "AND ( "
                    "(a.dtabertura BETWEEN TO_DATE('";
                    query0 += dados->data1;
                    query0 += " 00:00:00','DD/MM/YYYY HH24:MI:SS') AND TO_DATE('";
                    query0 += dados->data1;
                    query0 += " 23:59:59','DD/MM/YYYY HH24:MI:SS') ) " 
                     "OR (a.dtabertura BETWEEN TO_DATE('";
                    query0 += dados->data2;
                    query0 += " 00:00:00','DD/MM/YYYY HH24:MI:SS') AND TO_DATE('";
                    query0 += dados->data2;
                    query0 += " 23:59:59','DD/MM/YYYY HH24:MI:SS') ) "
                     "OR (a.dtabertura BETWEEN TO_DATE('";
                    query0 += dados->dataHoje;
                    query0 += " 00:00:00','DD/MM/YYYY HH24:MI:SS') AND TO_DATE('";
                    query0 += dados->dataHoje;
                    query0 += " 23:59:59','DD/MM/YYYY HH24:MI:SS') ) ) ";

    if ( status->idGrupo != -1 )
    {
        sprintf(idGrupo,"%d",dados->idGrupo);
        query0 += " AND a.idGrupo = ";
        query0 += idGrupo;
    }

    query0 += " GROUP BY a.dtabertura, uf.sgUF ";

    ULOG( (char*)query0.c_str() );

    query = (char*)query0.c_str();

    saida->createTag("WFRelatorioDinamicoVO");
        saida->addProp("xmlns", "workflow.fo.vivo.com.br/vo");

        saida->addItem("dsTituloRelatorio", "Palitagem nivel 0");

        saida->addItem("ultimoNivel", NAO);

        saida->createTag("ColunasRelatorio");
            saida->createTag("idColuna");
            saida->closeTag();
            saida->addItem("dsColuna","Hora");
        saida->closeTag();

        saida->createTag("ColunasRelatorio");
            saida->addItem("idColuna","sgUF");
            saida->addItem("dsColuna","Regional");
        saida->closeTag();

        saida->createTag("ColunasRelatorio");
            saida->createTag("idColuna");
            saida->closeTag();
            saida->addItem("dsColuna",dados->dataHoje);
        saida->closeTag();

        saida->createTag("ColunasRelatorio");
            saida->createTag("idColuna");
            saida->closeTag();
            saida->addItem("dsColuna",dados->data1);
        saida->closeTag();

        saida->createTag("ColunasRelatorio");
            saida->createTag("idColuna");
            saida->closeTag();
            saida->addItem("dsColuna",dados->data2);
        saida->closeTag();

    EXEC SQL WHENEVER SQLERROR DO WFAtdRel7SqlErro(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL PREPARE recebeQueryNv0 FROM :query;
    EXEC SQL DECLARE consultaNv0 CURSOR FOR recebeQueryNv0;

    EXEC SQL OPEN consultaNv0;

    /*

    A rotina no fetch logo abaixo agrega em mapas na memória os totais por hora/uf
    e totais por hora e é equivalente ao sql abaixo. A razão da substituição do
    processamento de consolidação na aplicação ao invés de no Oracle é que o sql
    abaixo apesar de funcionar corretamente é muitas vezes mais lento e estava
    comprometendo o funcionamento do cliente Java chamador deste serviço

    SELECT hora,sgUF,hoje,data1,data2 
    FROM 
        ( 
            SELECT DECODE(ar7v01.hora,NULL,'Total',ar7v01.hora) AS hora
                ,DECODE(ar7v01.sgUF,NULL,'Total',ar7v01.sgUF) AS sgUF
                ,NVL(SUM(a.quantidade),0) AS hoje
                ,NVL(SUM(b.quantidade),0) AS data1
                ,NVL(SUM(c.quantidade),0) AS data2
                FROM 
            ( 
            SELECT data,hora,sgUF,idGrupo,nmGrupo,quantidade 
            FROM atendimento.AtendimentoRelatorio7v01 
            GROUP BY data,hora,sgUF,idGrupo,nmGrupo,quantidade 
            ) ar7v01 
            ,( 
                SELECT data,hora,sgUF,idGrupo,nmGrupo,sum(quantidade) AS quantidade 
                FROM atendimento.AtendimentoRelatorio7v01
                WHERE data = TRUNC(SYSDATE) 
                GROUP BY data,hora,sgUF,idGrupo,nmGrupo 
            ) a 
            ,( 
                SELECT data,hora,sgUF,idGrupo,nmGrupo,sum(quantidade) AS quantidade 
                FROM atendimento.AtendimentoRelatorio7v01
                WHERE data = TRUNC(TO_DATE('02/12/2004','DD/MM/YYYY')) 
                GROUP BY data,hora,sgUF,idGrupo,nmGrupo 
            ) b 
            ,( 
                SELECT data,hora,sgUF,idGrupo,nmGrupo,sum(quantidade) AS quantidade 
                FROM atendimento.AtendimentoRelatorio7v01
                WHERE data = TRUNC(TO_DATE('13/12/2004','DD/MM/YYYY')) 
                GROUP BY data,hora,sgUF,idGrupo,nmGrupo 
            ) c 
        WHERE ar7v01.data = a.data (+) 
        AND ar7v01.data = b.data (+) 
        AND ar7v01.data = c.data (+) 
        AND ar7v01.hora = a.hora (+) 
        AND ar7v01.hora = b.hora (+) 
        AND ar7v01.hora = c.hora (+) 
        AND ar7v01.sgUF = a.sgUF (+) 
        AND ar7v01.sgUF = b.sgUF (+) 
        AND ar7v01.sgUF = c.sgUF (+) 
        AND ar7v01.nmGrupo = a.nmGrupo (+) 
        AND ar7v01.nmGrupo = b.nmGrupo (+) 
        AND ar7v01.nmGrupo = c.nmGrupo (+) 
        AND ar7v01.idGrupo = a.idGrupo (+) 
        AND ar7v01.idGrupo = b.idGrupo (+) 
        AND ar7v01.idGrupo = c.idGrupo (+) 
        HAVING ( (NVL(SUM(a.quantidade),0) > 0) OR (NVL(SUM(b.quantidade),0) > 0) OR (NVL(SUM(c.quantidade),0) > 0) ) 
        GROUP BY GROUPING SETS ((ar7v01.hora,ar7v01.sgUF),ROLLUP((ar7v01.hora))) 
        ) r 
    ORDER BY hora desc,sgUF,hoje,data1,data2
    */

    PosPagina =  pagina * NRO_MAX_REGS;
    RegInicial = PosPagina - NRO_MAX_REGS;
    int regCorrente = -1;

    while ( true )
    {
        EXEC SQL FETCH consultaNv0 INTO :data:i_data,
                                        :hora:i_hora,
                                        :sgUF:i_sgUF,
                                        :quantidade;

        regCorrente++;

        ULOG( "Registro corrente [%d], registro inicial [%d]",regCorrente,RegInicial );

        if ( regCorrente < RegInicial )
        {
            ULOG( "Buscando proximo registro..." );
            continue;
        }
        
        ctRegs++;

        ULOG( "Enviando registro [%d], Nro. Maximo de Registros por pagina [%d]",ctRegs,NRO_MAX_REGS );

        if ( ctRegs > NRO_MAX_REGS )
        {
            pPagina->hasNext = 1;
            ULOG( "*** Nro. Maximo de Registros por pagina [%d] enviado",NRO_MAX_REGS );
            ULOG( "*** Ajustando hasNext para [%d]",pPagina->hasNext );
            break;
        }  
        
        ULOG( "Somando valores..." );

        CONVIND(data,i_data);
        CONVIND(hora,i_hora);
        CONVIND(sgUF,i_sgUF);

        // Sumariza as quantidades de HOJE, DATA1 e DATA2 por HORA e SGUF
        chave = (string)((char*)hora.arr) + (string)((char*)sgUF.arr);

        sprintf(horaContato,"%.2s%.2s",hora.arr,hora.arr+3);

        itMapNvZr = mapNvZr.find(chave);

        ULOG( "data = %s, hora = %s"
                        ,(char*)data.arr
                        ,(char*)hora.arr);

        if ( itMapNvZr == mapNvZr.end() )
        {
            sprintf(anz.hora,"%.*s",sizeof(anz.hora)-1,(char*)hora.arr);
            sprintf(anz.sgUF,"%.*s",sizeof(anz.sgUF)-1,(char*)sgUF.arr);

            if ( !strcmp((char*)data.arr, dados->data1) )
            {
                anz.qtdeData1 = quantidade;
                anz.qtdeData2 = anz.qtdeHoje = 0;
            }

            if ( !strcmp((char*)data.arr, dados->data2) )
            {
                anz.qtdeData2 = quantidade;
                anz.qtdeData1 = anz.qtdeHoje = 0;
            }

            if ( !strcmp((char*)data.arr, dados->dataHoje) )
            {
                if ( strcmp(horaContato,dados->horaAtual) <= 0 )
                {
                    anz.qtdeHoje = quantidade;
                    anz.qtdeData1 = anz.qtdeData2 = 0;
                }
                else
                {
                    anz.qtdeHoje = anz.qtdeData1 = anz.qtdeData2 = 0;
                }
            }

            mapNvZr[chave] = anz;
        }
        else
        {
            if ( !strcmp((char*)data.arr, dados->data1) )
            {
                itMapNvZr->second.qtdeData1 += quantidade;
            }

            if ( !strcmp((char*)data.arr, dados->data2) )
            {
                itMapNvZr->second.qtdeData2 += quantidade;
            }

            if ( !strcmp((char*)data.arr, dados->dataHoje) )
            {
                if ( strcmp(horaContato,dados->horaAtual) <= 0 )
                {
                    itMapNvZr->second.qtdeHoje += quantidade;
                }
            }
        }
/*

        // Totais agrupados por hora para as datas de HOJE, DATA1 e DATA2
        chave = (string)((char*)hora.arr+1);

        itMapTtNZr = mapTtNZr.find(chave);

        if ( itMapTtNZr == mapTtNZr.end() )
        {
            sprintf(tnz.hora,"%.*s",sizeof(tnz.hora)-1,hora.arr+1);

            if ( !strcmp((char*)data.arr, dados->data1) )
            {
                tnz.qtdeData1 = quantidade;
                tnz.qtdeData2 = tnz.qtdeHoje = 0;
            }
            else if ( !strcmp((char*)data.arr, dados->data2) )
            {
                tnz.qtdeData2 = quantidade;
                tnz.qtdeData1 = tnz.qtdeHoje = 0;
            }
            else
            {
                tnz.qtdeHoje = quantidade;
                tnz.qtdeData1 = tnz.qtdeData2 = 0;
            }

            mapTtNZr[chave] = tnz;
        }
        else
        {
            if ( !strcmp((char*)data.arr, dados->data1) )
            {
                itMapTtNZr->second.qtdeData1 += quantidade;
            }
            else if ( !strcmp((char*)data.arr, dados->data2) )
            {
                itMapTtNZr->second.qtdeData2 += quantidade;
            }
            else
            {
                itMapTtNZr->second.qtdeHoje += quantidade;
            }
        }
*/

        ctLinhas++;
    }

    EXEC SQL CLOSE consultaNv0;

    // Gera XML de saida
    AcumularHorasAnteriores(mapNvZr,mapTtNZr);

    long sm=mapNvZr.size();

    itMapNvZr = mapNvZr.end();

    if ( sm && itMapNvZr != mapNvZr.begin()  )
    {
        itMapNvZr--;
        chave = (string)(itMapNvZr->second.hora);
    }

    while ( sm )
    {
        if ( strcmp(itMapNvZr->second.hora,chave.c_str()) )
        { // quebrou hora

            itMapTtNZr =  mapTtNZr.find(chave);

            if ( itMapTtNZr == mapTtNZr.end() )
            { // não encontrou total para o agrupamento hora/sgUF

               ULOG("chave '%s' nao encontrada no mapa de totais por hora"
                        ,chave);

                return false;
            }

            chave = (string)(itMapNvZr->second.hora);

            GerarValoresRelatorio(saida
                                 ,itMapTtNZr->second.hora
                                 ,DESC_TOTAL
                                 ,itMapTtNZr->second.qtdeHoje
                                 ,itMapTtNZr->second.qtdeData1
                                 ,itMapTtNZr->second.qtdeData2);
        }

        GerarValoresRelatorio(saida
                             ,itMapNvZr->second.hora
                             ,itMapNvZr->second.sgUF
                             ,itMapNvZr->second.qtdeHoje
                             ,itMapNvZr->second.qtdeData1
                             ,itMapNvZr->second.qtdeData2);
        itMapNvZr--;
        sm--;
    }

    if ( chave.length() )
    {
        itMapTtNZr =  mapTtNZr.find(chave);

        if ( itMapTtNZr == mapTtNZr.end() )
        { // não encontrou total para o agrupamento hora/sgUF

           ULOG( "chave '%s' nao encontrada no mapa de totais por hora"
                    ,chave);

            return false;
        }

        GerarValoresRelatorio(saida
                             ,itMapTtNZr->second.hora
                             ,DESC_TOTAL
                             ,itMapTtNZr->second.qtdeHoje
                             ,itMapTtNZr->second.qtdeData1
                             ,itMapTtNZr->second.qtdeData2);
    }

    saida->createTag( "Paginacao" );
        saida->addProp("xmlns", "cliente.fo.vivo.com.br/vo");
        saida->addItem( "pageNumber",pPagina->pageNumber );
        saida->addItem( "hasNext",pPagina->hasNext );
    saida->closeTag();

    saida->closeTag();


    ULOG( "Nivel zero carregou %d linhas",ctLinhas );

    ULOG_END( "proCObtemWFAtendimentoRel7N0()" );

    return true;
}

bool proCCarregarArvoreContatos(st_AtendimentoRel7 *dados
                               ,st_vlAtendimentoRel7 *status
                               ,XMLGen* saida
                               ,MAP_AC &mapAC
                               ,MAP_TAB_RAIZ &mapRaiz
                               ,int &nivelMax)
{
    struct sqlca sqlca;
    ArvoreContatos ac;
    int hojeOkay = 0;

    EXEC SQL BEGIN DECLARE SECTION;

        char *query2;

        int idContatoPai[1000];
        int idContato[1000];
        int nivel[1000];

        short i_nmContato[1000];
        short i_hoje[1000];

        VARCHAR nmContato[1000][256];
        VARCHAR hoje[1000][256];

        int rows_to_fetch, rows_before, rows_this_time;
        
    EXEC SQL END DECLARE SECTION;

    rows_to_fetch = 1000;   // numero de linhas para cada fetch
    rows_before = 0;      // numero de linhas carregadas ate o ultimo fetch 
    rows_this_time = 1000;  // numero de linhas carregadas no fetch

    query2 = " SELECT " // /*+ NO_CPU_COSTING */
                   "LEVEL, "
                   "contatohierarquia.IDCONTATOPAI idcontatopai, "
                   "contatohierarquia.IDCONTATO idcontato, "
                   "nomecontato.NMCONTATO nmcontato, "
                   "TO_CHAR (SYSDATE, 'DD/MM/YYYY') "
              "FROM "
                   "contatoadm.contatohierarquia contatohierarquia, "
                   "contatoadm.contato contatofilho, "
                   "contatoadm.nomecontato nomecontato "
              "WHERE "
                   "contatofilho.IDCONTATO = contatohierarquia.IDCONTATO "
                   "AND nomecontato.idnomecontato = contatofilho.IDNOMECONTATO "
        "START WITH contatohierarquia.IDCONTATOPAI = 1 "
        "CONNECT BY PRIOR contatohierarquia.IDCONTATO = contatohierarquia.IDCONTATOPAI "
          "GROUP BY LEVEL, "
                   "contatohierarquia.IDCONTATOPAI, "
                   "contatohierarquia.IDCONTATO, "
                   "nomecontato.NMCONTATO, "
                   "TO_CHAR (SYSDATE, 'DD/MM/YYYY') "
          "ORDER BY LEVEL, contatohierarquia.IDCONTATOPAI, contatohierarquia.IDCONTATO";


    ULOG( query2 );

    EXEC SQL WHENEVER SQLERROR DO WFAtdRel7SqlErro(&sqlca);

    EXEC SQL DECLARE recebeQuery2 STATEMENT;

    EXEC SQL PREPARE recebeQuery2 FROM :query2;
    
    EXEC SQL DECLARE consulta2 CURSOR FOR recebeQuery2;

    EXEC SQL OPEN consulta2;


    // Troca a diretiva de tratamento de erro para o fetch com host array
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    nivelMax = 0;

    while (rows_this_time == rows_to_fetch) 
    { 
        EXEC SQL FOR :rows_to_fetch FETCH consulta2 INTO :nivel,
                                                         :idContatoPai, 
                                                         :idContato,
                                                         :nmContato:i_nmContato,
                                                         :hoje:i_hoje;

        rows_this_time = sqlca.sqlerrd[2] - rows_before; 
        rows_before = sqlca.sqlerrd[2]; 

        ULOG("FETCH: %d linhas carregadas.", rows_before);

        for(int icount=0; icount < rows_this_time; icount++) 
        {
            CONVIND(nmContato[icount],i_nmContato[icount]);
            CONVIND(hoje[icount],i_hoje[icount]);

            // Mapa representando a árvore de contatos
            ac.idContatoPai = idContatoPai[icount];
            ac.idContato = idContato[icount];
            ac.nivel = nivel[icount];
            ac.possuiDescendente = false;
            strcpy(ac.nmContato, (char*)nmContato[icount].arr);

            mapAC[idContato[icount]] = ac;

            // Mapa com lista de todos os idContatoPai lidos
            // (valores repetidos não são inseridos)
            if ( mapRaiz.find(idContatoPai[icount]) == mapRaiz.end() )
            {
                mapRaiz[idContatoPai[icount]] = 0;
            }
    
            // salva o maior nível lido até o momento
            if ( nivel[icount] > nivelMax ) nivelMax = nivel[icount];
        }

        ULOG("MAP mapAC: %d linhas carregadas.", rows_before);
    }
 
    EXEC SQL CLOSE consulta2;

    ULOG( "Lidos %d itens da arvore de contato",mapAC.size() );

    ULOG( "Encontrados %d idContatoPai distintos",mapRaiz.size() );

    ULOG( "nivelMax=%d",nivelMax );

    sprintf(dados->dataHoje,"%.*s",sizeof(dados->dataHoje)-1,rtrim((char*)hoje[0].arr));
    status->dataHoje = 1;

    return true;
}

bool proCCarregarPalitagem(st_AtendimentoRel7 *dados, st_vlAtendimentoRel7 *status, XMLGen* saida,VEC_PAL &vecPal)
{
    string menorData;
    struct sqlca sqlca;
    Palitagem pal;
    char idGrupoQuery[12];
    char nmGrupoQuery[256];
    string query;

    EXEC SQL BEGIN DECLARE SECTION;

        char *query3;

        int idContato[1000];
        //int idGrupo[1000];
        int quantidade[1000];

        short i_data[1000];
        short i_hora[1000];
        short i_sgUF[1000];
        //short i_nmGrupo[1000];

        VARCHAR data[1000][11];
        VARCHAR hora[1000][7];
        VARCHAR sgUF[1000][3];
        //VARCHAR nmGrupo[1000][256];

        int rows_to_fetch, rows_before, rows_this_time;

    EXEC SQL END DECLARE SECTION;

    rows_to_fetch = 1000;   // numero de linhas para cada fetch
    rows_before = 0;      // numero de linhas carregadas ate o ultimo fetch 
    rows_this_time = 1000;  // numero de linhas carregadas no fetch

    menor2Datas(dados->data1,dados->data2,menorData);

    query= " SELECT " // /*+ NO_CPU_COSTING */
                "TO_CHAR(a.dtabertura, 'DD/MM/YYYY') data, "
                "TO_CHAR(a.dtabertura, 'HH24:MI') AS hora, "
                "uf.sgUF sgUF, "
                "a.idContato idContato, "
                "SUM(a.QTPALITAGEM) AS quantidade "
            "FROM "
                "atendimento.auxatdpalitagem a, "
                "apoio.uf uf, "
                "acesso.grupo grupo "
            "WHERE "
                "a.idUF = uf.idUF "
                "AND grupo.idgrupo = a.idgrupo "
                "AND ( "
                    "(a.dtabertura BETWEEN TO_DATE('";
                    query += dados->data1;
                    query += " 00:00:00','DD/MM/YYYY HH24:MI:SS') AND TO_DATE('";
                    query += dados->data1;
                    query += " 23:59:59','DD/MM/YYYY HH24:MI:SS') ) " 
                     "OR (a.dtabertura BETWEEN TO_DATE('";
                    query += dados->data2;
                    query += " 00:00:00','DD/MM/YYYY HH24:MI:SS') AND TO_DATE('";
                    query += dados->data2;
                    query += " 23:59:59','DD/MM/YYYY HH24:MI:SS') ) "
                     "OR (a.dtabertura BETWEEN TO_DATE('";
                    query += dados->dataHoje;
                    query += " 00:00:00','DD/MM/YYYY HH24:MI:SS') AND TO_DATE('";
                    query += dados->dataHoje;
                    query += " 23:59:59','DD/MM/YYYY HH24:MI:SS') ) ) ";

    if ( 1 == status->sgUF )
    {
        query+= "AND uf.sgUF = '";
        query+= dados->sgUF;
        query+= "' ";
    }

    query+="AND a.idContato > 1 ";

    if ( 1 == status->idGrupo )
    {
        sprintf(idGrupoQuery,"%d ",dados->idGrupo);
        query += " AND a.idGrupo = ";
        query += idGrupoQuery;
    }

    if ( 1 == status->nmGrupo )
    {
        sprintf(nmGrupoQuery,"'%.*s' ",sizeof(nmGrupoQuery)-1,dados->nmGrupo);
        query += " AND grupo.nmGrupo = ";
        query += nmGrupoQuery;
    }

    query += "  GROUP BY a.dtabertura, uf.sgUF, a.idContato "
             "  ORDER BY hora DESC ";

    query3 = (char*)query.c_str();

    ULOG( query3 );

    EXEC SQL WHENEVER SQLERROR DO WFAtdRel7SqlErro(&sqlca);

    EXEC SQL DECLARE recebeQuery3 STATEMENT;

    EXEC SQL PREPARE recebeQuery3 FROM :query3;
    
    EXEC SQL DECLARE consulta3 CURSOR FOR recebeQuery3;

    EXEC SQL OPEN consulta3;

    // Troca a diretiva de tratamento de erro para o fetch com host array
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    while (rows_this_time == rows_to_fetch) 
    { 
        EXEC SQL FOR :rows_to_fetch FETCH consulta3 INTO :data:i_data,
                                                         :hora:i_hora,
                                                         :sgUF:i_sgUF,
                                                         :idContato,
                                                         :quantidade;
        rows_this_time = sqlca.sqlerrd[2] - rows_before; 
        rows_before = sqlca.sqlerrd[2]; 

        ULOG( "FETCH: %d linhas carregadas.", rows_before );

        for(int icount=0; icount < rows_this_time; icount++) 
        {
            CONVIND(data[icount],i_data[icount]);
            CONVIND(hora[icount],i_hora[icount]);
            CONVIND(sgUF[icount],i_sgUF[icount]);

            pal.nmContato[0] = '\0';
            pal.idContatoPai = 0;
            pal.idContato = idContato[icount];
            pal.quantidade = quantidade[icount];
            pal.possuiDescendente = false;

            strncpy(pal.data, (char*)data[icount].arr, sizeof(pal.data)-1); pal.data[sizeof(pal.data)-1] = '\0';
            strncpy(pal.hora, (char*)hora[icount].arr, sizeof(pal.hora)-1); pal.hora[sizeof(pal.hora)-1] = '\0';
            strncpy(pal.sgUF, (char*)sgUF[icount].arr, sizeof(pal.sgUF)-1); pal.sgUF[sizeof(pal.sgUF)-1] = '\0';

            vecPal.push_back(pal);
        }

        ULOG("VECTOR vecPal: %d linhas carregadas.", rows_before);

    // Este log foi desligado para redução de log e aumento de performance
    /*        ULOG( "idContatoPai=%d,idContato=%d,data=%s,hora=%s,UF=%s,nmGrupo=%s",
                    pal.idContatoPai,pal.idContato,pal.data,pal.hora,pal.sgUF,pal.nmGrupo);
    */
    }
 
    EXEC SQL CLOSE consulta3;

    return true;
}

void GerarValoresRelatorio(XMLGen *saida,char *hora,char *sgUF,int qtHoje,int qtData1,int qtData2)
{
    if ( qtHoje || qtData1 || qtData2 )
    { // não gera saida se todos os totais da linha estiverem zerados
        saida->createTag("ValoresRelatorio");

            saida->createTag("ValorColuna");
                saida->addItem("valor",hora);
            saida->closeTag();

            saida->createTag("ValorColuna");
                saida->addItem("idValor",sgUF);
                saida->addItem("valor",sgUF);
            saida->closeTag();

            saida->createTag("ValorColuna");
                saida->addItem("valor",qtHoje);
            saida->closeTag();

            saida->createTag("ValorColuna");
                saida->addItem("valor",qtData1);
            saida->closeTag();

            saida->createTag("ValorColuna");
                saida->addItem("valor",qtData2);
            saida->closeTag();

            saida->addItem("inProximoNivel",1);

        saida->closeTag();
   }
}

void AcumularHorasAnteriores(MAP_NVZR &mapNvZr,MAP_TTNZR &mapTtNZr)
{
    ULOG_START( "AcumularHorasAnteriores()" );

    long sm;
    MAP_NVZR::iterator itMapNvZr;
    MAP_NVZR::iterator itMapNvZr2;
    MAP_TTNZR::iterator itMapTtNZr;
    string chave;
    TotaisAgrupamentoNivelZero tnz;


    itMapNvZr = mapNvZr.end();
    itMapNvZr--;
    sm=mapNvZr.size();

    ULOG( "===> Antes" );

    while ( sm )
    {
        ULOG( "hora=%s,sgUF=%s,qtdeHoje=%d,qtdeData1=%d,qtdeData2=%d"
                    ,itMapNvZr->second.hora
                    ,itMapNvZr->second.sgUF
                    ,itMapNvZr->second.qtdeHoje
                    ,itMapNvZr->second.qtdeData1
                    ,itMapNvZr->second.qtdeData2 );

        itMapNvZr--;
        sm--;
    }

    itMapNvZr = mapNvZr.end();
    itMapNvZr--;
    sm=mapNvZr.size();

    while ( sm )
    {
        itMapNvZr2 = itMapNvZr;
        itMapNvZr2--;

        long sm2 = sm - 1L;

        while ( sm2 > 0L )
        {
            if ( memcmp(itMapNvZr->second.sgUF,itMapNvZr2->second.sgUF,2) == 0 )
            {
                if ( itMapNvZr->second.qtdeHoje )
                {
                    itMapNvZr->second.qtdeHoje += itMapNvZr2->second.qtdeHoje;
                }
                
                if ( itMapNvZr->second.qtdeData1 )
                {
                    itMapNvZr->second.qtdeData1 += itMapNvZr2->second.qtdeData1;
                }

                if ( itMapNvZr->second.qtdeData2 )
                {
                    itMapNvZr->second.qtdeData2 += itMapNvZr2->second.qtdeData2;
                }
            }

            itMapNvZr2--;
            sm2--;
        }

        itMapNvZr--;
        sm--;
    }

    ULOG( "==> DEPOIS" );

    itMapNvZr = mapNvZr.end();
    itMapNvZr--;
    sm=mapNvZr.size();

    while ( sm )
    {
        ULOG( "hora=%s,sgUF=%s,qtdeHoje=%d,qtdeData1=%d,qtdeData2=%d"
                    ,itMapNvZr->second.hora
                    ,itMapNvZr->second.sgUF
                    ,itMapNvZr->second.qtdeHoje
                    ,itMapNvZr->second.qtdeData1
                    ,itMapNvZr->second.qtdeData2 );

        itMapNvZr--;
        sm--;
    }

    // Totais por hora
    itMapNvZr = mapNvZr.begin();

    while ( itMapNvZr != mapNvZr.end() )
    {
        chave = (string)(itMapNvZr->second.hora);

        itMapTtNZr = mapTtNZr.find(chave);

        if ( itMapTtNZr == mapTtNZr.end() )
        {
            strcpy(tnz.hora,itMapNvZr->second.hora);
            tnz.qtdeHoje = itMapNvZr->second.qtdeHoje;
            tnz.qtdeData1 = itMapNvZr->second.qtdeData1;
            tnz.qtdeData2 = itMapNvZr->second.qtdeData2;

            mapTtNZr[chave] = tnz;
        }
        else
        {
            itMapTtNZr->second.qtdeHoje += itMapNvZr->second.qtdeHoje;
            itMapTtNZr->second.qtdeData1 += itMapNvZr->second.qtdeData1;
            itMapTtNZr->second.qtdeData2 += itMapNvZr->second.qtdeData2;
        }

        itMapNvZr++;
    }

    ULOG_END( "AcumularHorasAnteriores()" );
}

char * rtrim(char *bf)
{
    char *p = bf ? strchr(bf,' ') : 0;

    if ( p ) *p = 0;

    return bf;
}

void WFAtdRel7SqlErro(sqlca*sqlca)
{
    throw new TuxBasicOraException(sqlca->sqlcode
                                  ,sqlca->sqlerrm.sqlerrmc
                                  ,sqlca->sqlerrm.sqlerrml);
}

void menor2Datas(char *data1,char *data2,string &menorData)
{
    char dt1[10],dt2[10];

    sprintf(dt1,"%.4s%.2s%.2s",data1+6,data1+3,data1);
    sprintf(dt2,"%.4s%.2s%.2s",data2+6,data2+3,data2);

    if ( strcmp(dt1,dt2) < 0 )
    {
        menorData = data1;
    }
    else
    {
        menorData = data2;
    }
}