/**
 * 
 * @modulo  Workflow
 * @usecase Workflow
 * @author  Cassio M Garcia
 * @version $Revision: 1.1.2.1 $
 * @CVS     $Author: a5116174 $ - $Date: 2011/08/12 17:11:33 $
 **/

#undef SQLCA
#define SQLCA_NONE
#include <sqlca.h>
#include <sqlda.h>

#include "../../../commons/queryMacro.h"
#include "../../../commons/msgPadrao.h"

#include "../../../commons/definesAtendimento.h"
#include "../include/cWFAtendimentoRelPesqSatisfa.h"

void WFAtdPsqSqlErro(sqlca*sqlca);
void proCGetPerguntas( int sIdQuestionario, XMLGen* saida );
void proCGetRespostas( int sIdPergunta, XMLGen* saida );
void proCGetSaltoResposta( int sIdResposta, XMLGen* saida );

// int proCGetUfOperadora( int sIdAtendimento)
// {
//     ULOG("> proCGetUfOperadora()");
// 
//     int ret = 1;
// 
//     struct sqlca sqlca;
// 
//     EXEC SQL BEGIN DECLARE SECTION;
//         long idAtendimento = sIdAtendimento;
//         int idUfOperadora;
// 
//         short i_idUfOperadora = -1;
//     EXEC SQL END DECLARE SECTION;
// 
//     EXEC SQL WHENEVER SQLERROR DO WFAtdPsqSqlErro(&sqlca);
//     //
//     // =========================================================================
//     // Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
//     // Este código desativou o uso da view ATENDIMENTO.ATENDIMENTOUFOPERADORAV01
//     // pois a mesma era usada somente neste ponto no sistema.
//     // =========================================================================
//     //
//     EXEC SQL
//         SELECT
//             ATENDIMENTO.IDUFOPERADORA
//         INTO 
//             idUfOperadora:i_idUfOperadora
//         FROM
//             ATENDIMENTO.ATENDIMENTO
//         WHERE
//             IDATENDIMENTO = :idAtendimento;
// 
//     if ( i_idUfOperadora >= 0 )
//     {
//         ret = idUfOperadora;
//     }
//     
//     ULOG("< proCGetUfOperadora()");
// 
//     return ret;
// }

void proCGetQuestionario( int sIdContato, int sIdTipoPessoa, int sIdUfOperadora, XMLGen* saida )
{
    ULOG_START("proCGetQuestionario()");

    if ( 0 == saida )
    {
        throw new TuxException(TUXEXCE_PONTEIRO_INVALIDO,"xml de entrada com erro ou vazio.");
    }

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        int idContato = sIdContato;
        int idTipoPessoa = sIdTipoPessoa;
        int idUfOperadora = sIdUfOperadora;
        int idPesquisaSatisfacao;
        VARCHAR nmPesquisaSatisfacao[256];

        short i_idPesquisaSatisfacao=-1;
        short i_nmPesquisaSatisfacao=-1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO WFAtdPsqSqlErro(&sqlca);

    EXEC SQL 
        SELECT 
            CU.IDPESQUISASATISFACAO,
            CP.NMPESQUISASATISFACAO
        INTO 
            :idPesquisaSatisfacao:i_idPesquisaSatisfacao,
            :nmPesquisaSatisfacao:i_nmPesquisaSatisfacao
        FROM 
            CONTATOADM.PESQUISASATISFACAOUF CU,
            CONTATOADM.PESQUISASATISFACAO CP
        WHERE 
            CU.IDPESQUISASATISFACAO = CP.IDPESQUISASATISFACAO
        AND CU.IDCONTATO = :idContato
        AND CU.IDTIPOPESSOA = :idTipoPessoa
        AND CU.IDUFOPERADORA = :idUfOperadora
        AND ROWNUM < 2;

    if ( 0 == sqlca.sqlcode ) 
    {
        CONVIND(nmPesquisaSatisfacao, i_nmPesquisaSatisfacao);

        saida->addItem("idQuestionario",idPesquisaSatisfacao);
        saida->addItem("dsQuestionario", (char*)nmPesquisaSatisfacao.arr);

        proCGetPerguntas(idPesquisaSatisfacao, saida);
    }
    else
    {
        ULOGW("Nenhuma pergunta cadastrada!");
    }

    ULOG_END("proCGetQuestionario()");
}

void proCGetPerguntas( int sIdQuestionario, XMLGen* saida )
{
    ULOG_START("proCGetPerguntas()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int idQuestionario = sIdQuestionario;

        VARCHAR idTipoApresentacaoPergunta[256];
        VARCHAR dsTipoApresentacaoPergunta[256];
        VARCHAR dsPergunta[256];
        VARCHAR dsScriptPergunta[256];
        VARCHAR sqApresentacao[256];
        VARCHAR inEncerramento[256];
        VARCHAR inDisponibilidade[256];
        VARCHAR inObrigatoria[256];
        int idPergunta;

        short i_idTipoApresentacaoPergunta;
        short i_dsTipoApresentacaoPergunta;
        short i_dsPergunta;
        short i_dsScriptPergunta;
        short i_sqApresentacao;
        short i_inEncerramento;
        short i_inDisponibilidade;
        short i_inObrigatoria;
        short i_idPergunta;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO WFAtdPsqSqlErro(&sqlca);

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL 
    DECLARE consultaPergunta CURSOR FOR
        SELECT 
            P.IDTIPOAPRESENTACAOPERGUNTA, 
            AP.DSTIPOAPRESENTACAOPERGUNTA, 
            P.DSPERGUNTA, 
            P.DSSCRIPTPERGUNTA, 
            P.SQAPRESENTACAO, 
            P.INENCERRAMENTO, 
            P.INDISPONIBILIDADE, 
            P.INOBRIGATORIA, 
            P.IDPERGUNTA 
        FROM 
            CONTATOADM.PESQUISASATISFACAOPERGUNTA CP,
            QUESTIONARIO.PERGUNTA P,
            APOIO.TIPOAPRESENTACAOPERGUNTA AP
        WHERE
            P.IDPERGUNTA = CP.IDPERGUNTA
        AND 
            P.IDTIPOAPRESENTACAOPERGUNTA = AP.IDTIPOAPRESENTACAOPERGUNTA
        AND 
            CP.IDPESQUISASATISFACAO = :idQuestionario
        AND 
            P.INDISPONIBILIDADE = 1
        ORDER BY 
            P.SQAPRESENTACAO;

    EXEC SQL OPEN consultaPergunta;

    while (true)
    {
        i_idTipoApresentacaoPergunta = -1;
        i_dsTipoApresentacaoPergunta = -1;
        i_dsPergunta = -1;
        i_dsScriptPergunta = -1;
        i_sqApresentacao = -1;
        i_inEncerramento = -1;
        i_inDisponibilidade = -1;
        i_inObrigatoria = -1;

        EXEC SQL FETCH consultaPergunta INTO
            :idTipoApresentacaoPergunta:i_idTipoApresentacaoPergunta,
            :dsTipoApresentacaoPergunta:i_dsTipoApresentacaoPergunta,
            :dsPergunta:i_dsPergunta,
            :dsScriptPergunta:i_dsScriptPergunta,
            :sqApresentacao:i_sqApresentacao,
            :inEncerramento:i_inEncerramento,
            :inDisponibilidade:i_inDisponibilidade,
            :inObrigatoria:i_inObrigatoria,
            :idPergunta:i_idPergunta;

        CONVIND(idTipoApresentacaoPergunta,i_idTipoApresentacaoPergunta);
        CONVIND(dsTipoApresentacaoPergunta,i_dsTipoApresentacaoPergunta);
        CONVIND(dsPergunta,i_dsPergunta);
        CONVIND(dsScriptPergunta,i_dsScriptPergunta);
        CONVIND(sqApresentacao,i_sqApresentacao);
        CONVIND(inEncerramento,i_inEncerramento);
        CONVIND(inDisponibilidade,i_inDisponibilidade);
        CONVIND(inObrigatoria,i_inObrigatoria);

        saida->createTag("AdmPerguntaVO");
            saida->addItem("idTipoApresentacaoPergunta",(char*)idTipoApresentacaoPergunta.arr);
            saida->addItem("dsTipoApresentacaoPergunta",(char*)dsTipoApresentacaoPergunta.arr);
            saida->addItem("dsPergunta",(char*)dsPergunta.arr);
            saida->addItem("dsScriptPergunta",(char*)dsScriptPergunta.arr);
            saida->addItem("sqApresentacao",(char*)sqApresentacao.arr);
            saida->addItem("inEncerramento",(char*)inEncerramento.arr);
            saida->addItem("inDisponibilidade",(char*)inDisponibilidade.arr);
            saida->addItem("inObrigatoria",(char*)inObrigatoria.arr);
            saida->addItem("idPergunta",idPergunta);

        proCGetRespostas(idPergunta, saida);
    
        saida->closeTag();
    }

    EXEC SQL CLOSE consultaPergunta;

    ULOG_END("proCGetPerguntas()");
}

void proCGetRespostas( int sIdPergunta, XMLGen* saida )
{
    ULOG_START("proCGetRespostas()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int idPergunta = sIdPergunta;
        int idResposta;

        VARCHAR dsResposta[256];
        VARCHAR dsScriptResposta[256];
        VARCHAR sqApresentacao[256];
        VARCHAR inEncerramento[256];
        VARCHAR inDisponibilidade[256];

        short i_idResposta;
        short i_dsResposta;
        short i_dsScriptResposta;
        short i_sqApresentacao;
        short i_inEncerramento;
        short i_inDisponibilidade;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO WFAtdPsqSqlErro(&sqlca);

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE consultaResposta CURSOR FOR
        SELECT 
            IDRESPOSTA, 
            DSRESPOSTA, 
            DSSCRIPTRESPOSTA, 
            SQAPRESENTACAO, 
            INENCERRAMENTO, 
            INDISPONIBILIDADE
        FROM 
            QUESTIONARIO.RESPOSTA
        WHERE
            IDPERGUNTA = :idPergunta
        AND INDISPONIBILIDADE = 1
        ORDER BY 
            SQAPRESENTACAO;

    EXEC SQL OPEN consultaResposta;

    while (true)
    {
        i_dsResposta = -1;
        i_dsScriptResposta = -1;
        i_sqApresentacao = -1;
        i_inEncerramento = -1;
        i_inDisponibilidade = -1;

        EXEC SQL FETCH consultaResposta INTO
            :idResposta:i_idResposta,
            :dsResposta:i_dsResposta,
            :dsScriptResposta:i_dsScriptResposta,
            :sqApresentacao:i_sqApresentacao,
            :inEncerramento:i_inEncerramento,
            :inDisponibilidade:i_inDisponibilidade;

        CONVIND(dsResposta,i_dsResposta);
        CONVIND(dsScriptResposta,i_dsScriptResposta);
        CONVIND(sqApresentacao,i_sqApresentacao);
        CONVIND(inEncerramento,i_inEncerramento);
        CONVIND(inDisponibilidade,i_inDisponibilidade);

        saida->createTag("AdmRespostaVO");
            saida->addItem("idResposta",idResposta);
            saida->addItem("dsResposta",(char*)dsResposta.arr);
            saida->addItem("dsScriptResposta",(char*)dsScriptResposta.arr);
            saida->addItem("sqApresentacao",(char*)sqApresentacao.arr);
            saida->addItem("inEncerramento",(char*)inEncerramento.arr);
            saida->addItem("inDisponibilidade",(char*)inDisponibilidade.arr);

        proCGetSaltoResposta(idResposta, saida);
    
        saida->closeTag();
    }

    EXEC SQL CLOSE consultaResposta;

    ULOG_END("proCGetRespostas()");
}

void proCGetSaltoResposta( int sIdResposta, XMLGen* saida )
{
    ULOG_START("proCGetSaltoResposta()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        int idResposta = sIdResposta;
        int idPergunta;
        VARCHAR inAtivo[256];

        short i_idPergunta;
        short i_inAtivo;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO WFAtdPsqSqlErro(&sqlca);

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE consultaSaltoResposta CURSOR FOR
        SELECT 
            IDPERGUNTA, 
            INATIVO
        FROM 
            QUESTIONARIO.RESPOSTAPROXIMAPERGUNTA
        WHERE
            IDRESPOSTA = :idResposta;

    EXEC SQL OPEN consultaSaltoResposta;

    while (true)
    {
        i_inAtivo = -1;

        EXEC SQL FETCH consultaSaltoResposta INTO
            :idPergunta:i_idPergunta,
            :inAtivo:i_inAtivo;

        CONVIND(inAtivo,i_inAtivo);

        saida->createTag("AdmSaltoVO");
            saida->addItem("idPergunta",idPergunta);
            saida->addItem("ativo",(char*)inAtivo.arr);
        saida->closeTag();
    }

    EXEC SQL CLOSE consultaSaltoResposta;

    ULOG_END("proCGetSaltoResposta()");
}

void WFAtdPsqSqlErro(sqlca*sqlca)
{
    ULOGE("WFAtdPsqSqlErro:sqlcode=%d,sqlerrmc=%.70s",sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc);

    throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc
                                  ,sqlca->sqlerrm.sqlerrml);
}
