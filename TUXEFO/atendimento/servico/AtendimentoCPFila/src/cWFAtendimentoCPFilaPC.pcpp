/**
 * 
 * @modulo  Workflow
 * @usecase Workflow
 * @remark  
 * @author  Charles Santos
 * @version $Revision: 1.1.2.1.6.2 $
 * @CVS     $Author: a5114878 $ - $Date: 2013/02/05 17:38:05 $
 **/

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"
#include "../../../commons/msgPadrao.h"

#include "../include/cWFAtendimentoCPFila.h"
#include "../include/stWFAtendimentoCPFila.h"

void sql_error_WFAtendimentoCPFila(sqlca*sqlca);

	// Declara as estruturas compatíveis ao ProC.
    EXEC SQL BEGIN DECLARE SECTION;
		#include "../include/stWFAtendimentoCPFila.h"
    EXEC SQL END DECLARE SECTION;

long proCIncluirWFAtendimentoCPFila(st_AtendimentoCPFila* dados, st_vlAtendimentoCPFila* status, XMLGen* saida)
{
    ULOG_START( "proCIncluirWFAtendimentoCPFila()" );

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AtendimentoCPFila   *oDados=dados;
		struct st_vlAtendimentoCPFila *oStatus=status;

	EXEC SQL END DECLARE SECTION;

//	memcpy(&oDados,  dados,  sizeof(oDados));
//	memcpy(&oStatus, status, sizeof(oStatus));

   EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoCPFila(&sqlca);

//	EXEC SQL SELECT atendimento.AtendimentoCPFilaSQ.NextVal INTO :oDados.idAtendimentoCPFila FROM DUAL;

	EXEC SQL 
		INSERT INTO
			atendimento.AtendimentoCPFila
			(
              IDATENDIMENTO
            , IDGRUPOORIGEM   
            , IDPESSOAUSUARIOORIGEM
            , INCONTATOPREVIOREALIZADO
            , NRTENTATIVAS
            , IDUSUARIOALTERACAO
            , DTULTIMAALTERACAO
            , DTCALCULADA
		     )
			VALUES
			(
				 :oDados->idAtendimento
				, DECODE(:oDados->idGrupoOrigem,0,NULL,:oDados->idGrupoOrigem)
				, DECODE(:oDados->idPessoaUsuarioOrigem,0,NULL,:oDados->idPessoaUsuarioOrigem)
				,:oDados->inContatoPrevioRealizado
				,:oDados->nrTentativas
				,:oDados->idUsuarioAlteracao
				, SYSDATE
				, TO_DATE(:oDados->dtCalculada,'DD/MM/YYYY HH24:MI:SS')
			);

    ULOG_END( "proCIncluirWFAtendimentoCPFila()" );
	return oDados->idAtendimento;
}

bool proCAlterarWFAtendimentoCPFilaPessGrupo(st_AtendimentoCPFila* dados)
{
   ULOG_START( "proCAlterarWFAtendimentoCPFilaPessGrupo()" );

   struct sqlca sqlca;

   EXEC SQL BEGIN DECLARE SECTION;

		struct st_AtendimentoCPFila   *oDados = dados;


   EXEC SQL END DECLARE SECTION;

   
//   memcpy(&oDados,  dados,  sizeof(oDados));

   EXEC SQL 
        UPDATE
             ATENDIMENTO.ATENDIMENTOCPFILA
        SET  
             IDGRUPOORIGEM = DECODE(:oDados->idGrupoOrigem,0,NULL,:oDados->idGrupoOrigem)
            ,IDPESSOAUSUARIOORIGEM = DECODE(:oDados->idPessoaUsuarioOrigem,0,NULL,:oDados->idPessoaUsuarioOrigem)
            ,IDUSUARIOALTERACAO = :oDados->idUsuarioAlteracao
            ,DTULTIMAALTERACAO = SYSDATE
         WHERE
            IDATENDIMENTO = :oDados->idAtendimento;

    ULOG_END( "proCAlterarWFAtendimentoCPFilaPessGrupo()" );

    return true;
}

bool proCAlterarWFAtendimentoCPFila(st_AtendimentoCPFila* dados, st_vlAtendimentoCPFila* status, XMLGen* saida)
{
    ULOG_START( "proCAlterarWFAtendimentoCPFila()" );

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

         struct st_AtendimentoCPFila   oDados;
         struct st_vlAtendimentoCPFila oStatus;
         
         char query[800];

   EXEC SQL END DECLARE SECTION;
   
   EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoCPFila(&sqlca);

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

	sprintf(query,"%s", "UPDATE atendimento.AtendimentoCPFila SET ");

	bool separa = false;

	if (status->idGrupoOrigem != -1) 
		montaUpdate("idGrupoOrigem", oDados.idGrupoOrigem, TIPO_INT );

	if (status->idAtendimento != -1) 
		montaUpdate("idPessoaUsuarioOrigem", oDados.idPessoaUsuarioOrigem, TIPO_INT);

	if (status->nrTentativas != -1) 
		montaUpdate("nrTentativas", oDados.nrTentativas, TIPO_INT );

	if (status->dtCalculada != -1) 
		montaUpdate("dtCalculada", oDados.dtCalculada, TIPO_DATAHORA );

	if (status->idUsuarioAlteracao != -1) 
		montaUpdate("idUsuarioAlteracao", oDados.idUsuarioAlteracao, TIPO_INT );
	

	if (status->dtUltimaAlteracao != -1) 
      montaUpdate("dtUltimaAlteracao", oDados.dtUltimaAlteracao, TIPO_DATAHORA );


	sprintf(query, "%s WHERE idAtendimento = %ld", query, dados->idAtendimento );

	EXEC SQL EXECUTE IMMEDIATE :query;

    ULOG_END( "proCAlterarWFAtendimentoCPFila()" );

	return true;
}

bool proCExcluirWFAtendimentoCPFila(st_AtendimentoCPFila* dados, st_vlAtendimentoCPFila* status, XMLGen* saida)
{
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimento = dados->idAtendimento;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoCPFila(&sqlca);

	EXEC SQL 
		DELETE
			atendimento.AtendimentoCPFila
		WHERE
			idAtendimento = :idAtendimento;

	return true;
}

unsigned long proCObterWFRegistroCPFila(long sIdAtendimento,st_AtendimentoCPFila* dados)
{

    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimento = sIdAtendimento;
	
		struct st_AtendimentoCPFila oDados ;
		struct st_vlAtendimentoCPFila  Status ;

    EXEC SQL END DECLARE SECTION;
    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoCPFila(&sqlca);
	EXEC SQL 
		SELECT
         idAtendimento,
         idGrupoOrigem,             
         idPessoaUsuarioOrigem,
         inContatoPrevioRealizado,
         nrTentativas,
         dtCalculada,
         idUsuarioAlteracao,
         dtUltimaAlteracao
		INTO
			:oDados:Status
		FROM
			atendimento.AtendimentoCPFila
		WHERE
			idAtendimento = :idAtendimento;

  if (sqlca.sqlcode == 1403)
  {
		idAtendimento = 0;
  }
  else
  {
      memcpy(dados,&oDados, sizeof(oDados));
  }
	
  return idAtendimento;
}

bool proCExisteCPrevio( long _idAtendimento )
{
    ULOG_START( "proCExisteCPrevio()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = _idAtendimento;
        short i_idAtendimento =-1;

    EXEC SQL END DECLARE SECTION;
    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoCPFila(&sqlca);

    EXEC SQL
          SELECT
              IDATENDIMENTO
          INTO 
              :idAtendimento:i_idAtendimento
          FROM 
              ATENDIMENTO.ATENDIMENTOCPFILA 
          WHERE 
              IDATENDIMENTO = :idAtendimento;
              
    if (sqlca.sqlcode == 1403)
    {
        ULOG( "Nao encontrou idAtendimento = %d",idAtendimento );
    }

    ULOG_END( "proCExisteCPrevio()" );

    return i_idAtendimento == -1 ? false : true;
}

bool proCConsultaWFAtendimentoCPFila(st_AtendimentoCPFila* dados, st_vlAtendimentoCPFila* status, char* order, XMLGen* saida)
{

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
    
      long idAtendimento ;
      int idGrupoOrigem;             
      int idPessoaUsuarioOrigem;
      int inContatoPrevioRealizado;
      int nrTentativas;
      char dtCalculada[64];
      int idUsuarioAlteracao;
      char dtUltimaAlteracao[64];    
    
      short iidAtendimento ;
      short iidGrupoOrigem;             
      short iidPessoaUsuarioOrigem;
      short iinContatoPrevioRealizado;
      short inrTentativas;
      short idtCalculada;
      short iidUsuarioAlteracao;
      short idtUltimaAlteracao;
      
 	  char query[800];

   EXEC SQL END DECLARE SECTION;
      
   EXEC SQL WHENEVER SQLERROR  DO sql_error_WFEstado(&sqlca);
   EXEC SQL WHENEVER NOT FOUND DO BREAK;

	sprintf(query,"SELECT idAtendimento ,idGrupoOrigem,idPessoaUsuarioOrigem,inContatoPrevioRealizado,nrTentativas, TO_CHAR( dtCalculada, 'DD/MM/YYYY' ),idUsuarioAlteracao, TO_CHAR( dtUltimaAlteracao, 'DD/MM/YYYY' ) FROM atendimento.AtendimentoCPFila ");

	bool separa = false;

	if (status->idAtendimento != -1) 
		montaWhere("idAtendimento", dados->idAtendimento, 1);

	if (status->idGrupoOrigem != -1)
		montaWhere("idGrupoOrigem", dados->idGrupoOrigem, TIPO_INT);

	if (status->idAtendimento != -1) 
		montaWhere("idPessoaUsuarioOrigem", dados->idPessoaUsuarioOrigem, TIPO_INT);
 
	if (status->inContatoPrevioRealizado != -1) 
		montaWhere("inContatoPrevioRealizado", dados->inContatoPrevioRealizado, TIPO_INT);

	if (status->dtCalculada != -1) 
		montaWhere("dtCalculada", dados->dtCalculada, TIPO_DATAHORA);

	if (status->nrTentativas != -1) 
		montaWhere("nrTentativas", dados->nrTentativas, TIPO_INT);

	if (status->idUsuarioAlteracao != -1) 
		montaWhere("idUsuarioAlteracao", dados->idUsuarioAlteracao, TIPO_INT);

	if (status->dtUltimaAlteracao != -1) 
		montaWhere("dtUltimaAlteracao", dados->dtUltimaAlteracao, TIPO_DATAHORA);

	if (strlen(order) > 0) 
		sprintf( query, "%s ORDER BY %s ", query, order);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoCPFila(&sqlca);

	EXEC SQL PREPARE consultaAtendimentoCPFila FROM :query;
	EXEC SQL DECLARE consulta CURSOR FOR consultaAtendimentoCPFila;

	EXEC SQL OPEN consulta;

	while (true)
	{
		EXEC SQL FETCH consulta INTO 
									:idAtendimento:iidAtendimento, 
									:idGrupoOrigem:iidGrupoOrigem,
									:idPessoaUsuarioOrigem:iidPessoaUsuarioOrigem,
									:inContatoPrevioRealizado:iinContatoPrevioRealizado,
									:nrTentativas:inrTentativas,
									:dtCalculada:idtCalculada,
									:idUsuarioAlteracao:iidUsuarioAlteracao,
									:dtUltimaAlteracao:idtUltimaAlteracao;


		saida->createTag("WFAtendimentoCPFilaVO");
			saida->addItem("idAtendimento", idAtendimento);
			saida->addItem("idGrupoOrigem", idGrupoOrigem);
			saida->addItem("idPessoaUsuarioOrigem", idPessoaUsuarioOrigem);
			saida->addItem("inContatoPrevioRealizado", inContatoPrevioRealizado);
			saida->addItem("nrTentativas", nrTentativas);
			saida->addItem("dtCalculada", dtCalculada);
			saida->addItem("idUsuarioAlteracao", idUsuarioAlteracao);
			saida->addItem("dtUltimaAlteracao", dtUltimaAlteracao);
		saida->closeTag();
	}

	EXEC SQL CLOSE consulta;

	return true;

}

bool proCObterGrupoRCConfigurado(long _idAtendimento ,int _idContato ,int _idCanal
                             ,int _idProcedencia ,int _idSegmentacao ,int _idTipoCarteira
                             ,int _idUFOperadora ,int &idGrupoEncaminhar
							 ,int _idUsuarioGrupo
                            )
{
    ULOG_START( "proCObterGrupoRCConfigurado()" );
    
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = _idAtendimento;
        int idContato = _idContato;
        int idCanal = _idCanal;
        int idProcedencia = _idProcedencia;
        int idSegmentacao = _idSegmentacao;
        int idTipoCarteira = _idTipoCarteira;
        int idUFOperadora = _idUFOperadora;
        int idGrupo;
        short i_idGrupo = -1;
		int idUsuarioGrupo = _idUsuarioGrupo ;

    EXEC SQL END DECLARE SECTION;

/*    EXEC SQL WHENEVER SQLERROR DO ContatoPrevioSQLError(&sqlca,__LINE__,0);  */
    EXEC SQL WHENEVER NOTFOUND CONTINUE;  
    
    

    EXEC SQL 
        SELECT 
              ARG.IDGRUPO
        INTO  
              :idGrupo:i_idGrupo
        FROM 
              ATENDIMENTO.ATDRELGRUPORCV01 ARG
             ,CONTATOADM.UFOPERADORAGRUPO UFOG
        WHERE 
              ARG.IDCONTATO = :idContato
        AND
              ARG.IDCANAL = :idCanal
        AND
              ARG.IDPROCEDENCIA = :idProcedencia
        AND
              ARG.IDSEGMENTACAO = :idSegmentacao
        AND
              ARG.IDTIPOCARTEIRA = :idTipoCarteira
        AND 
              UFOG.IDUFOPERADORA = :idUFOperadora
        AND 
              UFOG.IDGRUPO = ARG.IDGRUPO
        AND 
		      ( ARG.IDGRUPO IN (SELECT aug.idGrupo FROM ACESSO.USUARIOGRUPO AUG WHERE AUG.IDPESSOAUSUARIO = :idUsuarioGrupo))                        
        AND
              ROWNUM < 2;
    ULOG( "= Primeira pesquisa de Grupo = [%d]",idGrupo );              
    //
    // se não encontrar nenhum grupo que atenda as variáveis configuradas,
    // assume o primeiro grupo de resposta ao cliente associado ao contato
    // que pertença a UF operadora do atendimento
    //
    if (sqlca.sqlcode == 1403)
    {
        EXEC SQL 
            SELECT 
                  ARG.IDGRUPO
            INTO
                  :idGrupo:i_idGrupo
            FROM 
                  ATENDIMENTO.ATDRELGRUPORCV01 ARG
                 ,CONTATOADM.UFOPERADORAGRUPO UFOG
                 ,ACESSO.USUARIOUFOPERADORA UUFOP
            WHERE 
                  ARG.IDCONTATO = :idContato
            AND 
                  UFOG.IDUFOPERADORA = :idUFOperadora
            AND 
                  UFOG.IDGRUPO = ARG.IDGRUPO
            AND 
		          (ARG.IDGRUPO IN (SELECT aug.idGrupo FROM ACESSO.USUARIOGRUPO AUG WHERE AUG.IDPESSOAUSUARIO = :idUsuarioGrupo))                        

            AND
                  ROWNUM < 2;
        ULOG( "= Segunda pesquisa de Grupo = [%d]",idGrupo );              
        //
        // se não existe grupo associado a UF operadora então pega o primeiro
        // grupo associado ao contato que for encontrado
        //
        if (sqlca.sqlcode == 1403)
        {
            EXEC SQL 
                SELECT 
                      ARG.IDGRUPO
                INTO
                      :idGrupo:i_idGrupo
                FROM 
                      ATENDIMENTO.ATDRELGRUPORCV01 ARG
                WHERE 
                      ARG.IDCONTATO = :idContato
                AND 
 		              (ARG.IDGRUPO IN (SELECT aug.idGrupo FROM ACESSO.USUARIOGRUPO AUG WHERE AUG.IDPESSOAUSUARIO = :idUsuarioGrupo))                        
                AND
                      ROWNUM < 2;

			ULOG("= Terceira pesquisa de Grupo = [%d]",idGrupo);              

            //
            // nenhum grupo associado ? então falha a busca
            //
            if (sqlca.sqlcode == 1403)
            {
                ULOG_END( "proCObterGrupoRCConfigurado() -> return false" );
                return false;
            }
        }
    }
    idGrupoEncaminhar = idGrupo;
    ULOG_END( "proCObterGrupoRCConfigurado() -> return true" );
    return true;
}

bool proCObterAtdCPrevio(long i_idAtendimento,st_AtdCprevio *dados )
{

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
//        struct st_AtdCprevio *st_dados = dados ;
//        struct st_vAtdCprevio st_status ;
        long  _idAtendimento = i_idAtendimento ;

        double            nrCriticidade;
        long     idAtendimento;
        char              dtAbertura[64];
        char              dtTPrazoFinalCPrevio[64];
        int               idContato;
        int               idCanal;
        int               idProcedencia;
        int               idSegmentacao; 
        int               idTipoCarteira;
        long              idPessoaUsuarioAtual;
        int               idGrupoAtual;
        int               idUFOperadora;  

        short  inrCriticidade;
        short  iidAtendimento;
        short  idtAbertura;
        short  idtTPrazoFinalCPrevio;
        short  iidContato;
        short  iidCanal;
        short  iidProcedencia;
        short  iidSegmentacao; 
        short  iidTipoCarteira;
        short  iidPessoaUsuarioAtual;
        short  iidGrupoAtual;
        short  iidUFOperadora; 


    EXEC SQL END DECLARE SECTION;

    // memset (&st_status , -1, sizeof(struct st_vAtdCprevio)); 

    inrCriticidade=-1;
    iidAtendimento=-1;
    idtAbertura=-1;
    idtTPrazoFinalCPrevio=-1;
    iidContato=-1;
    iidCanal=-1;
    iidProcedencia=-1;
    iidSegmentacao=-1; 
    iidTipoCarteira=-1;
    iidPessoaUsuarioAtual=-1;
    iidGrupoAtual=-1;
    iidUFOperadora=-1; 



    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoCPFila(&sqlca);
    EXEC SQL
        SELECT
              NRCRITICIDADE
             ,IDATENDIMENTO
             ,DTABERTURA
             ,DTPRAZOFINALCPREVIO
             ,IDCONTATO
             ,IDCANAL
             ,IDPROCEDENCIA
             ,IDSEGMENTACAO
             ,IDTIPOCARTEIRA
             ,IDPESSOAUSUARIOATUAL
             ,IDGRUPOATUAL
             ,IDUFOPERADORA
        INTO
         :nrCriticidade:inrCriticidade
        ,:idAtendimento:iidAtendimento
        ,:dtAbertura:idtAbertura
        ,:dtTPrazoFinalCPrevio:idtTPrazoFinalCPrevio
        ,:idContato:iidContato
        ,:idCanal:iidCanal
        ,:idProcedencia:iidProcedencia
        ,:idSegmentacao:iidSegmentacao 
        ,:idTipoCarteira:iidTipoCarteira
        ,:idPessoaUsuarioAtual:iidPessoaUsuarioAtual
        ,:idGrupoAtual:iidGrupoAtual
        ,:idUFOperadora:iidUFOperadora
//           :st_dados:st_status
        FROM
            ATENDIMENTO.ATDPROXATENDIMENTOCPREVIOV01
            WHERE idAtendimento = :_idAtendimento 
            AND ROWNUM < 2;

    dados->nrCriticidade=nrCriticidade;
    dados->idAtendimento=idAtendimento;
    strcpy(dados->dtAbertura,dtAbertura);
    strcpy(dados->dtTPrazoFinalCPrevio,dtTPrazoFinalCPrevio);
    dados->idContato=idContato;
    dados->idCanal=idCanal;
    dados->idProcedencia=idProcedencia;
    dados->idSegmentacao=idSegmentacao; 
    dados->idTipoCarteira=idTipoCarteira;
    dados->idPessoaUsuarioAtual=idPessoaUsuarioAtual;
    dados->idGrupoAtual=idGrupoAtual;
    dados->idUFOperadora=idUFOperadora;  
    
    if (sqlca.sqlcode < 0) 
    {
       return false;
    }
    else
    { 
       return true;
    }
}

bool proCObterAtendimentoGrupoRCConfigurado( FetchResultado &_dFetchResultado,int &idGrupoEncaminhamento,int _idUsuarioGrupo)
{
    ULOG_START( "proCObterAtendimentoGrupoRCConfigurado()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento;
        long idPessoaUsuarioAtual ;
        int idGrupoAtual;
        VARCHAR dtCalculada[64];
        int idContato;
        int idCanal;
        int idProcedencia ;
        int idSegmentacao;
        int idTipoCarteira ;
        int idUFOperadora;

        short iidAtendimento = -1 ;
        short iidPessoaUsuarioAtual = -1 ;
        short idtCalculada = -1;
        short iidContato= -1;
        short iidCanal= -1 ;
        short iidProcedencia = -1;
        short iidSegmentacao= -1;
        short iidTipoCarteira = -1;
        short iidGrupoAtual = -1;
        short iidUFOperadora= -1;
		

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoCPFila(&sqlca); // WFAtdAttrUsuSem(&sqlca);

    EXEC SQL DECLARE cursorContatoPrevio CURSOR FOR
        SELECT
             IDATENDIMENTO
            ,IDGRUPOATUAL
            ,DTPRAZOFINALCPREVIO
            ,IDCONTATO 
            ,IDCANAL 
            ,IDPROCEDENCIA
            ,IDSEGMENTACAO
            ,IDTIPOCARTEIRA
            ,IDPESSOAUSUARIOATUAL
            ,IDUFOPERADORA
         FROM 
            ATENDIMENTO.ATDPROXATENDIMENTOCPREVIOV01
         WHERE ROWNUM < 100;

    EXEC SQL OPEN cursorContatoPrevio;

    bool retorna = false ;

    if ( sqlca.sqlcode < 0 ) 
    {
       ULOGE( "1. ERRO ORACLE [%d]",sqlca.sqlcode );
       return retorna;
    }

    for(;;)
    {
          EXEC SQL FETCH cursorContatoPrevio 
              INTO 
                   :idAtendimento:iidAtendimento
                  ,:idGrupoAtual:iidGrupoAtual
                  ,:dtCalculada:idtCalculada
                  ,:idContato:iidContato
                  ,:idCanal:iidCanal
                  ,:idProcedencia:iidProcedencia
                  ,:idSegmentacao:iidSegmentacao
                  ,:idTipoCarteira:iidTipoCarteira
                  ,:idPessoaUsuarioAtual:iidPessoaUsuarioAtual
                  ,:idUFOperadora:iidUFOperadora;

        if (sqlca.sqlcode < 0) 
        {
           ULOGE( "2. ERRO ORACLE [%d]",sqlca.sqlcode );
           return retorna;
        }

        CONVIND(dtCalculada,idtCalculada);

        // verifica se o processo tem grupo contato previo
        retorna = proCObterGrupoRCConfigurado(idAtendimento,idContato,idCanal
                                             ,idProcedencia,idSegmentacao,idTipoCarteira
                                             ,idUFOperadora,idGrupoEncaminhamento,_idUsuarioGrupo);

        if ( retorna == true )
        { 
             _dFetchResultado.idAtendimento=  idAtendimento;  
             _dFetchResultado.idGrupoAtual=   idGrupoAtual;   
             _dFetchResultado.idContato=      idContato;      
             _dFetchResultado.idCanal=        idCanal;        
             _dFetchResultado.idProcedencia=  idProcedencia; 
             _dFetchResultado.idSegmentacao=  idSegmentacao;  
             _dFetchResultado.idTipoCarteira= idTipoCarteira;
             _dFetchResultado.idUFOperadora=  idUFOperadora;  
             _dFetchResultado.idPessoaUsuarioAtual=idPessoaUsuarioAtual;
             strcpy(_dFetchResultado.dtCalculada, (char*)dtCalculada.arr);

            ULOG_END( "proCObterAtendimentoGrupoRCConfigurado() -> return true" );

            return retorna;
        }
    }

    ULOG_END( "proCObterAtendimentoGrupoRCConfigurado()" );

    return retorna;
}

int proCGetGruposAssociadosRC( int _idUsuario )
{
    ULOG_START( "proCGetGruposAssociadosRC()" );

    ULOG("> _idUsuario = [%d]",_idUsuario);

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        int idGRUPO=0;
        int idUsuario = _idUsuario;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoCPFila(&sqlca);
	 EXEC SQL
        SELECT
            GRUPO.idGRUPO
        INTO
            :idGRUPO
        FROM
            ACESSO.USUARIOGRUPO USUARIOGRUPO
           ,ACESSO.GRUPO GRUPO
           ,APOIO.TIPOGRUPO TIPOGRUPO
        WHERE
            IDPESSOAUSUARIO = :idUsuario
        AND
            USUARIOGRUPO.IDGRUPO = GRUPO.IDGRUPO
        AND
            GRUPO.IDTIPOGRUPO = TIPOGRUPO.IDTIPOGRUPO
        AND
            TIPOGRUPO.CDTIPOGRUPO = 'RC'
        AND ROWNUM < 2 ;
            
            
    ULOG("< retorno da view -> idGrupo [%d]",idGRUPO);

    ULOG_END( "proCGetGruposAssociadosRC()" );

    return idGRUPO ;
}


void sql_error_WFAtendimentoCPFila(sqlca*sqlca)
{
	throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}