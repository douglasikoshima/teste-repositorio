/**
 * 
 * @modulo  Workflow
 * @usecase Workflow
 * @author  Cassio M Garcia
 * @version $Revision: 1.1.2.9.6.2 $
 * @CVS     $Author: a5114878 $ - $Date: 2013/02/06 12:36:43 $
 **/

#undef SQLCA
#define SQLCA_NONE
#include <sqlca.h>
#include <sqlda.h>

#include "../../../commons/queryMacro.h"
#include "../../../commons/msgPadrao.h"
#include "../include/cWFAtdDetAcao.h"

void sql_error_WFDetAcao(sqlca*sqlca);

// Esta operação devolve true se o usuário informado participar de ao menos
// um dos grupos de abertura configurados na fase TRATAMENTO da árvore de 
// contato ou false em caso contrário.
bool proCUsuarioPossuiPerfilAbertura(int _idPessoaUsuario,int _idContato)
{
    ULOG_START("proCUsuarioPossuiPerfilAbertura()"); 

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int count;
        int idPessoaUsuario = _idPessoaUsuario;
        int idContato = _idContato;
        
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFDetAcao(&sqlca);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        SELECT /*+ NO_CPU_COSTING */
             COUNT(1)
        INTO
            :count
        FROM 
             ACESSO.USUARIOGRUPO USUARIOGRUPO
            ,CONTATOADM.CONTATOGRUPO CONTATOGRUPO
            ,CONTATOADM.SEQUENCIA SEQUENCIA
        WHERE 
            USUARIOGRUPO.IDPESSOAUSUARIO = :idPessoaUsuario
        AND USUARIOGRUPO.IDGRUPO = CONTATOGRUPO.IDGRUPO
        AND CONTATOGRUPO.IDCONTATOGRUPO = SEQUENCIA.IDCONTATOGRUPO
        AND CONTATOGRUPO.IDCONTATO = :idContato
        AND SEQUENCIA.IDTIPOSEQUENCIA = 1 // 1 = FASE ABERTURA
        AND ROWNUM < 2;

    ULOG_END("proCUsuarioPossuiPerfilAbertura()"); 

    return count == 0 ? false : true;
}

bool proCPermitirAcaoProcMC(int _idPessoaUsuario, long _idAtendimento,int _idAtividade)
{
    ULOG_START("proCPermitirAcaoProcMC()"); 

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        long idAtendimento = _idAtendimento;

        int idPessoaUsuarioWeb = _idPessoaUsuario;

        int varOraIdPessoaUsuarioMC = -1;
        int varOraIdGrupoMC = -1;
        int varOraInSupervisor = -1;
        long varOraIdPessoaUsuarioAtual = -1;

        short statOraIdPessoaUsuarioMC = -1;
        short statOraIdGrupoMC = -1;
        short statOraInSupervisor = -1;
        short statOraIdPessoaUsuarioAtual = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFDetAcao(&sqlca);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        SELECT
            IDPESSOAUSUARIOMC,
            IDPESSOAUSUARIOATUAL,
            IDGRUPOMC
        INTO
            :varOraIdPessoaUsuarioMC:statOraIdPessoaUsuarioMC,
            :varOraIdPessoaUsuarioAtual:statOraIdPessoaUsuarioAtual,
            :varOraIdGrupoMC:statOraIdGrupoMC
        FROM
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        WHERE
            IDATENDIMENTO = :idAtendimento;

    if ( sqlca.sqlcode )
    {
        ULOG_END("proCPermitirAcaoProcMC() ==> ATENDIMENTO <<NOT FOUND>>");
        return false;
    }

    ULOG("  idPessoaUsuarioWeb=%d",idPessoaUsuarioWeb);
    ULOG("idPessoaUsuarioAtual=%ld",varOraIdPessoaUsuarioAtual);
    ULOG("   idPessoaUsuarioMC=%d",varOraIdPessoaUsuarioMC);
    ULOG("           idGrupoMC=%d",varOraIdGrupoMC);

    /*
        Processos MeuCliente2:
            acoes de fechar/encerrar/cancelar só podem ser executadas pelo analista responsavel pelo processo ou seu superior imediato.

        ação 'DEVOLVER_ANALISTA_MEU_CLIENTE'
            so deve aparecer para analista BKO/FO quando não eh ele mesmo o responsavel o processo e o analista logado é o 
            analista com o processo
    */

    if ( _idAtividade == DEVOLVER_ANALISTA_MEU_CLIENTE )
    {
        if ( varOraIdPessoaUsuarioMC == idPessoaUsuarioWeb )
        { // analista responsável pelo processo não deve devolver para ele mesmo!
            ULOG_END("proCPermitirAcaoProcMC() ==> DEVOLVER_ANALISTA_MEU_CLIENTE off (1)");
            return false;
        }

        if ( idPessoaUsuarioWeb != varOraIdPessoaUsuarioAtual )
        { // Só o analista BKO que recebeu o processo MC2 é que pode acionar a ação de devolução ao BKO

        // Não houve solicitação disso -->
        //    // ultima chance... vamos ver se o cara pelo menos é supervisor do grupo de retorno.
        //    EXEC SQL
        //        SELECT
        //            NVL(INSUPERVISOR,0) AS INSUPERVISOR
        //        INTO
        //            :varOraInSupervisor:statOraInSupervisor
        //        FROM
        //            ACESSO.USUARIOGRUPO
        //        WHERE
        //            IDPESSOAUSUARIO = :idPessoaUsuarioWeb
        //        AND IDGRUPO = :varOraIdGrupoMC;
        //
        //    if ( sqlca.sqlcode )
        //    {
        //        ULOG_END("proCPermitirAcaoProcMC() ==> INSUPERVISOR <<NOT FOUND>> (1)");
        //        return false;
        //    }
        //
        //    ULOG("      inSupervisor(1)=%d",varOraInSupervisor);

        //    if ( 0==varOraInSupervisor )
        //    { // nem supervisor o cara é, então a ação fica indisponível mesmo.
                ULOG_END("proCPermitirAcaoProcMC() ==> DEVOLVER_ANALISTA_MEU_CLIENTE off (2)");
                return false;
        //    }
        }

    }
    else
    { // atividades cancelar/fechar/encerrar/devolver bko
        EXEC SQL
            SELECT
                NVL(INSUPERVISOR,0) AS INSUPERVISOR
            INTO
                :varOraInSupervisor:statOraInSupervisor
            FROM
                ACESSO.USUARIOGRUPO
            WHERE
                IDPESSOAUSUARIO = :idPessoaUsuarioWeb
            AND IDGRUPO = :varOraIdGrupoMC;

        if ( sqlca.sqlcode )
        {
            ULOG_END("proCPermitirAcaoProcMC() ==> INSUPERVISOR <<NOT FOUND>> (2)");
            return varOraIdPessoaUsuarioMC == idPessoaUsuarioWeb ? true : false;
        }

        ULOG("      inSupervisor(2)=%d",varOraInSupervisor);

        if (_idAtividade == DEVOLVER_BKO_D ||
            _idAtividade == DEVOLVER_BKO_DCRI ||
            _idAtividade == DEVOLVER_BKO_DR )
        {
            if ( varOraIdPessoaUsuarioMC != idPessoaUsuarioWeb && 0==varOraInSupervisor )
            { // analista responsável pelo processo não deve devolver para ele mesmo!
                ULOG_END("proCPermitirAcaoProcMC() ==> DEVOLVER_ANALISTA_MEU_CLIENTE off (3)");
                return false;
            }
        }
        else
        { // se cancelamento/encerramento/fechamento ...
            if ( varOraIdPessoaUsuarioMC != idPessoaUsuarioWeb && 0==varOraInSupervisor )
            { // analista responsável pelo processo não deve devolver para ele mesmo!
                ULOG_END("proCPermitirAcaoProcMC() ==> DEVOLVER_ANALISTA_MEU_CLIENTE off (4)");
                return false;
            }
        }
    }

    ULOG_END("proCPermitirAcaoProcMC() ==> TRUE"); 

    return true;
}

void sql_error_WFDetAcao(sqlca*sqlca)
{
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    ULOGE("sql_error_WFDetAcao:sqlcode=%d,sqlerrmc=%.70s"
                              ,sqlca->sqlcode
                              ,sqlca->sqlerrm.sqlerrmc);

    throw new TuxBasicOraException(sqlca->sqlcode
                                  ,sqlca->sqlerrm.sqlerrmc
                                  ,sqlca->sqlerrm.sqlerrml);
}
