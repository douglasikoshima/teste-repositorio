/**
 * @author  Renato Teixeira
 * @version $Revision: 1.1.2.1.6.2 $
 * @CVS     $Author: a5114878 $ - $Date: 2013/02/06 12:36:43 $
 **/ 

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"

#include "../include/cWFChamadaAtendimento.h"
#include "../include/stWFChamadaAtendimento.h"

// Declara as estruturas compatíveis ao ProC.
EXEC SQL BEGIN DECLARE SECTION;
#include "../include/stWFChamadaAtendimento.h"
EXEC SQL END DECLARE SECTION;

void sql_error_WFChamadaAtendimento(sqlca*sqlca);

long proCIncluirWFChamadaAtendimento(st_ChamadaAtendimento* dados, st_vlChamadaAtendimento* status) 
{
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        struct st_ChamadaAtendimento   oDados;
        struct st_vlChamadaAtendimento oStatus;
        int nCount;
    EXEC SQL END DECLARE SECTION;

    memcpy(&oDados,  dados,  sizeof(oDados));
    memcpy(&oStatus, status, sizeof(oStatus));

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFChamadaAtendimento(&sqlca);

    // Não irá gravar registro de chamada telefonica para usuários URA/VOL/TAV e BAC
    EXEC SQL
        SELECT
            COUNT(1)
        INTO
            :nCount
        FROM
            ACESSO.USUARIO
        WHERE
            IDPESSOAUSUARIO = :oDados.idUsuarioAlteracao
        AND (UPPER(NMLOGINUSUARIO) LIKE 'BAC_%'
          OR UPPER(NMLOGINUSUARIO) LIKE 'URA%'
          OR UPPER(NMLOGINUSUARIO) = 'USUARIO URA'
          OR UPPER(NMLOGINUSUARIO) = 'URA/MIGRACAO'
          OR UPPER(NMLOGINUSUARIO) = 'USUARIO VOL'
          OR UPPER(NMLOGINUSUARIO) = 'USUARIO TAV');

    if ( 0 == nCount )
    {
        EXEC SQL
            SELECT 
                ATENDIMENTO.CHAMADAATENDIMENTOSQ.NEXTVAL 
            INTO 
                :oDados.idChamadaAtendimento
            FROM
                DUAL;

        EXEC SQL
            INSERT INTO
                ATENDIMENTO.CHAMADAATENDIMENTO
                (
                    IDCHAMADAATENDIMENTO,
                    IDATENDIMENTO,
                    IDCHAMADATELEFONICA,
                    IDUSUARIOALTERACAO,
                    DTULTIMAALTERACAO
                )
                VALUES
                (
                    :oDados.idChamadaAtendimento,
                    :oDados.idAtendimento,
                    :oDados.idChamadaTelefonica,
                    DECODE(:oStatus.idUsuarioAlteracao, -1,NULL,:oDados.idUsuarioAlteracao),
                    TO_DATE(DECODE(:oStatus.dtUltimaAlteracao,-1,NULL,:oDados.dtUltimaAlteracao),'DD/MM/YYYY HH24:MI:SS')
                );
    }

    return oDados.idAtendimento;
}

bool proCAlterarWFChamadaAtendimento(st_ChamadaAtendimento* dados, st_vlChamadaAtendimento* status, XMLGen* saida) {

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        struct st_ChamadaAtendimento   oDados;
        struct st_vlChamadaAtendimento oStatus;

        char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFChamadaAtendimento(&sqlca);

    memcpy(&oDados,  dados,  sizeof(oDados));
    memcpy(&oStatus, status, sizeof(oStatus));

    sprintf(query,"%s", "UPDATE atendimento.ChamadaAtendimento SET ");

    bool separa = false;

    if (status->idAtendimento != -1) 
        montaUpdate("idAtendimento", oDados.idAtendimento, 1);

    if (status->idChamadaTelefonica != -1) 
        montaUpdate("idChamadaTelefonica", oDados.idChamadaTelefonica, 1);

    if (status->idUsuarioAlteracao != -1) 
        montaUpdate("idUsuarioAlteracao", oDados.idUsuarioAlteracao, TIPO_INT);

    if (status->dtUltimaAlteracao != -1) 
        montaUpdate("dtUltimaAlteracao", oDados.dtUltimaAlteracao, TIPO_DATAHORA);

    sprintf(query, "%s WHERE idChamadaAtendimento = %ld", query, dados->idChamadaAtendimento);

    EXEC SQL EXECUTE IMMEDIATE :query;

    return true;
}

bool proCExcluirWFChamadaAtendimento(st_ChamadaAtendimento* dados, st_vlChamadaAtendimento* status, XMLGen* saida) {

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idChamadaAtendimento = dados->idChamadaAtendimento;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFChamadaAtendimento(&sqlca);

    EXEC SQL 
        DELETE
            atendimento.ChamadaAtendimento
        WHERE
            idChamadaAtendimento = :idChamadaAtendimento;

    return true;
}

bool proCConsultaWFChamadaAtendimento(st_ChamadaAtendimento* dados, st_vlChamadaAtendimento* status, char* order, XMLGen* saida) {

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idChamadaAtendimento;
        long idAtendimento;
        int idChamadaTelefonica;

        char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    sprintf(query,"SELECT idChamadaAtendimento, idAtendimento, idChamadaTelefonica FROM atendimento.ChamadaAtendimento ");

    bool separa = false;

    if (status->idChamadaAtendimento != -1) 
        montaWhere("idChamadaAtendimento", dados->idChamadaAtendimento, 1);

    if (status->idAtendimento != -1)
        montaWhere("idAtendimento", dados->idAtendimento, 1);

    if (status->idChamadaTelefonica != -1)
        montaWhere("idChamadaTelefonica", dados->idChamadaTelefonica, 1);

    if (status->idUsuarioAlteracao != -1) 
        montaWhere("idUsuarioAlteracao", dados->idUsuarioAlteracao, TIPO_INT);

    if (status->dtUltimaAlteracao != -1) 
        montaWhere("dtUltimaAlteracao", dados->dtUltimaAlteracao, TIPO_DATAHORA);

    if (strlen(order) > 0) 
        sprintf( query, "%s ORDER BY %s ", query, order);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFChamadaAtendimento(&sqlca);

    EXEC SQL PREPARE consultaChamadaAtendimento FROM :query;
    EXEC SQL DECLARE consulta CURSOR FOR consultaChamadaAtendimento;

    EXEC SQL OPEN consulta;

    while (true)
    {
        EXEC SQL FETCH consulta INTO 
                                    :idChamadaAtendimento, 
                                    :idAtendimento, 
                                    :idChamadaTelefonica;
                                

        saida->createTag("WFChamadaAtendimentoVO");
            saida->addItem("idChamadaAtendimento", idChamadaAtendimento);
            saida->addItem("idAtendimento", idAtendimento);
            saida->addItem("idChamadaTelefonica", idChamadaTelefonica);
        saida->closeTag();
    }

    EXEC SQL CLOSE consulta;

    return true;
}

bool proCConsultaContato(st_ChamadaAtendimento* dados, st_vlChamadaAtendimento* status, XMLGen* saida) {

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        int idChamadaTelefonica = dados->idChamadaTelefonica;

        long idAtendimento;
        int flagConsulta = -1;
        VARCHAR path[256];

        short i_path;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFChamadaAtendimento(&sqlca);

    //
    // Incidencia 3303.
    // Esta consulta se faz necessaria, pois no caso de atendimento nao
    // identificado o codigo java possue um hard code para IDPESSOADEPARA = 26.
    // Sendo assim, seria impossivel retornar a pesquisa, pois existem milhares
    // de registros na base.
    // A "solucao" adotada, foi inibir a consulta nesta situacao.
    //  
    // 2006-04-07 @ Marcelo @
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        SELECT 
            COUNT(1)
        INTO
            :flagConsulta 
        FROM 
            ATENDIMENTO.CHAMADATELEFONICA
        WHERE 
            IDPESSOADEPARA = 26 --//'Não cliente'
        AND 
            IDCHAMADATELEFONICA = :idChamadaTelefonica;

    //
    //  Condicao feita, conforme o comentario da incidencia 3303.
    //
    if ( 0 == flagConsulta )
    {
        //Quando um processo eh aberto como 'nao identificado' o sistema grava idChamadaTelefonica com o valor 1
        //que tem alguns milhoes de registros
        //Tambem verifiquei que exite um valor 0. Não sei quem grava, mas existem milhoes na tabela. (Eder)
        //Para evitar o problema de retornar muitas linhas estou colocando o IF abaixo
        if( idChamadaTelefonica > 1 )
        {
    
            EXEC SQL WHENEVER NOT FOUND DO BREAK;

            EXEC SQL DECLARE consultarAtdHierarquia CURSOR FOR
                SELECT
                    IDATENDIMENTO,
                    PATH
                FROM    
                    ATENDIMENTO.CHAMADAATENDIMENTOCONTATOV01
                WHERE   
                    IDCHAMADATELEFONICA = :idChamadaTelefonica
                ORDER BY
                    IDATENDIMENTO,
                    PATH;
            
            EXEC SQL OPEN consultarAtdHierarquia;
            
            while (true)
            {
                i_path = -1;
        
                EXEC SQL FETCH consultarAtdHierarquia INTO 
                    :idAtendimento, 
                    :path:i_path;
            
                CONVIND(path,i_path);
            
                saida->createTag("AtendimentoVO");
                    saida->addItem("idAtendimento", idAtendimento);
                    saida->createTag("ArvoreAtendimentoVO");
                        saida->addProp("xmlns","admsistemas.fo.vivo.com.br/vo");
                        saida->addItem("descricaoCompleta", (char*)path.arr);
                    saida->closeTag();
                saida->closeTag();
            }
            
            EXEC SQL CLOSE consultarAtdHierarquia;
    
        }//if( idChamadaTelefonica > 1 )
    }

    return true;
}

void sql_error_WFChamadaAtendimento(sqlca*sqlca) {
    throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
