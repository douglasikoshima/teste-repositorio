#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <sqlda.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tuxfw.h>


class TuxHelperImpl:public TuxHelper
{
public:
	DOMNode * walkDOMImpl( DOMNode*a , char*b , int*c , int d )
	{
		return walkDOM( a , b , c , d );
	}
};


int ValidaDependencias(const char* idParam, int idOperacao)
{
   ULOG_START("ValidaDependencias()");
	 struct sqlca sqlca;
	
	EXEC SQL BEGIN DECLARE SECTION;
		int idGrupo;
		int iRetorno=0;
	EXEC SQL END DECLARE SECTION;
	
	
	
	idGrupo = atoi( idParam );

	switch(idOperacao)
	{
	case 1:
			ULOG( "Case 1");
	EXEC SQL
		SELECT 
			COUNT(1)
		INTO
			:iRetorno
		FROM
				ACESSO.GRUPOSKILL
		WHERE
			IDGRUPO = :idGrupo;
		break;

	case 2:
			ULOG( "Case 2");
	EXEC SQL
		SELECT
				USUARIOS
		INTO
			:iRetorno
		FROM
		(
				SELECT 
					COUNT(1) AS USUARIOS
			FROM
					ACESSO.USUARIOGRUPOSKILL
			WHERE
				IDGRUPOSKILL IN
				(
					SELECT
						IDGRUPOSKILL
					FROM
						ACESSO.GRUPOSKILL
					WHERE
						IDGRUPO = :idGrupo
				)
		);
	break;
	}

	ULOG_END("ValidaDependencias()");
	return iRetorno;
}


int RemoveUsuarioSkill(const char*idParam)
{
   ULOG_START("RemoveUsuarioSkill()");
   struct sqlca sqlca;
   
   EXEC SQL BEGIN DECLARE SECTION;
      int idGrupoParam;
   EXEC SQL END DECLARE SECTION;

	ULOG( "==========================RemoveUsuarioSkill========================================");
   idGrupoParam = atoi( idParam );

	EXEC SQL WHENEVER SQLERROR GOTO UndefinedError;
	
	EXEC SQL 
	DELETE FROM 
		ACESSO.USUARIOGRUPOSKILL
   	WHERE 
   		IDGRUPOSKILL IN
   		(
   			SELECT 
   				IDGRUPOSKILL
			FROM 
				ACESSO.GRUPOSKILL
			WHERE 
				IDGRUPO= :idGrupoParam
		);


/*Conforme incidencia 
 *	//Removendo grupo Skill
 *EXEC SQL WHENEVER SQLERROR GOTO UndefinedError;
 *EXEC SQL DELETE FROM acesso.GRUPOSKILL
 *WHERE idGrupo =:idGrupoParam;*/
  

   if( sqlca.sqlcode )
   {
     if( sqlca.sqlcode != -1403 && sqlca.sqlcode != 1403 )
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
   }
   else
   {
      ULOG_END("RemoveUsuarioSkill()");
      return 1;
   }

UndefinedError:
        if( sqlca.sqlcode != -1403 && sqlca.sqlcode != 1403 )
           throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
        return 1;


}

int InsereTipoLinha( const char * idParam, DOMNode *dnode )
{
   ULOG_START("InsereTipoLinha()");
	DOMNode *pNoCodigo;
	struct sqlca sqlca;
	TuxHelper tuxHelper;
	TuxHelperImpl tuxhelperIMPL;

	char * pCodGrupoTmp;

	EXEC SQL BEGIN DECLARE SECTION;
	struct vo_TipoLinha_struct 
	{
			int idGrupo;
			int idTipoLinha;
	} ORA_sql_TipoLinha;
	EXEC SQL END DECLARE SECTION;

  	memset( &ORA_sql_TipoLinha, 0x0, sizeof(vo_TipoLinha_struct));
	sqlca.sqlcode=0;
    

   ORA_sql_TipoLinha.idGrupo = atoi( idParam );
   EXEC SQL WHENEVER SQLERROR GOTO UndefinedError;
    
   /*
	 * Pega todos os codigos
	 */
	int SubnoAtual = 0;
	int Subno = 0;
	for ( ;; )  
	{
	   Subno = 0;
		pNoCodigo = tuxhelperIMPL.walkDOMImpl( dnode,"TipoLinhaVO",&Subno,SubnoAtual++ );
		if ( pNoCodigo == NULL )
		{
		   ULOG_END("InsereTipoLinha() -> pNoCodigo == NULL  return 1");
		   return 1;
		}

      pCodGrupoTmp = tuxHelper.walkTree( pNoCodigo,"id",0 );
		if ( pCodGrupoTmp == NULL )
		   break;
      ORA_sql_TipoLinha.idTipoLinha = atoi( pCodGrupoTmp );
      XMLString::release(&pCodGrupoTmp);

		EXEC SQL INSERT INTO contatoadm.TipoLinhaGrupo 
        ( 
           idTipoLinhaGrupo , 
           idGrupo , 
           idTipoLinha 
        )
		VALUES
	    ( 
           contatoadm.TipoLinhaGrupoSQ.nextval , 
           :ORA_sql_TipoLinha.idGrupo , 
           :ORA_sql_TipoLinha.idTipoLinha 
        );
		if( sqlca.sqlcode )
		{
		   ULOG_END("InsereTipoLinha() -> sqlca.sqlcode > 0 return 0");
			return 0;
		}
    }
    ULOG_END("InsereTipoLinha() ->  return 1");
    return 1;

UndefinedError:
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
    
}


