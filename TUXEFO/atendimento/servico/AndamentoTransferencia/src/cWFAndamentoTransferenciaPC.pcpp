#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"
#include "../../../commons/msgPadrao.h"


#include "../include/cWFAndamentoTransferencia.h"
#include "../include/stWFAndamentoTransferencia.h"

void sql_error_WFAndamentoTransferencia(sqlca*sqlca);

    // Declara as estruturas compatíveis ao ProC.
    EXEC SQL BEGIN DECLARE SECTION;
        #include "../include/stWFAndamentoTransferencia.h"
    EXEC SQL END DECLARE SECTION;

bool proCIncluirWFAndamentoTransferencia(st_AndamentoTransferencia* dados, st_vlAndamentoTransferencia* status, XMLGen* saida)
{

    ULOG_START( "proCIncluirWFAndamentoTransferencia()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        struct st_AndamentoTransferencia   oDados;
        struct st_vlAndamentoTransferencia oStatus;

    EXEC SQL END DECLARE SECTION;

    memcpy(&oDados,  dados,  sizeof(oDados));
    memcpy(&oStatus, status, sizeof(oStatus));


    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAndamentoTransferencia(&sqlca);

    ULOG( "idAndamento           [%ld]", oDados.idAndamento );
    ULOG( "idPessoaUsuario       [%d]", oDados.idPessoaUsuario );
    ULOG( "dtInicioTransferencia [%s]", oDados.dtInicioTransferencia );
    ULOG( "dtFimTransferencia    [%s]", oDados.dtFinTransferencia );

    EXEC SQL 
        INSERT INTO
            atendimento.AndamentoTransferencia
            (
                idAndamento,
                idPessoaUsuario,
                dtInicioTransferencia,
                dtFimTransferencia,
                idUsuarioAlteracao,
                dtUltimaAlteracao
            )
            VALUES
            (
                :oDados.idAndamento,
                :oDados.idPessoaUsuario,
                TO_DATE(DECODE(:oStatus.dtInicioTransferencia, -1, NULL, :oDados.dtInicioTransferencia),'DD/MM/YYYY HH24:MI:SS'),
                TO_DATE(DECODE(:oStatus.dtFinTransferencia, -1, NULL,:oDados.dtFinTransferencia),'DD/MM/YYYY HH24:MI:SS'),
                DECODE(:oStatus.idUsuarioAlteracao, -1, NULL, :oDados.idUsuarioAlteracao),
                TO_DATE(DECODE(:oStatus.dtUltimaAlteracao, -1, NULL, :oDados.dtUltimaAlteracao),'DD/MM/YYYY HH24:MI:SS')
            );

    saida->createTag("Registro");
        saida->addItem("idAndamento", oDados.idAndamento);
    saida->closeTag();

    ULOG_END( "proCIncluirWFAndamentoTransferencia()" );

    return true;
}

bool proCAlterarWFAndamentoTransferencia(st_AndamentoTransferencia* dados, st_vlAndamentoTransferencia* status, XMLGen* saida)
{

    ULOG_START( "proCAlterarWFAndamentoTransferencia()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        struct st_AndamentoTransferencia   oDados;
        struct st_vlAndamentoTransferencia oStatus;

        char query[800];

    EXEC SQL END DECLARE SECTION;


    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAndamentoTransferencia(&sqlca);

    memcpy(&oDados,  dados,  sizeof(oDados));
    memcpy(&oStatus, status, sizeof(oStatus));

    sprintf(query,"%s", "UPDATE atendimento.AndamentoTransferencia SET ");

    bool separa = false;

    if (status->idPessoaUsuario != -1) 
        montaUpdate("idPessoaUsuario", oDados.idPessoaUsuario, 1);

    if (status->dtInicioTransferencia != -1) 
        montaUpdate("dtInicioTransferencia", oDados.dtInicioTransferencia, TIPO_DATAHORA);

    if (status->dtFinTransferencia != -1) 
        montaUpdate("dtFimTransferencia", oDados.dtFinTransferencia, TIPO_DATAHORA);

    if (status->idUsuarioAlteracao != -1) 
        montaUpdate("idUsuarioAlteracao", oDados.idUsuarioAlteracao, TIPO_INT);

    if (status->dtUltimaAlteracao != -1) 
        montaUpdate("dtUltimaAlteracao", oDados.dtUltimaAlteracao, TIPO_DATAHORA);

    sprintf(query, "%s WHERE idAndamento = %ld", query, dados->idAndamento);

    ULOG( "QUERY [%s]",query );

    EXEC SQL EXECUTE IMMEDIATE :query;

    ULOG_END( "proCAlterarWFAndamentoTransferencia()" );

    return true;
}

bool proCExcluirWFAndamentoTransferencia(st_AndamentoTransferencia* dados, st_vlAndamentoTransferencia* status, XMLGen* saida)
{

    ULOG_START( "proCExcluirWFAndamentoTransferencia()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAndamento = dados->idAndamento;

    EXEC SQL END DECLARE SECTION;

    ULOG( "idAndamento [%ld]",idAndamento );

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAndamentoTransferencia(&sqlca);

    ULOG( "Removendo [%ld]", idAndamento );
    EXEC SQL 
        DELETE
            atendimento.AndamentoTransferencia
        WHERE
            idAndamento = :idAndamento;

    ULOG_END( "proCExcluirWFAndamentoTransferencia()" );

    return true;
}

bool proCConsultaWFAndamentoTransferencia(st_AndamentoTransferencia* dados, st_vlAndamentoTransferencia* status, char* order, XMLGen* saida)
{

    ULOG_START( "proCConsultaWFAndamentoTransferencia()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAndamento;
        int idPessoaUsuario;

        char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAndamentoTransferencia(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    sprintf(query,"SELECT idAndamento, idPessoaUsuario FROM atendimento.AndamentoTransferencia ");

    bool separa = false;

    if (status->idAndamento != -1) 
        montaWhere("idAndamento", dados->idAndamento, 1);

    if (status->idPessoaUsuario != -1)
        montaWhere("idPessoaUsuario", dados->idPessoaUsuario, 1);

    if (strlen(order) > 0) 
        sprintf( query, "%s ORDER BY %s ", query, order);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAndamentoTransferencia(&sqlca);

    ULOG( "QUERY [%s]",query );

    EXEC SQL PREPARE consultaAndamentoTransferencia FROM :query;
    EXEC SQL DECLARE consulta CURSOR FOR consultaAndamentoTransferencia;

    EXEC SQL OPEN consulta;

    while (true)
    {
        EXEC SQL FETCH consulta INTO :idAndamento, :idPessoaUsuario;

        saida->createTag("WFAndamentoTransferenciaVO");
            saida->addItem("idAndamento", idAndamento);
            saida->addItem("idPessoaUsuario", idPessoaUsuario);
        saida->closeTag();
    }

    EXEC SQL CLOSE consulta;

    ULOG_END( "proCConsultaWFAndamentoTransferencia()" );

    return true;

}

bool proCObtemWFAndamentoTransferencia(long sIdAtendimento, XMLGen* saida)
{

    ULOG_START( "proCObtemWFAndamentoTransferencia()" );
    
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long      idAtendimento = sIdAtendimento;
        long      idAndamento;

        short    i_idAndamento;

    EXEC SQL END DECLARE SECTION;


    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAndamentoTransferencia(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE consultaAtdTransferencia CURSOR FOR

    SELECT 
        IDANDAMENTO
    FROM 
        ATENDIMENTO.OBTEMATDTRANSFERENCIAV01 
    WHERE 
        IDATENDIMENTO = :idAtendimento
        AND DTFINTRANSFERENCIA IS NULL;
                    
    ULOG( "idAtendimento [%ld]",idAtendimento );

    EXEC SQL OPEN consultaAtdTransferencia;

    while (true)
    {
        EXEC SQL FETCH consultaAtdTransferencia INTO 
                                    :idAndamento:i_idAndamento;
                                    
        saida->createTag("WFAtdTransferenciaVO");
            saida->addItem( "idAndamento",idAndamento );
        saida->closeTag();
    }

    EXEC SQL CLOSE consultaAtdTransferencia;

    ULOG_END( "proCObtemWFAndamentoTransferencia()" );

    return true;

}




void sql_error_WFAndamentoTransferencia(sqlca*sqlca)
{
    throw new 
       TuxBasicOraException
       (
            sqlca->sqlcode,
            sqlca->sqlerrm.sqlerrmc,
            sqlca->sqlerrm.sqlerrml
       );
}
