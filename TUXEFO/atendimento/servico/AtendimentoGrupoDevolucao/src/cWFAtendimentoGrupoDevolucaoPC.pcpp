#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"


#include "../include/cWFAtendimentoGrupoDevolucao.h"
#include "../include/stWFAtendimentoGrupoDevolucao.h"

void sql_error_WFAtendimentoGrupoDevolucao(sqlca*sqlca);

// Declara as estruturas compatíveis ao ProC.
EXEC SQL BEGIN DECLARE SECTION;

#include "../include/stWFAtendimentoGrupoDevolucao.h"
EXEC SQL END DECLARE SECTION;

bool proCIncluirWFAtendimentoGrupoDevolucao(st_AtendimentoGrupoDevolucao* dados, st_vlAtendimentoGrupoDevolucao* status, XMLGen* saida)
{
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AtendimentoGrupoDevolucao   *oDados = dados;
		struct st_vlAtendimentoGrupoDevolucao *oStatus = status;

	EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoGrupoDevolucao(&sqlca);

	// EXEC SQL 
	// 	INSERT INTO
	// 		atendimento.AtendimentoGrupoDevolucao
	// 		(
	// 			idAtendimento,
	// 			idGrupo
	// 		)
	// 		VALUES
	// 		(
	// 			:oDados->idAtendimento,
	// 			:oDados->idGrupo
	// 		);

    // ==> Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
    // Versão piloto. Nesta versão devido a data de entrega muito próxima
    // estou apenas atualizando os campos novos que foram desnormalizados
    // junto com as tabelas respectivas para em uma segunda versão, com mais
    // tempo poder criar métodos especificos e mais rápidos para a atualização
    // destes campos em objetos respectivos às tabelas sendo atualizadas.
    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        SET
            IDGRUPOANTERIOR = :oDados->idGrupo,
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :oDados->idAtendimento;
    // <== Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio

    saida->createTag("Registro");
		saida->addItem("idAtendimento", oDados->idAtendimento);
	saida->closeTag();

	return true;
}

bool proCAlterarWFAtendimentoGrupoDevolucao(st_AtendimentoGrupoDevolucao* dados, st_vlAtendimentoGrupoDevolucao* status, XMLGen* saida)
{
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AtendimentoGrupoDevolucao   *oDados = dados;
		struct st_vlAtendimentoGrupoDevolucao *oStatus = status;

		// char query[1024] = "UPDATE atendimento.AtendimentoGrupoDevolucao SET ";

    EXEC SQL END DECLARE SECTION;
    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoGrupoDevolucao(&sqlca);

	// bool separa = false;

	// if (status->idGrupo != -1) 
	// 	montaUpdate("idGrupo", oDados.idGrupo, 1);

	// sprintf(query, "%s WHERE idAtendimento = %ld", query, oDados.idAtendimento);

	// EXEC SQL EXECUTE IMMEDIATE :query;

    // ==> Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
    // Versão piloto. Nesta versão devido a data de entrega muito próxima
    // estou apenas atualizando os campos novos que foram desnormalizados
    // junto com as tabelas respectivas para em uma segunda versão, com mais
    // tempo poder criar métodos especificos e mais rápidos para a atualização
    // destes campos em objetos respectivos às tabelas sendo atualizadas.
    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        SET
            IDGRUPOANTERIOR = :oDados->idGrupo,
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :oDados->idAtendimento;
    // <== Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio

	return true;
}

bool proCExcluirWFAtendimentoGrupoDevolucao(st_AtendimentoGrupoDevolucao* dados, st_vlAtendimentoGrupoDevolucao* status, XMLGen* saida)
{
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimento = dados->idAtendimento;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoGrupoDevolucao(&sqlca);

    // ==> Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
    // Versão piloto. Nesta versão devido a data de entrega muito próxima
    // estou apenas atualizando os campos novos que foram desnormalizados
    // junto com as tabelas respectivas para em uma segunda versão, com mais
    // tempo poder criar métodos especificos e mais rápidos para a atualização
    // destes campos em objetos respectivos às tabelas sendo atualizadas.
 	// EXEC SQL 
	// 	DELETE
	// 		atendimento.AtendimentoGrupoDevolucao
	// 	WHERE
	// 		idAtendimento = :idAtendimento;

   EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        SET
            IDGRUPOANTERIOR = NULL,
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :idAtendimento;
    // <== Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio

	return true;
}

bool proCAtualizarWFAtendimentoGrupoDevolucao(long _idAtendimento,int _idGrupo,int _idUsuarioAlteracao)
{
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
		long idAtendimento = _idAtendimento;
        int idGrupo = _idGrupo;
        int idUsuarioAlteracao = _idUsuarioAlteracao;
        //int contador;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoGrupoDevolucao(&sqlca);

    // EXEC SQL
    //     SELECT
    //         COUNT(1)
    //     INTO
    //         :contador
    //     FROM
    //         ATENDIMENTO.ATENDIMENTOGRUPODEVOLUCAO
    //     WHERE
    //         IDATENDIMENTO = :idAtendimento;

    // if ( contador )
    // {
    //     EXEC SQL
    //         UPDATE
    //             ATENDIMENTO.ATENDIMENTOGRUPODEVOLUCAO
    //         SET
    //             IDGRUPO = :idGrupo,
    //             IDUSUARIOALTERACAO = idUsuarioAlteracao,
    //             DTULTIMAALTERACAO = SYSDATE
    //         WHERE
    //             IDATENDIMENTO = :idAtendimento;
    // }
    // else
    // {
    //     EXEC SQL
    //         INSERT INTO
    //             ATENDIMENTO.ATENDIMENTOGRUPODEVOLUCAO(IDATENDIMENTO
    //                                                     ,IDGRUPO
    //                                                     ,IDUSUARIOALTERACAO
    //                                                     ,DTULTIMAALTERACAO)
    //         VALUES(:idAtendimento
    //               ,:idGrupo
    //               ,:idUsuarioAlteracao
    //               ,SYSDATE);
    // }

    // ==> Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
    // Versão piloto. Nesta versão devido a data de entrega muito próxima
    // estou apenas atualizando os campos novos que foram desnormalizados
    // junto com as tabelas respectivas para em uma segunda versão, com mais
    // tempo poder criar métodos especificos e mais rápidos para a atualização
    // destes campos em objetos respectivos às tabelas sendo atualizadas.
    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        SET
            IDGRUPOANTERIOR = :idGrupo,
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :idAtendimento;
    // <== Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio

    return sqlca.sqlcode ? false : true;
}

bool proCConsultaWFAtendimentoGrupoDevolucao(st_AtendimentoGrupoDevolucao* dados, st_vlAtendimentoGrupoDevolucao* status, char* order, XMLGen* saida)
{
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
		long idAtendimento = dados->idAtendimento;
		VARCHAR idGrupo[21];
        short i_idGrupo = -1;
		// char query[800] = "SELECT idAtendimento,idGrupo "
        //                     "FROM atendimento.AtendimentoGrupoDevolucao ";
    EXEC SQL END DECLARE SECTION;

    // EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoGrupoDevolucao(&sqlca);
	// EXEC SQL WHENEVER NOT FOUND DO BREAK;

	// bool separa = false;

	// if (status->idAtendimento != -1) 
	// 	montaWhere("idAtendimento", dados->idAtendimento, 1);

	// if (status->idGrupo != -1)
	// 	montaWhere("idGrupo", dados->idGrupo, 1);

	// if (strlen(order) > 0) 
	// 	sprintf( query, "%s ORDER BY %s ", query, order);

    ULOG("idAtendimento=%ld",idAtendimento);

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoGrupoDevolucao(&sqlca);
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        SELECT 
            IDGRUPOANTERIOR
        INTO
            idGrupo:i_idGrupo
        FROM
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        WHERE
            IDATENDIMENTO = :idAtendimento;

    if ( !sqlca.sqlcode )
    {
        CONVIND(idGrupo,i_idGrupo);

        ULOG("idGrupo=%s",idGrupo.arr);

	    // EXEC SQL PREPARE consultaAtendimentoGrupoDevolucao FROM :query;
	    // EXEC SQL DECLARE consulta CURSOR FOR consultaAtendimentoGrupoDevolucao;

	    // EXEC SQL OPEN consulta;

	    // while (true)
	    // {
		    //EXEC SQL FETCH consulta INTO :idAtendimento, :idGrupo;

		    saida->createTag("WFAtendimentoGrupoDevolucaoVO");
			    saida->addItem("idAtendimento",idAtendimento);
			    saida->addItem("idGrupo",(char*)idGrupo.arr);
		    saida->closeTag();
	    // }
    }

	// EXEC SQL CLOSE consulta;

	return true;
}

void sql_error_WFAtendimentoGrupoDevolucao(sqlca*sqlca)
{
	throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
