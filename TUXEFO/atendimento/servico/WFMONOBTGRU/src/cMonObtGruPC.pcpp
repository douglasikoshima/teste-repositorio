/**
 * @author  Renato Teixeira
 * @version $Revision: 1.1 $
 * @CVS     $Author: a5110702 $ - $Date: 2009/07/31 15:33:39 $
 **/

#include "../include/cMonObtGruPC.h"

#ifdef WIN32
#pragma warning(disable:4786)
#endif
#include <string>
using namespace std;


void cMonObtGruPC::obtemRegionaisPC( st_VariaveisRegional *_dadosEntradaPC, Collection *_ResultadoPC )
{
    ULOG_START("cMonObtGruPC::obtemRegionaisPC()");

    struct sqlca sqlca;
    st_VariaveisRegional *regionaisPC;

    EXEC SQL BEGIN DECLARE SECTION;

        VARCHAR idRegional[ 256 ];
        VARCHAR dsRegional[ 256 ];

        short i_idRegional;
        short i_dsRegional;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFobtemGrupos( &sqlca );
    EXEC SQL WHENEVER NOT FOUND DO BREAK; 

    EXEC SQL DECLARE ObtemRegionais CURSOR FOR
        SELECT IDREGIONAL,DSREGIONAL
        FROM
        (
          SELECT 
                UO.IDUFOPERADORA AS IDREGIONAL
               ,UF.SGUF || ' - ' || P.NMPESSOA AS DSREGIONAL
            FROM 
                CUSTOMER.UFOPERADORA UO,
                CUSTOMER.OPERADORA O,
                CUSTOMER.PESSOADEPARA PDP,
                CUSTOMER.PESSOA P,
                APOIO.UF UF
            WHERE
                UO.IDUF = UF.IDUF
            AND
                UO.IDPESSOADEPARAOPERADORA = O.IDPESSOADEPARAOPERADORA
            AND
                O.IDPESSOADEPARAOPERADORA = PDP.IDPESSOADEPARA
            AND
                PDP.IDPESSOA = P.IDPESSOA
        )
        ORDER BY 
           DSREGIONAL;

    EXEC SQL OPEN ObtemRegionais;

    for ( ;; )
    {
        i_idRegional = i_dsRegional = -1;

        EXEC SQL FETCH ObtemRegionais INTO :idRegional:i_idRegional,:dsRegional:i_dsRegional;

        CONVIND( idRegional, i_idRegional );
        CONVIND( dsRegional, i_dsRegional );

        regionaisPC = new st_VariaveisRegional;

        if ( regionaisPC )
        {
            strcpy(regionaisPC->idRegional,(char*) idRegional.arr);
            strcpy(regionaisPC->dsRegional,(char*) dsRegional.arr);

            _ResultadoPC->AddItem( (void*) regionaisPC );
        }
        else
        {
            ULOGE("Falha de alocação de memória");
        }
    }

    EXEC SQL CLOSE ObtemRegionais;    

    ULOG_END("cMonObtGruPC::obtemRegionaisPC()");
}

void cMonObtGruPC::obterTiposCarteiraPC( st_VariaveisTipoCarteira *_dadosEntradaPC, Collection *_ResultadoPC )
{
    ULOG_START("cMonObtGruPC::obterTiposCarteiraPC()");

    struct sqlca sqlca;
    st_VariaveisTipoCarteira *tipoCarteiraPC;

    EXEC SQL BEGIN DECLARE SECTION;
        
        struct
        {
            VARCHAR idTipoCarteira[21];
            VARCHAR dsTipoCarteira[256];
        } oraDadosTipoCarteira;

        struct
        {
            short idTipoCarteira;
            short dsTipoCarteira;
        } oraStatusTipoCarteira;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFobtemGrupos( &sqlca );
    EXEC SQL WHENEVER NOT FOUND DO BREAK; 

    EXEC SQL DECLARE cursorTipoCarteira CURSOR FOR
        SELECT
            IDTIPOCARTEIRA,DSTIPOCARTEIRA
        FROM
            APOIO.TIPOCARTEIRA
        ORDER BY
            UPPER(DSTIPOCARTEIRA);

    EXEC SQL OPEN cursorTipoCarteira;

    for ( ;; )
    {
        memset(&oraStatusTipoCarteira,-1,sizeof(oraStatusTipoCarteira));

        EXEC SQL
            FETCH
                cursorTipoCarteira 
            INTO 
                :oraDadosTipoCarteira:oraStatusTipoCarteira;

        CONVIND( oraDadosTipoCarteira.idTipoCarteira, oraStatusTipoCarteira.idTipoCarteira );
        CONVIND( oraDadosTipoCarteira.dsTipoCarteira, oraStatusTipoCarteira.dsTipoCarteira );

        if ( tipoCarteiraPC = new st_VariaveisTipoCarteira,tipoCarteiraPC )
        {
            strcpy(tipoCarteiraPC->idTipoCarteira,(char*) oraDadosTipoCarteira.idTipoCarteira.arr);
            strcpy(tipoCarteiraPC->dsTipoCarteira,(char*) oraDadosTipoCarteira.dsTipoCarteira.arr);

            _ResultadoPC->AddItem((void*)tipoCarteiraPC);
        }
        else
        {
            ULOGE("Falha de alocação de memória");
        }
    }

    EXEC SQL CLOSE cursorTipoCarteira;    

    ULOG_END("cMonObtGruPC::obterTiposCarteiraPC()");
}

void cMonObtGruPC::obterSegmentacaoPC( st_VariaveisSegmentacao *_dadosEntradaPC, Collection *_ResultadoPC )
{
    ULOG_START("cMonObtGruPC::obterSegmentacaoPC()");

    struct sqlca sqlca;
    st_VariaveisSegmentacao *segmentacaoPC;

    EXEC SQL BEGIN DECLARE SECTION;
        
        struct
        {
            VARCHAR idSegmentacao[21];
            VARCHAR dsSegmentacao[256];
        } oraDadosSegmentacao;

        struct
        {
            short idSegmentacao;
            short dsSegmentacao;
        } oraStatusSegmentacao;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFobtemGrupos( &sqlca );
    EXEC SQL WHENEVER NOT FOUND DO BREAK; 

    EXEC SQL DECLARE cursorSegmentacao CURSOR FOR
        SELECT
            IDSEGMENTACAO,DSSEGMENTACAO
        FROM
            APOIO.SEGMENTACAO
        ORDER BY
            UPPER(DSSEGMENTACAO);

    EXEC SQL OPEN cursorSegmentacao;

    for ( ;; )
    {
        memset(&oraStatusSegmentacao,-1,sizeof(oraStatusSegmentacao));

        EXEC SQL
            FETCH
                cursorSegmentacao 
            INTO 
                :oraDadosSegmentacao:oraStatusSegmentacao;

        CONVIND( oraDadosSegmentacao.idSegmentacao, oraStatusSegmentacao.idSegmentacao );
        CONVIND( oraDadosSegmentacao.dsSegmentacao, oraStatusSegmentacao.dsSegmentacao );

        if ( segmentacaoPC = new st_VariaveisSegmentacao,segmentacaoPC )
        {
            strcpy(segmentacaoPC->idSegmentacao,(char*) oraDadosSegmentacao.idSegmentacao.arr);
            strcpy(segmentacaoPC->dsSegmentacao,(char*) oraDadosSegmentacao.dsSegmentacao.arr);

            _ResultadoPC->AddItem((void*)segmentacaoPC);
        }
        else
        {
            ULOGE("Falha de alocação de memória");
        }
    }

    EXEC SQL CLOSE cursorSegmentacao;    

    ULOG_END("cMonObtGruPC::obterSegmentacaoPC()");
}

void cMonObtGruPC::obterAlertaPC( st_VariaveisAlerta *_dadosEntradaPC, Collection *_ResultadoPC )
{
    ULOG_START("cMonObtGruPC::obterAlertaPC()");

    struct sqlca sqlca;
    st_VariaveisAlerta *alertaPC;

    EXEC SQL BEGIN DECLARE SECTION;
        
        struct
        {
            VARCHAR idAlerta[21];
            VARCHAR dsAlerta[256];
        } oraDadosAlerta;

        struct
        {
            short idAlerta;
            short dsAlerta;
        } oraStatusAlerta;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFobtemGrupos( &sqlca );
    EXEC SQL WHENEVER NOT FOUND DO BREAK; 

    EXEC SQL DECLARE cursorAlerta CURSOR FOR
        SELECT
            IDALERTA,DSALERTA
        FROM
            WORKFLOW.ALERTA 
        WHERE
            SGALERTA LIKE 'portout_%'
        ORDER BY
            IDALERTA;

    EXEC SQL OPEN cursorAlerta;

    for ( ;; )
    {
        memset(&oraStatusAlerta,-1,sizeof(oraStatusAlerta));

        EXEC SQL
            FETCH
                cursorAlerta 
            INTO 
                :oraDadosAlerta:oraStatusAlerta;

        CONVIND( oraDadosAlerta.idAlerta, oraStatusAlerta.idAlerta );
        CONVIND( oraDadosAlerta.dsAlerta, oraStatusAlerta.dsAlerta );

        if ( alertaPC = new st_VariaveisAlerta,alertaPC )
        {
            strcpy(alertaPC->idAlerta,(char*) oraDadosAlerta.idAlerta.arr);
            strcpy(alertaPC->dsAlerta,(char*) oraDadosAlerta.dsAlerta.arr);

            _ResultadoPC->AddItem((void*)alertaPC);
        }
        else
        {
            ULOGE("Falha de alocação de memória");
        }
    }

    EXEC SQL CLOSE cursorAlerta;    

    ULOG_END("cMonObtGruPC::obterAlertaPC()");
}

void cMonObtGruPC::obterTodosGruposPC( st_VariaveisGrupo *_dadosEntradaPC, Collection *_ResultadoPC )
{
    ULOG_START("cMonObtGruPC::obterTodosGruposPC()");

    bool cursorAberto = false;
    bool fimNormal = false;

    struct sqlca sqlcaError;
    struct sqlca sqlca;
    st_VariaveisGrupo *gruposPC;

    EXEC SQL BEGIN DECLARE SECTION;
        int idUser = _dadosEntradaPC->idUsuario ? atoi(_dadosEntradaPC->idUsuario) : 0;

        VARCHAR idGrupo[ 256 ];
        VARCHAR dsGrupo[ 256 ];

        short i_idGrupo;
        short i_dsGrupo;

    EXEC SQL END DECLARE SECTION;

    ULOG( "SELECT  "
            "B.IDPESSOAUSUARIO, "
            "A.IDGRUPO,  "
            "A.NMGRUPO "
         "FROM  "
            "ACESSO.GRUPO A, "
            "ACESSO.USUARIOGRUPO B "
         "WHERE  "
               "A.IDGRUPO = B.IDGRUPO "
           "AND "
               "A.DTEXCLUSAO IS NULL "
           "AND  "
               "B.IDPESSOAUSUARIO = %d "
         "ORDER BY "
            "UPPER(A.NMGRUPO)",idUser);

    EXEC SQL WHENEVER SQLERROR GOTO SaidaIncondicional;
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE cursorObterTodosGruposPC CURSOR FOR
    SELECT 
        A.IDGRUPO,
        A.NMGRUPO
    FROM 
        ACESSO.GRUPO A,
        ACESSO.USUARIOGRUPO B
    WHERE 
        A.IDGRUPO = B.IDGRUPO
    AND
        A.DTEXCLUSAO IS NULL
    AND 
        B.IDPESSOAUSUARIO = :idUser
    ORDER BY
        UPPER(A.NMGRUPO);

    EXEC SQL OPEN cursorObterTodosGruposPC;

    cursorAberto = true;

    for ( ;; )
    {
        i_idGrupo = i_dsGrupo=-1;

        EXEC SQL FETCH cursorObterTodosGruposPC INTO :idGrupo:i_idGrupo,
                                                     :dsGrupo:i_dsGrupo;
        CONVIND( idGrupo, i_idGrupo );
        CONVIND( dsGrupo, i_dsGrupo );

        gruposPC = new st_VariaveisGrupo;

        if ( gruposPC )
        {
            strcpy(gruposPC->idGrupo,(char*)idGrupo.arr);
            strcpy(gruposPC->dsGrupo,(char*)dsGrupo.arr);

            _ResultadoPC->AddItem( (void*) gruposPC );
        }
        else
        {
            ULOGE("Falha de alocação de memória");
        }
    }

    fimNormal = true;

SaidaIncondicional:

    if ( fimNormal == false )
    { // salva a estrutura original em caso de eminencia de lançamento de erro
        memcpy(&sqlcaError,&sqlca,sizeof(sqlcaError));
    }

    if ( cursorAberto ) 
    {
        EXEC SQL CLOSE cursorObterTodosGruposPC;
    }

    if ( fimNormal == false ) 
    {
        ULOG_END("cMonObtGruPC::obterTodosGruposPC()");

        sql_error_WFobtemGrupos( &sqlcaError );
    }

    ULOG_END("cMonObtGruPC::obterTodosGruposPC()");
}

void cMonObtGruPC::obtemGruposPC( st_VariaveisGrupo *_dadosEntradaPC, Collection *_ResultadoPC )
{
    ULOG_START("cMonObtGruPC::obtemGruposPC()");

    struct sqlca sqlca;
    st_VariaveisGrupo *gruposPC;

    EXEC SQL BEGIN DECLARE SECTION;
        int idUser = _dadosEntradaPC->idUsuario ? atoi(_dadosEntradaPC->idUsuario) : 0;

        VARCHAR idUsuario[ 256 ];
        VARCHAR idGrupo[ 256 ];
        VARCHAR dsGrupo[ 256 ];

        short i_idUsuario;
        short i_idGrupo;
        short i_dsGrupo;

    EXEC SQL END DECLARE SECTION;

    ULOG( "SELECT "
            "B.IDPESSOAUSUARIO, "
            "A.IDGRUPO, "
            "A.NMGRUPO "
         "FROM  "
            "ACESSO.GRUPO A, "
            "ACESSO.USUARIOGRUPO B "
         "WHERE  "
               "A.IDGRUPO = B.IDGRUPO "
           "AND "
               "A.DTEXCLUSAO IS NULL "
           "AND  "
               "A.IDTIPOGRUPO = (SELECT IDTIPOGRUPO FROM APOIO.TIPOGRUPO WHERE CDTIPOGRUPO = 'NORMAL') "
           "AND  "
               "B.IDPESSOAUSUARIO = %d "
         "ORDER BY "
            "UPPER(A.NMGRUPO);",idUser);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFobtemGrupos( &sqlca );
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE ObtemGrupos CURSOR FOR
    SELECT 
        B.IDPESSOAUSUARIO,
        A.IDGRUPO,
        A.NMGRUPO
    FROM 
        ACESSO.GRUPO A,
        ACESSO.USUARIOGRUPO B
    WHERE 
        A.IDGRUPO = B.IDGRUPO
    AND
        A.DTEXCLUSAO IS NULL
    AND 
        A.IDTIPOGRUPO = (SELECT IDTIPOGRUPO FROM APOIO.TIPOGRUPO WHERE CDTIPOGRUPO = 'NORMAL')
    AND 
        B.IDPESSOAUSUARIO = :idUser
    ORDER BY
        UPPER(A.NMGRUPO);

    EXEC SQL OPEN ObtemGrupos;

    for ( ;; )
    {
        i_idUsuario = i_idGrupo = i_dsGrupo = -1;

        EXEC SQL FETCH ObtemGrupos INTO :idUsuario:i_idUsuario,
                                   :idGrupo:i_idGrupo,
                                   :dsGrupo:i_dsGrupo;

        CONVIND( idUsuario, i_idUsuario );
        CONVIND( idGrupo, i_idGrupo );
        CONVIND( dsGrupo, i_dsGrupo );

        gruposPC = new st_VariaveisGrupo;

        if ( gruposPC )
        {
            strcpy(gruposPC->idUsuario,(char*) idUsuario.arr);
            strcpy(gruposPC->idGrupo,(char*) idGrupo.arr);
            strcpy(gruposPC->dsGrupo,(char*) dsGrupo.arr);

            _ResultadoPC->AddItem( (void*) gruposPC );
        }
        else
        {
            ULOGE("Falha de alocação de memória");
        }
    }

    EXEC SQL CLOSE ObtemGrupos;

    ULOG_END("cMonObtGruPC::obtemGruposPC()");
}

void cMonObtGruPC::obtemGruposPCRC( st_VariaveisGrupo *_dadosEntradaPC, Collection *_ResultadoPC )
{
    ULOG_START("cMonObtGruPC::obtemGruposPCRC()");

    struct sqlca sqlca;
    st_VariaveisGrupo *gruposPC;

    EXEC SQL BEGIN DECLARE SECTION;
        int idUser = _dadosEntradaPC->idUsuario ? atoi(_dadosEntradaPC->idUsuario) : 0;

        VARCHAR idUsuario[ 256 ];
        VARCHAR idGrupo[ 256 ];
        VARCHAR dsGrupo[ 256 ];

        short i_idUsuario;
        short i_idGrupo;
        short i_dsGrupo;
    EXEC SQL END DECLARE SECTION;

    ULOG("SELECT  "
            "B.IDPESSOAUSUARIO, "
            "A.IDGRUPO,  "
            "A.NMGRUPO "
         "FROM  "
            "ACESSO.GRUPO A, "
            "ACESSO.USUARIOGRUPO B "
         "WHERE  "
               "A.IDGRUPO = B.IDGRUPO "
           "AND "
               "A.DTEXCLUSAO IS NULL "
           "AND  "
               "A.IDTIPOGRUPO = (SELECT IDTIPOGRUPO FROM APOIO.TIPOGRUPO WHERE CDTIPOGRUPO = 'RC') "
           "AND  "
               "B.IDPESSOAUSUARIO = %d "
         "ORDER BY "
            "UPPER(A.NMGRUPO);",idUser);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFobtemGrupos( &sqlca );
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE ObtemGruposRC CURSOR FOR
    SELECT 
        B.IDPESSOAUSUARIO,
        A.IDGRUPO, 
        A.NMGRUPO
    FROM 
        ACESSO.GRUPO A,
        ACESSO.USUARIOGRUPO B
    WHERE 
        A.IDGRUPO = B.IDGRUPO
    AND
        A.DTEXCLUSAO IS NULL
    AND 
        A.IDTIPOGRUPO = (SELECT IDTIPOGRUPO FROM APOIO.TIPOGRUPO WHERE CDTIPOGRUPO = 'RC')
    AND 
        B.IDPESSOAUSUARIO = :idUser
    ORDER BY
        UPPER(A.NMGRUPO);

      EXEC SQL OPEN ObtemGruposRC;

      for ( ;; )
      {
           EXEC SQL FETCH ObtemGruposRC INTO :idUsuario:i_idUsuario,
                                           :idGrupo:i_idGrupo,
                                           :dsGrupo:i_dsGrupo;

         CONVIND( idUsuario, i_idUsuario );
         CONVIND( idGrupo, i_idGrupo );
         CONVIND( dsGrupo, i_dsGrupo );

         gruposPC = new st_VariaveisGrupo;

         if ( gruposPC )
         {
            strcpy(gruposPC->idUsuario,(char*) idUsuario.arr);
            strcpy(gruposPC->idGrupo,(char*) idGrupo.arr);
            strcpy(gruposPC->dsGrupo,(char*) dsGrupo.arr);

            _ResultadoPC->AddItem( (void*) gruposPC );
         }
         else
         {
            ULOGE("Falha de alocação de memória");
         }
      }

    EXEC SQL CLOSE ObtemGruposRC;

    ULOG_START("cMonObtGruPC::obtemGruposPCRC()");
}

void cMonObtGruPC::obtemMonitoramentoPC( st_VariaveisGrupo *_dadosEntradaPC, st_vlVariaveisGrupo *_statusEntradaPC, XMLGen *saida )
{
    ULOG_START("cMonObtGruPC::obtemMonitoramentoPC()");

    struct sqlca sqlca;
    string query;
    char buffer[32];

    EXEC SQL BEGIN DECLARE SECTION;
        unsigned long idPessoaUsuario;
        unsigned long idGrupo;

        unsigned long maxRegistros = 50L;
        unsigned long vlInicial;
        unsigned long vlFinal;

        char dtInicio[11];
        char dtFim[11];
        char *pQuery;

        short i_idGrupo = -1;
        short i_dtInicio = -1;
        short i_dtFim = -1;

        VARCHAR nmLoginUsuario[256];
        VARCHAR nmGrupo[256];
        VARCHAR dsEstado[256];
        int qtde;

        short i_nmLoginUsuario;
        short i_nmGrupo;
        short i_dsEstado;
        short i_qtde;
    EXEC SQL END DECLARE SECTION;

    idPessoaUsuario = _dadosEntradaPC->idPessoaUsuarioPesquisa;
    idGrupo = _dadosEntradaPC->idGrupoPesquisa;

    strcpy(dtInicio, _dadosEntradaPC->dtInicio);
    strcpy(dtFim, _dadosEntradaPC->dtFim);

    i_idGrupo = _statusEntradaPC->idGrupoPesquisa;
    i_dtInicio = _statusEntradaPC->dtInicio;
    i_dtFim = _statusEntradaPC->dtFim;

    _dadosEntradaPC->inPagina = (_dadosEntradaPC->inPagina < 0 || _dadosEntradaPC->inPagina > 1000) ? 0 : _dadosEntradaPC->inPagina;

    vlInicial = (unsigned long) _dadosEntradaPC->inPagina * maxRegistros;
    vlFinal = (unsigned long) vlInicial + maxRegistros;

    ULOG("idPessoaUsuario: %lu", idPessoaUsuario);
    ULOG("idGrupo: %lu", idGrupo);
    ULOG("dtInicio: %s", dtInicio);
    ULOG("dtFim: %s", dtFim);
    ULOG("idGrupo: %d", i_idGrupo);
    ULOG("dtInicio: %d", i_dtInicio);
    ULOG("dtFim: %d", i_dtFim);
    ULOG("vlInicial: %lu", vlInicial);
    ULOG("vlFinal: %lu", vlFinal);

    query = "SELECT nmgrupo,nmloginusuario,dsestado,qtde "
           "FROM "
           "( "
               "SELECT ROWNUM AS numLinha,nmgrupo,nmloginusuario,dsestado,qtde "
               "FROM "
               "( "
                   "SELECT nmgrupo,nmloginusuario,dsestado,COUNT(1) AS qtde "
                   "FROM "
                        "( "
                           "SELECT  "
                               "grupo.nmgrupo "
                              ",usuario.nmloginusuario "
                              ",estado.dsestado "
                           "FROM  "
                               "atendimento.atendimentopriorizacao atendimentopriorizacao, "
                               //"atendimento.atendimentoandamentoatual atendimentoandamentoatual, "
                               //"andamento.andamentotrans andamentotrans, "
                               // ==> Remodelagem Atendimento--Fev/2007--Cassio 
                               //"atendimento.atendimentogrupoatual atendimentogrupoatual, "
                               //"atendimento.atendimentousuarioatual atendimentousuarioatual, "
                               "acesso.usuario usuario, "
                               "acesso.grupo grupo, "
                               "workflow.agrupamentoestadotpproc agrupamentoestadotpproc, "
                               "workflow.agrupamentoestado agrupamentoestado, "
                               "workflow.estado estado "
                           "WHERE estado.sgestado <> 'C' "
                           //"AND atendimentopriorizacao.idatendimento=atendimentoandamentoatual.idatendimento "
                           //"AND atendimentoandamentoatual.idandamento=andamentotrans.idandamento "
                           //"AND atendimentopriorizacao.idatendimento=atendimentogrupoatual.idatendimento "
                           //"AND atendimentogrupoatual.idgrupo = (SELECT usuariogrupo.idgrupo "
                           "AND atendimentopriorizacao.idgrupoatual = (SELECT usuariogrupo.idgrupo "
                                                                        "FROM acesso.usuariogrupo usuariogrupo "
                                                                       "WHERE usuariogrupo.idPessoaUsuario = ";
    sprintf(buffer,"%lu",idPessoaUsuario);
    query += (string)buffer;

    query += 
                                                                   //" AND usuariogrupo.idgrupo = atendimentogrupoatual.idgrupo ) ";
                                                                   " AND usuariogrupo.idgrupo = atendimentopriorizacao.idgrupoatual ) ";
    if ( i_dtInicio != -1 )
    {
        query += 
                           "AND TRUNC(atendimentopriorizacao.dtAbertura) >= (SELECT TO_DATE('"+(string)dtInicio+"','DD/MM/YYYY') FROM DUAL) ";
    }

    if ( i_dtFim != -1 )
    {
        query += 
                           "AND TRUNC(atendimentopriorizacao.dtAbertura) <= (SELECT TO_DATE('"+(string)dtFim+"','DD/MM/YYYY') FROM DUAL) ";
    }

    if ( i_idGrupo != -1 )
    {
        sprintf(buffer,"%lu",idGrupo);

        query += 
                           //"AND atendimentogrupoatual.idGrupo = "+(string)buffer;
                           "AND atendimentopriorizacao.idgrupoatual = "+(string)buffer;
    }
        query += 
                          //" AND atendimentopriorizacao.idatendimento=atendimentousuarioatual.idatendimento(+) "
                           //"AND atendimentousuarioatual.idpessoausuario=usuario.idpessoausuario (+) "
                           "AND atendimentopriorizacao.idpessoausuarioatual=usuario.idpessoausuario (+) "
                           //"AND grupo.idgrupo=atendimentogrupoatual.idgrupo "
                           "AND grupo.idgrupo=atendimentopriorizacao.idgrupoatual "
                           //"AND andamentotrans.idagrupamentoestadotpproc=agrupamentoestadotpproc.idagrupamentoestadotpproc "
                           "AND atendimentopriorizacao.idagrupamentoestadotpproc=agrupamentoestadotpproc.idagrupamentoestadotpproc "
                           "AND agrupamentoestadotpproc.idagrupamentoestado=agrupamentoestado.idagrupamentoestado "
                           "AND agrupamentoestado.idestado=estado.idestado "
                       ") "
                   "GROUP BY nmgrupo,nmloginusuario,dsestado "
                   "ORDER BY UPPER(nmgrupo),UPPER(nmloginusuario),dsestado "
               ") "
           ") ";

    char valIni[32],valFin[32];
    sprintf(valIni,"%d",vlInicial);
    sprintf(valFin,"%d",vlFinal);

    query += "WHERE numLinha >= "+(string)valIni+" AND numLinha <= "+(string)valFin;

    pQuery = (char*)query.c_str();

    ULOG("QUERY = '%s'",pQuery);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFobtemGrupos( &sqlca );
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL PREPARE recebeQuery FROM :pQuery;
    EXEC SQL DECLARE ObtemMonitoramento CURSOR FOR recebeQuery;

    EXEC SQL OPEN ObtemMonitoramento;

    for ( ;; )
    {
        i_nmGrupo = i_nmLoginUsuario = i_dsEstado = -1;

        EXEC SQL FETCH ObtemMonitoramento 
                 INTO :nmGrupo:i_nmGrupo,
                      :nmLoginUsuario:i_nmLoginUsuario,
                      :dsEstado:i_dsEstado,
                      :qtde:i_qtde;

        CONVIND( nmGrupo, i_nmGrupo );
        CONVIND( nmLoginUsuario, i_nmLoginUsuario );
        CONVIND( dsEstado, i_dsEstado );

        saida->createTag("MonitoramentoVO");
            saida->addProp("xmlns", "workflow.fo.vivo.com.br/vo" );
            saida->addItem( "descricaoGrupo", (char*)nmGrupo.arr);
            saida->addItem( "descricaoLogin", (char*)nmLoginUsuario.arr );
            saida->addItem( "descricaoEstado", (char*)dsEstado.arr );
            saida->addItem( "quantidade", qtde );
        saida->closeTag();
    }

    EXEC SQL CLOSE ObtemMonitoramento;

    ULOG_END("cMonObtGruPC::obtemMonitoramentoPC()");
}

void cMonObtGruPC::obterTipoPessoaPC( st_VariaveisTipoPessoa *_dadosEntradaPC, Collection *_ResultadoPC )
{
    ULOG_START("cMonObtGruPC::obterTipoPessoaPC()");

    struct sqlca sqlca;
    st_VariaveisTipoPessoa *TipoPessoaPC;

    EXEC SQL BEGIN DECLARE SECTION;

        struct
        {
            VARCHAR idTipoPessoa[21];
            VARCHAR dsTipoPessoa[256];
        } oraDadosTipoPessoa;

        struct
        {
            short idTipoPessoa;
            short dsTipoPessoa;
        } oraStatusTipoPessoa;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFobtemGrupos( &sqlca );
    EXEC SQL WHENEVER NOT FOUND DO BREAK; 

    EXEC SQL DECLARE cursorTipoPessoa CURSOR FOR
        SELECT
            IDTIPOPESSOA,DSTIPOPESSOA
        FROM
            APOIO.TIPOPESSOA
        ORDER BY
            UPPER(DSTIPOPESSOA);

    EXEC SQL OPEN cursorTipoPessoa;

    for ( ;; )
    {
        memset(&oraStatusTipoPessoa,-1,sizeof(oraStatusTipoPessoa));

        EXEC SQL
            FETCH
                cursorTipoPessoa 
            INTO 
                :oraDadosTipoPessoa:oraStatusTipoPessoa;

        CONVIND( oraDadosTipoPessoa.idTipoPessoa, oraStatusTipoPessoa.idTipoPessoa );
        CONVIND( oraDadosTipoPessoa.dsTipoPessoa, oraStatusTipoPessoa.dsTipoPessoa );

        if ( TipoPessoaPC = new st_VariaveisTipoPessoa,TipoPessoaPC )
        {
            strcpy(TipoPessoaPC->idTipoPessoa,(char*) oraDadosTipoPessoa.idTipoPessoa.arr);
            strcpy(TipoPessoaPC->dsTipoPessoa,(char*) oraDadosTipoPessoa.dsTipoPessoa.arr);

            _ResultadoPC->AddItem((void*)TipoPessoaPC);
        }
        else
        {
            ULOGE("Falha de alocação de memória");
        }
    }

    EXEC SQL CLOSE cursorTipoPessoa;    

    ULOG_END("cMonObtGruPC::obterTipoPessoaPC()");
}

void cMonObtGruPC::obterClassificacaoTipoLinhaPC( st_VariaveisClassificacaoTipoLinha *_dadosEntradaPC, Collection *_ResultadoPC )
{
    ULOG_START("cMonObtGruPC::obterClassificacaoTipoLinhaPC()");

    struct sqlca sqlca;
    st_VariaveisClassificacaoTipoLinha *ClassificacaoTipoLinhaPC;

    EXEC SQL BEGIN DECLARE SECTION;

        struct
        {
            VARCHAR idClassificacaoTipoLinha[21];
            VARCHAR dsClassificacaoTipoLinha[256];
        } oraDadosClassificacaoTipoLinha;

        struct
        {
            short idClassificacaoTipoLinha;
            short dsClassificacaoTipoLinha;
        } oraStatusClassificacaoTipoLinha;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFobtemGrupos( &sqlca );
    EXEC SQL WHENEVER NOT FOUND DO BREAK; 

    EXEC SQL DECLARE cursorClassificacaoTipoLinha CURSOR FOR
        SELECT
            IDCLASSIFICACAOTIPOLINHA,DSCLASSIFICACAOTIPOLINHA
        FROM
            APOIO.CLASSIFICACAOTIPOLINHA
        ORDER BY
            UPPER(DSCLASSIFICACAOTIPOLINHA);

    EXEC SQL OPEN cursorClassificacaoTipoLinha;

    for ( ;; )
    {
        memset(&oraStatusClassificacaoTipoLinha,-1,sizeof(oraStatusClassificacaoTipoLinha));

        EXEC SQL
            FETCH
                cursorClassificacaoTipoLinha 
            INTO 
                :oraDadosClassificacaoTipoLinha:oraStatusClassificacaoTipoLinha;

        CONVIND( oraDadosClassificacaoTipoLinha.idClassificacaoTipoLinha, oraStatusClassificacaoTipoLinha.idClassificacaoTipoLinha );
        CONVIND( oraDadosClassificacaoTipoLinha.dsClassificacaoTipoLinha, oraStatusClassificacaoTipoLinha.dsClassificacaoTipoLinha );

        if ( ClassificacaoTipoLinhaPC = new st_VariaveisClassificacaoTipoLinha,ClassificacaoTipoLinhaPC )
        {
            strcpy(ClassificacaoTipoLinhaPC->idClassificacaoTipoLinha,(char*) oraDadosClassificacaoTipoLinha.idClassificacaoTipoLinha.arr);
            strcpy(ClassificacaoTipoLinhaPC->dsClassificacaoTipoLinha,(char*) oraDadosClassificacaoTipoLinha.dsClassificacaoTipoLinha.arr);

            _ResultadoPC->AddItem((void*)ClassificacaoTipoLinhaPC);
        }
        else
        {
            ULOGE("Falha de alocação de memória");
        }
    }

    EXEC SQL CLOSE cursorClassificacaoTipoLinha;

    ULOG_END("cMonObtGruPC::obterClassificacaoTipoLinhaPC()");
}

void cMonObtGruPC::sql_error_WFobtemGrupos( sqlca * sqlca )
{
    throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}

