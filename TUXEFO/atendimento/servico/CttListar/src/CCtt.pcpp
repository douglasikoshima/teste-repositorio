#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CCttWF.h"

CContato::CContato()
{
}

CContato::~CContato()
{
}


int CContato::ListaSemContato( 
                                 char* cidUFOperadora ,
                                 char* cidTipoLinha ,
                                 char* cidTipoCarteira ,
                                 char* cidSegmentacao 
                               )
{
   ULOG_START("CContato::ListaSemContato()");  
   
   int iCont = 0;
   struct sqlca sqlca;
   EXEC SQL BEGIN DECLARE SECTION;
   
      char* cAuxidUFOperadora = cidUFOperadora;
      char  cAuxidTipoLinha[21+1];
      char  cAuxidTipoCarteira[21+1];
      char  cAuxidSegmentacao[21+1];
     
      struct
      {
         VARCHAR stidContato[255+1];
         VARCHAR stidNomeContato[255+1];
         VARCHAR stnmContato[255+1];
         VARCHAR stinDisponibilidade[255+1];
         int     iLevel;
         VARCHAR stidContatoPai[255+1];
         VARCHAR stdsPath[2048+1];
         int     iFolha;
      } stContatoRegistro;
      struct
      {
         short iidContato;
         short iidNomeContato;
         short inmContato;
         short iinDisponibilidade;
         short iLevel;
         short iidContatoPai;
         short idsPath;
         short iiFolha;
      } stContatoIndicator;
      struct
      {
         VARCHAR stidContato[21+1];
         VARCHAR stidNomeContato[21+1];
         VARCHAR stnmContato[255+1];
         VARCHAR stinDisponibilidade[21+1];
      } stContatoRaiz;
      struct
      {
         short iidContato;
         short iidNomeContato;
         short inmContato;
         short iinDisponibilidade;
      } stContatoRaizIndicator;
   EXEC SQL END DECLARE SECTION;

   //Processamento Principal
   try
   {
      memset( &cAuxidTipoLinha, 0, sizeof( cAuxidTipoLinha ) );
      memset( &cAuxidTipoCarteira, 0, sizeof( cAuxidTipoCarteira ) );
      memset( &cAuxidSegmentacao, 0, sizeof( cAuxidSegmentacao ) );

      if( strlennull( cidTipoLinha ) <= 0 )
         strcpy( cAuxidTipoLinha, "-1" );
      else
         strcpy( cAuxidTipoLinha, cidTipoLinha );

      if( strlennull( cidTipoCarteira ) <= 0 )
         strcpy( cAuxidTipoCarteira, "-1" );
      else
         strcpy( cAuxidTipoCarteira, cidTipoCarteira );

      if( strlennull( cidSegmentacao ) <= 0 )
         strcpy( cAuxidSegmentacao, "-1" );
      else
         strcpy( cAuxidSegmentacao, cidSegmentacao );

      ZeraContato();
      memset( &stContatoRaiz, 0, sizeof( stContatoRaiz ) );

      sqlca.sqlcode=0;
      EXEC SQL WHENEVER SQLERROR GOTO SemContatoError;
      //Recupera a raiz da arvore
      EXEC SQL
		 SELECT CONTATO.IDCONTATO,
                CONTATO.IDNOMECONTATO,
                NMCONTATO.NMCONTATO NMCONTATO,
                CONTATO.INDISPONIBILIDADE
          INTO	:stContatoRaiz:stContatoRaizIndicator
          FROM	CONTATOADM.CONTATO CONTATO,
		   		CONTATOADM.NOMECONTATO NMCONTATO
          WHERE
		  	    CONTATO.IDNOMECONTATO=NMCONTATO.IDNOMECONTATO 
		  AND	
				CONTATO.IDCONTATO NOT IN
                (SELECT IDCONTATO
                   FROM CONTATOADM.CONTATOHIERARQUIA CONTATOHIERARQUIA)
                  --//WHERE CONTATOHIERARQUIA.IDCONTATO > 0)
          AND ROWNUM <= 1;
                  
      Add((char*)stContatoRaiz.stidContato.arr,
          "",
         (char*)stContatoRaiz.stidNomeContato.arr,
         (char*)stContatoRaiz.stnmContato.arr,
         (char*)stContatoRaiz.stinDisponibilidade.arr,
          "",
         0,
         0);               
      iCont++;
   
      //Cursor para recuperar a arvore 
	   EXEC SQL DECLARE readContato CURSOR FOR
            SELECT 
                HIERARQUIA.IDCONTATO,
                HIERARQUIA.IDNOMECONTATO,
                HIERARQUIA.NMCONTATO,
                HIERARQUIA.INDISPONIBILIDADE,
                LEVEL,
                HIERARQUIA.IDCONTATOPAI,
                SYS_CONNECT_BY_PATH(REPLACE(HIERARQUIA.NMCONTATO, '/', '\' ), '/') AS "PATH",
                DECODE(IDCONTATOFOLHA, NULL, 0, 1 )
            FROM 
                CONTATOADM.CONTATOHIERARQUIAV01 HIERARQUIA,
		        CONTATOADM.CONTATO CONTATO
            WHERE
                HIERARQUIA.IDCONTATO = CONTATO.IDCONTATO
		    AND CONTATO.IDTIPOARVORE = (SELECT IDTIPOARVORE
                                          FROM APOIO.TIPOARVORE
                                         WHERE DSTIPOARVORE = 'ÁRVORE DE CONTATOS')
            START WITH
                HIERARQUIA.IDCONTATOPAI = :stContatoRaiz.stidContato
            CONNECT BY
                HIERARQUIA.IDCONTATOPAI = PRIOR HIERARQUIA.IDCONTATO;

      EXEC SQL WHENEVER NOT FOUND DO break;
      EXEC SQL OPEN readContato;
      for(;;)
      {
         memset( &stContatoRegistro, 0, sizeof(stContatoRegistro) );
         EXEC SQL FETCH readContato INTO :stContatoRegistro:stContatoIndicator;
         Add((char*)stContatoRegistro.stidContato.arr,
            (char*)stContatoRegistro.stidContatoPai.arr,
            (char*)stContatoRegistro.stidNomeContato.arr,
            (char*)stContatoRegistro.stnmContato.arr,
            (char*)stContatoRegistro.stinDisponibilidade.arr,
            (char*)stContatoRegistro.stdsPath.arr,
            stContatoRegistro.iLevel,
            stContatoRegistro.iFolha);
         iCont++;
      }
      EXEC SQL CLOSE readContato;
      
      ULOG_END("CContato::ListaSemContato()");  

      return iCont;
   }
   catch(...)
   {
      throw;
   }

SemContatoError:
   throw TuxBasicOraException(sqlca.sqlcode);

}




void CContato::GetXmlWF( char* cNomeTag, char *cidTpRelacionamento, int idContatoAux,XMLGen*xml )
{
   ULOG_START("CContato::GetXmlWF()");  
   CContato     oContato;
   char        *idContato;
   char         idTpRetorno[ 23 ];
   char         UrlInf[256];
   bool         flagTAG = false;


   int idTpRelac = atoi( cidTpRelacionamento );
   idTpRetorno[0] = 0x0;
   UrlInf[0] = 0x0;

   strcpy( idTpRetorno,"0" );

	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
         if ( idContatoAux > 0 )
            flagTAG = true;
         
         if ( flagTAG == true )
         {
			   xml->createTag(cNomeTag);
            idContatoAux = 1;
         }

//         if ( x == 0 )
//            xml->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{ 
            idContato = Registro(x)->cidContato;
            oContato.TpRetorno( idContato, idTpRelac, idTpRetorno );
            oContato.URLInf( idContato, UrlInf );
				xml->addItem("idContato", Registro(x)->cidContato );
				xml->addItem("idNomeContato", Registro(x)->cidNomeContato );
				xml->addItem("nmContato", Registro(x)->cnmContato );
				xml->addItem("inDisponibilidade", Registro(x)->cinDisponibilidade ); 
				xml->addItem("nrNivel", Registro(x)->cdsPath ); 
				xml->addItem("inFolha", ( Registro(x)->iFolha ? 1 : 0 ) );
            xml->addItem("inRelacionamento", idTpRetorno );
            if ( strlen(UrlInf) > 0 )
            {
               xml->createTag("AdmContatoInformacaoVO");
                  xml->addItem("nmURLContatoInformacao", UrlInf );
               xml->closeTag();
            }
			}
         if ( flagTAG == true )
         {
   			xml->closeTag();
            flagTAG = true;
         }
         else
         {
            idContatoAux = 1;
            flagTAG = true;
         }
		}
	}
	ULOG_END("CContato::GetXmlWF()");  
}

int CContato::ListaSemGrupo( 
                              char *idContatoParam, 
                              char* cidUFOperadora ,
                              char* cidTipoLinha ,
                              char* cidTipoCarteira ,
                              char* cidSegmentacao 
                           )
{
   ULOG_START("CContato::ListaSemGrupo()");  
   int iCont = 0;
   struct sqlca sqlca;
   EXEC SQL BEGIN DECLARE SECTION;
   
      int idContatoWrk = atoi( idContatoParam );
 
      char* cAuxidUFOperadora = cidUFOperadora;
      char  cAuxidTipoLinha[21+1];
      char  cAuxidTipoCarteira[21+1];
      char  cAuxidSegmentacao[21+1];

      struct
      {
         VARCHAR stidContato[21+1];
         VARCHAR stidNomeContato[21+1];
         VARCHAR stnmContato[255+1];
         VARCHAR stinDisponibilidade[21+1];
         int     iLevel;
         VARCHAR stidContatoPai[21+1];
         VARCHAR stdsPath[1024+1];
         int     iFolha;
      } stContatoRegistro;
      struct
      {
         short iidContato;
         short iidNomeContato;
         short inmContato;
         short iinDisponibilidade;
         short iLevel;
         short iidContatoPai;
         short idsPath;
         short iiFolha;
      } stContatoIndicator;
      struct
      {
         VARCHAR stidContato[21+1];
         VARCHAR stidNomeContato[21+1];
         VARCHAR stnmContato[255+1];
         VARCHAR stinDisponibilidade[21+1];
      } stContatoRaiz;
      struct
      {
         short iidContato;
         short iidNomeContato;
         short inmContato;
         short iinDisponibilidade;
      } stContatoRaizIndicator;
   EXEC SQL END DECLARE SECTION;


   memset( &cAuxidTipoLinha, 0, sizeof( cAuxidTipoLinha ) );
   memset( &cAuxidTipoCarteira, 0, sizeof( cAuxidTipoCarteira ) );
   memset( &cAuxidSegmentacao, 0, sizeof( cAuxidSegmentacao ) );
   if( strlennull( cidTipoLinha ) <= 0 )
      strcpy( cAuxidTipoLinha, "-1" );
   else
      strcpy( cAuxidTipoLinha, cidTipoLinha );

   if( strlennull( cidTipoCarteira ) <= 0 )
      strcpy( cAuxidTipoCarteira, "-1" );
   else
      strcpy( cAuxidTipoCarteira, cidTipoCarteira );

   if( strlennull( cidSegmentacao ) <= 0 )
      strcpy( cAuxidSegmentacao, "-1" );
   else
      strcpy( cAuxidSegmentacao, cidSegmentacao );

   ZeraContato();
   
   
   memset( &stContatoRaiz, 0, sizeof( stContatoRaiz ) );

   EXEC SQL WHENEVER NOT FOUND CONTINUE;
   EXEC SQL WHENEVER SQLERROR GOTO GotoListaSemGrupo;
   sqlca.sqlcode=0;
   
   EXEC SQL
       SELECT CONTATO.IDCONTATO,
             CONTATO.IDNOMECONTATO,
             NMCONTATO.NMCONTATO NMCONTATO,
             CONTATO.INDISPONIBILIDADE
        INTO :stContatoRaiz:stContatoRaizIndicator
        FROM CONTATOADM.CONTATO CONTATO,
		 	 CONTATOADM.NOMECONTATO NMCONTATO
       WHERE 
	   		 CONTATO.IDNOMECONTATO=NMCONTATO.IDNOMECONTATO
	   AND
	   	  	 CONTATO.IDCONTATO NOT IN
             (SELECT IDCONTATO
                FROM CONTATOADM.CONTATOHIERARQUIA
               WHERE CONTATOHIERARQUIA.IDCONTATO = :idContatoWrk)
         AND ROWNUM <= 1;

   Add((char*)stContatoRaiz.stidContato.arr,
       "",
      (char*)stContatoRaiz.stidNomeContato.arr,
      (char*)stContatoRaiz.stnmContato.arr,
      (char*)stContatoRaiz.stinDisponibilidade.arr,
       "",
      0,
      0);               
  iCont++;
  
   //Cursor para recuperar a arvore
   EXEC SQL WHENEVER NOT FOUND DO break;

	EXEC SQL DECLARE ReadContatoGrupo CURSOR FOR
        SELECT 
            HIERARQUIA.IDCONTATO,
            HIERARQUIA.IDNOMECONTATO,
            HIERARQUIA.NMCONTATO,
            HIERARQUIA.INDISPONIBILIDADE,
            LEVEL,
            HIERARQUIA.IDCONTATOPAI,
            SYS_CONNECT_BY_PATH(REPLACE(HIERARQUIA.NMCONTATO, '/', '\' ), '/') AS "PATH",
            DECODE(IDCONTATOFOLHA, NULL, 0, 1 )
        FROM 
            CONTATOADM.CONTATOHIERARQUIAV01 HIERARQUIA,
		    CONTATOADM.CONTATO CONTATO
        WHERE
            HIERARQUIA.IDCONTATO = CONTATO.IDCONTATO
		AND CONTATO.IDTIPOARVORE = (SELECT IDTIPOARVORE
                                      FROM APOIO.TIPOARVORE
                                     WHERE DSTIPOARVORE = 'ÁRVORE DE CONTATOS')
        START WITH
            HIERARQUIA.IDCONTATOPAI = :stContatoRaiz.stidContato
        CONNECT BY
            HIERARQUIA.IDCONTATOPAI = PRIOR HIERARQUIA.IDCONTATO;

   EXEC SQL OPEN ReadContatoGrupo;

   if(sqlca.sqlcode)
      return 0;
   else
   {
      for(;;)
      {
         memset( &stContatoRegistro, 0, sizeof(stContatoRegistro) );
         EXEC SQL FETCH ReadContatoGrupo INTO :stContatoRegistro:stContatoIndicator;
         Add((char*)stContatoRegistro.stidContato.arr,
            (char*)stContatoRegistro.stidContatoPai.arr,
            (char*)stContatoRegistro.stidNomeContato.arr,
            (char*)stContatoRegistro.stnmContato.arr,
            (char*)stContatoRegistro.stinDisponibilidade.arr,
            (char*)stContatoRegistro.stdsPath.arr,
            stContatoRegistro.iLevel,
            stContatoRegistro.iFolha);
         iCont++;
      }
      EXEC SQL CLOSE ReadContatoGrupo;
   }
  
   if(sqlca.sqlcode)
      iCont= 0;
   
   ULOG_END("CContato::ListaSemGrupo()");  
   return iCont;

GotoListaSemGrupo:
   throw TuxBasicOraException(sqlca.sqlcode);

}


int CContato::ListaComGrupo( 
                              char *idGrupoParam ,
                              char* cidUFOperadora ,
                              char* cidTipoLinha ,
                              char* cidTipoCarteira ,
                              char* cidSegmentacao 
                           )
{
   ULOG_START("CContato::ListaComGrupo()");    
   int iCont = 0;
   struct sqlca sqlca;
   
   EXEC SQL BEGIN DECLARE SECTION;
   
      int idContatoWrk;
      int idGrupoWrk = atoi( idGrupoParam );
 
      char* cAuxidUFOperadora = cidUFOperadora;
      char  cAuxidTipoLinha[21+1];
      char  cAuxidTipoCarteira[21+1];
      char  cAuxidSegmentacao[21+1];
     
      struct
      {
         VARCHAR stidContato[21+1];
         VARCHAR stidNomeContato[21+1];
         VARCHAR stnmContato[255+1];
         VARCHAR stinDisponibilidade[21+1];
         int     iLevel;
         VARCHAR stidContatoPai[21+1];
         VARCHAR stdsPath[1024+1];
         int     iFolha;
      } stContatoRegistro;
      struct
      {
         short iidContato;
         short iidNomeContato;
         short inmContato;
         short iinDisponibilidade;
         short iLevel;
         short iidContatoPai;
         short idsPath;
         short iiFolha;
      } stContatoIndicator;
      struct
      {
         VARCHAR stidContato[21+1];
         VARCHAR stidNomeContato[21+1];
         VARCHAR stnmContato[255+1];
         VARCHAR stinDisponibilidade[21+1];
      } stContatoRaiz;
      struct
      {
         short iidContato;
         short iidNomeContato;
         short inmContato;
         short iinDisponibilidade;
      } stContatoRaizIndicator;
   EXEC SQL END DECLARE SECTION;


   memset( &cAuxidTipoLinha, 0, sizeof( cAuxidTipoLinha ) );
   memset( &cAuxidTipoCarteira, 0, sizeof( cAuxidTipoCarteira ) );
   memset( &cAuxidSegmentacao, 0, sizeof( cAuxidSegmentacao ) );
   if( strlennull( cidTipoLinha ) <= 0 )
      strcpy( cAuxidTipoLinha, "-1" );
   else
      strcpy( cAuxidTipoLinha, cidTipoLinha );

   if( strlennull( cidTipoCarteira ) <= 0 )
      strcpy( cAuxidTipoCarteira, "-1" );
   else
      strcpy( cAuxidTipoCarteira, cidTipoCarteira );

   if( strlennull( cidSegmentacao ) <= 0 )
      strcpy( cAuxidSegmentacao, "-1" );
   else
      strcpy( cAuxidSegmentacao, cidSegmentacao );

   ZeraContato();
   memset( &stContatoRaiz, 0, sizeof( stContatoRaiz ) );

   EXEC SQL WHENEVER NOT FOUND CONTINUE;
   EXEC SQL WHENEVER SQLERROR GOTO GotoListaComGrupo;
   sqlca.sqlcode=0;
   
   //Recupera a raiz da arvore
   EXEC SQL
  	  SELECT CONTATO.IDCONTATO,
             CONTATO.IDNOMECONTATO,
             NMCONTATO.NMCONTATO NMCONTATO,
             CONTATO.INDISPONIBILIDADE
        INTO :stContatoRaiz:stContatoRaizIndicator
        FROM CONTATOADM.CONTATO CONTATO,
			CONTATOADM.NOMECONTATO NMCONTATO
       WHERE
	   		 CONTATO.IDNOMECONTATO=NMCONTATO.IDNOMECONTATO  
	   AND 
	   	   CONTATO.IDCONTATO NOT IN
             (SELECT IDCONTATO
                FROM CONTATOADM.CONTATOHIERARQUIA)
               --//WHERE CONTATOHIERARQUIA.IDCONTATO > 0)
         AND ROWNUM <= 1;
                  
   Add((char*)stContatoRaiz.stidContato.arr,
       "",
      (char*)stContatoRaiz.stidNomeContato.arr,
      (char*)stContatoRaiz.stnmContato.arr,
      (char*)stContatoRaiz.stinDisponibilidade.arr,
       "",
      0,
      0);
   iCont++;
   idContatoWrk = atoi((char *)stContatoRaiz.stidContato.arr);

   //Cursor para recuperar a arvore
   EXEC SQL WHENEVER NOT FOUND DO break;
   
	EXEC SQL DECLARE ReadListaComGrupo CURSOR FOR
        SELECT DISTINCT
            HIERARQUIA.IDCONTATO,
            HIERARQUIA.IDNOMECONTATO,
            HIERARQUIA.NMCONTATO NMCONTATO,
            HIERARQUIA.INDISPONIBILIDADE,
            LEVEL,
            HIERARQUIA.IDCONTATOPAI,
            SYS_CONNECT_BY_PATH(REPLACE(HIERARQUIA.NMCONTATO, '/', '\' ), '/') AS "PATH",
            DECODE(IDCONTATOFOLHA, NULL, 0, 1 )
        FROM 
            CONTATOADM.CONTATOHIERARQUIAV01 HIERARQUIA
        WHERE 
            HIERARQUIA.IDCONTATOPAI = :idContatoWrk
        START WITH HIERARQUIA.IDCONTATO IN
        (
            SELECT 
                IDCONTATO 
            FROM
                CONTATOADM.CONTATOFILTROV01
            WHERE 
                IDGRUPO = :idGrupoWrk
            AND IDUFOPERADORA = :cAuxidUFOperadora
            AND ( IDTIPOLINHA = :cAuxidTipoLinha OR :cAuxidTipoLinha = '-1' )
            AND ( IDTIPOCARTEIRA = :cAuxidTipoCarteira OR :cAuxidTipoCarteira = '-1' )
            AND ( IDSEGMENTACAO = :cAuxidSegmentacao OR :cAuxidSegmentacao = '-1' )
        )
        CONNECT BY PRIOR 
            HIERARQUIA.IDCONTATOPAI = HIERARQUIA.IDCONTATO
        ORDER BY
            LEVEL DESC;

   EXEC SQL OPEN ReadListaComGrupo;

   if(sqlca.sqlcode)
      iCont = 0;
   else
   {
      for(;;)
      {
         memset( &stContatoRegistro, 0, sizeof(stContatoRegistro) );
         EXEC SQL FETCH ReadListaComGrupo INTO :stContatoRegistro:stContatoIndicator;
         Add((char*)stContatoRegistro.stidContato.arr,
            (char*)stContatoRegistro.stidContatoPai.arr,
            (char*)stContatoRegistro.stidNomeContato.arr,
            (char*)stContatoRegistro.stnmContato.arr,
            (char*)stContatoRegistro.stinDisponibilidade.arr,
            (char*)stContatoRegistro.stdsPath.arr,
            stContatoRegistro.iLevel,
            stContatoRegistro.iFolha);
         iCont++;
      }
      EXEC SQL CLOSE ReadListaComGrupo;
   }

   if(sqlca.sqlcode)
      iCont = 0;
   
   ULOG_END("CContato::ListaComGrupo()");    
   return iCont;

GotoListaComGrupo:
   throw TuxBasicOraException(sqlca.sqlcode);

}


int CContato::ListaComContato( 
                                 char *idContatoParam, 
                                 char *idGrupoParam ,
                                 char* cidUFOperadora ,
                                 char* cidTipoLinha ,
                                 char* cidTipoCarteira ,
                                 char* cidSegmentacao 
                             )
{
   ULOG_START("CContato::ListaComContato()");    
   int iCont = 0;
   struct sqlca sqlca;
   EXEC SQL BEGIN DECLARE SECTION;
   
      int idContatoWrk = atoi( idContatoParam );
      int idGrupoWrk = atoi( idGrupoParam );
 
      char* cAuxidUFOperadora = cidUFOperadora;
      char  cAuxidTipoLinha[21+1];
      char  cAuxidTipoCarteira[21+1];
      char  cAuxidSegmentacao[21+1];
     
      struct
      {
         VARCHAR stidContato[21+1];
         VARCHAR stidNomeContato[21+1];
         VARCHAR stnmContato[255+1];
         VARCHAR stinDisponibilidade[21+1];
         int     iLevel;
         VARCHAR stidContatoPai[21+1];
         VARCHAR stdsPath[1024+1];
         int     iFolha;
      } stContatoRegistro;
      struct
      {
         short iidContato;
         short iidNomeContato;
         short inmContato;
         short iinDisponibilidade;
         short iLevel;
         short iidContatoPai;
         short idsPath;
         short iiFolha;
      } stContatoIndicator;
      struct
      {
         VARCHAR stidContato[21+1];
         VARCHAR stidNomeContato[21+1];
         VARCHAR stnmContato[255+1];
         VARCHAR stinDisponibilidade[21+1];
      } stContatoRaiz;
      struct
      {
         short iidContato;
         short iidNomeContato;
         short inmContato;
         short iinDisponibilidade;
      } stContatoRaizIndicator;
   EXEC SQL END DECLARE SECTION;

   memset( &cAuxidTipoLinha, 0, sizeof( cAuxidTipoLinha ) );
   memset( &cAuxidTipoCarteira, 0, sizeof( cAuxidTipoCarteira ) );
   memset( &cAuxidSegmentacao, 0, sizeof( cAuxidSegmentacao ) );

   if( strlennull( cidTipoLinha ) <= 0 )
      strcpy( cAuxidTipoLinha, "-1" );
   else
      strcpy( cAuxidTipoLinha, cidTipoLinha );

   if( strlennull( cidTipoCarteira ) <= 0 )
      strcpy( cAuxidTipoCarteira, "-1" );
   else
      strcpy( cAuxidTipoCarteira, cidTipoCarteira );

   if( strlennull( cidSegmentacao ) <= 0 )
      strcpy( cAuxidSegmentacao, "-1" );
   else
      strcpy( cAuxidSegmentacao, cidSegmentacao );

   ZeraContato();
   memset( &stContatoRaiz, 0, sizeof( stContatoRaiz ) );

   EXEC SQL WHENEVER NOT FOUND CONTINUE;
   EXEC SQL WHENEVER SQLERROR GOTO GotoListaComContato;
   sqlca.sqlcode=0;
   
   EXEC SQL
	 SELECT CONTATO.IDCONTATO,
            CONTATO.IDNOMECONTATO,
            NMCONTATO.NMCONTATO NMCONTATO,
            CONTATO.INDISPONIBILIDADE
     INTO	:stContatoRaiz:stContatoRaizIndicator
     FROM	CONTATOADM.CONTATO CONTATO,
			CONTATOADM.NOMECONTATO NMCONTATO
     WHERE
	   		CONTATO.IDNOMECONTATO=NMCONTATO.IDNOMECONTATO 
	 AND 
			CONTATO.IDCONTATO NOT IN
            (SELECT IDCONTATO
             FROM CONTATOADM.CONTATOHIERARQUIA
             WHERE CONTATOHIERARQUIA.IDCONTATO = :idContatoWrk)
     AND ROWNUM <= 1; 

   Add((char*)stContatoRaiz.stidContato.arr,
       "",
      (char*)stContatoRaiz.stidNomeContato.arr,
      (char*)stContatoRaiz.stnmContato.arr,
      (char*)stContatoRaiz.stinDisponibilidade.arr,
       "",
      0,
      0);               
   iCont++;
   
   //Cursor para recuperar a arvore
   EXEC SQL WHENEVER NOT FOUND DO break;
   
	EXEC SQL 
		DECLARE 
			ReadComContatos CURSOR FOR
      SELECT DISTINCT
          HIERARQUIA.IDCONTATO
         ,HIERARQUIA.IDNOMECONTATO
         ,HIERARQUIA.NMCONTATO NMCONTATO
         ,HIERARQUIA.INDISPONIBILIDADE
         ,LEVEL
         ,HIERARQUIA.IDCONTATOPAI
         ,SYS_CONNECT_BY_PATH(REPLACE(HIERARQUIA.NMCONTATO, '/', '\' ), '/') "PATH"
         ,DECODE(IDCONTATOFOLHA, NULL, 0, 1 )
      FROM 
         CONTATOADM.CONTATOHIERARQUIAV01 HIERARQUIA
      WHERE 
         HIERARQUIA.IDCONTATOPAI = :idContatoWrk
      START WITH 
         HIERARQUIA.IDCONTATO
      IN 
         ( SELECT 
               IDCONTATO 
           FROM
               CONTATOADM.CONTATOFILTROV01
           WHERE 
               IDGRUPO = :idGrupoWrk
           AND 
               IDUFOPERADORA = :cAuxidUFOperadora
           AND 
              ( IDTIPOLINHA = :cAuxidTipoLinha OR :cAuxidTipoLinha = '-1' )
           AND 
              ( IDTIPOCARTEIRA = :cAuxidTipoCarteira OR :cAuxidTipoCarteira = '-1' )
           AND 
              ( IDSEGMENTACAO = :cAuxidSegmentacao OR :cAuxidSegmentacao = '-1' )
         )
         CONNECT BY PRIOR 
            HIERARQUIA.IDCONTATOPAI = HIERARQUIA.IDCONTATO
         ORDER BY LEVEL DESC;

   EXEC SQL OPEN ReadComContatos;

   if(sqlca.sqlcode)
      iCont = 0;
   else
   {
      for(;;)
      {
         memset( &stContatoRegistro, 0, sizeof(stContatoRegistro) );
         EXEC SQL FETCH ReadComContatos INTO :stContatoRegistro:stContatoIndicator;
         Add((char*)stContatoRegistro.stidContato.arr,
            (char*)stContatoRegistro.stidContatoPai.arr,
            (char*)stContatoRegistro.stidNomeContato.arr,
            (char*)stContatoRegistro.stnmContato.arr,
            (char*)stContatoRegistro.stinDisponibilidade.arr,
            (char*)stContatoRegistro.stdsPath.arr,
            stContatoRegistro.iLevel,
            stContatoRegistro.iFolha);
         iCont++;
      }
      EXEC SQL CLOSE ReadComContatos;
   }

   if(sqlca.sqlcode)
      iCont = 0;
   
   
   ULOG_END("CContato::ListaComContato()");    
   
   return iCont;

GotoListaComContato:
   throw TuxBasicOraException(sqlca.sqlcode);

}

void CContato::TpRetorno( char *idContatoParam, int idTpRetornoParam, char * Saida )
{
   ULOG_START("CContato::TpRetorno()");     
   struct sqlca sqlca;
   EXEC SQL BEGIN DECLARE SECTION;
      int idTpRetornoWrk = idTpRetornoParam;
      int idContatoWrk = atoi( idContatoParam );

      int Retorno;
   EXEC SQL END DECLARE SECTION;
  
   EXEC SQL WHENEVER SQLERROR GOTO ErroTpRetorno;
   EXEC SQL WHENEVER NOT FOUND CONTINUE;
   EXEC SQL
      SELECT 
	         A.IDTIPORELACIONAMENTO
      INTO
            :Retorno 
      FROM 
	       CONTATOADM.CONTATOTIPORELACIONAMENTO A,
	       CONTATOADM.CONTATO B
      WHERE
	       A.IDCONTATO = :idContatoWrk
      and
	       A.IDCONTATO = B.IDCONTATO
      AND
           A.IDCONTATOTIPORELACIONAMENTO = :idTpRetornoWrk;

   if ( Retorno > 0 )
      strcpy( Saida,"1" );
   else
      strcpy( Saida,"0" );

   ULOG_END("CContato::TpRetorno()");     
   return;

ErroTpRetorno:
   throw TuxBasicOraException(sqlca.sqlcode);

}





void CContato::URLInf( char *idContatoParam, char * Saida )
{
   ULOG_START("CContato::URLInf()");     
   struct sqlca sqlca;
   EXEC SQL BEGIN DECLARE SECTION;
      int idContatoWrk = atoi( idContatoParam );
      VARCHAR  OraURL[ 256 ];

      short i_OraURL;
   EXEC SQL END DECLARE SECTION;
  
   EXEC SQL WHENEVER SQLERROR GOTO ErroTpRetorno;
   EXEC SQL WHENEVER NOT FOUND CONTINUE;
   EXEC SQL
      SELECT
	        NMURLCONTATOINFORMACAO
      INTO
          :OraURL:i_OraURL
      FROM
	        CONTATOADM.CONTATOINFORMACAO
      WHERE
	       IDCONTATO = :idContatoWrk;

   if ( i_OraURL < 0 )
   {
      ULOG_END("CContato::URLInf()");     
      return;
   }

   OraURL.arr[OraURL.len] = 0x0;

   strcpy( Saida,(char *)OraURL.arr );
   
   ULOG_END("CContato::URLInf()");     

   return;

ErroTpRetorno:
   throw TuxBasicOraException(sqlca.sqlcode);

}