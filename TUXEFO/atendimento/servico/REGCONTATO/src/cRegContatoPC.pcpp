/**
 * @author  Renato Teixeira
 * @version $Revision: 1.1.2.13.6.5 $
 * @CVS     $Author: a5114878 $ - $Date: 2013/02/06 12:36:43 $
 **/

#ifdef WIN32
#pragma warning(disable:4786)
#endif

#include <string>

using namespace std;

#include <tuxfw.h> 
#include "../include/cApoio.h" 
#include "../include/cRegContatoPC.h"
#include "../../../commons/msgPadrao.h"

EXEC SQL BEGIN DECLARE SECTION;

#include "../../Atendimento/include/stWFAtendimento.h"

EXEC SQL END DECLARE SECTION;

EXEC SQL BEGIN DECLARE SECTION; 
   #define TAM_MAX_BLC_ORA      25 
   #define NRO_MAX_REG_ORA      10 
   #define TAM_MAX_NR_DOCUMENTO 90
EXEC SQL END DECLARE SECTION; 

void SqlError( sqlca * sqlca );

/**
    Retorna a data atual do banco de dados para ser usada como parametro das demais chamadas.
*/
void cRegContatoPC::dataAtual(char* data/*,char *dataSMS*/)
{
    ULOG_START("cRegContatoPC::dataAtual()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        VARCHAR dataAtual[32]; 
        //VARCHAR dataAtualSMS[32];
        short idataAtual = -1; 
        //short idataAtualSMS = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL 
        SELECT
            TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS')
           //,TO_CHAR(SYSDATE, 'DD/MM/YYYY')|| ' as ' ||TO_CHAR(SYSDATE, 'HH24:MI') 
        INTO
            :dataAtual:idataAtual
           //,:dataAtualSMS:idataAtualSMS
        FROM
            DUAL;

    CONVIND(dataAtual,idataAtual); 
    //CONVIND(dataAtualSMS,idataAtualSMS); 

    //strcpy(data,(char*)dataAtual.arr); 
    sprintf( data,"%.*s",dataAtual.len,(char*)dataAtual.arr);
    //strcpy(dataSMS,(char*)dataAtualSMS.arr); 

    ULOG_END("cRegContatoPC::dataAtual()");
}

bool cRegContatoPC::ValidaPessoaDePara( const int idPessoaDeParaPrm )
{
    ULOG_START("cRegContatoPC::ValidaPessoaDePara()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

       const int idPessoaDePara = idPessoaDeParaPrm;
       int iTotReg = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegContatoPC(&sqlca);

    ULOG("Consultando idPessoaDePara [%d]", idPessoaDePara );

    EXEC SQL 
        SELECT
            COUNT(1)
        INTO
            :iTotReg
        FROM
           CUSTOMER.PESSOADEPARA
        WHERE
           IDPESSOADEPARA = :idPessoaDePara;

    ULOG("Dados obtidos - iTotReg = [%d]", iTotReg );

    ULOG_END("cRegContatoPC::ValidaPessoaDePara()");

    return iTotReg > 0 ? true : false;
}

// SM324--DPR--DEZ/2006--Cassio
// Funcionalidade "quebra-galho" do DPR.
// Em tempo:
//  Como o DPR não estava enviando dados de INSERTs de tabelas customer 
//  (pessoa,pessoadepara,pessoalinhahistorico) agora a cada abertura de processo 
//  é enviado ao DPR um XML "fake" indicativo de um INSERT nestas tabelas.
//  Esta funcionalidade foi executada a pedido do Tiago e Borelli da área
//  do Tibco Indra.
//
void cRegContatoPC::AtualizarDadosPessoaLinhaHistorico(long _idPessoaLinhaHistorico,XMLDPR *xmlDpr)
{
    ULOG_START("cRegContatoPC::AtualizarDadosPessoaLinhaHistorico()");

    PessoaLinhaHistoricoDPR pessoaLinhaHistoricoDPR;
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idPessoaLinhaHistorico = _idPessoaLinhaHistorico;
        int cdAreaRegistro;
        VARCHAR dtRelacionamento[32];
        int idLinhaTelefonica;
        int idPessoaDePara;
        int idTipoRelacionamento;
        int nrLinha;

        short i_cdAreaRegistro = -1;
        short i_dtRelacionamento = -1;
        short i_idLinhaTelefonica = -1;
        short i_idPessoaDePara = -1;
        short i_idPessoaLinhaHistorico = -1;
        short i_idTipoRelacionamento = -1;
        short i_nrLinha = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL 
        SELECT
            CDAREAREGISTRO,
            TO_CHAR(DTRELACIONAMENTO,'DD/MM/YYYY HH24:MI:SS'),
            IDLINHATELEFONICA,
            IDPESSOADEPARA,
            IDPESSOALINHAHISTORICO,
            IDTIPORELACIONAMENTO,
            NRLINHA
        INTO
            :cdAreaRegistro:i_cdAreaRegistro,
            :dtRelacionamento:i_dtRelacionamento,
            :idLinhaTelefonica:i_idLinhaTelefonica,
            :idPessoaDePara:i_idPessoaDePara,
            :idPessoaLinhaHistorico:i_idPessoaLinhaHistorico,
            :idTipoRelacionamento:i_idTipoRelacionamento,
            :nrLinha:i_nrLinha
        FROM
           CUSTOMER.PESSOALINHAHISTORICO
        WHERE
           IDPESSOALINHAHISTORICO = :idPessoaLinhaHistorico;

    if ( 0 == sqlca.sqlcode )
    {
        CONVIND(dtRelacionamento,i_dtRelacionamento);

        pessoaLinhaHistoricoDPR.setCdAreaRegistro(cdAreaRegistro);
        pessoaLinhaHistoricoDPR.setDtRelacionamento((char*)dtRelacionamento.arr);
        pessoaLinhaHistoricoDPR.setIdLinhaTelefonica(idLinhaTelefonica);
        pessoaLinhaHistoricoDPR.setIdPessoaDePara(idPessoaDePara);
        pessoaLinhaHistoricoDPR.setIdPessoaLinhaHistorico(idPessoaLinhaHistorico);
        pessoaLinhaHistoricoDPR.setIdTipoRelacionamento(idTipoRelacionamento);
        pessoaLinhaHistoricoDPR.setNrLinha(nrLinha);
        pessoaLinhaHistoricoDPR.setOpCode(OPCODE_INSERT);

        xmlDpr->pessoalinhahistoricovo.inserir(&pessoaLinhaHistoricoDPR);
    }
    else
    {
        ULOGW("Dados não encontrados para idPessoaLinhaHistorico=%ld",
                                                            idPessoaLinhaHistorico);
    }

    ULOG_END("cRegContatoPC::AtualizarDadosPessoaLinhaHistorico()");
}

// SM324--DPR--DEZ/2006--Cassio
// Funcionalidade "quebra-galho" do DPR.
// Em tempo:
//  Como o DPR não estava enviando dados de INSERTs de tabelas customer 
//  (pessoa,pessoadepara,pessoalinhahistorico) agora a cada abertura de processo 
//  é enviado ao DPR um XML "fake" indicativo de um INSERT nestas tabelas.
//  Esta funcionalidade foi executada a pedido do Tiago e Borelli da área
//  do Tibco Indra.
//
void cRegContatoPC::AtualizarDadosPessoaDeParaDPR(int _idPessoaDePara,XMLDPR *xmlDpr)
{
    ULOG_START("cRegContatoPC::AtualizarDadosPessoaDeParaDPR()");

    PessoaDeParaDPR pessoaDeParaDPR;
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

       int idPessoaDePara = _idPessoaDePara;
       long idPessoa;
       long idPessoaOrigem;

       short i_idPessoa = -1;
       short i_idPessoaOrigem = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL 
        SELECT
            IDPESSOA,
            IDPESSOAORIGEM
        INTO
            :idPessoa:i_idPessoa,
            :idPessoaOrigem:i_idPessoaOrigem
        FROM
           CUSTOMER.PESSOADEPARA
        WHERE
           IDPESSOADEPARA = :idPessoaDePara;

    if ( 0 == sqlca.sqlcode )
    {
        pessoaDeParaDPR.setIdPessoa(idPessoa);
        pessoaDeParaDPR.setIdPessoaDePara(idPessoaDePara);
        pessoaDeParaDPR.setIdPessoaOrigem(idPessoaOrigem);
        pessoaDeParaDPR.setOpCode(OPCODE_INSERT);

        xmlDpr->pessoadeparavo.inserir(&pessoaDeParaDPR);
    }
    else
    {
        ULOGW("Dados não encontrados para idPessoaDePara=%d",idPessoaDePara);
    }

    ULOG_END("cRegContatoPC::AtualizarDadosPessoaDeParaDPR()");
}

// SM324--DPR--DEZ/2006--Cassio
// Funcionalidade "quebra-galho" do DPR.
// Em tempo:
//  Como o DPR não estava enviando dados de INSERTs de tabelas customer 
//  (pessoa,pessoadepara,pessoalinhahistorico) agora a cada abertura de processo 
//  é enviado ao DPR um XML "fake" indicativo de um INSERT nestas tabelas.
//  Esta funcionalidade foi executada a pedido do Tiago e Borelli da área
//  do Tibco Indra.
//
void cRegContatoPC::AtualizarDadosPessoaDPR(int _idPessoaDePara,XMLDPR *xmlDpr)
{
    ULOG_START("cRegContatoPC::AtualizarDadosPessoaDPR()");

    PessoaDPR pessoaDPR;
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

       int idPessoaDePara = _idPessoaDePara;

       long idPessoa;
       int idTipoPessoa;
       VARCHAR nmPessoa[256];

       short i_idPessoa;
       short i_idTipoPessoa;
       short i_nmPessoa;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE curPessoa CURSOR FOR
        SELECT
            PESSOA.IDPESSOA,
            PESSOA.IDTIPOPESSOA,
            PESSOA.NMPESSOA
        INTO
            :idPessoa:i_idPessoa,
            :idTipoPessoa:i_idTipoPessoa,
            :nmPessoa:i_nmPessoa
        FROM
           CUSTOMER.PESSOA PESSOA,
           CUSTOMER.PESSOADEPARA PESSOADEPARA
        WHERE
           PESSOADEPARA.IDPESSOADEPARA = :idPessoaDePara
        AND
           PESSOADEPARA.IDPESSOA = PESSOA.IDPESSOA;

    EXEC SQL OPEN curPessoa;

    while (true)
    {
        i_nmPessoa = -1;

        EXEC SQL FETCH curPessoa INTO
            :idPessoa:i_idPessoa,
            :idTipoPessoa:i_idTipoPessoa,
            :nmPessoa:i_nmPessoa;

        CONVIND(nmPessoa,i_nmPessoa);
            
        pessoaDPR.setIdPessoa(idPessoa);
        pessoaDPR.setIdPessoaDePara(idPessoaDePara);
        pessoaDPR.setIdTipoPessoa(idTipoPessoa);
        pessoaDPR.setNmPessoa((char*)nmPessoa.arr);
        pessoaDPR.setOpCode(OPCODE_INSERT);

        xmlDpr->pessoavo.inserir(&pessoaDPR);
    }

    EXEC SQL CLOSE curPessoa;

    ULOG_END("cRegContatoPC::AtualizarDadosPessoaDPR()");
}
/**
    Retorna o prazo solução do atendimento.
*/
void cRegContatoPC::obtemPrazoAtendimentoSegmentado(double* horas,int _idContato, int _idSegmentacao, int _idProcedencia)
{
    ULOG_START("cRegContatoPC::obtemPrazoAtendimentoSegmentado()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int idContato     = _idContato;
        int idSegmentacao = _idSegmentacao;
        int idProcedencia = _idProcedencia;

        int vlHoras = 0;

        short i_vlHoras = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        SELECT
            QTHORASPRAZOCONTATO
        INTO
            :vlHoras:i_vlHoras
        FROM
            CONTATOADM.PRAZOATENDIMENTO
        WHERE
            IDCONTATO = :idContato
        AND IDSEGMENTACAO = :idSegmentacao
        AND IDPROCEDENCIA = :idProcedencia
        AND ROWNUM < 2;

    if (i_vlHoras == -1)
        vlHoras = i_vlHoras;

    *horas = vlHoras;

    ULOG("Dados obtidos - vlHoras = [%i]", vlHoras);

    ULOG_END("cRegContatoPC::obtemPrazoAtendimentoSegmentado()");
}

/**
    Retorna o peso do atendimento.
*/
bool cRegContatoPC::obtemPesoAtendimento(char* peso,int _idContato,int _idSegmentacao,int _idProcedencia,int _idTipoCarteira,const char *sgTipoPortabilidade,int _idFormulario,bool _isVolE)
{
    ULOG_START("cRegContatoPC::obtemPesoAtendimento()");

    struct sqlca sqlca;
    bool pesoBKO = true;

    EXEC SQL BEGIN DECLARE SECTION;

        int idContato      = _idContato;
        int idSegmentacao  = _idSegmentacao;
        int idProcedencia  = _idProcedencia;
        int idTipoCarteira = _idTipoCarteira;
        int idFormulario   = _idFormulario;

        VARCHAR vlPeso[256];
        short i_vlPeso=-1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegContatoPC(&sqlca); 
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    if ( _isVolE )
    {
        ULOG(
           "SELECT "
               "SLAFUNCIONALIDADEFRM.VALORSLA "
           "FROM "
               "CONTATOADM.FUNCIONALIDADEFRM FUNCIONALIDADEFRM, "
               "CONTATOADM.SLAFUNCIONALIDADEFRM SLAFUNCIONALIDADEFRM "
           "WHERE "
               "FUNCIONALIDADEFRM.IDCONTATO = %d "
           "AND FUNCIONALIDADEFRM.IDFORMULARIO = %d "
           "AND FUNCIONALIDADEFRM.INATIVO = 0 "
           "AND FUNCIONALIDADEFRM.IDSLAFUNCIONALIDADEFRM= SLAFUNCIONALIDADEFRM.IDSLAFUNCIONALIDADEFRM "
                    ,idContato,_idFormulario);

        EXEC SQL
            SELECT 
                SLAFUNCIONALIDADEFRM.VALORSLA
            INTO
                :vlPeso:i_vlPeso
            FROM
                CONTATOADM.FUNCIONALIDADEFRM FUNCIONALIDADEFRM,
                CONTATOADM.SLAFUNCIONALIDADEFRM SLAFUNCIONALIDADEFRM
            WHERE
                FUNCIONALIDADEFRM.IDCONTATO = :idContato
            AND FUNCIONALIDADEFRM.IDFORMULARIO = :idFormulario
            AND FUNCIONALIDADEFRM.INATIVO = 0
            AND FUNCIONALIDADEFRM.IDSLAFUNCIONALIDADEFRM =
                                SLAFUNCIONALIDADEFRM.IDSLAFUNCIONALIDADEFRM;

        CONVIND(vlPeso,i_vlPeso);

        if ( sqlca.sqlcode==0 && strcmp((char*)vlPeso.arr,"0") )
        {
            pesoBKO=false;
        }
    }

    if ( strcmp(sgTipoPortabilidade,"PORTOUT")==0 )
    {
        ULOG("SELECT pesoEstatico "
                       "FROM atendimento.CalculaPesoEstaticoPOV01 "
                      "WHERE idContato = %d "
                        "AND idSegmentacao = %d "
                        "AND idProcedencia = %d "
                        "AND idTipoCarteira = %d"
                    ,idContato,idSegmentacao
                    ,idProcedencia,idTipoCarteira);

        EXEC SQL
            SELECT
                pesoEstatico
            INTO
                :vlPeso:i_vlPeso
            FROM
                atendimento.CalculaPesoEstaticoPOV01
            WHERE
                idContato = :idContato
            AND idSegmentacao = :idSegmentacao
            AND idProcedencia = :idProcedencia
            AND idTipoCarteira = :idTipoCarteira; 
    }
    else if ( pesoBKO )
    {
        ULOG("SELECT pesoEstatico "
                       "FROM atendimento.CalculaPesoEstaticoV01 "
                      "WHERE idContato = %d "
                        "AND idSegmentacao = %d "
                        "AND idProcedencia = %d "
                        "AND idTipoCarteira = %d"
                    ,idContato,idSegmentacao
                    ,idProcedencia,idTipoCarteira);

        EXEC SQL
            SELECT
                pesoEstatico
            INTO
                :vlPeso:i_vlPeso
            FROM
                atendimento.CalculaPesoEstaticoV01
            WHERE
                idContato = :idContato
            AND idSegmentacao = :idSegmentacao
            AND idProcedencia = :idProcedencia
            AND idTipoCarteira = :idTipoCarteira; 
    }
 
    if ( 0 == sqlca.sqlcode ) 
    { 
        CONVIND(vlPeso,i_vlPeso);

        strncpy(peso,(char*)vlPeso.arr,255); 
        *(peso+255) = 0; 

        ULOG("vlPeso = [%s]", vlPeso.arr); 
    } 
    else 
    { 
        strcpy(peso,"0"); 
 
        ULOG("Peso não encontrado"); 
    }

    ULOG_END("cRegContatoPC::obtemPesoAtendimento()"); 
 
    return 0 == sqlca.sqlcode ? true : false;
}

/**
    Busca no banco de dados de parametros o prazo em horas que 
    a ANATEL estabelece para o encerramento do atendimento.
*/
int cRegContatoPC::obtemPrazoANATEL()
{
    ULOG_START("cRegContatoPC::obtemPrazoANATEL()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int vlPrazoANATEL;

        short i_vlPrazoANATEL = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL
        SELECT
            dsValorParametro
        INTO
            :vlPrazoANATEL:i_vlPrazoANATEL
        FROM
            apoio.Parametro
        WHERE
            cdParametro = 'pzANATEL';

    if (i_vlPrazoANATEL == -1)
        vlPrazoANATEL = -1;

    ULOG("Dados obtidos - vlPrazoANATEL = [%i]", vlPrazoANATEL);

    ULOG_END("cRegContatoPC::obtemPrazoANATEL()");

    return vlPrazoANATEL;
}

void cRegContatoPC::proCDataFechamentoAnatel(long sIdAtendimento, char* dataFechamento)
{
    ULOG_START("cRegContatoPC::proCDataFechamentoAnatel()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = sIdAtendimento;
        VARCHAR dataAtual[256];
        short i_dataAtual = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL 
        SELECT
            TO_CHAR(DTPRAZOFINALANATEL, 'DD/MM/YYYY HH24:MI')
        INTO    
            :dataAtual:i_dataAtual
        FROM
            Atendimento.Atendimento
        WHERE
            idAtendimento = :idAtendimento;

    CONVIND(dataAtual,i_dataAtual);

    strcpy(dataFechamento,(char*)dataAtual.arr);

    ULOG("Dados obtidos - dataFechamento = [%s]", dataFechamento);

    ULOG_END("cRegContatoPC::proCDataFechamentoAnatel()");
}

void cRegContatoPC::proCDataFechamento(long sIdAtendimento, char* dataFechamento)
{
    ULOG_START("cRegContatoPC::proCDataFechamento()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = sIdAtendimento;
        VARCHAR dataAtual[256];
        short i_dataAtual = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL 
        SELECT
            TO_CHAR(DTPRAZOFINALINTERNO, 'DD/MM/YYYY HH24:MI')
        INTO    
            :dataAtual:i_dataAtual
        FROM
            Atendimento.Atendimento
        WHERE
            idAtendimento = :idAtendimento;

    CONVIND(dataAtual,i_dataAtual);

    strcpy(dataFechamento,(char*)dataAtual.arr);

    ULOG("Dados obtidos - dataFechamento = [%s]", dataFechamento);
    ULOG_END("cRegContatoPC::proCDataFechamento()");
}

//====================================================================================
//  Busca os dados da linha informada na abertura do atendimento.
//====================================================================================
//
void cRegContatoPC::obtemDadosLinhaTelefonica(int _idPessoaDeParaCliente
                                             ,int _idLinhaTelefonica
                                             ,long* _idPessoaLinhaHistorico
                                             ,int* _idEstadoLinha
                                             ,int* _idTipoLinha)
{
    ULOG_START("cRegContatoPC::obtemDadosLinhaTelefonica()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int idPessoaDeParaCliente = _idPessoaDeParaCliente;
        int idLinhaTelefonica = _idLinhaTelefonica;

        long idPessoaLinhaHistorico;
        int idEstadoLinha;
        int idTipoLinha;

        short i_idPessoaLinhaHistorico = -1;
        short i_idEstadoLinha = -1;
        short i_idTipoLinha = -1;

    EXEC SQL END DECLARE SECTION;

    ULOG("idPessoaDeParaCliente=%d",idPessoaDeParaCliente);
    ULOG("idLinhaTelefonica=%d",idLinhaTelefonica);

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL
        SELECT
            IDPESSOALINHAHISTORICO,
            IDESTADOLINHA,
            IDTIPOLINHA
        INTO
            :idPessoaLinhaHistorico:i_idPessoaLinhaHistorico,
            :idEstadoLinha:i_idEstadoLinha,
            :idTipoLinha:i_idTipoLinha
        FROM
		(
	        SELECT
	            PESSOALINHAHISTORICO.IDPESSOALINHAHISTORICO,
	            LINHABASE.IDESTADOLINHA,
	            LINHATELEFONICA.IDTIPOLINHA,
				PESSOALINHAHISTORICO.DTULTIMAALTERACAO
	        FROM
	            CUSTOMER.PESSOALINHAHISTORICO PESSOALINHAHISTORICO,
	            LINHA.LINHATELEFONICA LINHATELEFONICA,
	            LINHA.LINHABASE LINHABASE
	        WHERE
	            PESSOALINHAHISTORICO.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
	        AND LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
	        AND PESSOALINHAHISTORICO.IDTIPORELACIONAMENTO = 2
	        AND PESSOALINHAHISTORICO.IDPESSOADEPARA = :idPessoaDeParaCliente
	        AND PESSOALINHAHISTORICO.IDLINHATELEFONICA = :idLinhaTelefonica
	        AND PESSOALINHAHISTORICO.CDAREAREGISTRO IS NOT NULL
	        AND PESSOALINHAHISTORICO.NRLINHA IS NOT NULL
			ORDER BY PESSOALINHAHISTORICO.DTULTIMAALTERACAO DESC
		)
		WHERE ROWNUM < 2;

    if ( 0==sqlca.sqlcode )
    {
        if (i_idPessoaLinhaHistorico == -1) idPessoaLinhaHistorico = -1;
        if (i_idEstadoLinha == -1) idEstadoLinha = -1;
        if (i_idTipoLinha == -1) idTipoLinha = -1;

        if ( _idPessoaLinhaHistorico ) 
        {
            *_idPessoaLinhaHistorico = idPessoaLinhaHistorico;

            ULOG("idPessoaLinhaHistorico=%ld",idPessoaLinhaHistorico);
        }

        if ( _idEstadoLinha ) 
        {
            *_idEstadoLinha = idEstadoLinha;

            ULOG("idEstadoLinha=%d",idEstadoLinha);
        }

        if ( _idTipoLinha ) 
        {
            *_idTipoLinha = idTipoLinha;

            ULOG("idTipoLinha=%d",idTipoLinha);
        }
    }

    ULOG_END("cRegContatoPC::obtemDadosLinhaTelefonica()");
}

/**
    Busca os dados da linha informada na abertura do atendimento.
*/
void cRegContatoPC::obtemSequenciaAbertura(int *sequencia,int _idContato,int _idGrupoAbertura)
{
    ULOG_START("cRegContatoPC::obtemSequenciaAbertura()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int idContato = _idContato;
        int idGrupo   = _idGrupoAbertura;

        int idSequencia;

        short i_idSequencia  = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegContatoPC(&sqlca);

    /*  @Marcelo remoção de views bzeroum
    EXEC SQL
        SELECT
            idSequencia
        INTO
            :idSequencia:i_idSequencia
        FROM
            contatoadm.SequenciaB01
        WHERE
            idContato = :idContato AND
            idGrupo = :idGrupo AND
            idTipoSequencia = 1 AND
            rownum < 2;
    */

    EXEC SQL
        SELECT
           SEQUENCIA.IDSEQUENCIA
        INTO
            :idSequencia:i_idSequencia
        FROM
           CONTATOADM.CONTATOGRUPO CONTATOGRUPO,
           CONTATOADM.TIPOSEQUENCIA TIPOSEQUENCIA,
           CONTATOADM.SEQUENCIA SEQUENCIA
        WHERE
           SEQUENCIA.IDCONTATOGRUPO = CONTATOGRUPO.IDCONTATOGRUPO
        AND
           SEQUENCIA.IDTIPOSEQUENCIA = TIPOSEQUENCIA.IDTIPOSEQUENCIA
        AND
           CONTATOGRUPO.IDCONTATO = :idContato
        AND
           CONTATOGRUPO.IDGRUPO = :idGrupo 
        AND
           TIPOSEQUENCIA.NMTIPOSEQUENCIA = 'ABERTURA'
        AND
           ROWNUM < 2;

    if ( sequencia ) 
    { 
        *sequencia = i_idSequencia == -1 ? -1 : idSequencia; 
        ULOG("Dados obtidos - idSequencia = [%i]", *sequencia); 
    } 
    else 
    { 
        ULOGW("área para gravação da resposta não foi disponibilizada"); 
    }

    ULOG_END("cRegContatoPC::obtemSequenciaAbertura()");
}

//====================================================================================
//==> Incidência 3271 Homologação VIVO, Julho,2006 - Cassio
//
// Esta operação ficou sem uso com a implementação da incidência acima.
//
//====================================================================================
// Busca os tipo de retorno do atendimento
//====================================================================================
//
void cRegContatoPC::obtemTipoRetornoAtendimento(int* _idTipoRetornoContato, int* _inEnvioTelefone)
{
    ULOG_START("obtemTipoRetornoAtendimento()");
    
    //ULOG( "dados->idTipoRetorno [%d]", dados->idTipoRetorno);
    
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        //int idTipoComunicacao = dados->idTipoRetorno;
        int idTipoComunicacao = 1;

        int idTipoRetornoContato;
        int inEnvioTelefone;

        short i_idTipoRetornoContato = -1;
        short i_inEnvioTelefone = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL
        SELECT
            IDTIPORETORNOCONTATO,
            INENVIOTELEFONE
        INTO
            :idTipoRetornoContato:i_idTipoRetornoContato,
            :inEnvioTelefone:i_inEnvioTelefone
        FROM
            CONTATOADM.FORMARETORNOV01
        WHERE
            IDTIPOCOMUNICACAO = :idTipoComunicacao;

    if (i_idTipoRetornoContato == -1) idTipoRetornoContato = -1;
    if (i_inEnvioTelefone == -1) inEnvioTelefone = -1;

    if ( _idTipoRetornoContato ) *_idTipoRetornoContato = idTipoRetornoContato;
    if ( _inEnvioTelefone ) *_inEnvioTelefone = inEnvioTelefone;

    ULOG("idTipoRetornoContato = %i",idTipoRetornoContato);
    ULOG("inEnvioTelefone = %i",inEnvioTelefone);

    ULOG_END("obtemTipoRetornoAtendimento()");
}

void cRegContatoPC::obtemTipoRetornoAtendimento_11( char * idTipoRetornoPrm )
{
    ULOG_START("obtemTipoRetornoAtendimento_11()");
    
    ULOG( "dados->idTipoRetorno [%d]", dados->idTipoRetorno);
    
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int idTipoComunicacao = dados->idTipoRetorno;

        int idTipoRetornoContato;
        int inEnvioTelefone;

        short i_idTipoRetornoContato = -1;
        short i_inEnvioTelefone = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL
        SELECT
            IDTIPORETORNOCONTATO,
            INENVIOTELEFONE
        INTO
            :idTipoRetornoContato:i_idTipoRetornoContato,
            :inEnvioTelefone:i_inEnvioTelefone
        FROM
            CONTATOADM.FORMARETORNOV01
        WHERE
            IDTIPOCOMUNICACAO = :idTipoComunicacao;

    //if (i_idTipoRetornoContato == -1) idTipoRetornoContato = -1;
    //if (i_inEnvioTelefone == -1) inEnvioTelefone = -1;
    
    if ( i_idTipoRetornoContato != -1)
    {
       sprintf( idTipoRetornoPrm, "%d", idTipoRetornoContato );
    }

    ULOG("idTipoRetornoContato = [%s]",idTipoRetornoPrm);
    
    //if ( _idTipoRetornoContato ) *_idTipoRetornoContato = idTipoRetornoContato;
    //if ( _inEnvioTelefone ) *_inEnvioTelefone = inEnvioTelefone;

    /*
    ULOG("idTipoRetornoContato = %i",idTipoRetornoContato);
    ULOG("inEnvioTelefone = %i",inEnvioTelefone);
    */

    ULOG_END("obtemTipoRetornoAtendimento_11()");
}

//====================================================================================
//==> Incidência 3271 Homologação VIVO, Julho,2006 - Cassio
//
// Esta operação ficou sem uso com a implementação da incidência acima.
//
//====================================================================================
// Busca os tipo de retorno do atendimento.
//====================================================================================
//
// void cRegContatoPC::obtemTipoRetornoTelefone(int* sequencia, int* tipoLinha, int* tipo)
// {
//     ULOG_START("obtemTipoRetornoTelefone()");
// 
//     struct sqlca sqlca;
// 
//     EXEC SQL BEGIN DECLARE SECTION;
// 
//         int idContato       = dados->idContato;
//         int idProcedencia   = dados->idProcedencia;
//         int idCanal         = dados->idCanal;
//         int idTipoCarteira  = dados->idTipoCarteira;
//         int idSegmentacao   = dados->idSegmentacao;
//         int inRespAbertura  = dados->idTipoRelacionamento;
//         int idTipoPessoa    = dados->idTipoPessoa;
//         int idTipoLinha     = *tipoLinha;
//         int idSequencia     = *sequencia;
// 
//         int idTipoRetornoContato=0;
// 
//         short i_idTipoRetornoContato = -1;
// 
//     EXEC SQL END DECLARE SECTION;
// 
//     EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegContatoPC(&sqlca);
// 
//     EXEC SQL
//         SELECT
//             idTipoRetornoContato
//         INTO
//             :idTipoRetornoContato:i_idTipoRetornoContato
//         FROM
//             contatoadm.ParametrosTipoRetornoV01
//         WHERE
//             idContato = :idContato AND
//             idProcedencia = :idProcedencia AND
//             idCanal = :idCanal AND
//             idTipoCarteira = :idTipoCarteira AND
//             idSegmentacao = :idSegmentacao AND
//             idTipoLinha = :idTipoLinha AND
//             idTipoRelacionamento = :inRespAbertura AND
//             idTipoPessoa = :idTipoPessoa AND
//             idSequencia = :idSequencia AND 
//             rownum < 2
//         ORDER BY
//             idTipoRetornoContato DESC;
// 
//     if (i_idTipoRetornoContato == -1)
//         idTipoRetornoContato = 1;
// 
//     *tipo = idTipoRetornoContato;
// 
//     ULOG("Dados obtidos - idTipoRetornoContato = [%i]", idTipoRetornoContato);
// 
//     ULOG_END("obtemTipoRetornoTelefone()");
// }


/**
    Retorna o tipo de retorno que o atendimento terá.
*/
// void cRegContatoPC::obtemPrazoAtendimentoContato(double *_qtHorasPrazoContato,
//                                                  double *_qtHorasPrazoAnatel,
//                                                  int _idContato)
// {
//     ULOG_START("cRegContatoPC::obtemPrazoAtendimentoContato()");
// 
//     struct sqlca sqlca;
// 
//     EXEC SQL BEGIN DECLARE SECTION;
// 
//         int idContato = _idContato;
// 
//         double qtHorasPrazoContato;
//         double qtHorasPrazoAnatel;
// 
//         short i_qtHorasPrazoContato=-1;
//         short i_qtHorasPrazoAnatel = -1;
// 
//     EXEC SQL END DECLARE SECTION;
// 
//     EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca);
//     EXEC SQL WHENEVER NOT FOUND CONTINUE;
// 
//     EXEC SQL
//         SELECT
//             NVL(qtHorasPrazoContato,0) AS qtHorasPrazoContato,
//             NVL(qtHorasPrazoAnatel,0) AS qtHorasPrazoAnatel
//         INTO
//             :qtHorasPrazoContato:i_qtHorasPrazoContato,
//             :qtHorasPrazoAnatel:i_qtHorasPrazoAnatel // prazo de contato prévio
//         FROM
//             contatoadm.ContatoFolha
//         WHERE
//             idContato = :idContato;
// 
//     if ( i_qtHorasPrazoContato == -1 )
//     {
//         qtHorasPrazoContato = qtHorasPrazoAnatel = -1;
//     }
// 
//     *_qtHorasPrazoContato = qtHorasPrazoContato;
//     *_qtHorasPrazoAnatel = qtHorasPrazoAnatel;
// 
//     ULOG("Dados obtidos - qtHorasPrazoContato = ["MASCFLOAT"]", qtHorasPrazoContato);
//     ULOG("Dados obtidos - qtHorasPrazoAnatel = ["MASCFLOAT"]", qtHorasPrazoAnatel);
// 
//     ULOG_END("cRegContatoPC::obtemPrazoAtendimentoContato()");
// }

void cRegContatoPC::obterDadosContatoFolha(st_RegContato *dados)
{
    ULOG_START("cRegContatoPC::obterDadosContatoFolha()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int varOraIdContato = dados->idContato;

        int varOraIdAgrupamentoEstadoTpProc;
        int varOraInSMS;

        double varOraQtHorasPrazoContato;
        double varOraQtHorasPrazoAnatel;

        VARCHAR varOraDsClassificacaoSMS[256];
        VARCHAR varOraSgRegraEncaminhamento[4];
        VARCHAR varOraSgFluxoAtendimento[4];

        short statOraQtHorasPrazoContato=-1;
        short statOraQtHorasPrazoAnatel = -1;
        short statOraIdAgrupamentoEstadoTpProc = -1;
        short statOraDsClassificacaoSMS = -1;

        short statOraSgRegraEncaminhamento=-1;
        short statOraSgFluxoAtendimento=-1;


    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL
        SELECT
            AGRUPAMENTOESTADOTPPROC.IDAGRUPAMENTOESTADOTPPROC,
            NVL(CONTATOFOLHA.QTHORASPRAZOCONTATO,0) AS QTHORASPRAZOCONTATO,
            NVL(CONTATOFOLHA.QTHORASPRAZOANATEL,0) AS QTHORASPRAZOANATEL,
            CONTATOFOLHA.INSMS,
            CLASSIFICACAOSMS.DSCLASSIFICACAOSMS,
            CONTATOFOLHA.SGREGRAENCAMINHAMENTO,
            CONTATOFOLHA.SGFLUXOATENDIMENTO
        INTO
            :varOraIdAgrupamentoEstadoTpProc:statOraIdAgrupamentoEstadoTpProc,
            :varOraQtHorasPrazoContato:statOraQtHorasPrazoContato,
            :varOraQtHorasPrazoAnatel:statOraQtHorasPrazoAnatel,
            :varOraInSMS,
            :varOraDsClassificacaoSMS:statOraDsClassificacaoSMS,
            :varOraSgRegraEncaminhamento:statOraSgRegraEncaminhamento,
            :varOraSgFluxoAtendimento:statOraSgFluxoAtendimento
        FROM
            CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
            WORKFLOW.AGRUPAMENTOESTADOTPPROC AGRUPAMENTOESTADOTPPROC,
            APOIO.CLASSIFICACAOSMS CLASSIFICACAOSMS
        WHERE
            CONTATOFOLHA.IDCONTATO = :varOraIdContato
        AND CONTATOFOLHA.IDTIPOPROCESSO = AGRUPAMENTOESTADOTPPROC.IDTIPOPROCESSO 
        AND AGRUPAMENTOESTADOTPPROC.INESTADOINICIAL = 1
        AND CONTATOFOLHA.IDCLASSIFICACAOSMS = CLASSIFICACAOSMS.IDCLASSIFICACAOSMS (+)
        AND ROWNUM < 2;

    if ( strcmp(dados->sgTipoPortabilidade,"PORTOUT")==0 )
    {
        EXEC SQL
            SELECT
                IDAGRUPAMENTOESTADOTPPROC
            INTO
                :varOraIdAgrupamentoEstadoTpProc:statOraIdAgrupamentoEstadoTpProc
            FROM
                WORKFLOW.AGRUPAMENTOESTADOTPPROC 
            WHERE
                INESTADOINICIAL = 1
            AND IDTIPOPROCESSO = 3 // Processo de portout
            AND ROWNUM < 2;
    }

    if (statOraIdAgrupamentoEstadoTpProc == -1)
        varOraIdAgrupamentoEstadoTpProc = -1;

    if ( statOraQtHorasPrazoContato == -1 )
        varOraQtHorasPrazoContato = varOraQtHorasPrazoAnatel = -1;

    CONVIND(varOraDsClassificacaoSMS,statOraDsClassificacaoSMS);
    CONVIND(varOraSgRegraEncaminhamento,statOraSgRegraEncaminhamento);
    CONVIND(varOraSgFluxoAtendimento,statOraSgFluxoAtendimento);

    dados->idAgrupamentoEstadoTpProc = varOraIdAgrupamentoEstadoTpProc;
    dados->horas = varOraQtHorasPrazoContato;
    dados->horasRC = varOraQtHorasPrazoAnatel;
    dados->inSMS = varOraInSMS;
    strcpy(dados->dsClassificacaoSMS,(char*)varOraDsClassificacaoSMS.arr);
    strcpy(dados->sgRegraEncaminhamento,(char*)varOraSgRegraEncaminhamento.arr);
    strcpy(dados->sgFluxoAtendimento,(char*)varOraSgFluxoAtendimento.arr);

    ULOG("                 idContato=%d",varOraIdContato);
    ULOG("       qtHorasPrazoContato="MASCFLOAT,varOraQtHorasPrazoContato);
    ULOG("        qtHorasPrazoAnatel="MASCFLOAT,varOraQtHorasPrazoAnatel);
    ULOG("                     inSMS=%d",varOraInSMS);
    ULOG("        dsClassificacaoSMS='%s'",varOraDsClassificacaoSMS.arr);
    ULOG(" idAgrupamentoEstadoTpProc=%d",varOraIdAgrupamentoEstadoTpProc);
    ULOG("                       ddd=%d",dados->cdAreaRegistro);
    ULOG("     sgRegraEncaminhamento='%s'",varOraSgRegraEncaminhamento.arr);
    ULOG("        sgFluxoAtendimento='%s'",varOraSgFluxoAtendimento.arr);

    ULOG_END("cRegContatoPC::obterDadosContatoFolha()");
}

/**
    Obtem os dados a respeito da conta.
*/
bool cRegContatoPC::obtemDadosConta(int* idConta, char* conta, char* digitoConta)
{
    ULOG_START("cRegContatoPC::obtemDadosConta()");

    bool retorno = false;
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        int idconta = *idConta;

        VARCHAR cdConta[101];
        VARCHAR cdDigitoConta[256];

        short i_cdConta = -1;
        short i_cdDigitoConta = -1;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL
        SELECT 
            CDCONTA, 
            CDDIGITOCONTA
        INTO
            cdConta:i_cdConta,
            cdDigitoConta:i_cdDigitoConta
        FROM 
            CUSTOMER.CONTA
        WHERE
            IDCONTA = :idconta;

    if ( !sqlca.sqlcode )
    {
        CONVIND(cdConta,i_cdConta);
        CONVIND(cdDigitoConta,i_cdDigitoConta);

        strcpy(conta,(char*)cdConta.arr);
        strcpy(digitoConta,(char*)cdDigitoConta.arr);

        retorno = true;
    }

    ULOG_END("cRegContatoPC::obtemDadosConta()");

    return retorno;
}
 
/** 
    Obtem o idTipoPessoa 
*/ 
void cRegContatoPC::obtemIdTipoPessoa(int* _idTipoPessoa,char *_inTipoPessoa) 
{ 
    ULOG_START("cRegContatoPC::obtemIdTipoPessoa()"); 
 
    struct sqlca sqlca; 
 
    EXEC SQL BEGIN DECLARE SECTION; 
 
        char *inTipoPessoa = _inTipoPessoa; 
 
        int idTipoPessoa = 0; 
        short i_idTipoPessoa = -1; 
 
    EXEC SQL END DECLARE SECTION; 
 
    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegContatoPC(&sqlca); 
 
    EXEC SQL 
        SELECT  
            IDTIPOPESSOA 
        INTO 
            idTipoPessoa:i_idTipoPessoa 
        FROM  
            APOIO.TIPOPESSOA 
        WHERE 
            SGTIPOPESSOA = :inTipoPessoa; 
 
    if (i_idTipoPessoa == -1) 
    { 
        ULOG("Tipo de pessoa nao encontrado, assumindo tipo default."); 
        idTipoPessoa = 1; 
    } 
 
    *_idTipoPessoa = idTipoPessoa; 
 
    ULOG("idTipoPessoa = [%d]",idTipoPessoa); 
 
    ULOG_END("cRegContatoPC::obtemIdTipoPessoa()"); 
} 
 
/** 
    Obtém parâmetros de portabilidade 
*/ 
int cRegContatoPC::obterGrupoTratamentoPortout(const char *sgTipoPortabilidade,const char *dsAcaoPortabilidade) 
{ 
    ULOG_START("cRegContatoPC::obterGrupoTratamentoPortout()"); 
 
    struct sqlca sqlca; 
 
    EXEC SQL BEGIN DECLARE SECTION; 
        const char *pOraSgTipoPortabilidade = sgTipoPortabilidade; 
        const char *pOraDsAcaoPortabilidade = dsAcaoPortabilidade; 
        int idGrupoTratamento; 
        short i_idGrupoTratamento; 
 
    EXEC SQL END DECLARE SECTION; 
 
    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca); 
    EXEC SQL WHENEVER NOT FOUND CONTINUE; 
 
    EXEC SQL 
        SELECT  
            IDGRUPOTRATAMENTO 
        INTO 
            :idGrupoTratamento:i_idGrupoTratamento 
        FROM  
            CONTATOADM.CONTATOFUNCIONALIDADE 
        WHERE 
            CDFUNCIONALIDADE = UPPER(:pOraSgTipoPortabilidade||'_'||:pOraDsAcaoPortabilidade);
 
    if ( 0 == sqlca.sqlcode ) 
    { 
        ULOG("idGrupoTratamento = %d",idGrupoTratamento); 
    } 
    else 
    { 
        ULOG("idGrupoTratamento NAO ENCONTRADO"); 
    } 
 
    ULOG_END("cRegContatoPC::obterGrupoTratamentoPortout()"); 
 
    return sqlca.sqlcode == 0 ? idGrupoTratamento : -1; 
} 
 
/** 
    Obtém o idContato 
*/ 
int cRegContatoPC::obtemIdContato(char *nmPath) 
{ 
    ULOG_START("cRegContatoPC::obtemIdContato()"); 
 
    struct sqlca sqlca; 
 
    EXEC SQL BEGIN DECLARE SECTION; 
 
        char *nmPathOra = nmPath; 
        int idContato; 
 
    EXEC SQL END DECLARE SECTION; 
 
    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca); 
    EXEC SQL WHENEVER NOT FOUND CONTINUE; 
 
    ULOG("path '%s'",nmPathOra); 
 
    EXEC SQL 
        SELECT  
            CONTATO.IDCONTATO 
        INTO 
            :idContato 
        FROM  
            CONTATOADM.CONTATO CONTATO,
            CONTATOADM.CONTATOFOLHA CONTATOFOLHA
        WHERE 
            CONTATO.NMPATH = :nmPathOra
        AND CONTATO.IDCONTATO = CONTATOFOLHA.IDCONTATO;
 
    if ( 0 == sqlca.sqlcode ) 
    { 
        ULOG("idContato = %d",idContato); 
    } 
    else 
    { 
        ULOG("idContato NAO ENCONTRADO"); 
    } 
 
    ULOG_END("cRegContatoPC::obtemIdContato()"); 
 
    return sqlca.sqlcode == 0 ? idContato : -1; 
} 

/**
    Grava o historico de portabilidade
*/
void cRegContatoPC::gravaPessoaPortabilidadeHist(int idUsuarioAlteracao, 
                                                 int idPessoaDePara, 
                                                 int idTipoLinha, 
                                                 int cdAreaRegistro, 
                                                 const char *nrTelefone, 
                                                 const char *sgTipoPortabilidade,
                                                 const char *dsAcaoPortabilidade,
                                                 const char *dsObservacao,
                                                 const char *sgOperadoraSolicitante,
                                                 const char *nrProtocoloPortabilidade,
                                                 const char *dtJanelaPortout)
{
    ULOG_START("cRegContatoPC::gravaPessoaPortabilidadeHist()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION; 
 
        int varOraCdAreaRegistro = cdAreaRegistro; 
        long varOraIdPessoa=0; 
        int varOraIdPessoaDePara = idPessoaDePara; 
        int varOraIdTipoDocumento=0; 
        int varOraIdTipoEndereco=0; 
        int varOraIdTipoLinha = idTipoLinha;
        int varOraIdTipoPessoa=0; 
        int varOraIdUsuarioAlteracao = idUsuarioAlteracao; 
		int varOraIPUP=0;
		int varOraQtdiasPUP=0;
		int varOraGravaPUP=0;
 
        VARCHAR varOraNmBairro[256];
        VARCHAR varOraNmLogradouro[256];
        VARCHAR varOraNmMunicipio[256];
        VARCHAR varOraNmPessoa[256];
        VARCHAR varOraNmTipoLogradouro[256];
        VARCHAR varOraNrCep[256];
        VARCHAR varOraNrDocumento[256];
        VARCHAR varOraNrEndereco[256];

        const char *varOraNrLinha = nrTelefone+2;
        const char *varOraSgTipoPortabilidade = sgTipoPortabilidade;
        const char *varOraDsAcaoPortabilidade = dsAcaoPortabilidade;

        const char *varOraDsObservacao = dsObservacao;
        const char *varOraSgOperadoraSolicitante = sgOperadoraSolicitante;
        const char *varOraNrProtocoloPortabilidade = nrProtocoloPortabilidade;
        const char *varOraDtJanelaPortout = dtJanelaPortout;

        short varStatOraCdAreaRegistro = varOraCdAreaRegistro>0?1:-1;
        short varStatOraIdPessoa = -1;
        short varStatOraIdPessoaDePara = -1;
        short varStatOraIdTipoDocumento = -1;
        short varStatOraIdTipoEndereco = -1;
        short varStatOraIdTipoLinha = 0;
        short varStatOraIdTipoPessoa = -1;
        short varStatOraIdUsuarioAlteracao = 0;
        short varStatOraNmBairro = -1;
        short varStatOraNmLogradouro = -1;
        short varStatOraNmMunicipio = -1;
        short varStatOraNmPessoa = -1;
        short varStatOraNmTipoLogradouro = -1;
        short varStatOraNrCep = -1;
        short varStatOraNrDocumento = -1;
        short varStatOraNrEndereco = -1;
        short varStatOraNrLinha = 0;
        short varStatOraSgTipoPortabilidade = 0;
        short varStatOraDsAcaoPortabilidade = 0;
        short varStatOraDsObservacao = *dsObservacao ? 0 : -1;
        short varStatOraSgOperadoraSolicitante = *sgOperadoraSolicitante ? 0 : -1;
        short varStatOraNrProtocoloPortabilidade = *nrProtocoloPortabilidade ? 0 : -1;
        short varStatOraDtJanelaPortout = *dtJanelaPortout ? 0 : -1;

    EXEC SQL END DECLARE SECTION;

    // 
    //================================================================ 
    // Inicializa

    memset(&varOraNmBairro,0,sizeof(varOraNmBairro));
    memset(&varOraNmLogradouro,0,sizeof(varOraNmLogradouro));
    memset(&varOraNmMunicipio,0,sizeof(varOraNmMunicipio));
    memset(&varOraNmPessoa,0,sizeof(varOraNmPessoa));
    memset(&varOraNmTipoLogradouro,0,sizeof(varOraNmTipoLogradouro));
    memset(&varOraNrCep,0,sizeof(varOraNrCep));
    memset(&varOraNrDocumento,0,sizeof(varOraNrDocumento));
    memset(&varOraNrEndereco,0,sizeof(varOraNrEndereco));

    // 
    //================================================================ 
    // Tipo da linha default (caso não fornecido)
 
    if ( 0 == varOraIdTipoLinha )
    {
        ULOG("vai buscar idTipoLinha 'NÃO CLASSIFICADO' em APOIO.TIPOLINHA"); 
    
        EXEC SQL 
            SELECT
                IDTIPOLINHA
            INTO
                :varOraIdTipoLinha:varStatOraIdTipoLinha
            FROM
                APOIO.TIPOLINHA
            WHERE
                DSTIPOLINHA = 'NÃO CLASSIFICADO';
    }

    // 
    //================================================================ 
    // Dados da pessoa 

    ULOG("vai buscar dados para idPessoaDePara=%d",varOraIdPessoaDePara); 

    EXEC SQL 
        SELECT 
            PESSOA.IDPESSOA, 
            PESSOA.NMPESSOA, 
            PESSOA.IDTIPOPESSOA 
        INTO 
            :varOraIdPessoa:varStatOraIdPessoa, 
            :varOraNmPessoa:varStatOraNmPessoa, 
            :varOraIdTipoPessoa:varStatOraIdTipoPessoa 
        FROM 
            CUSTOMER.PESSOA PESSOA, 
            CUSTOMER.PESSOADEPARA PESSOADEPARA 
        WHERE 
            PESSOADEPARA.IDPESSOADEPARA = :varOraIdPessoaDePara 
        AND PESSOADEPARA.IDPESSOA = PESSOA.IDPESSOA; 

    if ( sqlca.sqlcode ) 
    { 
        ULOGW("idPessoa não encontrado para o processo"); 
        ULOG_END("cRegContatoPC::gravaPessoaPortabilidadeHist()"); 
        return; 
    } 

    CONVIND(varOraNmPessoa,varStatOraNmPessoa); 

    // 
    //================================================================ 
    // Documento da pessoa 

    ULOG("vai buscar documento para idPessoa=%ld",varOraIdPessoa); 

    EXEC SQL 
        SELECT 
            IDTIPODOCUMENTO, 
            NRDOCUMENTO 
        INTO 
            :varOraIdTipoDocumento:varStatOraIdTipoDocumento, 
            :varOraNrDocumento:varStatOraNrDocumento 
        FROM 
            ( 
                SELECT 
                    DOCUMENTO.IDTIPODOCUMENTO, 
                    DOCUMENTO.NRDOCUMENTO 
                FROM 
                    CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO, 
                    CUSTOMER.DOCUMENTO DOCUMENTO, 
                    APOIO.TIPODOCUMENTO TIPODOCUMENTO 
                WHERE 
                    PESSOADOCUMENTO.IDPESSOA = :varOraIdPessoa 
                AND PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO 
                AND DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO 
                ORDER BY 
                    TIPODOCUMENTO.NRPRIORIDADE 
            ) 
        WHERE 
            ROWNUM < 2; 

    CONVIND(varOraNrDocumento,varStatOraNrDocumento); 

    // 
    //================================================================ 
    // Documento da pessoa 
 
    ULOG("vai buscar endereço para idPessoa=%ld",varOraIdPessoa); 
 
    EXEC SQL 
        SELECT 
            IDTIPOENDERECO, 
            NMTIPOLOGRADOURO, 
            NMLOGRADOURO, 
            NRENDERECO, 
            NMMUNICIPIO, 
            NMBAIRRO, 
            NRCEP 
        INTO 
            :varOraIdTipoEndereco:varStatOraIdTipoEndereco, 
            :varOraNmTipoLogradouro:varStatOraNmTipoLogradouro, 
            :varOraNmLogradouro:varStatOraNmLogradouro, 
            :varOraNrEndereco:varStatOraNrEndereco, 
            :varOraNmMunicipio:varStatOraNmMunicipio, 
            :varOraNmBairro:varStatOraNmBairro, 
            :varOraNrCep:varStatOraNrCep 
        FROM 
            ( 
                SELECT 
                    NRSEQUENCIA, 
                    INENDERECOPREFERENCIAL,  
                    IDTIPOENDERECO, 
                    NMTIPOLOGRADOURO, 
                    NMLOGRADOURO, 
                    NRENDERECO, 
                    NMMUNICIPIO, 
                    NMBAIRRO, 
                    NRCEP 
                FROM 
                    CUSTOMER.PESSOAENDERECO  
                WHERE 
                    IDPESSOA = :varOraIdPessoa 
                ORDER BY 
                    NVL(INENDERECOPREFERENCIAL,0) DESC,NRSEQUENCIA 
            ) 
        WHERE 
            ROWNUM < 2; 
 
    CONVIND(varOraNmTipoLogradouro,varStatOraNmTipoLogradouro); 
    CONVIND(varOraNmLogradouro,varStatOraNmLogradouro); 
    CONVIND(varOraNrEndereco,varStatOraNrEndereco); 
    CONVIND(varOraNmMunicipio,varStatOraNmMunicipio); 
    CONVIND(varOraNmBairro,varStatOraNmBairro); 
    CONVIND(varOraNrCep,varStatOraNrCep); 

    // 
    //================================================================ 
    // Insere o histórico 

    ULOG("vai inserir no historico de portabilidade...");

    ULOG("             idTipoLinha=%+d:%d",varStatOraIdTipoLinha,varOraIdTipoLinha);
    ULOG("          cdAreaRegistro=%+d:%d",varStatOraCdAreaRegistro,varOraCdAreaRegistro);
    ULOG("                 nrLinha=%+d:%s",varStatOraNrLinha,varOraNrLinha);
    ULOG("            idTipoPessoa=%+d:%d",varStatOraIdTipoPessoa,varOraIdTipoPessoa);
    ULOG("                nmPessoa=%+d:%s",varStatOraNmPessoa,varOraNmPessoa.arr);
    ULOG("         idTipoDocumento=%+d:%d",varStatOraIdTipoDocumento,varOraIdTipoDocumento);
    ULOG("             nrDocumento=%+d:%s",varStatOraNrDocumento,varOraNrDocumento.arr);
    ULOG("          idTipoEndereco=%+d:%s",varStatOraIdTipoEndereco,varOraIdTipoEndereco);
    ULOG("        nmTipoLogradouro=%+d:%s",varStatOraNmTipoLogradouro,varOraNmTipoLogradouro.arr);
    ULOG("            nmLogradouro=%+d:%s",varStatOraNmLogradouro,varOraNmLogradouro.arr);
    ULOG("              nrEndereco=%+d:%s",varStatOraNrEndereco,varOraNrEndereco.arr);
    ULOG("             nmMunicipio=%+d:%s",varStatOraNmMunicipio,varOraNmMunicipio.arr);
    ULOG("                nmBairro=%+d:%s",varStatOraNmBairro,varOraNmBairro.arr);
    ULOG("                   nrCep=%+d:%s",varStatOraNrCep,varOraNrCep.arr);
    ULOG("      idUsuarioAlteracao=%+d:%d",varStatOraIdUsuarioAlteracao,varOraIdUsuarioAlteracao);
    ULOG("     sgTipoPortabilidade=%+d:%s",varStatOraSgTipoPortabilidade,varOraSgTipoPortabilidade);
    ULOG("     dsAcaoPortabilidade=%+d:%s",varStatOraDsAcaoPortabilidade,varOraDsAcaoPortabilidade);
    ULOG("            dsObservacao=%+d:%s",varStatOraDsObservacao,varOraDsObservacao);
    ULOG("  sgOperadoraSolicitante=%+d:%s",varStatOraSgOperadoraSolicitante,varOraSgOperadoraSolicitante);
    ULOG("nrProtocoloPortabilidade=%+d:%s",varStatOraNrProtocoloPortabilidade,varOraNrProtocoloPortabilidade);
    ULOG("         dtJanelaPortout=%+d:%s",varStatOraDtJanelaPortout,varOraDtJanelaPortout);

    EXEC SQL
        INSERT INTO CUSTOMER.PESSOAPORTABILIDADEHIST 
            (IDPESSOAPORTABILIDADEHIST 
            ,IDTIPOLINHA 
            ,CDAREAREGISTRO 
            ,NRLINHA 
            ,IDTIPOPESSOA 
            ,NMPESSOA 
            ,IDTIPODOCUMENTO 
            ,NRDOCUMENTO 
            ,IDTIPOENDERECO 
            ,NMTIPOLOGRADOURO 
            ,NMLOGRADOURO 
            ,NRENDERECO 
            ,NMMUNICIPIO 
            ,NMBAIRRO 
            ,NRCEP 
            ,IDUSUARIOALTERACAO 
            ,DSACAOPORTABILIDADE 
            ,SGTIPOPORTABILIDADE
            ,DSOBSERVACAO
            ,SGOPERADORASOLICITANTE
            ,NRPROTOCOLOPORTABILIDADE
            ,DTJANELAPORTOUT)
        VALUES 
            (PESSOAPORTABILIDADEHISTSQ.NEXTVAL 
            ,:varOraIdTipoLinha:varStatOraIdTipoLinha 
            ,:varOraCdAreaRegistro:varStatOraCdAreaRegistro 
            ,:varOraNrLinha:varStatOraNrLinha 
            ,:varOraIdTipoPessoa:varStatOraIdTipoPessoa 
            ,:varOraNmPessoa:varStatOraNmPessoa 
            ,:varOraIdTipoDocumento:varStatOraIdTipoDocumento 
            ,:varOraNrDocumento:varStatOraNrDocumento 
            ,:varOraIdTipoEndereco:varStatOraIdTipoEndereco 
            ,:varOraNmTipoLogradouro:varStatOraNmTipoLogradouro 
            ,:varOraNmLogradouro:varStatOraNmLogradouro 
            ,:varOraNrEndereco:varStatOraNrEndereco 
            ,:varOraNmMunicipio:varStatOraNmMunicipio 
            ,:varOraNmBairro:varStatOraNmBairro 
            ,:varOraNrCep:varStatOraNrCep 
            ,:varOraIdUsuarioAlteracao:varStatOraIdUsuarioAlteracao 
            ,:varOraDsAcaoPortabilidade:varStatOraDsAcaoPortabilidade
            ,:varOraSgTipoPortabilidade:varStatOraSgTipoPortabilidade
            ,:varOraDsObservacao:varStatOraDsObservacao
            ,:varOraSgOperadoraSolicitante:varStatOraSgOperadoraSolicitante
            ,:varOraNrProtocoloPortabilidade:varStatOraNrProtocoloPortabilidade
            ,TO_DATE(:varOraDtJanelaPortout:varStatOraDtJanelaPortout,'DDMMYYYYHH24MISS')
            );

		   try //apenas para garantir :)
		   {
		    //TIAGO COSTA MPOG
			//a regra de portabilidade esta muito ruim...
			//alem disto fazendo da maneira + for dummies que existe
			//estou deixando explicito o que deve ser feito...
			//int varOraIPUP
			//int varOraQtdiasPUP=0;
			//int varOraGravaPUP=0;
			//SE AÇÃO IGUAL A PORTIN
			 ULOG("TRY...");
				if(!strcmp(varOraSgTipoPortabilidade,"PORTIN"))
				{
					//valida as ações de portabilidade
					//'Aguardando Autorização' ou 'Reagendamento Automático'
					if(!strcmp(varOraDsAcaoPortabilidade,"Aguardando Autorização")||!strcmp(varOraDsAcaoPortabilidade,"Reagendamento Automático"))
					{
						ULOG("VarOraQtdiasPUP=30...");
						varOraGravaPUP=1;
						varOraQtdiasPUP=30;//NUMERO DE DIAS 30 + DATA DA JANELA
						
					}//if ações de portabilidade portin

				}//SE FOR PORTOUT
				else if(!strcmp(varOraSgTipoPortabilidade,"PORTOUT"))
				{
					//VALIDA AÇÃO AGUARDANDO JANELA....
					if(!strcmp(varOraDsAcaoPortabilidade,"Aguardando Janela"))
					{
						varOraGravaPUP=1;
						ULOG("varOraQtdiasPUP=9999");
						varOraQtdiasPUP=9999;//NUMERO DE DIAS =9999 + DATA DA JANELA
					}
				
				}
				//processa pup realmente
				if(varOraGravaPUP==1) //explicitamente comparando com 1
				{
					ULOG("varOraGravaPUP==1");
					EXEC SQL
							SELECT COUNT(1) 
							INTO	:varOraIPUP
							FROM linha.LINHAPUP
							WHERE CDAREAREGISTRO=:varOraCdAreaRegistro
							and   NRLINHA		=:varOraNrLinha;

						if(varOraIPUP==0) //NAO EXISTE NA PUP AINDA explicito
						{
							ULOG("varOraIPUP==0");
						 EXEC SQL
							INSERT INTO LINHA.LINHAPUP (CDAREAREGISTRO,
														NRLINHA,
														DTCADASTROPUP,
														IDUSUARIOCADASTROPUP)
											VALUES(:varOraCdAreaRegistro:varStatOraCdAreaRegistro,
												   :varOraNrLinha:varStatOraNrLinha,
												   sysdate,
												  :varOraIdUsuarioAlteracao:varStatOraIdUsuarioAlteracao);

						 EXEC SQL
							insert into linha.PERMISSAOLINHAPUP              
							SELECT :varOraCdAreaRegistro:varStatOraCdAreaRegistro,
								   :varOraNrLinha:varStatOraNrLinha,
								   P.SGPERMISSAOPUP,
								   0,
								   TO_DATE(:varOraDtJanelaPortout:varStatOraDtJanelaPortout,'DDMMYYYYHH24MISS')+:varOraQtdiasPUP,
								   :varOraIdUsuarioAlteracao:varStatOraIdUsuarioAlteracao,
								   SYSDATE,
								   P.IDLINHATELEFONICA,
								   P.INPROCON,
								   P.IDSISTEMAORIGEM,
								   P.IDCANAL
							FROM LINHA.PERMISSAOPUP P
							WHERE SGPERMISSAOPUP = 'PERCONT';
						}
						else //existe na PUP
						{
							ULOG("ELSE existe na PUP");

							//----------------------PERCONT
							EXEC SQL
							update linha.permissaolinhapup
							set    inativo=0,
							   dtexpiracao=TO_DATE(:varOraDtJanelaPortout,'DDMMYYYYHH24MISS')+:varOraQtdiasPUP,
							   idusuarioalteracao=:varOraIdUsuarioAlteracao
							where SGPERMISSAOPUP='PERCONT'
							AND CDAREAREGISTRO=:varOraCdAreaRegistro
							AND   NRLINHA=:varOraNrLinha;

							if(sqlca.sqlerrd[2] == 0)
							{
								EXEC SQL
								Insert into LINHA.PERMISSAOLINHAPUP (CDAREAREGISTRO,
																	NRLINHA,
																	SGPERMISSAOPUP,
																	INATIVO,
																	DTEXPIRACAO,
																	IDUSUARIOALTERACAO,
																	DTULTIMAALTERACAO,
																	INPROCON)
										 Values
													(:varOraCdAreaRegistro:varStatOraCdAreaRegistro,
													:varOraNrLinha:varStatOraNrLinha,
													'PERCONT',
													0,
													TO_DATE(:varOraDtJanelaPortout,'DDMMYYYYHH24MISS')+:varOraQtdiasPUP,
													:varOraIdUsuarioAlteracao,
													sysdate,
													0);

							}
							//----------------------PERCONT

						}//else if existe pup
					}//fim varOraGravaPUP==1

		  }//try
		  catch(...)
		  {
			  ULOG("nao é pra dar erro, mas as veiz faia...");
		  }

    ULOG_END("cRegContatoPC::gravaPessoaPortabilidadeHist()");
}
 
/** 
    Registra o atendimento na tabela de priorizacao. 
*/ 
void cRegContatoPC::registraTabelaPriorizacao(int _idTipoReabertura 
                                             //,int _idLinhaTelefonica 
                                             ,int _idTipoPessoa 
                                             //,int _idUFOperadora 
                                             //,int _idTipoLinha 
                                             ,st_Atendimento *dadosAtendimento 
                                             ,st_vlAtendimento *statusAtendimento 
                                             ,st_AtendimentoPessoa *dadosAtendimentoPessoa 
                                             ,st_vlAtendimentoPessoa *statusAtendimentoPessoa 
                                             //,st_AtendimentoLinha *dadosAtendimentoLinha 
                                             //,st_vlAtendimentoLinha *statusAtendimentoLinha 
                                             ) 
{ 
    ULOG_START("cRegContatoPC::registraTabelaPriorizacao()"); 
 
    struct sqlca sqlca; 
 
    EXEC SQL BEGIN DECLARE SECTION; 
        struct 
        { 
            struct st_Atendimento *dadosAtd; 
            char *peso; 
            int idAlerta; 
            int idAtividade; 
            VARCHAR nmCor[256]; 
            VARCHAR dtReabertura[21+1]; 
            int idPessoaDePara; 
            int idTipoRelacionamento; 
            int idTipoPessoa; 
        } oDados; 
 
        struct 
        { 
            struct st_vlAtendimento *statusAtd; 
            short peso; 
            short idAtividade; 
            short idAlerta; 
            short nmCor; 
            short dtReabertura; 
            short idPessoaDePara; 
            short idTipoRelacionamento; 
            short idTipoPessoa; 
        } oStatus; 
 
        struct 
        { 
            long idPessoa; 
            int idDocumento; 
        } oDadosDocumentoProcesso; 
 
        struct 
        { 
            short idPessoa; 
            short idDocumento; 
        } oStatusDocumentoProcesso; 
 
        VARCHAR nrAtendimentoAgrupado[39];
        short i_nrAtendimentoAgrupado;
        int iCount;
 
    EXEC SQL END DECLARE SECTION; 
   
    memset(&sqlca, 0, sizeof(sqlca)); 
    
    memset(&oDados.dtReabertura,0, sizeof(oDados.dtReabertura)); 
    oStatus.dtReabertura = -1; 
 
    memset(&oDados.nmCor,0, sizeof(oDados.nmCor)); 
    oStatus.nmCor = -1; 
 
    oDados.idAlerta = 0; 
    oStatus.idAlerta = -1; 
 
    oDados.dadosAtd = dadosAtendimento; 
    oStatus.statusAtd = statusAtendimento; 
 
    oDados.idPessoaDePara = dadosAtendimentoPessoa->idPessoaDePara; 
    oStatus.idPessoaDePara = statusAtendimentoPessoa->idPessoaDePara; 
 
    oDados.idTipoRelacionamento = dadosAtendimentoPessoa->idTipoRelacionamento; 
    oStatus.idTipoRelacionamento = statusAtendimentoPessoa->idTipoRelacionamento; 
 
    oDados.idTipoPessoa = _idTipoPessoa; 
    oStatus.idTipoPessoa = 1; 
 
    oDados.peso = oDados.dadosAtd->vlPesoAtendimento; 
    if ( atol(oDados.peso) < 0 ) oDados.peso = "1"; 
    oStatus.peso = 1; 
 
    if (_idTipoReabertura == 3) { oDados.idAtividade = 12; } 
    else if (_idTipoReabertura == 2) { oDados.idAtividade = 15; } 
    else { oDados.idAtividade = 0; } 
    oStatus.idAtividade = 1; 
 
    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca); 
    EXEC SQL WHENEVER NOT FOUND CONTINUE; 
 
    ULOG("Obtendo Alerta..."); 
 
    EXEC SQL  
        SELECT  
            al.nmCor, 
            al.idAlerta 
        INTO  
            :oDados.nmCor:oStatus.nmCor, 
            :oDados.idAlerta:oStatus.idAlerta 
        FROM  
            workflow.Alerta al, 
            workflow.AtividadeAlerta a 
        WHERE  
            a.idAlerta = al.idAlerta 
        AND a.idAtividade = :oDados.idAtividade; 
     
    CONVIND(oDados.nmCor,oStatus.nmCor); 
 
    // Pesquisa a data primeira abertura processo sendo criado 
    ULOG("Vai pesquisar a data da primeira abertura do processo"); 
      
     EXEC SQL 
        SELECT 
            TO_CHAR(A.DTABERTURA,'DD/MM/YYYY HH24:MI:SS') AS DTABERTURA 
        INTO  
            :oDados.dtReabertura:oStatus.dtReabertura 
        FROM  
            ATENDIMENTO.ATENDIMENTO A 
        WHERE  
            A.IDATENDIMENTO =  
            ( 
                SELECT 
                    IDATENDIMENTOORIGEM 
                FROM 
                ( 
                    SELECT 
                        NIVEL,IDATENDIMENTOORIGEM 
                    FROM 
                    ( 
                        SELECT 
                            AO.IDATENDIMENTOORIGEM,LEVEL AS NIVEL 
                        FROM 
                            ATENDIMENTO.ATENDIMENTOORIGEM AO 
                        START WITH 
                            AO.IDATENDIMENTO = :oDados.dadosAtd->idAtendimento 
                        CONNECT BY PRIOR 
                            AO.IDATENDIMENTOORIGEM = AO.IDATENDIMENTO 
                    ) 
                    ORDER BY NIVEL DESC 
                ) 
                WHERE ROWNUM < 2 
            ); 
 
    if ( (char*)oDados.dtReabertura.len > 0 ) 
    { 
        ULOG("dtReabertura [%s]", (char*)oDados.dtReabertura.arr); 
    } 
    else 
    { 
        ULOG("data de primeira abertura não localizada"); 
    } 
     
    ULOG("Inserindo processo %d em AtendimentoPriorizacao",oDados.dadosAtd->idAtendimento); 
    
    EXEC SQL 
        INSERT INTO 
            atendimento.AtendimentoPriorizacao 
            ( 
                idAtendimento, 
                dtAbertura, 
                idContato, 
                dtPrazoFinalInterno, 
                qtInsistencia, 
                inAlarme, 
                idCanal, 
                idProcedencia, 
                idTipoCarteira, 
                idSegmentacao, 
                idPessoaUsuarioAbertura,  
                idGrupoAbertura, 
                dtPrazoFinalAnatel, 
                nrNivel, 
                idFase, 
                qtHorasPrazoAtendimento, 
                vlPesoAtendimento, 
                idTipoRetornoContato, 
                idUsuarioAlteracao, 
                dtUltimaAlteracao, 
                dtPrazoFinalCPrevio, 
                idTipoAbertura, 
                nrCriticidade, 
                nmCor, 
                idPessoaDePara, 
                idPessoaLinhaHistorico, 
                idTipoRelacionamento, 
                idLinhaTelefonica, 
                idTipoPessoa, 
                idUFOperadora, 
                idTipoLinha, 
                dtAtualizacao, 
                idAlerta, 
                dtReabertura, 
                cdAreaRegistro, 
                idAgrupamentoEstadoTpProc, 
                idAndamentoAtual, 
                idGrupoAnterior, 
                idGrupoAtual, 
                idPessoaUsuarioAnterior, 
                idPessoaUsuarioAtual, 
                idEstadoLinha, 
                idPessoaConta, 
                idAtendimentoProtocolo, 
                sgTipoPortabilidade, 
                sgOperadoraSolicitante, 
                nrProtocoloPortabilidade, 
                dtJanelaPortout, 
                dtUltimaOperacaoExcFila,
                SGREGRAENCAMINHAMENTO,
                SGFLUXOATENDIMENTO,
                IDPERFILCONSULTORATD,
                IDFORNECEDORCONSULTORATD,
                IDSITECONSULTORATD,
                NRORDEMVENDA,
                IDPESSOAUSUARIOMC,
                IDGRUPOMC
            ) 
        VALUES 
            (
                :oDados.dadosAtd->idAtendimento, 
                DECODE(:oStatus.statusAtd->dtAbertura,-1,SYSDATE,TO_DATE(:oDados.dadosAtd->dtAbertura,'DD/MM/YYYY HH24:MI:SS')), 
                :oDados.dadosAtd->idContato, 
                TO_DATE(:oDados.dadosAtd->dtPrazoFinalInterno:oStatus.statusAtd->dtPrazoFinalInterno,'DD/MM/YYYY HH24:MI:SS'),
                DECODE(:oStatus.statusAtd->qtInsistencia,-1,0,:oDados.dadosAtd->qtInsistencia), 
                DECODE(:oStatus.statusAtd->inAlarme,-1,0,:oDados.dadosAtd->inAlarme), 
                :oDados.dadosAtd->idCanal, 
                :oDados.dadosAtd->idProcedencia, 
                DECODE(:oStatus.statusAtd->idTipoCarteira,-1,0,:oDados.dadosAtd->idTipoCarteira), 
                DECODE(:oStatus.statusAtd->idSegmentacao,-1,0,:oDados.dadosAtd->idSegmentacao), 
                :oDados.dadosAtd->idPessoaUsuarioAbertura, 
                :oDados.dadosAtd->idGrupoAbertura, 
                TO_DATE(:oDados.dadosAtd->dtPrazoFinalAnatel:oStatus.statusAtd->dtPrazoFinalAnatel,'DD/MM/YYYY HH24:MI:SS'), 
                DECODE(:oStatus.statusAtd->nrNivel,-1,NULL,:oDados.dadosAtd->nrNivel), 
                :oDados.dadosAtd->idFase, 
                DECODE(:oStatus.statusAtd->qtHorasPrazoAtendimento,-1,NULL,:oDados.dadosAtd->qtHorasPrazoAtendimento), 
                DECODE(:oStatus.statusAtd->vlPesoAtendimento,-1,0,:oDados.dadosAtd->vlPesoAtendimento), 
                DECODE(:oStatus.statusAtd->idTipoRetornoContato,-1,0,:oDados.dadosAtd->idTipoRetornoContato), 
                DECODE(:oStatus.statusAtd->idUsuarioAlteracao,-1,NULL,:oDados.dadosAtd->idUsuarioAlteracao), 
                DECODE(:oStatus.statusAtd->dtUltimaAlteracao,-1,SYSDATE,TO_DATE(:oDados.dadosAtd->dtUltimaAlteracao,'DD/MM/YYYY HH24:MI:SS')), 
                TO_DATE(:oDados.dadosAtd->dtPrazoFinalCPrevio:oStatus.statusAtd->dtPrazoFinalCPrevio,'DD/MM/YYYY HH24:MI:SS'), 
                DECODE(:oStatus.statusAtd->idTipoAbertura,-1,0,:oDados.dadosAtd->idTipoAbertura), 
                :oDados.peso, 
                DECODE(:oStatus.nmCor,-1,NULL,:oDados.nmCor), 
                DECODE(:oStatus.idPessoaDePara,-1,NULL,:oDados.idPessoaDePara), 
                DECODE(:oStatus.statusAtd->idPessoaLinhaHistorico,-1,NULL,:oDados.dadosAtd->idPessoaLinhaHistorico), 
                DECODE(:oStatus.idTipoRelacionamento,-1,NULL,:oDados.idTipoRelacionamento), 
                DECODE(:oStatus.statusAtd->idLinhaTelefonica,-1,NULL,:oDados.dadosAtd->idLinhaTelefonica), 
                DECODE(:oStatus.idTipoPessoa,-1,NULL,:oDados.idTipoPessoa), 
                DECODE(:oStatus.statusAtd->idUFOperadora,-1,NULL,:oDados.dadosAtd->idUFOperadora), 
                DECODE(:oStatus.statusAtd->idTipoLinha,-1,NULL,:oDados.dadosAtd->idTipoLinha), 
                DECODE(:oStatus.statusAtd->dtUltimaAlteracao,-1,SYSDATE,TO_DATE(:oDados.dadosAtd->dtUltimaAlteracao,'DD/MM/YYYY HH24:MI:SS')), 
                :oDados.idAlerta, 
                DECODE(:oDados.dtReabertura,NULL,DECODE(:oStatus.statusAtd->dtAbertura,-1,SYSDATE,TO_DATE(:oDados.dadosAtd->dtAbertura,'DD/MM/YYYY HH24:MI:SS')),TO_DATE(:oDados.dtReabertura, 'DD/MM/YYYY HH24:MI:SS')), 
                DECODE(:oStatus.statusAtd->cdAreaRegistro,-1,NULL,:oDados.dadosAtd->cdAreaRegistro), 
                DECODE(:oStatus.statusAtd->idAgrupamentoEstadoTpProc,-1,NULL,:oDados.dadosAtd->idAgrupamentoEstadoTpProc), 
                NULL, // idAndamentoAtual 
                NULL, // idGrupoAnterior 
                NULL, // idGrupoAtual 
                NULL, // idPessoaUsuarioAnterior 
                DECODE(:oDados.dadosAtd->sgFluxoAtendimento,'MC1',:oDados.dadosAtd->idPessoaUsuarioAbertura,NULL), // idPessoaUsuarioAtual
                DECODE(:oStatus.statusAtd->idEstadoLinha,-1,NULL,:oDados.dadosAtd->idEstadoLinha), 
                DECODE(:oStatus.statusAtd->idPessoaConta,-1,NULL,:oDados.dadosAtd->idPessoaConta), 
                :oDados.dadosAtd->idAtendimentoProtocolo, 
                DECODE(:oStatus.statusAtd->sgTipoPortabilidade,-1,NULL,:oDados.dadosAtd->sgTipoPortabilidade), 
                DECODE(:oStatus.statusAtd->sgOperadoraSolicitante,-1,NULL,:oDados.dadosAtd->sgOperadoraSolicitante), 
                DECODE(:oStatus.statusAtd->nrProtocoloPortabilidade,-1,NULL,:oDados.dadosAtd->nrProtocoloPortabilidade), 
                TO_DATE(:oDados.dadosAtd->dtJanelaPortout:oStatus.statusAtd->dtJanelaPortout,'DDMMYYYYHH24MISS'), 
                NULL, // dtUltimaOperacaoExcFila 
                :oDados.dadosAtd->sgRegraEncaminhamento:oStatus.statusAtd->sgRegraEncaminhamento,
                :oDados.dadosAtd->sgFluxoAtendimento:oStatus.statusAtd->sgFluxoAtendimento,
                :oDados.dadosAtd->idPerfilConsultorAtd:oStatus.statusAtd->idPerfilConsultorAtd,
                :oDados.dadosAtd->idFornecedorConsultorAtd:oStatus.statusAtd->idFornecedorConsultorAtd,
                :oDados.dadosAtd->idSiteConsultorAtd:oStatus.statusAtd->idSiteConsultorAtd,
                :oDados.dadosAtd->nrOrdemVenda:oStatus.statusAtd->nrOrdemVenda,
                DECODE(:oDados.dadosAtd->sgFluxoAtendimento,'MC2',:oDados.dadosAtd->idPessoaUsuarioAbertura,NULL), // idPessoaUsuarioMC
                DECODE(:oDados.dadosAtd->sgFluxoAtendimento,'MC2',:oDados.dadosAtd->idGrupoAbertura,NULL) // idGrupoMC
            );
 
    if (oStatus.nmCor != -1) 
    { 
        ULOG("Inserindo Alerta..."); 
 
        EXEC SQL  
            INSERT INTO 
                Atendimento.AtendimentoAlerta 
                ( 
                    idAtendimentoAlerta, 
                    idAlerta, 
                    idAtendimento, 
                    dsMensagem, 
                    idUsuarioAlteracao, 
                    dtUltimaAlteracao 
                ) 
                VALUES 
                ( 
                    Atendimento.AtendimentoAlertaSQ.NEXTVAL, 
                    :oDados.idAlerta, 
                    :oDados.dadosAtd->idAtendimento, 
                    NULL, 
                    :oDados.dadosAtd->idUsuarioAlteracao, 
                    SYSDATE 
                ); 
    } 
 
    // Portabilidade - Associação de processos 
    if ( strcmp(oDados.dadosAtd->sgTipoPortabilidade,PROCESSO_PORTOUT)==0 ) 
    { 
        ULOG("Vai verificar se já existe agrupamento para a mesma linha..."); 
        
        // Em produção não vão ocorrer casos de port-out para a mesma linha telefônica
        // ocorrendo mais de 1x, mas em ambiente de testes é comum serem feitos testes
        // repetidas vezes com a mesma linha e por isso estamos evitando a inclusão da
        // mesma linha no agrupamento e com isso afetar a camada web de retenção.
        //
        EXEC SQL
            SELECT
                COUNT(1)
            INTO
                :iCount
            FROM
                ATENDIMENTO.ATENDIMENTOAGRUPADO ATENDIMENTOAGRUPADO,
                ATENDIMENTO.ATENDIMENTOPRIORIZACAO ATENDIMENTOPRIORIZACAO
            WHERE
                ATENDIMENTOPRIORIZACAO.IDATENDIMENTO = ATENDIMENTOAGRUPADO.IDATENDIMENTO
            AND ATENDIMENTOPRIORIZACAO.IDLINHATELEFONICA = :oDados.dadosAtd->idLinhaTelefonica
            AND ROWNUM < 2;

        if ( iCount == 0 )
        {
            ULOG("Vai associar processos de portabilidade..."); 
 
            EXEC SQL DECLARE curDocumentos CURSOR FOR 
                SELECT DISTINCT 
                    PESSOADOCUMENTO.IDPESSOA, 
                    PESSOADOCUMENTO.IDDOCUMENTO 
                FROM 
                    ATENDIMENTO.ATENDIMENTOPRIORIZACAO ATENDIMENTOPRIORIZACAO, 
                    ATENDIMENTO.ATENDIMENTOPESSOA ATENDIMENTOPESSOA, 
                    CUSTOMER.PESSOADEPARA PESSOADEPARA, 
                    CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO, 
                    CUSTOMER.DOCUMENTO DOCUMENTO, 
                    APOIO.TIPODOCUMENTO TIPODOCUMENTO 
                WHERE  
                    ATENDIMENTOPRIORIZACAO.IDATENDIMENTO = :oDados.dadosAtd->idAtendimento 
                AND ATENDIMENTOPRIORIZACAO.IDATENDIMENTO = ATENDIMENTOPESSOA.IDATENDIMENTO 
                AND ATENDIMENTOPESSOA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA  
                AND PESSOADEPARA.IDPESSOA = PESSOADOCUMENTO.IDPESSOA 
                AND PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO 
                AND DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO 
                AND TIPODOCUMENTO.SGCLASSIFICACAO IN ('CPF','CNPJ'); 
 
            EXEC SQL OPEN curDocumentos; 
 
            EXEC SQL WHENEVER NOT FOUND DO BREAK; 
 
            while (true) 
            {
                memset(&oStatusDocumentoProcesso,-1,sizeof(oStatusDocumentoProcesso));
                i_nrAtendimentoAgrupado = -1;
                memset(&nrAtendimentoAgrupado.arr,0,sizeof(nrAtendimentoAgrupado.arr));
                nrAtendimentoAgrupado.len = 0;
 
                EXEC SQL FETCH curDocumentos INTO :oDadosDocumentoProcesso:oStatusDocumentoProcesso;
 
                EXEC SQL WHENEVER NOT FOUND CONTINUE; 
 
                EXEC SQL 
                    SELECT 
                        NRATENDIMENTOAGRUPADO 
                    INTO 
                        :nrAtendimentoAgrupado:i_nrAtendimentoAgrupado 
                    FROM 
                        ATENDIMENTO.ATENDIMENTOAGRUPADO 
                    WHERE 
                        IDDOCUMENTO = :oDadosDocumentoProcesso.idDocumento 
                    AND 
                        ROWNUM < 2; 

                CONVIND(nrAtendimentoAgrupado,i_nrAtendimentoAgrupado);
 
                    if ( sqlca.sqlcode ) 
                    { 
                        EXEC SQL 
                            SELECT 
                                ATENDIMENTOAGRUPADOSQ.NEXTVAL  
                            INTO  
                                :nrAtendimentoAgrupado:i_nrAtendimentoAgrupado
                            FROM 
                                DUAL; 
                        ULOG("Obtida nova sequence de ATENDIMENTO.ATENDIMENTOAGRUPADO"); 
                    } 
 
                ULOG("nrAtendimentoAgrupado=%d:%s",i_nrAtendimentoAgrupado,(char*)nrAtendimentoAgrupado.arr); 
                ULOG("idPessoa=%d",oDadosDocumentoProcesso.idPessoa); 
                ULOG("idDocumento=%d",oDadosDocumentoProcesso.idDocumento); 
 
                // Insere o processo no contexto de associação 
                EXEC SQL 
                    INSERT INTO 
                        ATENDIMENTO.ATENDIMENTOAGRUPADO 
                            (NRATENDIMENTOAGRUPADO,IDATENDIMENTO,IDPESSOA,IDDOCUMENTO) 
                    VALUES 
                    (:nrAtendimentoAgrupado:i_nrAtendimentoAgrupado
                    ,:oDados.dadosAtd->idAtendimento 
                    ,:oDadosDocumentoProcesso.idPessoa 
                    ,:oDadosDocumentoProcesso.idDocumento); 
            }
 
            EXEC SQL CLOSE curDocumentos; 
        } // if ( iCount == 0 )
        else
        {
            ULOG("ja existe agrupamento para a mesma linha, inserção em ATENDIMENTOAGRUPADO ignorada."); 
        }
 
    } // se portout ... 
 
    ULOG_END("cRegContatoPC::registraTabelaPriorizacao()"); 
} 
 
void cRegContatoPC::gravarAtendimentoLinhas(long idAtendimento,Collection *atendimentoLinhas) 
{ 
    ULOG_START("cRegContatoPC::gravarAtendimentoLinhas()"); 
 
    struct sqlca sqlca; 
 
    EXEC SQL BEGIN DECLARE SECTION; 
 
        long listaIdAtendimento[TAM_MAX_BLC_ORA]; 
        char listaCdConta[TAM_MAX_BLC_ORA][101]; 
        char listaNrTelefone[TAM_MAX_BLC_ORA][13]; 
 
        int rows_to_insert; 
 
    EXEC SQL END DECLARE SECTION; 
 
	ULOG("Alteracao nono digito listaNrTelefone[TAM_MAX_BLC_ORA][11] para listaNrTelefone[TAM_MAX_BLC_ORA][13]"); 
	
    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca); 
 
    int iCount = atendimentoLinhas->GetCount(); 
    int i=0, j=0; 
 
    ULOG("Foram enviadas %d linhas para associacao",iCount); 
 
    while ( i < iCount ) 
    { 
        memset(&listaIdAtendimento,0,sizeof(listaIdAtendimento)); 
        memset(&listaCdConta,0,sizeof(listaCdConta)); 
        memset(&listaNrTelefone,0,sizeof(listaNrTelefone)); 
 
        for ( j = 0; j < TAM_MAX_BLC_ORA; j++ ) 
        { 
            if ( i >= iCount ) { break; } 
 
            listaIdAtendimento[j] = idAtendimento; 
            SAFE_STRNCPY(listaCdConta[j],((AtendimentoLinhas*)atendimentoLinhas->GetItem(i))->cdConta); 
            SAFE_STRNCPY(listaNrTelefone[j],((AtendimentoLinhas*)atendimentoLinhas->GetItem(i))->nrTelefone); 
 
            i++; 
        } 
 
        if ( j )  
        { 
            ULOG("Vai inserir bloco com %d linhas em ATENDIMENTOLINHAS",j); 
 
            rows_to_insert = j; 
 
            EXEC SQL FOR :rows_to_insert 
                INSERT INTO 
                    ATENDIMENTO.ATENDIMENTOLINHAS 
                    ( 
                        IDATENDIMENTOLINHAS, 
                        IDATENDIMENTO, 
                        CDCONTA, 
                        NRTELEFONE 
                    ) 
                VALUES 
                    ( 
                        ATENDIMENTO.ATENDIMENTOLINHASSQ.NEXTVAL, 
                        :listaIdAtendimento, 
                        :listaCdConta, 
                        :listaNrTelefone 
                    ); 
        } 
    } 
 
    ULOG_END("cRegContatoPC::gravarAtendimentoLinhas()"); 
} 
 
// void cRegContatoPC::gravarSmsProtocolo(long idAtendimento,int idContato,char *idAtendimentoProtocolo 
//                                       ,char *msgSMS,char *dataAtualSMS)
// { 
//     ULOG_START("cRegContatoPC::gravarSmsProtocolo()"); 
//  
//     struct sqlca sqlca; 
//  
//     EXEC SQL BEGIN DECLARE SECTION; 
//  
//         int oraIdAtendimento = idAtendimento; 
//         char *oraNrProtocolo = idAtendimentoProtocolo; 
//         int oraIdContato = idContato; 
//         int inSMS; 
//         VARCHAR dsSMS[51]; 
//         VARCHAR nmPath[2001]; 
//         VARCHAR dsMensagemEnvio[600]; 
//         short i_dsSMS = -1; 
//         short i_nmPath = -1; 
//  
//     EXEC SQL END DECLARE SECTION; 
//  
//     EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca); 
//  
//     EXEC SQL 
//         SELECT 
//             INSMS, 
//             DSSMS 
//         INTO 
//             :inSMS, 
//             :dsSMS:i_dsSMS 
//         FROM 
//             CONTATOADM.CONTATOFOLHA CONTATOFOLHA 
//         WHERE 
//             IDCONTATO = :oraIdContato; 
//  
//     // se não encontrou a folha do contato, sai sem inserir na tabela de SMS ... 
//     if ( sqlca.sqlcode != 0 ) 
//     { 
//         ULOGW(">>> Folha de contato %d não encontrada",idContato); 
//         ULOG_START("cRegContatoPC::gravarSmsProtocolo()"); 
//         return; 
//     } 
//  
//     // se envio de sms = sim (1) então enfileira 
//     if ( inSMS ) 
//     { 
//         CONVIND(dsSMS,i_dsSMS); 
//  
//         if ( (msgSMS && *msgSMS) ) 
//         { 
//             strcpy((char*)dsSMS.arr,msgSMS); 
//             dsSMS.len = strlen((char*)dsSMS.arr); 
//         } 
//  
//         // Se não tem descrição incluida, aplica regra de obtenção de nós da árvore 
//         if ( *dsSMS.arr == 0 ) 
//         { 
//             EXEC SQL 
//                 SELECT 
//                     NMPATH 
//                 INTO 
//                     :nmPath:i_nmPath 
//                 FROM 
//                     CONTATOADM.CONTATO 
//                 WHERE 
//                     IDCONTATO = :oraIdContato; 
//  
//             if ( sqlca.sqlcode == 0 ) 
//             { 
//                 CONVIND(nmPath,i_nmPath); 
//  
//                 obterDescricaoPath((char*)nmPath.arr,(char*)dsSMS.arr); 
//  
//                 if ( *dsSMS.arr == 0 ) 
//                 { // se não conseguiu montar a mensagem obtém pelo nome da folha 
//                     EXEC SQL 
//                         SELECT 
//                             NOMECONTATO.NMCONTATO 
//                         INTO 
//                             :dsSMS:i_dsSMS 
//                         FROM  
//                             CONTATOADM.NOMECONTATO NOMECONTATO, 
//                             CONTATOADM.CONTATO CONTATO 
//                         WHERE 
//                             CONTATO.IDCONTATO = :oraIdContato 
//                         AND CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO; 
//                 } 
//  
//                 dsSMS.arr[sizeof(dsSMS.arr)-1] = 0; 
//                 dsSMS.len = strlen((char*)dsSMS.arr); 
//                 i_dsSMS = 1; 
//             } 
//  
//             if ( sqlca.sqlcode || *dsSMS.arr == 0 ) 
//             { 
//                 throw new TuxException("04E0001","Não foi possivel montar mensagem SMS"); 
//             } 
//         } 
//  
//         // Monta mensagem de envio de acordo com a documentação 
//         sprintf((char*)dsMensagemEnvio.arr,"Vivo: Numero do protocolo: %s - %s - %s" 
//                     ,idAtendimentoProtocolo,(char*)dsSMS.arr,dataAtualSMS); 
//  
//         dsMensagemEnvio.len = strlen((char*)dsMensagemEnvio.arr); 
//  
//         EXEC SQL 
//             INSERT INTO 
//                 ATENDIMENTO.SMSPROTOCOLO 
//                 ( 
//                     IDATENDIMENTO, 
//                     IDATENDIMENTOPROTOCOLO, 
//                     DSMENSAGEMENVIO, 
//                     DSMENSAGEMOBS, 
//                     DTENVIO, 
//                     INESTADOSMS 
//                 ) 
//             VALUES 
//                 ( 
//                     :oraIdAtendimento, 
//                     :oraNrProtocolo, 
//                     :dsMensagemEnvio, 
//                     NULL, 
//                     NULL, 
//                     0 
//                 ); 
//     } 
//  
//     ULOG_END("cRegContatoPC::gravarSmsProtocolo()"); 
// }
 
void cRegContatoPC::alterarFilaSmsProtocolo(st_RegContato *dados)
{ 
    ULOG_START("cRegContatoPC::alterarFilaSmsProtocolo()"); 
 
    struct sqlca sqlca; 
 
    EXEC SQL BEGIN DECLARE SECTION; 

        char *varOraIdAtendimentoProtocolo = dados->idAtendimentoProtocolo;
        const char *varOraIdUsuarioAlteracao = dados->idUsuarioBKOSZ;
        int varOraIdContato = dados->idContato;

        int varOraQtProcessoAberto;

        VARCHAR varOraDsMensagemEnvio[1001];
        short statOraDsMensagemEnvio = -1;

    EXEC SQL END DECLARE SECTION; 
 
    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca); 
 
    EXEC SQL
        SELECT 
            QTPROCESSOABERTO
        INTO
            :varOraQtProcessoAberto
        FROM
            ATENDIMENTO.ATENDIMENTOPROTOCOLO
        WHERE
            IDATENDIMENTOPROTOCOLO = :varOraIdAtendimentoProtocolo;

    EXEC SQL
        SELECT
            DSMENSAGEMENVIO
        INTO
            :varOraDsMensagemEnvio:statOraDsMensagemEnvio
        FROM
            ATENDIMENTO.FILASMSPROTOCOLO
        WHERE
            IDATENDIMENTOPROTOCOLO = :varOraIdAtendimentoProtocolo
        FOR UPDATE WAIT 1; // aguarda até 1s para destravar

    if ( sqlca.sqlcode ) 
    { 
        ULOGE("sql_error_WFcRegContatoPC:sqlcode=%d,sqlerrmc=%.70s"
                                ,sqlca.sqlcode
                                ,sqlca.sqlerrm.sqlerrmc);
        ULOG_END("cRegContatoPC::alterarFilaSmsProtocolo()"); 
        return; 
    }

    if ( 0==dados->inSMS && varOraQtProcessoAberto == 1 )
    { // se é primeiro processo sendo associado ao protocolo e o contato
      // do mesmo indica que não é pra enviar SMS então marca isso na tabela.
        EXEC SQL
            UPDATE
                ATENDIMENTO.FILASMSPROTOCOLO
            SET
                INENVIOSMS = 0,
                DTULTIMAALTERACAO = SYSTIMESTAMP,
                IDUSUARIOALTERACAO = :varOraIdUsuarioAlteracao
            WHERE
                IDATENDIMENTOPROTOCOLO = :varOraIdAtendimentoProtocolo;
    }
    else if ( 1==dados->inSMS )
    {
        CONVIND(varOraDsMensagemEnvio,statOraDsMensagemEnvio);

        if ( dados->dsClassificacaoSMS[0] )
        {
            if ( strstr((char*)varOraDsMensagemEnvio.arr,dados->dsClassificacaoSMS) == 0 )
            {
                char *p = strstr((char*)varOraDsMensagemEnvio.arr," - Atendimento Vivo");

                if ( p ) { *p = 0;} // remove a frase

                strcat((char*)varOraDsMensagemEnvio.arr," - ");
                strcat((char*)varOraDsMensagemEnvio.arr,dados->dsClassificacaoSMS);
                varOraDsMensagemEnvio.len = strlen((char*)varOraDsMensagemEnvio.arr);
            }
        }

        EXEC SQL 
            UPDATE
                ATENDIMENTO.FILASMSPROTOCOLO
            SET
                DSMENSAGEMENVIO = :varOraDsMensagemEnvio,
                INENVIOSMS = 1,
                DTULTIMAALTERACAO = SYSTIMESTAMP,
                IDUSUARIOALTERACAO = :varOraIdUsuarioAlteracao
            WHERE
                IDATENDIMENTOPROTOCOLO = :varOraIdAtendimentoProtocolo;
    }

    ULOG_END("cRegContatoPC::alterarFilaSmsProtocolo()"); 
}
 
void cRegContatoPC::registraTerminalVOL(long * _idAtendimento, int* _idTerminal) 
{ 
    ULOG_START("cRegContatoPC::registraTerminalVOL()"); 
 
    struct sqlca sqlca; 
 
        EXEC SQL BEGIN DECLARE SECTION; 
 
        long idAtendimento = *_idAtendimento; 
        int idTerminal    = *_idTerminal; 
 
        EXEC SQL END DECLARE SECTION; 
 
        EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegContatoPC(&sqlca); 
 
    EXEC SQL 
        INSERT INTO 
            vol.AtendimentoTerminal 
            ( 
                idAtendimento, 
                idTerminal 
            ) 
        VALUES 
            ( 
                :idAtendimento, 
                :idTerminal 
            ); 
 
    ULOG_END("cRegContatoPC::registraTerminalVOL()"); 
} 

int cRegContatoPC::buscarRegional(int prefixoPrm)
{
    ULOG_START("cRegContatoPC::buscarRegional()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int   prefixo = prefixoPrm;
        int   idUFOperadora;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL
        SELECT 
            AR.IDUFOPERADORA
        INTO
            :idUFOperadora
        FROM 
            APOIO.AREAREGISTRO AR
           ,CUSTOMER.UFOPERADORA UFO
           ,CUSTOMER.PESSOADEPARA PDP
           ,CUSTOMER.PESSOA P
        WHERE 
            AR.IDUFOPERADORA = UFO.IDUFOPERADORA
        AND UFO.IDPESSOADEPARAOPERADORA = PDP.IDPESSOADEPARA
        AND PDP.IDPESSOA = P.IDPESSOA
        AND AR.CDAREAREGISTRO = :prefixo
        AND ROWNUM < 2;

    ULOG("idUFOperadora = [%d]",idUFOperadora);

    ULOG_END("cRegContatoPC::buscarRegional()");

    return sqlca.sqlcode == 0 ? idUFOperadora : -1;
}

bool cRegContatoPC::proCOperadoraNaoCliente( const int _idPessoaDePara, int *_idUFOperadoraNaoCliente )
{
    ULOG_START( "cRegContatoPC::proCOperadoraNaoCliente()" );

    struct sqlca sqlca;
    bool retorno = false;

    EXEC SQL BEGIN DECLARE SECTION;

        int idPessoaDePara = _idPessoaDePara;
        int idUFOperadora;
        int inNaoCliente = 0;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        SELECT
            UFOPERADORA.IDUFOPERADORA, 
            DECODE(PESSOA.IDPESSOA,26,1,0) AS NAO_CLIENTE
        INTO
            :idUFOperadora,
            :inNaoCliente
        FROM 
            CUSTOMER.UFOPERADORA UFOPERADORA,
            CUSTOMER.PESSOA PESSOA
        WHERE 
            UFOPERADORA.IDUF = PESSOA.IDUF
        AND PESSOA.IDPESSOA = :idPessoaDePara
        AND ROWNUM < 2;

    // Caso este seja o atendimento de um NÃO-CLIENTE, retornamos o UFOperadora do mesmo
    if( sqlca.sqlcode == 0 && inNaoCliente == 1 )
    {
        *_idUFOperadoraNaoCliente = idUFOperadora;
        retorno = true;
    }

    ULOG_END( "cRegContatoPC::proCOperadoraNaoCliente()" );

    return retorno;
}

bool cRegContatoPC::proCObterConsultorRelacionamento(const int idConta
                                                    ,const int idPessoaDeParaCliente
                                                    ,int *idPessoaConta)
{
    ULOG_START( "cRegContatoPC::proCObterConsultorRelacionamento()" );

    struct sqlca sqlca;
    bool retorno = false;

    EXEC SQL BEGIN DECLARE SECTION;
        const int parOraIdPessoaDeParaCliente = idPessoaDeParaCliente;

        VARCHAR varOraIdConta[101];
        short statOraIdConta = -1;

        int varOraIdPessoaConta;
        short statOraIdPessoaConta = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    ULOG("idConta=%d",idConta);
    ULOG("idPessoaDeParaCliente=%d",parOraIdPessoaDeParaCliente);

    if ( idConta > 0 )
    { // Se informou id conta, verifica se possui consultor de relacionamento associado
        sprintf((char*)varOraIdConta.arr,"%d",idConta);
        varOraIdConta.len = strlen((char*)varOraIdConta.arr);

        ULOG("Vai buscar idPessoaConta por idConta=%s...",varOraIdConta.arr);

        EXEC SQL
            SELECT
                PESSOACONTA.IDPESSOACONTA
            INTO
                :varOraIdPessoaConta:statOraIdPessoaConta
            FROM
                CUSTOMER.PESSOACONTA PESSOACONTA,
                CUSTOMER.PESSOADEPARA PESSOADEPARA,
                CUSTOMER.PESSOA PESSOA,
                ACESSO.USUARIO USUARIO,
                APOIO.STATUSUSUARIO STATUSUSUARIO,
                CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTO
            WHERE
                PESSOACONTA.IDCONTA = :varOraIdConta
            AND PESSOACONTA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA
            AND PESSOADEPARA.IDPESSOA = PESSOA.IDPESSOA
            AND PESSOA.IDPESSOA = USUARIO.IDPESSOAUSUARIO
            AND USUARIO.IDSTATUSUSUARIO = STATUSUSUARIO.IDSTATUSUSUARIO
            AND STATUSUSUARIO.SGSTATUSUSUARIO = 'ATIVO'
            AND PESSOACONTA.IDTIPORELACIONAMENTO = TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
            AND TIPORELACIONAMENTO.NMTIPORELACIONAMENTO = 'CONSULTOR RELACIONAMENTO'
            AND ROWNUM < 2;
    }

    if ( sqlca.sqlcode || idConta <= 0 )
    { // se o cliente possui conta, verifica se tem consultor de relacionamento

        ULOG("Vai buscar idPessoaConta por pessoa...");

        EXEC SQL
            SELECT
                PESSOACONTA.IDPESSOACONTA
            INTO
                :varOraIdPessoaConta:statOraIdPessoaConta
            FROM
                CUSTOMER.PESSOACONTA PESSOACONTA,
                CUSTOMER.PESSOADEPARA PESSOADEPARA,
                CUSTOMER.PESSOA PESSOA,
                ACESSO.USUARIO USUARIO,
                APOIO.STATUSUSUARIO STATUSUSUARIO,
                CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTO
            WHERE
                PESSOACONTA.IDCONTA IN
                (
                    SELECT
                        PESSOACONTACLI.IDCONTA
                    FROM
                        CUSTOMER.PESSOACONTA PESSOACONTACLI,
                        CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTOCLI
                    WHERE
                        PESSOACONTACLI.IDPESSOADEPARA = :parOraIdPessoaDeParaCliente
                    AND NVL(PESSOACONTACLI.DTEXPIRACAO,SYSDATE+1) > SYSDATE
                    AND PESSOACONTACLI.IDTIPORELACIONAMENTO = TIPORELACIONAMENTOCLI.IDTIPORELACIONAMENTO
                    AND TIPORELACIONAMENTOCLI.NMTIPORELACIONAMENTO = 'CLIENTE'
                )
            AND PESSOACONTA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA
            AND PESSOADEPARA.IDPESSOA = PESSOA.IDPESSOA
            AND PESSOA.IDPESSOA = USUARIO.IDPESSOAUSUARIO
            AND USUARIO.IDSTATUSUSUARIO = STATUSUSUARIO.IDSTATUSUSUARIO
            AND STATUSUSUARIO.SGSTATUSUSUARIO = 'ATIVO'
            AND PESSOACONTA.IDTIPORELACIONAMENTO = TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
            AND TIPORELACIONAMENTO.NMTIPORELACIONAMENTO = 'CONSULTOR RELACIONAMENTO'
            AND ROWNUM < 2;
    }

    if ( 0==sqlca.sqlcode )
    {
        *idPessoaConta = varOraIdPessoaConta;
        retorno = true;
        ULOG("idPessoaConta=%d",varOraIdPessoaConta);
    }
    else
    {
        ULOG("Consultor de relacionamento da conta não encontrado ou não ativo");
    }

    ULOG_END( "cRegContatoPC::proCObterConsultorRelacionamento()" );

    return retorno;
}

void cRegContatoPC::registraErro(DOMNode *dnode,const char *_msgErro)
{
    ULOG_START("cRegContatoPC::registraErro()");

    struct sqlca sqlca;

    char *p = tx.getNodeAsString(dnode);
    string valor = p;
    if ( p ) { free(p); }

    EXEC SQL BEGIN DECLARE SECTION;
        long idAtendimentoRegContatoErr;
        char idContato[21];
        char idCanal[21];
        char idGrupoAbertura[21];
        char idUsuarioBKO[21];
        char idProcedencia[21];
        char idSegmentacao[21];
        char idTipoCarteira[21];
        const char *xmlEntrada = valor.c_str();
        const char *msgErro = _msgErro;
    EXEC SQL END DECLARE SECTION;

    if ( dados->idContato )
    {
        sprintf(idContato,"%d",dados->idContato);
    }
    else
    {
        idContato[0] = 0;
    }

    if ( dados->idCanal )
    {
        sprintf(idCanal,"%d",dados->idCanal);
    }
    else
    {
        idCanal[0] = 0;
    }

    if ( dados->idGrupoAbertura )
    {
        sprintf(idGrupoAbertura,"%d",dados->idGrupoAbertura);
    }
    else
    {
        idGrupoAbertura[0] = 0;
    }

    if ( dados->idUsuarioBKO )
    {
        sprintf(idUsuarioBKO,"%d",dados->idUsuarioBKO);
    }
    else
    {
        idUsuarioBKO[0] = 0;
    }

    if ( dados->idProcedencia )
    {
        sprintf(idProcedencia,"%d",dados->idProcedencia);
    }
    else
    {
        idProcedencia[0] = 0;
    }

    if ( dados->idSegmentacao )
    {
        sprintf(idSegmentacao,"%d",dados->idSegmentacao);
    }
    else
    {
        idSegmentacao[0] = 0;
    }

    if ( dados->idTipoCarteira )
    {
        sprintf(idTipoCarteira,"%d",dados->idTipoCarteira);
    }
    else
    {
        idTipoCarteira[0] = 0;
    }

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL
        SELECT ATENDIMENTO.ATENDIMENTOREGCONTATOERRSQ.NEXTVAL 
          INTO :idAtendimentoRegContatoErr
          FROM DUAL;

    ULOG("idAtendimentoRegContatoErr=%ld",idAtendimentoRegContatoErr);
    ULOG("idContato=%s",idContato);
    ULOG("idCanal=%s",idCanal);
    ULOG("idGrupoAbertura=%s",idGrupoAbertura);
    ULOG("idUsuarioBKO=%s",idUsuarioBKO);
    ULOG("idProcedencia=%s",idProcedencia);
    ULOG("idSegmentacao=%s",idSegmentacao);
    ULOG("idTipoCarteira=%s",idTipoCarteira);
    ULOG("xmlEntrada=%s",xmlEntrada);
    ULOG("msgErro=%s",msgErro);

    EXEC SQL
        INSERT INTO
            ATENDIMENTO.ATENDIMENTOREGCONTATOERR
            (
                IDATENDIMENTOREGCONTATOERR,
                IDCONTATOERR,
                IDCANALERR,
                IDGRUPOABERTURAERR,
                IDPESSOAUSUARIOABERTURAERR,
                IDPROCEDENCIAERR,
                IDSEGMENTACAOERR,
                IDTIPOCARTEIRAERR,
                DTOCORRENCIA,
                XMLENTRADA,
                MENSAGEMERRO
            )
        VALUES
            (
                :idAtendimentoRegContatoErr,
                :idContato,
                :idCanal,
                :idGrupoAbertura,
                :idUsuarioBKO,
                :idProcedencia,
                :idSegmentacao,
                :idTipoCarteira,
                SYSDATE,
                :xmlEntrada,
                :msgErro
            );

    ULOG("sqlca.sqlcode=%d",sqlca.sqlcode);

    ULOG_END("cRegContatoPC::registraErro()");
}

bool cRegContatoPC::proCObterIdUserUra(const char *userNN,char *idPessoaUsuario)
{
    ULOG_START("cRegContatoPC::proCObterIdUserUra()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        char paraOraNmLoginUsuario[256];
        VARCHAR varOraIdPessoaUsuario[256];
        short statOraIdPessoaUsuario = -1;

    EXEC SQL END DECLARE SECTION;

    sprintf(paraOraNmLoginUsuario,"ura%s",userNN);

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL
        SELECT
            IDPESSOAUSUARIO
        INTO
            :varOraIdPessoaUsuario:statOraIdPessoaUsuario
        FROM
            ACESSO.USUARIO
        WHERE
            NMLOGINUSUARIO = :paraOraNmLoginUsuario;

    ULOG("(1) sqlca.sqlcode=%d",sqlca.sqlcode);

    if ( sqlca.sqlcode )
    {
        EXEC SQL
            SELECT
                IDPESSOAUSUARIO
            INTO
                :varOraIdPessoaUsuario:statOraIdPessoaUsuario
            FROM
                ACESSO.USUARIO
            WHERE
                NMLOGINUSUARIO = 'usuario URA';
    }

    ULOG("(2) sqlca.sqlcode=%d",sqlca.sqlcode);

    if ( sqlca.sqlcode )
    {
        ULOG_END("cRegContatoPC::proCObterIdUserUra() --> não encontrou usuário");
        return false;
    }

    strcpy(idPessoaUsuario,(char*)varOraIdPessoaUsuario.arr);

    ULOG_END("cRegContatoPC::proCObterIdUserUra()");

    return true;
}

bool cRegContatoPC::proCVerificarUserNumericoSimNao(const char *userNN)
{
    ULOG_START("cRegContatoPC::proCVerificarUserNumericoSimNao()");

    bool retorno = true;
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        char paramOraCdParametro[256];
        VARCHAR varOraDsValorParametro[256];
        short statOraDsValorParametro = -1;
    EXEC SQL END DECLARE SECTION;

    sprintf(paramOraCdParametro,"REGC_NAOANALISAR_IDUSER_%s",userNN);

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca);

    EXEC SQL
        SELECT
            DSVALORPARAMETRO
        INTO
            :varOraDsValorParametro:statOraDsValorParametro
        FROM
            APOIO.PARAMETRO
        WHERE
            CDPARAMETRO = :paramOraCdParametro
        AND ROWNUM < 2;

    ULOG("sqlcode=%d",sqlca.sqlcode);

    if ( 0==sqlca.sqlcode )
    {
        CONVIND(varOraDsValorParametro,statOraDsValorParametro);

        ULOG("varOraDsValorParametro=%s",varOraDsValorParametro.arr);
        if ( strcmp((char*)varOraDsValorParametro.arr,"false")==0 )
        {
            retorno = false;
        }
    }

    ULOG("retorno=%d",retorno);

    ULOG_END("cRegContatoPC::proCVerificarUserNumericoSimNao()");

    return retorno;
}

bool cRegContatoPC::proCObterDadosProtocolo(const char *idAtendimentoProtocolo)
{
    ULOG_START("cRegContatoPC::proCObterDadosProtocolo(const char *idAtendimentoProtocolo)");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        struct
        {
            short idTipoAberturaProtocolo;
            short dsTipoAberturaProtocolo;
            short idStatusProtocolo;
            short dsStatusProtocolo;
        } statOraDadosProtocolo;

        struct
        {
            VARCHAR idTipoAberturaProtocolo[4];
            VARCHAR dsTipoAberturaProtocolo[256];
            VARCHAR idStatusProtocolo[4];
            VARCHAR dsStatusProtocolo[41];
        } dadosOraDadosProtocolo;

        const char *paramOraIdAtendimentoProtocolo = idAtendimentoProtocolo;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegContatoPC(&sqlca);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    memset(&dadosOraDadosProtocolo,0,sizeof(st_DadosEstadoProtocolo));
    memset(&statOraDadosProtocolo,-1,sizeof(statOraDadosProtocolo));

    EXEC SQL
        SELECT
             ATENDIMENTOPROTOCOLO.IDTIPOABERTURAPROTOCOLO,
             TIPOABERTURAPROTOCOLO.DSTIPOABERTURAPROTOCOLO,
             ATENDIMENTOPROTOCOLO.IDSTATUSPROTOCOLO,
             STATUSPROTOCOLO.DSSTATUSPROTOCOLO
        INTO
            :dadosOraDadosProtocolo:statOraDadosProtocolo
        FROM
            ATENDIMENTO.ATENDIMENTOPROTOCOLO ATENDIMENTOPROTOCOLO,
            APOIO.TIPOABERTURAPROTOCOLO TIPOABERTURAPROTOCOLO,
            APOIO.STATUSPROTOCOLO STATUSPROTOCOLO
        WHERE
            ATENDIMENTOPROTOCOLO.IDATENDIMENTOPROTOCOLO = :paramOraIdAtendimentoProtocolo
        AND ATENDIMENTOPROTOCOLO.IDTIPOABERTURAPROTOCOLO = TIPOABERTURAPROTOCOLO.IDTIPOABERTURAPROTOCOLO
        AND ATENDIMENTOPROTOCOLO.IDSTATUSPROTOCOLO = STATUSPROTOCOLO.IDSTATUSPROTOCOLO;

    if (  sqlca.sqlcode )
    {
        ULOG_END("cRegContatoPC::proCObterDadosProtocolo(const char *idAtendimentoProtocolo)-NOT FOUND");
        return false;
    }

    CONVIND(dadosOraDadosProtocolo.idTipoAberturaProtocolo,statOraDadosProtocolo.idTipoAberturaProtocolo);
    CONVIND(dadosOraDadosProtocolo.dsTipoAberturaProtocolo,statOraDadosProtocolo.dsTipoAberturaProtocolo);
    CONVIND(dadosOraDadosProtocolo.idStatusProtocolo,statOraDadosProtocolo.idStatusProtocolo);
    CONVIND(dadosOraDadosProtocolo.dsStatusProtocolo,statOraDadosProtocolo.dsStatusProtocolo);

    SAFE_STRNCPY(dadosProtocolo->idTipoAberturaProtocolo,(char*)dadosOraDadosProtocolo.idTipoAberturaProtocolo.arr);
    SAFE_STRNCPY(dadosProtocolo->dsTipoAberturaProtocolo,(char*)dadosOraDadosProtocolo.dsTipoAberturaProtocolo.arr);
    SAFE_STRNCPY(dadosProtocolo->idStatusProtocolo,(char*)dadosOraDadosProtocolo.idStatusProtocolo.arr);
    SAFE_STRNCPY(dadosProtocolo->dsStatusProtocolo,(char*)dadosOraDadosProtocolo.dsStatusProtocolo.arr);

    ULOG_END("cRegContatoPC::proCObterDadosProtocolo(const char *idAtendimentoProtocolo)");

    return true;
}

void cRegContatoPC::sql_error_WFcRegContatoPC( sqlca * sqlca )
{
    ULOGE("sql_error_WFcRegContatoPC:sqlcode=%d,sqlerrmc=%.70s"
                            ,sqlca->sqlcode
                            ,sqlca->sqlerrm.sqlerrmc);

    throw new TuxBasicOraException(sqlca->sqlcode
                                  ,sqlca->sqlerrm.sqlerrmc
                                  ,sqlca->sqlerrm.sqlerrml);
}
 
//============================================================================== 
// Funções de apoio 
char *cRegContatoPC::obterDescricaoPath(char *stringIn, char *stringOut) 
{ 
    ULOG_START("cRegContatoPC::obterDescricaoPath()"); 
 
    char seps[] = "/"; 
    char *token; 
    int nivel = 1; 
    char stringTmp[2001]; 
 
    SAFE_STRNCPY(stringTmp,stringIn); 
 
    int niveis = 0; 
 
    token = strtok(stringTmp, seps); 
 
    while( token ) 
    { 
        niveis++; 
        token = strtok( NULL, seps ); 
    } 
 
    if ( stringOut ) 
    { 
        *stringOut = 0; 
 
        if ( niveis ) 
        { // tem path? 
            token = strtok(stringIn, seps); 
 
            while( token ) 
            { 
                nivel++; 
 
                token = strtok( NULL, seps ); 
 
                if ( niveis > 3 && (nivel < 2 || nivel > 3) ) { continue; } 
                if ( niveis == 3 && nivel < 3 ) { continue; } 
 
                if ( token ) 
                { 
                    if ( *stringOut ) { strcat(stringOut," "); } 
                    strcat(stringOut,token); 
                } 
            } 
        } 
    } 
 
    ULOG_END("cRegContatoPC::obterDescricaoPath()"); 
 
    return stringOut; 
} 
