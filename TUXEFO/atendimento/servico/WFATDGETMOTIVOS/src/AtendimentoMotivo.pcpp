/**
 * 
 * @modulo  Workflow
 * @usecase Workflow
 * @author  Andrei Kurak
 * @version $Revision: 1.1 $
 * @CVS     $Author: a5110702 $ - $Date: 2009/07/31 15:33:53 $
 **/

#include "../../../commons/queryMacro.h"
#include "../include/AtendimentoMotivo.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

AtendimentoMotivo::AtendimentoMotivo() {}
AtendimentoMotivo::~AtendimentoMotivo() {}


int AtendimentoMotivo::listMotivos(char*idTabelaMotivo,XMLGen*xml)
{
    ULOG_START("AtendimentoMotivo::listMotivos()");
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        struct param
        {
            VARCHAR idMotivo[22];
            VARCHAR dsMotivo[256];
        }m_param;

        struct iparam
        {
            short idMotivo;
            short dsMotivo;
        } m_iparam;

        char *cidTabelaMotivo = idTabelaMotivo;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_ATDGETMOTIVOS(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL DECLARE CURSORMOTIVO CURSOR FOR
    SELECT
          M.IDMOTIVO,
          M.DSMOTIVO
    FROM
        ATENDIMENTO.TABELAMOTIVO TM,
        ATENDIMENTO.MOTIVO M,
        ATENDIMENTO.MOTIVOTABELAMOTIVO MTM
    WHERE
         TM.IDTABELAMOTIVO = MTM.IDTABELAMOTIVO
         AND MTM.IDMOTIVO = M.IDMOTIVO
         AND TM.IDTABELAMOTIVO = :cidTabelaMotivo
         AND M.DTEXCLUSAO IS NULL
         AND M.INVISIVEL = 1
    ORDER BY
          UPPER(M.DSMOTIVO) ASC;

    EXEC SQL OPEN CURSORMOTIVO; 
    for(;;)
    {
        //memset(&m_param,0,sizeof(param));
        memset(&m_iparam,-1,sizeof(iparam));
        EXEC SQL FETCH CURSORMOTIVO INTO :m_param:m_iparam;

        CONVIND(m_param.idMotivo,m_iparam.idMotivo);
        CONVIND(m_param.dsMotivo,m_iparam.dsMotivo);

        xml->createTag("WFMotivoVO");
            xml->addItem("idMotivo",(char*)m_param.idMotivo.arr);
            xml->addItem("dsMotivo",(char*)m_param.dsMotivo.arr);
        xml->closeTag();
    }

    EXEC SQL CLOSE CURSORMOTIVO;    
    
    ULOG_END("AtendimentoMotivo::listMotivos()");

    return 1;
}


int AtendimentoMotivo::listAllMotivos(XMLGen*xml)
{
    ULOG_START("AtendimentoMotivo::listAllMotivos()");
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        struct param
        {
            VARCHAR idMotivo[22];
            VARCHAR dsMotivo[256];
        } m_param;
        
        struct iparam
        {
            short idMotivo;
            short dsMotivo;
        } m_iparam;
        
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_ATDGETMOTIVOS(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE CURSORMOTIVO2 CURSOR FOR
    SELECT 
           IDMOTIVO,DSMOTIVO 
      FROM 
           ATENDIMENTO.MOTIVO
    ORDER BY
           IDMOTIVO ASC;

    EXEC SQL OPEN CURSORMOTIVO2;

    for(;;)
    {
        //memset(&m_param,0,sizeof(param));
        memset(&m_iparam,-1,sizeof(iparam));

        EXEC SQL FETCH CURSORMOTIVO2 INTO :m_param:m_iparam;

        CONVIND(m_param.idMotivo,m_iparam.idMotivo);
        CONVIND(m_param.dsMotivo,m_iparam.dsMotivo);

        xml->createTag("WFMotivoVO");
            xml->addItem("idMotivo",(char*)m_param.idMotivo.arr);
            xml->addItem("dsMotivo",(char*)m_param.dsMotivo.arr);
        xml->closeTag();
    }

    EXEC SQL CLOSE CURSORMOTIVO2;
    
    ULOG_END("AtendimentoMotivo::listAllMotivos()");
    
    return 1;
}


void AtendimentoMotivo::sql_error_ATDGETMOTIVOS( sqlca * sqlca )
{
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    ULOGE("sql_error_ATDGETMOTIVOS:sqlcode=%d,sqlerrmc=%.70s"
                            ,sqlca->sqlcode
                            ,sqlca->sqlerrm.sqlerrmc);

    throw new TuxBasicOraException(sqlca->sqlcode
                                  ,sqlca->sqlerrm.sqlerrmc
                                  ,sqlca->sqlerrm.sqlerrml);
}
