#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"


#include "../include/cWFAtendimentoPesquisaResp.h"
#include "../include/stWFAtendimentoPesquisaResp.h"

void sql_error_WFAtendimentoPesquisaResp(sqlca*sqlca);

    // Declara as estruturas compatíveis ao ProC.
    EXEC SQL BEGIN DECLARE SECTION;
        #include "../include/stWFAtendimentoPesquisaResp.h"
    EXEC SQL END DECLARE SECTION;

bool proCIncluirWFAtendimentoPesquisaResp(st_AtendimentoPesquisaResp* dados, st_vlAtendimentoPesquisaResp* status, XMLGen* saida)
{
    ULOG_START("proCIncluirWFAtendimentoPesquisaResp");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        struct st_AtendimentoPesquisaResp *oDados = dados;
        struct st_vlAtendimentoPesquisaResp *oStatus = status;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoPesquisaResp(&sqlca);

    EXEC SQL 
        SELECT 
            atendimento.AtendimentoPesquisaRespSQ.NEXTVAL 
        INTO 
            :oDados->idAtendimentoPesquisaResp 
        FROM 
            DUAL;

    ULOG("idAtendimentoPesquisaResp=%d",oDados->idAtendimentoPesquisaResp);
    ULOG("idAtendimentoPesquisaSatisfa=%d",oDados->idAtendimentoPesquisaSatisfa);
    ULOG("idPessoaUsuario=%d",oDados->idPessoaUsuario);

    EXEC SQL 
        INSERT INTO
            atendimento.AtendimentoPesquisaResp
            (
                 idAtendimentoPesquisaResp
                ,idAtendimentoPesquisaSatisfa
                ,idPergunta
                ,vlResposta
                ,idUsuarioAlteracao
                ,dtUltimaAlteracao
            )
            VALUES
            (
                 :oDados->idAtendimentoPesquisaResp
                ,:oDados->idAtendimentoPesquisaSatisfa
                ,:oDados->idPergunta
                ,:oDados->vlResposta
                ,:oDados->idPessoaUsuario
                ,SYSDATE
            );

    if ( saida )
    {
        saida->createTag("Registro");
            saida->addItem("idAtendimentoPesquisaResp", oDados->idAtendimentoPesquisaResp);
        saida->closeTag();
    }

    ULOG_END("proCIncluirWFAtendimentoPesquisaResp");

    return true;
}

bool proCAlterarWFAtendimentoPesquisaResp(st_AtendimentoPesquisaResp* dados, st_vlAtendimentoPesquisaResp* status, XMLGen* saida)
{
    ULOG_START("proCAlterarWFAtendimentoPesquisaResp");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        struct st_AtendimentoPesquisaResp   oDados;
        struct st_vlAtendimentoPesquisaResp oStatus;

        char query[800] = "UPDATE atendimento.AtendimentoPesquisaResp SET ";

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoPesquisaResp(&sqlca);

    memcpy(&oDados,  dados,  sizeof(oDados));
    memcpy(&oStatus, status, sizeof(oStatus));

    bool separa = false;

    if (status->idAtendimentoPesquisaSatisfa != -1) 
        montaUpdate("idAtendimentoPesquisaSatisfa", oDados.idAtendimentoPesquisaSatisfa, TIPO_ULONG);

    if (status->idPergunta != -1) 
        montaUpdate("idPergunta", oDados.idPergunta, TIPO_INT);

    if (status->vlResposta != -1) 
        montaUpdate("vlResposta", oDados.vlResposta, TIPO_INT);

    montaUpdate("dtUltimaAlteracao", "SYSDATE", TIPO_DATAHORA);

    sprintf(query, "%s WHERE idAtendimentoPesquisaResp = %i", query, dados->idAtendimentoPesquisaResp);

    EXEC SQL EXECUTE IMMEDIATE :query;

    ULOG_END("proCAlterarWFAtendimentoPesquisaResp");

    return true;
}

bool proCExcluirWFAtendimentoPesquisaResp(st_AtendimentoPesquisaResp* dados, st_vlAtendimentoPesquisaResp* status, XMLGen* saida)
{
    ULOG_START("proCExcluirWFAtendimentoPesquisaResp");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimentoPesquisaResp = dados->idAtendimentoPesquisaResp;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoPesquisaResp(&sqlca);

    EXEC SQL 
        DELETE
            atendimento.AtendimentoPesquisaResp
        WHERE
            idAtendimentoPesquisaResp = :idAtendimentoPesquisaResp;

    ULOG_END("proCExcluirWFAtendimentoPesquisaResp");

    return true;
}

bool proCConsultaWFAtendimentoPesquisaResp(st_AtendimentoPesquisaResp* dados, st_vlAtendimentoPesquisaResp* status, char* order, XMLGen* saida)
{
    ULOG_START("proCConsultaWFAtendimentoPesquisaResp");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimentoPesquisaResp;
        long idAtendimentoPesquisaSatisfa;
        int idPergunta;

        char query[1024] = "SELECT idAtendimentoPesquisaResp,idAtendimentoPesquisaSatisfa"
                                 ",idPergunta,vlResposta "
                             "FROM atendimento.AtendimentoPesquisaResp ";

    EXEC SQL END DECLARE SECTION;

    memset(sqlca.sqlerrm.sqlerrmc,0,sizeof(sqlca.sqlerrm.sqlerrmc));

    bool separa = false;

    if (status->idAtendimentoPesquisaResp != -1) 
        montaWhere("idAtendimentoPesquisaResp", dados->idAtendimentoPesquisaResp, 1);

    if (status->idAtendimentoPesquisaSatisfa != -1)
        montaWhere("idAtendimentoPesquisaSatisfa", dados->idAtendimentoPesquisaSatisfa, 1);

    if (status->idPergunta != -1)
        montaWhere("idPergunta", dados->idPergunta, 1);

    if (status->vlResposta != -1)
        montaWhere("vlResposta", dados->vlResposta, 1);

    if (strlen(order) > 0) 
        sprintf( query, "%s ORDER BY %s ", query, order);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoPesquisaResp(&sqlca);

    EXEC SQL PREPARE consultaAtendimentoPesquisaResp FROM :query;
    EXEC SQL DECLARE consulta CURSOR FOR consultaAtendimentoPesquisaResp;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL OPEN consulta;

    while (true)
    {
        EXEC SQL FETCH consulta INTO :idAtendimentoPesquisaResp, :idAtendimentoPesquisaSatisfa, :idPergunta;

        saida->createTag("WFAtendimentoPesquisaRespVO");
            saida->addItem("idAtendimentoPesquisaResp", idAtendimentoPesquisaResp);
            saida->addItem("idAtendimentoPesquisaSatisfa", idAtendimentoPesquisaSatisfa);
            saida->addItem("idPergunta", idPergunta);
        saida->closeTag();
    }

    EXEC SQL CLOSE consulta;

    ULOG_END("proCConsultaWFAtendimentoPesquisaResp");

    return true;
}

void sql_error_WFAtendimentoPesquisaResp(sqlca*sqlca)
{
    throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
