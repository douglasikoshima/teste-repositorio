/**
 * @modulo  Workflow
 * @usecase Workflow
 * @author
 * @version $Revision: 1.1.2.1 $
 * @CVS     $Author: a5116174 $ - $Date: 2011/08/12 17:11:35 $
 **/

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"
#include "../../../commons/msgPadrao.h"
#include "../include/cWFFluxoFase.h"

// Declara as estruturas compatíveis ao ProC.
EXEC SQL BEGIN DECLARE SECTION;
	#include "../include/stWFFluxoFase.h"
EXEC SQL END DECLARE SECTION;

//==============================================================================
// Protótipos
void sql_error_WFFluxoFase(sqlca*sqlca);

//==============================================================================
// Tipagem & estruturas
struct TiposRelacionamentoBKO
{
    int idTipoRelacionamento;
    //char descricao[256];
    const char *descricao;
} tiposRelacionamentoBKO[] = 
    {
        { ANALISTA_BKO_SEM_CRI,"ANALISTA BKO - SEM CRI" },
        { SUPERVISOR_CRI,"SUPERVISOR CRI" },
        { CRI_RESPONSAVEL,"CRI RESPONSAVEL" },
        { CRI_NAO_RESPONSAVEL,"CRI NAO RESPONSAVEL" },
        { ANALISTA_BKO_COM_CRI,"ANALISTA BKO - COM CRI" },
        { ANALISTA_RESP_CLI,"ANALISTA RESPOSTA AO CLIENTE" },
        { SUPERVISOR_BKO,"SUPERVISOR" },
        { SUPERVISOR_BKO_COM_CRI,"SUPERVISOR BKO - COM CRI" },
        { ANALISTA_DE_RETENCAO,"ANALISTA DE RETENÇÃO" }
    };

//==============================================================================
// Implementação
int proCObterTipoRelacionamentoBKO(int _tipoRelacionamentoBko)
{
    ULOG_START("proCObterTipoRelacionamentoBKO()");

    int retorno = -1;
    struct sqlca sqlca;

    ULOG("_tipoRelacionamentoBko=%d",_tipoRelacionamentoBko);

    if ( _tipoRelacionamentoBko > (sizeof(tiposRelacionamentoBKO) / sizeof(tiposRelacionamentoBKO[0])) )
    {
        ULOG_END("proCObterTipoRelacionamentoBKO() saida anormal");

        return retorno; // se id invalido retorna como não encontrado
    }

    EXEC SQL BEGIN DECLARE SECTION;
        const char *dsTipoRelacionamentoBko =
                                tiposRelacionamentoBKO[_tipoRelacionamentoBko].descricao;

        int idTipoRelacionamentoBKO = 0;
        short iidTipoRelacionamentoBKO = -1;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);

    EXEC SQL
        SELECT
            IDTIPORELACIONAMENTOBKO
        INTO 
            :idTipoRelacionamentoBKO:iidTipoRelacionamentoBKO
        FROM 
            APOIO.TIPORELACIONAMENTOBKO
        WHERE
            DSTIPORELACIONAMENTOBKO = :dsTipoRelacionamentoBko;

    ULOG("dsTipoRelacionamentoBko='%s'",dsTipoRelacionamentoBko);

    if ( 0==sqlca.sqlcode )
    {
        retorno = idTipoRelacionamentoBKO;

        ULOG("idTipoRelacionamentoBKO=%d",idTipoRelacionamentoBKO);
    }
    else
    {
        ULOG(resultadoNaoEncontradoSql());
    }

     ULOG_END("proCObterTipoRelacionamentoBKO()");

    return retorno;
}

bool proCFFIncluirWFFluxoFase(st_FluxoFase* dados, st_vlFluxoFase* status, XMLGen* saida)
{
   ULOG_START("proCFFIncluirWFFluxoFase()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_FluxoFase   oDados;
		struct st_vlFluxoFase oStatus;

	EXEC SQL END DECLARE SECTION;

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);

	EXEC SQL SELECT workflow.FluxoFaseSQ.NEXTVAL INTO :oDados.idFluxoFase FROM DUAL;

	EXEC SQL 
		INSERT INTO
			workflow.FluxoFase
			(
				idFluxoFase,
				idFase,
				idFluxo,
				nmURLDestino,
				nmFuncValidacao
			)
			VALUES
			(
				:oDados.idFluxoFase,
				:oDados.idFase,
				:oDados.idFluxo,
				:oDados.nmURLDestino,
				:oDados.nmFuncValidacao
			);

	saida->createTag("Registro");
		saida->addItem("idFluxoFase", oDados.idFluxoFase);
	saida->closeTag();

   ULOG_END("proCFFIncluirWFFluxoFase()");

	return true;
}

bool proCFFAlterarWFFluxoFase(st_FluxoFase* dados, st_vlFluxoFase* status, XMLGen* saida)
{
    ULOG_START("proCFFAlterarWFFluxoFase()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_FluxoFase   oDados;
		struct st_vlFluxoFase oStatus;

		char query[800] = "UPDATE workflow.FluxoFase SET ";

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

	bool separa = false;

	if (status->idFluxoFase != -1) 
		montaUpdate("idFluxoFase", oDados.idFluxoFase, 1);

	if (status->idFase != -1) 
		montaUpdate("idFase", oDados.idFase, 1);

	if (status->idFluxo != -1) 
		montaUpdate("idFluxo", oDados.idFluxo, 1);

	if (status->nmURLDestino != -1)
		montaUpdate("nmURLDestino", dados->nmURLDestino, 2);

	if (status->nmFuncValidacao != -1)
		montaUpdate("nmFuncValidacao", dados->nmFuncValidacao, 2);

	sprintf(query, "%s WHERE idFluxoFase = %i", query, dados->idFluxoFase);

	EXEC SQL EXECUTE IMMEDIATE :query;

   ULOG_END("proCFFAlterarWFFluxoFase()");
   
	return true;
}

bool proCFFExcluirWFFluxoFase(st_FluxoFase* dados, st_vlFluxoFase* status, XMLGen* saida)
{
   ULOG_START("proCFFExcluirWFFluxoFase()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idFluxoFase = dados->idFluxoFase;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);

	EXEC SQL 
		DELETE
			workflow.FluxoFase
		WHERE
			idFluxoFase = :idFluxoFase;

   ULOG_END("proCFFExcluirWFFluxoFase()");

	return true;
}

bool proCFFConsultaWFFluxoFase(st_FluxoFase* dados, st_vlFluxoFase* status, char* order, XMLGen* saida)
{
   ULOG_START("proCFFConsultaWFFluxoFase()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idFluxoFase;
		int idFase;
		int idFluxo;
		VARCHAR nmURLDestino[256];
		VARCHAR nmFuncValidacao[256];

		char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFEstado(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	sprintf(query,"SELECT idFluxoFase, idFase, idFluxo, nmURLDestino, nmFuncValidacao FROM workflow.FluxoFase ");

	bool separa = false;

	if (status->idFluxoFase != -1) 
		montaWhere("idFluxoFase", dados->idFluxoFase, 1);

	if (status->idFase != -1)
		montaWhere("idFase", dados->idFase, 1);

	if (status->idFluxo != -1)
		montaWhere("idFluxo", dados->idFluxo, 1);

	if (status->nmURLDestino != -1)
		montaWhere("nmURLDestino", dados->nmURLDestino, 2);

	if (status->nmFuncValidacao != -1)
		montaWhere("nmFuncValidacao", dados->nmFuncValidacao, 2);

	if (strlen(order) > 0) 
		sprintf( query, "%s ORDER BY %s ", query, order);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);

	EXEC SQL PREPARE consultaFluxoFase FROM :query;
	EXEC SQL DECLARE consulta CURSOR FOR consultaFluxoFase;

	EXEC SQL OPEN consulta;

	while (true)
	{
		EXEC SQL FETCH consulta INTO :idFluxoFase, :idFase, :idFluxo, :nmURLDestino, :nmFuncValidacao;

		CONV(nmURLDestino);
		CONV(nmFuncValidacao);

		saida->createTag("WFFluxoFaseVO");
			saida->addItem("idFluxoFase", idFluxoFase);
			saida->addItem("idFase", idFase);
			saida->addItem("idFluxo", idFluxo);
			saida->addItem("nmURLDestino", (char *)nmURLDestino.arr);
			saida->addItem("nmFuncValidacao", (char *)nmFuncValidacao.arr);
		saida->closeTag();
	}

	EXEC SQL CLOSE consulta;

   ULOG_END("proCFFConsultaWFFluxoFase()");

	return true;
}

bool proCFFObtemWFFluxo(int sIdContato, int sIdAtividade, int sIdPessoaUsuario, int sIdAgrupamentoEstadoTpProc, XMLGen* saida)
{
   ULOG_START("proCFFObtemWFFluxo()");

	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		int  idPessoaUsuario = sIdPessoaUsuario;
		int  idContato = sIdContato;
		int  idAtividade = sIdAtividade;
		int  idAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;
		int  idFluxoFase;
		VARCHAR dsAtividade[256];
		VARCHAR nmFuncValidacao[256];
		VARCHAR nmUrlDestino[256];
		int  idAgrupamentoEstadoTpProcFt;
		VARCHAR dsSubEstado[256];
		int  idSubEstado;
		
		short i_idFluxoFase;
		short i_dsAtividade;
		short i_idAtividade;
		short i_nmFuncValidacao;
		short i_idAgrupamentoEstadoTpProcFt;
		short i_nmUrlDestino;
		short i_dsSubEstado;
		short i_idSubEstado;

    EXEC SQL END DECLARE SECTION;

    ULOG("idPessoaUsuario=%d",idPessoaUsuario);

    ULOG("idContato=%d",idContato);

    ULOG("idAtividade=%d",idAtividade);

    ULOG("idAgrupamentoEstadoTpProc=%d",idAgrupamentoEstadoTpProc);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE consultaFluxo CURSOR FOR
	SELECT DISTINCT
		IDFLUXOFASE, 
		DSATIVIDADE, 
		IDATIVIDADE,
		NMURLDESTINO,
		IDAGRUPAMENTOESTADOTPPROCFT, 
		NMFUNCVALIDACAO,
		IDSUBESTADO,
		DSSUBESTADO
	FROM 
		WORKFLOW.FLUXOACOESV01
	WHERE 
        // =====================================================================
        // Não será mais necessário verificar se o usuário faz parte do grupo
        // A verificação deste parâmetro associada a regra de permitir que usuários
        // desassociados do grupo estava gerando um tempo de execução
        // inviável em produção com a entrada dos parâmetros de CRI.
        // Alteração acordada com a Tatiana em 04/04/2006.
        // Abril de 2006, Cassio
        //
		// IDPESSOAUSUARIO = :idPessoaUsuario
        // =====================================================================
		    IDCONTATO = :idContato
		AND IDATIVIDADE = :idAtividade
		AND IDAGRUPAMENTOESTADOTPPROC = :idAgrupamentoEstadoTpProc
	ORDER BY
		IDATIVIDADE;
	
	EXEC SQL OPEN consultaFluxo;


	while (true)
	{
		EXEC SQL FETCH consultaFluxo INTO
			:idFluxoFase:i_idFluxoFase,
			:dsAtividade:i_dsAtividade,
			:idAtividade:i_idAtividade,
			:nmUrlDestino:i_nmUrlDestino,
			:idAgrupamentoEstadoTpProcFt:i_idAgrupamentoEstadoTpProcFt,
			:nmFuncValidacao:i_nmFuncValidacao,
			:idSubEstado:i_idSubEstado,
			:dsSubEstado:i_dsSubEstado;
						
		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmUrlDestino, i_nmUrlDestino);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);
		CONVIND(dsSubEstado, i_dsSubEstado);

		saida->createTag("WFAcoesVO");
	
			saida->addItem("idFluxoFase", idFluxoFase);
			saida->addItem("dsAtividade", (char *)dsAtividade.arr);
			saida->addItem("idAtividade", idAtividade);
			saida->addItem("idAgEstTpProcFt", idAgrupamentoEstadoTpProcFt);
			saida->addItem("nmUrlDestino", (char *)nmUrlDestino.arr);
			saida->addItem("nmFuncValidacao", (char *)nmFuncValidacao.arr);
			saida->addItem("idSubEstado", idSubEstado);
			saida->addItem("dsSubEstado", (char *)dsSubEstado.arr);
			
		saida->closeTag();

	}

	EXEC SQL CLOSE consultaFluxo;

    ULOG_END("proCFFObtemWFFluxo()");
	
    return true;
}

bool proCFFObtemWFFluxoPout(int sIdAtividade,int sIdAgrupamentoEstadoTpProc,XMLGen* saida)
{
   ULOG_START("proCFFObtemWFFluxoPout()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        int prmOraIdAtividade = sIdAtividade;
        int prmOraIdAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;

        struct
        {
            VARCHAR idFluxoFase[21];
            VARCHAR idAtividade[21];
            VARCHAR dsAtividade[256];
            VARCHAR nmUrlDestino[256];
            VARCHAR nmFuncValidacao[256];
            VARCHAR idAgrupamentoEstadoTpProcFt[21];
            VARCHAR idSubEstado[21];
            VARCHAR dsSubEstado[256];
        } varOraFFase;

        struct
        {
            short idFluxoFase;
            short idAtividade;
            short dsAtividade;
            short nmUrlDestino;
            short nmFuncValidacao;
            short idAgrupamentoEstadoTpProcFt;
            short idSubEstado;
            short dsSubEstado;
        } statOraFFase;

    EXEC SQL END DECLARE SECTION;

    ULOG("idAtividade=%d",prmOraIdAtividade);
    ULOG("idAgrupamentoEstadoTpProc=%d",prmOraIdAgrupamentoEstadoTpProc);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE consultaFluxoPout CURSOR FOR
        SELECT DISTINCT
            IDFLUXOFASE,
            IDATIVIDADE,
            DSATIVIDADE,
            NMURLDESTINO,
            NMFUNCVALIDACAO,
            IDAGRUPAMENTOESTADOTPPROCFT,
            IDSUBESTADO,
            DSSUBESTADO
        FROM
            WORKFLOW.FLUXOACOESPOUTV01
        WHERE
            IDATIVIDADE = :prmOraIdAtividade
        AND IDAGRUPAMENTOESTADOTPPROC = :prmOraIdAgrupamentoEstadoTpProc
        ORDER BY
            IDATIVIDADE;

    EXEC SQL OPEN consultaFluxoPout;

    while (true)
    {
        memset(&varOraFFase,0,sizeof(varOraFFase));
        memset(&statOraFFase,-1,sizeof(statOraFFase));

        EXEC SQL FETCH consultaFluxoPout INTO :varOraFFase:statOraFFase;

        CONVIND(varOraFFase.idFluxoFase,statOraFFase.idFluxoFase);
        CONVIND(varOraFFase.idAtividade,statOraFFase.idAtividade);
        CONVIND(varOraFFase.dsAtividade,statOraFFase.dsAtividade);
        CONVIND(varOraFFase.nmUrlDestino,statOraFFase.nmUrlDestino);
        CONVIND(varOraFFase.nmFuncValidacao,statOraFFase.nmFuncValidacao);
        CONVIND(varOraFFase.idAgrupamentoEstadoTpProcFt,statOraFFase.idAgrupamentoEstadoTpProcFt);
        CONVIND(varOraFFase.idSubEstado,statOraFFase.idSubEstado);
        CONVIND(varOraFFase.dsSubEstado,statOraFFase.dsSubEstado);

        if ( saida )
        {
            saida->createTag("WFAcoesVO");
            saida->addItem("idFluxoFase",(char*)varOraFFase.idFluxoFase.arr);
                saida->addItem("dsAtividade",(char*)varOraFFase.dsAtividade.arr);
                saida->addItem("idAtividade",(char*)varOraFFase.idAtividade.arr);
                saida->addItem("idAgEstTpProcFt",(char*)varOraFFase.idAgrupamentoEstadoTpProcFt.arr);
                saida->addItem("nmUrlDestino",(char*)varOraFFase.nmUrlDestino.arr);
                saida->addItem("nmFuncValidacao",(char*)varOraFFase.nmFuncValidacao.arr);
                saida->addItem("idSubEstado",(char*)varOraFFase.idSubEstado.arr);
                saida->addItem("dsSubEstado",(char*)varOraFFase.dsSubEstado.arr);
            saida->closeTag();
        }
    }

    EXEC SQL CLOSE consultaFluxoPout;

    ULOG_END("proCFFObtemWFFluxoPout()");

    return true;
}

bool proCFFObtemWFFluxoRC(int sIdAtividade,int sIdAgrupamentoEstadoTpProc, XMLGen* saida)
{
   ULOG_START("proCFFObtemWFFluxoRC()");

	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		int  idAtividade = sIdAtividade;
		int  idAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;
		int  idFluxoFase;
		VARCHAR dsAtividade[256];
		VARCHAR nmFuncValidacao[256];
		VARCHAR nmUrlDestino[256];
		int  idAgrupamentoEstadoTpProcFt;
		VARCHAR dsSubEstado[256];
		int  idSubEstado;
		
		short i_idFluxoFase;
		short i_dsAtividade;
		short i_idAtividade;
		short i_nmFuncValidacao;
		short i_idAgrupamentoEstadoTpProcFt;
		short i_nmUrlDestino;
		short i_dsSubEstado;
		short i_idSubEstado;

    EXEC SQL END DECLARE SECTION;

    ULOG("idAtividade=%d",idAtividade);

    ULOG("idAgrupamentoEstadoTpProc=%d",idAgrupamentoEstadoTpProc);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE consultaFluxoRC CURSOR FOR
	SELECT DISTINCT
		  IDFLUXOFASE,
		  DSATIVIDADE,
		  IDATIVIDADE,
		  NMURLDESTINO,
		  IDAGRUPAMENTOESTADOTPPROCFT,
		  NMFUNCVALIDACAO,
		  IDSUBESTADO,
		  DSSUBESTADO
	FROM
		  WORKFLOW.FLUXOACOESRCV01
	WHERE
		  IDATIVIDADE = :idAtividade
      //AND IDAGRUPAMENTOESTADOTPPROC = :idAgrupamentoEstadoTpProc
      AND ROWNUM < 2
	ORDER BY
		IDATIVIDADE;

	EXEC SQL OPEN consultaFluxoRC;

	while (true)
	{
		EXEC SQL FETCH consultaFluxoRC INTO
			:idFluxoFase:i_idFluxoFase,
			:dsAtividade:i_dsAtividade,
			:idAtividade:i_idAtividade,
			:nmUrlDestino:i_nmUrlDestino,
			:idAgrupamentoEstadoTpProcFt:i_idAgrupamentoEstadoTpProcFt,
			:nmFuncValidacao:i_nmFuncValidacao,
			:idSubEstado:i_idSubEstado,
			:dsSubEstado:i_dsSubEstado;

		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmUrlDestino, i_nmUrlDestino);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);
		CONVIND(dsSubEstado, i_dsSubEstado);

		saida->createTag("WFAcoesVO");
	
			saida->addItem("idFluxoFase", idFluxoFase);
			saida->addItem("dsAtividade", (char *)dsAtividade.arr);
			saida->addItem("idAtividade", idAtividade);
			saida->addItem("idAgEstTpProcFt", idAgrupamentoEstadoTpProcFt);
			saida->addItem("nmUrlDestino", (char *)nmUrlDestino.arr);
			saida->addItem("nmFuncValidacao", (char *)nmFuncValidacao.arr);
			saida->addItem("idSubEstado", idSubEstado);
			saida->addItem("dsSubEstado", (char *)dsSubEstado.arr);
			
		saida->closeTag();

	}

	EXEC SQL CLOSE consultaFluxoRC;

    ULOG_END("proCFFObtemWFFluxoRC()");
	
    return true;
}

bool proCFFObtemWFFluxoCri(int sIdContato, int sIdAtividade, int sIdPessoaUsuario, int sIdAgrupamentoEstadoTpProc, int sIdTipoRelacionamentoBko, XMLGen* saida)
{
   ULOG_START("proCFFObtemWFFluxoCri()");

	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		int  idPessoaUsuario = sIdPessoaUsuario;
		int  idContato = sIdContato;
		int  idAtividade = sIdAtividade;
		int  idAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;
		int  idTipoRelacionamentoBko = sIdTipoRelacionamentoBko;
		int  idFluxoFase;
		VARCHAR dsAtividade[256];
		VARCHAR nmFuncValidacao[256];
		VARCHAR nmUrlDestino[256];
		int  idAgrupamentoEstadoTpProcFt;
		VARCHAR dsSubEstado[256];
		int  idSubEstado;
		
		short i_idFluxoFase;
		short i_dsAtividade;
		short i_idAtividade;
		short i_nmFuncValidacao;
		short i_idAgrupamentoEstadoTpProcFt;
		short i_nmUrlDestino;
		short i_dsSubEstado;
		short i_idSubEstado;

    EXEC SQL END DECLARE SECTION;

    ULOG("idPessoaUsuario=%d",idPessoaUsuario);

    ULOG("idContato=%d",idContato);

    ULOG("idAtividade=%d",idAtividade);

    ULOG("idAgrupamentoEstadoTpProc=%d",idAgrupamentoEstadoTpProc);

    ULOG("idTipoRelacionamentoBko=%d",idTipoRelacionamentoBko);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE consultaFluxoCri CURSOR FOR
	SELECT DISTINCT
		IDFLUXOFASE, 
		DSATIVIDADE, 
		IDATIVIDADE,
		NMURLDESTINO,
		IDAGRUPAMENTOESTADOTPPROCFT, 
		NMFUNCVALIDACAO,
		IDSUBESTADO,
		DSSUBESTADO
	FROM 
		WORKFLOW.FLUXOACOESCRIV01
	WHERE 
        // =====================================================================
        // Não será mais necessário verificar se o usuário faz parte do grupo
        // A verificação deste parâmetro associada a regra de permitir que usuários
        // desassociados do grupo estava gerando um tempo de execução
        // inviável em produção com a entrada dos parâmetros de CRI.
        // Alteração acordada com a Tatiana em 04/04/2006.
        // Abril de 2006, Cassio
        //
		// IDPESSOAUSUARIO = :idPessoaUsuario
        // =====================================================================
        // O idContato foi removido da view de fluxo de ações do CRI pois este
        // pois grupos CRI não são configurados para contatos.
		// IDCONTATO = :idContato
		    IDATIVIDADE = :idAtividade
		AND IDAGRUPAMENTOESTADOTPPROC = :idAgrupamentoEstadoTpProc
		AND IDTIPORELACIONAMENTOBKO = :idTipoRelacionamentoBko
	ORDER BY
		IDATIVIDADE;
	
	EXEC SQL OPEN consultaFluxoCri;


	while (true)
	{
		EXEC SQL FETCH consultaFluxoCri INTO
			:idFluxoFase:i_idFluxoFase,
			:dsAtividade:i_dsAtividade,
			:idAtividade:i_idAtividade,
			:nmUrlDestino:i_nmUrlDestino,
			:idAgrupamentoEstadoTpProcFt:i_idAgrupamentoEstadoTpProcFt,
			:nmFuncValidacao:i_nmFuncValidacao,
			:idSubEstado:i_idSubEstado,
			:dsSubEstado:i_dsSubEstado;
						
		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmUrlDestino, i_nmUrlDestino);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);
		CONVIND(dsSubEstado, i_dsSubEstado);

		saida->createTag("WFAcoesVO");
	
			saida->addItem("idFluxoFase", idFluxoFase);
			saida->addItem("dsAtividade", (char *)dsAtividade.arr);
			saida->addItem("idAtividade", idAtividade);
			saida->addItem("idAgEstTpProcFt", idAgrupamentoEstadoTpProcFt);
			saida->addItem("nmUrlDestino", (char *)nmUrlDestino.arr);
			saida->addItem("nmFuncValidacao", (char *)nmFuncValidacao.arr);
			saida->addItem("idSubEstado", idSubEstado);
			saida->addItem("dsSubEstado", (char *)dsSubEstado.arr);
			
		saida->closeTag();

	}

	EXEC SQL CLOSE consultaFluxoCri;

   ULOG_END("proCFFObtemWFFluxoCri()");

	return true;
}

bool proCFFObtemWFFluxoFuturo(int sIdContato, int sIdAtividade, int sIdPessoaUsuario, int sIdAgrupamentoEstadoTpProc, int sIdAgrupamentoEstadoTpProcFt, int sIdFase, XMLGen* saida)
{
   ULOG_START("proCFFObtemWFFluxoFuturo()");

	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		int  idPessoaUsuario = sIdPessoaUsuario;
		int  idContato = sIdContato;
		int  idAtividade = sIdAtividade;
		int  idAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;
		int  idAgrupamentoEstadoTpProcFt = sIdAgrupamentoEstadoTpProcFt;
		int  idFase = sIdFase;
		int  idFluxoFase;
		VARCHAR dsAtividade[256];
		VARCHAR nmFuncValidacao[256];
		VARCHAR nmUrlDestino[256];
		VARCHAR dsSubEstado[256];
		int  idSubEstado;
		
		short i_idFluxoFase;
		short i_dsAtividade;
		short i_idAtividade;
		short i_nmFuncValidacao;
		short i_nmUrlDestino;
		short i_dsSubEstado;
		short i_idSubEstado;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;


    ULOG("idPessoaUsuario=%d",idPessoaUsuario);

    ULOG("idContato=%d",idContato);

    ULOG("idAtividade=%d",idAtividade);

    ULOG("idAgrupamentoEstadoTpProc=%d",idAgrupamentoEstadoTpProc);

    ULOG("idAgrupamentoEstadoTpProcFt=%d",idAgrupamentoEstadoTpProcFt);

    ULOG("idFase=%d",idFase);

    EXEC SQL DECLARE consultaFluxoFuturo CURSOR FOR
	SELECT  DISTINCT
		IDFLUXOFASE, 
		DSATIVIDADE, 
		IDATIVIDADE,
		NMURLDESTINO,
		NMFUNCVALIDACAO,
		IDSUBESTADO,
		DSSUBESTADO
	FROM 
		WORKFLOW.FLUXOACOESV01
	WHERE 
        // =====================================================================
        // Não será mais necessário verificar se o usuário faz parte do grupo
        // A verificação deste parâmetro associada a regra de permitir que usuários
        // desassociados do grupo estava gerando um tempo de execução
        // inviável em produção com a entrada dos parâmetros de CRI.
        // Alteração acordada com a Tatiana em 04/04/2006.
        // Abril de 2006, Cassio
        //
		// IDPESSOAUSUARIO = :idPessoaUsuario
        // =====================================================================
		    IDCONTATO = :idContato
		AND IDATIVIDADE = :idAtividade
		AND IDAGRUPAMENTOESTADOTPPROC = :idAgrupamentoEstadoTpProc
		AND IDAGRUPAMENTOESTADOTPPROCFT = :idAgrupamentoEstadoTpProcFt
		AND IDFASE = :idFase
	ORDER BY
		IDATIVIDADE;
	
	EXEC SQL OPEN consultaFluxoFuturo;


	while (true)
	{
		EXEC SQL FETCH consultaFluxoFuturo INTO
			:idFluxoFase:i_idFluxoFase,
			:dsAtividade:i_dsAtividade,
			:idAtividade:i_idAtividade,
			:nmUrlDestino:i_nmUrlDestino,
			:nmFuncValidacao:i_nmFuncValidacao,
			:idSubEstado:i_idSubEstado,
			:dsSubEstado:i_dsSubEstado;
						
		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmUrlDestino, i_nmUrlDestino);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);
		CONVIND(dsSubEstado, i_dsSubEstado);

		saida->createTag("WFAcoesVO");
	
			saida->addItem("idFluxoFase", idFluxoFase);
			saida->addItem("dsAtividade", (char *)dsAtividade.arr);
			saida->addItem("idAtividade", idAtividade);
			saida->addItem("idAgEstTpProcFt", idAgrupamentoEstadoTpProcFt);
			saida->addItem("nmUrlDestino", (char *)nmUrlDestino.arr);
			saida->addItem("nmFuncValidacao", (char *)nmFuncValidacao.arr);
			saida->addItem("idSubEstado", idSubEstado);
			saida->addItem("dsSubEstado", (char *)dsSubEstado.arr);
			
		saida->closeTag();

	}

	EXEC SQL CLOSE consultaFluxoFuturo;

   ULOG_END("proCFFObtemWFFluxoFuturo()");

	return true;
}

bool proCFFObtemWFFluxoFuturoRC(int sIdAtividade
                               ,int sIdAgrupamentoEstadoTpProc
                               ,int sIdAgrupamentoEstadoTpProcFt
                               ,int sIdFase
                               ,XMLGen* saida)
{
   ULOG_START("proCFFObtemWFFluxoFuturoRC()");

	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		int  idAtividade = sIdAtividade;
		int  idAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;
		int  idAgrupamentoEstadoTpProcFt = sIdAgrupamentoEstadoTpProcFt;
		int  idFase = sIdFase;
		int  idFluxoFase;
		VARCHAR dsAtividade[256];
		VARCHAR nmFuncValidacao[256];
		VARCHAR nmUrlDestino[256];
		VARCHAR dsSubEstado[256];
		int  idSubEstado;
		
		short i_idFluxoFase;
		short i_dsAtividade;
		short i_idAtividade;
		short i_nmFuncValidacao;
		short i_nmUrlDestino;
		short i_dsSubEstado;
		short i_idSubEstado;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

    ULOG("idAtividade=%d",idAtividade);

    ULOG("idAgrupamentoEstadoTpProc=%d",idAgrupamentoEstadoTpProc);

    ULOG("idAgrupamentoEstadoTpProcFt=%d",idAgrupamentoEstadoTpProcFt);

    ULOG("idFase=%d",idFase);

    EXEC SQL DECLARE consultaFluxoFuturoRC CURSOR FOR
	SELECT  DISTINCT
		IDFLUXOFASE,
		DSATIVIDADE,
		IDATIVIDADE,
		NMURLDESTINO,
		NMFUNCVALIDACAO,
		IDSUBESTADO,
		DSSUBESTADO
	FROM 
		WORKFLOW.FLUXOACOESRCV01
	WHERE 
		    IDATIVIDADE = :idAtividade
		AND IDAGRUPAMENTOESTADOTPPROC = :idAgrupamentoEstadoTpProc
		AND IDAGRUPAMENTOESTADOTPPROCFT = :idAgrupamentoEstadoTpProcFt
		AND IDFASE = :idFase
        AND ROWNUM < 2
	ORDER BY
		IDATIVIDADE;
	
	EXEC SQL OPEN consultaFluxoFuturoRC;

	while (true)
	{
		EXEC SQL FETCH consultaFluxoFuturoRC INTO
			:idFluxoFase:i_idFluxoFase,
			:dsAtividade:i_dsAtividade,
			:idAtividade:i_idAtividade,
			:nmUrlDestino:i_nmUrlDestino,
			:nmFuncValidacao:i_nmFuncValidacao,
			:idSubEstado:i_idSubEstado,
			:dsSubEstado:i_dsSubEstado;
						
		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmUrlDestino, i_nmUrlDestino);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);
		CONVIND(dsSubEstado, i_dsSubEstado);

		saida->createTag("WFAcoesVO");
	
			saida->addItem("idFluxoFase", idFluxoFase);
			saida->addItem("dsAtividade", (char *)dsAtividade.arr);
			saida->addItem("idAtividade", idAtividade);
			saida->addItem("idAgEstTpProcFt", idAgrupamentoEstadoTpProcFt);
			saida->addItem("nmUrlDestino", (char *)nmUrlDestino.arr);
			saida->addItem("nmFuncValidacao", (char *)nmFuncValidacao.arr);
			saida->addItem("idSubEstado", idSubEstado);
			saida->addItem("dsSubEstado", (char *)dsSubEstado.arr);
			
		saida->closeTag();

	}

	EXEC SQL CLOSE consultaFluxoFuturoRC;

   ULOG_END("proCFFObtemWFFluxoFuturoRC()");

	return true;
}

bool proCFFObtemWFFluxoFuturoBko(int sIdContato, int sIdAtividade, int sIdPessoaUsuario, int sIdAgrupamentoEstadoTpProc, int sIdAgrupamentoEstadoTpProcFt, int sIdFase, int sIdTipoRelacionamentoBko, XMLGen* saida)
{
   ULOG_START("proCFFObtemWFFluxoFuturoBko()");

	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		int  idPessoaUsuario = sIdPessoaUsuario;
		int  idContato = sIdContato;
		int  idAtividade = sIdAtividade;
		int  idAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;
		int  idAgrupamentoEstadoTpProcFt = sIdAgrupamentoEstadoTpProcFt;
		int  idFase = sIdFase;
		int  idTipoRelacionamento = sIdTipoRelacionamentoBko;
		int  idFluxoFase;
		VARCHAR dsAtividade[256];
		VARCHAR nmFuncValidacao[256];
		VARCHAR nmUrlDestino[256];
		VARCHAR dsSubEstado[256];
		int  idSubEstado;
		
		short i_idFluxoFase;
		short i_dsAtividade;
		short i_idAtividade;
		short i_nmFuncValidacao;
		short i_nmUrlDestino;
		short i_dsSubEstado;
		short i_idSubEstado;

    EXEC SQL END DECLARE SECTION;

    ULOG("idPessoaUsuario=%d",idPessoaUsuario);

    ULOG("idContato=%d",idContato);

    ULOG("idAtividade=%d",idAtividade);

    ULOG("idAgrupamentoEstadoTpProc=%d",idAgrupamentoEstadoTpProc);

    ULOG("idAgrupamentoEstadoTpProcFt=%d",idAgrupamentoEstadoTpProcFt);

    ULOG("idFase=%d",idFase);

    ULOG("idTipoRelacionamento=%d",idTipoRelacionamento);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE consultaFluxoFuturoBko CURSOR FOR
	SELECT  DISTINCT
		IDFLUXOFASE, 
		DSATIVIDADE, 
		IDATIVIDADE,
		NMURLDESTINO,
		NMFUNCVALIDACAO,
		IDSUBESTADO,
		DSSUBESTADO
	FROM 
		WORKFLOW.FLUXOACOESBKOV01
	WHERE 
        // =====================================================================
        // Não será mais necessário verificar se o usuário faz parte do grupo
        // A verificação deste parâmetro associada a regra de permitir que usuários
        // desassociados do grupo estava gerando um tempo de execução
        // inviável em produção com a entrada dos parâmetros de CRI.
        // Alteração acordada com a Tatiana em 04/04/2006.
        // Abril de 2006, Cassio
        //
		// IDPESSOAUSUARIO = :idPessoaUsuario
        // =====================================================================
		    IDCONTATO = :idContato
		AND IDATIVIDADE = :idAtividade
		AND IDAGRUPAMENTOESTADOTPPROC = :idAgrupamentoEstadoTpProc
		AND IDAGRUPAMENTOESTADOTPPROCFT = :idAgrupamentoEstadoTpProcFt
		AND IDFASE = :idFase
		AND IDTIPORELACIONAMENTOBKO = :idTipoRelacionamento
	ORDER BY
		IDATIVIDADE;
	
	EXEC SQL OPEN consultaFluxoFuturoBko;

	while (true)
	{
		EXEC SQL FETCH consultaFluxoFuturoBko INTO
			:idFluxoFase:i_idFluxoFase,
			:dsAtividade:i_dsAtividade,
			:idAtividade:i_idAtividade,
			:nmUrlDestino:i_nmUrlDestino,
			:nmFuncValidacao:i_nmFuncValidacao,
			:idSubEstado:i_idSubEstado,
			:dsSubEstado:i_dsSubEstado;
						
		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmUrlDestino, i_nmUrlDestino);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);
		CONVIND(dsSubEstado, i_dsSubEstado);

		saida->createTag("WFAcoesVO");
	
			saida->addItem("idFluxoFase", idFluxoFase);
			saida->addItem("dsAtividade", (char *)dsAtividade.arr);
			saida->addItem("idAtividade", idAtividade);
			saida->addItem("idAgEstTpProcFt", idAgrupamentoEstadoTpProcFt);
			saida->addItem("nmUrlDestino", (char *)nmUrlDestino.arr);
			saida->addItem("nmFuncValidacao", (char *)nmFuncValidacao.arr);
			saida->addItem("idSubEstado", idSubEstado);
			saida->addItem("dsSubEstado", (char *)dsSubEstado.arr);
			
		saida->closeTag();

	}

	EXEC SQL CLOSE consultaFluxoFuturoBko;

   ULOG_END("proCFFObtemWFFluxoFuturoBko()");

	return true;
}


bool proCFFObtemWFFluxoFuturoBkoRC(int sIdAtividade
                                  ,int sIdAgrupamentoEstadoTpProc
                                  ,int sIdAgrupamentoEstadoTpProcFt
                                  ,int sIdFase
                                  ,int sIdTipoRelacionamentoBko
                                  ,XMLGen* saida)
{
   ULOG_START("proCFFObtemWFFluxoFuturoBkoRC()");

	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		int  idAtividade = sIdAtividade;
		int  idAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;
		int  idAgrupamentoEstadoTpProcFt = sIdAgrupamentoEstadoTpProcFt;
		int  idFase = sIdFase;
		int  idTipoRelacionamento = sIdTipoRelacionamentoBko;
		int  idFluxoFase;
		VARCHAR dsAtividade[256];
		VARCHAR nmFuncValidacao[256];
		VARCHAR nmUrlDestino[256];
		VARCHAR dsSubEstado[256];
		int  idSubEstado;
		
		short i_idFluxoFase;
		short i_dsAtividade;
		short i_idAtividade;
		short i_nmFuncValidacao;
		short i_nmUrlDestino;
		short i_dsSubEstado;
		short i_idSubEstado;

    EXEC SQL END DECLARE SECTION;

    ULOG("idAtividade=%d",idAtividade);

    ULOG("idAgrupamentoEstadoTpProcFt=%d",idAgrupamentoEstadoTpProcFt);

    ULOG("idFase=%d",idFase);

    ULOG("idTipoRelacionamento=%d",idTipoRelacionamento);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE cursorConsFFBKORC CURSOR FOR
	SELECT  DISTINCT
		    IDFLUXOFASE, 
		    DSATIVIDADE, 
		    IDATIVIDADE,
		    NMURLDESTINO,
		    NMFUNCVALIDACAO,
		    IDSUBESTADO,
		    DSSUBESTADO
	FROM 
		    WORKFLOW.FLUXOACOESBKORCV01
	WHERE 
		    IDATIVIDADE = :idAtividade
		//AND IDFASE = :idFase
		//AND IDTIPORELACIONAMENTOBKO = :idTipoRelacionamento
        AND ROWNUM < 2
	ORDER BY
		IDATIVIDADE;
	
	EXEC SQL OPEN cursorConsFFBKORC;

	while (true)
	{
		EXEC SQL FETCH cursorConsFFBKORC INTO
			:idFluxoFase:i_idFluxoFase,
			:dsAtividade:i_dsAtividade,
			:idAtividade:i_idAtividade,
			:nmUrlDestino:i_nmUrlDestino,
			:nmFuncValidacao:i_nmFuncValidacao,
			:idSubEstado:i_idSubEstado,
			:dsSubEstado:i_dsSubEstado;
						
		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmUrlDestino, i_nmUrlDestino);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);
		CONVIND(dsSubEstado, i_dsSubEstado);

		saida->createTag("WFAcoesVO");
	
			saida->addItem("idFluxoFase", idFluxoFase);
			saida->addItem("dsAtividade", (char *)dsAtividade.arr);
			saida->addItem("idAtividade", idAtividade);
			saida->addItem("idAgEstTpProcFt", idAgrupamentoEstadoTpProcFt);
			saida->addItem("nmUrlDestino", (char *)nmUrlDestino.arr);
			saida->addItem("nmFuncValidacao", (char *)nmFuncValidacao.arr);
			saida->addItem("idSubEstado", idSubEstado);
			saida->addItem("dsSubEstado", (char *)dsSubEstado.arr);
			
		saida->closeTag();

	}

	EXEC SQL CLOSE cursorConsFFBKORC;

   ULOG_END("proCFFObtemWFFluxoFuturoBkoRC()");

	return true;
}

bool proCFFObtemWFFluxoFuturoCri(int sIdContato, int sIdAtividade, int sIdPessoaUsuario, int sIdAgrupamentoEstadoTpProc, int sIdAgrupamentoEstadoTpProcFt, int sIdFase, int sIdTipoRelacionamentoBko, XMLGen* saida)
{
   ULOG_START("proCFFObtemWFFluxoFuturoCri()");

	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		int  idPessoaUsuario = sIdPessoaUsuario;
		int  idContato = sIdContato;
		int  idAtividade = sIdAtividade;
		int  idAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;
		int  idAgrupamentoEstadoTpProcFt = sIdAgrupamentoEstadoTpProcFt;
		int  idFase = sIdFase;
		int  idTipoRelacionamento = sIdTipoRelacionamentoBko;
		int  idFluxoFase;
		VARCHAR dsAtividade[256];
		VARCHAR nmFuncValidacao[256];
		VARCHAR nmUrlDestino[256];
		VARCHAR dsSubEstado[256];
		int  idSubEstado;
		
		short i_idFluxoFase;
		short i_dsAtividade;
		short i_idAtividade;
		short i_nmFuncValidacao;
		short i_nmUrlDestino;
		short i_dsSubEstado;
		short i_idSubEstado;

    EXEC SQL END DECLARE SECTION;

    ULOG("idPessoaUsuario=%d",idPessoaUsuario);

    ULOG("idContato=%d",idContato);

    ULOG("idAtividade=%d",idAtividade);

    ULOG("idAgrupamentoEstadoTpProc=%d",idAgrupamentoEstadoTpProc);

    ULOG("idAgrupamentoEstadoTpProcFt=%d",idAgrupamentoEstadoTpProcFt);

    ULOG("idFase=%d",idFase);

    ULOG("idTipoRelacionamento=%d",idTipoRelacionamento);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE consultaFluxoFuturoCri CURSOR FOR
	SELECT  DISTINCT
		IDFLUXOFASE, 
		DSATIVIDADE, 
		IDATIVIDADE,
		NMURLDESTINO,
		NMFUNCVALIDACAO,
		IDSUBESTADO,
		DSSUBESTADO
	FROM 
		WORKFLOW.FLUXOACOESCRIV01
	WHERE 
        // =====================================================================
        // Não será mais necessário verificar se o usuário faz parte do grupo
        // A verificação deste parâmetro associada a regra de permitir que usuários
        // desassociados do grupo estava gerando um tempo de execução
        // inviável em produção com a entrada dos parâmetros de CRI.
        // Alteração acordada com a Tatiana em 04/04/2006.
        // Abril de 2006, Cassio
        //
		// IDPESSOAUSUARIO = :idPessoaUsuario
        // =====================================================================
        // O idContato foi removido da view de fluxo de ações do CRI pois este
        // pois grupos CRI não são configurados para contatos.
		// IDCONTATO = :idContato
		    IDATIVIDADE = :idAtividade
		AND IDAGRUPAMENTOESTADOTPPROC = :idAgrupamentoEstadoTpProc
		AND IDAGRUPAMENTOESTADOTPPROCFT = :idAgrupamentoEstadoTpProcFt
		AND IDFASE = :idFase
		AND IDTIPORELACIONAMENTOBKO = :idTipoRelacionamento
	ORDER BY
		IDATIVIDADE;
	
	EXEC SQL OPEN consultaFluxoFuturoCri;

	while (true)
	{
		EXEC SQL FETCH consultaFluxoFuturoCri INTO
			:idFluxoFase:i_idFluxoFase,
			:dsAtividade:i_dsAtividade,
			:idAtividade:i_idAtividade,
			:nmUrlDestino:i_nmUrlDestino,
			:nmFuncValidacao:i_nmFuncValidacao,
			:idSubEstado:i_idSubEstado,
			:dsSubEstado:i_dsSubEstado;
						
		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmUrlDestino, i_nmUrlDestino);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);
		CONVIND(dsSubEstado, i_dsSubEstado);

		saida->createTag("WFAcoesVO");
	
			saida->addItem("idFluxoFase", idFluxoFase);
			saida->addItem("dsAtividade", (char *)dsAtividade.arr);
			saida->addItem("idAtividade", idAtividade);
			saida->addItem("idAgEstTpProcFt", idAgrupamentoEstadoTpProcFt);
			saida->addItem("nmUrlDestino", (char *)nmUrlDestino.arr);
			saida->addItem("nmFuncValidacao", (char *)nmFuncValidacao.arr);
			saida->addItem("idSubEstado", idSubEstado);
			saida->addItem("dsSubEstado", (char *)dsSubEstado.arr);
			
		saida->closeTag();
	}

	EXEC SQL CLOSE consultaFluxoFuturoCri;

   ULOG_END("proCFFObtemWFFluxoFuturoCri()");

	return true;
}

bool proCFFObtemWFFluxoAtividade(int sIdContato, int sIdAtividade, int sIdAgrupamentoEstadoTpProc, XMLGen* saida)
{
   ULOG_START("proCFFObtemWFFluxoAtividade()");

	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		int  idContato = sIdContato;
		int  idAtividade = sIdAtividade;
		int  idAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;
		int  idFluxoFase;
		VARCHAR dsAtividade[256];
		VARCHAR nmFuncValidacao[256];
		VARCHAR nmUrlDestino[256];
		int  idAgrupamentoEstadoTpProcFt;
		VARCHAR dsSubEstado[256];
		int  idSubEstado;
		
		short i_idFluxoFase;
		short i_dsAtividade;
		short i_idAtividade;
		short i_nmFuncValidacao;
		short i_idAgrupamentoEstadoTpProcFt;
		short i_nmUrlDestino;
		short i_dsSubEstado;
		short i_idSubEstado;

    EXEC SQL END DECLARE SECTION;

    ULOG("idContato=%d",idContato);

    ULOG("idAtividade=%d",idAtividade);

    ULOG("idAgrupamentoEstadoTpProc=%d",idAgrupamentoEstadoTpProc);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE consultaFluxoAtividade CURSOR FOR
	SELECT DISTINCT
		IDFLUXOFASE, 
		DSATIVIDADE, 
		IDATIVIDADE,
		NMURLDESTINO,
		IDAGRUPAMENTOESTADOTPPROCFT, 
		NMFUNCVALIDACAO,
		IDSUBESTADO,
		DSSUBESTADO
	FROM 
		WORKFLOW.FLUXOACOESV01
	WHERE 
		IDCONTATO = :idContato
		AND IDATIVIDADE = :idAtividade
		AND IDAGRUPAMENTOESTADOTPPROC = :idAgrupamentoEstadoTpProc
	ORDER BY
		IDATIVIDADE;
	
	EXEC SQL OPEN consultaFluxoAtividade;


	while (true)
	{
		EXEC SQL FETCH consultaFluxoAtividade INTO
			:idFluxoFase:i_idFluxoFase,
			:dsAtividade:i_dsAtividade,
			:idAtividade:i_idAtividade,
			:nmUrlDestino:i_nmUrlDestino,
			:idAgrupamentoEstadoTpProcFt:i_idAgrupamentoEstadoTpProcFt,
			:nmFuncValidacao:i_nmFuncValidacao,
			:idSubEstado:i_idSubEstado,
			:dsSubEstado:i_dsSubEstado;
						
		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmUrlDestino, i_nmUrlDestino);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);
		CONVIND(dsSubEstado, i_dsSubEstado);

		saida->createTag("WFAcoesVO");
	
			saida->addItem("idFluxoFase", idFluxoFase);
			saida->addItem("dsAtividade", (char *)dsAtividade.arr);
			saida->addItem("idAtividade", idAtividade);
			saida->addItem("idAgEstTpProcFt", idAgrupamentoEstadoTpProcFt);
			saida->addItem("nmUrlDestino", (char *)nmUrlDestino.arr);
			saida->addItem("nmFuncValidacao", (char *)nmFuncValidacao.arr);
			saida->addItem("idSubEstado", idSubEstado);
			saida->addItem("dsSubEstado", (char *)dsSubEstado.arr);
			
		saida->closeTag();

	}

	EXEC SQL CLOSE consultaFluxoAtividade;

   ULOG_END("proCFFObtemWFFluxoAtividade()");

	return true;
}

bool proCFFObtemWFFluxoAtividadePout(int sIdContato, int sIdAtividade, int sIdAgrupamentoEstadoTpProc, XMLGen* saida)
{
   ULOG_START("proCFFObtemWFFluxoAtividadePout()");

	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		int  idContato = sIdContato;
		int  idAtividade = sIdAtividade;
		int  idAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;
		int  idFluxoFase;
		VARCHAR dsAtividade[256];
		VARCHAR nmFuncValidacao[256];
		VARCHAR nmUrlDestino[256];
		int  idAgrupamentoEstadoTpProcFt;
		VARCHAR dsSubEstado[256];
		int  idSubEstado;
		
		short i_idFluxoFase;
		short i_dsAtividade;
		short i_idAtividade;
		short i_nmFuncValidacao;
		short i_idAgrupamentoEstadoTpProcFt;
		short i_nmUrlDestino;
		short i_dsSubEstado;
		short i_idSubEstado;

    EXEC SQL END DECLARE SECTION;

    ULOG("idContato=%d",idContato);

    ULOG("idAtividade=%d",idAtividade);

    ULOG("idAgrupamentoEstadoTpProc=%d",idAgrupamentoEstadoTpProc);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE curFluxoFaseAtPout CURSOR FOR
	SELECT DISTINCT
		IDFLUXOFASE, 
		DSATIVIDADE, 
		IDATIVIDADE,
		NMURLDESTINO,
		IDAGRUPAMENTOESTADOTPPROCFT, 
		NMFUNCVALIDACAO,
		IDSUBESTADO,
		DSSUBESTADO
	FROM 
		WORKFLOW.FLUXOACOESPOUTV01
	WHERE 
		IDATIVIDADE = :idAtividade
    AND IDAGRUPAMENTOESTADOTPPROC = :idAgrupamentoEstadoTpProc
	ORDER BY
		IDATIVIDADE;
	
	EXEC SQL OPEN curFluxoFaseAtPout;

	while (true)
	{
		EXEC SQL FETCH curFluxoFaseAtPout INTO
			:idFluxoFase:i_idFluxoFase,
			:dsAtividade:i_dsAtividade,
			:idAtividade:i_idAtividade,
			:nmUrlDestino:i_nmUrlDestino,
			:idAgrupamentoEstadoTpProcFt:i_idAgrupamentoEstadoTpProcFt,
			:nmFuncValidacao:i_nmFuncValidacao,
			:idSubEstado:i_idSubEstado,
			:dsSubEstado:i_dsSubEstado;
						
		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmUrlDestino, i_nmUrlDestino);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);
		CONVIND(dsSubEstado, i_dsSubEstado);

		saida->createTag("WFAcoesVO");
			saida->addItem("idFluxoFase", idFluxoFase);
			saida->addItem("dsAtividade", (char *)dsAtividade.arr);
			saida->addItem("idAtividade", idAtividade);
			saida->addItem("idAgEstTpProcFt", idAgrupamentoEstadoTpProcFt);
			saida->addItem("nmUrlDestino", (char *)nmUrlDestino.arr);
			saida->addItem("nmFuncValidacao", (char *)nmFuncValidacao.arr);
			saida->addItem("idSubEstado", idSubEstado);
			saida->addItem("dsSubEstado", (char *)dsSubEstado.arr);
		saida->closeTag();
	}

    EXEC SQL CLOSE curFluxoFaseAtPout;

    ULOG_END("proCFFObtemWFFluxoAtividadePout()");

	return true;
}

bool proCFFObtemWFCancelamento(int sIdAtividade, int sIdFase, int sIdAgrupamentoEstadoTpProc, XMLGen* saida)
{
    ULOG_START("proCFFObtemWFCancelamento()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idFase = sIdFase;
		int idAtividade = sIdAtividade;
		int idAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;
        int idMotivo;
        int idAgrupamentoEstadoTpfuturo;
		VARCHAR dsMotivo[256];
		
        short i_idMotivo;
		short i_dsMotivo;
        short i_idAgrupamentoEstadoTpfuturo;

    EXEC SQL END DECLARE SECTION;

    ULOG("idFase=%d",idFase);
    ULOG("idAtividade=%d",idAtividade);
    ULOG("idAgrupamentoEstadoTpProc=%d",idAgrupamentoEstadoTpProc);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE consultaCancelamento CURSOR FOR
        SELECT DISTINCT
            MOTIVO.IDMOTIVO,
            MOTIVO.DSMOTIVO,
            FLUXO.IDAGRUPAMENTOESTADOTPPROC AS IDAGRUPAMENTOESTADOTPPROCFT
        FROM
            WORKFLOW.FLUXOFASE FLUXOFASE,
            WORKFLOW.FLUXO FLUXO,
            WORKFLOW.AGRUPESTADOATIVTIPOPROC AGRUPESTADOATIVTIPOPROC,
            WORKFLOW.AGRUPAMENTOESTADOATIVIDADE AGRUPAMENTOESTADOATIVIDADE,
            WORKFLOW.ATIVIDADE ATIVIDADE,
            WORKFLOW.AGRUPAMENTOESTADOTPPROC AGRUPAMENTOESTADOTPPROC,
            // -- CONTATOADM.SEQUENCIA SEQUENCIA,
            WORKFLOW.AGRPESTTPPROCMOTIVO AGRPESTTPPROCMOTIVO,
            ATENDIMENTO.MOTIVO MOTIVO,
            ATENDIMENTO.MOTIVOTABELAMOTIVO MOTIVOTABELAMOTIVO
        WHERE
             FLUXOFASE.NMFUNCVALIDACAO = 'cancelar()'
        AND  FLUXOFASE.IDFLUXO = FLUXO.IDFLUXO
        AND  FLUXO.IDAGRUPAMENTOESTADOATIVTIPOPR = AGRUPESTADOATIVTIPOPROC.IDAGRUPAMENTOESTADOATIVTIPOPR
        AND  FLUXO.IDAGRUPAMENTOESTADOTPPROC = AGRUPAMENTOESTADOTPPROC.IDAGRUPAMENTOESTADOTPPROC
        AND  AGRUPESTADOATIVTIPOPROC.IDAGRUPAMENTOESTADOATIVIDADE = AGRUPAMENTOESTADOATIVIDADE.IDAGRUPAMENTOESTADOATIVIDADE
        AND  AGRUPAMENTOESTADOATIVIDADE.IDATIVIDADE = ATIVIDADE.IDATIVIDADE
        // -- AND  FLUXOFASE.IDFASE = SEQUENCIA.IDTIPOSEQUENCIA
        AND  FLUXO.IDAGRUPAMENTOESTADOTPPROC = AGRPESTTPPROCMOTIVO.IDAGRUPAMENTOESTADOTPPROC
        AND  AGRPESTTPPROCMOTIVO.IDMOTIVO = MOTIVOTABELAMOTIVO.IDMOTIVO
        AND  MOTIVOTABELAMOTIVO.IDMOTIVO = MOTIVO.IDMOTIVO
        AND  ATIVIDADE.INCANCELAMENTO = 0
        AND  FLUXOFASE.IDFASE = :idFase
        AND  ATIVIDADE.IDATIVIDADE = :idAtividade
        AND  AGRUPESTADOATIVTIPOPROC.IDAGRUPAMENTOESTADOTPPROC = :idAgrupamentoEstadoTpProc		
        ORDER BY
            UPPER(MOTIVO.DSMOTIVO);

    EXEC SQL OPEN consultaCancelamento;

    while (true)
    {
        i_dsMotivo = -1;

        EXEC SQL FETCH consultaCancelamento INTO
            :idMotivo:i_idMotivo,
            :dsMotivo:i_dsMotivo,
            :idAgrupamentoEstadoTpfuturo:i_idAgrupamentoEstadoTpfuturo;
                        
        CONVIND(dsMotivo,i_dsMotivo);

        saida->createTag("WFAcoesVO");
            saida->addItem("idMotivo", idMotivo);
            saida->addItem("dsMotivo", (char *)dsMotivo.arr);
            saida->addItem("idAgrupamentoEstadoTpfuturo", idAgrupamentoEstadoTpfuturo);
        saida->closeTag();
    }

    EXEC SQL CLOSE consultaCancelamento;

    ULOG_END("proCFFObtemWFCancelamento()");

    return true;
}

bool proCFFObtemWFAcoes (int sIdContato, int sIdPessoaUsuario, int sIdAgrupamentoEstadoTpProc, XMLGen* saida)
{
   ULOG_START("proCFFObtemWFAcoes()");

	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		int  idPessoaUsuario = sIdPessoaUsuario;
		int  idContato = sIdContato;
		int  idAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;
		int  idFluxoFase;
		int  idFase;
		VARCHAR dsAtividade[256];
		int  idAtividade;
		VARCHAR nmFuncValidacao[256];
		
		short i_idFluxoFase;
		short i_idFase;
		short i_dsAtividade;
		short i_idAtividade;
		short i_nmFuncValidacao;

    EXEC SQL END DECLARE SECTION;

    ULOG("idPessoaUsuario=%d",idPessoaUsuario);

    ULOG("idContato=%d",idContato);

    ULOG("idAgrupamentoEstadoTpProc=%d",idAgrupamentoEstadoTpProc);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE consultaAcoes CURSOR FOR
	SELECT DISTINCT
		IDFLUXOFASE, 
		IDFASE,
		DSATIVIDADE, 
		IDATIVIDADE, 
		NMFUNCVALIDACAO
	FROM 
		WORKFLOW.FLUXOACOESV01
	WHERE 
        // =====================================================================
        // Não será mais necessário verificar se o usuário faz parte do grupo
        // A verificação deste parâmetro associada a regra de permitir que usuários
        // desassociados do grupo estava gerando um tempo de execução
        // inviável em produção com a entrada dos parâmetros de CRI.
        // Alteração acordada com a Tatiana em 04/04/2006.
        // Abril de 2006, Cassio
        //
		// IDPESSOAUSUARIO = :idPessoaUsuario
        // =====================================================================
		    IDCONTATO = :idContato
		AND IDAGRUPAMENTOESTADOTPPROC = :idAgrupamentoEstadoTpProc
	ORDER BY
		IDATIVIDADE, IDFASE;
	
	EXEC SQL OPEN consultaAcoes;


	while (true)
	{
		EXEC SQL FETCH consultaAcoes INTO
			:idFluxoFase:i_idFluxoFase,
			:idFase:i_idFase,
			:dsAtividade:i_dsAtividade,
			:idAtividade:i_idAtividade,
			:nmFuncValidacao:i_nmFuncValidacao;
						
		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);

		saida->createTag("WFAcoesVO");
	
			saida->addItem("idFluxoFase", idFluxoFase);
			saida->addItem("idFase", idFase);
			saida->addItem("dsAtividade", (char *)dsAtividade.arr);
			saida->addItem("idAtividade", idAtividade);
			saida->addItem("nmFuncValidacao", (char *)nmFuncValidacao.arr);
			
		saida->closeTag();

	}

	EXEC SQL CLOSE consultaAcoes;

   ULOG_END("proCFFObtemWFAcoes()");

	return true;
}

bool proCFFObtemWFAcoesCri(int sIdContato, int sIdPessoaUsuario, int sIdAgrupamentoEstadoTpProc, int sIdTipoRelacionamentoBko, Collection *colecaoAcoes)
{
   ULOG_START("proCFFObtemWFAcoesCri()");

	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		int  idPessoaUsuario = sIdPessoaUsuario;
		int  idContato = sIdContato;
		int  idAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;
		int  idTipoRelacionamentoBko = sIdTipoRelacionamentoBko;
		int  idFluxoFase;
		int  idFase;
		VARCHAR dsAtividade[256];
		int  idAtividade;
		VARCHAR nmFuncValidacao[256];
		
		short i_idFluxoFase;
		short i_idFase;
		short i_dsAtividade;
		short i_idAtividade;
		short i_nmFuncValidacao;

    EXEC SQL END DECLARE SECTION;

    ULOG(
	        "SELECT DISTINCT "
		        "IDFLUXOFASE,  "
		        "IDFASE, "
		        "DSATIVIDADE,  "
		        "IDATIVIDADE,  "
		        "NMFUNCVALIDACAO "
	        "FROM  "
		        "WORKFLOW.FLUXOACOESCRIV01 "
	        "WHERE  "
		        // "IDPESSOAUSUARIO = %d "
		        "IDCONTATO = %d "
		        "AND IDAGRUPAMENTOESTADOTPPROC = %d "
		        "AND IDTIPORELACIONAMENTOBKO = %d "
	        "ORDER BY "
		        "IDATIVIDADE, IDFASE; "
            ,idPessoaUsuario,idContato,idAgrupamentoEstadoTpProc,idTipoRelacionamentoBko );

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE consultaAcoesCri CURSOR FOR
	SELECT DISTINCT
		IDFLUXOFASE, 
		IDFASE,
		DSATIVIDADE, 
		IDATIVIDADE, 
		NMFUNCVALIDACAO
	FROM 
		WORKFLOW.FLUXOACOESCRIV01
	WHERE 
        // =====================================================================
        // Não será mais necessário verificar se o usuário faz parte do grupo
        // A verificação deste parâmetro associada a regra de permitir que usuários
        // desassociados do grupo estava gerando um tempo de execução
        // inviável em produção com a entrada dos parâmetros de CRI.
        // Alteração acordada com a Tatiana em 04/04/2006.
        // Abril de 2006, Cassio
        //
		// IDPESSOAUSUARIO = :idPessoaUsuario
        // =====================================================================
        // O idContato foi removido da view de fluxo de ações do CRI pois este
        // pois grupos CRI não são configurados para contatos.
		// IDCONTATO = :idContato
		    IDAGRUPAMENTOESTADOTPPROC = :idAgrupamentoEstadoTpProc
		AND IDTIPORELACIONAMENTOBKO = :idTipoRelacionamentoBko
	ORDER BY
		IDATIVIDADE, IDFASE;
	
	EXEC SQL OPEN consultaAcoesCri;

	while (true)
	{
		i_dsAtividade = i_nmFuncValidacao = -1;

		EXEC SQL FETCH consultaAcoesCri INTO
			:idFluxoFase:i_idFluxoFase,
			:idFase:i_idFase,
			:dsAtividade:i_dsAtividade,
			:idAtividade:i_idAtividade,
			:nmFuncValidacao:i_nmFuncValidacao;
						
		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);

        ACOES_FLUXO *acoesFluxo = new ACOES_FLUXO;

        if ( acoesFluxo )
        {
            acoesFluxo->idAtividade = idAtividade;
            acoesFluxo->idFase = idFase;
            acoesFluxo->idFluxoFase = idFluxoFase;
            acoesFluxo->dsAtividade = (char*)dsAtividade.arr;
            acoesFluxo->nmFuncValidacao = (char*)nmFuncValidacao.arr;

            colecaoAcoes->AddItem( (void*) acoesFluxo );
        }
        else
        {
            ULOGE(erroFalhaAlocacaoMemoria());
        }
	}

	EXEC SQL CLOSE consultaAcoesCri;

   ULOG_END("proCFFObtemWFAcoesCri()");

	return true;
}

bool proCFFObtemWFAcoesBko(int sIdContato, int sIdPessoaUsuario, int sIdAgrupamentoEstadoTpProc, int sIdTipoRelacionamentoBko, Collection *colecaoAcoes)
{
   ULOG_START("proCFFObtemWFAcoesBko()");

	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		int  idPessoaUsuario = sIdPessoaUsuario;
		int  idContato = sIdContato;
		int  idAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;
		int  idTipoRelacionamentoBko = sIdTipoRelacionamentoBko;
		int  idFluxoFase;
		int  idFase;
		VARCHAR dsAtividade[256];
		int  idAtividade;
		VARCHAR nmFuncValidacao[256];
		
		short i_idFluxoFase;
		short i_idFase;
		short i_dsAtividade;
		short i_idAtividade;
		short i_nmFuncValidacao;

    EXEC SQL END DECLARE SECTION;

    ULOG("idPessoaUsuario=%d",idPessoaUsuario);
    ULOG("idContato=%d",idContato);
    ULOG("idAgrupamentoEstadoTpProc=%d",idAgrupamentoEstadoTpProc);
    ULOG("idTipoRelacionamentoBko=%d",idTipoRelacionamentoBko);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE consultaAcoesBko CURSOR FOR
	SELECT DISTINCT
		IDFLUXOFASE, 
		IDFASE,
		DSATIVIDADE, 
		IDATIVIDADE, 
		NMFUNCVALIDACAO
	FROM 
		WORKFLOW.FLUXOACOESBKOV01
	WHERE 
        // =====================================================================
        // Não será mais necessário verificar se o usuário faz parte do grupo
        // A verificação deste parâmetro associada a regra de permitir que usuários
        // desassociados do grupo estava gerando um tempo de execução
        // inviável em produção com a entrada dos parâmetros de CRI.
        // Alteração acordada com a Tatiana em 04/04/2006.
        // Abril de 2006, Cassio
        //
		// IDPESSOAUSUARIO = :idPessoaUsuario
        // =====================================================================
		    IDCONTATO = :idContato
		AND IDAGRUPAMENTOESTADOTPPROC = :idAgrupamentoEstadoTpProc
		AND IDTIPORELACIONAMENTOBKO = :idTipoRelacionamentoBko
        // ==> Incidência 3399 Hom.Vivo - Dez/2005 - Cassio
        // Esta ação não pode ser exibida no list-box do detalhe do processo.
        AND IDATIVIDADE <> 23 /*ENCERRAR_BKO_EM_MASSA*/
        // <== Incidência 3399 Hom.Vivo - Dez/2005 - Cassio
	ORDER BY
		IDATIVIDADE, IDFASE;
	
	EXEC SQL OPEN consultaAcoesBko;

	while (true)
	{
        i_dsAtividade = i_nmFuncValidacao = -1;

		EXEC SQL FETCH consultaAcoesBko INTO
			:idFluxoFase:i_idFluxoFase,
			:idFase:i_idFase,
			:dsAtividade:i_dsAtividade,
			:idAtividade:i_idAtividade,
			:nmFuncValidacao:i_nmFuncValidacao;

		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);

        ACOES_FLUXO *acoesFluxo = new ACOES_FLUXO;

        if ( acoesFluxo )
        {
            acoesFluxo->idAtividade = idAtividade;
            acoesFluxo->idFase = idFase;
            acoesFluxo->idFluxoFase = idFluxoFase;
            acoesFluxo->dsAtividade = (char*)dsAtividade.arr;
            acoesFluxo->nmFuncValidacao = (char*)nmFuncValidacao.arr;

            colecaoAcoes->AddItem( (void*) acoesFluxo );
        }
        else
        {
            ULOGE(erroFalhaAlocacaoMemoria());
        }
	}

	EXEC SQL CLOSE consultaAcoesBko;

   ULOG_END("proCFFObtemWFAcoesBko()");

	return true;
}

bool proCFFObtemWFAcoesGrupo (int sIdContato, int sIdGrupo, int sIdAgrupamentoEstadoTpProc, Collection *colecaoAcoes)
{
   ULOG_START("proCFFObtemWFAcoesGrupo()");

	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		int  idGrupo = sIdGrupo;
		int  idContato = sIdContato;
		int  idAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;
		int  idFluxoFase;
		int  idFase;
		VARCHAR dsAtividade[256];
		int  idAtividade;
		VARCHAR nmFuncValidacao[256];
		
		short i_idFluxoFase;
		short i_idFase;
		short i_dsAtividade;
		short i_idAtividade;
		short i_nmFuncValidacao;

    EXEC SQL END DECLARE SECTION;

    ULOG(
	        "SELECT DISTINCT "
		        "IDFLUXOFASE,  "
		        "IDFASE, "
		        "DSATIVIDADE,  "
		        "IDATIVIDADE,  "
		        "NMFUNCVALIDACAO "
	        "FROM  "
		        "WORKFLOW.FLUXOACOESV01 "
	        "WHERE  "
		        "IDGRUPO = %d "
		        "AND IDCONTATO = %d "
		        "AND IDAGRUPAMENTOESTADOTPPROC = %d "
		        "AND IDFASE = 1 "
	        "ORDER BY "
		        "IDATIVIDADE, IDFASE; "
            ,idGrupo,idContato,idAgrupamentoEstadoTpProc);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE consultaAcoesGrupo CURSOR FOR
	SELECT DISTINCT
		IDFLUXOFASE, 
		IDFASE,
		DSATIVIDADE, 
		IDATIVIDADE, 
		NMFUNCVALIDACAO
	FROM 
		WORKFLOW.FLUXOACOESV01
	WHERE 
		IDGRUPO = :idGrupo
		AND IDCONTATO = :idContato
		AND IDAGRUPAMENTOESTADOTPPROC = :idAgrupamentoEstadoTpProc
        AND IDFASE = 1
	ORDER BY
		IDATIVIDADE, IDFASE;
	
	EXEC SQL OPEN consultaAcoesGrupo;

	while (true)
	{
        i_dsAtividade = i_nmFuncValidacao = -1;

		EXEC SQL FETCH consultaAcoesGrupo INTO
			:idFluxoFase:i_idFluxoFase,
			:idFase:i_idFase,
			:dsAtividade:i_dsAtividade,
			:idAtividade:i_idAtividade,
			:nmFuncValidacao:i_nmFuncValidacao;
						
		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);

        ACOES_FLUXO *acoesFluxo = new ACOES_FLUXO;

        if ( acoesFluxo )
        {
            acoesFluxo->idAtividade = idAtividade;
            acoesFluxo->idFase = idFase;
            acoesFluxo->idFluxoFase = idFluxoFase;
            acoesFluxo->dsAtividade = (char*)dsAtividade.arr;
            acoesFluxo->nmFuncValidacao = (char*)nmFuncValidacao.arr;

            colecaoAcoes->AddItem( (void*) acoesFluxo );
        }
        else
        {
            ULOGE(erroFalhaAlocacaoMemoria());
        }
	}

	EXEC SQL CLOSE consultaAcoesGrupo;

   ULOG_END("proCFFObtemWFAcoesGrupo()");

	return true;
}


bool proCFFObtemWFAcoesFase1Cri(int sIdContato, int sIdAgrupamentoEstadoTpProc, Collection *colecaoAcoes)
{
   ULOG_START("proCFFObtemWFAcoesFase1Cri()");

	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		int  idContato = sIdContato;
		int  idAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;
		int  idFluxoFase;
		int  idFase;
		VARCHAR dsAtividade[256];
		int  idAtividade;
		VARCHAR nmFuncValidacao[256];
		
		short i_idFluxoFase;
		short i_idFase;
		short i_dsAtividade;
		short i_idAtividade;
		short i_nmFuncValidacao;

    EXEC SQL END DECLARE SECTION;

    ULOG(
	        "SELECT DISTINCT "
		        "IDFLUXOFASE,  "
		        "IDFASE, "
		        "DSATIVIDADE,  "
		        "IDATIVIDADE,  "
		        "NMFUNCVALIDACAO "
	        "FROM  "
		        "WORKFLOW.FLUXOACOESV01 "
	        "WHERE  "
		        "IDCONTATO = %d "
		        "AND IDAGRUPAMENTOESTADOTPPROC = %d "
		        "AND IDFASE = 1 "
	        "ORDER BY "
		        "IDATIVIDADE, IDFASE; "
            ,idContato,idAgrupamentoEstadoTpProc);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE consultaAcoesFase1CRI CURSOR FOR
	SELECT DISTINCT
		IDFLUXOFASE, 
		IDFASE,
		DSATIVIDADE, 
		IDATIVIDADE, 
		NMFUNCVALIDACAO
	FROM 
		WORKFLOW.FLUXOACOESV01
	WHERE 
		IDCONTATO = :idContato
		AND IDAGRUPAMENTOESTADOTPPROC = :idAgrupamentoEstadoTpProc
        AND IDFASE = 1
	ORDER BY
		IDATIVIDADE, IDFASE;
	
	EXEC SQL OPEN consultaAcoesFase1CRI;

	while (true)
	{
		EXEC SQL FETCH consultaAcoesFase1CRI INTO
			:idFluxoFase:i_idFluxoFase,
			:idFase:i_idFase,
			:dsAtividade:i_dsAtividade,
			:idAtividade:i_idAtividade,
			:nmFuncValidacao:i_nmFuncValidacao;
						
		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);

        ACOES_FLUXO *acoesFluxo = new ACOES_FLUXO;

        if ( acoesFluxo )
        {
            acoesFluxo->idAtividade = idAtividade;
            acoesFluxo->idFase = idFase;
            acoesFluxo->idFluxoFase = idFluxoFase;
            acoesFluxo->dsAtividade = (char*)dsAtividade.arr;
            acoesFluxo->nmFuncValidacao = (char*)nmFuncValidacao.arr;

            colecaoAcoes->AddItem( (void*) acoesFluxo );
        }
        else
        {
            ULOGE(erroFalhaAlocacaoMemoria());
        }
	}

	EXEC SQL CLOSE consultaAcoesFase1CRI;

   ULOG_END("proCFFObtemWFAcoesFase1Cri()");

	return true;
}

bool proCFFObtemWFAcoesAbertura (st_FluxoFase* dados,st_vlFluxoFase* status,Collection *colecaoAcoes)
{
   ULOG_START("proCFFObtemWFAcoesAbertura()");

	struct sqlca sqlca;
    int nLinhas = 0;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_FluxoFase   oDados;
		struct st_vlFluxoFase oStatus;

		int  idFluxoFase;
		int  idFase;
		VARCHAR dsAtividade[256];
		int  idAtividade;
		VARCHAR nmFuncValidacao[256];
		
		short i_idFluxoFase;
		short i_idFase;
		short i_dsAtividade;
		short i_idAtividade;
		short i_nmFuncValidacao;

    EXEC SQL END DECLARE SECTION;

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

    ULOG("idGrupo: %d", oDados.idGrupo);
    ULOG("idContato: %d", oDados.idContato);
    ULOG("idFase: %d", oDados.idFase);
    ULOG("idTipoLinha: %d", oDados.idTipoLinha);
    ULOG("idTipoRelacionamento: %d", oDados.idTipoRelacionamento);
    ULOG("idTipoCarteira: %d", oDados.idTipoCarteira);
    ULOG("idSegmentacao: %d", oDados.idSegmentacao);
    ULOG("inTipoPessoa: %s", oDados.inTipoPessoa);

	EXEC SQL DECLARE consultaAcoesAbertura CURSOR FOR
	SELECT DISTINCT
		IDFLUXOFASE, 
		IDFASE,
		DSATIVIDADE, 
		IDATIVIDADE, 
		NMFUNCVALIDACAO
	FROM 
		WORKFLOW.WFFLUXOGRUPOSABERTURAV01
	WHERE 
		IDGRUPO = :oDados.idGrupo
		AND IDCONTATO = :oDados.idContato
		AND IDFASE = :oDados.idFase
		AND IDTIPOLINHA = :oDados.idTipoLinha
		AND IDTIPORELACIONAMENTO = :oDados.idTipoRelacionamento
		AND IDTIPOCARTEIRA = :oDados.idTipoCarteira
		AND IDSEGMENTACAO = :oDados.idSegmentacao
		AND IDTIPOPESSOA = (SELECT IDTIPOPESSOA FROM APOIO.TIPOPESSOA WHERE SGTIPOPESSOA = :oDados.inTipoPessoa)
	ORDER BY
		IDATIVIDADE, IDFASE;
	
	EXEC SQL OPEN consultaAcoesAbertura;

	while (true)
	{
		i_dsAtividade = i_nmFuncValidacao = -1;

		EXEC SQL FETCH consultaAcoesAbertura INTO
			:idFluxoFase:i_idFluxoFase,
			:idFase:i_idFase,
			:dsAtividade:i_dsAtividade,
			:idAtividade:i_idAtividade,
			:nmFuncValidacao:i_nmFuncValidacao;

		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);

        nLinhas++;

        ACOES_FLUXO *acoesFluxo = new ACOES_FLUXO;

        if ( acoesFluxo )
        {
            acoesFluxo->idAtividade = idAtividade;
            acoesFluxo->idFase = idFase;
            acoesFluxo->idFluxoFase = idFluxoFase;
            acoesFluxo->dsAtividade = (char*)dsAtividade.arr;
            acoesFluxo->nmFuncValidacao = (char*)nmFuncValidacao.arr;

            colecaoAcoes->AddItem( (void*) acoesFluxo );
        }
        else
        {
            ULOGE(erroFalhaAlocacaoMemoria());
        }
	}

	EXEC SQL CLOSE consultaAcoesAbertura;

    ULOG_END("proCFFObtemWFAcoesAbertura()");

    return nLinhas ? true : false;
}

bool proCFFObtemWFAcoesAberturaCore(st_FluxoFase* dados, st_vlFluxoFase* status, XMLGen* saida)
{
   ULOG_START("proCFFObtemWFAcoesAberturaCore()");

	struct sqlca sqlca;
   	
    EXEC SQL BEGIN DECLARE SECTION;

		struct st_FluxoFase   oDados;
		struct st_vlFluxoFase oStatus;

		int  idFluxoFase;
		int  idFase;
		VARCHAR dsAtividade[256];
		int  idAtividade;
		VARCHAR nmFuncValidacao[256];
		
		short i_idFluxoFase;
		short i_idFase;
		short i_dsAtividade;
		short i_idAtividade;
		short i_nmFuncValidacao;

    EXEC SQL END DECLARE SECTION;

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

    ULOG("idGrupo: %d", oDados.idGrupo);
    ULOG("idContato: %d", oDados.idContato);
    ULOG("idFase: %d", oDados.idFase);
    //ULOG("idTipoLinha: %d", oDados.idTipoLinha);
    //ULOG("idTipoRelacionamento: %d", oDados.idTipoRelacionamento);
    //ULOG("idTipoCarteira: %d", oDados.idTipoCarteira);
    //ULOG("idSegmentacao: %d", oDados.idSegmentacao);
    //ULOG("inTipoPessoa: %s", oDados.inTipoPessoa);

	EXEC SQL DECLARE consultaAcoesAberturaCore CURSOR FOR
	SELECT DISTINCT
		IDFLUXOFASE, 
		IDFASE,
		DSATIVIDADE, 
		IDATIVIDADE, 
		NMFUNCVALIDACAO
	FROM 
		WORKFLOW.WFFLUXOGRUPOSABERTURAV01
	WHERE 
		IDGRUPO = :oDados.idGrupo
		AND IDCONTATO = :oDados.idContato
		AND IDFASE = :oDados.idFase
		//AND IDTIPOLINHA = :oDados.idTipoLinha
		//AND IDTIPORELACIONAMENTO = :oDados.idTipoRelacionamento
		//AND IDTIPOCARTEIRA = :oDados.idTipoCarteira
		//AND IDSEGMENTACAO = :oDados.idSegmentacao
		//AND IDTIPOPESSOA = (SELECT IDTIPOPESSOA FROM APOIO.TIPOPESSOA WHERE SGTIPOPESSOA = :oDados.inTipoPessoa)
	ORDER BY
		IDATIVIDADE, IDFASE;
	
	EXEC SQL OPEN consultaAcoesAberturaCore;


	while (true)
	{
		EXEC SQL FETCH consultaAcoesAberturaCore INTO
			:idFluxoFase:i_idFluxoFase,
			:idFase:i_idFase,
			:dsAtividade:i_dsAtividade,
			:idAtividade:i_idAtividade,
			:nmFuncValidacao:i_nmFuncValidacao;
						
		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);

		saida->createTag("WFAcoesVO");
	
			saida->addItem("idFluxoFase", idFluxoFase);
			saida->addItem("idFase", idFase);
			saida->addItem("dsAtividade", (char *)dsAtividade.arr);
			saida->addItem("idAtividade", idAtividade);
			saida->addItem("nmFuncValidacao", (char *)nmFuncValidacao.arr);
			
		saida->closeTag();

	}

	EXEC SQL CLOSE consultaAcoesAberturaCore;

   ULOG_END("proCFFObtemWFAcoesAberturaCore()");

	return true;
}

int proCFFObtemWFUsuarioAtualCri(long sIdAtendimento)
{
    ULOG_START("proCFFObtemWFUsuarioAtualCri()");

    int idPessoaUsuarioRetorno = 0;

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION; 

        long idAtendimento = sIdAtendimento;

        int  idPessoaUsuario = 0;
        short i_idPessoaUsuario = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    ULOG("sIdAtendimento=%lu",sIdAtendimento);

    EXEC SQL
        SELECT
            IDPESSOAUSUARIOCRI
          INTO
      	    :idPessoaUsuario:i_idPessoaUsuario
          FROM
            ATENDIMENTO.ATDTRATCRIWFV01
          WHERE 
      	    IDATENDIMENTO = :idAtendimento;
	
    if (i_idPessoaUsuario != -1)
    {
        ULOG("idPessoaUsuario=%d",idPessoaUsuario);

        idPessoaUsuarioRetorno = idPessoaUsuario;
    }
    else
    {
        EXEC SQL
            SELECT
                ANDA.IDPESSOAUSUARIO
            INTO
                :idPessoaUsuario:i_idPessoaUsuario
            FROM
                ANDAMENTO.ANDAMENTO ANDA,
                (
                    SELECT MAX(DTANDAMENTO) AS DTANDAMENTO
                    FROM ANDAMENTO.ANDAMENTO
                    WHERE (IDATIVIDADE = (SELECT IDATIVIDADE FROM WORKFLOW.ATIVIDADE WHERE SGATIVIDADE = 'E')
	                   OR IDATIVIDADE = (SELECT IDATIVIDADE FROM WORKFLOW.ATIVIDADE WHERE SGATIVIDADE = 'PBKO'))
                    AND IDATENDIMENTO = :idAtendimento
                ) TEMP,
                (
                    SELECT MAX(IDANDAMENTO) AS IDANDAMENTO
                    FROM ANDAMENTO.ANDAMENTO
                    WHERE (IDATIVIDADE = (SELECT IDATIVIDADE FROM WORKFLOW.ATIVIDADE WHERE SGATIVIDADE = 'E')
	                   OR IDATIVIDADE = (SELECT IDATIVIDADE FROM WORKFLOW.ATIVIDADE WHERE SGATIVIDADE = 'PBKO'))
                    AND IDATENDIMENTO = :idAtendimento
                ) TEMP2
            WHERE
                TEMP.DTANDAMENTO = ANDA.DTANDAMENTO
			AND TEMP2.IDANDAMENTO = ANDA.IDANDAMENTO;

        if (i_idPessoaUsuario != -1)
        {
            ULOG("idPessoaUsuario=%d",idPessoaUsuario);

            idPessoaUsuarioRetorno = idPessoaUsuario;
        }
        else
        {
            ULOG(("*** idPessoaUsuario nao encontrado ***"));

            idPessoaUsuarioRetorno = 0;
        }
    }

    ULOG_END("proCFFObtemWFUsuarioAtualCri()");

    return idPessoaUsuarioRetorno;
}


bool proCObtemWFAcoesRC(int sIdContato, int sIdPessoaUsuario, int sIdAgrupamentoEstadoTpProc, int sIdTipoRelacionamentoBko, Collection *colecaoAcoes)
{
    ULOG_START("proCObtemWFAcoesRC()");

    bool retorno = false;
	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		int  idPessoaUsuario = sIdPessoaUsuario;
		int  idContato = sIdContato;
		int  idAgrupamentoEstadoTpProc = sIdAgrupamentoEstadoTpProc;
		int  idTipoRelacionamentoBko = sIdTipoRelacionamentoBko;
		int  idFluxoFase;
		int  idFase;
		VARCHAR dsAtividade[256];
		int  idAtividade;
		VARCHAR nmFuncValidacao[256];
		
		short i_idFluxoFase = -1;
		short i_idFase = -1;
		short i_dsAtividade = -1;
		short i_idAtividade = -1;
		short i_nmFuncValidacao = -1;

    EXEC SQL END DECLARE SECTION;

    ULOG("idTipoRelacionamentoBko=%d",idTipoRelacionamentoBko);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);

    EXEC SQL
	    SELECT DISTINCT
		       IDFLUXOFASE, 
		       IDFASE,
		       DSATIVIDADE, 
		       IDATIVIDADE, 
		       NMFUNCVALIDACAO
          INTO 
			   :idFluxoFase:i_idFluxoFase,
			   :idFase:i_idFase,
			   :dsAtividade:i_dsAtividade,
			   :idAtividade:i_idAtividade,
			   :nmFuncValidacao:i_nmFuncValidacao
	      FROM 
		       WORKFLOW.FLUXOACOESBKORCV01
	     WHERE 
               IDATIVIDADE = (SELECT IDATIVIDADE FROM WORKFLOW.ATIVIDADE WHERE SGATIVIDADE = 'RRC')
           AND 
               ROWNUM < 2;

	if ( i_idFluxoFase != -1 )
	{
		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);

        ACOES_FLUXO *acoesFluxo = new ACOES_FLUXO;

        if ( acoesFluxo )
        {
            acoesFluxo->idAtividade = idAtividade;
            acoesFluxo->idFase = idFase;
            acoesFluxo->idFluxoFase = idFluxoFase;
            acoesFluxo->dsAtividade = (char*)dsAtividade.arr;
            acoesFluxo->nmFuncValidacao = (char*)nmFuncValidacao.arr;

            colecaoAcoes->AddItem( (void*) acoesFluxo );
        }
        else
        {
            ULOGE(erroFalhaAlocacaoMemoria());
        }

        retorno = true;
	}

   ULOG_END("proCObtemWFAcoesRC()");

	return retorno;
}

bool proCObtemWFAcoesRCAP(int sIdContato, int sIdPessoaUsuario, int sIdAgrupamentoEstadoTpProc, int sIdTipoRelacionamentoBko, Collection *colecaoAcoes)
{
   ULOG_START("proCObtemWFAcoesRCAP()");

   bool retorno = false;
	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		int  idTipoRelacionamentoBko = sIdTipoRelacionamentoBko;
		int  idFluxoFase;
		int  idFase;
		VARCHAR dsAtividade[256];
		int  idAtividade;
		VARCHAR nmFuncValidacao[256];
		
		short i_idFluxoFase = -1;
		short i_idFase = -1;
		short i_dsAtividade = -1;
		short i_idAtividade = -1;
		short i_nmFuncValidacao = -1;

    EXEC SQL END DECLARE SECTION;

    ULOG("idTipoRelacionamentoBko=%d",idTipoRelacionamentoBko);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFFluxoFase(&sqlca);

    EXEC SQL
	    SELECT DISTINCT
		       IDFLUXOFASE, 
		       IDFASE,
		       DSATIVIDADE, 
		       IDATIVIDADE, 
		       NMFUNCVALIDACAO
          INTO 
			   :idFluxoFase:i_idFluxoFase,
			   :idFase:i_idFase,
			   :dsAtividade:i_dsAtividade,
			   :idAtividade:i_idAtividade,
			   :nmFuncValidacao:i_nmFuncValidacao
	      FROM 
		       WORKFLOW.FLUXOACOESRCV01
	     WHERE 
               IDATIVIDADE = (SELECT IDATIVIDADE FROM WORKFLOW.ATIVIDADE WHERE SGATIVIDADE = 'ADRC')
           AND 
               ROWNUM < 2;

	if ( i_idFluxoFase != -1 )
	{
		CONVIND(dsAtividade, i_dsAtividade);
		CONVIND(nmFuncValidacao, i_nmFuncValidacao);

        ACOES_FLUXO *acoesFluxo = new ACOES_FLUXO;

        if ( acoesFluxo )
        {
            acoesFluxo->idAtividade = idAtividade;
            acoesFluxo->idFase = idFase;
            acoesFluxo->idFluxoFase = idFluxoFase;
            acoesFluxo->dsAtividade = (char*)dsAtividade.arr;
            acoesFluxo->nmFuncValidacao = (char*)nmFuncValidacao.arr;

            colecaoAcoes->AddItem( (void*) acoesFluxo );
        }
        else
        {
            ULOGE(erroFalhaAlocacaoMemoria());
        }

        retorno = true;
	}

   ULOG_END("proCObtemWFAcoesRCAP()");

	return retorno;
}

void sql_error_WFFluxoFase(sqlca*sqlca)
{
	throw new TuxBasicOraException(sqlca->sqlcode
                                  ,sqlca->sqlerrm.sqlerrmc
                                  ,sqlca->sqlerrm.sqlerrml);
}
