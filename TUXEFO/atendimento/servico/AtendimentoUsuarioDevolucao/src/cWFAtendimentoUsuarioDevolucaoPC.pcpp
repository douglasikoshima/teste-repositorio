#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"

#include "../include/cWFAtendUsuarioDevolucao.h"
#include "../include/stWFAtendUsuarioDevolucao.h"

void sql_error_WFAtendimentoUsuarioDevolucao(sqlca*sqlca);

	// Declara as estruturas compatíveis ao ProC.
    EXEC SQL BEGIN DECLARE SECTION;
		#include "../include/stWFAtendUsuarioDevolucao.h"
    EXEC SQL END DECLARE SECTION;

bool proCIncluirWFAtendimentoUsuarioDevolucao(st_AtendimentoUsuarioDevolucao* dados, st_vlAtendimentoUsuarioDevolucao* status, XMLGen* saida)
{
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AtendimentoUsuarioDevolucao   *oDados = dados;
		struct st_vlAtendimentoUsuarioDevolucao *oStatus = status;

	EXEC SQL END DECLARE SECTION;

	// memcpy(&oDados,  dados,  sizeof(oDados));
	// memcpy(&oStatus, status, sizeof(oStatus));

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoUsuarioDevolucao(&sqlca);

	// EXEC SQL 
	// 	INSERT INTO
	// 		atendimento.AtendimentoUsuarioDevolucao
	// 		(
	// 			idAtendimento,
	// 			idPessoaUsuario
	// 		)
	// 		VALUES
	// 		(
	// 			:oDados.idAtendimento,
	// 			:oDados.idPessoaUsuario
	// 		);

    // ==> Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
    // Versão piloto. Nesta versão devido a data de entrega muito próxima
    // estou apenas atualizando os campos novos que foram desnormalizados
    // junto com as tabelas respectivas para em uma segunda versão, com mais
    // tempo poder criar métodos especificos e mais rápidos para a atualização
    // destes campos em objetos respectivos às tabelas sendo atualizadas.
    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        SET
            IDPESSOAUSUARIOANTERIOR = :oDados->idPessoaUsuario,
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :oDados->idAtendimento;
    // <== Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio

	saida->createTag("Registro");
		saida->addItem("idAtendimento", oDados->idAtendimento);
	saida->closeTag();

	return true;
}

void proCAtualizarWFAtendimentoUsuarioDevolucao(long _idAtendimento,int _idPessoaUsuario,int _idUsuarioAlteracao)
{
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

    long idAtendimento = _idAtendimento;
    int idPessoaUsuario = _idPessoaUsuario;
    int idUsuarioAlteracao = _idUsuarioAlteracao;
    // int contador;

	EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoUsuarioDevolucao(&sqlca);

	// EXEC SQL
    //     SELECT
    //         COUNT(1)
    //     INTO
    //         :contador
    //     FROM
    //         ATENDIMENTO.ATENDIMENTOUSUARIODEVOLUCAO
    //     WHERE
    //         IDATENDIMENTO = :idAtendimento;

    // if ( contador )
    // {
	//     EXEC SQL
	// 	    UPDATE
	// 		    ATENDIMENTO.ATENDIMENTOUSUARIODEVOLUCAO
    //         SET
    //             IDPESSOAUSUARIO = :idPessoaUsuario,
    //             IDUSUARIOALTERACAO = :idUsuarioAlteracao,
    //             DTULTIMAALTERACAO = SYSDATE
    //         WHERE
    //             IDATENDIMENTO = :idAtendimento;
    // }
    // else
    // {
	//     EXEC SQL
	// 	    INSERT INTO
	// 		    ATENDIMENTO.ATENDIMENTOUSUARIODEVOLUCAO
	// 		    (
	// 			    IDATENDIMENTO,
	// 			    IDPESSOAUSUARIO,
    //                 IDUSUARIOALTERACAO,
    //                 DTULTIMAALTERACAO
	// 		    )
	// 		    VALUES
	// 		    (
	// 			    :idAtendimento,
	// 			    :idPessoaUsuario,
    //                 :idUsuarioAlteracao,
    //                 SYSDATE
	// 		    );
    // }

    // ==> Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
    // Versão piloto. Nesta versão devido a data de entrega muito próxima
    // estou apenas atualizando os campos novos que foram desnormalizados
    // junto com as tabelas respectivas para em uma segunda versão, com mais
    // tempo poder criar métodos especificos e mais rápidos para a atualização
    // destes campos em objetos respectivos às tabelas sendo atualizadas.
    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        SET
            IDPESSOAUSUARIOANTERIOR = :idPessoaUsuario,
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :idAtendimento;
    // <== Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
}

bool proCAlterarWFAtendimentoUsuarioDevolucao(st_AtendimentoUsuarioDevolucao* dados, st_vlAtendimentoUsuarioDevolucao* status, XMLGen* saida)
{

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AtendimentoUsuarioDevolucao   *oDados = dados;
		struct st_vlAtendimentoUsuarioDevolucao *oStatus = status;

		// char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoUsuarioDevolucao(&sqlca);

	// memcpy(&oDados,  dados,  sizeof(oDados));
	// memcpy(&oStatus, status, sizeof(oStatus));

	// sprintf(query,"%s", "UPDATE atendimento.AtendimentoUsuarioDevolucao SET ");

	// bool separa = false;

	// if (status->idPessoaUsuario != -1) 
	// 	montaUpdate("idPessoaUsuario", oDados.idPessoaUsuario, 1);

	// sprintf(query, "%s WHERE idAtendimento = %i", query, oDados.idAtendimento);

	// EXEC SQL EXECUTE IMMEDIATE :query;

    // ==> Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
    // Versão piloto. Nesta versão devido a data de entrega muito próxima
    // estou apenas atualizando os campos novos que foram desnormalizados
    // junto com as tabelas respectivas para em uma segunda versão, com mais
    // tempo poder criar métodos especificos e mais rápidos para a atualização
    // destes campos em objetos respectivos às tabelas sendo atualizadas.
    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        SET
            IDPESSOAUSUARIOANTERIOR = :oDados->idPessoaUsuario,
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :oDados->idAtendimento;
    // <== Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio

	return true;
}

bool proCExcluirWFAtendimentoUsuarioDevolucao(st_AtendimentoUsuarioDevolucao* dados, st_vlAtendimentoUsuarioDevolucao* status, XMLGen* saida)
{
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimento = dados->idAtendimento;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoUsuarioDevolucao(&sqlca);

	// EXEC SQL 
	// 	DELETE
	// 		atendimento.AtendimentoUsuarioDevolucao
	// 	WHERE
	// 		idAtendimento = :idAtendimento;

    // ==> Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
    // Versão piloto. Nesta versão devido a data de entrega muito próxima
    // estou apenas atualizando os campos novos que foram desnormalizados
    // junto com as tabelas respectivas para em uma segunda versão, com mais
    // tempo poder criar métodos especificos e mais rápidos para a atualização
    // destes campos em objetos respectivos às tabelas sendo atualizadas.
    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        SET
            IDPESSOAUSUARIOANTERIOR = NULL,
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :idAtendimento;
    // <== Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio

	return true;
}

bool proCConsultaWFAtendimentoUsuarioDevolucao(st_AtendimentoUsuarioDevolucao* dados, st_vlAtendimentoUsuarioDevolucao* status, char* order, XMLGen* saida)
{
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimento = dados->idAtendimento;
		VARCHAR idPessoaUsuario[21];
        
        short i_idPessoaUsuario = -1;

		// char query[800];

    EXEC SQL END DECLARE SECTION;

    // EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoUsuarioDevolucao(&sqlca);
	// EXEC SQL WHENEVER NOT FOUND DO BREAK;

	// sprintf(query,"SELECT idAtendimento, idPessoaUsuario FROM atendimento.AtendimentoUsuarioDevolucao ");

	// bool separa = false;

	// if (status->idAtendimento != -1) 
	// 	montaWhere("idAtendimento", dados->idAtendimento, 1);

	// if (status->idPessoaUsuario != -1)
	// 	montaWhere("idPessoaUsuario", dados->idPessoaUsuario, 1);

	// if (strlen(order) > 0) 
	// 	sprintf( query, "%s ORDER BY %s ", query, order);

    // EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoUsuarioDevolucao(&sqlca);

	// EXEC SQL PREPARE consultaAtendimentoUsuarioDevolucao FROM :query;
	// EXEC SQL DECLARE consulta CURSOR FOR consultaAtendimentoUsuarioDevolucao;

	// EXEC SQL OPEN consulta;

	// while (true)
	// {
	// 	EXEC SQL FETCH consulta INTO :idAtendimento, :idPessoaUsuario;
    // 
	// 	saida->createTag("WFAtendimentoUsuarioDevolucaoVO");
	// 		saida->addItem("idAtendimento", idAtendimento);
	// 		saida->addItem("idPessoaUsuario", idPessoaUsuario);
	// 	saida->closeTag();
	// }

	// EXEC SQL CLOSE consulta;

    ULOG("proCConsultaWFAtendimentoUsuarioDevolucao:idAtendimento=%d",idAtendimento);

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoUsuarioDevolucao(&sqlca);
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        SELECT 
            IDPESSOAUSUARIOANTERIOR
        INTO
            idPessoaUsuario:i_idPessoaUsuario
        FROM
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        WHERE
            IDATENDIMENTO = :idAtendimento;

    if ( !sqlca.sqlcode )
    {
        CONVIND(idPessoaUsuario,i_idPessoaUsuario);

        ULOG("idPessoaUsuario=%s",idPessoaUsuario.arr);

	    saida->createTag("WFAtendimentoUsuarioDevolucaoVO");
	    	saida->addItem("idAtendimento", idAtendimento);
	    	saida->addItem("idPessoaUsuario", (char*)idPessoaUsuario.arr);
	    saida->closeTag();
    }

    return true;
}

void sql_error_WFAtendimentoUsuarioDevolucao(sqlca*sqlca)
{
	throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
