/**
 * @modulo  Workflow
 * @usecase Workflow
 * @author  Renato Teixeira
 * @version $Revision: 1.1.2.1.6.3 $
 * @CVS     $Author: a5114878 $ - $Date: 2013/02/06 12:36:43 $
 **/
 
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"
#include "../../../commons/msgPadrao.h"

#include <tuxfw.h>

#include "../include/cWFAtendimentoUsuarioAtual.h"
#include "../include/stWFAtendimentoUsuarioAtual.h"

void sql_error_WFAtendimentoUsuarioAtual(sqlca*sqlca);

    // Declara as estruturas compatíveis ao ProC.
    EXEC SQL BEGIN DECLARE SECTION;
        #include "../include/stWFAtendimentoUsuarioAtual.h"
    EXEC SQL END DECLARE SECTION;

bool proCIncluirWFAtendimentoUsuarioAtual(st_AtendimentoUsuarioAtual* dados, st_vlAtendimentoUsuarioAtual* status, XMLGen* saida, XMLDPR *xmlDpr)
{
    ULOG_START( "proCIncluirWFAtendimentoUsuarioAtual()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        struct st_AtendimentoUsuarioAtual *oDados = dados;
        struct st_vlAtendimentoUsuarioAtual *oStatus = status;

    EXEC SQL END DECLARE SECTION;

    ULOG("idAtendimento=%ld",oDados->idAtendimento);
    ULOG("idPessoaUsuario=%d",oDados->idPessoaUsuario);
    ULOG("dtUltimaAlteracao='%s'",oDados->dtUltimaAlteracao);
    ULOG("dtFimPausaAtendimento='%s'",oDados->dtFimPausaAtendimento);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoUsuarioAtual(&sqlca);

    // ==> Remodelagem Atendimento--Fev/2007--Cassio 
    // EXEC SQL 
    //     INSERT INTO
    //         atendimento.AtendimentoUsuarioAtual
    //         (
    //             idAtendimento,
    //             idPessoaUsuario,
    //             inPausaAtendimento,
    //             idUsuarioAlteracao,
    //             dtUltimaAlteracao,
    //             dtFimPausaAtendimento
    //         )
    //         VALUES
    //         (
    //             :oDados->idAtendimento,
    //             :oDados->idPessoaUsuario,
    //             DECODE(:oStatus->inPausaAtendimento, -1, NULL,:oDados->inPausaAtendimento),
    //             DECODE(:oStatus->idUsuarioAlteracao, -1, NULL,:oDados->idUsuarioAlteracao),
    //             DECODE(:oStatus->dtUltimaAlteracao,-1,SYSDATE,TO_DATE(:oDados->dtUltimaAlteracao,'DD/MM/YYYY HH24:MI:SS')),
    //             DECODE(:oStatus->dtFimPausaAtendimento,-1,NULL,TO_DATE(:oDados->dtFimPausaAtendimento,'DD/MM/YYYY HH24:MI:SS'))
    //         );

    // ==> Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
    // Versão piloto. Nesta versão devido a data de entrega muito próxima
    // estou apenas atualizando os campos novos que foram desnormalizados
    // junto com as tabelas respectivas para em uma segunda versão, com mais
    // tempo vamos poder criar métodos especificos e mais rápidos para a 
    // atualização destes campos em objetos respectivos às tabelas sendo atualizadas.
    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTO
        SET
            IDPESSOAUSUARIOATUAL = :oDados->idPessoaUsuario,
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :oDados->idAtendimento;

    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        SET
            IDPESSOAUSUARIOATUAL = :oDados->idPessoaUsuario,
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :oDados->idAtendimento;
    // <== Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio

    if ( saida )
    {
        saida->createTag("WFAtendimentoUsuarioAtualVO");
            saida->addItem("idAtendimento", oDados->idAtendimento);
        saida->closeTag();
    }

    // ==> SM324--DPR--DEZ/2006--Cassio
    if ( xmlDpr )
    {
        AtendimentoUsuarioAtualDPR atendimentousuarioatualdpr;

        atendimentousuarioatualdpr.setIdAtendimento(oDados->idAtendimento);
        atendimentousuarioatualdpr.setIdPessoaUsuario(oDados->idPessoaUsuario);
        atendimentousuarioatualdpr.setOpCode(OPCODE_INSERT);

        xmlDpr->atendimentousuarioatualvo.inserir(&atendimentousuarioatualdpr);
    }
    // <== SM324--DPR--DEZ/2006--Cassio

    ULOG_END( "proCIncluirWFAtendimentoUsuarioAtual()");

    return true;
}

// Esta inclusão difere da inclusão normal pois a coluna IDPESSOAUSUARIOATUAL deve ser = NULL
// caso contrário o UPDATE lança exceção
bool proCIncluirWFAtendimentoUsuarioAtual1aVez(long idAtendimento,long idPessoaUsuarioAtual,XMLDPR *xmlDpr)
{
    ULOG_START( "proCIncluirWFAtendimentoUsuarioAtual1aVez()");

    bool retorno;
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        long paramOraIdAtendimento = idAtendimento;
        long paramOraIdPessoaUsuarioAtual = idPessoaUsuarioAtual;
    EXEC SQL END DECLARE SECTION;

    ULOG("idAtendimento=%ld",paramOraIdAtendimento);
    ULOG("idPessoaUsuario=%ld",paramOraIdPessoaUsuarioAtual);

    EXEC SQL WHENEVER SQLERROR GOTO erroInc1aVez;

    ULOG("Vai tentar reservar o processo para o usuário...");

    EXEC SQL
        SELECT
            ATENDIMENTO.IDPESSOAUSUARIOATUAL,
            ATENDIMENTOPRIORIZACAO.IDPESSOAUSUARIOATUAL,
            ATENDIMENTO.DTULTIMAALTERACAO,
            ATENDIMENTOPRIORIZACAO.DTULTIMAALTERACAO
        FROM
            ATENDIMENTO.ATENDIMENTO ATENDIMENTO,
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO ATENDIMENTOPRIORIZACAO
        WHERE
            ATENDIMENTO.IDATENDIMENTO = :paramOraIdAtendimento
        AND ATENDIMENTO.IDPESSOAUSUARIOATUAL IS NULL
        AND ATENDIMENTO.IDATENDIMENTO = ATENDIMENTOPRIORIZACAO.IDATENDIMENTO
        AND ATENDIMENTOPRIORIZACAO.IDPESSOAUSUARIOATUAL IS NULL
    FOR UPDATE NOWAIT;

    ULOG( "sqlca.sqlcode=%d",sqlca.sqlcode);
    if ( 0==sqlca.sqlcode )
    {
        // Conseguiu reservar! Então atualiza.
        ULOG("Vai entregar o processo ao usuário.");

        EXEC SQL
            UPDATE
                ATENDIMENTO.ATENDIMENTO
            SET
                IDPESSOAUSUARIOATUAL = :paramOraIdPessoaUsuarioAtual,
                DTULTIMAALTERACAO = SYSDATE
            WHERE
                IDATENDIMENTO = :paramOraIdAtendimento;

        EXEC SQL
            UPDATE
                ATENDIMENTO.ATENDIMENTOPRIORIZACAO
            SET
                IDPESSOAUSUARIOATUAL = :paramOraIdPessoaUsuarioAtual,
                DTULTIMAALTERACAO = SYSDATE
            WHERE
                IDATENDIMENTO = :paramOraIdAtendimento;

        ULOG("Processo entregue ao usuário com sucesso.");

        // ==> SM324--DPR--DEZ/2006--Cassio
        if ( xmlDpr )
        {
            AtendimentoUsuarioAtualDPR atendimentousuarioatualdpr;

            atendimentousuarioatualdpr.setIdAtendimento(paramOraIdAtendimento);
            atendimentousuarioatualdpr.setIdPessoaUsuario(paramOraIdPessoaUsuarioAtual);
            atendimentousuarioatualdpr.setOpCode(OPCODE_INSERT);

            xmlDpr->atendimentousuarioatualvo.inserir(&atendimentousuarioatualdpr);
        }
        // <== SM324--DPR--DEZ/2006--Cassio
        retorno = true;
    }
    else
    {
        ULOGW("Processo já esta em poder de outro usuário!!");
        retorno = false;
    }

    ULOG_END( "proCIncluirWFAtendimentoUsuarioAtual1aVez()");

    return retorno;

erroInc1aVez:
    ULOG( "sqlca.sqlcode=%d",sqlca.sqlcode);

    if ( -54 == sqlca.sqlcode || 54 == sqlca.sqlcode)
    {
        ULOGE( "TENTATIVA DE CAPTURA DE UM PROCESSO JÁ RESERVADO A OUTRO USUÁRIO");
        ULOG_END( "proCIncluirWFAtendimentoUsuarioAtual1aVez()");
        return false;
    }

    throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

bool proCAlterarWFAtendimentoUsuarioAtual(st_AtendimentoUsuarioAtual* dados, st_vlAtendimentoUsuarioAtual* status, XMLGen* saida, XMLDPR *xmlDpr)
{
    ULOG_START( "proCAlterarWFAtendimentoUsuarioAtual()" );

	struct sqlca sqlca;
    // char buf[32];

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AtendimentoUsuarioAtual   oDados;
		struct st_vlAtendimentoUsuarioAtual oStatus;

        // ==> Remodelagem Atendimento--Fev/2007--Cassio 
		// char query[800] = "UPDATE atendimento.AtendimentoUsuarioAtual SET ";

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoUsuarioAtual(&sqlca);

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

	// bool separa = false;

	// if (status->idPessoaUsuario != -1) 
	// 	montaUpdate("idPessoaUsuario", oDados.idPessoaUsuario, TIPO_INT);

	// if (status->inPausaAtendimento != -1) 
	// 	montaUpdate("inPausaAtendimento", oDados.inPausaAtendimento, TIPO_INT);

	// if (status->idUsuarioAlteracao != -1) 
	// 	montaUpdate("idUsuarioAlteracao", oDados.idUsuarioAlteracao, TIPO_INT);

	// if (status->dtUltimaAlteracao != -1) 
	// 	montaUpdate("dtUltimaAlteracao", oDados.dtUltimaAlteracao, TIPO_DATAHORA);

	// if (status->dtFimPausaAtendimento != -1) 
	// 	montaUpdate("dtFimPausaAtendimento", oDados.dtFimPausaAtendimento, TIPO_DATAHORA);

    // sprintf(buf,"%d",dados->idAtendimento);

    // strcat(query,"WHERE idAtendimento = ");
    // strcat(query,buf);

    // ULOG( "Executando Query [%s]",query);

    // EXEC SQL EXECUTE IMMEDIATE :query;

    // ==> Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
    // Versão piloto. Nesta versão devido a data de entrega muito próxima
    // estou apenas atualizando os campos novos que foram desnormalizados
    // junto com as tabelas respectivas para em uma segunda versão, com mais
    // tempo poder criar métodos especificos e mais rápidos para a atualização
    // destes campos em objetos respectivos às tabelas sendo atualizadas.
    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTO
        SET
            IDPESSOAUSUARIOATUAL = :oDados.idPessoaUsuario,
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :oDados.idAtendimento;

    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        SET
            IDPESSOAUSUARIOATUAL = :oDados.idPessoaUsuario,
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :oDados.idAtendimento;
    // <== Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio

    // ==> SM324--DPR--DEZ/2006--Cassio
    if ( xmlDpr )
    {
        AtendimentoUsuarioAtualDPR atendimentousuarioatualdpr;

        atendimentousuarioatualdpr.setIdAtendimento(oDados.idAtendimento);
        atendimentousuarioatualdpr.setIdPessoaUsuario(oDados.idPessoaUsuario);
        atendimentousuarioatualdpr.setOpCode(OPCODE_UPDATE);

        xmlDpr->atendimentousuarioatualvo.inserir(&atendimentousuarioatualdpr);
    }
    // <== SM324--DPR--DEZ/2006--Cassio

    ULOG_END( "proCAlterarWFAtendimentoUsuarioAtual()" );

	return true;
}

void proCExcluirWFAtendimentoUsuarioAtual(long _idAtendimento,long _idPessoaUsuarioAtual,XMLDPR *xmlDpr)
{
    ULOG_START( "proCExcluirWFAtendimentoUsuarioAtual()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = _idAtendimento;
        long idPessoaUsuarioAtual = _idPessoaUsuarioAtual;
        int counter;
        short i_idPessoaUsuarioAtual = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoUsuarioAtual(&sqlca);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    if ( _idPessoaUsuarioAtual <= 0 )
    {
        EXEC SQL
            SELECT
                IDPESSOAUSUARIOATUAL
            INTO
                :idPessoaUsuarioAtual:i_idPessoaUsuarioAtual
            FROM
                ATENDIMENTO.ATENDIMENTO
            WHERE
                IDATENDIMENTO = :idAtendimento;
    }

    ULOG( "idAtendimento = %d",idAtendimento );
    ULOG( "idPessoaUsuarioAtual = %ld",idPessoaUsuarioAtual );

    // ==> Remodelagem Atendimento--Fev/2007--Cassio 
    // EXEC SQL 
    //     DELETE
    //         ATENDIMENTO.ATENDIMENTOUSUARIOATUAL
    //     WHERE
    //         IDATENDIMENTO = :idAtendimento;

    // ==> Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
    // Versão piloto. Nesta versão devido a data de entrega muito próxima
    // estou apenas atualizando os campos novos que foram desnormalizados
    // junto com as tabelas respectivas para em uma segunda versão, com mais
    // tempo poderemos criar métodos especificos e mais rápidos para a atualização
    // destes campos em objetos respectivos às tabelas sendo atualizadas.
    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTO
        SET
            IDPESSOAUSUARIOATUAL = NULL,
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :idAtendimento;

    EXEC SQL
        SELECT
            COUNT(1)
        INTO
            :counter
        FROM
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        WHERE
            IDATENDIMENTO = :idAtendimento;

    if ( counter )
    {
        EXEC SQL
            UPDATE
                ATENDIMENTO.ATENDIMENTOPRIORIZACAO
            SET
                IDPESSOAUSUARIOATUAL = NULL,
                DTULTIMAALTERACAO = SYSDATE
            WHERE
                IDATENDIMENTO = :idAtendimento;
    }
    // <== Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio

    // ==> SM324--DPR--DEZ/2006--Cassio
    if ( xmlDpr )
    {
        AtendimentoUsuarioAtualDPR atendimentousuarioatualdpr;

        atendimentousuarioatualdpr.setIdAtendimento(idAtendimento);
        atendimentousuarioatualdpr.setIdPessoaUsuario(idPessoaUsuarioAtual);
        atendimentousuarioatualdpr.setOpCode(OPCODE_DELETE);

        xmlDpr->atendimentousuarioatualvo.inserir(&atendimentousuarioatualdpr);
    }
    // <== SM324--DPR--DEZ/2006--Cassio

    ULOG_END( "proCExcluirWFAtendimentoUsuarioAtual()" );
}

bool proCExcluirLogWFAtendimentoUsuarioAtual(st_AtendimentoUsuarioAtual* dados, st_vlAtendimentoUsuarioAtual* status, XMLGen* saida)
{
    ULOG_START( "proCExcluirLogWFAtendimentoUsuarioAtual()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = dados->idAtendimento;
        int counter;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoUsuarioAtual(&sqlca);

    ULOG( "idAtendimento=%d",idAtendimento);

    // Os registros desta tabela não devem ser deletados, sob pena dos
    // processos desaparecem das filas BKO no modelo atual - Fev/2006 - Cassio
    //
    //EXEC SQL 
    //    DELETE
    //        atendimento.AtendimentoUsuarioAtual
    //    WHERE
    //        idAtendimento = :idAtendimento;

    // ==> Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
    //
	// EXEC SQL 
    //     UPDATE
	// 		atendimento.AtendimentoUsuarioAtual
    //     SET 
    //         dtExclusao = SYSDATE
	// 	WHERE
	// 		idAtendimento = :idAtendimento;
    //
    // Versão piloto. Nesta versão devido a data de entrega muito próxima
    // estou apenas atualizando os campos novos que foram desnormalizados
    // junto com as tabelas respectivas para em uma segunda versão, com mais
    // tempo poderemos criar métodos especificos e mais rápidos para a atualização
    // destes campos em objetos respectivos às tabelas sendo atualizadas.
    //
    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTO
        SET
            IDPESSOAUSUARIOATUAL = NULL,
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :idAtendimento;

    EXEC SQL
        SELECT
            COUNT(1)
        INTO
            :counter
        FROM
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        WHERE
            IDATENDIMENTO = :idAtendimento;

    if ( counter )
    {
        EXEC SQL
            UPDATE
                ATENDIMENTO.ATENDIMENTOPRIORIZACAO
            SET
                IDPESSOAUSUARIOATUAL = NULL,
                DTULTIMAALTERACAO = SYSDATE
            WHERE
                IDATENDIMENTO = :idAtendimento;
    }
    // <== Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio

    ULOG_END( "proCExcluirLogWFAtendimentoUsuarioAtual()" );

	return true;
}

long proCObterIdPessoaUsuarioAtual(long _idAtendimento)
{
	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION; 

		long idAtendimento = _idAtendimento;
        long idPessoaUsuarioAtual;
        short i_idPessoaUsuarioAtual = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoUsuarioAtual(&sqlca);
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL 
	    SELECT 
		    IDPESSOAUSUARIOATUAL
	    INTO
            :idPessoaUsuarioAtual:i_idPessoaUsuarioAtual
	    FROM 
		    ATENDIMENTO.ATENDIMENTO
	    WHERE 
		    IDATENDIMENTO = :idAtendimento;
	
    return i_idPessoaUsuarioAtual == -1 ? 0 :idPessoaUsuarioAtual;
}

bool proCExisteWFAtendimentoUsuarioAtual(long _idAtendimento)
{
    ULOG_START( "proCExisteWFAtendimentoUsuarioAtual()" );

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimento = _idAtendimento;
        int registros;
        short i_registros=-1;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoUsuarioAtual(&sqlca);

    ULOG( "idAtendimento=%d",idAtendimento );

    // ==> Remodelagem Atendimento--Fev/2007--Cassio 
	// EXEC SQL 
	// 	SELECT COUNT(1)
    //     INTO
    //         :registros
	// 	FROM
    //         ATENDIMENTO.ATENDIMENTOUSUARIOATUAL
    //     WHERE
    //         IDATENDIMENTO = :idAtendimento;

    EXEC SQL
        SELECT 
            NVL(IDPESSOAUSUARIOATUAL,0)
        INTO
            :registros:i_registros
        FROM
            ATENDIMENTO.ATENDIMENTO
        WHERE
            IDATENDIMENTO = :idAtendimento;

    ULOG_END( "proCExisteWFAtendimentoUsuarioAtual()" );

    return registros > 0 ? true : false;
}

void sql_error_WFAtendimentoUsuarioAtual(sqlca*sqlca)
{
	throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
