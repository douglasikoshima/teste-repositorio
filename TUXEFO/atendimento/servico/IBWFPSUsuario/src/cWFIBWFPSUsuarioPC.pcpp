
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <tuxfw.h>

#include "../../../commons/queryMacro.h"
#include "../../../commons/Collection/include/Collection.h"
#include "../../../commons/msgPadrao.h"

void sql_error_IBWFPSUsuario(sqlca*sqlca);

EXEC SQL BEGIN DECLARE SECTION;
	#include "../include/stUsuario.h"
EXEC SQL END DECLARE SECTION;

// ====================================================================
// Módulo usuário já possui estes métodos. Este serviço irá deixar de
// ser transacional. Não reativar estas operações.
// ====================================================================
//
//bool proCIbAltInDisponivelWF(int idPessoaUsuario,bool inDisponivelWF)
//{
//	struct sqlca sqlca;
//
//    EXEC SQL BEGIN DECLARE SECTION;
//
//		int idpessoausuario = idPessoaUsuario;
//		int indisponivelwf = inDisponivelWF;
//
//    EXEC SQL END DECLARE SECTION;
//
//    EXEC SQL WHENEVER SQLERROR DO sql_error_IBWFPSUsuario(&sqlca);
//
//	EXEC SQL
//	UPDATE
//		acesso.Usuario
//	SET
//		inDisponivelWF  = :indisponivelwf,
//		dtUltimaAlteracao = SYSDATE
//	WHERE
//		idPessoaUsuario = :idpessoausuario;
//
//	return sqlca.sqlcode ? false : true;
//}

// ====================================================================
// Módulo usuário já possui estes métodos. Este serviço irá deixar de
// ser transacional. Não reativar estas operações.
// ====================================================================
//
//bool proCIbAltInDisponivelWF(DOMNode*entrada)
//{
//    char *p;
//	struct sqlca sqlca;
//	TuxHelper tx;
//
//    EXEC SQL BEGIN DECLARE SECTION;
//
//		int idPessoaUsuario = 0;
//		int inDisponivelWF = 0;
//
//    EXEC SQL END DECLARE SECTION;
//
//    EXEC SQL WHENEVER SQLERROR  DO sql_error_IBWFPSUsuario(&sqlca);
//
//	if ( p=tx.walkTree( entrada, "idPessoaUsuario", 0 ),p )
//    {
//        idPessoaUsuario = atoi(p); 
//        XMLString::release(&p);
//    }
//
//	if ( p=tx.walkTree( entrada, "inDisponivelWF", 0 ),p )
//    {
//        inDisponivelWF = atoi(p); 
//        XMLString::release(&p);
//    }
//
//	EXEC SQL
//	UPDATE
//		acesso.Usuario
//	SET
//		inDisponivelWF = :inDisponivelWF,
//		dtUltimaAlteracao = SYSDATE
//	WHERE
//		idPessoaUsuario = :idPessoaUsuario;
//
//	return sqlca.sqlcode ? false : true;
//}


// ====================================================================
// Módulo usuário já possui estes métodos. Este serviço irá deixar de
// ser transacional. Não reativar estas operações.
// ====================================================================
//
//bool proCIbAltStatusUsuario(int idPessoaUsuario,int idStatusUsuario)
//{
//	struct sqlca sqlca;
//
//    EXEC SQL BEGIN DECLARE SECTION;
//
//		int idpessoausuario = idPessoaUsuario;
//		int idstatususuario = idStatusUsuario;
//
//    EXEC SQL END DECLARE SECTION;
//
//    EXEC SQL WHENEVER SQLERROR  DO sql_error_IBWFPSUsuario(&sqlca);
//
//	EXEC SQL
//	UPDATE
//		acesso.Usuario
//	SET
//		idstatususuario = :idstatususuario,
//		dtStatusUsuario = SYSDATE,
//		dtUltimaAlteracao = SYSDATE
//	WHERE
//		idPessoaUsuario = :idpessoausuario;
//
//	return true;
//}

//bool proCIbAltStatusUsuario(DOMNode*entrada)
//{
//    char *p;
//	struct sqlca sqlca;
//	TuxHelper tx;
//
//    EXEC SQL BEGIN DECLARE SECTION;
//
//		int idpessoausuario = 0;
//		int idStatusUsuario = 0;
//
//    EXEC SQL END DECLARE SECTION;
//
//    EXEC SQL WHENEVER SQLERROR  DO sql_error_IBWFPSUsuario(&sqlca);
//
//	if ( p=tx.walkTree( entrada, "idPessoaUsuario", 0 ),p )
//    {
//        idpessoausuario = atoi(p); 
//        XMLString::release(&p);
//    }
//    else
//    {
//        return false;
//    }
//
//	if ( p=tx.walkTree( entrada, "idStatusUsuario", 0 ),p )
//    {
//        idStatusUsuario = atoi(p); 
//        XMLString::release(&p);
//    }
//    else
//    {
//        return false;
//    }
//
//	EXEC SQL
//	UPDATE
//		acesso.Usuario
//	SET
//		idStatusUsuario = :idStatusUsuario,
//		dtStatusUsuario = SYSDATE,
//		dtUltimaAlteracao = SYSDATE
//	WHERE
//		idPessoaUsuario = :idpessoausuario;
//
//	return true;
//}
int proCIbGetInDisponivelWF(DOMNode*entrada)
{
    ULOG_START("InsereCanalEntrada()");
    char *p;
	struct sqlca sqlca;
	TuxHelper tx;

    EXEC SQL BEGIN DECLARE SECTION;

		int   idpessoausuario  = 0;
		int   inDisponivelWF  = 0;
		short i_inDisponivelWF = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_IBWFPSUsuario(&sqlca);

	if ( p=tx.walkTree( entrada, "idPessoaUsuario", 0 ),p )
    {
        idpessoausuario = atoi(p); 
        XMLString::release(&p);
    }

	EXEC SQL
	SELECT 
		inDisponivelWF 
	INTO 
        :inDisponivelWF:i_inDisponivelWF
	FROM 
		acesso.Usuario
	WHERE 
        idPessoaUsuario = :idpessoausuario;

    ULOG_END("InsereCanalEntrada()");

	return inDisponivelWF;
}

int proCIbGetStatusUsuario(DOMNode*entrada)
{
    ULOG_START("proCIbGetStatusUsuario()");
    char *p;
	struct sqlca sqlca;
	TuxHelper tx;
	int ret = 0; 

    EXEC SQL BEGIN DECLARE SECTION;

		int   idpessoausuario  = 0;
		int   idStatusUsuario  = 0;
		short iidStatusUsuario = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_IBWFPSUsuario(&sqlca);

	if ( p=tx.walkTree( entrada, "idPessoaUsuario", 0 ),p )
    {
        idpessoausuario = atoi(p); 
        XMLString::release(&p);
    }

	EXEC SQL
	SELECT 
		IDSTATUSUSUARIO 
		INTO :idStatusUsuario:iidStatusUsuario
	FROM 
		ACESSO.USUARIO 
		WHERE IDPESSOAUSUARIO = :idpessoausuario;

	if ( iidStatusUsuario >= 0 ) 
	    ret = idStatusUsuario;

	ULOG_END("proCIbGetStatusUsuario()");

	return ret;

}

bool proCIbPesquisaUsuario(st_VariaveisUsuario* _dados, st_Result *result)
{

    ULOG_START("proCIbPesquisaUsuario()");
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idpessoausuario = _dados->idPessoaUsuario;

		VARCHAR idPessoaUsuario[16];
		VARCHAR nmNome[256];
		VARCHAR nmLoginUsuario[256];
        VARCHAR idStatusUsuario[256];
		VARCHAR inDisponivelWF[256];

		short i_idPessoaUsuario=-1;
		short i_nmNome=-1;
		short i_nmLoginUsuario=-1;
		short i_idStatusUsuario=-1;
		short i_inDisponivelWF=-1;

    EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL WHENEVER SQLERROR DO sql_error_IBWFPSUsuario(&sqlca);

    EXEC SQL
        SELECT
            U.IDPESSOAUSUARIO,
            P.NMNOME,
            U.NMLOGINUSUARIO,
            U.IDSTATUSUSUARIO,
            U.INDISPONIVELWF
        INTO
		    idPessoaUsuario:i_idPessoaUsuario,
		    nmNome:i_nmNome,
		    nmLoginUsuario:i_nmLoginUsuario,
		    idStatusUsuario:i_idStatusUsuario,
		    inDisponivelWF:i_inDisponivelWF
        FROM 
	        ACESSO.USUARIO U,
	        CUSTOMER.PESSOA P
        WHERE
            U.IDPESSOAUSUARIO = :idpessoausuario
	      AND
            U.IDPESSOAUSUARIO = P.IDPESSOA;

	CONVIND(idPessoaUsuario, i_idPessoaUsuario);
	CONVIND(nmNome, i_nmNome);
	CONVIND(nmLoginUsuario, i_nmLoginUsuario);
	CONVIND(idStatusUsuario, i_idStatusUsuario);
	CONVIND(inDisponivelWF, i_inDisponivelWF);

    ULOG("sqlca.sqlcode = '%d'",sqlca.sqlcode);

	if( sqlca.sqlcode )
    {
		return false;
    }

    sprintf(result->idPessoaUsuario,"%.*s",sizeof(result->idPessoaUsuario)-1,idPessoaUsuario.arr);
    sprintf(result->nmNome,"%.*s",sizeof(result->nmNome)-1,nmNome.arr);
    sprintf(result->nmLoginUsuario,"%.*s",sizeof(result->nmLoginUsuario)-1,nmLoginUsuario.arr);
    sprintf(result->idStatusUsuario,"%.*s",sizeof(result->idStatusUsuario)-1,idStatusUsuario.arr);
    sprintf(result->inDisponivelWF,"%.*s",sizeof(result->inDisponivelWF)-1,inDisponivelWF.arr);

    ULOG_END("proCIbPesquisaUsuario()");

	return true;
}

// bool proCIbPesquisaGrupoAberturaUsuario(DOMNode*entrada,XMLGen* saida)
// {
//     ULOG_START("proCIbPesquisaGrupoAberturaUsuario()");
//     char *p;
// 	struct sqlca sqlca;
// 	TuxHelper tx;
// 
//     EXEC SQL BEGIN DECLARE SECTION;
// 		int idpessoausuario = 0;
// 
// 		VARCHAR nmNome[256];
// 		VARCHAR nmLoginUsuario[256];
//         int idStatusUsuario;
// 		int inDisponivelWF;
// 
// 		short i_nmNome=-1;
// 		short i_nmLoginUsuario=-1;
// 		short i_idStatusUsuario=-1;
// 		short i_inDisponivelWF=-1;
// 
//     EXEC SQL END DECLARE SECTION;
// 
// 	if ( p=tx.walkTree( entrada, "idPessoaUsuario", 0 ),p )
//     {
//         idpessoausuario = atoi(p); 
//         XMLString::release(&p);
//     }
// 
//     EXEC SQL WHENEVER SQLERROR  DO sql_error_IBWFPSUsuario(&sqlca);
// 
// 
//     EXEC SQL
//         SELECT
//             P.NMNOME, 
//             U.NMLOGINUSUARIO,
//             U.IDSTATUSUSUARIO,
//             U.INDISPONIVELWF
//         INTO
// 		    nmNome:i_nmNome,
// 		    nmLoginUsuario:i_nmLoginUsuario,
// 		    idStatusUsuario:i_idStatusUsuario,
// 		    inDisponivelWF:i_inDisponivelWF
//         FROM 
// 	        ACESSO.USUARIO U,
// 	        CUSTOMER.PESSOA P
//         WHERE
//             U.IDPESSOAUSUARIO = :idpessoausuario
// 	    AND U.IDPESSOAUSUARIO = P.IDPESSOA;
// 
//     CONVIND(nmNome, i_nmNome);
// 	CONVIND(nmLoginUsuario, i_nmLoginUsuario);
// 
// 	saida->createTag("UsuarioVIVO");
// 	saida->addProp("xmlns", "usuario.fo.vivo.com.br/vo");
// 	saida->addItem("idPessoaUsuario",idpessoausuario);
// 	saida->addItem("nmNome", (char*)nmNome.arr);
// 	saida->addItem("nmLoginUsuario",(char*)nmLoginUsuario.arr);
// 	saida->addItem("idStatusUsuario",CONVINT(idStatusUsuario,i_idStatusUsuario));
// 	saida->addItem("inDisponivelWF",CONVINT(inDisponivelWF,i_inDisponivelWF));
// 	saida->closeTag();
// 
//     ULOG_END("proCIbPesquisaGrupoAberturaUsuario()");
// 
// 	return true;
// }

bool proCIbConsultaWFGrupos(XMLGen* saida)
{

    ULOG_START("proCIbConsultaWFGrupos()");
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idgrupo; 
		VARCHAR nmgrupo[256];

		short i_idgrupo;
		short i_nmgrupo;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_IBWFPSUsuario(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE tsqlcursor1 CURSOR FOR
	SELECT 
		idGrupo, 
		nmGrupo 
	FROM 
		acesso.Grupo
   WHERE
      idGrupo > 0
     AND
        dtexclusao IS NULL
	ORDER BY 
        UPPER(nmGrupo);

	EXEC SQL OPEN tsqlcursor1;
	
    for(;;)
    {
		EXEC SQL FETCH tsqlcursor1 INTO :idgrupo:i_idgrupo, :nmgrupo:i_nmgrupo;

		CONVIND(nmgrupo, i_nmgrupo);

		saida->createTag("WFGrupoVO");
		saida->addItem("idGrupo",idgrupo);
		saida->addItem("dsGrupo",(char*)nmgrupo.arr);
		saida->closeTag();
	}
	EXEC SQL CLOSE tsqlcursor1;

    ULOG_END("proCIbConsultaWFGrupos()");

	return true;

}

bool proCIbConsultaWFGruposFilaProcesso( DOMNode * entrada , XMLGen * saida )
{

    ULOG_START("proCIbConsultaWFGruposFilaProcesso()");
    char *p;
	struct sqlca sqlca;
	TuxHelper tx;

    EXEC SQL BEGIN DECLARE SECTION;
		int idgrupo;
		int idUsuario = 0;

		VARCHAR nmgrupo[256];

		short i_idgrupo;
		short i_nmgrupo;
    EXEC SQL END DECLARE SECTION;

	if ( p=tx.walkTree( entrada, "idUsuario", 0),p )
    {
        idUsuario = atoi(p);
        XMLString::release(&p);
    }

   EXEC SQL WHENEVER SQLERROR  DO sql_error_IBWFPSUsuario(&sqlca);
   EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE ReadGruposProcFila CURSOR FOR
   SELECT 
      a.idgrupo, a.nmgrupo
   FROM 
      acesso.grupo a
     ,acesso.usuariogrupo b
   WHERE 
      a.idgrupo = b.idgrupo 
   AND
      a.dtexclusao IS NULL
   AND 
      b.idpessoausuario = :idUsuario;

	EXEC SQL OPEN ReadGruposProcFila;
	
	for(;;) 
	{
		EXEC SQL FETCH ReadGruposProcFila INTO :idgrupo:i_idgrupo, :nmgrupo:i_nmgrupo;

		CONVIND(nmgrupo, i_nmgrupo);

		saida->createTag("WFGrupoVO");
		saida->addItem("idGrupo",idgrupo);
		saida->addItem("dsGrupo",(char*)nmgrupo.arr);
		saida->closeTag();
	}
	EXEC SQL CLOSE ReadGruposProcFila;

    ULOG_END("proCIbConsultaWFGruposFilaProcesso()");

	return true;

}

// bool proCIbPesquisaUsuarioPorGrupo(DOMNode*entrada,XMLGen* saida)
// {
//     ULOG_START("proCIbPesquisaUsuarioPorGrupo()");
//     char *p;
// 	struct sqlca sqlca;
// 	TuxHelper tx;
// 
//     EXEC SQL BEGIN DECLARE SECTION;
// 
// 		int idgrupo  = 0;
// 
// 		int idPessoaUsuario; 
// 
// 		VARCHAR nmNome[256];
// 		VARCHAR nmLoginUsuario[256];
//         int idStatusUsuario;
// 		int inDisponivelWF;
// 
// 		short i_idPessoaUsuario=-1;
// 		short i_nmNome=-1;
// 		short i_nmLoginUsuario=-1;
// 		short i_idStatusUsuario=-1;
// 		short i_inDisponivelWF=-1;
// 
//     EXEC SQL END DECLARE SECTION;
// 
// 	if ( p=tx.walkTree( entrada, "idGrupo", 0 ),p )
//     {
//         idgrupo  = atoi(p); 
//         XMLString::release(&p);
//     }
// 
//     EXEC SQL WHENEVER SQLERROR  DO sql_error_IBWFPSUsuario(&sqlca);
// 	EXEC SQL WHENEVER NOT FOUND DO BREAK;
// 
//     
// 
// 	EXEC SQL DECLARE usuarioGrupo CURSOR FOR
//         SELECT
//             U.IDPESSOAUSUARIO,
//             P.NMNOME, 
//             U.NMLOGINUSUARIO,
//             U.IDSTATUSUSUARIO,
//             U.INDISPONIVELWF
//         FROM 
//             ACESSO.USUARIO U,
//             ACESSO.USUARIOGRUPO UG,
//             CUSTOMER.PESSOA P
//         WHERE UG.IDGRUPO = :idgrupo
//         AND UG.IDPESSOAUSUARIO = U.IDPESSOAUSUARIO
//         AND U.IDPESSOAUSUARIO = P.IDPESSOA;
// 
// 	EXEC SQL OPEN usuarioGrupo;
// 
// 	for(;;) 
// 	{
// 		EXEC SQL FETCH usuarioGrupo INTO :idPessoaUsuario:i_idPessoaUsuario, 
// 										 :nmNome:i_nmNome,
// 										 :nmLoginUsuario:i_nmLoginUsuario,
// 										 :idStatusUsuario:i_idStatusUsuario,
// 										 :inDisponivelWF:i_inDisponivelWF;
// 
// 		CONVIND(nmNome, i_nmNome);
// 		CONVIND(nmLoginUsuario, i_nmLoginUsuario);
// 
//    		saida->createTag("UsuarioVIVO");
//    		saida->addProp("xmlns", "usuario.fo.vivo.com.br/vo");
//    		saida->addItem("idPessoaUsuario",idPessoaUsuario);
//    		saida->addItem("nmNome", (char*)nmNome.arr);
//    		saida->addItem("nmLoginUsuario",(char*)nmLoginUsuario.arr);
// 	    saida->addItem("idStatusUsuario",CONVINT(idStatusUsuario,i_idStatusUsuario));
// 	    saida->addItem("inDisponivelWF",CONVINT(inDisponivelWF,i_inDisponivelWF));
//    		saida->closeTag();
// 	}
// 
// 	EXEC SQL CLOSE usuarioGrupo;
// 
//     ULOG_END("proCIbPesquisaUsuarioPorGrupo()");
// 
// 	return true;
// 
// }

bool proCIbPesquisaGrupoUsuarioAbertura(DOMNode*entrada,XMLGen* saida)
{
    ULOG_START("proCIbPesquisaGrupoUsuarioAbertura()");
    char *p;
	struct sqlca sqlca;
	TuxHelper tx;

    EXEC SQL BEGIN DECLARE SECTION;

		int idpessoausuario = 0;
		int idGrupo; 
		int idSequencia; 

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_IBWFPSUsuario(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	if ( p=tx.walkTree( entrada, "idPessoaUsuario", 0 ),p )
    {
        idpessoausuario = atoi(p); 
        XMLString::release(&p);
    }

	EXEC SQL DECLARE usuarioGrupoAbertura CURSOR FOR
	SELECT 
		idGrupo,
		idSequencia
	FROM 
		atendimento.PesquisaGrupoUsuarioV01
	WHERE
		idPessoaUsuario = :idpessoausuario;

	EXEC SQL OPEN usuarioGrupoAbertura;

    for(;;)
    {
		EXEC SQL FETCH usuarioGrupoAbertura INTO :idGrupo, 
												 :idSequencia;

		saida->createTag("GrupoAbertura");
			saida->addItem("idPessoaUsuario", idpessoausuario);
			saida->addItem("idGrupo", idGrupo);
			saida->addItem("idSequencia", idSequencia);
		saida->closeTag();
	}

	EXEC SQL CLOSE usuarioGrupoAbertura;

    ULOG_END("proCIbPesquisaGrupoUsuarioAbertura()");

	return true;

}

bool proCIbConsultaGruposUsuario(DOMNode*entrada, XMLGen* saida)
{
    ULOG_START("proCIbConsultaGruposUsuario()");
    char *p;
	struct sqlca sqlca;
	TuxHelper tx;

    EXEC SQL BEGIN DECLARE SECTION;
		int idpessoausuario = 0;

		int idgrupo; 
		VARCHAR nmgrupo[256];
		int idTipoSequencia;
		VARCHAR nmTipoSequencia[256];

		short i_idgrupo;
		short i_nmgrupo;
		short i_idTipoSequencia;
		short i_nmTipoSequencia;

    EXEC SQL END DECLARE SECTION;

	if ( p=tx.walkTree( entrada, "idPessoaUsuario", 0 ),p )
    {
        idpessoausuario = atoi(p); 
        XMLString::release(&p);
    }

    EXEC SQL WHENEVER SQLERROR  DO sql_error_IBWFPSUsuario(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE tsqlcursor2 CURSOR FOR
	SELECT 
		idGrupo, 
		nmGrupo,
		idTipoSequencia,
		nmTipoSequencia
	FROM 
		acesso.UsuarioGrupoTpTratV01
	WHERE
		idPessoaUsuario = :idpessoausuario
	ORDER BY 
		nmGrupo;

	EXEC SQL OPEN tsqlcursor2;

	int idGrupoOriginal = -1;

    for(;;)
    {
		EXEC SQL FETCH tsqlcursor2 INTO 
										:idgrupo:i_idgrupo, 
										:nmgrupo:i_nmgrupo,
										:idTipoSequencia:i_idTipoSequencia,
										:nmTipoSequencia:i_nmTipoSequencia;

		CONVIND(nmgrupo, i_nmgrupo);
		CONVIND(nmTipoSequencia, i_nmTipoSequencia);

		if (
			idGrupoOriginal == -1 || 
			(idGrupoOriginal != -1 && idgrupo != idGrupoOriginal)
		   )
		{
			if (idGrupoOriginal != -1)
			{
				saida->closeTag();
			}

			idGrupoOriginal = idgrupo;

			saida->createTag("WFGrupoVO");
				saida->addProp("xmlns","workflow.fo.vivo.com.br/vo");
				saida->addItem("idGrupo",idgrupo);
				saida->addItem("dsGrupo",(char*)nmgrupo.arr);
		}

		saida->createTag("WFTipoSequenciaVO");
			saida->addItem("idTipoSequencia",idTipoSequencia);
			saida->addItem("nmTipoSequencia",(char*)nmTipoSequencia.arr);
		saida->closeTag();
	}
	saida->closeTag();
	EXEC SQL CLOSE tsqlcursor2;

    ULOG_END("proCIbConsultaGruposUsuario()");

	return true;
 
}

bool proCIbPesquisaGrupoFaseVariables(st_VariaveisUsuario* _dados, Collection** _grupos)
{

    ULOG_START("proCIbPesquisaGrupoFaseVariables()");
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_VariaveisUsuario dados;

		VARCHAR idGrupo[256]; 

    EXEC SQL END DECLARE SECTION;

	memcpy(&dados, _dados, sizeof(dados));

	EXEC SQL DECLARE grupoFaseVariables CURSOR FOR
	SELECT 
		idGrupo
	FROM 
		atendimento.PesquisaGrupoFaseV01
	WHERE
		idTipoSequencia     = :dados.idFase
		AND idTipoCarteira  = :dados.idTipoCarteira
		AND idSegmentacao   = :dados.idSegmentacao
		AND idProcedencia   = :dados.idProcedencia
		AND idContato       = :dados.idContato
		AND GrupoAbertura	= :dados.idGrupoAbertura
		AND idTipoPessoa	= :dados.idTipoPessoa
		AND idCanal			= :dados.idCanal
		AND idTipoRelacionamento = :dados.idTipoRelacionamento
		AND idTipoLinha = :dados.idTipoLinha
	ORDER BY sqOrdem;
	
	EXEC SQL OPEN grupoFaseVariables;

	EXEC SQL WHENEVER SQLERROR  DO sql_error_IBWFPSUsuario(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO break;

    ULOG("sqlca.sqlcode = '%d'",sqlca.sqlcode);

	if( sqlca.sqlcode )
    {
		return false;
    }

	if ( *_grupos = new Collection(),_grupos )
    {
	    for(;;)
        {
		    EXEC SQL FETCH grupoFaseVariables INTO :idGrupo;

		    CONV(idGrupo);

            char *p = new char [idGrupo.len+1];

            sprintf(p,"%.*s",idGrupo.len,idGrupo.arr);

		    (*_grupos)->AddItem( (void*) p );
            
            ULOG("idGrupo = '%s'",idGrupo.arr);
	    }
	}

	EXEC SQL CLOSE grupoFaseVariables;

    ULOG_END("proCIbPesquisaGrupoFaseVariables()");

	return true;

}

bool proCIbPesquisaGrupoFaseVariablesUsuario(DOMNode*entrada,XMLGen* saida)
{

    ULOG_START("proCIbPesquisaGrupoFaseVariablesUsuario()");

    char *p;
	struct sqlca sqlca;
	TuxHelper tx;

    EXEC SQL BEGIN DECLARE SECTION;

		int idFase          = 0;
		int idTipoCarteira  = 0;
		int idSegmentacao   = 0;
		int idProcedencia   = 0;
		int idContato       = 0;
		int idPessoaUsuario = 0;
		int idGrupo; 

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_IBWFPSUsuario(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	if ( p=tx.walkTree( entrada, "idFase", 0 ),p )
    {
        idFase          = atoi(p); 
        XMLString::release(&p);
    }

	if ( p=tx.walkTree( entrada, "idTipoCarteira", 0 ),p )
    {
        idTipoCarteira  = atoi(p); 
        XMLString::release(&p);
    }

	if ( p=tx.walkTree( entrada, "idSegmentacao", 0 ),p )
    {
        idSegmentacao   = atoi(p); 
        XMLString::release(&p);
    }

	if ( p=tx.walkTree( entrada, "idProcedencia", 0 ),p )
    {
        idProcedencia   = atoi(p); 
        XMLString::release(&p);
    }

	if ( p=tx.walkTree( entrada, "idContato", 0 ),p )
    {
        idContato       = atoi(p); 
        XMLString::release(&p);
    }

	if ( p=tx.walkTree( entrada, "idPessoaUsuario", 0 ),p )
    {
        idPessoaUsuario = atoi(p); 
        XMLString::release(&p);
    }

	EXEC SQL DECLARE grupoFaseVariablesUsuario CURSOR FOR
	SELECT 
		idGrupo
	FROM 
		atendimento.PesquisaGrupoFaseUsuarioV01
	WHERE
		idFase              = :idFase
		AND idTipoCarteira  = :idTipoCarteira
		AND idSegmentacao   = :idSegmentacao
		AND idProcedencia   = :idProcedencia
		AND idContato       = :idContato
		AND idPessoaUsuario = :idPessoaUsuario
        AND idUFOperadora   = (SELECT IDUFOPERADORA 
                                 FROM ACESSO.USUARIO 
                                WHERE IDPESSOAUSUARIO = :idPessoaUsuario)
	ORDER BY numOrdem;
	
	EXEC SQL OPEN grupoFaseVariablesUsuario;

    for(;;)
    {
		EXEC SQL FETCH grupoFaseVariablesUsuario INTO :idGrupo;

		saida->createTag("GrupoFase");
			saida->addItem("idGrupo", idGrupo);
		saida->closeTag();
	}

	EXEC SQL CLOSE grupoFaseVariablesUsuario;

    ULOG_END("proCIbPesquisaGrupoFaseVariablesUsuario()");

	return true;

}

bool proCIbPesquisaGrupoFase(st_VariaveisUsuario* _dados, Collection** _grupos)
{
    ULOG_START("proCIbPesquisaGrupoFase()");
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_VariaveisUsuario dados;

		VARCHAR idGrupo[256]; 

    EXEC SQL END DECLARE SECTION;

	memcpy(&dados, _dados, sizeof(dados));

    EXEC SQL WHENEVER SQLERROR  DO sql_error_IBWFPSUsuario(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE grupoFase CURSOR FOR
	SELECT
	   distinct cg.idgrupo, sq.sqordem
  	FROM
  	   	contatoadm.contatogrupo cg,
         	contatoadm.sequencia sq
 	WHERE
	    	cg.idcontatogrupo = sq.idcontatogrupo
		AND sq.idTipoSequencia = :dados.idFase
		AND cg.idContato = :dados.idContato
	ORDER BY sq.sqOrdem;
	
	EXEC SQL OPEN grupoFase;

	if ( *_grupos = new Collection(),_grupos )
    {
	    for(;;)
        {
		    EXEC SQL FETCH grupoFase INTO :idGrupo;

			CONV(idGrupo);

            char *p = new char [idGrupo.len+1];

            sprintf(p,"%.*s",idGrupo.len,idGrupo.arr);

		    (*_grupos)->AddItem( (void*) p );

            ULOG("idGrupo = '%s'",idGrupo.arr);
	    }
    }

	EXEC SQL CLOSE grupoFase;

    ULOG_END("proCIbPesquisaGrupoFase()");

	return true;

}

bool proCIbPesquisaGrupoFaseUsuario(DOMNode*entrada,XMLGen* saida)
{
    ULOG_START("proCIbPesquisaGrupoFaseUsuario()");
    char *p;
	struct sqlca sqlca;
	TuxHelper tx;

    EXEC SQL BEGIN DECLARE SECTION;

		int idFase          = 0;
		int idContato       = 0;
		int idPessoaUsuario = 0;
		int idGrupo; 

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_IBWFPSUsuario(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	if ( p=tx.walkTree( entrada, "idFase", 0 ),p )
    {
        idFase          = atoi(p); 
        XMLString::release(&p);
    }

	if ( p=tx.walkTree( entrada, "idContato", 0 ),p )
    {
        idContato       = atoi(p); 
        XMLString::release(&p);
    }

	if ( p=tx.walkTree( entrada, "idPessoaUsuario", 0 ),p )
    {
        idPessoaUsuario = atoi(p); 
        XMLString::release(&p);
    }


	EXEC SQL DECLARE grupoFaseUsuario CURSOR FOR
	SELECT 
		idGrupo
	FROM 
		atendimento.PesquisaGrupoFaseUsuarioV01
	WHERE
		idFase              = :idFase
		AND idContato       = :idContato
		AND idPessoaUsuario = :idPessoaUsuario
	ORDER BY numOrdem;
	
	EXEC SQL OPEN grupoFaseUsuario;

    for(;;)
    {
		EXEC SQL FETCH grupoFaseUsuario INTO :idGrupo;

		saida->createTag("GrupoFase");
			saida->addItem("idGrupo", idGrupo);
		saida->closeTag();
	}

	EXEC SQL CLOSE grupoFaseUsuario;

    ULOG_END("proCIbPesquisaGrupoFaseUsuario()");

	return true;

}

bool proCIbPesquisaUsuarioGrupoCanal(DOMNode*entrada,XMLGen* saida)
{
    ULOG_START("proCIbPesquisaUsuarioGrupoCanal()");
    char *p;
	struct sqlca sqlca;
	TuxHelper tx;

    EXEC SQL BEGIN DECLARE SECTION;

		int idPessoaUsuario = 0;

		int     idCanal; 
		VARCHAR nmCanal[256];

		short i_idCanal;
		short i_nmCanal;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_IBWFPSUsuario(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	if ( p=tx.walkTree( entrada, "idPessoaUsuario", 0 ),p )
    {
        idPessoaUsuario = atoi(p); 
        XMLString::release(&p);
    }

	EXEC SQL DECLARE usuarioGrupoCanal CURSOR FOR
	SELECT DISTINCT
		idCanal,
		nmCanal
	FROM 
		acesso.UsuarioGrupoCanalv01
	WHERE
		idPessoaUsuario = :idPessoaUsuario
		AND inAtivo = 1
	ORDER BY nmCanal;
	
	EXEC SQL OPEN usuarioGrupoCanal;

	for(;;)
    {
		EXEC SQL FETCH usuarioGrupoCanal INTO 
												:idCanal:i_idCanal,
												:nmCanal:i_nmCanal;
		CONVIND(nmCanal, i_nmCanal)

		saida->createTag("CanalVO");
			saida->addItem("idCanal", idCanal);
			saida->addItem("nmCanal", (char*)nmCanal.arr);
		saida->closeTag();
	}

	EXEC SQL CLOSE usuarioGrupoCanal;

    ULOG_END("proCIbPesquisaUsuarioGrupoCanal()");

	return true;

}

bool proCIbPesquisaUsuarioGrupoProcedencia(DOMNode*entrada,XMLGen* saida)
{
    ULOG_START("proCIbPesquisaUsuarioGrupoProcedencia()");
    char *p;
	struct sqlca sqlca;
	TuxHelper tx;

    EXEC SQL BEGIN DECLARE SECTION;

		int idPessoaUsuario = 0;

		int     idProcedencia; 
		VARCHAR dsProcedencia[256];

		short i_idProcedencia;
		short i_dsProcedencia;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_IBWFPSUsuario(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	if ( p=tx.walkTree( entrada, "idPessoaUsuario", 0 ),p )
    {
        idPessoaUsuario = atoi(p); 
        XMLString::release(&p);
    }

	EXEC SQL DECLARE usuarioGrupoProcedencia CURSOR FOR
	SELECT DISTINCT
		idProcedencia,
		dsProcedencia
	FROM 
		acesso.UsuarioGrupoProcedenciav01
	WHERE
		idPessoaUsuario = :idPessoaUsuario
	ORDER BY dsProcedencia;
	
	EXEC SQL OPEN usuarioGrupoProcedencia;

    for(;;)
    {

		EXEC SQL FETCH usuarioGrupoProcedencia INTO 
												:idProcedencia:i_idProcedencia,
												:dsProcedencia:i_dsProcedencia;

		CONVIND(dsProcedencia, i_dsProcedencia)

		saida->createTag("ProcedenciaVO");
			saida->addProp("xmlns","admsistemas.fo.vivo.com.br/vo");
			saida->addItem("idProcedencia", idProcedencia);
			saida->addItem("dsProcedencia", (char*)dsProcedencia.arr);
		saida->closeTag();
	}

	EXEC SQL CLOSE usuarioGrupoProcedencia;

    ULOG_END("proCIbPesquisaUsuarioGrupoProcedencia()");

	return true;

}

void sql_error_IBWFPSUsuario(sqlca*sqlca)
{
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc);
	throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
