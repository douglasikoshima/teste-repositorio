#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CBxaListarMsg.h"

CBaixaMensagem::CBaixaMensagem()
{
}

CBaixaMensagem::~CBaixaMensagem()
{
}


int CBaixaMensagem::ListaMsgBaixaWF( char *idFormaRetParam,char *idMsgBaixaParam,char *dsMsgBaixaParam )
{
    ULOG_START("CBaixaMensagem::ListaMsgBaixaWF()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        int     idFormaRetorno = atoi(idFormaRetParam);
        int     idMsgBaixa;
        VARCHAR dsMsgBaixa[256];
    EXEC SQL END DECLARE SECTION;
    sqlca.sqlcode=0;

    EXEC SQL WHENEVER SQLERROR GOTO ErrorWF;
    EXEC SQL
        SELECT idMensagemBaixa INTO :idMsgBaixa
        FROM 
            CONTATOADM.BAIXAMENSAGEM
        WHERE
            IDFORMARETORNO = :idFormaRetorno;

    if ( sqlca.sqlcode )
    {
        ULOG_END("CBaixaMensagem::ListaMsgBaixaWF()  sqlca.sqlcode > 0 return 0");
        return 0;
    }   

    EXEC SQL
        SELECT
            DSMENSAGEMBAIXA 
        INTO 
            :dsMsgBaixa
        FROM 
            CONTATOADM.MENSAGEMBAIXA
        WHERE
            IDMENSAGEMBAIXA = :idMsgBaixa;

    if ( sqlca.sqlcode )
    {
        ULOG_END("CBaixaMensagem::ListaMsgBaixaWF() sqlca.sqlcode > 0 return 0");
        return 0;  //Erro
    }		   
    
    dsMsgBaixa.arr[dsMsgBaixa.len] = 0x0;

    sprintf( idMsgBaixaParam,"%d",idMsgBaixa );
    strcpy( dsMsgBaixaParam,(char *)dsMsgBaixa.arr );
    ULOG_END("CBaixaMensagem::ListaMsgBaixaWF() return 1");

    return 1;

ErrorWF:
	throw TuxBasicOraException(sqlca.sqlcode);
}


int CBaixaMensagem::ListTpComunicWF( char *idBaixaParam )
{
    ULOG_START("CBaixaMensagem::ListTpComunicWF()");

    CBaixaMensagem oBaixaMensagem;
    char idFormaRetorno[23];
    char idMsgBaixa[23];
    char dsMsgBaixa[256];

    idFormaRetorno[0] = 0;
    idMsgBaixa[0] = 0;
    dsMsgBaixa[0] = 0;

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        int idBaixaAux = atoi(idBaixaParam);
        int idFormaRetornoWrk;

        struct
        {
            VARCHAR stidBaixaMensagem[21+1];
            VARCHAR stidBaixa[21+1];
            VARCHAR stidTipoComunicacao[21+1];
            VARCHAR stdsTipoComunicacao[255+1];
            VARCHAR stidMensagem[21+1];
            VARCHAR stdsMensagem[255+1];
        } stBaixaMensagemRegistro;

        struct
        {
            short iidBaixaMensagem;
            short iidBaixa;
            short iidTipoComunicacao;
            short idsTipoComunicacao;
            short iidMensagem;
            short idsMensagem;
        } stBaixaMensagemIndicator;

    EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaMensagem();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListTpComunicWF;
		sqlca.sqlcode=0;

        EXEC SQL
            SELECT 
                IDFORMARETORNO
            INTO
                :idFormaRetornoWrk
            FROM 
                CONTATOADM.BAIXAMENSAGEM
            WHERE
                IDBAIXA = :idBaixaAux;

		EXEC SQL WHENEVER NOT FOUND DO BREAK;

		//Declara um cursor para listar todos os registros
   		EXEC SQL
   			DECLARE ReadFormaRetorno CURSOR FOR
                SELECT
                    BM.IDBAIXAMENSAGEM,
                    BM.IDBAIXA,
                    BM.IDFORMARETORNO,
                    FR.DSFORMARETORNO,
                    BM.IDMENSAGEMBAIXA,
                    MB.DSMENSAGEMBAIXA
                FROM 
                    CONTATOADM.BAIXAMENSAGEM BM,
                    CONTATOADM.FORMARETORNO FR,
                    CONTATOADM.MENSAGEMBAIXA MB
                WHERE
                    BM.IDFORMARETORNO = FR.IDFORMARETORNO
                AND
                    BM.IDMENSAGEMBAIXA = MB.IDMENSAGEMBAIXA	
                AND
                    BM.IDBAIXA = :idBaixaAux
                AND 
                    BM.IDFORMARETORNO = :idFormaRetornoWrk;

		EXEC SQL OPEN ReadFormaRetorno;

        if(sqlca.sqlcode)
        {
            ULOG_END("CBaixaMensagem::ListTpComunicWF() sqlca.sqlcode > 0 return 0");
            return 0;//Erro
        }

		EXEC SQL WHENEVER NOT FOUND DO BREAK;

        int iCont = 0;

		for(;;)
		{
            memset( &stBaixaMensagemRegistro, 0, sizeof(stBaixaMensagemRegistro) );

            EXEC SQL 
                FETCH ReadFormaRetorno 
                INTO :stBaixaMensagemRegistro:stBaixaMensagemIndicator;

            /*
            strcpy( idFormaRetorno,(char*)stBaixaMensagemRegistro.stidTipoComunicacao.arr );
            if ( oBaixaMensagem.ListaMsgBaixaWF( idFormaRetorno, idMsgBaixa, dsMsgBaixa ))
            {
                strcpy( (char *)stBaixaMensagemRegistro.stidMensagem.arr,idMsgBaixa );
                strcpy( (char *)stBaixaMensagemRegistro.stdsMensagem.arr,dsMsgBaixa );
                stBaixaMensagemRegistro.stidMensagem.len = strlen(idMsgBaixa);
                stBaixaMensagemRegistro.stdsMensagem.len = strlen(dsMsgBaixa);
            }
            */       

            //Adiciona a classe
            if ( stBaixaMensagemIndicator.idsTipoComunicacao >= 0 )
            {
                Add( (char*)stBaixaMensagemRegistro.stidBaixaMensagem.arr
                   , (char*)stBaixaMensagemRegistro.stidBaixa.arr
                   , (char*)stBaixaMensagemRegistro.stidTipoComunicacao.arr
                   , (char*)stBaixaMensagemRegistro.stdsTipoComunicacao.arr
                   , (char*)stBaixaMensagemRegistro.stidMensagem.arr
                   , (char*)stBaixaMensagemRegistro.stdsMensagem.arr );

                //conta quantos existem
                iCont++;
            }
        }

		EXEC SQL CLOSE ReadFormaRetorno;
		
        ULOG ("return iCont = [%d]",iCont);		
        ULOG_END("CBaixaMensagem::ListTpComunicWF()");		
      
		return iCont; //Retorna a quantidade de registros
	}
	catch(...)
	{
		throw;
	}

GotoListTpComunicWF:
	throw TuxBasicOraException(sqlca.sqlcode);
}


int CBaixaMensagem::ListTpComunicWFSel( char *idBaixaParam, int idTpComunicParam )
{
   ULOG_START("CBaixaMensagem::ListTpComunicWFSel()");

    CBaixaMensagem oBaixaMensagem;
    char idFormaRetorno[23];
    char idMsgBaixa[23];
    char dsMsgBaixa[256];

    idFormaRetorno[0] = 0x0;
    idMsgBaixa[0] = 0x0;
    dsMsgBaixa[0] = 0x0;

    //Variavel de controle para a quantidade de registros retornada
    int    iCont = 0;
	
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
      int idTpComunic = idTpComunicParam;
      int idBaixaWrk  = atoi( idBaixaParam );

		struct
		{
			VARCHAR stidBaixaMensagem[21+1];
			VARCHAR stidBaixa[21+1];
			VARCHAR stidTipoComunicacao[21+1];
			VARCHAR stdsTipoComunicacao[255+1];
			VARCHAR stidMensagem[21+1];
			VARCHAR stdsMensagem[255+1];
		} stBaixaMensagemRegistro;
		struct
		{
			short iidBaixaMensagem;
			short iidBaixa;
			short iidTipoComunicacao;
			short idsTipoComunicacao;
			short iidMensagem;
			short idsMensagem;
		} stBaixaMensagemIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaMensagem();

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListTpComunicWFSel;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL
   			DECLARE 
   				ReadFormaRetornoSel CURSOR FOR
				   SELECT 	 BM.IDBAIXAMENSAGEM
							,BM.IDBAIXA
							,BM.IDFORMARETORNO
							,FR.DSFORMARETORNO
							,BM.IDMENSAGEMBAIXA
							,MB.DSMENSAGEMBAIXA
				   FROM 
							CONTATOADM.BAIXAMENSAGEM BM,
							CONTATOADM.FORMARETORNO FR,
							CONTATOADM.MENSAGEMBAIXA MB
				   WHERE
							BM.IDFORMARETORNO=FR.IDFORMARETORNO
				   AND
							BM.IDMENSAGEMBAIXA=MB.IDMENSAGEMBAIXA			   
				   AND 
							BM.IDBAIXA = :idBaixaWrk
				   AND 
							BM.IDFORMARETORNO = :idTpComunic;

		EXEC SQL OPEN ReadFormaRetornoSel;

		if(sqlca.sqlcode)
			return 0;//Erro

		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			memset( &stBaixaMensagemRegistro, 0, sizeof(stBaixaMensagemRegistro) );

			EXEC SQL 
            FETCH 
               ReadFormaRetornoSel 
            INTO 
               :stBaixaMensagemRegistro:stBaixaMensagemIndicator;

            //Adiciona a classe
            if ( stBaixaMensagemIndicator.idsTipoComunicacao >= 0 )
            {
                Add( (char*)stBaixaMensagemRegistro.stidBaixaMensagem.arr
                   ,(char*)stBaixaMensagemRegistro.stidBaixa.arr
                   ,(char*)stBaixaMensagemRegistro.stidTipoComunicacao.arr
                   ,(char*)stBaixaMensagemRegistro.stdsTipoComunicacao.arr
                   ,(char*)stBaixaMensagemRegistro.stidMensagem.arr /* IDMENSAGEMBAIXA */
                   ,(char*)stBaixaMensagemRegistro.stdsMensagem.arr ); /* DSMENSAGEMBAIXA */

                //conta quantos existem
                iCont++;
            }
		}
		EXEC SQL CLOSE ReadFormaRetornoSel;
		
		ULOG_END("CBaixaMensagem::ListTpComunicWFSel()");
		return iCont;   //Retorna a quantidade de registros
	}
	catch(...)
	{
		throw;
	}

GotoListTpComunicWFSel:
	throw TuxBasicOraException(sqlca.sqlcode);

}


void CBaixaMensagem::GetXmlTpComunicWF( char* cNomeTagMen, char* cNomeTagTipo, char* cNomeTagMsg, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	ULOG_START("CBaixaMensagem::GetXmlTpComunicWF()");
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTagMen ) > 0 )
				xml->createTag(cNomeTagMen);
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				xml->addItem("idBaixaMensagem", Registro(x)->cidBaixaMensagem ); 
				xml->addItem("idMensagemBaixa", Registro(x)->cidMensagem ); 
				//Adiciona as tags necessarias
				if( strlennull( cNomeTagMsg ) > 0 )
					xml->createTag(cNomeTagMsg);
				xml->addItem("dsMensagemAviso", Registro(x)->cdsMensagem ); 
				if( strlennull( cNomeTagMsg ) > 0 )
					xml->closeTag();
				if( strlennull( cNomeTagTipo ) > 0 )
					xml->createTag(cNomeTagTipo);
				xml->addItem("idTipoComunicacao", Registro(x)->cidTipoComunicacao );
				xml->addItem("dsTipoComunicacao", Registro(x)->cdsTipoComunicacao );
				if( strlennull( cNomeTagTipo ) > 0 )
					xml->closeTag();
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTagMen ) > 0 )
				xml->closeTag();
		}
	}
   ULOG_END("CBaixaMensagem::GetXmlTpComunicWF()");	
}

void CBaixaMensagem::GetXmlTipoComunicacao( char* cNomeTagTipo, XMLGen*xml )
{
   ULOG_START("CBaixaMensagem::GetXmlTipoComunicacao()");
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				if( strlennull( cNomeTagTipo ) > 0 )
					xml->createTag(cNomeTagTipo);
				xml->addItem("idTipoComunicacao", Registro(x)->cidTipoComunicacao );
				xml->addItem("sgTipoComunicacao", "" );
				xml->addItem("dsTipoComunicacao", Registro(x)->cdsTipoComunicacao );
				if( strlennull( cNomeTagTipo ) > 0 )
					xml->closeTag();
			}
		}
	}
	ULOG_END("CBaixaMensagem::GetXmlTipoComunicacao()");
}

