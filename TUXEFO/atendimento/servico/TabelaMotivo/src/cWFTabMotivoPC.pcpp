/**
 * @modulo  Workflow
 * @usecase Workflow
 * @author
 * @version $Revision: 1.1 $
 * @CVS     $Author: a5110702 $ - $Date: 2009/07/31 15:33:31 $
 **/

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <tuxfw.h>

#include "../../../commons/queryMacro.h"
#include "../../../commons/msgPadrao.h"

void sql_error_WFPesquisaTabelaMotivo(sqlca*sqlca);

bool proCPesquisaMotivoAtividade(int _idAtividade,XMLGen* saida);
bool proCPesquisaMotivoAtividade(int _idAtividade,int _Fase,XMLGen* saida);
bool proCPesquisaMotivoAtividade(int _idFase,DOMNode*entrada,XMLGen* saida);
bool proCPesquisaMotivoAtividade(DOMNode*entrada,XMLGen* saida);
bool proCPesquisaMotivoAtividadeCPrevio(int _idAtividade,XMLGen* saida);

/*
bool proCPesquisaTabelaMotivo(DOMNode*entrada,XMLGen* saida)
{
	TuxHelper tx;
//    char *p = entrada ? tx.walkTree( entrada, "idTabelaMotivo", 0 ) : 0;
    char *p = entrada ? tx.walkTree( entrada, "idAtividade", 0 ) : 0;
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

//		int idTabelaMotivo = 0;
        int idAtividade = 0;
        int idMotivo;
		VARCHAR dsMotivo[256];

		short i_dsMotivo;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFPesquisaTabelaMotivo(&sqlca);

    if ( p )
    {
        idAtividade = atoi(p);
        XMLString::release(&p);
    }

	EXEC SQL
         SELECT 
   	          ATIVIDADEMOTIVO.IDATIVIDADE, MOTIVO.IDMOTIVO, MOTIVO.DSMOTIVO 
           FROM WORKFLOW.ATIVIDADEMOTIVO ATIVIDADEMOTIVO,
                ATENDIMENTO.MOTIVO MOTIVO 
          WHERE 
	              MOTIVO.IDMOTIVO  = ATIVIDADEMOTIVO.IDMOTIVO 
	        AND	  ATIVIDADEMOTIVO.IDATIVIDADE = :idAtividade
         ORDER BY UPPER(MOTIVO.DSMOTIVO);

	CONVIND( dsMotivo,i_dsMotivo );

	saida->createTag("AtendimentoInformacaoVO");
   	saida->addProp("xmlns", "workflow.fo.vivo.com.br/vo");
   	    saida->addItem( "idMotivo",idMotivo );
   	    saida->addItem( "dsMotivo",(char *)dsMotivo.arr );
	saida->closeTag();

	return true;
}

*/
bool proCPesquisaTabelaMotivo(DOMNode*entrada,XMLGen* saida)
{
    ULOG_START(" proCPesquisaTabelaMotivo()");   
	TuxHelper tx;
    char *p = entrada ? tx.walkTree( entrada, "idTabelaMotivo", 0 ) : 0;
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idTabelaMotivo = 0;
        int idMotivo;
		VARCHAR dsMotivo[256];

		short i_dsMotivo;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFPesquisaTabelaMotivo(&sqlca);

    if ( p )
    {
        idTabelaMotivo = atoi(p);
        XMLString::release(&p);
    }

	EXEC SQL
	    SELECT DISTINCT
		    a.idMOTIVO, 
		    a.dsMOTIVO
        INTO
            :idMotivo,
            :dsMotivo:i_dsMotivo
	    FROM 
		    Atendimento.MOTIVO            a,
		    Atendimento.MotivoTabelaMotivo b
	    WHERE
		    b.idTabelaMOTIVO = :idTabelaMotivo
	    And
	        b.idMOTIVO      = a.idMOTIVO
        And
            a.inVisivel = 1;


	CONVIND( dsMotivo,i_dsMotivo );

	saida->createTag("AtendimentoInformacaoVO");
   	saida->addProp("xmlns", "workflow.fo.vivo.com.br/vo");
   	    saida->addItem( "idMotivo",idMotivo );
   	    saida->addItem( "dsMotivo",(char *)dsMotivo.arr );
	saida->closeTag();
	
	ULOG_END("proCPesquisaTabelaMotivo()");   

	return true;
}


bool proCPesquisaMotivoAtividade(DOMNode*entrada,XMLGen* saida)
{
    ULOG_START(" proCPesquisaMotivoAtividade()");   
	TuxHelper tx;

    char *p = entrada ? tx.walkTree( entrada, "idAtividade", 0 ) : 0;

    int idAtividade = 0;

    if ( p )
    {
        idAtividade = atoi(p);
        XMLString::release(&p);
    }
    

    /* esta funcao foi incluida para nao gera erros em em outro locais dos motivios */
    int inRC = 0 ;
    if (p=tx.walkTree( entrada, "inRC", 0 ),p) 
	{
		if (strlen(p)>0)
		{
			inRC = atoi(p);
		}
		XMLString::release(&p);
	}

    bool retorno ;
    
    if ( 1 == inRC )
        retorno = proCPesquisaMotivoAtividadeCPrevio(idAtividade,saida);
    else
        retorno = proCPesquisaMotivoAtividade(idAtividade,saida);

    ULOG_END( "proCPesquisaMotivoAtividade()" );   
    return retorno ;
}


bool proCPesquisaMotivoAtividadeCPrevio(int _idAtividade,XMLGen* saida)
{
    ULOG_START( "proCPesquisaMotivoAtividadeCPrevio()" );   
    ULOG( "idAtividade = [%d]",_idAtividade );   
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idAtividade = _idAtividade;
		int idMotivo;
		VARCHAR dsMotivo[256];

		short i_dsMotivo=-1;

    
    EXEC SQL END DECLARE SECTION;

    ULOG(" QUERY = SELECT IDMOTIVO,DSMOTIVO FROM WORKFLOW.WFMOTIVOATIVIDADEV01  WHERE IDATIVIDADE = %d  ORDER BY UPPER(DSMOTIVO)",_idAtividade );

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFPesquisaTabelaMotivo(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE tsqlcursorCPrevio CURSOR FOR
       SELECT DISTINCT
              M.IDMOTIVO, M.DSMOTIVO
         FROM WORKFLOW.MOTIVOATIVIDADE MA,
              ATENDIMENTO.MOTIVO M,
              ATENDIMENTO.MOTIVOTABELAMOTIVO MB,
              ATENDIMENTO.TABELAMOTIVO MC
        WHERE MB.IDTABELAMOTIVO = MA.IDTABELAMOTIVO
          AND MC.IDTABELAMOTIVO = MB.IDTABELAMOTIVO
          AND M.IDMOTIVO        = MB.IDMOTIVO
          AND MC.INVISIVEL = 1
          AND M.INVISIVEL = 0
          AND M.DTEXCLUSAO IS NULL
          AND MB.IDMOTIVO = M.IDMOTIVO
	      and MA.IDATIVIDADE = :idAtividade
         ORDER BY       UPPER(DSMOTIVO);
		
	EXEC SQL OPEN tsqlcursorCPrevio;
	
	for(;;) 
    {
		EXEC SQL FETCH tsqlcursorCPrevio INTO 
                idMotivo, 
                dsMotivo:i_dsMotivo;

		CONVIND( dsMotivo,i_dsMotivo );
	
		saida->createTag("WFMotivoVO");
	   	    saida->addItem( "idMotivo",idMotivo );
	   	    saida->addItem( "dsMotivo",(char *)dsMotivo.arr );
		saida->closeTag();
	}
	
    EXEC SQL CLOSE tsqlcursorCPrevio;
    ULOG_END( "proCPesquisaMotivoAtividadeCPrevio()" );   
	if ( 0 ==  sqlca.sqlcode )
 	     return true;
	else
		return false;
}

bool proCPesquisaMotivoAtividade(int _idAtividade,XMLGen* saida)
{
    ULOG_START(" proCPesquisaMotivoAtividade()");   
    ULOG("idAtividade = [%d]",_idAtividade);   
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idAtividade = _idAtividade;
		int idMotivo;
		VARCHAR dsMotivo[256];

		short i_dsMotivo=-1;

    EXEC SQL END DECLARE SECTION;

    ULOG("QUERY = SELECT IDMOTIVO,DSMOTIVO FROM WORKFLOW.WFMOTIVOATIVIDADEV01 WHERE IDATIVIDADE = %d ORDER BY UPPER(DSMOTIVO)",_idAtividade );

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFPesquisaTabelaMotivo(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE tsqlcursor1 CURSOR FOR
	    SELECT 
		    IDMOTIVO, 
		    DSMOTIVO
	    FROM 
		    WORKFLOW.WFMOTIVOATIVIDADEV01
	    WHERE
		    IDATIVIDADE = :idAtividade
        ORDER BY
            UPPER(DSMOTIVO);

	EXEC SQL OPEN tsqlcursor1;

	for(;;) 
    {
		EXEC SQL FETCH tsqlcursor1 INTO 
                idMotivo, 
                dsMotivo:i_dsMotivo;

		CONVIND( dsMotivo,i_dsMotivo );

		saida->createTag("WFMotivoVO");
	   	    saida->addItem( "idMotivo",idMotivo );
	   	    saida->addItem( "dsMotivo",(char *)dsMotivo.arr );

            saida->createTag("WFAcaoVO");
                saida->addItem("idAtividade",idAtividade);
            saida->closeTag();

		saida->closeTag();
	}

    EXEC SQL CLOSE tsqlcursor1;

    ULOG_END("proCPesquisaMotivoAtividade()");

	if ( 0 ==  sqlca.sqlcode )
 	     return true;
	else
		return false;
}

bool proCPesquisaMotivoAtividade(int _idFase ,DOMNode*entrada,XMLGen* saida)
{
    ULOG_START(" proCPesquisaMotivoAtividade()");   
	TuxHelper tx;

    char *p = entrada ? tx.walkTree( entrada, "idAtividade", 0 ) : 0;

    int idAtividade = 0;

    if ( p )
    {
        idAtividade = atoi(p);
        XMLString::release(&p);
    }
    ULOG_END("proCPesquisaMotivoAtividade()");   
    return proCPesquisaMotivoAtividade(idAtividade,_idFase,saida);
}

bool proCPesquisaMotivoAtividade(int _idAtividade,int _idFase,XMLGen* saida)
{
   ULOG_START(" proCPesquisaMotivoAtividade()");   
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idAtividade = _idAtividade;
        int idFase = _idFase;
		int idMotivo;
		VARCHAR dsMotivo[256];

		short i_dsMotivo=-1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFPesquisaTabelaMotivo(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE tsqlcursor1Fase CURSOR FOR
           SELECT DISTINCT 
   		          MOTIVO.IDMOTIVO,
                  MOTIVO.DSMOTIVO 
             FROM WORKFLOW.MOTIVOATIVIDADE MOTIVOATIVIDADE, 
                  ATENDIMENTO.MOTIVO MOTIVO,
				  ATENDIMENTO.MOTIVOFASE MOTIVOFASE, 
                  ATENDIMENTO.MOTIVOTABELAMOTIVO MOTIVOTABELAMOTIVO, 
                  ATENDIMENTO.TABELAMOTIVO TABELAMOTIVO,
		          WORKFLOW.ATIVIDADE ATIVIDADE
            WHERE MOTIVOTABELAMOTIVO.IDTABELAMOTIVO = MOTIVOATIVIDADE.IDTABELAMOTIVO 
              AND TABELAMOTIVO.IDTABELAMOTIVO = MOTIVOTABELAMOTIVO.IDTABELAMOTIVO 
	          AND MOTIVO.IDMOTIVO        = MOTIVOTABELAMOTIVO.IDMOTIVO 
              AND TABELAMOTIVO.INVISIVEL = 1 
              AND MOTIVO.INVISIVEL = 1 
              AND MOTIVO.DTEXCLUSAO IS NULL 
              AND MOTIVOTABELAMOTIVO.IDMOTIVO = MOTIVO.IDMOTIVO 
	          AND ATIVIDADE.IDATIVIDADE = MOTIVOATIVIDADE.IDATIVIDADE
 			  AND MOTIVOFASE.IDMOTIVO   = MOTIVO.IDMOTIVO
              AND ATIVIDADE.IDATIVIDADE = :idAtividade
			  AND MOTIVOFASE.IDFASE     = :idFase
         ORDER BY UPPER(MOTIVO.DSMOTIVO);
		
	EXEC SQL OPEN tsqlcursor1Fase;
	
	for(;;) 
    {
		EXEC SQL FETCH tsqlcursor1Fase INTO 
                idMotivo, 
                dsMotivo:i_dsMotivo;

		CONVIND( dsMotivo,i_dsMotivo );
	
		saida->createTag("WFMotivoVO");
	   	    saida->addItem( "idMotivo",idMotivo );
	   	    saida->addItem( "dsMotivo",(char *)dsMotivo.arr );
		saida->closeTag();
	}
	
    EXEC SQL CLOSE tsqlcursor1Fase;
    
    ULOG_END("proCPesquisaMotivoAtividade()");

	return true;

}

void sql_error_WFPesquisaTabelaMotivo(sqlca*sqlca)
{

    ULOGE("sql_error_WFAtdInBoxAdq:sqlcode=%d,sqlerrmc=%.70s"
                            ,sqlca->sqlcode
                            ,sqlca->sqlerrm.sqlerrmc);

	throw new TuxBasicOraException
        (
            sqlca->sqlcode,
            sqlca->sqlerrm.sqlerrmc,
            sqlca->sqlerrm.sqlerrml
        );

}
