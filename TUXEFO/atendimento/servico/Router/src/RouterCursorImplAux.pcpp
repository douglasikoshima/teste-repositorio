#undef SQLCA
#define SQLCA_NONE

#include"../include/RouterClass.h"

/*++
Module Name:
    RouterSQLImplAux.pcpp

Abstract:
	Implements class to work with Oracle
	Extended PRO*C part

Author:
    Ivan Mentone 2004-06-29

Environment:
    Router Core

Revision History:

--*/

#include<sqlcpr.h>
#include<sqlca.h>
#include<sqlda.h>

//TR1
#define dvoid void*

EXEC SQL WHENEVER SQLERROR GOTO UndefinedError;

int RouterCursorImpl::SQLDAAllocator(void**pv,int sz)
{
	SQLDA*sqlda=0L;

	if(sz)
		sqlda=SQLSQLDAAlloc(SQL_SINGLE_RCTX,sz,CUSTSIZE,CUSTSIZE);
	*pv=sqlda;
	return 1;
}
int RouterCursorImpl::SQLDAFree(void*pv)
{
	if(pv)
		SQLSQLDAFree(SQL_SINGLE_RCTX,(SQLDA*)pv);
	return 1;
}
int RouterCursorImpl::Prepare()
{
	sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		char*psql;
	EXEC SQL END DECLARE SECTION;
	psql=sqlclause;
	EXEC SQL PREPARE stmt FROM :psql;
	EXEC SQL DECLARE cur CURSOR FOR stmt;
	adind=1;
	return 1;
UndefinedError:
	if(adind)
		sqlcd=sqlca.sqlcode;
	adind=0;
	return 0;
}
int RouterCursorImpl::AssembleWhere(void**ppv,short**pind)
{
	int ccW;
	COLUMN*col;
	int i;
	SQLDA*sqlda;
	sqlca sqlca;

	if(!adind)return 0;
	ccW=CountWhere();
	if(!ccW)
		return 0;
	SQLDAAllocator(ppv,ccW);
	*pind=(short*)malloc(sizeof(short)*ccW);
	sqlda=(SQLDA*)*ppv;
	sqlda->N=ccW;

	EXEC SQL DESCRIBE BIND VARIABLES FOR stmt INTO sqlda;

	for(i=0,col=wclause;col;col=col->nextColumn,i++)
	{
		if(col->paccum)
		{
			switch(col->paccum->descriptor.vartype)
			{
			case AC_STREAM:
				sqlda->T[i]=1;
				sqlda->V[i]=((RouterStreamImpl*)col->paccum->descriptor.var.othr)->GetText();
				(*pind)[i]=(short)NVL(col->cname);
				sqlda->I[i]=&((*pind)[i]);
				sqlda->L[i]=strlen(sqlda->V[i]);
				break;
			case AC_INTEGER:
				sqlda->T[i]=3;
				sqlda->V[i]=(char*)&(col->paccum->descriptor.var.i32);
				sqlda->L[i]=RTINT_SZ;
				(*pind)[i]=0;
				sqlda->I[i]=&((*pind)[i]);
				break;
			case AC_STRING:
				sqlda->T[i]=1;
				sqlda->V[i]=col->paccum->descriptor.var.pstr;
				(*pind)[i]=(short)NVL(col->cname);
				sqlda->I[i]=&((*pind)[i]);
				sqlda->L[i]=strlen(sqlda->V[i]);
				break;
			default:
				throw new TuxBasicSvcException("00E9999","SQL clause cannot support this datatype");
			}
		}
		else
		{
			sqlda->V[i]=col->cname;
			(*pind)[i]=(short)NVL(col->cname);
			sqlda->I[i]=&((*pind)[i]);
			sqlda->L[i]=strlen(sqlda->V[i]);
			sqlda->T[i]=1;
		}
	}
	return 1;
UndefinedError:
	if(adind)
		sqlcd=sqlca.sqlcode;
	adind=0;
	return 0;
}
int RouterCursorImpl::AssembleCols(void*pv,void**ppv,short**pind)
{
	COLUMN*col;
	SQLDA*sqlda;
	sqlca sqlca;
	int ccW,no;
	RouterStringImpl rsi;

	EXEC SQL BEGIN DECLARE SECTION;
		char*sql;
	EXEC SQL END DECLARE SECTION;

	if(!adind)return 0;
	if(!pcol)
		throw new TuxBasicSvcException("00E9999","Cannot find any colunms to fetch");
	col=pcol;

	ccW=CountSelList();
	SQLDAAllocator(ppv,ccW);

	sqlda=(SQLDA*)*ppv;
	*pind=(short*)malloc(sizeof(short)*(ccW));

	sql=sqlclause;
	sqlda->N=ccW;
	if(pv)
	{
		SQLDA*sqlda_=(SQLDA*)pv;
		EXEC SQL OPEN cur USING DESCRIPTOR sqlda_;
	}
	else
		EXEC SQL OPEN cur;
	EXEC SQL DESCRIBE SELECT LIST FOR stmt INTO sqlda;
	while(col)
	{
		SQLColumnNullCheck(SQL_SINGLE_RCTX,(unsigned short*)&(sqlda->T[cc]),(unsigned short*)&(sqlda->T[cc]),&no);
		col->paccum=rootAccum->RetrieveVar(col->cname);
		switch(sqlda->T[cc])
		{
			case 2:
				col->paccum->MakeVar(col->cname,AC_INTEGER);
				sqlda->T[cc]=3;
				sqlda->V[cc]=(char*)(&col->paccum->descriptor.var.i32);
				sqlda->L[cc]=RTINT_SZ;
				break;
			default:
				col->paccum->MakeVar(col->cname,AC_STRING);
				rsi.MakeString(col->paccum,1024);
				memset(col->paccum->descriptor.var.othr,0,1024);
				sqlda->T[cc]=1;
				sqlda->V[cc]=col->paccum->descriptor.var.pstr;
				sqlda->L[cc]=1023;	//Save byte to \0
		}
		sqlda->I[cc]=&(*pind)[cc++];
		col=col->nextColumn;
	}
	return 1;

UndefinedError:
	if(adind)
		sqlcd=sqlca.sqlcode;
	adind=0;
	return 0;
}
int RouterCursorImpl::AssembleColsAdj(void*pv,void**ppv,short**pind,RouterRecordsetImpl*prrs)
{
	COLUMN*col;
	SQLDA*sqlda;
	sqlca sqlca;
	int ccW,no,i;

	EXEC SQL BEGIN DECLARE SECTION;
		char*sql;
	EXEC SQL END DECLARE SECTION;

	if(!adind)return 0;
	if(!pcol)
		throw new TuxBasicSvcException("00E9999","Cannot find any colunms to fetch");
	col=pcol;

	ccW=prrs->GetColCount();
	SQLDAAllocator(ppv,ccW);

	sqlda=(SQLDA*)*ppv;
	*pind=(short*)malloc(sizeof(short)*(ccW));

	sql=sqlclause;
	sqlda->N=ccW;
	if(pv)
	{
		SQLDA*sqlda_=(SQLDA*)pv;
		EXEC SQL OPEN cur USING DESCRIPTOR sqlda_;
	}
	else
		EXEC SQL OPEN cur;
	EXEC SQL DESCRIBE SELECT LIST FOR stmt INTO sqlda;
	for(i=0;i<ccW;i++)
	{
		SQLColumnNullCheck(SQL_SINGLE_RCTX,(unsigned short*)&(sqlda->T[cc]),(unsigned short*)&(sqlda->T[cc]),&no);
		switch(sqlda->T[i])
		{
			case 2:
				sqlda->T[i]=3;
				sqlda->V[i]=(char*)prrs->GetColBuffInd(0,i,AC_INTEGER);
				sqlda->L[i]=RTINT_SZ;
				break;
			default:
				sqlda->T[i]=1;
				sqlda->V[i]=prrs->GetColBuffInd(1024,i,AC_STRING);
				sqlda->L[i]=1023;	//Save byte to \0
		}
		sqlda->I[i]=&(*pind)[i];
	}
	return 1;

UndefinedError:
	if(adind)
		sqlcd=sqlca.sqlcode;
	adind=0;
	return 0;
}
int RouterCursorImpl::ORAExecute(void*sqlsel,void*sqlbind)
{
	sqlca sqlca;
	short indbind=0;
	SQLDA*sqldabind;
	SQLDA*sqldasel;

	if(!adind)return 0;
	sqldabind=(SQLDA*)sqlbind;
	sqldasel=(SQLDA*)sqlsel;

	EXEC SQL WHENEVER NOT FOUND GOTO NotFound;
	EXEC SQL FETCH cur USING DESCRIPTOR sqldasel;

	EXEC SQL CLOSE cur;

	return 1;

UndefinedError:
	adind=0;
	return 0;
NotFound:
	return 2;
}
int RouterCursorImpl::ORAExecuteAdj(void*sqlsel,void*sqlbind,RouterRecordsetImpl*prrs)
{
	sqlca sqlca;
	short indbind=0;
	SQLDA*sqldabind;
	SQLDA*sqldasel;
	int rw=0;

	if(!adind)return 0;
	sqldabind=(SQLDA*)sqlbind;
	sqldasel=(SQLDA*)sqlsel;

	EXEC SQL WHENEVER NOT FOUND DO break;

	for(;;)
	{
		EXEC SQL FETCH cur USING DESCRIPTOR sqldasel;
		prrs->SetValues();
		rw++;
	}

	EXEC SQL CLOSE cur;

	return rw;

UndefinedError:
	if(adind)
		sqlcd=sqlca.sqlcode;
	adind=0;
	return 0;
}