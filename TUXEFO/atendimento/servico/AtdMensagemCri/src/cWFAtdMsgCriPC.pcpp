/**
 * @modulo  Workflow
 * @usecase Workflow
 * @author  Miguel Angel Benaventes
 * @version $Revision: 1.1.2.1 $
 * @CVS     $Author: a5110702 $ - $Date: 2010/04/06 14:28:07 $
 **/

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
#include<ctype.h>

#include "../include/cWFAtdMsgCri.h"
#include "../../../commons/SmallString.h"
#include "../../../commons/queryMacro.h"
#include "../../../commons/msgPadrao.h"


void sql_error_WFAtdMsgCri(sqlca*sqlca);

// Declara as estruturas compatíveis ao ProC.
EXEC SQL BEGIN DECLARE SECTION;
    #include "../include/stWFAtdMsgCri.h"
EXEC SQL END DECLARE SECTION;

bool proCIncluirWFAndamentoMensagem(st_AtdMsgCri* dados, st_vlAtdMsgCri* status)
{
    ULOG_START( "proCIncluirWFAndamentoMensagem()" );

    struct sqlca sqlca;

    if ( status->idAndamento == -1 )
    {
        ULOGE("idAndamento nao fornecido");
        ULOG_END( "proCIncluirWFAndamentoMensagem()" );
        return false;
    }

    if ( status->idPessoaUsuarioBko == -1 )
    {
        ULOGE("idPessoaUsuarioBko nao fornecido");
        ULOG_END( "proCIncluirWFAndamentoMensagem()" );
        return false;
    }

    if ( status->idUsuarioAlteracao == -1 )
    {
        ULOGE("idUsuarioAlteracao nao fornecido");
        ULOG_END( "proCIncluirWFAndamentoMensagem()" );
        return false;
    }

    EXEC SQL BEGIN DECLARE SECTION;

        unsigned long idAndamento = dados->idAndamento;
        unsigned long idPessoaUsuario = dados->idPessoaUsuario;
        unsigned long idPessoaUsuarioBko = dados->idPessoaUsuarioBko;
        unsigned long idUsuarioAlteracao = dados->idUsuarioAlteracao;

        int inOrigem = dados->inOrigem;

        char *dtMensagem = dados->dtMensagem;
        char *dtUltimaAlteracao = dados->dtUltimaAlteracao;

        struct st_vlAtdMsgCri oStatus;

    EXEC SQL END DECLARE SECTION;

    memcpy(&oStatus, status, sizeof(oStatus));

    ULOG( "idAndamento=%u",idAndamento);

    ULOG( "idPessoaUsuario=%d",idPessoaUsuario);

    ULOG( "idPessoaUsuarioBko=%d",idPessoaUsuarioBko);

    ULOG( "inOrigem=%d",inOrigem);

    ULOG( "dtMensagem=[%s]",dados->dtMensagem?dtMensagem:"(null)");

    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtdMsgCri(&sqlca);
    EXEC SQL 
      INSERT INTO
          ATENDIMENTO.ANDAMENTOMENSAGEM
          (
              IDANDAMENTO
             ,IDPESSOAUSUARIO
             ,IDPESSOAUSUARIODESTINO
             ,DTMENSAGEM
             ,IDUSUARIOALTERACAO
             ,DTULTIMAALTERACAO
             ,INORIGEM
          )
          VALUES
          (
              :idAndamento
             ,:idPessoaUsuario
             ,:idPessoaUsuarioBko
             ,TO_DATE(:dtMensagem,'DD/MM/YYYY HH24:MI:SS')
             ,:idPessoaUsuario
             ,SYSDATE
             ,DECODE(:oStatus.inOrigem, -1,0,:inOrigem)
          );

    ULOG_END( "proCIncluirWFAndamentoMensagem()" );

    return true;
}

bool proCConsultaWFMensagemUsuario(st_AtdMsgCri* dados, st_vlAtdMsgCri* status, XMLGen* saida)
{
    ULOG_START( "proCConsultaWFMensagemUsuario()" );

    struct sqlca sqlca;

    int numeroRegistros = 0;
    int totalRegistros = 0;

    EXEC SQL BEGIN DECLARE SECTION;

        struct st_SaidaAtdMsgCri
        {
            VARCHAR  idAtendimento[21];
            VARCHAR dsAtividade[256];
            int  idContato;
            VARCHAR dtMensagem[22];
            VARCHAR arvore[800];
            VARCHAR nrTelefone[256];
            VARCHAR nmPessoa[256];
        }oDadosSaida;
        
        struct st_vlSaidaAtdMsgCri
        {
            short idAtendimento;
            short dsAtividade;
            short idContato;
            short dtMensagem;
            // short qtInsistencia;
            short arvore;
            short nrTelefone;
            short nmPessoa;
        }oStatusSaida;

        struct st_AtdMsgCri oDados;
        struct st_vlAtdMsgCri oStatus;

    EXEC SQL END DECLARE SECTION;

    memcpy( &oDados , dados , sizeof(oDados));
    memcpy( &oStatus, status, sizeof(oStatus));

    memset(&oStatusSaida,-1,sizeof(oStatusSaida));


    ULOG("Filtro por usuario =  [%d]", oDados.idPessoaUsuario );
    ULOG("Filtro por Atendimento =  [%d]", oDados.idAtendimento );
    ULOG("Status Atendimento =  [%d]", oStatus.idAtendimento );

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtdMsgCri(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE consultaWFMsgUsuario CURSOR FOR
        SELECT 
            idAtendimento, 
            dsAtividade, 
            idContato, 
            TO_CHAR(dtMensagem,'DD/MM/YYYY HH24:MI:SS'), 
            path,
            nrTelefone,
            nmPessoa
         FROM 
            Atendimento.ATDMENSAGEMWFV01
         WHERE 
            idPessoaUsuarioDestino = :oDados.idPessoaUsuario
            AND (idAtendimento = :oDados.idAtendimento OR -1=:oStatus.idAtendimento)
            AND (idContato = :oDados.idContato OR -1=:oStatus.idContato)
            AND (TRUNC(dtMensagem)>=TO_DATE(:oDados.dtAberturaInicio, 'DD/MM/YYYY' ) OR -1 = :oStatus.dtAberturaInicio)
            AND (TRUNC(dtMensagem)<=TO_DATE(:oDados.dtAberturaFim,'DD/MM/YYYY') OR -1 = :oStatus.dtAberturaFim)
    ORDER BY dtMensagem DESC;

    EXEC SQL OPEN consultaWFMsgUsuario;

    char sbuffer[129];

    // limpa a estrutura 
    memset(&oDadosSaida,-1,sizeof(oDadosSaida));
    memset(&oStatusSaida,-1,sizeof(oStatusSaida));


    while (true)
    {
        EXEC SQL FETCH consultaWFMsgUsuario INTO :oDadosSaida INDICATOR :oStatusSaida;

        totalRegistros++;

        if (numeroRegistros < 100)
        {
            numeroRegistros++;

            saida->createTag("RWFAtendimentoVO");
        
                saida->addProp("xmlns", "workflow.fo.vivo.com.br/vo");

                CONVIND(oDadosSaida.idAtendimento, oStatusSaida.idAtendimento);
                CONVIND(oDadosSaida.dtMensagem, oStatusSaida.dtMensagem);
                CONVIND(oDadosSaida.dsAtividade, oStatusSaida.dsAtividade);
                CONVIND(oDadosSaida.nrTelefone, oStatusSaida.nrTelefone);
                CONVIND(oDadosSaida.arvore, oStatusSaida.arvore);
                CONVIND(oDadosSaida.nmPessoa, oStatusSaida.nmPessoa);

//              saida->addItem("idAtendimento", (char*)oDadosSaida.idAtendimento.arr);
                sprintf( sbuffer,"%.*s",oDadosSaida.idAtendimento.len,(char *)&oDadosSaida.idAtendimento.arr );
                ULOG( "idAtendimento [%s]", sbuffer );
                saida->addItem("idAtendimento", sbuffer );

//              saida->addItem("dtAbertura", (char*)oDadosSaida.dtMensagem.arr);
                sprintf( sbuffer,"%.*s",oDadosSaida.dtMensagem.len,(char *)&oDadosSaida.dtMensagem.arr );
                ULOG( "dtAbertura [%s]", sbuffer );
                saida->addItem("dtAbertura", sbuffer );

//              saida->addItem("operacaoWorkflow", (char*)oDadosSaida.dsAtividade.arr);
                sprintf( sbuffer,"%.*s",oDadosSaida.dsAtividade.len,(char *)&oDadosSaida.dsAtividade.arr );
                ULOG( "operacaoWorkflow [%s]", sbuffer );
                saida->addItem("operacaoWorkflow", sbuffer);

//              saida->addItem("nrTelefone", (char*)oDadosSaida.nrTelefone.arr);
                sprintf( sbuffer,"%.*s",oDadosSaida.nrTelefone.len,(char *)&oDadosSaida.nrTelefone.arr );
                ULOG("nrTelefone [%s]", sbuffer );
                saida->addItem("nrTelefone", sbuffer );

//              saida->addItem("descricaoCompleta", (char*)oDadosSaida.arvore.arr);
                sprintf( sbuffer,"%.*s",oDadosSaida.arvore.len,(char *)&oDadosSaida.arvore.arr );
                ULOG("descricaoCompleta [%s]", sbuffer );
                saida->addItem("descricaoCompleta", sbuffer );

//              saida->addItem("nmNome", (char*)oDadosSaida.nmPessoa.arr);
                sprintf( sbuffer,"%.*s",oDadosSaida.nmPessoa.len,(char *)&oDadosSaida.nmPessoa.arr );
                ULOG("nmPessoa [%s]", sbuffer );
                saida->addItem("nmNome", sbuffer );
            saida->closeTag();
            // limpa a estrutura 
            memset(&oDadosSaida,-1,sizeof(oDadosSaida));
            memset(&oStatusSaida,-1,sizeof(oStatusSaida));

        }
    }

    saida->addItem("totalRegistros", totalRegistros);
    saida->addItem("nrRegistros", numeroRegistros);

    EXEC SQL CLOSE consultaWFMsgUsuario;

    ULOG_END( "proCConsultaWFMensagemUsuario()" );

    return true;
}




bool proCConsultaWFMensagemLinha(st_AtdMsgCri* dados, st_vlAtdMsgCri* status, XMLGen* saida)
{
    ULOG_START( "proCConsultaWFMensagemLinha()" );

    struct sqlca sqlca;

    int numeroRegistros = 0;
    int totalRegistros = 0;

    int prefixo = 0;
    int numero  = 0;
    char cConv[3];

    if ( dados->nrLinha[0]=='0' ) 
    {
        strncpy(cConv,dados->nrLinha+1,2);cConv[2]=0;
        prefixo = atoi(cConv);
        numero  = atoi(dados->nrLinha+3);
    }
    else
    {
        strncpy(cConv,dados->nrLinha,2);cConv[2]=0;
        prefixo = atoi(cConv);
        numero  = atoi(dados->nrLinha+2);
    }

    EXEC SQL BEGIN DECLARE SECTION;

    int   oprefixo         = prefixo;
    int   otelefone        = numero;

    struct st_SaidaAtdMsgCri
    {
        VARCHAR  idAtendimento[21];
        VARCHAR dsAtividade[256];
        int  idContato;
        VARCHAR dtMensagem[22];
        VARCHAR arvore[800];
        VARCHAR nrTelefone[256];
        VARCHAR nmPessoa[256];
    }oDadosSaida;
    
    struct st_vlSaidaAtdMsgCri
    {
        short idAtendimento;
        short dsAtividade;
        short idContato;
        short dtMensagem;
        short qtInsistencia;
        short arvore;
        short nrTelefone;
        short nmPessoa;
    }oStatusSaida;

    struct st_AtdMsgCri oDados;
    struct st_vlAtdMsgCri oStatus;

    EXEC SQL END DECLARE SECTION;

    memcpy(&oDados, dados, sizeof(oDados));
    memcpy(&oStatus, status, sizeof(oStatus));
    memset(&oStatusSaida,-1,sizeof(oStatusSaida));

    ULOG("Filtro por Linha =  [%s]", dados->nrLinha);
    ULOG("Filtro por Usuario =  [%d]", dados->idPessoaUsuario);
    ULOG("Filtro por Atendimento =  [%d]", dados->idAtendimento);

    ULOG("Filtro por Linha =  [%d]", status->nrLinha);
    ULOG("Filtro por usuario =  [%d]", status->idPessoaUsuario);
    ULOG("Filtro por Atendimento =  [%d]", status->idAtendimento);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtdMsgCri(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE consultaWFMsgLinha CURSOR FOR
        SELECT 
            idAtendimento, 
            dsAtividade, 
            idContato, 
            TO_CHAR(dtMensagem,'DD/MM/YYYY HH24:MI:SS'), 
            path,
            nrTelefone,
            nmPessoa
         FROM 
            Atendimento.ATDMENSAGEMWFV01
         WHERE 
            idPessoaUsuarioDestino = :oDados.idPessoaUsuario
            AND cdAreaRegistro = :oprefixo
            AND nrLinha = :otelefone
            AND (idAtendimento = :oDados.idAtendimento OR -1=:oStatus.idAtendimento)
            AND (idContato = :oDados.idContato OR -1=:oStatus.idContato)
            AND (TRUNC(dtMensagem)>=TO_DATE(:oDados.dtAberturaInicio, 'DD/MM/YYYY' ) OR -1 = :oStatus.dtAberturaInicio)
            AND (TRUNC(dtMensagem)<=TO_DATE(:oDados.dtAberturaFim,'DD/MM/YYYY') OR -1 = :oStatus.dtAberturaFim)
    ORDER BY dtMensagem DESC;

    EXEC SQL OPEN consultaWFMsgLinha;

    char sbuffer[129];

    // limpa a estrutura 
    memset(&oDadosSaida,-1,sizeof(oDadosSaida));
    memset(&oStatusSaida,-1,sizeof(oStatusSaida));
    while (true)
    {
        EXEC SQL FETCH consultaWFMsgLinha INTO :oDadosSaida INDICATOR :oStatusSaida;

        totalRegistros++;

        if (numeroRegistros < 100)
        {
            numeroRegistros++;

            saida->createTag("RWFAtendimentoVO");
        
                saida->addProp("xmlns", "workflow.fo.vivo.com.br/vo");

//              saida->addItem("idAtendimento", (char*)oDadosSaida.idAtendimento.arr);
                sprintf( sbuffer,"%.*s",oDadosSaida.idAtendimento.len,(char *)&oDadosSaida.idAtendimento.arr );
                ULOG("idAtendimento [%s]", sbuffer );
                saida->addItem("idAtendimento", sbuffer );

//              saida->addItem("dtAbertura", (char*)oDadosSaida.dtMensagem.arr);
                sprintf( sbuffer,"%.*s",oDadosSaida.dtMensagem.len,(char *)&oDadosSaida.dtMensagem.arr );
                ULOG("dtAbertura [%s]", sbuffer );
                saida->addItem("dtAbertura", sbuffer );

//              saida->addItem("operacaoWorkflow", (char*)oDadosSaida.dsAtividade.arr);
                sprintf( sbuffer,"%.*s",oDadosSaida.dsAtividade.len,(char *)&oDadosSaida.dsAtividade.arr );
                ULOG("operacaoWorkflow [%s]", sbuffer );
                saida->addItem("operacaoWorkflow", sbuffer);

//              saida->addItem("nrTelefone", (char*)oDadosSaida.nrTelefone.arr);
                sprintf( sbuffer,"%.*s",oDadosSaida.nrTelefone.len,(char *)&oDadosSaida.nrTelefone.arr );
                ULOG("nrTelefone [%s]", sbuffer );
                saida->addItem("nrTelefone", sbuffer );

//              saida->addItem("descricaoCompleta", (char*)oDadosSaida.arvore.arr);
                sprintf( sbuffer,"%.*s",oDadosSaida.arvore.len,(char *)&oDadosSaida.arvore.arr );
                ULOG("descricaoCompleta [%s]", sbuffer );
                saida->addItem("descricaoCompleta", sbuffer );

//              saida->addItem("nmNome", (char*)oDadosSaida.nmPessoa.arr);
                sprintf( sbuffer,"%.*s",oDadosSaida.nmPessoa.len,(char *)&oDadosSaida.nmPessoa.arr );
                ULOG("nmPessoa [%s]", sbuffer );
                saida->addItem("nmNome", sbuffer );

            saida->closeTag();
 

            // limpa a estrutura 
            memset(&oDadosSaida,-1,sizeof(oDadosSaida));
            memset(&oStatusSaida,-1,sizeof(oStatusSaida));

            
        }
    }

    saida->addItem("totalRegistros", totalRegistros);
    saida->addItem("nrRegistros", numeroRegistros);

    EXEC SQL CLOSE consultaWFMsgLinha;

    ULOG_END( "proCConsultaWFMensagemLinha()" );

    return true;
}




void sql_error_WFAtdMsgCri( sqlca * sqlca )
{
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    ULOGE( "sql_error_WFAtdMsgCri:sqlcode=%d,sqlerrmc=%.70s"
                            ,sqlca->sqlcode
                            ,sqlca->sqlerrm.sqlerrmc);

    throw new TuxBasicOraException(sqlca->sqlcode
                                  ,sqlca->sqlerrm.sqlerrmc
                                  ,sqlca->sqlerrm.sqlerrml);
}
