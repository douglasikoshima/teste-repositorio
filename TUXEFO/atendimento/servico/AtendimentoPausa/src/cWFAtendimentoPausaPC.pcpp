/**
 * 
 * @modulo  Workflow
 * @usecase Workflow
 * @author  Charles Santos
 * @version $Revision: 1.1.2.2.6.2 $
 * @CVS     $Author: a5114878 $ - $Date: 2013/02/06 12:36:44 $
 **/

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"
#include "../../../commons/msgPadrao.h"

#include "../include/cWFAtendimentoPausa.h"

// Declara as estruturas compatíveis ao ProC.
EXEC SQL BEGIN DECLARE SECTION;
    #include "../include/stWFAtendimentoPausa.h"
EXEC SQL END DECLARE SECTION;

void sql_error_WFAtendimentoPausa(sqlca*sqlca);

bool proCExistePausa( long _idAtendimento )
{
    ULOG_START( "proCExistePausa()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        long idAtendimento = _idAtendimento;
        int counter;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoPausa(&sqlca);

    EXEC SQL 
          SELECT
              COUNT(1)
          INTO 
              :counter
          FROM 
              ATENDIMENTO.ATENDIMENTOPAUSA
          WHERE 
              IDATENDIMENTO = :idAtendimento;

    ULOG( "idAtendimento %d %s esta em pausa",idAtendimento,counter?"":"NÃO" );

    ULOG_END( "proCExistePausa()" );

    return counter ? true : false;
}


void proCAlterarWFAtendimentoPausa(st_AtendimentoPausa* dados,st_vlAtendimentoPausa* status)
{
    ULOG_START( "proCAlterarWFAtendimentoPausa()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        struct st_AtendimentoPausa *pDados = dados;
        struct st_vlAtendimentoPausa *pStatus = status;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoPausa(&sqlca);
    
    EXEC SQL 
        UPDATE
            ATENDIMENTO.ATENDIMENTOPAUSA
        SET
            DTFIMPAUSAATENDIMENTO = DECODE(:pStatus->dtFimPausaAtendimento,-1,SYSDATE,
                                        TO_DATE(:pDados->dtFimPausaAtendimento, 'DD/MM/YYYY HH24:MI:SS')),
            IDUSUARIOALTERACAO = DECODE(:pStatus->idUsuarioAlteracao,-1,NULL,:pDados->idUsuarioAlteracao),
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :pDados->idAtendimento;

    ULOG_END( "proCAlterarWFAtendimentoPausa()" );
}

void proCIncluirWFAtendimentoPausa(st_AtendimentoPausa *dados,st_vlAtendimentoPausa *status, XMLGen *saida)
{
    ULOG_START( "proCIncluirWFAtendimentoPausa()" );

    // Verifica se o atendimento já está em pausa e desvia para a alteração
    if ( proCExistePausa(dados->idAtendimento) )
    {
        proCAlterarWFAtendimentoPausa(dados, status);
        return;
    }

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        struct st_AtendimentoPausa *oDados = dados;
        struct st_vlAtendimentoPausa *oStatus = status;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoPausa(&sqlca);

    //ULOG("dtFimPausaAtendimento=%s",oDados->dtFimPausaAtendimento); //@cassio
    //ULOG("   idUsuarioAlteracao=%d",oDados->idUsuarioAlteracao); //@cassio

    EXEC SQL
        INSERT INTO
            ATENDIMENTO.ATENDIMENTOPAUSA
            (
                IDATENDIMENTO,
                DTFIMPAUSAATENDIMENTO,
                IDUSUARIOALTERACAO,
                DTULTIMAALTERACAO
            )
            VALUES
            (
                :oDados->idAtendimento,
                TO_DATE(:oDados->dtFimPausaAtendimento,'DD/MM/YYYY HH24:MI:SS'),
                DECODE(:oStatus->idUsuarioAlteracao,-1,NULL,:oDados->idUsuarioAlteracao),
                SYSDATE
            );

    ULOG_END( "proCIncluirWFAtendimentoPausa()" );
}

bool proCProcessoEmPausaSimNao(long _idAtendimento)
{
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        long idAtendimento = _idAtendimento;
        int inPausa;
        short i_inPausa=-1;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoPausa(&sqlca);

    EXEC SQL 
        SELECT
			SIGN(DTFIMPAUSAATENDIMENTO-SYSDATE) AS RESULT
        INTO
            :inPausa:i_inPausa
        FROM
            ATENDIMENTO.ATENDIMENTOPAUSA
        WHERE
            IDATENDIMENTO = :idAtendimento;

    if ( sqlca.sqlcode )
    {
        return false; // Processo não esta em pausa
    }

    return inPausa >=0 ? true : false;
}

void proCExcluirWFAtendimentoPausa(st_AtendimentoPausa* dados, st_vlAtendimentoPausa* status, XMLGen* saida)
{
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = dados->idAtendimento;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoPausa(&sqlca);

    EXEC SQL 
        DELETE
            ATENDIMENTO.ATENDIMENTOPAUSA
        WHERE
            IDATENDIMENTO = :idAtendimento;
}

bool proCObterWFRegistroPausa(long sIdAtendimento,st_AtendimentoPausa* dados)
{
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        long idAtendimento = sIdAtendimento;
        struct st_AtendimentoPausa *oDados = dados;
        struct st_vlAtendimentoPausa oStatus ;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoPausa(&sqlca);

    EXEC SQL 
        SELECT
            IDATENDIMENTO,
            DTULTIMAALTERACAO,
            IDUSUARIOALTERACAO,
            DTULTIMAALTERACAO
        INTO
            :oDados:oStatus
        FROM
            ATENDIMENTO.ATENDIMENTOPAUSA
        WHERE
            IDATENDIMENTO = :idAtendimento;

  return !sqlca.sqlcode ? true : false;
}



void proCConsultaWFAtendimentoPausa(st_AtendimentoPausa* dados, st_vlAtendimentoPausa* status, char* order, XMLGen* saida)
{
    ULOG_START( "proCConsultaWFAtendimentoPausa()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

      long idAtendimento ;
      char  dtFimPausaAtendimento[64];
      int  idUsuarioAlteracao;
      char dtUltimaAlteracao[64];

      short iidAtendimento ;
      short idtFimPausaAtendimento;
      short iidUsuarioAlteracao;
      short idtUltimaAlteracao;

      char query[1024];

   EXEC SQL END DECLARE SECTION;

   EXEC SQL WHENEVER SQLERROR  DO sql_error_WFEstado(&sqlca);
   EXEC SQL WHENEVER NOT FOUND DO BREAK;

    sprintf(query,"SELECT "
                         "idAtendimento,dtFimPausaAtendimento,idUsuarioAlteracao,dtUltimaAlteracao"
                    "FROM atendimento.AtendimentoPausa ");

    bool separa = false;

    if (status->idAtendimento != -1) 
        montaWhere("idAtendimento", dados->idAtendimento, 1);

    if (status->dtFimPausaAtendimento != -1) 
        montaWhere("dtFimPausaAtendimento", dados->dtFimPausaAtendimento, TIPO_DATAHORA);


    if (status->idUsuarioAlteracao != -1) 
        montaWhere("idUsuarioAlteracao", dados->idUsuarioAlteracao, TIPO_INT);

    if (status->dtUltimaAlteracao != -1) 
        montaWhere("dtUltimaAlteracao", dados->dtUltimaAlteracao, TIPO_DATAHORA);

    if (strlen(order) > 0) 
        sprintf( query, "%s ORDER BY %s ", query, order);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoPausa(&sqlca);

    EXEC SQL PREPARE consultaAtendimentoPausa FROM :query;
    EXEC SQL DECLARE consulta CURSOR FOR consultaAtendimentoPausa;

    EXEC SQL OPEN consulta;

    while (true)
    {
        EXEC SQL FETCH consulta INTO 
            :idAtendimento:iidAtendimento, 
            :dtFimPausaAtendimento:idtFimPausaAtendimento,
            :idUsuarioAlteracao:iidUsuarioAlteracao,
            :dtUltimaAlteracao:idtUltimaAlteracao;

        saida->createTag("WFAtendimentoPausaVO");
            saida->addItem("idAtendimento", idAtendimento);
            saida->addItem("dtFimPausaAtendimento", dtFimPausaAtendimento);
            saida->addItem("idUsuarioAlteracao", idUsuarioAlteracao);
            saida->addItem("dtUltimaAlteracao", dtUltimaAlteracao);
        saida->closeTag();
    }

    EXEC SQL CLOSE consulta;

    ULOG_END( "proCConsultaWFAtendimentoPausa()" );

}


void sql_error_WFAtendimentoPausa(sqlca*sqlca)
{
    throw new TuxBasicOraException(sqlca->sqlcode
                                  ,sqlca->sqlerrm.sqlerrmc
                                  ,sqlca->sqlerrm.sqlerrml);
}
