
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CConsultaConta.h"
#include "../../../commons/queryMacro.h"
#include "../../../commons/SmallString.h"
#include "../../../commons/msgPadrao.h"


void SqlError( sqlca * sqlca );


CConsultaConta::CConsultaConta( DOMNode * dnode )
{
	char *p;

    if (p = tx.walkTree( dnode, "idAtendimento", 0 ), p ) 
    {
        idAtendimentoPrm = atol(p);
        XMLString::release(&p);
    }

    if (p = tx.walkTree( dnode, "idPessoa", 0 ), p ) 
    {
        idPessoaPrm = atol( p );
        XMLString::release(&p);
    }

    if (p = tx.walkTree( dnode, "tpOperacao", 0 ), p ) 
    {
        iOperacao = atoi( p );
        XMLString::release(&p);
    }

    if (p = tx.walkTree( dnode, "cdConta", 0 ), p ) 
    {
        strcpy( cdContaPrm,p );
        XMLString::release(&p);
    }

    if (p = tx.walkTree( dnode, "nrLinha", 0 ), p ) 
    {
        strcpy( nrLinhaPrm,p );
        XMLString::release(&p);
    }

}




int CConsultaConta::GetOperacao( void )
{
	return iOperacao;
}




int CConsultaConta::ListaContas( XMLGen* saida )
{
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idPessoa = idPessoaPrm;
		VARCHAR cdConta[101];
		short i_cdConta = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO SqlError(&sqlca);

    EXEC SQL DECLARE ListaContas CURSOR FOR
	SELECT
	   CONTA.CDCONTA
	FROM
	   CUSTOMER.PESSOADEPARA PESSOADEPARA ,
	   CUSTOMER.PESSOACONTA  PESSOACONTA ,
	   CUSTOMER.CONTA        CONTA
	WHERE
	   PESSOADEPARA.IDPESSOADEPARA = PESSOACONTA.IDPESSOADEPARA
	AND
	   PESSOACONTA.IDCONTA = CONTA.IDCONTA
	AND 
       PESSOACONTA.IDTIPORELACIONAMENTO = 2
	AND
	   PESSOADEPARA.IDPESSOA = :idPessoa
	AND 
	   ROWNUM <= 100;
	   

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL OPEN ListaContas;
    saida->createTag( "ListaDadosVO" );
    saida->addProp("xmlns","workflow.fo.vivo.com.br/vo");
    saida->addItem( "idPessoa",idPessoaPrm );
	for ( ;; )
	{
        EXEC SQL FETCH ListaContas INTO
            :cdConta:i_cdConta;

        CONVIND( cdConta,i_cdConta );
        saida->addItem( "vlItem",(char *)cdConta.arr );
	}
    saida->closeTag();
    EXEC SQL CLOSE ListaContas;

    return 1;
}

int CConsultaConta::ListaLinhas( XMLGen* saida )
{
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        char cdConta[101];
        VARCHAR nrLinha[32];
		short i_nrLinha = -1;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO SqlError(&sqlca);
    
    strcpy(cdConta,cdContaPrm);
    
    ULOG( "Pesquisando cdConta [%s]",cdConta );

    EXEC SQL DECLARE ListaLinhas CURSOR FOR
	SELECT
	   AREAREGISTRO.CDAREAREGISTRO||LINHABASE.NRLINHA
	FROM
	   CUSTOMER.CONTA        CONTA ,
	   CUSTOMER.LINHACONTA   LINHACONTA ,
	   LINHA.LINHATELEFONICA LINHATELEFONICA ,
	   LINHA.LINHABASE       LINHABASE ,
	   APOIO.AREAREGISTRO    AREAREGISTRO 
	WHERE
	   CONTA.CDCONTA = :cdConta
	AND
	   LINHACONTA.IDCONTA = CONTA.IDCONTA
	AND
	   LINHACONTA.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
	AND
	   LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
	AND
	   LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO 
	AND 
	   ROWNUM <= 100;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL OPEN ListaLinhas;
    saida->createTag( "ListaDadosVO" );
    saida->addProp("xmlns","workflow.fo.vivo.com.br/vo");
    saida->addItem( "idPessoa",idPessoaPrm );
	for ( ;; )
	{
        EXEC SQL FETCH ListaLinhas INTO
            :nrLinha:i_nrLinha;

        CONVIND( nrLinha,i_nrLinha );
        saida->addItem( "vlItem",(char *)nrLinha.arr );
	}
    saida->closeTag();
    EXEC SQL CLOSE ListaLinhas;

    return 1;
}




int CConsultaConta::PesquisaConta( XMLGen* saida )
{
    struct sqlca sqlca;
    
    EXEC SQL BEGIN DECLARE SECTION;

        long idPessoa = idPessoaPrm;
        VARCHAR idLinhaTelefonica[51];
		char cdArea[3];
		char nrLinhaBase[15];
        VARCHAR cdConta[101];
        short i_cdConta = -1;
        short i_idLinhaTelefonica = -1;
        
    EXEC SQL END DECLARE SECTION;
    
    sprintf( cdArea     , "%.2s",nrLinhaPrm ); 
    strcpy ( nrLinhaBase, (char *)&nrLinhaPrm[2] ); 

    EXEC SQL WHENEVER SQLERROR  DO SqlError(&sqlca);

    EXEC SQL DECLARE SelConta CURSOR FOR
    SELECT
       CONTA.IDCONTA ,
       LINHATELEFONICA.IDLINHATELEFONICA
    FROM
       CUSTOMER.CONTA        CONTA ,
       CUSTOMER.LINHACONTA   LINHACONTA ,
       LINHA.LINHATELEFONICA LINHATELEFONICA ,
       LINHA.LINHABASE       LINHABASE ,
	   CUSTOMER.PESSOADEPARA PESSOADEPARA ,
	   CUSTOMER.PESSOACONTA  PESSOACONTA ,
       APOIO.AREAREGISTRO    AREAREGISTRO 
    WHERE
       LINHACONTA.IDCONTA = CONTA.IDCONTA
    AND
       LINHACONTA.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
    AND
       LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
    AND
       LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
    AND
   	   PESSOADEPARA.IDPESSOADEPARA = PESSOACONTA.IDPESSOADEPARA
	AND
	   PESSOACONTA.IDCONTA = CONTA.IDCONTA
    AND
       PESSOADEPARA.IDPESSOA = :idPessoa
    AND
       AREAREGISTRO.CDAREAREGISTRO = :cdArea
    AND
       LINHABASE.NRLINHA = :nrLinhaBase ;
       
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL OPEN SelConta;
    saida->createTag( "ListaDadosVO" );
    saida->addProp("xmlns","workflow.fo.vivo.com.br/vo");
    saida->addItem( "idPessoa",idPessoaPrm );
	for ( ;; )
	{
        EXEC SQL FETCH SelConta INTO
            :cdConta:i_cdConta ,
            :idLinhaTelefonica:i_idLinhaTelefonica ;

        CONVIND( cdConta,i_cdConta );
        CONVIND( idLinhaTelefonica,i_idLinhaTelefonica );
        saida->addItem( "vlItem",(char *)cdConta.arr );
        saida->addItem( "idLinhaTelefonica",(char *)idLinhaTelefonica.arr );
	}
    saida->closeTag();
    EXEC SQL CLOSE SelConta;

    return 1;
}



int CConsultaConta::PesquisaLinhasAssoc( XMLGen* saida )
{
    ULOG_START( "CConsultaConta::PesquisaLinhasAssoc()" );
    
    struct sqlca sqlca;
    
    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = idAtendimentoPrm;
		VARCHAR nrLinhaBase[64];
        VARCHAR cdConta[101];
        short i_cdConta = -1;
        short i_nrLinhaBase = -1;
        
    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL WHENEVER SQLERROR  DO SqlError(&sqlca);

    EXEC SQL DECLARE PesquisaLinhas CURSOR FOR
    SELECT
       ATENDIMENTOLINHAS.CDCONTA ,
       ATENDIMENTOLINHAS.NRTELEFONE
    FROM
       ATENDIMENTO.ATENDIMENTOLINHAS ATENDIMENTOLINHAS
    WHERE
       ATENDIMENTOLINHAS.IDATENDIMENTO = :idAtendimento
    ORDER BY ATENDIMENTOLINHAS.NRTELEFONE ;
       
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL OPEN PesquisaLinhas;
    saida->createTag( "ListaDadosVO" );
    saida->addProp("xmlns","workflow.fo.vivo.com.br/vo");
    saida->addItem( "idPessoa",idPessoaPrm );
    	for ( ;; )
    	{
            EXEC SQL FETCH PesquisaLinhas INTO
                :cdConta:i_cdConta ,
                :nrLinhaBase:i_nrLinhaBase ;
    
            CONVIND( cdConta,i_cdConta );
            CONVIND( nrLinhaBase,i_nrLinhaBase );
            saida->createTag( "LinhasAssociadasVO" );
                saida->addItem( "cdConta",(char *)cdConta.arr );
                saida->addItem( "nrTelefone",(char *)nrLinhaBase.arr );
            saida->closeTag();
    	}
    saida->closeTag();
    EXEC SQL CLOSE PesquisaLinhas;

    ULOG_END( "CConsultaConta::PesquisaLinhasAssoc()" );
    
    return 1;
}



void SqlError( sqlca * sqlca )
{
	ULOG("Ocorreu um erro na Obtencao de Campo Dinamico.");
	ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc);
	throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
