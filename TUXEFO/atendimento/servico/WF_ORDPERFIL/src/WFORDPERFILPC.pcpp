#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <tuxfw.h>
#include <WFORDPERFIL.h>

int MoverPerfil( char* pzcidContatoPerfil, int iinMove, char* pzcidUser )
{
	//Declarar Estruturas
	struct sqlca sqlca; 
	int iRet = 0;
	
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		char* pzcidUserAux = pzcidUser;
		char* pzcidContatoPerfilAux = pzcidContatoPerfil;
		int   inMover = 0;//default: para cima
		int   inMoverAux;
		int   isqOrdemAtual;
		int   iCont;
		struct ST_REGISTRO_MOVER_PERFIL
		{
			VARCHAR stidContatoperfil[21+1];
			int     isqOrdem;
		} stRegistro;
		struct
		{
			short sidContatoperfil;
			short ssqOrdem;
		} stRegistroInd;
		struct
		{
			struct ST_REGISTRO_MOVER_PERFIL * pzstRegistro;
			int iQuantidade;
		} stRegistros;
	EXEC SQL END DECLARE SECTION;

	memset( &stRegistros, 0, sizeof( stRegistros ) );

	/************************************************************************
	 * Processamento Principal
	 ************************************************************************/
	if( STRLENNULL( pzcidContatoPerfil ) <= 0 )
		return 1;

	if( STRLENNULL( pzcidUser ) <= 0 )
		return 2;

	if( iinMove > 0 )
		inMover = 1;//Dependendo do parametro de entrada, muda para baixo
	
	sqlca.sqlcode=0;
	EXEC SQL WHENEVER SQLERROR GOTO ErrorF;
	EXEC SQL WHENEVER NOT FOUND DO break;

	//Recupera todos os gruposperfis de um contato
	EXEC SQL
	DECLARE 
		CursorMoverPerfil CURSOR FOR
	SELECT
		IDCONTATOPERFIL,
		SQORDEM
	FROM
		CONTATOADM.CONTATOPERFIL
	WHERE
		IDCONTATO = 1
	AND
		DTEXPIRACAO IS NULL
	ORDER BY 
		SQORDEM;

	EXEC SQL OPEN CursorMoverPerfil;
	
	//Recupera todos os itens do mesmo nivel que o item passado como paramentro
	//E re-ordena, para garantir a integridade
	for(iCont = 0;;iCont++)
	{
		memset( &stRegistro, 0, sizeof( stRegistro ) );
		EXEC SQL FETCH CursorMoverPerfil INTO :stRegistro:stRegistroInd;

		if( strcmp( (char*)stRegistro.stidContatoperfil.arr, pzcidContatoPerfilAux ) == 0 )
			isqOrdemAtual = iCont;//Salva a posicao

		stRegistros.pzstRegistro = (struct ST_REGISTRO_MOVER_PERFIL *) realloc( stRegistros.pzstRegistro, sizeof(struct ST_REGISTRO_MOVER_PERFIL)*iCont );
		stRegistros.iQuantidade++;

		memset( &stRegistros.pzstRegistro[iCont], 0, sizeof( struct ST_REGISTRO_MOVER_PERFIL ) );
		strcpy( (char*)stRegistros.pzstRegistro[iCont].stidContatoperfil.arr, (char*)stRegistro.stidContatoperfil.arr );
		stRegistros.pzstRegistro[iCont].isqOrdem = iCont;
	}
	EXEC SQL CLOSE CursorMoverPerfil;

	if( stRegistros.iQuantidade > 1 )
	{

		if( !( ( ( isqOrdemAtual == (stRegistros.iQuantidade-1) ) && ( inMover ) ) 
			|| ( ( isqOrdemAtual == 0 ) && ( !inMover ) ) ) )
		{
			//Troca a numeracao, dependendo da escolha
			if( inMover == 0 )
				inMover = -1;

			stRegistros.pzstRegistro[isqOrdemAtual].isqOrdem = stRegistros.pzstRegistro[isqOrdemAtual].isqOrdem + inMover;
			inMoverAux = inMover*(-1);
			stRegistros.pzstRegistro[isqOrdemAtual+inMover].isqOrdem = stRegistros.pzstRegistro[isqOrdemAtual].isqOrdem + inMoverAux;

			EXEC SQL WHENEVER NOT FOUND CONTINUE;
			//Acerta todas as sequencias do mesmo nivel que o idPassado com parametro
			for(iCont = 0;iCont < stRegistros.iQuantidade;iCont++)
			{
				pzcidContatoPerfilAux = (char*)stRegistros.pzstRegistro[iCont].stidContatoperfil.arr;
				isqOrdemAtual = stRegistros.pzstRegistro[iCont].isqOrdem;

				EXEC SQL 
				UPDATE
					CONTATOADM.CONTATOPERFIL 
				SET 	
					SQORDEM     = :isqOrdemAtual,
					IDUSUARIOALTERACAO = :pzcidUserAux, 
					DTULTIMAALTERACAO  =  SYSDATE
				WHERE 	
					IDCONTATOPERFIL = :pzcidContatoPerfilAux;
			}//for(iCont = 0;iCont < Quantidade();iCont++)

		}
		else
			iRet = 5;//Operacao nao pode ser realizada

	}//if( stRegistros.iQuantidade > 1 )
	else
		iRet = 4;//Nao pode mover apenas um item

	if( stRegistros.pzstRegistro != NULL )
		free( stRegistros.pzstRegistro );

	return iRet;

/************************************************************************
 * Tratamento de Exception
 ************************************************************************/

ErrorF:
	if( stRegistros.pzstRegistro != NULL )
		free( stRegistros.pzstRegistro );
		
    ULOGE("SqlError -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}