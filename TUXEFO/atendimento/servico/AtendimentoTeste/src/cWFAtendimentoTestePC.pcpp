#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"


#include "../include/cWFAtendimentoTeste.h"
#include "../include/stWFAtendimentoTeste.h"

void sql_error_WFAtendimentoTeste(sqlca*sqlca);

	// Declara as estruturas compatíveis ao ProC.
    EXEC SQL BEGIN DECLARE SECTION;
		#include "../include/stWFAtendimentoTeste.h"
    EXEC SQL END DECLARE SECTION;

long proCIncluirWFAtendimentoTeste(st_AtendimentoTeste* dados, st_vlAtendimentoTeste* status, XMLDPR *xmlDpr)
{
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AtendimentoTeste   oDados;
		struct st_vlAtendimentoTeste oStatus;
        char sysDate[64];

	EXEC SQL END DECLARE SECTION;

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoTeste(&sqlca);

    EXEC SQL SELECT SYSDATE INTO :sysDate FROM DUAL;

	EXEC SQL SELECT atendimento.AtendimentoTesteSQ.NEXTVAL INTO :oDados.idAtendimentoTeste FROM DUAL;

	EXEC SQL 
		INSERT INTO
			atendimento.AtendimentoTeste
			(
				idAtendimentoTeste,
				idAtendimento,
				dsObservacao,
				dtTeste,
				idPessoaUsuario,
				idUsuarioAlteracao,
				dtUltimaAlteracao
			)
			VALUES
			(
				:oDados.idAtendimentoTeste,
				:oDados.idAtendimento,
				:oDados.dsTeste,
                TO_DATE(DECODE(:oStatus.dtTeste,-1,:sysDate,:oDados.dtTeste),'DD/MM/YYYY HH24:MI:SS'),
				:oDados.idPessoaUsuario,
				:oDados.idPessoaUsuario,
                TO_DATE(DECODE(:oStatus.dtUltimaAlteracao,-1,:sysDate,:oDados.dtUltimaAlteracao),'DD/MM/YYYY HH24:MI:SS')
			);

    // ==> SM324--DPR--DEZ/2006--Cassio
    if ( xmlDpr )
    {
        AtendimentoTesteDPR atendimentotestedpr;

        atendimentotestedpr.setIdAtendimento(oDados.idAtendimento);
        atendimentotestedpr.setIdAtendimentoTeste(oDados.idAtendimentoTeste);
        atendimentotestedpr.setDtTeste(oStatus.dtTeste==-1?sysDate:oDados.dtTeste);
        atendimentotestedpr.setIdPessoaUsuario(oDados.idPessoaUsuario);
        atendimentotestedpr.setOpCode(OPCODE_INSERT);

        xmlDpr->atendimentotestevo.inserir(&atendimentotestedpr);
    }
    // <== SM324--DPR--DEZ/2006--Cassio

	return oDados.idAtendimentoTeste;
}

bool proCIncluirWFTesteResposta(st_AtendimentoTeste* dados, st_vlAtendimentoTeste* status, XMLGen* saida)
{
	ULOG_START("proCIncluirWFTesteResposta()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AtendimentoTeste   *oDados = dados;
		struct st_vlAtendimentoTeste *oStatus = status;

	EXEC SQL END DECLARE SECTION;

	ULOG("idTeste=%d", oDados->idTeste);
	ULOG("idAtendimentoTeste= %d", oDados->idAtendimentoTeste);

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoTeste(&sqlca);

	EXEC SQL 
        SELECT 
            ATENDIMENTO.TESTERESPOSTASQ.NEXTVAL 
        INTO 
            :oDados->idTesteResposta 
        FROM DUAL;

	EXEC SQL 
		INSERT INTO
			ATENDIMENTO.TESTERESPOSTA
			(
				IDTESTERESPOSTA,
				IDATENDIMENTOTESTE,
				DSRESPOSTA,
				IDTESTE,
				IDUSUARIOALTERACAO,
				DTULTIMAALTERACAO
			)
			VALUES
			(
				:oDados->idTesteResposta,
				:oDados->idAtendimentoTeste,
				:oDados->dsResposta,
				:oDados->idTeste,
				:oDados->idPessoaUsuario,
				DECODE(:oStatus->dtUltimaAlteracao, -1, SYSDATE,
                    TO_DATE(:oDados->dtUltimaAlteracao,'DD/MM/YYYY HH24:MI:SS'))
			);

	ULOG_END("proCIncluirWFTesteResposta()");

	return true;
}

bool proCAlterarWFAtendimentoTeste(st_AtendimentoTeste* dados, st_vlAtendimentoTeste* status, XMLGen* saida)
{
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AtendimentoTeste   oDados;
		struct st_vlAtendimentoTeste oStatus;

		char query[1024] = "UPDATE atendimento.AtendimentoTeste SET ";

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoTeste(&sqlca);

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

	bool separa = false;

	if (status->idAtendimentoTeste != -1) 
		montaUpdate("idAtendimentoTeste", oDados.idAtendimentoTeste, 1);

	if (status->idAtendimento != -1) 
		montaUpdate("idAtendimento", oDados.idAtendimento, 1);

	if (status->dsTeste != -1)
		montaUpdate("dsTeste", dados->dsTeste, 2);

	if (status->dtTeste != -1)
		montaUpdate("dtTeste", oDados.dtTeste, 4);

	if (status->idPessoaUsuario != -1) 
		montaUpdate("idPessoaUsuario", oDados.idPessoaUsuario, 1);

	sprintf(query, "%s WHERE idAtendimentoTeste = %ld", query, dados->idAtendimentoTeste);

	EXEC SQL EXECUTE IMMEDIATE :query;

	return true;
}

bool proCExcluirWFAtendimentoTeste(st_AtendimentoTeste* dados, st_vlAtendimentoTeste* status, XMLGen* saida)
{

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimentoTeste = dados->idAtendimentoTeste;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoTeste(&sqlca);

	EXEC SQL 
		DELETE
			atendimento.AtendimentoTeste
		WHERE
			idAtendimentoTeste = :idAtendimentoTeste;

	return true;
}

bool proCConsultaWFAtendimentoTeste(st_AtendimentoTeste* dados, st_vlAtendimentoTeste* status, char* order, XMLGen* saida)
{

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimentoTeste;
		long idAtendimento;
		VARCHAR dsTeste[501];
		VARCHAR dtTeste[256];
		int idPessoaUsuario;

		char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFEstado(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	sprintf(query,"SELECT idAtendimentoTeste, idAtendimento, dsTeste, TO_CHAR(dtTeste,'dd/mm/yyyy hh24:mi'), idPessoaUsuario FROM atendimento.AtendimentoTeste ");

	bool separa = false;

	if (status->idAtendimentoTeste != -1) 
		montaWhere("idAtendimentoTeste", dados->idAtendimentoTeste, 1);

	if (status->idAtendimento != -1)
		montaWhere("idAtendimento", dados->idAtendimento, 1);

	if (status->dsTeste != -1)
		montaWhere("dsTeste", dados->dsTeste, 2);

	if (status->dtTeste != -1) 
		montaWhere("dtTeste", dados->dtTeste, 4);

	if (status->idPessoaUsuario != -1)
		montaWhere("idPessoaUsuario", dados->idPessoaUsuario, 1);

	if (strlen(order) > 0) 
		sprintf( query, "%s ORDER BY %s ", query, order);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoTeste(&sqlca);

	EXEC SQL PREPARE consultaAtendimentoTeste FROM :query;
	EXEC SQL DECLARE consulta CURSOR FOR consultaAtendimentoTeste;

	EXEC SQL OPEN consulta;

	while (true)
	{
		EXEC SQL FETCH consulta INTO :idAtendimentoTeste, :idAtendimento, :dsTeste, :dtTeste, :idPessoaUsuario;

		CONV(dsTeste);
		CONV(dtTeste);

		saida->createTag("WFAtendimentoTesteVO");
			saida->addItem("idAtendimentoTeste", idAtendimentoTeste);
			saida->addItem("idAtendimento", idAtendimento);
			saida->addItem("dsTeste", (char *)dsTeste.arr);
			saida->addItem("dtTeste", (char *)dtTeste.arr);
			saida->addItem("idPessoaUsuario", idPessoaUsuario);
		saida->closeTag();
	}

	EXEC SQL CLOSE consulta;

	return true;

}

void sql_error_WFAtendimentoTeste(sqlca*sqlca)
{
	throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
