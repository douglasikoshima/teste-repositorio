#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"
#include "../../../commons/msgPadrao.h"

#include "../include/cWFAtendimentoSuspeito.h"
#include "../include/stWFAtendimentoSuspeito.h"

void sql_error_WFAtendimentoSuspeito(sqlca*sqlca);

    // Declara as estruturas compatíveis ao ProC.
    EXEC SQL BEGIN DECLARE SECTION;
        #include "../include/stWFAtendimentoSuspeito.h"
    EXEC SQL END DECLARE SECTION;

long proCIncluirWFAtendimentoSuspeito(st_AtendimentoSuspeito* dados, st_vlAtendimentoSuspeito* status, XMLGen* saida)
{
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        struct st_AtendimentoSuspeito oDados;
        struct st_vlAtendimentoSuspeito oStatus;
    EXEC SQL END DECLARE SECTION;

    memcpy(&oDados,  dados,  sizeof(oDados));
    memcpy(&oStatus, status, sizeof(oStatus));

   EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoSuspeito(&sqlca);
   EXEC SQL WHENEVER NOT FOUND CONTINUE;

    // Existe uma constraint para esta tabela impedindo a duplicidade de inserção
    // para as colunas idatendimento+idpessoausuario+idmotivo, caso estes valores
    // existam esta operação irá apenas atualizar a data da ultima atualização destes
    // valores.
    EXEC SQL
        SELECT IDATENDIMENTOSUSPEITO
          INTO :oDados.idAtendimentoSuspeito
          FROM ATENDIMENTO.ATENDIMENTOSUSPEITO
         WHERE IDATENDIMENTO = :oDados.idAtendimento
           AND IDPESSOAUSUARIO = :oDados.idPessoaUsuario
           AND IDMOTIVO = :oDados.idMotivo;

    if ( sqlca.sqlcode == 0 )
    {
        EXEC SQL
            UPDATE ATENDIMENTO.ATENDIMENTOSUSPEITO
            SET DTSUSPEITO = SYSDATE,
                IDUSUARIOALTERACAO = :oDados.idPessoaUsuario,
                DTULTIMAALTERACAO = SYSDATE
            WHERE
                IDATENDIMENTOSUSPEITO = :oDados.idAtendimentoSuspeito;
    }
    else
    {
        EXEC SQL
            SELECT ATENDIMENTO.ATENDIMENTOSUSPEITOSQ.NEXTVAL
              INTO :oDados.idAtendimentoSuspeito
              FROM DUAL;

        EXEC SQL
            INSERT INTO ATENDIMENTO.ATENDIMENTOSUSPEITO(IDATENDIMENTOSUSPEITO,
                                                          DTSUSPEITO,
                                                          IDATENDIMENTO,
                                                          IDPESSOAUSUARIO,
                                                          IDUSUARIOALTERACAO,
                                                          DTULTIMAALTERACAO,
                                                          IDMOTIVO)
            VALUES (:oDados.idAtendimentoSuspeito,
                    SYSDATE,
                    :oDados.idAtendimento,
                    :oDados.idPessoaUsuario,
                    :oDados.idPessoaUsuario,
                    SYSDATE,
                    :oDados.idMotivo
                   );
    }

    return oDados.idAtendimentoSuspeito;
}

bool proCAlterarWFAtendimentoSuspeito(st_AtendimentoSuspeito* dados, st_vlAtendimentoSuspeito* status, XMLGen* saida)
{
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

         struct st_AtendimentoSuspeito   oDados;
         struct st_vlAtendimentoSuspeito oStatus;
     
         char query[800] = "UPDATE atendimento.AtendimentoSuspeito SET ";

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoSuspeito(&sqlca);

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

	bool separa = false;

	if (status->dtSuspeito != -1) 
		montaUpdate("dtSuspeito", oDados.dtSuspeito, TIPO_DATAHORA );

	if (status->idAtendimento != -1) 
		montaUpdate("idAtendimento", oDados.idAtendimento, TIPO_ULONG);

	if (status->idPessoaUsuario != -1) 
		montaUpdate("idPessoaUsuario", oDados.idPessoaUsuario, TIPO_INT );

	if (status->idUsuarioAlteracao != -1) 
		montaUpdate("idUsuarioAlteracao", oDados.idUsuarioAlteracao, TIPO_INT );

	if (status->dtUltimaAlteracao != -1) 
		montaUpdate("dtUltimaAlteracao", oDados.dtUltimaAlteracao, TIPO_DATAHORA );

	if (status->idMotivo != -1) 
		montaUpdate("idMotivo", oDados.idMotivo, TIPO_INT );

	sprintf(query, "%s WHERE idAtendimentoSuspeito = %i", query, dados->idAtendimentoSuspeito );

	EXEC SQL EXECUTE IMMEDIATE :query;

	return true;
}

bool proCExcluirWFAtendimentoSuspeito(st_AtendimentoSuspeito* dados, st_vlAtendimentoSuspeito* status, XMLGen* saida)
{
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimento = dados->idAtendimento;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoSuspeito(&sqlca);


	EXEC SQL 
		DELETE
			atendimento.AtendimentoSuspeito
		WHERE
			idAtendimento = :idAtendimento;

	return true;
}

int proCObterWFAtendimentoSuspeito(long sIdAtendimento)
{
	struct sqlca sqlca;

    int idPessoaUsuarioSuspeito = 0;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimento = sIdAtendimento;
		int idPessoaUsuario;

		short i_idPessoaUsuario = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoSuspeito(&sqlca);

	EXEC SQL 
		SELECT
			idPessoaUsuario
		INTO
			:idPessoaUsuario:i_idPessoaUsuario
		FROM
			atendimento.AtendimentoSuspeito
		WHERE
			idAtendimento = :idAtendimento;

	if (i_idPessoaUsuario != -1)		
		idPessoaUsuarioSuspeito = idPessoaUsuario;

	return idPessoaUsuarioSuspeito;
}

bool proCConsultaWFAtendimentoSuspeito(st_AtendimentoSuspeito* dados, st_vlAtendimentoSuspeito* status, char* order, XMLGen* saida)
{
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

   	long      idAtendimentoSuspeito;
   	VARCHAR  dtSuspeito[256];
   	long      idAtendimento;
   	int      idPessoaUsuario;
   	int      idUsuarioAlteracao;
   	VARCHAR  dtUltimaAlteracao[256];
   	int      idMotivo;

   	short    i_dtSuspeito;
   	short    i_idAtendimento;
   	short    i_idPessoaUsuario;
   	short    i_idUsuarioAlteracao;
   	short    i_dtUltimaAlteracao;
   	short    i_idMotivo;

	char query[800] = "SELECT idAtendimentoSuspeito"
                            ",TO_CHAR(dtSuspeito,'DD/MM/YYYY')"
                            ",idAtendimento"
                            ",idPessoaUsuario"
                            ",idUsuarioAlteracao"
                            ",TO_CHAR(dtUltimaAlteracao,'DD/MM/YYYY')"
                            ",idMotivo "
                        "FROM atendimento.AtendimentoSuspeito ";

    EXEC SQL END DECLARE SECTION;
  
    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFEstado(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    bool separa = false;

	if (status->idAtendimentoSuspeito != -1) 
		montaWhere("idAtendimentoSuspeito", dados->idAtendimentoSuspeito, 1);

	if (status->dtSuspeito != -1)
		montaWhere("dtSuspeito", dados->dtSuspeito, TIPO_DATAHORA);

	if (status->idAtendimento != -1) 
		montaWhere("idAtendimento", dados->idAtendimento, TIPO_ULONG);

	if (status->idPessoaUsuario != -1) 
		montaWhere("idPessoaUsuario", dados->idPessoaUsuario, TIPO_INT);

	if (status->idUsuarioAlteracao != -1) 
		montaWhere("idUsuarioAlteracao", dados->idUsuarioAlteracao, TIPO_INT);

	if (status->dtUltimaAlteracao != -1) 
		montaWhere("dtUltimaAlteracao", dados->dtUltimaAlteracao, TIPO_DATAHORA);

	if (status->idMotivo != -1) 
		montaWhere("idMotivo", dados->idMotivo, TIPO_INT);

	if (strlen(order) > 0) 
		sprintf( query, "%s ORDER BY %s ", query, order);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoSuspeito(&sqlca);

	EXEC SQL PREPARE consultaAtendimentoSuspeito FROM :query;
	EXEC SQL DECLARE consulta CURSOR FOR consultaAtendimentoSuspeito;

	EXEC SQL OPEN consulta;

	while (true)
	{
		EXEC SQL FETCH consulta INTO 
									:idAtendimentoSuspeito, 
									:dtSuspeito:i_dtSuspeito,
									:idAtendimento:i_idAtendimento,
									:idPessoaUsuario:i_idPessoaUsuario,
									:idUsuarioAlteracao:i_idUsuarioAlteracao,
									:dtUltimaAlteracao:i_dtUltimaAlteracao,
									:idMotivo:i_idMotivo;

		CONVIND(dtUltimaAlteracao,i_dtUltimaAlteracao);

		saida->createTag("WFAtendimentoSuspeitoVO");
			saida->addItem("idAtendimentoSuspeito", idAtendimentoSuspeito);
			saida->addItem("dtSuspeito", (char *)dtSuspeito.arr);
			saida->addItem("idAtendimento", idAtendimento);
			saida->addItem("idPessoaUsuario", idPessoaUsuario);
			saida->addItem("idUsuarioAlteracao", idUsuarioAlteracao);
			saida->addItem("dtUltimaAlteracao", (char *)dtUltimaAlteracao.arr);
			saida->addItem("idMotivo", idMotivo);
		saida->closeTag();
	}

	EXEC SQL CLOSE consulta;

	return true;

}

void sql_error_WFAtendimentoSuspeito(sqlca*sqlca)
{
	throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
