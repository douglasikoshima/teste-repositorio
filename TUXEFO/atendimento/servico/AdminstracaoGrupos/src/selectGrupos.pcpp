/**
 * 
 * @modulo  Workflow
 * @usecase Workflow
 * @author  Unknow
 * @version $Revision: 1.1.114.1 $
 * @CVS     $Author: a5114878 $ - $Date: 2013/02/06 12:35:14 $
 **/ 

#undef SQLCA
#define SQLCA_NONE
#include <sqlca.h>
#include <sqlda.h>

#include "../../../commons/queryMacro.h"
#include "../include/selectData.h"
#include "../../../commons/SmallString.h"

//=====================================================================================
// Prototype
void Sql_Error_Read( sqlca * sqlca );

//=====================================================================================
// Implementation
int GruposRequest::QueryInContato()
{
    ULOG_START("GruposRequest::QueryInContato()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;
       char *ORA_pNode = pnode;
    
       int inDisponibilidade;
       short i_inDisponibilidade = -1;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL 
        SELECT INDISPONIBILIDADE
            INTO inDisponibilidade:i_inDisponibilidade
        FROM 
            CONTATOADM.CONTATO
        WHERE 
            idContato = :ORA_pNode;

   ULOG_END("GruposRequest::QueryInContato()");

   return inDisponibilidade;
}

long GruposRequest::QueryTipoRetornoContato()
{
    ULOG_START("GruposRequest::QueryTipoRetornoContato()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;
       char *ORA_pNode = pnode;
    
       long idTipoRetornoContato = 0;
       short i_idTipoRetornoContato = -1;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    // Para esta consulta, não precisamos contar todos os atendimentos que tem idTipoRetornoContato = 2
    // basta retornar 1 quando houver algum ou 0 se não houver
    // alteração conforme incidência WR 3138
    EXEC SQL 
        SELECT
            COUNT(idAtendimento)
        INTO
            idTipoRetornoContato:i_idTipoRetornoContato
        FROM 
            atendimento.atendimentopriorizacao
        WHERE 
            idTipoRetornoContato = 2
        AND idContato = :ORA_pNode
        AND ROWNUM < 2;

    ULOG_END("GruposRequest::QueryTipoRetornoContato()"); 

    return idTipoRetornoContato;
}

// VERSÃO SEM CURSOR
//long GruposWriter::QueryFaseFechamento( long _idContato,string _idGruposAbertura )
//{
//  long idFaseRetorno = 0;
//
//  INITIALIZE_SQL;
//
//  EXEC SQL BEGIN DECLARE SECTION;
//        const char *idGruposAbertura = _idGruposAbertura.c_str();
//        int grupos[1024];
//
//        short i_idFaseFechamento = -1;
//
//        long idContato = _idContato;
//        long idFaseFechamento=0;
//
//  EXEC SQL END DECLARE SECTION;
//
//    // converte os grupos de abertura em inteiros
//    char seps[]   = " ,";
//    char *token = strtok( _idGruposAbertura.c_str(), seps );
//    
//    memset(&grupos,-1,sizeof(grupos));
//    int i=0;
//
//    while( token )
//    {
//        grupos[i++] = atoi(token);
//
//        token = strtok( NULL, seps );
//    }
//
//  ULOG("GruposAbertura='%s'", _idGruposAbertura.c_str());
//  ULOG("idContato=%d", idContato);
//  ULOG("idContato=%d", idContato);
//
//
//  EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );
//  EXEC SQL 
//        SELECT TF.IDFASE 
//          INTO 
//              :idFaseFechamento:i_idFaseFechamento
//          FROM 
//               CONTATOADM.FASEGRUPOFECHAMENTO FG
//            ,CONTATOADM.TIPOFECHAMENTOCONTATO TF
//       WHERE
//               FG.IDCONTATO = :idContato
//           //AND FG.IDGRUPO IN ( :idGruposAbertura )
//           AND FG.IDGRUPO IN ( :grupos )
//           AND FG.IDTIPOFECHAMENTOCONTATO = TF.IDTIPOFECHAMENTOCONTATO
//         AND ROWNUM < 2
//         ORDER BY
//             TF.IDFASE DESC;
//
//    if (i_idFaseFechamento != -1)
//    {
//      idFaseRetorno = idFaseFechamento;
//    }
//
//  return idFaseRetorno;
//}

long GruposWriter::QueryFaseFechamento( long idContato, 
                                                 string idGruposAbertura)
{
    ULOG_START("GruposWriter::QueryFaseFechamento()"); 

    string queryFaseFechamento;

    long idFaseRetorno = 0;
    char valor[32];

    sprintf( valor,"%lu",idContato );

    INITIALIZE_SQL;
    EXEC SQL BEGIN DECLARE SECTION;
           char *query;
    
       long idFaseFechamento;
       short i_idFaseFechamento;
    
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    queryFaseFechamento = "SELECT idFase "
                           "FROM "
                           "(SELECT "
                           "tf.idFase "
                           "FROM "
                           "ContatoAdm.FaseGrupoFechamento    fg "
                           ",contatoadm.tipofechamentocontato tf "
                           "WHERE "
                           "fg.idTipoFechamentoContato = tf.idTipoFechamentoContato "
                           "AND fg.idContato = ";
    queryFaseFechamento += (string)valor;
    queryFaseFechamento += " AND fg.idGrupo IN (" + idGruposAbertura + ") ";
    queryFaseFechamento += "ORDER BY ";
    queryFaseFechamento += "tf.idFase desc) ";
    queryFaseFechamento += "WHERE ROWNUM <= 1";

    query = (char*)queryFaseFechamento.c_str();

    ULOG("query [%s]\n", query);
    
    EXEC SQL PREPARE recebeQuery FROM :query;
    EXEC SQL DECLARE consulta CURSOR FOR recebeQuery;

    EXEC SQL OPEN consulta;

    for ( ;; )
    {
        i_idFaseFechamento = -1;

        EXEC SQL FETCH consulta INTO :idFaseFechamento:i_idFaseFechamento;
        
        if (i_idFaseFechamento != -1)
            idFaseRetorno = idFaseFechamento;
    }

    EXEC SQL CLOSE consulta;
    
    ULOG_END("GruposWriter::QueryFaseFechamento()"); 

    return idFaseRetorno;
}

int GruposRequest::QueryGrupos()
{
    ULOG_START("GruposRequest::QueryGrupos()"); 

    long idTipoRetornoContato;
    int inDisponibilidade;

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        struct
        {
            VARCHAR idGrupo[21];
            VARCHAR nmGrupo[255];
        } oraGrpA;

        struct
        {
            short idGrupo;
            short nmGrupo;
        } oraStGrpA;

    EXEC SQL END DECLARE SECTION;

    //     
    // Esta validacao foi retirado  conforme incidencia 3271 item 2.1.1 da documentacão 
    // idTipoRetornoContato = QueryTipoRetornoContato();
    //
    idTipoRetornoContato = 0;
    inDisponibilidade = QueryInContato();

    ULOG( "SELECT /*+ NO_CPU_COSTING */ "
                 "G.IDGRUPO,G.NMGRUPO "
            "FROM "
                 "ACESSO.GRUPO G, "
                 "APOIO.TIPOGRUPO TG "
           "WHERE  "
                 "G.DTEXCLUSAO IS NULL "
             "AND G.IDGRUPO > 0  "
             "AND G.IDTIPOGRUPO = TG.IDTIPOGRUPO "
             "AND TG.CDTIPOGRUPO = 'NORMAL' "
        "ORDER BY UPPER(G.NMGRUPO)");

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL DECLARE vwContatoGrupo CURSOR FOR
        SELECT /*+ NO_CPU_COSTING */
                G.IDGRUPO, 
                G.NMGRUPO 
            FROM  
                ACESSO.GRUPO G, 
                APOIO.TIPOGRUPO TG 
            WHERE  
                G.DTEXCLUSAO IS NULL 
            AND 
                G.IDGRUPO > 0  
            AND 
                G.IDTIPOGRUPO = TG.IDTIPOGRUPO
            AND 
                TG.CDTIPOGRUPO = 'NORMAL'
            ORDER BY
                UPPER(G.NMGRUPO);

    EXEC SQL OPEN vwContatoGrupo;

    pxml->createTag("GruposDisponiveis");
        pxml->createTag("GrupoProcessoVO");
        pxml->createTag("ArvoreContatoVO");
            pxml->addItem("codigo",pnode);
            pxml->addItem("idTipoRetornoContato",idTipoRetornoContato);
            pxml->addItem("inDisponibilidade",inDisponibilidade);
        pxml->closeTag();

    for(;;)
    {
        memset(&oraStGrpA,-1,sizeof(oraStGrpA));

        EXEC SQL FETCH vwContatoGrupo INTO :oraGrpA:oraStGrpA;

        CONVIND(oraGrpA.nmGrupo,oraStGrpA.nmGrupo);
        CONVIND(oraGrpA.idGrupo,oraStGrpA.idGrupo);

        pxml->createTag("GrupoVO");
            pxml->addItem("codigo",(char*)oraGrpA.idGrupo.arr);
            pxml->addItem("descricao",(char*)oraGrpA.nmGrupo.arr);
            // pxml->addItem("status",(char*)oraGrpA.status.arr);
            pxml->addItem("status","0");
        pxml->closeTag();
    }

    EXEC SQL CLOSE vwContatoGrupo;

    pxml->closeTag();
    pxml->closeTag();

    ULOG_END("GruposRequest::QueryGrupos()"); 

    return 1;
}

int GruposRequest::QueryGruposContato()
{
    ULOG_START("GruposRequest::QueryGruposContato()"); 

    long idTipoRetornoContato;
    int inDisponibilidade;
    INITIALIZE_SQL;
    EXEC SQL BEGIN DECLARE SECTION;
        char *ORA_pNode = pnode;
        struct
        {
            VARCHAR idGrupo[21];
            VARCHAR nmGrupo[255];
            VARCHAR idContato[21];
        }oraGrpA;

        struct
        {
            short idGrupo;
            short nmGrupo;
            short idContato;
        }oraStGrpA;

    EXEC SQL END DECLARE SECTION;

    //
    // ====================================================================
    // ==> Incidência 3353 WarRoom RJ - Maio/2006
    // Não precisa analisar se existem processos em aberto
    // idTipoRetornoContato = QueryTipoRetornoContato();
    idTipoRetornoContato = 0; 
    // <== Incidência 3353 WarRoom RJ - Maio/2006
    // ====================================================================
    //
    inDisponibilidade = QueryInContato();

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL DECLARE vwContatoGrupoB02 CURSOR FOR
        SELECT DISTINCT 
            CG.IDGRUPO, 
            CG.NMGRUPO, 
            CG.IDCONTATO
        FROM 
            CONTATOADM.CONTATOGRUPOV02 CG,
            ACESSO.GRUPO G,
            APOIO.TIPOGRUPO TG
        WHERE 
            CG.IDCONTATO =  :ORA_pNode
        AND CG.IDGRUPO = G.IDGRUPO
        AND G.DTEXCLUSAO IS NULL
        AND G.IDTIPOGRUPO = TG.IDTIPOGRUPO
        AND TG.CDTIPOGRUPO = 'NORMAL'
        ORDER BY
            UPPER(CG.NMGRUPO);

    EXEC SQL OPEN vwContatoGrupoB02;

    pxml->createTag("GruposDisponiveis");
    pxml->createTag("GrupoProcessoVO");
    pxml->createTag("ArvoreContatoVO");
    pxml->addItem("codigo",pnode);
    pxml->addItem("idTipoRetornoContato",idTipoRetornoContato);
    pxml->addItem("inDisponibilidade",inDisponibilidade);
    pxml->closeTag();

    for(;;)
    {
        memset(&oraStGrpA,-1,sizeof(oraStGrpA));

        EXEC SQL FETCH vwContatoGrupoB02 INTO :oraGrpA:oraStGrpA;

        CONVIND(oraGrpA.nmGrupo,oraStGrpA.nmGrupo);
        CONVIND(oraGrpA.idGrupo,oraStGrpA.idGrupo);
        CONVIND(oraGrpA.idContato,oraStGrpA.idContato);

        pxml->createTag("GrupoVO");
            pxml->addItem("codigo",(char*)oraGrpA.idGrupo.arr);
            pxml->addItem("descricao",(char*)oraGrpA.nmGrupo.arr);
            pxml->addItem("status",(char*)oraGrpA.idContato.arr);
        pxml->closeTag();
    }

    EXEC SQL CLOSE vwContatoGrupoB02;

    pxml->closeTag();
    pxml->closeTag();

    ULOG_END("GruposRequest::QueryGruposContato()"); 

    return 1;
}

int GruposRequest::ConsultaGruposAbertura( long sIdContato ) const
{
    ULOG_START("GruposRequest::ConsultaGruposAbertura()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;
        long idContato = sIdContato;
        int idAtividade;
        VARCHAR dsAtividade[256];
        short i_dsAtividade;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL DECLARE ReadGrpAbert CURSOR FOR
        SELECT DISTINCT
            TF.IDTIPOFECHAMENTOCONTATO,
            TF.NMTIPOFECHAMENTOCONTATO
        FROM 
            CONTATOADM.TIPOFECHAMENTOCONTATO TF,
            CONTATOADM.SEQUENCIA SQ,
            CONTATOADM.CONTATOGRUPO CG
        WHERE 
            TF.IDFASE = SQ.IDTIPOSEQUENCIA
        AND CG.IDCONTATOGRUPO = SQ.IDCONTATOGRUPO
        AND CG.IDCONTATO = :idContato
        ORDER BY 
            TF.IDTIPOFECHAMENTOCONTATO;

    EXEC SQL OPEN ReadGrpAbert;

    pxml->createTag("AtendimentoVO");
    pxml->addProp("xmlns","workflow.fo.vivo.com.br/vo");

        for(;;)
        {
            i_dsAtividade = -1;

            EXEC SQL FETCH ReadGrpAbert 
                     INTO :idAtividade,
                          :dsAtividade:i_dsAtividade;

            CONVIND(dsAtividade,i_dsAtividade);

            pxml->createTag("WFAcaoVO");
                pxml->addItem("idAtividade", idAtividade );
                pxml->addItem("dsAtividade",(char*)dsAtividade.arr);
            pxml->closeTag();
        }

    pxml->closeTag();

    EXEC SQL CLOSE ReadGrpAbert;

    ULOG_END("GruposRequest::ConsultaGruposAbertura()"); 

    return 1;
}

int GruposRequest::ConsultaGruposDisponiveis( long idAtividadePrm, long idContatoPrm )
{
    ULOG_START("GruposRequest::ConsultaGruposDisponiveis()");

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        long  idAtividade = idAtividadePrm;
        long  idContato   = idContatoPrm;

        long  Codigo;
        VARCHAR Descricao[256];

        short i_Descricao;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL DECLARE ReadGrpDisp CURSOR FOR
        SELECT DISTINCT 
            idGrupo,
            nmGrupo
        FROM 
            Atendimento.SequenciaV01
        WHERE
            idContato = :idContato
        AND
            idTipoSequencia = 1
        AND
            idGrupo NOT IN (  SELECT 
                                 idGrupo
                              FROM
                                 WorkFlow.WFFluxoGruposBerturaV01
                              WHERE
                                 idContato = :idContato
                              AND
                                 idAtividade = :idAtividade
                           )
        AND
           idGrupo > 0
        ORDER BY 
           UPPER(nmGrupo);

    EXEC SQL OPEN ReadGrpDisp;

    pxml->createTag("GruposDisponiveis");
        pxml->createTag("GrupoProcessoVO");

        for(;;)
        {
            i_Descricao = -1;

            EXEC SQL FETCH 
                ReadGrpDisp 
            INTO 
                :Codigo,
                :Descricao:i_Descricao;

            if( i_Descricao >= 0 )
                CL_FETCH( Descricao );

            pxml->createTag("GrupoVO");
                pxml->addItem("codigo", Codigo );
                pxml->addItem("descricao",(char*)Descricao.arr );
                pxml->addItem("status", 0 );
            pxml->closeTag();

        }

        pxml->closeTag();

    pxml->closeTag();

    EXEC SQL CLOSE ReadGrpDisp;

    ULOG_END("GruposRequest::ConsultaGruposDisponiveis()"); 

    return 1;
}

int GruposRequest::ConsultaGruposAssociados(long idAtividadePrm,long idContatoPrm)
{
    ULOG_START("GruposRequest::ConsultaGruposAssociados()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtividade = idAtividadePrm;
        long idContato   = idContatoPrm;

        long  Codigo;
        VARCHAR Descricao[256];

        short i_Descricao;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL DECLARE ReadGrpAss CURSOR FOR
        SELECT DISTINCT 
            idGrupo,
            nmGrupo
        FROM 
            WorkFlow.WFFluxoGruposBerturaV01
        WHERE
            idAtividade = :idAtividade
        AND
            idContato = :idContato
        AND
            idGrupo > 0;

    EXEC SQL OPEN ReadGrpAss;

    pxml->createTag("GruposAbertura");
        pxml->createTag("GrupoProcessoVO");

        for(;;)
        {
            i_Descricao = -1;

            EXEC SQL FETCH 
                ReadGrpAss 
            INTO 
                :Codigo,
                :Descricao:i_Descricao;

            if( i_Descricao >= 0 )
                CL_FETCH( Descricao );

            pxml->createTag("GrupoVO");
                pxml->addItem("codigo", Codigo );
                pxml->addItem("descricao",(char*)Descricao.arr );
                pxml->addItem("status", 0 );
            pxml->closeTag();
        }

        pxml->closeTag();

    pxml->closeTag();

    EXEC SQL CLOSE ReadGrpAss;

    ULOG_END("GruposRequest::ConsultaGruposAssociados()"); 

    return 1;

}

int GruposRequest::ConsultaTipoCarteira(long idContatoPrm
                                       ,long idGrupoPrm
                                       ,long idTpFechamentoPrm ) const
{
    ULOG_START("GruposRequest::ConsultaTipoCarteira()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        long idContato = idContatoPrm;
        long idGrupo = idGrupoPrm;
        long idTpFechamento = idTpFechamentoPrm;

        long idTpCarteira;
        VARCHAR dsTpCarteira[256];

        short i_dsTpCarteira = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL DECLARE ReadTpCarteira CURSOR FOR
        SELECT 
            IDTIPOCARTEIRA, DSTIPOCARTEIRA 
        FROM 
            APOIO.TIPOCARTEIRA 
        WHERE 
            IDTIPOCARTEIRA > 0
        AND IDTIPOCARTEIRA NOT IN (SELECT 
                                            A.IDTIPOCARTEIRA 
                                        FROM 
                                            CONTATOADM.FECHAMENTOTPCARTEIRA  A,
                                            CONTATOADM.FASEGRUPOFECHAMENTO   B
                                        WHERE
                                            A.IDFASEGRUPOFECHAMENTO = B.IDFASEGRUPOFECHAMENTO
                                        AND
                                            B.IDCONTATO = :idContato
                                        AND
                                            B.IDGRUPO = :idGrupo
                                        AND
                                            B.IDTIPOFECHAMENTOCONTATO = :idTpFechamento
                                  )
       ORDER BY
           DSTIPOCARTEIRA;

    EXEC SQL OPEN ReadTpCarteira;

    for(;;)
    {
        i_dsTpCarteira = -1;

        EXEC SQL FETCH 
            ReadTpCarteira 
        INTO 
            :idTpCarteira,
            :dsTpCarteira:i_dsTpCarteira;

        if( i_dsTpCarteira >= 0 )
            CL_FETCH( dsTpCarteira );

            pxml->createTag("CarterizacaoVO");
                pxml->addItem("idTipoCarteira", idTpCarteira );
                pxml->addItem("descricao",(char*)dsTpCarteira.arr);
            pxml->closeTag();

    }

    EXEC SQL CLOSE ReadTpCarteira;

    ULOG_END("GruposRequest::ConsultaTipoCarteira()"); 

    return 1;

}

int GruposRequest::ConsultaTipoCarteiraAssoc(long idContatoPrm, 
                                             long idGrupoPrm, 
                                             long idTpFechamentoPrm) const
{
    ULOG_START("GruposRequest::ConsultaTipoCarteiraAssoc()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        long idContato = idContatoPrm;
        long idGrupo = idGrupoPrm;
        long idTpFechamento = idTpFechamentoPrm;

        long idTpCarteira;
        VARCHAR dsTpCarteira[256];

        short i_dsTpCarteira = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL DECLARE ReadTpCarteiraAssoc CURSOR FOR
        SELECT 
            IDTIPOCARTEIRA, DSTIPOCARTEIRA 
        FROM 
            APOIO.TIPOCARTEIRA
        WHERE 
            IDTIPOCARTEIRA > 0
        AND IDTIPOCARTEIRA IN (SELECT 
                                        A.IDTIPOCARTEIRA 
                                    FROM 
                                        CONTATOADM.FECHAMENTOTPCARTEIRA  A,
                                        CONTATOADM.FASEGRUPOFECHAMENTO   B
                                    WHERE
                                        A.IDFASEGRUPOFECHAMENTO = B.IDFASEGRUPOFECHAMENTO
                                    AND
                                        B.IDCONTATO = :idContato
                                    AND
                                        B.IDGRUPO = :idGrupo
                                    AND
                                        B.IDTIPOFECHAMENTOCONTATO = :idTpFechamento
                               )
    ORDER BY
           DSTIPOCARTEIRA;

    EXEC SQL OPEN ReadTpCarteiraAssoc;

    for(;;)
    {
        i_dsTpCarteira = -1;

        EXEC SQL FETCH 
            ReadTpCarteiraAssoc 
        INTO 
            :idTpCarteira,
            :dsTpCarteira:i_dsTpCarteira;

        if( i_dsTpCarteira >= 0 )
            CL_FETCH( dsTpCarteira );

            pxml->createTag("CarterizacaoVO");
                pxml->addItem("idTipoCarteira", idTpCarteira );
                pxml->addItem("descricao",(char*)dsTpCarteira.arr);
            pxml->closeTag();
    }

    EXEC SQL CLOSE ReadTpCarteiraAssoc;

    ULOG_END("GruposRequest::ConsultaTipoCarteiraAssoc()"); 

    return 1;
}

int GruposRequest::ConsultaTipoLinha(long idContatoPrm, 
                                       long idGrupoPrm, 
                                     long idTpFechamentoPrm) const
{
    ULOG_START("GruposRequest::ConsultaTipoLinha()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        long idContato = idContatoPrm;
        long idGrupo = idGrupoPrm;
        long idTpFechamento = idTpFechamentoPrm;

        long idTpLinha;
        VARCHAR dsTpLinha[256];

        short i_dsTpLinha = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL DECLARE ReadTpLinha CURSOR FOR
        SELECT 
            IDTIPOLINHA, DSTIPOLINHA 
        FROM 
            APOIO.TIPOLINHA 
        WHERE 
            IDTIPOLINHA NOT IN (SELECT 
                                        A.IDTIPOLINHA 
                                    FROM 
                                        CONTATOADM.FECHAMENTOTIPOLINHA  A,
                                        CONTATOADM.FASEGRUPOFECHAMENTO  B
                                    WHERE
                                        A.IDFASEGRUPOFECHAMENTO = B.IDFASEGRUPOFECHAMENTO
                                    AND
                                        B.IDCONTATO = :idContato
                                    AND
                                        B.IDGRUPO = :idGrupo
                                    AND
                                        B.IDTIPOFECHAMENTOCONTATO = :idTpFechamento
                               )
        AND
            IDTIPOLINHA > 0
        ORDER BY
            DSTIPOLINHA;

    EXEC SQL OPEN ReadTpLinha;

    for(;;)
    {
        i_dsTpLinha = -1;

        EXEC SQL FETCH 
            ReadTpLinha 
        INTO 
            :idTpLinha,
            :dsTpLinha:i_dsTpLinha;

        if( i_dsTpLinha >= 0 )
            CL_FETCH( dsTpLinha );

            pxml->createTag("TipoLinhaVO");
            pxml->addProp("xmlns","cliente.fo.vivo.com.br/vo");
                pxml->addItem("id", idTpLinha );
                pxml->addItem("descricao",(char*)dsTpLinha.arr);
            pxml->closeTag();
    }

    EXEC SQL CLOSE ReadTpLinha;

    ULOG_END("GruposRequest::ConsultaTipoLinha()"); 

    return 1;
}

int GruposRequest::ConsultaTipoLinhaAssoc( long idContatoPrm, 
                                           long idGrupoPrm, 
                                           long idTpFechamentoPrm ) const
{
    ULOG_START("GruposRequest::ConsultaTipoLinhaAssoc()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        long idContato = idContatoPrm;
        long idGrupo = idGrupoPrm;
        long idTpFechamento = idTpFechamentoPrm;

        long idTpLinha;
        VARCHAR dsTpLinha[256];

        short i_dsTpLinha = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL DECLARE ReadTpLinhaAssoc CURSOR FOR
        SELECT 
            IDTIPOLINHA, DSTIPOLINHA 
        FROM 
            APOIO.TIPOLINHA 
        WHERE 
            IDTIPOLINHA IN (SELECT 
                                    A.IDTIPOLINHA 
                                FROM 
                                    CONTATOADM.FECHAMENTOTIPOLINHA  A,
                                    CONTATOADM.FASEGRUPOFECHAMENTO  B
                                WHERE
                                    A.IDFASEGRUPOFECHAMENTO = B.IDFASEGRUPOFECHAMENTO
                                AND
                                    B.IDCONTATO = :idContato
                                AND
                                    B.IDGRUPO = :idGrupo
                                AND
                                    B.IDTIPOFECHAMENTOCONTATO = :idTpFechamento
                           )
        AND
            IDTIPOLINHA > 0
    ORDER BY
            DSTIPOLINHA;

    EXEC SQL OPEN ReadTpLinhaAssoc;

    for(;;)
    {
        i_dsTpLinha = -1;

        EXEC SQL FETCH 
            ReadTpLinhaAssoc 
        INTO 
            :idTpLinha,
            :dsTpLinha:i_dsTpLinha;

        if( i_dsTpLinha >= 0 )
            CL_FETCH( dsTpLinha );

            pxml->createTag("TipoLinhaVO");
            pxml->addProp("xmlns","cliente.fo.vivo.com.br/vo");
                pxml->addItem("id", idTpLinha );
                pxml->addItem("descricao",(char*)dsTpLinha.arr);
            pxml->closeTag();
    }

    EXEC SQL CLOSE ReadTpLinhaAssoc;

    ULOG_END("GruposRequest::ConsultaTipoLinhaAssoc()"); 

    return 1;
}

int GruposRequest::ConsultaTipoPessoa(long idContatoPrm, 
                                        long idGrupoPrm, 
                                      long idTpFechamentoPrm) const
{
    ULOG_START("GruposRequest::ConsultaTipoPessoa()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        long idContato = idContatoPrm;
        long idGrupo = idGrupoPrm;
        long idTpFechamento = idTpFechamentoPrm;

        long idTpPessoa;
        VARCHAR dsTpPessoa[256];

        short i_dsTpPessoa = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL DECLARE ReadTpPessoa CURSOR FOR
        SELECT 
            IDTIPOPESSOA, DSTIPOPESSOA 
        FROM 
            APOIO.TIPOPESSOA 
        WHERE 
            IDTIPOPESSOA NOT IN (SELECT 
                                        FTP.IDTIPOPESSOA 
                                    FROM 
                                        CONTATOADM.FECHAMENTOTIPOPESSOA FTP,
                                        CONTATOADM.FASEGRUPOFECHAMENTO  FGF
                                    WHERE
                                        FTP.IDFASEGRUPOFECHAMENTO = FGF.IDFASEGRUPOFECHAMENTO
                                    AND
                                        FGF.IDCONTATO = :idContato
                                    AND
                                        FGF.IDGRUPO = :idGrupo
                                    AND
                                        FGF.IDTIPOFECHAMENTOCONTATO = :idTpFechamento                                     
                                )
        AND
            IDTIPOPESSOA > 0
        ORDER BY
            DSTIPOPESSOA;

    EXEC SQL OPEN ReadTpPessoa;

    for(;;)
    {
        i_dsTpPessoa = -1;

        EXEC SQL FETCH 
            ReadTpPessoa 
        INTO 
            :idTpPessoa,
            :dsTpPessoa:i_dsTpPessoa;

        if( i_dsTpPessoa >= 0 )
            CL_FETCH( dsTpPessoa );

            pxml->createTag("TipoClienteVO");
                pxml->addItem("codigo", idTpPessoa );
                pxml->addItem("descricao",(char*)dsTpPessoa.arr);
            pxml->closeTag();
    }

    EXEC SQL CLOSE ReadTpPessoa;

    ULOG_END("GruposRequest::ConsultaTipoPessoa()"); 

    return 1;
}

int GruposRequest::ConsultaTipoPessoaAssoc( long idContatoPrm, 
                                             long idGrupoPrm, 
                                            long idTpFechamentoPrm ) const
{
    ULOG_START("GruposRequest::ConsultaTipoPessoaAssoc()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        long idContato = idContatoPrm;
        long idGrupo = idGrupoPrm;
        long idTpFechamento = idTpFechamentoPrm;

        long idTpPessoa;
        VARCHAR dsTpPessoa[256];

        short i_dsTpPessoa = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL DECLARE ReadTpPessoaAssoc CURSOR FOR
        SELECT 
            IDTIPOPESSOA, DSTIPOPESSOA 
        FROM 
            APOIO.TIPOPESSOA 
        WHERE 
            IDTIPOPESSOA IN (SELECT 
                                    FTP.IDTIPOPESSOA 
                                FROM 
                                    CONTATOADM.FECHAMENTOTIPOPESSOA FTP,
                                    CONTATOADM.FASEGRUPOFECHAMENTO  FGF
                                WHERE
                                    FTP.IDFASEGRUPOFECHAMENTO = FGF.IDFASEGRUPOFECHAMENTO
                                AND
                                    FGF.IDCONTATO = :idContato
                                AND
                                    FGF.IDGRUPO = :idGrupo
                                AND
                                    FGF.IDTIPOFECHAMENTOCONTATO = :idTpFechamento                                     
                            )
        AND
            IDTIPOPESSOA > 0
        ORDER BY
            DSTIPOPESSOA;

    EXEC SQL OPEN ReadTpPessoaAssoc;

    for(;;)
    {
        i_dsTpPessoa = -1;

        EXEC SQL FETCH 
            ReadTpPessoaAssoc 
        INTO 
            :idTpPessoa,
            :dsTpPessoa:i_dsTpPessoa;

        if( i_dsTpPessoa >= 0 )
            CL_FETCH( dsTpPessoa );

            pxml->createTag("TipoClienteVO");
                pxml->addItem("codigo", idTpPessoa );
                pxml->addItem("descricao",(char*)dsTpPessoa.arr);
            pxml->closeTag();
    }

    EXEC SQL CLOSE ReadTpPessoaAssoc;

    ULOG_END("GruposRequest::ConsultaTipoPessoaAssoc()"); 

    return 1;
}

int GruposRequest::ConsultaSegmentacao(long idContatoPrm, 
                                       long idGrupoPrm, 
                                       long idTpFechamentoPrm) const
{
    ULOG_START("GruposRequest::ConsultaSegmentacao()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        long idContato = idContatoPrm;
        long idGrupo = idGrupoPrm;
        long idTpFechamento = idTpFechamentoPrm;

        long idSegmentacao;
        VARCHAR dsSegmentacao[256];

        short i_dsSegmentacao = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL DECLARE ReadSegmentacao CURSOR FOR
        SELECT 
            IDSEGMENTACAO, DSSEGMENTACAO 
        FROM 
            APOIO.SEGMENTACAO 
        WHERE 
            IDSEGMENTACAO NOT IN (SELECT 
                                        A.IDSEGMENTACAO 
                                    FROM 
                                        CONTATOADM.FECHAMENTOSEGMENTACAO  A,
                                        CONTATOADM.FASEGRUPOFECHAMENTO    B
                                    WHERE
                                        A.IDFASEGRUPOFECHAMENTO = B.IDFASEGRUPOFECHAMENTO
                                    AND
                                        B.IDCONTATO = :idContato
                                    AND
                                        B.IDGRUPO = :idGrupo
                                    AND
                                        B.IDTIPOFECHAMENTOCONTATO = :idTpFechamento
                                 )
        ORDER BY
            DSSEGMENTACAO;

    EXEC SQL OPEN ReadSegmentacao;

    for(;;)
    {
        i_dsSegmentacao = -1;

        EXEC SQL FETCH 
            ReadSegmentacao 
        INTO 
            :idSegmentacao,
            :dsSegmentacao:i_dsSegmentacao;

        if( i_dsSegmentacao >= 0 )
            CL_FETCH( dsSegmentacao );

            pxml->createTag("SegmentacaoVO");
                pxml->addItem("idSegmentacao", idSegmentacao );
                pxml->addItem("descricao",(char*)dsSegmentacao.arr);
            pxml->closeTag();
    }

    EXEC SQL CLOSE ReadSegmentacao;

    ULOG_END("GruposRequest::ConsultaSegmentacao()"); 

    return 1;
}

int GruposRequest::ConsultaSegmentacaoAssoc(long idContatoPrm, 
                                            long idGrupoPrm, 
                                            long idTpFechamentoPrm) const
{
   
    ULOG_START("GruposRequest::ConsultaSegmentacaoAssoc()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        long idContato = idContatoPrm;
        long idGrupo = idGrupoPrm;
        long idTpFechamento = idTpFechamentoPrm;

        long idSegmentacao;
        VARCHAR dsSegmentacao[256];

        short i_dsSegmentacao = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL DECLARE ReadSegmentacaoAssoc CURSOR FOR
        SELECT 
            IDSEGMENTACAO, DSSEGMENTACAO 
        FROM 
            APOIO.SEGMENTACAO 
        WHERE 
            IDSEGMENTACAO IN (SELECT 
                                    A.IDSEGMENTACAO 
                                FROM 
                                    CONTATOADM.FECHAMENTOSEGMENTACAO  A,
                                    CONTATOADM.FASEGRUPOFECHAMENTO    B
                                WHERE
                                    A.IDFASEGRUPOFECHAMENTO = B.IDFASEGRUPOFECHAMENTO
                                AND
                                    B.IDCONTATO = :idContato
                                AND
                                    B.IDGRUPO = :idGrupo
                                AND
                                    B.IDTIPOFECHAMENTOCONTATO = :idTpFechamento
                             )
        ORDER BY
            DSSEGMENTACAO;

    EXEC SQL OPEN ReadSegmentacaoAssoc;

    for(;;)
    {
        i_dsSegmentacao = -1;

        EXEC SQL FETCH 
            ReadSegmentacaoAssoc 
        INTO 
            :idSegmentacao,
            :dsSegmentacao:i_dsSegmentacao;

        if( i_dsSegmentacao >= 0 )
            CL_FETCH( dsSegmentacao );

            pxml->createTag("SegmentacaoVO");
                pxml->addItem("idSegmentacao", idSegmentacao );
                pxml->addItem("descricao",(char*)dsSegmentacao.arr);
            pxml->closeTag();
    }

    EXEC SQL CLOSE ReadSegmentacaoAssoc;

    ULOG_END("GruposRequest::ConsultaSegmentacaoAssoc()"); 

    return 1;
}

int GruposRequest::ConsultaTipoRelacion(long idContatoPrm, 
                                        long idGrupoPrm, 
                                        long idTpFechamentoPrm) const
{
    ULOG_START("GruposRequest::ConsultaTipoRelacion()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        long idContato = idContatoPrm;
        long idGrupo = idGrupoPrm;
        long idTpFechamento = idTpFechamentoPrm;

        long idTpRelacion;
        VARCHAR dsTpRelacion[256];

        short i_dsTpRelacion = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL DECLARE ReadTpRelacion CURSOR FOR
        SELECT 
            IDTIPORELACIONAMENTO, NMTIPORELACIONAMENTO 
        FROM 
            CUSTOMER.TIPORELACIONAMENTO 
        WHERE 
            IDTIPORELACIONAMENTO NOT IN (SELECT 
                                                A.IDTIPORELACIONAMENTO 
                                            FROM 
                                                CONTATOADM.FECHAMENTOTPRELACIONAMENTO A,
                                                CONTATOADM.FASEGRUPOFECHAMENTO        B
                                            WHERE
                                                 A.IDFASEGRUPOFECHAMENTO = B.IDFASEGRUPOFECHAMENTO
                                            AND
                                                 B.IDCONTATO = :idContato
                                            AND
                                                 B.IDGRUPO = :idGrupo
                                            AND
                                                 B.IDTIPOFECHAMENTOCONTATO = :idTpFechamento
                                        )
        AND
            IDTIPORELACIONAMENTO > 0
        ORDER BY
            NMTIPORELACIONAMENTO;

    EXEC SQL OPEN ReadTpRelacion;

    for(;;)
    {
        i_dsTpRelacion = -1;

        EXEC SQL FETCH 
            ReadTpRelacion 
        INTO 
            :idTpRelacion,
            :dsTpRelacion:i_dsTpRelacion;

        if( i_dsTpRelacion >= 0 )
            CL_FETCH( dsTpRelacion );

            pxml->createTag("AdmNaturezaVO");
                pxml->addItem("idNatureza", idTpRelacion );
                pxml->addItem("dsNatureza",(char*)dsTpRelacion.arr);
            pxml->closeTag();
    }

    EXEC SQL CLOSE ReadTpRelacion;

    ULOG_END("GruposRequest::ConsultaTipoRelacion()"); 

    return 1;
}

int GruposRequest::ConsultaTipoRelacionAssoc(long idContatoPrm,
                                             long idGrupoPrm, 
                                             long idTpFechamentoPrm) const
{
    ULOG_START("GruposRequest::ConsultaTipoRelacionAssoc()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        long idContato = idContatoPrm;
        long idGrupo = idGrupoPrm;
        long idTpFechamento = idTpFechamentoPrm;

        long idTpRelacion;
        VARCHAR dsTpRelacion[256];

        short i_dsTpRelacion = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL DECLARE ReadTpRelacionAssoc CURSOR FOR
        SELECT 
            IDTIPORELACIONAMENTO, NMTIPORELACIONAMENTO 
        FROM 
            CUSTOMER.TIPORELACIONAMENTO 
        WHERE 
            IDTIPORELACIONAMENTO IN (SELECT 
                                            A.IDTIPORELACIONAMENTO 
                                        FROM 
                                            CONTATOADM.FECHAMENTOTPRELACIONAMENTO A,
                                            CONTATOADM.FASEGRUPOFECHAMENTO        B
                                        WHERE
                                             A.IDFASEGRUPOFECHAMENTO = B.IDFASEGRUPOFECHAMENTO
                                        AND
                                             B.IDCONTATO = :idContato
                                        AND
                                             B.IDGRUPO = :idGrupo
                                        AND
                                             B.IDTIPOFECHAMENTOCONTATO = :idTpFechamento
                                    )
        AND
            IDTIPORELACIONAMENTO > 0
        ORDER BY
            NMTIPORELACIONAMENTO;

    EXEC SQL OPEN ReadTpRelacionAssoc;

    for(;;)
    {
        i_dsTpRelacion = -1;

        EXEC SQL FETCH 
            ReadTpRelacionAssoc 
        INTO 
            :idTpRelacion,
            :dsTpRelacion:i_dsTpRelacion;

        if( i_dsTpRelacion >= 0 )
            CL_FETCH( dsTpRelacion );

            pxml->createTag("AdmNaturezaVO");
                pxml->addItem("idNatureza", idTpRelacion );
                pxml->addItem("dsNatureza",(char*)dsTpRelacion.arr);
            pxml->closeTag();
    }

    EXEC SQL CLOSE ReadTpRelacionAssoc;

    ULOG_END("GruposRequest::ConsultaTipoRelacionAssoc()"); 

    return 1;
}

int GruposRequest::ConsultaGruposTpFechamento(long idContatoPrm, 
                                              long idTpFechamentoPrm) const
{
    ULOG_START("GruposRequest::ConsultaGruposTpFechamento()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        VARCHAR idContato[51];
        VARCHAR idTpFechamento[51];

        long idGrupo;
        VARCHAR nmGrupo[256];

        short i_nmGrupo = -1;

    EXEC SQL END DECLARE SECTION;

    sprintf( (char *)idContato.arr,"%lu",idContatoPrm );
    idContato.len = strlen((char *)idContato.arr);

    sprintf( (char *)idTpFechamento.arr,"%lu",idTpFechamentoPrm );
    idTpFechamento.len = strlen((char *)idTpFechamento.arr);
    
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL DECLARE ReadTpFechamento CURSOR FOR
        SELECT DISTINCT 
            c.idGrupo,
            c.nmGrupo
        FROM
            ContatoAdm.ContatoGrupo a,
            ContatoAdm.Sequencia    b,
            Acesso.Grupo            c
        WHERE
            a.idContatoGrupo = b.idContatoGrupo
        AND
            a.idGrupo = c.idGrupo
        AND
            c.dtexclusao is null
        AND
            b.idTipoSequencia = 1
        AND
            a.idContato = :idContato
        AND
            a.idGrupo NOT IN (SELECT
                                    IDGRUPO
                                FROM
                                    CONTATOADM.FASEGRUPOFECHAMENTO
                                WHERE
                                    IDCONTATO = :idContato
                                AND
                                    IDTIPOFECHAMENTOCONTATO = :idTpFechamento
                             )
        ORDER BY UPPER (c.nmGrupo);


    EXEC SQL OPEN ReadTpFechamento;

    pxml->createTag("GruposDisponiveis");
        pxml->createTag("GrupoProcessoVO");

        for(;;)
        {
            i_nmGrupo = -1;

            EXEC SQL FETCH 
                ReadTpFechamento 
            INTO 
                :idGrupo,
                :nmGrupo:i_nmGrupo;

            if( i_nmGrupo >= 0 )
                CL_FETCH( nmGrupo );

            pxml->createTag("GrupoVO");
                pxml->addItem("codigo", idGrupo );
                pxml->addItem("descricao",(char*)nmGrupo.arr);
                pxml->addItem("status", 0 );
            pxml->closeTag();
        }

        pxml->closeTag();
    pxml->closeTag();

    EXEC SQL CLOSE ReadTpFechamento;

    ULOG_END("GruposRequest::ConsultaGruposTpFechamento()"); 

    return 1;
}

int GruposRequest::ConsultaGruposTpFechamentoAssoc(long idContatoPrm
                                                  ,long idTpFechamentoPrm) const
{
    ULOG_START("GruposRequest::ConsultaGruposTpFechamentoAssoc()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        long idContato = idContatoPrm;
        long idTpFechamento = idTpFechamentoPrm;

        long idGrupo;
        VARCHAR nmGrupo[256];

        short i_nmGrupo = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL DECLARE ReadTpFechamentoAssoc CURSOR FOR
        SELECT DISTINCT 
            c.idGrupo,c.nmGrupo
        FROM
            ContatoAdm.ContatoGrupo a,
            ContatoAdm.Sequencia    b,
            Acesso.Grupo            c
        WHERE
            a.idContatoGrupo = b.idContatoGrupo
        AND
            a.idGrupo = c.idGrupo
        AND
            c.dtexclusao is null
        AND
            b.idTipoSequencia = 1
        AND
            a.idContato = :idContato
        AND
            a.idGrupo IN (SELECT
                                    IDGRUPO
                                FROM
                                    CONTATOADM.FASEGRUPOFECHAMENTO
                                WHERE
                                    IDCONTATO = :idContato
                                AND
                                    IDTIPOFECHAMENTOCONTATO = :idTpFechamento
                         )
        ORDER BY UPPER (c.nmGrupo);

    EXEC SQL OPEN ReadTpFechamentoAssoc;

    pxml->createTag("GruposAbertura");
        pxml->createTag("GrupoProcessoVO");

        for(;;)
        {
            i_nmGrupo = -1;

            EXEC SQL FETCH 
                ReadTpFechamentoAssoc 
            INTO 
                :idGrupo,
                :nmGrupo:i_nmGrupo;

            if( i_nmGrupo >= 0 )
                CL_FETCH( nmGrupo );

            pxml->createTag("GrupoVO");
                pxml->addItem("codigo", idGrupo );
                pxml->addItem("descricao",(char*)nmGrupo.arr);
                pxml->addItem("status", 0 );
            pxml->closeTag();
        }

        pxml->closeTag();
    pxml->closeTag();

    EXEC SQL CLOSE ReadTpFechamentoAssoc;

    ULOG_END("GruposRequest::ConsultaGruposTpFechamentoAssoc()"); 

    return 1;
}

long GruposRequest::TotalRegistros(long  idContatoPrm, 
                                            long  idGrupoPrm,
                                            long  idTipoFechamentoPrm,
                                            long *idTipoLinhaPrm,
                                            long *idSegmentacaoPrm,
                                            long *idTipoCarteiraPrm,
                                            long *idTipoPessoaPrm,
                                            long *idTipoRelacionamentoPrm) const
{
    ULOG_START("GruposRequest::TotalRegistros()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        char *queryChar;

        long TotalRegistros = 0L;

    EXEC SQL END DECLARE SECTION;

    char buffer[100];
    int i;
    SmallString query;
    bool montaAND = false;

    query = "SELECT COUNT(1) FROM ContatoAdm.FaseGrupoFechamentoVarV01 WHERE ";
    
    for ( i=0;;i++ )
    {
        if ( idTipoLinhaPrm[i] == -1 )
           break;

        if ( i == 0 )
            query += "idTipoLinha IN (";
        else
            query += ",";
        
        sprintf( buffer,"%lu",idTipoLinhaPrm[i] );
        query += buffer;
    }
    if ( i > 0 )
    {
       query += ") ";
       montaAND = true;
    }

    for ( i=0;;i++ )
    {
        if ( idSegmentacaoPrm[i] == -1 )
           break;

        if ( montaAND == true )
        {
            query += "AND ";
            montaAND = false;
        }

        if ( i == 0 )
            query += "idSegmentacao IN (";
        else
            query += ",";
        
        sprintf( buffer,"%lu",idSegmentacaoPrm[i] );
        query += buffer;
    }
    if ( i > 0 )
    {
        query += ") ";
        montaAND = true;
    }

    for ( i=0;;i++ )
    {
        if ( idTipoCarteiraPrm[i] == -1 )
           break;
        
        if ( montaAND == true )
        {
            query += "AND ";
            montaAND = false;
        }

        if ( i == 0 )
            query += "idTipoCarteira IN (";
        else
            query += ",";
        
        sprintf( buffer,"%lu",idTipoCarteiraPrm[i] );
        query += buffer;
    }
    if ( i > 0 )
    {
        query += ") ";
        montaAND = true;
    }

    for ( i=0;;i++ )
    {
        if ( idTipoPessoaPrm[i] == -1 )
           break;
        
        if ( montaAND == true )
        {
            query += "AND ";
            montaAND = false;
        }

        if ( i == 0 )
            query += "idTipoPessoa IN (";
        else
            query += ",";
        
        sprintf( buffer,"%lu",idTipoPessoaPrm[i] );
        query += buffer;
    }
    if ( i > 0 )
    {
        query += ") ";
        montaAND = true;
    }

    for ( i=0;;i++ )
    {
        if ( idTipoRelacionamentoPrm[i] == -1 )
           break;
        
        if ( montaAND == true )
        {
            query += "AND ";
            montaAND = false;
        }

        if ( i == 0 )
            query += "idTipoRelacionamento IN (";
        else
            query += ",";
        
        sprintf( buffer,"%lu",idTipoRelacionamentoPrm[i] );
        query += buffer;
    }
    if ( i > 0 )
    {
        query += ") ";
        montaAND = true;
    }

    if ( montaAND == true )
        query += "AND ";

    query += "idContato = ";
    sprintf( buffer,"%lu",idContatoPrm );
    query += buffer;

    query += " AND idGrupo = ";
    sprintf( buffer,"%lu",idGrupoPrm );
    query += buffer;

    query += " AND idTipoFechamentoContato != ";
    sprintf( buffer,"%lu",idTipoFechamentoPrm );
    query += buffer;

    queryChar = query;


    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );

    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL PREPARE comandoSQL FROM :queryChar;

    EXEC SQL DECLARE consultaTot CURSOR FOR comandoSQL;
    EXEC SQL OPEN consultaTot;

    EXEC SQL FETCH 
        consultaTot 
    INTO 
        :TotalRegistros; 

    EXEC SQL CLOSE consultaTot;

    ULOG_END("GruposRequest::TotalRegistros()"); 

    return TotalRegistros;
}

long GruposRequest::RegistroAtual(long idContatoPrm, 
                                    long idGrupoPrm,
                                           long idTipoFechamentoPrm) const
{
    ULOG_START("GruposRequest::RegistroAtual()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

       long idContatoWrk = idContatoPrm;
       long idGrupoWrk = idGrupoPrm;
       long idTipoFechamentoWrk = idTipoFechamentoPrm;

       long idFaseGrupoFechamentoWrk = 0x0;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL
        SELECT
           IDFASEGRUPOFECHAMENTO
        INTO
           :idFaseGrupoFechamentoWrk
        FROM
           CONTATOADM.FASEGRUPOFECHAMENTO
        WHERE
           IDCONTATO = :idContatoWrk
        AND
           IDGRUPO = :idGrupoWrk
        AND
           IDTIPOFECHAMENTOCONTATO = :idTipoFechamentoWrk;

    ULOG_END("GruposRequest::RegistroAtual()"); 

    return idFaseGrupoFechamentoWrk;

}

bool GruposRequest::RegistrosInconsistentes(long  idContatoPrm, 
                                            long  idGrupoPrm,
                                            long  idTipoFechamentoPrm,
                                            long *idTipoLinhaPrm,
                                            long *idSegmentacaoPrm,
                                            long *idTipoCarteiraPrm,
                                            long *idTipoPessoaPrm,
                                            long *idTipoRelacionamentoPrm) const
{
    ULOG_START("GruposRequest::RegistrosInconsistentes()"); 

    INITIALIZE_SQL;

    EXEC SQL BEGIN DECLARE SECTION;

        char *queryChar;

        long idFaseGrupoFechamento = 0L;
        long idFaseWrk[500];

    EXEC SQL END DECLARE SECTION;

    char buffer[128];

    int i;
    SmallString query;
    SmallString queryRemove;
    bool montaAND = false;

    query  = "SELECT DISTINCT IDFASEGRUPOFECHAMENTO FROM ContatoAdm.FaseGrupoFechamentoVarV01 WHERE ";
    
    for ( i=0;;i++ )
    {
        if ( idTipoLinhaPrm[i] == -1 )
           break;

        if ( i == 0 )
            query += "idTipoLinha IN (";
        else
            query += ",";
        
        sprintf( buffer,"%lu",idTipoLinhaPrm[i] );
        query += buffer;
    }
    if ( i > 0 )
    {
       query += ") ";
       montaAND = true;
    }

    for ( i=0;;i++ )
    {
        if ( idSegmentacaoPrm[i] == -1 )
           break;

        if ( montaAND == true )
        {
            query += "AND ";
            montaAND = false;
        }

        if ( i == 0 )
            query += "idSegmentacao IN (";
        else
            query += ",";
        
        sprintf( buffer,"%lu",idSegmentacaoPrm[i] );
        query += buffer;
    }
    if ( i > 0 )
    {
        query += ") ";
        montaAND = true;
    }

    for ( i=0;;i++ )
    {
        if ( idTipoCarteiraPrm[i] == -1 )
           break;
        
        if ( montaAND == true )
        {
            query += "AND ";
            montaAND = false;
        }

        if ( i == 0 )
            query += "idTipoCarteira IN (";
        else
            query += ",";
        
        sprintf( buffer,"%lu",idTipoCarteiraPrm[i] );
        query += buffer;
    }
    if ( i > 0 )
    {
        query += ") ";
        montaAND = true;
    }

    for ( i=0;;i++ )
    {
        if ( idTipoPessoaPrm[i] == -1 )
           break;
        
        if ( montaAND == true )
        {
            query += "AND ";
            montaAND = false;
        }

        if ( i == 0 )
            query += "idTipoPessoa IN (";
        else
            query += ",";
        
        sprintf( buffer,"%lu",idTipoPessoaPrm[i] );
        query += buffer;
    }
    if ( i > 0 )
    {
        query += ") ";
        montaAND = true;
    }

    for ( i=0;;i++ )
    {
        if ( idTipoRelacionamentoPrm[i] == -1 )
           break;
        
        if ( montaAND == true )
        {
            query += "AND ";
            montaAND = false;
        }

        if ( i == 0 )
            query += "idTipoRelacionamento IN (";
        else
            query += ",";
        
        sprintf( buffer,"%lu",idTipoRelacionamentoPrm[i] );
        query += buffer;
    }
    if ( i > 0 )
    {
        query += ") ";
        montaAND = true;
    }

    if ( montaAND == true )
        query += "AND ";

    query += "idContato = ";
    sprintf( buffer,"%lu",idContatoPrm );
    query += buffer;

    query += " AND idGrupo = ";
    sprintf( buffer,"%lu",idGrupoPrm );
    query += buffer;

    query += " AND idTipoFechamentoContato != ";
    sprintf( buffer,"%lu",idTipoFechamentoPrm );
    query += buffer;

    queryChar = query;


    EXEC SQL WHENEVER SQLERROR DO Sql_Error_Read( &sqlca );
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL PREPARE comandoSql FROM :queryChar;
    EXEC SQL DECLARE Read CURSOR FOR comandoSql;

    EXEC SQL OPEN Read;
    
    i = 0;
    for ( ;; )
    {
        EXEC SQL FETCH Read INTO :idFaseGrupoFechamento;

        idFaseWrk[i] = idFaseGrupoFechamento;
        i++;
    }

    EXEC SQL CLOSE Read;

    if ( idFaseWrk[0] == 0L )
    {
        ULOG_END("GruposRequest::RegistrosInconsistentes()"); 
        return true;
    }

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL DELETE FROM 
        CONTATOADM.FECHAMENTOTIPOLINHA
    WHERE 
        IDFASEGRUPOFECHAMENTO = :idFaseWrk;

    EXEC SQL DELETE FROM 
        CONTATOADM.FECHAMENTOTIPOPESSOA
    WHERE 
        IDFASEGRUPOFECHAMENTO = :idFaseWrk;

    EXEC SQL DELETE FROM 
        CONTATOADM.FECHAMENTOTPCARTEIRA
    WHERE 
        IDFASEGRUPOFECHAMENTO = :idFaseWrk;

    EXEC SQL DELETE FROM 
        CONTATOADM.FECHAMENTOTPRELACIONAMENTO
    WHERE 
        IDFASEGRUPOFECHAMENTO = :idFaseWrk;

    EXEC SQL DELETE FROM 
        CONTATOADM.FECHAMENTOSEGMENTACAO
    WHERE 
        IDFASEGRUPOFECHAMENTO = :idFaseWrk;
    
    EXEC SQL DELETE FROM 
        CONTATOADM.FASEGRUPOFECHAMENTO
    WHERE
        IDFASEGRUPOFECHAMENTO = :idFaseWrk;

    ULOG_END("GruposRequest::RegistrosInconsistentes()"); 

    return true;
}

void Sql_Error_Read( sqlca * sqlca )
{
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
