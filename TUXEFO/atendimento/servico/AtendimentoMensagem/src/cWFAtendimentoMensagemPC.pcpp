#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"


#include "../include/cWFAtendimentoMensagem.h"
#include "../include/stWFAtendimentoMensagem.h"

void sql_error_WFAtendimentoMensagem(sqlca*sqlca);

	// Declara as estruturas compatíveis ao ProC.
    EXEC SQL BEGIN DECLARE SECTION;
		#include "../include/stWFAtendimentoMensagem.h"
    EXEC SQL END DECLARE SECTION;

bool proCIncluirWFAtendimentoMensagem(st_AtendimentoMensagem* dados, st_vlAtendimentoMensagem* status, XMLGen* saida)
{

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AtendimentoMensagem   oDados;
		struct st_vlAtendimentoMensagem oStatus;

	EXEC SQL END DECLARE SECTION;

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoMensagem(&sqlca);

	EXEC SQL SELECT atendimento.AtendimentoAlertaSQ.NEXTVAL INTO :oDados.idAtendimentoMensagem FROM DUAL;

	EXEC SQL 
		INSERT INTO
			ATENDIMENTO.ATENDIMENTOALERTA
			(
				IDATENDIMENTOALERTA,
				IDATENDIMENTO,
				IDALERTA,
                DTULTIMAALTERACAO,
                IDUSUARIOALTERACAO
			)
			VALUES
			(
				:oDados.idAtendimentoMensagem,
				:oDados.idAtendimento,
				:oDados.idMensagemAtendimento,
                SYSDATE,
                NULL
			);

	saida->createTag("Registro");
		saida->addItem("idAtendimentoAlerta", oDados.idAtendimentoMensagem);
	saida->closeTag();

	return true;
}

bool proCAlterarWFAtendimentoMensagem(st_AtendimentoMensagem* dados, st_vlAtendimentoMensagem* status, XMLGen* saida)
{

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AtendimentoMensagem   oDados;
		struct st_vlAtendimentoMensagem oStatus;

		char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoMensagem(&sqlca);

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

	sprintf(query,"%s", "UPDATE atendimento.AtendimentoMensagem SET ");

	bool separa = false;

	if (status->idAtendimento != -1) 
		montaUpdate("idAtendimento", oDados.idAtendimento, 1);

	if (status->idMensagemAtendimento != -1) 
		montaUpdate("idMensagemAtendimento", oDados.idMensagemAtendimento, 1);

	if (status->dtMensagem != -1)
		montaUpdate("dtMensagem", oDados.dtMensagem, 4);
			

	sprintf(query, "%s WHERE idAtendimento = %ld", query, dados->idAtendimento);

	EXEC SQL EXECUTE IMMEDIATE :query;

	return true;
}

bool proCExcluirWFAtendimentoMensagem(st_AtendimentoMensagem* dados, st_vlAtendimentoMensagem* status, XMLGen* saida)
{

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimentoMensagem = dados->idAtendimentoMensagem;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoMensagem(&sqlca);

	EXEC SQL 
		DELETE
			atendimento.AtendimentoMensagem
		WHERE
			idAtendimentoMensagem = :idAtendimentoMensagem;

	return true;
}

bool proCConsultaWFAtendimentoMensagem(st_AtendimentoMensagem* dados, st_vlAtendimentoMensagem* status, char* order, XMLGen* saida)
{

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimentoMensagem;
		long idAtendimento;
		long idMensagemAtendimento;
		VARCHAR dtMensagem[256];

		char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoMensagem(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	sprintf(query,"SELECT idAtendimentoMensagem, idAtendimento, idMensagemAtendimento, TO_CHAR(dtMensagem,'dd/mm/yyyy hh24:mi') FROM atendimento.AtendimentoMensagem ");

	bool separa = false;

	if (status->idAtendimentoMensagem != -1) 
		montaWhere("idAtendimentoMensagem", dados->idAtendimentoMensagem, 1);

	if (status->idAtendimento != -1) 
		montaWhere("idAtendimento", dados->idAtendimento, 1);

	if (status->idMensagemAtendimento != -1)
		montaWhere("idMensagemAtendimento", dados->idMensagemAtendimento, 1);

	if (status->dtMensagem != -1) 
		montaWhere("dtMensagem", dados->dtMensagem, 4);


	if (strlen(order) > 0) 
		sprintf( query, "%s ORDER BY %s ", query, order);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoMensagem(&sqlca);

	EXEC SQL PREPARE consultaAtendimentoMensagem FROM :query;
	EXEC SQL DECLARE consulta CURSOR FOR consultaAtendimentoMensagem;

	EXEC SQL OPEN consulta;

	while (true)
	{
		EXEC SQL FETCH consulta INTO :idAtendimentoMensagem, :idAtendimento, :idMensagemAtendimento, :dtMensagem;

		CONV(dtMensagem);

		saida->createTag("WFAtendimentoMensagemVO");
			saida->addItem("idAtendimentoMensagem", idAtendimentoMensagem);
			saida->addItem("idAtendimento", idAtendimento);
			saida->addItem("idMensagemAtendimento", idMensagemAtendimento);
			saida->addItem("dtMensagem", (char *)dtMensagem.arr);
		saida->closeTag();
	}

	EXEC SQL CLOSE consulta;

	return true;

}

bool proCObterWFAtividadeMensagem(int sIdAtividade, XMLGen* saida)
{

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idAtividade = sIdAtividade;
		int idAlerta;
		VARCHAR nmCor[256];
		VARCHAR nrCriticidade[256];

		short i_nmCor;
		short i_nrCriticidade;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoMensagem(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE consultaAlertaAtividade CURSOR FOR 
		SELECT 
			A.IDALERTA,
			A.NMCOR,
			A.NRCRITICIDADE
		FROM 
			WORKFLOW.ATIVIDADEALERTA AA, 
			WORKFLOW.ALERTA A
		WHERE 
			A.IDALERTA = AA.IDALERTA
			AND IDATIVIDADE=:idAtividade;

	EXEC SQL OPEN consultaAlertaAtividade;

	while (true)
	{
		EXEC SQL FETCH consultaAlertaAtividade INTO :idAlerta,
							    :nmCor:i_nmCor,
							    :nrCriticidade:i_nrCriticidade;

		CONVIND(nmCor, i_nmCor);
		CONVIND(nrCriticidade, i_nrCriticidade);

		saida->createTag("WFAlertaVO");
			saida->addItem("idAlerta", idAlerta);
			saida->addItem("nmCor", (char*)nmCor.arr);
			saida->addItem("nrCriticidade", (char*)nrCriticidade.arr);
		saida->closeTag();
	}

	EXEC SQL CLOSE consultaAlertaAtividade;

	return true;

}

bool proCObterWFMensagemDinamico(long sIdAtendimento, XMLGen* saida)
{

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimento = sIdAtendimento;
		VARCHAR dsMensagem[256];
		VARCHAR nmCor[256];
		VARCHAR nrCriticidadeAlerta[256];
		VARCHAR nrCriticidade[256];

		short i_dsMensagem;
		short i_nmCor;
		short i_nrCriticidadeAlerta;
		short i_nrCriticidade;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoMensagem(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE consultaAlertaDinamica CURSOR FOR 
		SELECT 
			DSALERTA,
			NMCOR,
			NRCRITICIDADEALERTA,
			NRCRITICIDADE
		FROM 
			ATENDIMENTO.ATENDIMENTONOVASPRIORIDADESV01
		WHERE 
			IDATENDIMENTO=:idAtendimento;

	EXEC SQL OPEN consultaAlertaDinamica;

	while (true)
	{
		EXEC SQL FETCH consultaAlertaDinamica INTO :dsMensagem:i_dsMensagem,
							    :nmCor:i_nmCor,
							    :nrCriticidadeAlerta:i_nrCriticidadeAlerta,
							    :nrCriticidade:i_nrCriticidade;

		CONVIND(dsMensagem, i_dsMensagem);
		CONVIND(nmCor, i_nmCor);
		CONVIND(nrCriticidadeAlerta, i_nrCriticidadeAlerta);
		CONVIND(nrCriticidade, i_nrCriticidade);

		saida->createTag("WFAlertaVO");
			saida->addItem("dsMensagem", (char*)dsMensagem.arr);
			saida->addItem("nmCor", (char*)nmCor.arr);
			saida->addItem("nrCriticidadeAlerta", (char*)nrCriticidadeAlerta.arr);
			saida->addItem("nrCriticidade", (char*)nrCriticidade.arr);
		saida->closeTag();
	}

	EXEC SQL CLOSE consultaAlertaDinamica;

	return true;

}

void sql_error_WFAtendimentoMensagem(sqlca*sqlca)
{
	throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
