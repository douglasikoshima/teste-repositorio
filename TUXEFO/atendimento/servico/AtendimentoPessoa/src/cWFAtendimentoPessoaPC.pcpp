/**
 * @author  Renato Teixeira
 * @version $Revision: 1.1.2.2.6.2 $
 * @CVS     $Author: a5114878 $ - $Date: 2013/02/06 12:36:43 $
 **/ 
 
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"
#include "../include/cWFAtendimentoPessoa.h"
#include "../../../commons/definesAtendimento.h"

void sql_error_WFAtendimentoPessoa(sqlca*sqlca);

// Declara as estruturas compatíveis ao ProC.
EXEC SQL BEGIN DECLARE SECTION;
    #include "../include/stWFAtendimentoPessoa.h"
EXEC SQL END DECLARE SECTION;

long proCIncluirWFAtendimentoPessoa(st_AtendimentoPessoa* dados, st_vlAtendimentoPessoa* status, XMLDPR *xmlDpr)
{
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        struct st_AtendimentoPessoa   oDados;
        struct st_vlAtendimentoPessoa oStatus;

    EXEC SQL END DECLARE SECTION;

    memcpy(&oDados,  dados,  sizeof(oDados));
    memcpy(&oStatus, status, sizeof(oStatus));

    ULOG("idAtendimento=%ld",oDados.idAtendimento);
    ULOG("idPessoaDePara=%d",oDados.idPessoaDePara);
    ULOG("idTipoRelacionamento=%d",oDados.idTipoRelacionamento);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoPessoa(&sqlca);

    EXEC SQL 
        SELECT
            atendimento.AtendimentoPessoaSQ.NEXTVAL 
        INTO 
            :oDados.idAtendimentoPessoa
        FROM 
            DUAL;

    // Tivemos de voltar a coluna INRESPONSAVELABERTURA, para resolver
    // um problema de ultima hora. Existem views materializadas para
    // o DPR que fazem acesso a esta coluna e nao ha tempo para gera-las
    // novamente nos ambientes de homologacao. Outubro,2006 - Cassio
    EXEC SQL 
        INSERT INTO
            ATENDIMENTO.ATENDIMENTOPESSOA
            (
                IDATENDIMENTOPESSOA,
                IDATENDIMENTO,
                IDPESSOADEPARA,
                IDTIPORELACIONAMENTO,
                INRESPONSAVELABERTURA,
                IDUSUARIOALTERACAO,
                DTULTIMAALTERACAO
            )
            VALUES
            (
                :oDados.idAtendimentoPessoa,
                :oDados.idAtendimento,
                :oDados.idPessoaDePara,
                nvl(:oDados.idTipoRelacionamento,2),
                nvl(:oDados.idTipoRelacionamento,2),
                DECODE(:oStatus.idUsuarioAlteracao, -1, NULL, :oDados.idUsuarioAlteracao),
                DECODE(:oStatus.dtUltimaAlteracao,-1,SYSDATE,TO_DATE(:oDados.dtUltimaAlteracao,'DD/MM/YYYY HH24:MI:SS'))
            );

    // ==> SM324--DPR--DEZ/2006--Cassio
    if ( xmlDpr )
    {
        AtendimentoPessoaDPR atendimentopessoadpr;

        atendimentopessoadpr.setIdAtendimento(oDados.idAtendimento);
        atendimentopessoadpr.setIdAtendimentoPessoa(oDados.idAtendimentoPessoa);
        atendimentopessoadpr.setIdPessoaDePara(oDados.idPessoaDePara);
        atendimentopessoadpr.setIdTipoRelacionamento(oDados.idTipoRelacionamento);
        atendimentopessoadpr.setOpCode(OPCODE_INSERT);

        xmlDpr->atendimentopessoavo.inserir(&atendimentopessoadpr);
    }
    // <== SM324--DPR--DEZ/2006--Cassio

    return oDados.idAtendimentoPessoa;
}

bool proCAlterarWFAtendimentoPessoa(st_AtendimentoPessoa* dados, st_vlAtendimentoPessoa* status, XMLGen* saida)
{
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		struct st_AtendimentoPessoa   oDados;
		struct st_vlAtendimentoPessoa oStatus;

		char query[1024] = "UPDATE atendimento.AtendimentoPessoa SET ";

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoPessoa(&sqlca);

	memcpy(&oDados,  dados,  sizeof(oDados));
	memcpy(&oStatus, status, sizeof(oStatus));

	bool separa = false;

	if (status->idAtendimentoPessoa != -1) 
		montaUpdate("idAtendimentoPessoa", oDados.idAtendimentoPessoa, 1);

	if (status->idAtendimento != -1) 
		montaUpdate("idAtendimento", oDados.idAtendimento, 1);

	if (status->idPessoaDePara != -1) 
		montaUpdate("idPessoaDePara", oDados.idPessoaDePara, 1);

	if (status->idTipoRelacionamento != -1) 
		montaUpdate("idTipoRelacionamento", oDados.idTipoRelacionamento, 1);

    // Tivemos de voltar a coluna INRESPONSAVELABERTURA, para resolver
    // um problema de ultima hora. Existem views materializadas para
    // o DPR que fazem acesso a esta coluna e nao ha tempo para gera-las
    // novamente nos ambientes de homologacao. Outubro,2006 - Cassio
	if (status->idTipoRelacionamento != -1) 
		montaUpdate("inResponsavelAbertura", oDados.idTipoRelacionamento, 1);

	if (status->idUsuarioAlteracao != -1) 
		montaUpdate("idUsuarioAlteracao", oDados.idUsuarioAlteracao, TIPO_INT);

	if (status->dtUltimaAlteracao != -1) 
		montaUpdate("dtUltimaAlteracao", oDados.dtUltimaAlteracao, TIPO_DATAHORA);

	sprintf(query, "%s WHERE idAtendimentoPessoa = %ld", query, dados->idAtendimentoPessoa);

	EXEC SQL EXECUTE IMMEDIATE :query;

	return true;
}

bool proCExcluirWFAtendimentoPessoa(st_AtendimentoPessoa* dados, st_vlAtendimentoPessoa* status, XMLGen* saida)
{
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimentoPessoa = dados->idAtendimentoPessoa;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoPessoa(&sqlca);

	EXEC SQL 
		DELETE
			atendimento.AtendimentoPessoa
		WHERE
			idAtendimentoPessoa = :idAtendimentoPessoa;

	return true;
}

bool proCConsultaWFAtendimentoPessoa(st_AtendimentoPessoa* dados, st_vlAtendimentoPessoa* status, char* order, XMLGen* saida)
{
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		long idAtendimentoPessoa;
		long idAtendimento;
		int idPessoaDePara;
		int idTipoRelacionamento;
		int idUsuarioAlteracao;
		VARCHAR	dtUltimaAlteracao[256];

		short i_idUsuarioAlteracao;
		short i_dtUltimaAlteracao;

		char query[1024] = "SELECT idAtendimentoPessoa, idAtendimento, idPessoaDePara, "
                                  "idTipoRelacionamento "
                             "FROM atendimento.AtendimentoPessoa ";

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFEstado(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	bool separa = false;

	if (status->idAtendimentoPessoa != -1) 
		montaWhere("idAtendimentoPessoa", dados->idAtendimentoPessoa, 1);

	if (status->idAtendimento != -1) 
		montaWhere("idAtendimento", dados->idAtendimento, 1);

	if (status->idPessoaDePara != -1)
		montaWhere("idPessoaDePara", dados->idPessoaDePara, 1);

	if (status->idTipoRelacionamento != -1)
		montaWhere("idTipoRelacionamento", dados->idTipoRelacionamento, 1);

	if (status->idUsuarioAlteracao != -1) 
		montaWhere("idUsuarioAlteracao", dados->idUsuarioAlteracao, TIPO_INT);

	if (status->dtUltimaAlteracao != -1) 
		montaWhere("dtUltimaAlteracao", dados->dtUltimaAlteracao, TIPO_DATAHORA);

	if (strlen(order) > 0) 
		sprintf( query, "%s ORDER BY %s ", query, order);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoPessoa(&sqlca);

	EXEC SQL PREPARE consultaAtendimentoPessoa FROM :query;
	EXEC SQL DECLARE consulta CURSOR FOR consultaAtendimentoPessoa;

	EXEC SQL OPEN consulta;

	while (true)
	{
		EXEC SQL FETCH consulta INTO 
									:idAtendimentoPessoa, 
									:idAtendimento, 
									:idPessoaDePara, 
									:idTipoRelacionamento,
									:idUsuarioAlteracao:i_idUsuarioAlteracao,
									:dtUltimaAlteracao:i_dtUltimaAlteracao;

		saida->createTag("WFAtendimentoPessoaVO");
			saida->addItem("idAtendimentoPessoa", idAtendimentoPessoa);
			saida->addItem("idAtendimento", idAtendimento);
			saida->addItem("idPessoaDePara", idPessoaDePara);
			saida->addItem("inResponsavelAbertura", idTipoRelacionamento);
			saida->addItem("idUsuarioAlteracao", idUsuarioAlteracao);
			saida->addItem("dtUltimaAlteracao", (char*)dtUltimaAlteracao.arr);
		saida->closeTag();
	}

	EXEC SQL CLOSE consulta;

	return true;
}

bool proCObtemWFPessoaAtendimento(long sIdAtendimento,XMLGen* saida,AtendimentoPessoa *ap)
{
    ULOG_START( "proCObtemWFPessoaAtendimento()" );

    struct sqlca sqlca;
    
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR nrDocumento[256];
        long idAtendimento = sIdAtendimento;
        int  idPessoaDePara;
        long  idPessoa;
        int  idTipoCarteira;
        VARCHAR dsTipoCarteira[256];
        int  idSegmentacao;
        VARCHAR dsSegmentacao[256];
        int  idTipoPessoa;
        VARCHAR nmpessoa[256];
        int  idTipoRelacionamento;
        VARCHAR dsTipoRelacionamento[256];
        VARCHAR dataCadastro[256];
        VARCHAR sgTipoPessoa[256];
        VARCHAR dsComunicacao[256];
        VARCHAR nmCadastradoPor[256];

        short i_nrDocumento = -1;
        short i_idPessoaDePara = -1;
        short i_idPessoa = -1;
        short i_idTipoCarteira = -1;
        short i_dsTipoCarteira = -1;
        short i_idSegmentacao = -1;
        short i_dsSegmentacao = -1;
        short i_idTipoPessoa = -1;
        short i_nmpessoa = -1;
        short i_idTipoRelacionamento = -1;
        short i_dsTipoRelacionamento = -1;
        short i_dataCadastro = -1;
        short i_sgTipoPessoa = -1;
        short i_dsComunicacao = -1;
        short i_nmCadastradoPor = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoPessoa(&sqlca);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    ULOG("idAtendimento: %ld",idAtendimento);

    EXEC SQL
        SELECT
            DOCUMENTO.NRDOCUMENTO,
            ATENDIMENTO.IDTIPOCARTEIRA,
            TIPOCARTEIRA.DSTIPOCARTEIRA,
            ATENDIMENTO.IDSEGMENTACAO,
            SEGMENTACAO.DSSEGMENTACAO,
            ATENDIMENTOPESSOA.IDPESSOADEPARA,
            PESSOA.IDPESSOA,
            PESSOA.IDTIPOPESSOA,
            PESSOA.NMPESSOA,
            ATENDIMENTOPESSOA.IDTIPORELACIONAMENTO,
            TIPORELACIONAMENTO.NMTIPORELACIONAMENTO,
            TIPOPESSOA.SGTIPOPESSOA,
            TO_CHAR(PESSOA.DTCADASTRO, 'DD/MM/YYYY HH24:MI:SS') AS DTCADASTRO,
            TELEFONE.DSCONTATO,
            PESSOACADASTRO.NMPESSOA AS NMPESSOACADASTRO
        INTO
        	:nrDocumento:i_nrDocumento,
            :idTipoCarteira:i_idTipoCarteira,
            :dsTipoCarteira:i_dsTipoCarteira,
            :idSegmentacao:i_idSegmentacao,
            :dsSegmentacao:i_dsSegmentacao,
            :idPessoaDePara:i_idPessoaDePara,
            :idPessoa:i_idPessoa,
            :idTipoPessoa:i_idTipoPessoa,
            :nmpessoa:i_nmpessoa,
            :idTipoRelacionamento:i_idTipoRelacionamento,
            :dsTipoRelacionamento:i_dsTipoRelacionamento,
            :sgTipoPessoa:i_sgTipoPessoa,
            :dataCadastro:i_dataCadastro,
            :dsComunicacao:i_dsComunicacao,
            :nmCadastradoPor:i_nmCadastradoPor
        FROM 
            ATENDIMENTO.ATENDIMENTO ATENDIMENTO,
            APOIO.SEGMENTACAO SEGMENTACAO,
            APOIO.TIPOCARTEIRA TIPOCARTEIRA,
            ATENDIMENTO.ATENDIMENTOPESSOA ATENDIMENTOPESSOA,
            CUSTOMER.PESSOADEPARA PESSOADEPARA,
            CUSTOMER.PESSOA PESSOA,
            CUSTOMER.PESSOA PESSOACADASTRO,
            CUSTOMER.DOCUMENTO DOCUMENTO,
            CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
            CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTO,
            APOIO.TIPOPESSOA TIPOPESSOA,
            (
                SELECT 
                    PESSOACOMUNICACAO.DSCONTATO DSCONTATO,
                    PESSOACOMUNICACAO.IDPESSOA  IDPESSOA
                FROM 
                    CUSTOMER.PESSOACOMUNICACAO PESSOACOMUNICACAO,
                    APOIO.TIPOCOMUNICACAO TIPOCOMUNICACAO
                WHERE 
                    PESSOACOMUNICACAO.IDTIPOCOMUNICACAO = TIPOCOMUNICACAO.IDTIPOCOMUNICACAO
                AND UPPER(TIPOCOMUNICACAO.SGCLASSIFICACAO) = 'TELEFONE'
                --//ORDER BY 
                  --//PESSOACOMUNICACAO.NRSEQUENCIA
            ) TELEFONE
        WHERE 
            ATENDIMENTO.IDTIPOCARTEIRA = TIPOCARTEIRA.IDTIPOCARTEIRA
        AND ATENDIMENTO.IDSEGMENTACAO = SEGMENTACAO.IDSEGMENTACAO
        AND PESSOADOCUMENTO.IDPESSOA = PESSOA.IDPESSOA
        AND DOCUMENTO.IDDOCUMENTO = PESSOADOCUMENTO.IDDOCUMENTO
        AND ATENDIMENTO.IDATENDIMENTO = ATENDIMENTOPESSOA.IDATENDIMENTO
        AND ATENDIMENTOPESSOA.IDPESSOADEPARA=PESSOADEPARA.IDPESSOADEPARA
        AND PESSOADEPARA.IDPESSOA = PESSOA.IDPESSOA
        AND TIPORELACIONAMENTO.IDTIPORELACIONAMENTO = ATENDIMENTOPESSOA.IDTIPORELACIONAMENTO
        AND ATENDIMENTO.IDATENDIMENTO = :idAtendimento
        AND PESSOA.IDPESSOA = TELEFONE.IDPESSOA (+) 
        AND PESSOA.IDUSUARIOALTERACAO = PESSOACADASTRO.IDPESSOA(+)
        AND TIPOPESSOA.IDTIPOPESSOA = PESSOA.IDTIPOPESSOA
        AND ATENDIMENTOPESSOA.IDTIPORELACIONAMENTO = (SELECT IDTIPORELACIONAMENTO 
                                                        FROM ( SELECT AP.IDTIPORELACIONAMENTO 
                                                                 FROM ATENDIMENTO.ATENDIMENTOPESSOA AP
                                                                WHERE AP.IDATENDIMENTO = :idAtendimento
                                                                ORDER BY AP.IDTIPORELACIONAMENTO
                                                             )
                                                       WHERE ROWNUM < 2
                                                     )
        AND ROWNUM < 2;

    if ( !sqlca.sqlcode )
    {
        CONVIND(nrDocumento, i_nrDocumento);
        CONVIND(dsTipoCarteira, i_dsTipoCarteira);
        CONVIND(dsSegmentacao, i_dsSegmentacao);
        CONVIND(nmpessoa, i_nmpessoa);
        CONVIND(dsTipoRelacionamento, i_dsTipoRelacionamento);
        CONVIND(dataCadastro, i_dataCadastro);
        CONVIND(sgTipoPessoa, i_sgTipoPessoa);
        CONVIND(dsComunicacao, i_dsComunicacao);
        CONVIND(nmCadastradoPor, i_nmCadastradoPor);

        if ( saida )
        {
            saida->createTag("PessoaVO");
                saida->addItem("nrDocumento", (char*)nrDocumento.arr);
                saida->addItem("idTipoCarteira", idTipoCarteira);
                saida->addItem("dsTipoCarteira", (char*)dsTipoCarteira.arr);
                saida->addItem("idSegmentacao", idSegmentacao);
                saida->addItem("dsSegmentacao", (char*)dsSegmentacao.arr);
                saida->addItem("idPessoaDePara", idPessoaDePara);
                saida->addItem("idPessoa", idPessoa);
                saida->addItem("idTipoPessoa", idTipoPessoa);
                saida->addItem("nome", (char*)nmpessoa.arr);
                saida->addItem("inRspAbertura", idTipoRelacionamento);
                saida->addItem("dsTipoRelacionamento", (char*)dsTipoRelacionamento.arr);
                saida->addItem("sgTipoPessoa", (char*)sgTipoPessoa.arr);
                saida->addItem("dtCadastro", (char*)dataCadastro.arr);
                saida->addItem("dsComunicacao", (char*)dsComunicacao.arr);
                saida->addItem("nmCadastradoPor", (char*)nmCadastradoPor.arr);
            saida->closeTag();
        }

        if ( ap )
        {
            ap->idPessoa = idPessoa;
            ap->idPessoaDePara = idPessoaDePara;
            ap->inRspAbertura = idTipoRelacionamento;
            ap->idTipoPessoa = idTipoPessoa;
            sprintf(ap->nome,"%.*s",sizeof(ap->nome)-1,nmpessoa.arr);
            sprintf(ap->sgTipoPessoa,"%.*s",sizeof(ap->sgTipoPessoa)-1,sgTipoPessoa.arr);
            sprintf(ap->dtCadastro,"%.*s",sizeof(ap->dtCadastro)-1,dataCadastro.arr);
        }
    }

    ULOG_END( "proCObtemWFPessoaAtendimento()" );

    return true;
}



bool proCObtemWFPessoaAtendimentoEx( long sIdAtendimento, XMLGen * saida, AtendimentoPessoa * ap )
{
    ULOG_START( "proCObtemWFPessoaAtendimentoEx()" );

    struct sqlca sqlca;
    
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR nrDocumento[256];
        long idAtendimento = sIdAtendimento;
        int  idPessoaDePara;
        long  idPessoa;
        int  idTipoCarteira;
        VARCHAR dsTipoCarteira[256];
        int  idSegmentacao;
        VARCHAR dsSegmentacao[256];
        int  idTipoPessoa;
        VARCHAR nmpessoa[256];
        int  idTipoRelacionamento;
        VARCHAR dsTipoRelacionamento[256];
        VARCHAR dataCadastro[256];
        VARCHAR sgTipoPessoa[256];
        VARCHAR dsComunicacao[256];
        VARCHAR nmCadastradoPor[256];

        short i_nrDocumento = -1;
        short i_idPessoaDePara = -1;
        short i_idPessoa = -1;
        short i_idTipoCarteira = -1;
        short i_dsTipoCarteira = -1;
        short i_idSegmentacao = -1;
        short i_dsSegmentacao = -1;
        short i_idTipoPessoa = -1;
        short i_nmpessoa = -1;
        short i_idTipoRelacionamento = -1;
        short i_dsTipoRelacionamento = -1;
        short i_dataCadastro = -1;
        short i_sgTipoPessoa = -1;
        short i_dsComunicacao = -1;
        short i_nmCadastradoPor = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoPessoa(&sqlca);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    ULOG("idAtendimento: %ld",idAtendimento);

    EXEC SQL
        SELECT
            DOCUMENTO.NRDOCUMENTO,
            ATENDIMENTO.IDTIPOCARTEIRA,
            ATENDIMENTO.DSTIPOCARTEIRA,
            ATENDIMENTO.IDSEGMENTACAO,
            ATENDIMENTO.DSSEGMENTACAO,
            ATENDIMENTOPESSOA.IDPESSOADEPARA,
            PESSOA.IDPESSOA,
            PESSOA.IDTIPOPESSOA,
            PESSOA.NMPESSOA,
            ATENDIMENTOPESSOA.IDTIPORELACIONAMENTO,
            TIPORELACIONAMENTO.NMTIPORELACIONAMENTO,
            TIPOPESSOA.SGTIPOPESSOA,
            TO_CHAR(PESSOA.DTCADASTRO, 'DD/MM/YYYY HH24:MI:SS') AS DTCADASTRO,
            TELEFONE.DSCONTATO,
            PESSOACADASTRO.NMPESSOA AS NMPESSOACADASTRO
        INTO
        	:nrDocumento:i_nrDocumento,
            :idTipoCarteira:i_idTipoCarteira,
            :dsTipoCarteira:i_dsTipoCarteira,
            :idSegmentacao:i_idSegmentacao,
            :dsSegmentacao:i_dsSegmentacao,
            :idPessoaDePara:i_idPessoaDePara,
            :idPessoa:i_idPessoa,
            :idTipoPessoa:i_idTipoPessoa,
            :nmpessoa:i_nmpessoa,
            :idTipoRelacionamento:i_idTipoRelacionamento,
            :dsTipoRelacionamento:i_dsTipoRelacionamento,
            :sgTipoPessoa:i_sgTipoPessoa,
            :dataCadastro:i_dataCadastro,
            :dsComunicacao:i_dsComunicacao,
            :nmCadastradoPor:i_nmCadastradoPor
        FROM 
            FOHIST_OW.ATENDIMENTO ATENDIMENTO,
            FOHIST_OW.ATENDIMENTOPESSOA ATENDIMENTOPESSOA,
            CUSTOMER.PESSOADEPARA PESSOADEPARA,
            CUSTOMER.PESSOA PESSOA,
            CUSTOMER.PESSOA PESSOACADASTRO,
            CUSTOMER.DOCUMENTO DOCUMENTO,
            CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
            CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTO,
            APOIO.TIPOPESSOA TIPOPESSOA,
            (
                SELECT 
                    PESSOACOMUNICACAO.DSCONTATO DSCONTATO,
                    PESSOACOMUNICACAO.IDPESSOA  IDPESSOA
                FROM 
                    CUSTOMER.PESSOACOMUNICACAO PESSOACOMUNICACAO,
                    APOIO.TIPOCOMUNICACAO TIPOCOMUNICACAO
                WHERE 
                    PESSOACOMUNICACAO.IDTIPOCOMUNICACAO = TIPOCOMUNICACAO.IDTIPOCOMUNICACAO
                AND UPPER(TIPOCOMUNICACAO.SGCLASSIFICACAO) = 'TELEFONE'
            ) TELEFONE
        WHERE 
            PESSOADOCUMENTO.IDPESSOA = PESSOA.IDPESSOA
        AND DOCUMENTO.IDDOCUMENTO = PESSOADOCUMENTO.IDDOCUMENTO
        AND ATENDIMENTO.IDATENDIMENTO = ATENDIMENTOPESSOA.IDATENDIMENTO
        AND ATENDIMENTOPESSOA.IDPESSOADEPARA=PESSOADEPARA.IDPESSOADEPARA
        AND PESSOADEPARA.IDPESSOA = PESSOA.IDPESSOA
        AND TIPORELACIONAMENTO.IDTIPORELACIONAMENTO = ATENDIMENTOPESSOA.IDTIPORELACIONAMENTO
        AND ATENDIMENTO.IDATENDIMENTO = :idAtendimento
        AND PESSOA.IDPESSOA = TELEFONE.IDPESSOA (+) 
        AND PESSOA.IDUSUARIOALTERACAO = PESSOACADASTRO.IDPESSOA(+)
        AND TIPOPESSOA.IDTIPOPESSOA = PESSOA.IDTIPOPESSOA
        AND ATENDIMENTOPESSOA.IDTIPORELACIONAMENTO = (SELECT IDTIPORELACIONAMENTO 
                                                        FROM ( SELECT AP.IDTIPORELACIONAMENTO 
                                                                 FROM FOHIST_OW.ATENDIMENTOPESSOA AP
                                                                WHERE AP.IDATENDIMENTO = :idAtendimento
                                                                ORDER BY AP.IDTIPORELACIONAMENTO
                                                             )
                                                       WHERE ROWNUM < 2
                                                     )
        AND ROWNUM < 2;

    if ( !sqlca.sqlcode )
    {
        CONVIND(nrDocumento, i_nrDocumento);
        CONVIND(dsTipoCarteira, i_dsTipoCarteira);
        CONVIND(dsSegmentacao, i_dsSegmentacao);
        CONVIND(nmpessoa, i_nmpessoa);
        CONVIND(dsTipoRelacionamento, i_dsTipoRelacionamento);
        CONVIND(dataCadastro, i_dataCadastro);
        CONVIND(sgTipoPessoa, i_sgTipoPessoa);
        CONVIND(dsComunicacao, i_dsComunicacao);
        CONVIND(nmCadastradoPor, i_nmCadastradoPor);

        if ( saida )
        {
            saida->createTag("PessoaVO");
                saida->addItem("nrDocumento", (char*)nrDocumento.arr);
                saida->addItem("idTipoCarteira", idTipoCarteira);
                saida->addItem("dsTipoCarteira", (char*)dsTipoCarteira.arr);
                saida->addItem("idSegmentacao", idSegmentacao);
                saida->addItem("dsSegmentacao", (char*)dsSegmentacao.arr);
                saida->addItem("idPessoaDePara", idPessoaDePara);
                saida->addItem("idPessoa", idPessoa);
                saida->addItem("idTipoPessoa", idTipoPessoa);
                saida->addItem("nome", (char*)nmpessoa.arr);
                saida->addItem("inRspAbertura", idTipoRelacionamento);
                saida->addItem("dsTipoRelacionamento", (char*)dsTipoRelacionamento.arr);
                saida->addItem("sgTipoPessoa", (char*)sgTipoPessoa.arr);
                saida->addItem("dtCadastro", (char*)dataCadastro.arr);
                saida->addItem("dsComunicacao", (char*)dsComunicacao.arr);
                saida->addItem("nmCadastradoPor", (char*)nmCadastradoPor.arr);
            saida->closeTag();
        }

        if ( ap )
        {
            ap->idPessoa = idPessoa;
            ap->idPessoaDePara = idPessoaDePara;
            ap->inRspAbertura = idTipoRelacionamento;
            ap->idTipoPessoa = idTipoPessoa;
            sprintf(ap->nome,"%.*s",sizeof(ap->nome)-1,nmpessoa.arr);
            sprintf(ap->sgTipoPessoa,"%.*s",sizeof(ap->sgTipoPessoa)-1,sgTipoPessoa.arr);
            sprintf(ap->dtCadastro,"%.*s",sizeof(ap->dtCadastro)-1,dataCadastro.arr);
        }
    }

    ULOG_END( "proCObtemWFPessoaAtendimentoEx()" );

    return true;
}



int proCObtemWFIdTipoRelacionamento(long sIdAtendimento)
{
    ULOG_START( "proCObtemWFIdTipoRelacionamento()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        long idAtendimento = sIdAtendimento;
        int idTipoRelacionamento;
        short i_idTipoRelacionamento;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoPessoa(&sqlca);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    ULOG("idAtendimento: %ld",idAtendimento);

    EXEC SQL
        SELECT
            IDTIPORELACIONAMENTO
        INTO
            :idTipoRelacionamento:i_idTipoRelacionamento
        FROM
        (
            SELECT
                IDTIPORELACIONAMENTO
            FROM
                ATENDIMENTO.ATENDIMENTOPESSOA
            WHERE
                IDATENDIMENTO = :idAtendimento
            ORDER BY
                IDTIPORELACIONAMENTO
        )
        WHERE ROWNUM < 2;

    ULOG("sqlcode = %d",sqlca.sqlcode);
    if ( sqlca.sqlcode )
    {
        idTipoRelacionamento = -1;
    }

    ULOG_END( "proCObtemWFIdTipoRelacionamento()" );

    return idTipoRelacionamento;
}



int proCObtemWFIdTipoRelacionamentoEx(long sIdAtendimento)
{
    ULOG_START( "proCObtemWFIdTipoRelacionamentoEx()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        long idAtendimento = sIdAtendimento;
        int idTipoRelacionamento;
        short i_idTipoRelacionamento;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoPessoa(&sqlca);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    ULOG("idAtendimento: %ld",idAtendimento);

    EXEC SQL
        SELECT
            IDTIPORELACIONAMENTO
        INTO
            :idTipoRelacionamento:i_idTipoRelacionamento
        FROM
        (
            SELECT
                IDTIPORELACIONAMENTO
            FROM
                FOHIST_OW.ATENDIMENTOPESSOA
            WHERE
                IDATENDIMENTO = :idAtendimento
            ORDER BY
                IDTIPORELACIONAMENTO
        )
        WHERE ROWNUM < 2;

    ULOG("sqlcode = %d",sqlca.sqlcode);
    if ( sqlca.sqlcode )
    {
        idTipoRelacionamento = -1;
    }

    ULOG_END( "proCObtemWFIdTipoRelacionamentoEx()" );

    return idTipoRelacionamento;
}



bool proCObtemWFDocumentoPessoa(int sIdPessoa, XMLGen* saida)
{
	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		long idPessoa = sIdPessoa;
		int  idTipoDocumento;
		VARCHAR	sgTipoDocumento[256];
		VARCHAR	nrDocumento[256];
		
		short i_idTipoDocumento;
		short i_sgTipoDocumento;
		short i_nrDocumento;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoPessoa(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;


    /* @Marcelo Retirar B01
	    EXEC SQL DECLARE consultaPessoaDocumento CURSOR FOR
	    SELECT 
		    IDTIPODOCUMENTO, 
		    SGTIPODOCUMENTO, 
		    NRDOCUMENTO
	    FROM 
		    CUSTOMER.PESSOADOCUMENTOB01
	    WHERE 
		    IDPESSOA = :idPessoa
	    ORDER BY 
		    IDTIPODOCUMENTO;
    */
	
	EXEC SQL DECLARE consultaPessoaDocumento CURSOR FOR
        SELECT
            TIPODOCUMENTO.IDTIPODOCUMENTO, 
            TIPODOCUMENTO.SGTIPODOCUMENTO, 
            DOCUMENTO.NRDOCUMENTO
        FROM
            CUSTOMER.PESSOA          PESSOA,
            APOIO.TIPODOCUMENTO      TIPODOCUMENTO,
            CUSTOMER.DOCUMENTO       DOCUMENTO,
            CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO
        WHERE
            TIPODOCUMENTO.IDTIPODOCUMENTO = DOCUMENTO.IDTIPODOCUMENTO
        AND
            DOCUMENTO.IDDOCUMENTO = PESSOADOCUMENTO.IDDOCUMENTO
        AND
            PESSOADOCUMENTO.IDPESSOA = PESSOA.IDPESSOA	
        AND	
            PESSOA.IDPESSOA = :idPessoa
        ORDER BY 
            TIPODOCUMENTO.IDTIPODOCUMENTO;

	EXEC SQL OPEN consultaPessoaDocumento;


	while (true)
	{
		EXEC SQL FETCH consultaPessoaDocumento INTO
			:idTipoDocumento:i_idTipoDocumento,
			:sgTipoDocumento:i_sgTipoDocumento,
			:nrDocumento:i_nrDocumento;

		CONVIND(sgTipoDocumento, i_sgTipoDocumento);
		CONVIND(nrDocumento, i_nrDocumento);
			
		saida->createTag("DocumentoVO");
	
			saida->addItem("idTipoDocumento", idTipoDocumento);
			saida->addItem("tipoDocumento", (char*)sgTipoDocumento.arr);
			saida->addItem("nrDocumento", (char*)nrDocumento.arr);
			
		saida->closeTag();

	}

	EXEC SQL CLOSE consultaPessoaDocumento;

	return true;
}

bool proCObtemWFEnderecoPessoa(int sIdPessoa, XMLGen* saida)
{
	struct sqlca sqlca;
   	
	EXEC SQL BEGIN DECLARE SECTION;

		long idPessoa = sIdPessoa;
		VARCHAR	nmMunicipio[256];
		VARCHAR	nmBairro[256];
		VARCHAR	dsEnderecoCompleto[256];
		VARCHAR	sgUf[256];
		VARCHAR	nrCep[256];
		
		short i_nmMunicipio;
		short i_nmBairro;
		short i_dsEnderecoCompleto;
		short i_sgUf;
		short i_nrCep;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoPessoa(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;


/*	SELECT 
		NMMUNICIPIO, 
		NMBAIRRO, 
		CONCAT(CONCAT(CONCAT(CONCAT(NMTIPOLOGRADOURO, ' ') ,NMLOGRADOURO), ', '), TO_CHAR(NRENDERECO)) AS DSENDERECOCOMPLETO, 
		SGUF, 
		NRCEP
	FROM 
		CUSTOMER.PESSOAENDERECOBZEROUM
	WHERE 
		IDPESSOA = :idPessoa
	ORDER BY 
		IDTIPOENDERECO;*/

	EXEC SQL DECLARE consultaPessoaEndereco CURSOR FOR
	SELECT 
		NMMUNICIPIO, 
		NMBAIRRO, 
		CONCAT(CONCAT(CONCAT(CONCAT(NMTIPOLOGRADOURO, ' ') ,NMLOGRADOURO), ', '), TO_CHAR(NRENDERECO)) AS DSENDERECOCOMPLETO, 
		UF.SGUF, 
		NRCEP
	FROM 
		CUSTOMER.PESSOAENDERECO PESSOAENDERECO,
		APOIO.UF		UF 
	WHERE 
		  PESSOAENDERECO.IDUF=UF.IDUF
	AND
		  IDPESSOA = :idPessoa
	ORDER BY 
		IDTIPOENDERECO;	


	EXEC SQL OPEN consultaPessoaEndereco;


	while (true)
	{
		EXEC SQL FETCH consultaPessoaEndereco INTO
			:nmMunicipio:i_nmMunicipio,
			:nmBairro:i_nmBairro,
			:dsEnderecoCompleto:i_dsEnderecoCompleto,
			:sgUf:i_sgUf,
			:nrCep:i_nrCep;

		CONVIND(nmMunicipio, i_nmMunicipio);
		CONVIND(nmBairro, i_nmBairro);
		CONVIND(dsEnderecoCompleto, i_dsEnderecoCompleto);
		CONVIND(sgUf, i_sgUf);
		CONVIND(nrCep, i_nrCep);
			
		saida->createTag("ns4:EnderecoVO");
	
			saida->addItem("nmMunicipio", (char*)nmMunicipio.arr);
			saida->addItem("nmBairro", (char*)nmBairro.arr);
			saida->addItem("dsEnderecoCompleto", (char*)dsEnderecoCompleto.arr);
			saida->addItem("nrCep", (char*)nrCep.arr);
			saida->createTag("ns4:UFVO");
				saida->addItem("sgUf", (char*)sgUf.arr);
			saida->closeTag();
			
		saida->closeTag();

	}

	EXEC SQL CLOSE consultaPessoaEndereco;

	return true;
}

void sql_error_WFAtendimentoPessoa(sqlca*sqlca)
{
	throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
