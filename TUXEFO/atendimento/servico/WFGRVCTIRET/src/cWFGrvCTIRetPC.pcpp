
#include <string>
using namespace std;

#include "../include/cWFGrvCTIRetPC.h"

bool cWFGrvCTIPC::verificaItem( stVariaveisGrvCTI *_dadosEntradaPC )
{

   ULOG_START("cWFGrvCTIPC::verificaItem()");

	struct sqlca sqlca;

   EXEC SQL BEGIN DECLARE SECTION;

		int idretornowfctiAux =  atoi( _dadosEntradaPC->idretornowfcti );
      int operacao = atoi( _dadosEntradaPC->operacao );
      int inPadrao = atoi( _dadosEntradaPC->operacao );

      int linhas = 0;

   EXEC SQL END DECLARE SECTION;

   ULOG("idretornowfctiAux = '%d'",idretornowfctiAux);
   ULOG("operacao          = '%d'",operacao);
   ULOG("inPadrao          = '%d'",inPadrao);

   EXEC SQL WHENEVER SQLERROR  DO sql_error_WFRetornoCTI( &sqlca );

   if ( operacao == 0 )
      EXEC SQL SELECT count(1) INTO :linhas FROM workflow.retornowfcti WHERE inpadrao = 1;
   else
      EXEC SQL SELECT count(1) INTO :linhas FROM workflow.retornowfcti WHERE inpadrao = 1 AND idretornowfcti != :idretornowfctiAux;

   ULOG("sqlca.sqlcode = '%d'",sqlca.sqlcode);
   
   ULOG("linhas = '%d'",linhas);

   ULOG_END("cWFGrvCTIPC::verificaItem()");

   if ( linhas > 0 )
      return true;
   else
      return false;



}



bool cWFGrvCTIPC::InsertWFRet( char *Msg )
{
    ULOG_START("cWFGrvCTIPC::InsertWFRet()");
    INITIALIZE_SQL;
    EXEC SQL BEGIN DECLARE SECTION;
        int idretornowfcti;
        VARCHAR sgretornowfcti[255];
        VARCHAR sgretornowfctiComp[255];
        VARCHAR dsretornowfcti[255];
        VARCHAR sgstatus[1];
        int inpadrao;
        int idusuarioalteracao;
        short i_sgretornowfctiComp = -1;
    EXEC SQL END DECLARE SECTION;

    if(!rwfcti.sgretornowfcti.len||!rwfcti.dsretornowfcti.len||!rwfcti.sgstatus.len||
        rwfcti.inpadrao<0)
        throw new TuxBasicSvcException("00E9999","Invalid field value");

    EXEC SQL SELECT workflow.RetornoWFCTISQ.nextval INTO :idretornowfcti FROM DUAL;

    FROM_STR_TO_VARCHAR(sgretornowfcti,rwfcti.sgretornowfcti);
    FROM_STR_TO_VARCHAR(sgretornowfcti,rwfcti.sgretornowfcti);
    FROM_STR_TO_VARCHAR(dsretornowfcti,rwfcti.dsretornowfcti);
    FROM_STR_TO_VARCHAR(sgstatus,rwfcti.sgstatus);
    inpadrao=rwfcti.inpadrao;
    idusuarioalteracao=rwfcti.idusuarioalteracao;

    EXEC SQL SELECT UPPER(:sgretornowfcti) INTO :sgretornowfcti FROM DUAL;

    EXEC SQL SELECT UPPER(sgretornowfcti) INTO :sgretornowfctiComp:i_sgretornowfctiComp 
               FROM workflow.RetornoWFCTI 
              WHERE sgretornowfcti = :sgretornowfcti;

    CONVIND(sgretornowfctiComp,i_sgretornowfctiComp);

    if ( *(char*)sgretornowfctiComp.arr )
    {
        sprintf( Msg,"Sigla '%s' ja existe na tabela RetornoWFCTI",(char*)sgretornowfctiComp.arr );
        return false;
    }

   EXEC SQL INSERT INTO workflow.RetornoWFCTI
     (idretornowfcti,sgretornowfcti,dsretornowfcti,sgstatus,inpadrao,
     idusuarioalteracao,dtultimaalteracao)
     VALUES
     (:idretornowfcti,:sgretornowfcti,:dsretornowfcti,
     :sgstatus,:inpadrao,:idusuarioalteracao,SYSDATE);
   
   rwfcti.idretornowfcti = idretornowfcti;
   
   ULOG_END("cWFGrvCTIPC::InsertWFRet()");

   return true;

}



bool cWFGrvCTIPC::Update( char *Msg )
{
    ULOG_START("cWFGrvCTIPC::Update()");
    
    INITIALIZE_SQL;
    EXEC SQL BEGIN DECLARE SECTION;
        int idretornowfcti;
        
        VARCHAR sgretornowfctiTeste[255];
        VARCHAR dsretornowfctiTeste[255];
        short i_sgretornowfctiTeste = -1;
        short i_dsretornowfctiTeste = -1;

        VARCHAR sgretornowfcti[255];
        VARCHAR dsretornowfcti[255];
        VARCHAR sgstatus[1];
        int inpadrao;
        int idusuarioalteracao;

    EXEC SQL END DECLARE SECTION;
    if(!rwfcti.sgretornowfcti.len||!rwfcti.dsretornowfcti.len||!rwfcti.sgstatus.len||
        rwfcti.inpadrao<0||rwfcti.idretornowfcti<0)
        throw new TuxBasicSvcException("09E9999","Invalid field value");

    FROM_STR_TO_VARCHAR(sgretornowfcti,rwfcti.sgretornowfcti);
    FROM_STR_TO_VARCHAR(dsretornowfcti,rwfcti.dsretornowfcti);
	
	CONV(sgretornowfcti)
	CONV(dsretornowfcti)

    FROM_STR_TO_VARCHAR(sgstatus,rwfcti.sgstatus);
    inpadrao=rwfcti.inpadrao;
    idusuarioalteracao=rwfcti.idusuarioalteracao;
    idretornowfcti=rwfcti.idretornowfcti;

	EXEC SQL DECLARE 
		testeUpdate
	CURSOR FOR
		SELECT 
			sgretornowfcti,
			dsretornowfcti
		FROM 
			workflow.RetornoWFCTI 
		WHERE
            (UPPER(sgretornowfcti) = UPPER(:sgretornowfcti)
			 OR UPPER(dsretornowfcti) = UPPER(:dsretornowfcti))
		AND
            idretornowfcti != :idretornowfcti;

	EXEC SQL OPEN testeUpdate;

	EXEC SQL WHENEVER NOT FOUND DO break;

	while (true)
	{
		
		EXEC SQL FETCH testeUpdate INTO	:sgretornowfctiTeste:i_sgretornowfctiTeste,
										:dsretornowfctiTeste:i_dsretornowfctiTeste;


		CONVIND( sgretornowfctiTeste,i_sgretornowfctiTeste )
		CONVIND( dsretornowfctiTeste,i_dsretornowfctiTeste )

		if (strcmp((char*)sgretornowfctiTeste.arr,(char*)sgretornowfcti.arr) == 0)
			sprintf( Msg,"Sigla '%s' ja existe na tabela RetornoWFCTI. ",(char*)sgretornowfctiTeste.arr );

		if (strcmp((char*)dsretornowfctiTeste.arr,(char*)dsretornowfcti.arr) == 0)
			sprintf( Msg,"%s Descrição '%s' ja existe na tabela RetornoWFCTI. ", Msg, (char*)dsretornowfcti.arr );


		if (strlen(Msg) > 0)
			return false;

	}

	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL WHENEVER SQLERROR  DO sql_error_WFRetornoCTI( &sqlca );

    EXEC SQL 
		UPDATE 
			workflow.RetornoWFCTI 
		SET
			sgretornowfcti = :sgretornowfcti,
			dsretornowfcti=:dsretornowfcti,
			sgstatus=:sgstatus,
			inpadrao=:inpadrao,
			idusuarioalteracao=:idusuarioalteracao,
			dtultimaalteracao=SYSDATE
		WHERE 
			idretornowfcti=:idretornowfcti;

   rwfcti.idretornowfcti = idretornowfcti;

   ULOG_END("cWFGrvCTIPC::Update()");
   
   return true;

}



void cWFGrvCTIPC::DeleteByIDWFGRet( void )
{
   ULOG_START("cWFGrvCTIPC::DeleteByIDWFGRet()");
   
	INITIALIZE_SQL;
	EXEC SQL BEGIN DECLARE SECTION;
		int idretornowfcti;
	EXEC SQL END DECLARE SECTION;
	if(rwfcti.idretornowfcti<0)
		throw new TuxBasicSvcException("00E9999","Invalid idGrupoRetornoWFCTI value");

	idretornowfcti=rwfcti.idretornowfcti;

   EXEC SQL WHENEVER SQLERROR  DO sql_error_WFRetornoCTI( &sqlca );
	EXEC SQL DELETE FROM workflow.GrupoRetornoWFCTI WHERE idretornowfcti=:idretornowfcti;

   rwfcti.idretornowfcti = idretornowfcti;
   
   ULOG_END("cWFGrvCTIPC::DeleteByIDWFGRet()");

	return;

}



void cWFGrvCTIPC::DeleteWFRet( void )
{
    ULOG_START("cWFGrvCTIPC::DeleteWFRet()");
    
    INITIALIZE_SQL;
    EXEC SQL BEGIN DECLARE SECTION;
        int idretornowfcti;
    EXEC SQL END DECLARE SECTION;
    if(rwfcti.idretornowfcti<0)
        throw new TuxBasicSvcException("00E9999","Invalid idRetornoWFCTI value");
    idretornowfcti=rwfcti.idretornowfcti;

    EXEC SQL DELETE FROM workflow.RetornoWFCTI WHERE idretornowfcti=:idretornowfcti;

    rwfcti.idretornowfcti = idretornowfcti;
   
    ULOG_END("cWFGrvCTIPC::DeleteWFRet()");

    return;

}



void cWFGrvCTIPC::InsertWFGRet( void )
{
   ULOG_START("cWFGrvCTIPC::InsertWFGRet()");
   
	INITIALIZE_SQL;
	EXEC SQL BEGIN DECLARE SECTION;
		int idgruporetornowfcti;
		int idretornowfcti;
		int idusuariogrupo;
		int idusuarioalteracao;
      int idgrupo;
	EXEC SQL END DECLARE SECTION;

	if(rwfcti.idretornowfcti<0||rwfcti.idusuariogrupo<0)
		throw new TuxBasicSvcException("00E9999","Invalid field value");

	EXEC SQL SELECT workflow.GrupoRetornoWFCTISQ.nextval INTO :idgruporetornowfcti FROM DUAL;

	idretornowfcti=rwfcti.idretornowfcti;
	idusuariogrupo=rwfcti.idusuariogrupo;
   idgrupo = rwfcti.idgrupo;
	idusuarioalteracao=rwfcti.idusuarioalteracao;

	EXEC SQL INSERT INTO workflow.GrupoRetornoWFCTI
		(idgruporetornowfcti,idretornowfcti,idgrupo,idusuarioalteracao,dtultimaalteracao)
		VALUES
		(:idgruporetornowfcti,:idretornowfcti,:idgrupo,:idusuarioalteracao,SYSDATE);
//		(:idgruporetornowfcti,:idretornowfcti,:idusuariogrupo,:idusuarioalteracao,SYSDATE);

   rwfcti.idgruporetornowfcti = idgruporetornowfcti;
   
   ULOG_END("cWFGrvCTIPC::InsertWFGRet()");

	return;

}



/*
 *---------------------------------------------------------
 * Metodos extraidos do Servico PSQGRPCTI
 *---------------------------------------------------------
 */
void cWFGrvCTIPC::SelectGroupsByRetWFCTI( stVariaveisGrvCTI * _dadosEntradaPC, Collection * _ResultadoPC )
{
   ULOG_START("cWFGrvCTIPC::SelectGroupsByRetWFCTI()");
   
	struct sqlca sqlca;
   
   int inpadraoWrk = atoi(_dadosEntradaPC->inpadrao);
   stVariaveisGrvCTI *pCTI;

	EXEC SQL BEGIN DECLARE SECTION;

		int idretornowfcti = atoi(_dadosEntradaPC->idretornowfcti);

      int     idgrupo;
      VARCHAR nmgrupo[256];

      short i_nmgrupo;

	EXEC SQL END DECLARE SECTION;

   EXEC SQL WHENEVER SQLERROR  DO sql_error_WFRetornoCTI( &sqlca );

	EXEC SQL WHENEVER NOT FOUND DO break;

	if ( idretornowfcti >= 0 )
	{


		if ( inpadraoWrk == 1 )
		{
			SelectGroupsPdrCam( _dadosEntradaPC,_ResultadoPC );
		}
		else
		{
			SelectGroupsNPdCam( _dadosEntradaPC,_ResultadoPC );
		}
		
		EXEC SQL DECLARE 
			crSelectRGrpU 
		CURSOR FOR
			SELECT 
				a.idgrupo,
				a.nmgrupo
			FROM 
				acesso.grupo a,
				workflow.gruporetornowfcti b
			WHERE 
				a.idgrupo = b.idgrupo AND 
				b.idretornowfcti = :idretornowfcti
			GROUP BY 
				a.idgrupo,
				nmgrupo;

		EXEC SQL OPEN crSelectRGrpU;
		
		for(;;)
		{
			EXEC SQL FETCH crSelectRGrpU INTO :idgrupo,
                                           :nmgrupo:i_nmgrupo;
		
			CONVIND( nmgrupo,i_nmgrupo );
         pCTI = new stVariaveisGrvCTI;

         if ( pCTI )
         {
            memset( pCTI,0x0,sizeof(pCTI) );
            ULOG("idgrupo = '%d'",idgrupo);
            ULOG("nmgrupo = '%s'",(char*)nmgrupo.arr);

            sprintf( pCTI->idGrupo,"%d",idgrupo );
            strcpy( pCTI->flagSelecionado,"1" );
            
            if ( i_nmgrupo >= 0 )
               strcpy( pCTI->nmgrupo,(char*)nmgrupo.arr );
            else
               pCTI->nmgrupo[0] = 0x0;

            _ResultadoPC->AddItem( (void*) pCTI );
         }
         else
            ULOG("ERRO: Nao Consegue Alocar Memoria para os Dados.");

		}

		EXEC SQL CLOSE crSelectRGrpU;

	}
	else
	{
		if ( inpadraoWrk > 0 )
		{
			SelectGroupsPdrTodos( _dadosEntradaPC,_ResultadoPC );
		}
		else
		{
			SelectGroupsNPdTodos( _dadosEntradaPC,_ResultadoPC );
		}
	}

	return;
	
	ULOG_END("cWFGrvCTIPC::SelectGroupsByRetWFCTI()");

}

/**
	Obtem os grupos disponiveis da para a campanha indicada.
	Esse processo não leva em conta a ligação do grupo em outras campanhas.
*/
void cWFGrvCTIPC::SelectGroupsPdrCam( stVariaveisGrvCTI * _dadosEntradaPC, Collection * _ResultadoPC )
{
   ULOG_START("cWFGrvCTIPC::SelectGroupsPdrCam()");
	struct sqlca sqlca;

   stVariaveisGrvCTI *pCTI;

	ULOG("Pesquisa InBox - Retorno CTI -> Obtendo Grupos disponiveis para campanha indicada inpadrao = 1 -> idretornowfcti >= 0.");

	EXEC SQL BEGIN DECLARE SECTION;

		int idretornowfcti = atoi(_dadosEntradaPC->idretornowfcti);

      int idgrupo;
      VARCHAR nmgrupo[256];

      short i_nmgrupo;

	EXEC SQL END DECLARE SECTION;

   EXEC SQL WHENEVER SQLERROR  DO sql_error_WFRetornoCTI( &sqlca );
	EXEC SQL DECLARE 
		crSelectRGrp 
	CURSOR FOR
		SELECT 
			idgrupo,
			nmgrupo 
		FROM 
			acesso.grupo
		WHERE 
			idGrupo NOT IN (
						SELECT 
							a.idgrupo
						FROM 
							acesso.grupo a,
							workflow.gruporetornowfcti b
						WHERE 
							a.idgrupo=b.idgrupo AND 
							a.idgrupo=acesso.grupo.idgrupo AND 
							b.idretornowfcti = :idretornowfcti
					)
		GROUP BY 
			idgrupo,
			nmgrupo
		ORDER BY
			nmGrupo;

		EXEC SQL OPEN crSelectRGrp;

      ULOG("sqlca.sqlcode = '%d'",sqlca.sqlcode);

		for(;;)
		{
			EXEC SQL FETCH crSelectRGrp INTO :idgrupo,
                                          :nmgrupo:i_nmgrupo;

			CONVIND( nmgrupo,i_nmgrupo );

         pCTI = new stVariaveisGrvCTI;

         if ( pCTI )
         {
            memset( pCTI,0x0,sizeof(pCTI) );
            ULOG("idgrupo = '%d'",idgrupo);
            ULOG("nmgrupo = '%s'",(char*)nmgrupo.arr);

            sprintf( pCTI->idGrupo,"%d",idgrupo );
            strcpy( pCTI->flagSelecionado,"0" );
            
            if ( i_nmgrupo >= 0 )
               strcpy( pCTI->nmgrupo,(char*)nmgrupo.arr );
            else
               pCTI->nmgrupo[0] = 0x0;

            _ResultadoPC->AddItem( (void*) pCTI );
         }
         else
            ULOG("ERRO: Nao Consegue Alocar Memoria para os Dados.");

		}

		EXEC SQL CLOSE crSelectRGrp;

	ULOG_END("cWFGrvCTIPC::SelectGroupsPdrCam()");

}


/**
	Obtem os grupos disponiveis da para a campanha indicada.
	Esse processo leva em conta a ligação do grupo em outras campanhas.
*/
void cWFGrvCTIPC::SelectGroupsNPdCam( stVariaveisGrvCTI * _dadosEntradaPC, Collection * _ResultadoPC )
{
   ULOG_START("cWFGrvCTIPC::SelectGroupsNPdCam()");
   
	struct sqlca sqlca;

   stVariaveisGrvCTI *pCTI;

	ULOG("Pesquisa InBox - Retorno CTI -> Obtendo Grupos disponiveis para campanha indicada inpadrao = 0 -> idretornowfcti >= 0.");

	EXEC SQL BEGIN DECLARE SECTION;

		int idretornowfcti = atoi(_dadosEntradaPC->idretornowfcti);

      int     idgrupo;
      VARCHAR nmgrupo[256];

      short i_nmgrupo;

	EXEC SQL END DECLARE SECTION;

   EXEC SQL WHENEVER SQLERROR  DO sql_error_WFRetornoCTI( &sqlca );
	EXEC SQL DECLARE 
		crSelectRGrpNP
	CURSOR FOR
		SELECT 
			idgrupo,
			nmgrupo 
		FROM 
			acesso.grupo
		WHERE 
			idGrupo NOT IN
					(
						SELECT 
							a.idgrupo
						FROM 
							acesso.grupo a,
							workflow.gruporetornowfcti b,
							workflow.RetornoWFCTI c
						WHERE 
							a.idgrupo = b.idgrupo AND 
							a.idgrupo = a.idgrupo AND 
							c.idRetornoWFCTI = b.idRetornoWFCTI AND 
							c.inPadrao = 0
					)
		GROUP BY 
			idgrupo,
			nmgrupo;

		EXEC SQL OPEN crSelectRGrpNP;

      ULOG("sqlca.sqlcode = '%d'",sqlca.sqlcode);

		for(;;)
		{
			EXEC SQL FETCH crSelectRGrpNP INTO :idgrupo,
                                          :nmgrupo:i_nmgrupo;

			CONVIND( nmgrupo,i_nmgrupo );

         pCTI = new stVariaveisGrvCTI;

         if ( pCTI )
         {
            memset( pCTI,0x0,sizeof(pCTI) );
            ULOG("idgrupo = '%d'",idgrupo);
            ULOG("nmgrupo = '%s'",(char*)nmgrupo.arr);

            sprintf( pCTI->idGrupo,"%d",idgrupo );
            strcpy( pCTI->flagSelecionado,"0" );
            
            if ( i_nmgrupo >= 0 )
               strcpy( pCTI->nmgrupo,(char*)nmgrupo.arr );
            else
               pCTI->nmgrupo[0] = 0x0;

            _ResultadoPC->AddItem( (void*) pCTI );
         }
         else
            ULOG("ERRO: Nao Consegue Alocar Memoria para os Dados.");

		}

		EXEC SQL CLOSE crSelectRGrpNP;

	ULOG_START("cWFGrvCTIPC::SelectGroupsNPdCam()");

}

/**
	Seleciona todos os grupos do sistema.
*/
void cWFGrvCTIPC::SelectGroupsPdrTodos( stVariaveisGrvCTI * _dadosEntradaPC, Collection * _ResultadoPC )
{
   ULOG_START("cWFGrvCTIPC::SelectGroupsPdrTodos()");
   
	struct sqlca sqlca;

   stVariaveisGrvCTI *pCTI;

	ULOG("Pesquisa InBox - Retorno CTI -> Obtendo todos os grupos do sistema.");

	EXEC SQL BEGIN DECLARE SECTION;

      int     idgrupo;
      VARCHAR nmgrupo[256];

      short i_nmgrupo;

	EXEC SQL END DECLARE SECTION;

   EXEC SQL WHENEVER SQLERROR  DO sql_error_WFRetornoCTI( &sqlca );
	EXEC SQL DECLARE 
		crTodosGrupos1
	CURSOR FOR
		SELECT 
			a.idgrupo,
			a.nmgrupo
		FROM 
			acesso.grupo a
		ORDER BY
			nmgrupo;

		EXEC SQL OPEN crTodosGrupos1;


   ULOG("sqlca.sqlcode = '%d'",sqlca.sqlcode);

		for(;;)
		{
			EXEC SQL FETCH crTodosGrupos1 INTO :idgrupo,
                                            :nmgrupo:i_nmgrupo;

			CONVIND( nmgrupo,i_nmgrupo );

         pCTI = new stVariaveisGrvCTI;

         if ( pCTI )
         {
            memset( pCTI,0x0,sizeof(pCTI) );
            ULOG("idgrupo = '%d'",idgrupo);
            ULOG("nmgrupo = '%s'",(char*)nmgrupo.arr);

            sprintf( pCTI->idGrupo,"%d",idgrupo );
            strcpy( pCTI->flagSelecionado,"0" );
            
            if ( i_nmgrupo >= 0 )
               strcpy( pCTI->nmgrupo,(char*)nmgrupo.arr );
            else
               pCTI->nmgrupo[0] = 0x0;

            _ResultadoPC->AddItem( (void*) pCTI );
         }
         else
            ULOG("ERRO: Nao Consegue Alocar Memoria para os Dados.");

		}

		EXEC SQL CLOSE crTodosGrupos1;
		
      ULOG_START("cWFGrvCTIPC::SelectGroupsPdrTodos()");

}

/**
	Seleciona todos os grupos que não possuem nenhum tipo de ligação com campanhas não padrão.
*/
void cWFGrvCTIPC::SelectGroupsNPdTodos( stVariaveisGrvCTI * _dadosEntradaPC, Collection * _ResultadoPC )
{
   
   ULOG_START("cWFGrvCTIPC::SelectGroupsNPdTodos()");

	struct sqlca sqlca;

   stVariaveisGrvCTI *pCTI;

	ULOG("Pesquisa InBox - Retorno CTI -> Obtendo Grupos que nao possuem ligacao com campanhas.");

	EXEC SQL BEGIN DECLARE SECTION;

      int idgrupo;
      VARCHAR nmgrupo[256];

      short i_nmgrupo;

	EXEC SQL END DECLARE SECTION;

   EXEC SQL WHENEVER SQLERROR  DO sql_error_WFRetornoCTI( &sqlca );

	EXEC SQL DECLARE 
		crTodosGrupos0
	CURSOR FOR
		SELECT 
			idGrupo, 
			nmGrupo 
		FROM  
			acesso.Grupo
		WHERE
			idGrupo NOT IN (
							SELECT 
					 			a.idgrupo
							FROM 
					 	  		acesso.grupo a,
								workflow.gruporetornowfcti b,
								workflow.RetornoWFCTI c
							WHERE 
					 			a.idgrupo = b.idgrupo AND 
								c.idRetornoWFCTI = b.idRetornoWFCTI AND 
								c.inPadrao = 0
							GROUP BY 
					  			a.idgrupo,
								nmgrupo
						   )
		ORDER BY
			nmGrupo;

      EXEC SQL OPEN crTodosGrupos0;


   ULOG("sqlca.sqlcode = '%d'",sqlca.sqlcode);

		for(;;)
		{
			EXEC SQL FETCH crTodosGrupos0 INTO :idgrupo,
                                            :nmgrupo:i_nmgrupo;

			CONVIND( nmgrupo,i_nmgrupo );

         pCTI = new stVariaveisGrvCTI;

         if ( pCTI != NULL )
         {
            memset( pCTI,0x0,sizeof(pCTI) );
            ULOG("idgrupo = '%d'",idgrupo);
            ULOG("nmgrupo = '%s'",(char*)nmgrupo.arr);

            sprintf( pCTI->idGrupo,"%d",idgrupo );
            strcpy( pCTI->flagSelecionado,"0" );
            
            if ( i_nmgrupo >= 0 )
               strcpy( pCTI->nmgrupo,(char*)nmgrupo.arr );
            else
               pCTI->nmgrupo[0] = 0x0;

            _ResultadoPC->AddItem( (void*) pCTI );
         }
         else
            ULOG("ERRO: Nao Consegue Alocar Memoria para os Dados.");

		}

	EXEC SQL CLOSE crTodosGrupos0;

	ULOG_END("cWFGrvCTIPC::SelectGroupsNPdTodos()");

}




void cWFGrvCTIPC::sql_error_WFRetornoCTI( sqlca * sqlca )
{
	ULOGE("Ocorreu um erro na consulta de Retorno CTI.");
	throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
