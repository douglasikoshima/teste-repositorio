/**
 * @author  Renato Teixeira
 * @version $Revision: 1.1.2.2.6.3 $
 * @CVS     $Author: a5114878 $ - $Date: 2013/02/06 12:36:43 $
 **/

#ifdef WIN32
#pragma warning(disable:4786)
#endif

#include <string>

using namespace std;

#include <tuxfw.h> 
#include "../include/cApoio.h" 
#include "../include/cRegPalitagemPC.h"
#include "../../../commons/msgPadrao.h"

EXEC SQL BEGIN DECLARE SECTION;

#include "../../Atendimento/include/stWFAtendimento.h"

EXEC SQL END DECLARE SECTION;

EXEC SQL BEGIN DECLARE SECTION; 
   #define TAM_MAX_BLC_ORA     25 
   #define NRO_MAX_REG_ORA     10 
   #define TAM_MAX_NR_DOCUMENTO 90 // verifiquei na base o maior tamanho é 81 
EXEC SQL END DECLARE SECTION; 

void SqlError( sqlca * sqlca );

/**
    Construtor padrão da classe.
*/
cRegPalitagemPC::cRegPalitagemPC(st_DadosRegPalitagem* origem)
{
    dados = origem;
}

/**
    Retorna a data atual do banco de dados para ser usada como parametro das demais chamadas.
*/
void cRegPalitagemPC::dataAtual(char* data)
{
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR dataAtual[32]; 
        short idataAtual = -1; 
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegPalitagemPC(&sqlca);

    EXEC SQL 
        SELECT
            TO_CHAR(SYSDATE, 'DD/MM/YYYY HH24:MI:SS'), 
        INTO
            :dataAtual:idataAtual
        FROM
            DUAL;

    CONVIND(dataAtual,idataAtual); 

    strcpy(data,(char*)dataAtual.arr); 
}

bool cRegPalitagemPC::ValidaPessoaDePara( const int idPessoaDeParaPrm )
{
    ULOG_START("cRegPalitagemPC::ValidaPessoaDePara()");

    EXEC SQL BEGIN DECLARE SECTION;

       const int idPessoaDePara = idPessoaDeParaPrm;
       int iTotReg = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegPalitagemPC(&sqlca);

    ULOG("Consultando idPessoaDePara [%d]", idPessoaDePara );

    EXEC SQL 
        SELECT
            COUNT(1)
        INTO
            :iTotReg
        FROM
           CUSTOMER.PESSOADEPARA
        WHERE
           IDPESSOADEPARA = :idPessoaDePara;

    ULOG("Dados obtidos - iTotReg = [%d]", iTotReg );

    ULOG_END("cRegPalitagemPC::ValidaPessoaDePara()");

    return iTotReg > 0 ? true : false;
}

// SM324--DPR--DEZ/2006--Cassio
// Funcionalidade "quebra-galho" do DPR.
// Em tempo:
//  Como o DPR não estava enviando dados de INSERTs de tabelas customer 
//  (pessoa,pessoadepara,pessoalinhahistorico) agora a cada abertura de processo 
//  é enviado ao DPR um XML "fake" indicativo de um INSERT nestas tabelas.
//  Esta funcionalidade foi executada a pedido do Tiago e Borelli da área
//  do Tibco Indra.
//
void cRegPalitagemPC::AtualizarDadosPessoaLinhaHistorico(long _idPessoaLinhaHistorico,XMLDPR *xmlDpr)
{
    ULOG_START("cRegPalitagemPC::AtualizarDadosPessoaLinhaHistorico()");

    PessoaLinhaHistoricoDPR pessoaLinhaHistoricoDPR;

    EXEC SQL BEGIN DECLARE SECTION;

        long idPessoaLinhaHistorico = _idPessoaLinhaHistorico;
        int cdAreaRegistro;
        VARCHAR dtRelacionamento[32];
        int idLinhaTelefonica;
        int idPessoaDePara;
        int idTipoRelacionamento;
        int nrLinha;

        short i_cdAreaRegistro = -1;
        short i_dtRelacionamento = -1;
        short i_idLinhaTelefonica = -1;
        short i_idPessoaDePara = -1;
        short i_idPessoaLinhaHistorico = -1;
        short i_idTipoRelacionamento = -1;
        short i_nrLinha = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegPalitagemPC(&sqlca);

    EXEC SQL 
        SELECT
            CDAREAREGISTRO,
            TO_CHAR(DTRELACIONAMENTO,'DD/MM/YYYY HH24:MI:SS'),
            IDLINHATELEFONICA,
            IDPESSOADEPARA,
            IDPESSOALINHAHISTORICO,
            IDTIPORELACIONAMENTO,
            NRLINHA
        INTO
            :cdAreaRegistro:i_cdAreaRegistro,
            :dtRelacionamento:i_dtRelacionamento,
            :idLinhaTelefonica:i_idLinhaTelefonica,
            :idPessoaDePara:i_idPessoaDePara,
            :idPessoaLinhaHistorico:i_idPessoaLinhaHistorico,
            :idTipoRelacionamento:i_idTipoRelacionamento,
            :nrLinha:i_nrLinha
        FROM
           CUSTOMER.PESSOALINHAHISTORICO
        WHERE
           IDPESSOALINHAHISTORICO = :idPessoaLinhaHistorico;

    if ( 0 == sqlca.sqlcode )
    {
        CONVIND(dtRelacionamento,i_dtRelacionamento);

        pessoaLinhaHistoricoDPR.setCdAreaRegistro(cdAreaRegistro);
        pessoaLinhaHistoricoDPR.setDtRelacionamento((char*)dtRelacionamento.arr);
        pessoaLinhaHistoricoDPR.setIdLinhaTelefonica(idLinhaTelefonica);
        pessoaLinhaHistoricoDPR.setIdPessoaDePara(idPessoaDePara);
        pessoaLinhaHistoricoDPR.setIdPessoaLinhaHistorico(idPessoaLinhaHistorico);
        pessoaLinhaHistoricoDPR.setIdTipoRelacionamento(idTipoRelacionamento);
        pessoaLinhaHistoricoDPR.setNrLinha(nrLinha);
        pessoaLinhaHistoricoDPR.setOpCode(OPCODE_INSERT);

        xmlDpr->pessoalinhahistoricovo.inserir(&pessoaLinhaHistoricoDPR);
    }
    else
    {
        ULOGW("Dados não encontrados para idPessoaLinhaHistorico=%ld",
                                                            idPessoaLinhaHistorico);
    }

    ULOG_END("cRegPalitagemPC::AtualizarDadosPessoaLinhaHistorico()");
}

// SM324--DPR--DEZ/2006--Cassio
// Funcionalidade "quebra-galho" do DPR.
// Em tempo:
//  Como o DPR não estava enviando dados de INSERTs de tabelas customer 
//  (pessoa,pessoadepara,pessoalinhahistorico) agora a cada abertura de processo 
//  é enviado ao DPR um XML "fake" indicativo de um INSERT nestas tabelas.
//  Esta funcionalidade foi executada a pedido do Tiago e Borelli da área
//  do Tibco Indra.
//
void cRegPalitagemPC::AtualizarDadosPessoaDeParaDPR(int _idPessoaDePara,XMLDPR *xmlDpr)
{
    ULOG_START("cRegPalitagemPC::AtualizarDadosPessoaDeParaDPR()");

    PessoaDeParaDPR pessoaDeParaDPR;

    EXEC SQL BEGIN DECLARE SECTION;

       int idPessoaDePara = _idPessoaDePara;
       long idPessoa;
       int idPessoaOrigem;

       short i_idPessoa = -1;
       short i_idPessoaOrigem = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegPalitagemPC(&sqlca);

    EXEC SQL 
        SELECT
            IDPESSOA,
            IDPESSOAORIGEM
        INTO
            :idPessoa:i_idPessoa,
            :idPessoaOrigem:i_idPessoaOrigem
        FROM
           CUSTOMER.PESSOADEPARA
        WHERE
           IDPESSOADEPARA = :idPessoaDePara;

    if ( 0 == sqlca.sqlcode )
    {
        pessoaDeParaDPR.setIdPessoa(idPessoa);
        pessoaDeParaDPR.setIdPessoaDePara(idPessoaDePara);
        pessoaDeParaDPR.setIdPessoaOrigem(idPessoaOrigem);
        pessoaDeParaDPR.setOpCode(OPCODE_INSERT);

        xmlDpr->pessoadeparavo.inserir(&pessoaDeParaDPR);
    }
    else
    {
        ULOGW("Dados não encontrados para idPessoaDePara=%d",idPessoaDePara);
    }

    ULOG_END("cRegPalitagemPC::AtualizarDadosPessoaDeParaDPR()");
}

// SM324--DPR--DEZ/2006--Cassio
// Funcionalidade "quebra-galho" do DPR.
// Em tempo:
//  Como o DPR não estava enviando dados de INSERTs de tabelas customer 
//  (pessoa,pessoadepara,pessoalinhahistorico) agora a cada abertura de processo 
//  é enviado ao DPR um XML "fake" indicativo de um INSERT nestas tabelas.
//  Esta funcionalidade foi executada a pedido do Tiago e Borelli da área
//  do Tibco Indra.
//
void cRegPalitagemPC::AtualizarDadosPessoaDPR(int _idPessoaDePara,XMLDPR *xmlDpr)
{
    ULOG_START("cRegPalitagemPC::AtualizarDadosPessoaDPR()");

    PessoaDPR pessoaDPR;

    EXEC SQL BEGIN DECLARE SECTION;

       int idPessoaDePara = _idPessoaDePara;

       long idPessoa;
       int idTipoPessoa;
       VARCHAR nmPessoa[256];

       short i_idPessoa;
       short i_idTipoPessoa;
       short i_nmPessoa;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegPalitagemPC(&sqlca);

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE curPessoa CURSOR FOR
        SELECT
            PESSOA.IDPESSOA,
            PESSOA.IDTIPOPESSOA,
            PESSOA.NMPESSOA
        INTO
            :idPessoa:i_idPessoa,
            :idTipoPessoa:i_idTipoPessoa,
            :nmPessoa:i_nmPessoa
        FROM
           CUSTOMER.PESSOA PESSOA,
           CUSTOMER.PESSOADEPARA PESSOADEPARA
        WHERE
           PESSOADEPARA.IDPESSOADEPARA = :idPessoaDePara
        AND
           PESSOADEPARA.IDPESSOA = PESSOA.IDPESSOA;

    EXEC SQL OPEN curPessoa;

    while (true)
    {
        i_nmPessoa = -1;

        EXEC SQL FETCH curPessoa INTO
            :idPessoa:i_idPessoa,
            :idTipoPessoa:i_idTipoPessoa,
            :nmPessoa:i_nmPessoa;

        CONVIND(nmPessoa,i_nmPessoa);
            
        pessoaDPR.setIdPessoa(idPessoa);
        pessoaDPR.setIdPessoaDePara(idPessoaDePara);
        pessoaDPR.setIdTipoPessoa(idTipoPessoa);
        pessoaDPR.setNmPessoa((char*)nmPessoa.arr);
        pessoaDPR.setOpCode(OPCODE_INSERT);

        xmlDpr->pessoavo.inserir(&pessoaDPR);
    }

    EXEC SQL CLOSE curPessoa;

    ULOG_END("cRegPalitagemPC::AtualizarDadosPessoaDPR()");
}

/**
    Retorna o tipo de retorno que o atendimento terá.
*/
void cRegPalitagemPC::obtemPrazoAtendimentoContato(double *_qtHorasPrazoContato,
                                                 double *_qtHorasPrazoAnatel,
                                                 int _idContato)
{
    ULOG_START("cRegPalitagemPC::obtemPrazoAtendimentoContato()");

    EXEC SQL BEGIN DECLARE SECTION;

        int idContato = _idContato;

        double qtHorasPrazoContato;
        double qtHorasPrazoAnatel;

        short i_qtHorasPrazoContato=-1;
        short i_qtHorasPrazoAnatel = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegPalitagemPC(&sqlca);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        SELECT
            NVL(qtHorasPrazoContato,0) AS qtHorasPrazoContato,
            NVL(qtHorasPrazoAnatel,0) AS qtHorasPrazoAnatel
        INTO
            :qtHorasPrazoContato:i_qtHorasPrazoContato,
            :qtHorasPrazoAnatel:i_qtHorasPrazoAnatel // prazo de contato prévio
        FROM
            contatoadm.ContatoFolha
        WHERE
            idContato = :idContato;

    if ( i_qtHorasPrazoContato == -1 )
    {
        qtHorasPrazoContato = qtHorasPrazoAnatel = -1;
    }

    *_qtHorasPrazoContato = qtHorasPrazoContato;
    *_qtHorasPrazoAnatel = qtHorasPrazoAnatel;

    ULOG("Dados obtidos - qtHorasPrazoContato = ["MASCFLOAT"]", qtHorasPrazoContato);
    ULOG("Dados obtidos - qtHorasPrazoAnatel = ["MASCFLOAT"]", qtHorasPrazoAnatel);

    ULOG_END("cRegPalitagemPC::obtemPrazoAtendimentoContato()");
}


/**
    Retorna o prazo solução do atendimento.
*/
void cRegPalitagemPC::obtemPrazoAtendimentoSegmentado(double* horas,int _idContato, int _idSegmentacao, int _idProcedencia)
{
    ULOG_START("cRegPalitagemPC::obtemPrazoAtendimentoSegmentado()");

    EXEC SQL BEGIN DECLARE SECTION;

        int idContato     = _idContato;
        int idSegmentacao = _idSegmentacao;
        int idProcedencia = _idProcedencia;

        int vlHoras = 0;

        short i_vlHoras = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegPalitagemPC(&sqlca);

    EXEC SQL
        SELECT
            qtHorasPrazoContato
        INTO
            :vlHoras:i_vlHoras
        FROM
            contatoadm.PrazoAtendimento
        WHERE
            idContato = :idContato AND
            idSegmentacao = :idSegmentacao AND
            idProcedencia = :idProcedencia AND
            rownum < 2;

    if (i_vlHoras == -1)
        vlHoras = i_vlHoras;

    *horas = vlHoras;

    ULOG("Dados obtidos - vlHoras = [%i]", vlHoras);

    ULOG_END("cRegPalitagemPC::obtemPrazoAtendimentoSegmentado()");
}

/**
    Retorna o peso do atendimento.
*/
bool cRegPalitagemPC::obtemPesoAtendimento(char* peso,int _idContato,int _idSegmentacao,int _idProcedencia,int _idTipoCarteira,const char *sgTipoPortabilidade)
{
    ULOG_START("cRegPalitagemPC::obtemPesoAtendimento()");

    EXEC SQL BEGIN DECLARE SECTION;

        int idContato      = _idContato;
        int idSegmentacao  = _idSegmentacao;
        int idProcedencia  = _idProcedencia;
        int idTipoCarteira = _idTipoCarteira;

        VARCHAR vlPeso[256];

        short i_vlPeso=-1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegPalitagemPC(&sqlca); 
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    if ( strcmp(sgTipoPortabilidade,"PORTOUT")==0 )
    {
        ULOG("SELECT pesoEstatico "
                       "FROM atendimento.CalculaPesoEstaticoPOV01 "
                      "WHERE idContato = %d "
                        "AND idSegmentacao = %d "
                        "AND idProcedencia = %d "
                        "AND idTipoCarteira = %d"
                    ,idContato,idSegmentacao
                    ,idProcedencia,idTipoCarteira);
    }
    else
    {
        ULOG("SELECT pesoEstatico "
                       "FROM atendimento.CalculaPesoEstaticoV01 "
                      "WHERE idContato = %d "
                        "AND idSegmentacao = %d "
                        "AND idProcedencia = %d "
                        "AND idTipoCarteira = %d"
                    ,idContato,idSegmentacao
                    ,idProcedencia,idTipoCarteira);
    }
 
    if ( strcmp(sgTipoPortabilidade,"PORTOUT")==0 )
    {
        EXEC SQL
            SELECT
                pesoEstatico
            INTO
                :vlPeso:i_vlPeso
            FROM
                atendimento.CalculaPesoEstaticoPOV01
            WHERE
                idContato = :idContato
            AND idSegmentacao = :idSegmentacao
            AND idProcedencia = :idProcedencia
            AND idTipoCarteira = :idTipoCarteira; 
    }
    else
    {
        EXEC SQL
            SELECT
                pesoEstatico
            INTO
                :vlPeso:i_vlPeso
            FROM
                atendimento.CalculaPesoEstaticoV01
            WHERE
                idContato = :idContato
            AND idSegmentacao = :idSegmentacao
            AND idProcedencia = :idProcedencia
            AND idTipoCarteira = :idTipoCarteira; 
    }
 
    if ( 0 == sqlca.sqlcode ) 
    { 
        CONVIND(vlPeso,i_vlPeso);

        strncpy(peso,(char*)vlPeso.arr,255); 
        *(peso+255) = 0; 

        ULOG("vlPeso = [%s]", vlPeso.arr); 
    } 
    else 
    { 
        strcpy(peso,"0"); 
 
        ULOG("Peso não encontrado"); 
    }

    ULOG_END("cRegPalitagemPC::obtemPesoAtendimento()"); 
 
    return 0 == sqlca.sqlcode ? true : false;
}

/**
    Busca no banco de dados de parametros o prazo em horas que 
    a ANATEL estabelece para o encerramento do atendimento.
*/
int cRegPalitagemPC::obtemPrazoANATEL()
{
    ULOG_START("cRegPalitagemPC::obtemPrazoANATEL()");

    EXEC SQL BEGIN DECLARE SECTION;

        int vlPrazoANATEL;

        short i_vlPrazoANATEL = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegPalitagemPC(&sqlca);

    EXEC SQL
        SELECT
            dsValorParametro
        INTO
            :vlPrazoANATEL:i_vlPrazoANATEL
        FROM
            apoio.Parametro
        WHERE
            cdParametro = 'pzANATEL';

    if (i_vlPrazoANATEL == -1)
        vlPrazoANATEL = -1;

    ULOG("Dados obtidos - vlPrazoANATEL = [%i]", vlPrazoANATEL);

    ULOG_END("cRegPalitagemPC::obtemPrazoANATEL()");

    return vlPrazoANATEL;
}

void cRegPalitagemPC::proCDataFechamentoAnatel(long sIdAtendimento, char* dataFechamento)
{
    ULOG_START("cRegPalitagemPC::proCDataFechamentoAnatel()");

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = sIdAtendimento;
        VARCHAR dataAtual[256];
        short i_dataAtual = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegPalitagemPC(&sqlca);

    EXEC SQL 
        SELECT
            TO_CHAR(DTPRAZOFINALANATEL, 'DD/MM/YYYY HH24:MI')
        INTO    
            :dataAtual:i_dataAtual
        FROM
            Atendimento.Atendimento
        WHERE
            idAtendimento = :idAtendimento;

    CONVIND(dataAtual,i_dataAtual);

    strcpy(dataFechamento,(char*)dataAtual.arr);

    ULOG("Dados obtidos - dataFechamento = [%s]", dataFechamento);

    ULOG_END("cRegPalitagemPC::proCDataFechamentoAnatel()");
}

void cRegPalitagemPC::proCDataFechamento(long sIdAtendimento, char* dataFechamento)
{
    ULOG_START("cRegPalitagemPC::proCDataFechamento()");

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = sIdAtendimento;
        VARCHAR dataAtual[256];
        short i_dataAtual = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegPalitagemPC(&sqlca);

    EXEC SQL 
        SELECT
            TO_CHAR(DTPRAZOFINALINTERNO, 'DD/MM/YYYY HH24:MI')
        INTO    
            :dataAtual:i_dataAtual
        FROM
            Atendimento.Atendimento
        WHERE
            idAtendimento = :idAtendimento;

    CONVIND(dataAtual,i_dataAtual);

    strcpy(dataFechamento,(char*)dataAtual.arr);

    ULOG("Dados obtidos - dataFechamento = [%s]", dataFechamento);
    ULOG_END("cRegPalitagemPC::proCDataFechamento()");
}

//====================================================================================
//  Busca os dados da linha informada na abertura do atendimento.
//====================================================================================
//
void cRegPalitagemPC::obtemDadosLinhaTelefonica(int _idPessoaCliente
                                             ,int _idLinhaTelefonica
                                             ,long* _idPessoaLinhaHistorico
                                             ,int* _idEstadoLinha
                                             ,int* _idTipoLinha)
{
    ULOG_START("cRegPalitagemPC::obtemDadosLinhaTelefonica()");

    EXEC SQL BEGIN DECLARE SECTION;

        int idPessoaCliente = _idPessoaCliente;
        int idLinhaTelefonica = _idLinhaTelefonica;

        long idPessoaLinhaHistorico;
        int idEstadoLinha;
        int idTipoLinha;

        short i_idPessoaLinhaHistorico = -1;
        short i_idEstadoLinha = -1;
        short i_idTipoLinha = -1;

    EXEC SQL END DECLARE SECTION;

    ULOG("Parametros de entrada - idPessoaCliente = [%d] - "
                             "idLinhaTelefonica = [%d]"
                             ,idPessoaCliente,idLinhaTelefonica );

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegPalitagemPC(&sqlca);

    // ==========================================================================
    // Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
    // Este código desativou o uso da view ATENDIMENTO.ATDDADOSLINHATELEFONICAV01
    // pois a mesma era usada somente neste ponto no sistema.
    //
    // EXEC SQL
    //     SELECT
    //         idPessoaLinhaHistorico,
    //         idEstadoLinha,
    //         idTipoLinha
    //     INTO
    //         :idPessoaLinhaHistorico:i_idPessoaLinhaHistorico,
    //         :idEstadoLinha:i_idEstadoLinha,
    //         :idTipoLinha:i_idTipoLinha
    //     FROM
    //         Atendimento.AtdDadosLinhaTelefonicaV01
    //     WHERE
    //         idPessoaDePara = :idPessoaCliente
    //     AND idLinhaTelefonica = :idLinhaTelefonica
    //     AND ROWNUM < 2;
    // ==========================================================================
    EXEC SQL
        SELECT
            PESSOALINHAHISTORICO.IDPESSOALINHAHISTORICO,
            LINHABASE.IDESTADOLINHA,
            LINHATELEFONICA.IDTIPOLINHA
        INTO
            :idPessoaLinhaHistorico:i_idPessoaLinhaHistorico,
            :idEstadoLinha:i_idEstadoLinha,
            :idTipoLinha:i_idTipoLinha
        FROM
            CUSTOMER.PESSOALINHAHISTORICO PESSOALINHAHISTORICO,
            LINHA.LINHATELEFONICA LINHATELEFONICA,
            LINHA.LINHABASE LINHABASE
        WHERE
            PESSOALINHAHISTORICO.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
        AND LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
        AND PESSOALINHAHISTORICO.IDTIPORELACIONAMENTO = 2
        AND PESSOALINHAHISTORICO.IDPESSOADEPARA = :idPessoaCliente
        AND PESSOALINHAHISTORICO.IDLINHATELEFONICA = :idLinhaTelefonica
        AND ROWNUM < 2;

    if (i_idPessoaLinhaHistorico == -1) idPessoaLinhaHistorico = -1;
    if (i_idEstadoLinha == -1) idEstadoLinha = -1;
    if (i_idTipoLinha == -1) idTipoLinha = -1;

    if ( _idPessoaLinhaHistorico ) 
    {
        *_idPessoaLinhaHistorico = idPessoaLinhaHistorico;

        ULOG("idPessoaLinhaHistorico=[%ld]",idPessoaLinhaHistorico);
    }
    else
    {
        ULOG("Sem destino disponível para atribuir [%ld] de 'idPessoaLinhaHistorico'",idPessoaLinhaHistorico);
    }

    if ( _idEstadoLinha ) 
    {
        *_idEstadoLinha = idEstadoLinha;

        ULOG("idEstadoLinha=[%i]",idEstadoLinha);
    }
    else
    {
        ULOG("Sem destino disponível para atribuir [%i] de 'idEstadoLinha'",idEstadoLinha);
    }

    if ( _idTipoLinha ) 
    {
        *_idTipoLinha = idTipoLinha;

        ULOG("idTipoLinha=[%i]",idTipoLinha);
    }
    else
    {
        ULOG("Sem destino disponível para atribuir [%i] de 'idTipoLinha'",idTipoLinha);
    }

    ULOG_END("cRegPalitagemPC::obtemDadosLinhaTelefonica()");
}

/**
    Busca os dados da linha informada na abertura do atendimento.
*/
void cRegPalitagemPC::obtemSequenciaAbertura(int *sequencia,int _idContato,int _idGrupoAbertura)
{
    ULOG_START("cRegPalitagemPC::obtemSequenciaAbertura()");

    EXEC SQL BEGIN DECLARE SECTION;

        int idContato = _idContato;
        int idGrupo   = _idGrupoAbertura;

        int idSequencia;

        short i_idSequencia  = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegPalitagemPC(&sqlca);

    /*  @Marcelo remoção de views bzeroum
    EXEC SQL
        SELECT
            idSequencia
        INTO
            :idSequencia:i_idSequencia
        FROM
            contatoadm.SequenciaB01
        WHERE
            idContato = :idContato AND
            idGrupo = :idGrupo AND
            idTipoSequencia = 1 AND
            rownum < 2;
    */

    EXEC SQL
        SELECT
           SEQUENCIA.IDSEQUENCIA
        INTO
            :idSequencia:i_idSequencia
        FROM
           CONTATOADM.CONTATOGRUPO CONTATOGRUPO,
           CONTATOADM.TIPOSEQUENCIA TIPOSEQUENCIA,
           CONTATOADM.SEQUENCIA SEQUENCIA
        WHERE
           SEQUENCIA.IDCONTATOGRUPO = CONTATOGRUPO.IDCONTATOGRUPO
        AND
           SEQUENCIA.IDTIPOSEQUENCIA = TIPOSEQUENCIA.IDTIPOSEQUENCIA
        AND
           CONTATOGRUPO.IDCONTATO = :idContato
        AND
           CONTATOGRUPO.IDGRUPO = :idGrupo 
        AND
           TIPOSEQUENCIA.NMTIPOSEQUENCIA = 'ABERTURA'
        AND
           ROWNUM < 2;

    if ( sequencia ) 
    { 
        *sequencia = i_idSequencia == -1 ? -1 : idSequencia; 
        ULOG("Dados obtidos - idSequencia = [%i]", *sequencia); 
    } 
    else 
    { 
        ULOGW("área para gravação da resposta não foi disponibilizada"); 
    }

    ULOG_END("cRegPalitagemPC::obtemSequenciaAbertura()");
}

//====================================================================================
//==> Incidência 3271 Homologação VIVO, Julho,2006 - Cassio
//
// Esta operação ficou sem uso com a implementação da incidência acima.
//
//====================================================================================
// Busca os tipo de retorno do atendimento
//====================================================================================
//
void cRegPalitagemPC::obtemTipoRetornoAtendimento(int* _idTipoRetornoContato, int* _inEnvioTelefone)
{
    ULOG_START("obtemTipoRetornoAtendimento()");

    EXEC SQL BEGIN DECLARE SECTION;

        int idTipoComunicacao = dados->idTipoRetorno;

        int idTipoRetornoContato;
        int inEnvioTelefone;

        short i_idTipoRetornoContato = -1;
        short i_inEnvioTelefone = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegPalitagemPC(&sqlca);

    EXEC SQL
        SELECT
            IDTIPORETORNOCONTATO,
            INENVIOTELEFONE
        INTO
            :idTipoRetornoContato:i_idTipoRetornoContato,
            :inEnvioTelefone:i_inEnvioTelefone
        FROM
            CONTATOADM.FORMARETORNOV01
        WHERE
            IDTIPOCOMUNICACAO = :idTipoComunicacao;

    if (i_idTipoRetornoContato == -1) idTipoRetornoContato = -1;
    if (i_inEnvioTelefone == -1) inEnvioTelefone = -1;

    if ( _idTipoRetornoContato ) *_idTipoRetornoContato = idTipoRetornoContato;
    if ( _inEnvioTelefone ) *_inEnvioTelefone = inEnvioTelefone;

    ULOG("idTipoRetornoContato = %i",idTipoRetornoContato);
    ULOG("inEnvioTelefone = %i",inEnvioTelefone);

    ULOG_END("obtemTipoRetornoAtendimento()");
}

//====================================================================================
//==> Incidência 3271 Homologação VIVO, Julho,2006 - Cassio
//
// Esta operação ficou sem uso com a implementação da incidência acima.
//
//====================================================================================
// Busca os tipo de retorno do atendimento.
//====================================================================================
//
// void cRegPalitagemPC::obtemTipoRetornoTelefone(int* sequencia, int* tipoLinha, int* tipo)
// {
//     ULOG_START("obtemTipoRetornoTelefone()");
// 
//     EXEC SQL BEGIN DECLARE SECTION;
// 
//         int idContato       = dados->idContato;
//         int idProcedencia   = dados->idProcedencia;
//         int idCanal         = dados->idCanal;
//         int idTipoCarteira  = dados->idTipoCarteira;
//         int idSegmentacao   = dados->idSegmentacao;
//         int inRespAbertura  = dados->idTipoRelacionamento;
//         int idTipoPessoa    = dados->idTipoPessoa;
//         int idTipoLinha     = *tipoLinha;
//         int idSequencia     = *sequencia;
// 
//         int idTipoRetornoContato=0;
// 
//         short i_idTipoRetornoContato = -1;
// 
//     EXEC SQL END DECLARE SECTION;
// 
//     EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegPalitagemPC(&sqlca);
// 
//     EXEC SQL
//         SELECT
//             idTipoRetornoContato
//         INTO
//             :idTipoRetornoContato:i_idTipoRetornoContato
//         FROM
//             contatoadm.ParametrosTipoRetornoV01
//         WHERE
//             idContato = :idContato AND
//             idProcedencia = :idProcedencia AND
//             idCanal = :idCanal AND
//             idTipoCarteira = :idTipoCarteira AND
//             idSegmentacao = :idSegmentacao AND
//             idTipoLinha = :idTipoLinha AND
//             idTipoRelacionamento = :inRespAbertura AND
//             idTipoPessoa = :idTipoPessoa AND
//             idSequencia = :idSequencia AND 
//             rownum < 2
//         ORDER BY
//             idTipoRetornoContato DESC;
// 
//     if (i_idTipoRetornoContato == -1)
//         idTipoRetornoContato = 1;
// 
//     *tipo = idTipoRetornoContato;
// 
//     ULOG("Dados obtidos - idTipoRetornoContato = [%i]", idTipoRetornoContato);
// 
//     ULOG_END("obtemTipoRetornoTelefone()");
// }

void cRegPalitagemPC::obtemAgrupamentoEstadoTpProc(int _idContato,int *agrupamento)
{
    ULOG_START("cRegPalitagemPC::obtemAgrupamentoEstadoTpProc()");

    EXEC SQL BEGIN DECLARE SECTION;

        int idContato = _idContato;

        int idAgrupamentoEstadoTpProc = 0;

        short i_idAgrupamentoEstadoTpProc = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegPalitagemPC(&sqlca);

    // ========================================================================
    // Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
    // Este código desativou o uso da view ATENDIMENTO.CONTATOFOLHATPPROCV01
    // pois a mesma era usada somente neste ponto no sistema.
    //
    //    SELECT
    //        idAgrupamentoEstadoTpProc
    //    INTO
    //        :idAgrupamentoEstadoTpProc:i_idAgrupamentoEstadoTpProc
    //    FROM
    //        atendimento.ContatoFolhaTpProcV01
    //    WHERE
    //        idContato = :idContato
    //    AND 
    //        ROWNUM < 2;
    // ========================================================================
    //
    EXEC SQL
        SELECT
            AETP.IDAGRUPAMENTOESTADOTPPROC
        INTO
            :idAgrupamentoEstadoTpProc:i_idAgrupamentoEstadoTpProc
        FROM
           CONTATOADM.CONTATOFOLHA CF,
           WORKFLOW.AGRUPAMENTOESTADOTPPROC AETP
        WHERE
            CF.IDTIPOPROCESSO = AETP.IDTIPOPROCESSO 
        AND AETP.INESTADOINICIAL = 1
        AND CF.IDCONTATO = :idContato
        AND ROWNUM < 2;

    if (i_idAgrupamentoEstadoTpProc == -1)
        idAgrupamentoEstadoTpProc = -1;

    *agrupamento = idAgrupamentoEstadoTpProc;

    ULOG("idContato=%d",idContato);
    ULOG("idAgrupamentoEstadoTpProc=%d",idAgrupamentoEstadoTpProc);

    ULOG_END("cRegPalitagemPC::obtemAgrupamentoEstadoTpProc()");
}

/**
    Obtem os dados a respeito da conta.
*/
void cRegPalitagemPC::obtemDadosConta(int* idConta, char* conta, char* digitoConta)
{
    ULOG_START("cRegPalitagemPC::obtemDadosConta()");

    EXEC SQL BEGIN DECLARE SECTION;

        int idconta = *idConta;

        VARCHAR cdConta[256];
        VARCHAR cdDigitoConta[256];

        short i_cdConta = -1;
        short i_cdDigitoConta = -1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegPalitagemPC(&sqlca);

    EXEC SQL
    SELECT 
        cdConta, 
        cdDigitoConta
    INTO
        cdConta:i_cdConta,
        cdDigitoConta:i_cdDigitoConta
    FROM 
        customer.Conta
    WHERE
        idConta = :idconta;

    if ( !sqlca.sqlcode )
    {
        CONVIND(cdConta,i_cdConta);
        CONVIND(cdDigitoConta,i_cdDigitoConta);

        strcpy(conta,(char*)cdConta.arr);
        strcpy(digitoConta,(char*)cdDigitoConta.arr);
    }

    ULOG_END("cRegPalitagemPC::obtemDadosConta()");
}
 
/** 
    Obtem o idTipoPessoa 
*/ 
void cRegPalitagemPC::obtemIdTipoPessoa(int* _idTipoPessoa,char *_inTipoPessoa) 
{ 
    ULOG_START("cRegPalitagemPC::obtemIdTipoPessoa()"); 
 
    EXEC SQL BEGIN DECLARE SECTION; 
 
        char *inTipoPessoa = _inTipoPessoa; 
 
        int idTipoPessoa = 0; 
        short i_idTipoPessoa = -1; 
 
    EXEC SQL END DECLARE SECTION; 
 
    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegPalitagemPC(&sqlca); 
 
    EXEC SQL 
        SELECT  
            IDTIPOPESSOA 
        INTO 
            idTipoPessoa:i_idTipoPessoa 
        FROM  
            APOIO.TIPOPESSOA 
        WHERE 
            SGTIPOPESSOA = :inTipoPessoa; 
 
    if (i_idTipoPessoa == -1) 
    { 
        ULOG("Tipo de pessoa nao encontrado, assumindo tipo default."); 
        idTipoPessoa = 1; 
    } 
 
    *_idTipoPessoa = idTipoPessoa; 
 
    ULOG("idTipoPessoa = [%d]",idTipoPessoa); 
 
    ULOG_END("cRegPalitagemPC::obtemIdTipoPessoa()"); 
} 
 
/** 
    Obtém parâmetros de portabilidade 
*/ 
int cRegPalitagemPC::obterGrupoTratamentoPortout(const char *sgTipoPortabilidade,const char *dsAcaoPortabilidade) 
{ 
    ULOG_START("cRegPalitagemPC::obterGrupoTratamentoPortout()"); 
 
    EXEC SQL BEGIN DECLARE SECTION; 
        const char *pOraSgTipoPortabilidade = sgTipoPortabilidade; 
        const char *pOraDsAcaoPortabilidade = dsAcaoPortabilidade; 
        int idGrupoTratamento; 
        short i_idGrupoTratamento; 
 
    EXEC SQL END DECLARE SECTION; 
 
    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegPalitagemPC(&sqlca); 
    EXEC SQL WHENEVER NOT FOUND CONTINUE; 
 
    EXEC SQL 
        SELECT  
            IDGRUPOTRATAMENTO 
        INTO 
            :idGrupoTratamento:i_idGrupoTratamento 
        FROM  
            CONTATOADM.CONTATOFUNCIONALIDADE 
        WHERE 
            CDFUNCIONALIDADE = UPPER(:pOraSgTipoPortabilidade||'_'||:pOraDsAcaoPortabilidade);
 
    if ( 0 == sqlca.sqlcode ) 
    { 
        ULOG("idGrupoTratamento = %d",idGrupoTratamento); 
    } 
    else 
    { 
        ULOG("idGrupoTratamento NAO ENCONTRADO"); 
    } 
 
    ULOG_END("cRegPalitagemPC::obterGrupoTratamentoPortout()"); 
 
    return sqlca.sqlcode == 0 ? idGrupoTratamento : -1; 
} 
 
/** 
    Obtém o idContato 
*/ 
int cRegPalitagemPC::obtemIdContato(char *nmPath) 
{ 
    ULOG_START("cRegPalitagemPC::obtemIdContato()"); 
 
    EXEC SQL BEGIN DECLARE SECTION; 
 
        char *nmPathOra = nmPath; 
        int idContato; 
 
    EXEC SQL END DECLARE SECTION; 
 
    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegPalitagemPC(&sqlca); 
    EXEC SQL WHENEVER NOT FOUND CONTINUE; 
 
    ULOG("path '%s'",nmPathOra); 
 
    EXEC SQL 
        SELECT  
            IDCONTATO 
        INTO 
            :idContato 
        FROM  
            CONTATOADM.CONTATO 
        WHERE 
            NMPATH = :nmPathOra; 
 
    if ( 0 == sqlca.sqlcode ) 
    { 
        ULOG("idContato = %d",idContato); 
    } 
    else 
    { 
        ULOG("idContato NAO ENCONTRADO"); 
    } 
 
    ULOG_END("cRegPalitagemPC::obtemIdContato()"); 
 
    return sqlca.sqlcode == 0 ? idContato : -1; 
} 

/**
    Grava o historico de portabilidade
*/
void cRegPalitagemPC::gravaPessoaPortabilidadeHist(int idUsuarioAlteracao, 
                                                   int idPessoaDePara, 
                                                   int idTipoLinha, 
                                                   int cdAreaRegistro, 
                                                   const char *nrTelefone, 
                                                   const char *sgTipoPortabilidade,
                                                   const char *dsAcaoPortabilidade,
                                                   const char *dsObservacao,
                                                   const char *sgOperadoraSolicitante,
                                                   const char *nrProtocoloPortabilidade,
                                                   const char *dtJanelaPortout)
{
    ULOG_START("cRegPalitagemPC::gravaPessoaPortabilidadeHist()");

    EXEC SQL BEGIN DECLARE SECTION; 
 
        int varOraCdAreaRegistro = cdAreaRegistro; 
        long varOraIdPessoa=0; 
        int varOraIdPessoaDePara = idPessoaDePara; 
        int varOraIdTipoDocumento=0; 
        int varOraIdTipoEndereco=0; 
        int varOraIdTipoLinha = idTipoLinha;
        int varOraIdTipoPessoa=0; 
        int varOraIdUsuarioAlteracao = idUsuarioAlteracao; 
 
        VARCHAR varOraNmBairro[256];
        VARCHAR varOraNmLogradouro[256];
        VARCHAR varOraNmMunicipio[256];
        VARCHAR varOraNmPessoa[256];
        VARCHAR varOraNmTipoLogradouro[256];
        VARCHAR varOraNrCep[256];
        VARCHAR varOraNrDocumento[256];
        VARCHAR varOraNrEndereco[256];

        const char *varOraNrLinha = nrTelefone+2;
        const char *varOraSgTipoPortabilidade = sgTipoPortabilidade;
        const char *varOraDsAcaoPortabilidade = dsAcaoPortabilidade;
 
        const char *varOraDsObservacao = dsObservacao;
        const char *varOraSgOperadoraSolicitante = sgOperadoraSolicitante;
        const char *varOraNrProtocoloPortabilidade = nrProtocoloPortabilidade;
        const char *varOraDtJanelaPortout = dtJanelaPortout;

        short varStatOraCdAreaRegistro = 0;
        short varStatOraIdPessoa = -1;
        short varStatOraIdPessoaDePara = -1;
        short varStatOraIdTipoDocumento = -1;
        short varStatOraIdTipoEndereco = -1;
        short varStatOraIdTipoLinha = 0;
        short varStatOraIdTipoPessoa = -1;
        short varStatOraIdUsuarioAlteracao = 0;
        short varStatOraNmBairro = -1;
        short varStatOraNmLogradouro = -1;
        short varStatOraNmMunicipio = -1;
        short varStatOraNmPessoa = -1;
        short varStatOraNmTipoLogradouro = -1;
        short varStatOraNrCep = -1;
        short varStatOraNrDocumento = -1;
        short varStatOraNrEndereco = -1;
        short varStatOraNrLinha = 0;
        short varStatOraSgTipoPortabilidade = 0;
        short varStatOraDsAcaoPortabilidade = 0;
        short varStatOraDsObservacao = *dsObservacao ? 0 : -1;
        short varStatOraSgOperadoraSolicitante = *sgOperadoraSolicitante ? 0 : -1;
        short varStatOraNrProtocoloPortabilidade = *nrProtocoloPortabilidade ? 0 : -1;
        short varStatOraDtJanelaPortout = *dtJanelaPortout ? 0 : -1;

    EXEC SQL END DECLARE SECTION;
 
    // 
    //================================================================ 
    // Inicializa

    memset(&varOraNmBairro,0,sizeof(varOraNmBairro));
    memset(&varOraNmLogradouro,0,sizeof(varOraNmLogradouro));
    memset(&varOraNmMunicipio,0,sizeof(varOraNmMunicipio));
    memset(&varOraNmPessoa,0,sizeof(varOraNmPessoa));
    memset(&varOraNmTipoLogradouro,0,sizeof(varOraNmTipoLogradouro));
    memset(&varOraNrCep,0,sizeof(varOraNrCep));
    memset(&varOraNrDocumento,0,sizeof(varOraNrDocumento));
    memset(&varOraNrEndereco,0,sizeof(varOraNrEndereco));

    // 
    //================================================================ 
    // Tipo da linha default (caso não fornecido)
 
    if ( 0 == varOraIdTipoLinha )
    {
        ULOG("vai buscar idTipoLinha 'NÃO CLASSIFICADO' em APOIO.TIPOLINHA"); 
    
        EXEC SQL 
            SELECT
                IDTIPOLINHA
            INTO
                :varOraIdTipoLinha:varStatOraIdTipoLinha
            FROM
                APOIO.TIPOLINHA
            WHERE
                DSTIPOLINHA = 'NÃO CLASSIFICADO';
    }

    // 
    //================================================================ 
    // Dados da pessoa 
 
    ULOG("vai buscar dados para idPessoaDePara=%d",varOraIdPessoaDePara); 
 
    EXEC SQL 
        SELECT 
            PESSOA.IDPESSOA, 
            PESSOA.NMPESSOA, 
            PESSOA.IDTIPOPESSOA 
        INTO 
            :varOraIdPessoa:varStatOraIdPessoa, 
            :varOraNmPessoa:varStatOraNmPessoa, 
            :varOraIdTipoPessoa:varStatOraIdTipoPessoa 
        FROM 
            CUSTOMER.PESSOA PESSOA, 
            CUSTOMER.PESSOADEPARA PESSOADEPARA 
        WHERE 
            PESSOADEPARA.IDPESSOADEPARA = :varOraIdPessoaDePara 
        AND PESSOADEPARA.IDPESSOA = PESSOA.IDPESSOA; 
 
    if ( sqlca.sqlcode ) 
    { 
        ULOGW("idPessoa não encontrado para o processo"); 
        ULOG_END("cRegPalitagemPC::gravaPessoaPortabilidadeHist()"); 
        return; 
    } 
 
    CONVIND(varOraNmPessoa,varStatOraNmPessoa); 

    // 
    //================================================================ 
    // Documento da pessoa 
 
    ULOG("vai buscar documento para idPessoa=%ld",varOraIdPessoa); 
 
    EXEC SQL 
        SELECT 
            IDTIPODOCUMENTO, 
            NRDOCUMENTO 
        INTO 
            :varOraIdTipoDocumento:varStatOraIdTipoDocumento, 
            :varOraNrDocumento:varStatOraNrDocumento 
        FROM 
            ( 
                SELECT 
                    DOCUMENTO.IDTIPODOCUMENTO, 
                    DOCUMENTO.NRDOCUMENTO 
                FROM 
                    CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO, 
                    CUSTOMER.DOCUMENTO DOCUMENTO, 
                    APOIO.TIPODOCUMENTO TIPODOCUMENTO 
                WHERE 
                    PESSOADOCUMENTO.IDPESSOA = :varOraIdPessoa 
                AND PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO 
                AND DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO 
                ORDER BY 
                    TIPODOCUMENTO.NRPRIORIDADE 
            ) 
        WHERE 
            ROWNUM < 2; 
     
    CONVIND(varOraNrDocumento,varStatOraNrDocumento); 

    // 
    //================================================================ 
    // Documento da pessoa 
 
    ULOG("vai buscar endereço para idPessoa=%ld",varOraIdPessoa); 
 
    EXEC SQL 
        SELECT 
            IDTIPOENDERECO, 
            NMTIPOLOGRADOURO, 
            NMLOGRADOURO, 
            NRENDERECO, 
            NMMUNICIPIO, 
            NMBAIRRO, 
            NRCEP 
        INTO 
            :varOraIdTipoEndereco:varStatOraIdTipoEndereco, 
            :varOraNmTipoLogradouro:varStatOraNmTipoLogradouro, 
            :varOraNmLogradouro:varStatOraNmLogradouro, 
            :varOraNrEndereco:varStatOraNrEndereco, 
            :varOraNmMunicipio:varStatOraNmMunicipio, 
            :varOraNmBairro:varStatOraNmBairro, 
            :varOraNrCep:varStatOraNrCep 
        FROM 
            ( 
                SELECT 
                    NRSEQUENCIA, 
                    INENDERECOPREFERENCIAL,  
                    IDTIPOENDERECO, 
                    NMTIPOLOGRADOURO, 
                    NMLOGRADOURO, 
                    NRENDERECO, 
                    NMMUNICIPIO, 
                    NMBAIRRO, 
                    NRCEP 
                FROM 
                    CUSTOMER.PESSOAENDERECO  
                WHERE 
                    IDPESSOA = :varOraIdPessoa 
                ORDER BY 
                    NVL(INENDERECOPREFERENCIAL,0) DESC,NRSEQUENCIA 
            ) 
        WHERE 
            ROWNUM < 2; 
 
    CONVIND(varOraNmTipoLogradouro,varStatOraNmTipoLogradouro); 
    CONVIND(varOraNmLogradouro,varStatOraNmLogradouro); 
    CONVIND(varOraNrEndereco,varStatOraNrEndereco); 
    CONVIND(varOraNmMunicipio,varStatOraNmMunicipio); 
    CONVIND(varOraNmBairro,varStatOraNmBairro); 
    CONVIND(varOraNrCep,varStatOraNrCep); 

    // 
    //================================================================ 
    // Insere o histórico 
 
    ULOG("vai inserir no historico de portabilidade"); 

    ULOG("             idTipoLinha=%+d:%d",varStatOraIdTipoLinha,varOraIdTipoLinha);
    ULOG("          cdAreaRegistro=%+d:%d",varStatOraCdAreaRegistro,varOraCdAreaRegistro);
    ULOG("                 nrLinha=%+d:%s",varStatOraNrLinha,varOraNrLinha);
    ULOG("            idTipoPessoa=%+d:%d",varStatOraIdTipoPessoa,varOraIdTipoPessoa);
    ULOG("                nmPessoa=%+d:%s",varStatOraNmPessoa,(char*)varOraNmPessoa.arr);
    ULOG("         idTipoDocumento=%+d:%d",varStatOraIdTipoDocumento,varOraIdTipoDocumento);
    ULOG("             nrDocumento=%+d:%s",varStatOraNrDocumento,(char*)varOraNrDocumento.arr);
    ULOG("          idTipoEndereco=%+d:%s",varStatOraIdTipoEndereco,varOraIdTipoEndereco);
    ULOG("        nmTipoLogradouro=%+d:%s",varStatOraNmTipoLogradouro,(char*)varOraNmTipoLogradouro.arr);
    ULOG("            nmLogradouro=%+d:%s",varStatOraNmLogradouro,(char*)varOraNmLogradouro.arr);
    ULOG("              nrEndereco=%+d:%s",varStatOraNrEndereco,(char*)varOraNrEndereco.arr);
    ULOG("             nmMunicipio=%+d:%s",varStatOraNmMunicipio,(char*)varOraNmMunicipio.arr);
    ULOG("                nmBairro=%+d:%s",varStatOraNmBairro,(char*)varOraNmBairro.arr);
    ULOG("                   nrCep=%+d:%s",varStatOraNrCep,(char*)varOraNrCep.arr);
    ULOG("      idUsuarioAlteracao=%+d:%d",varStatOraIdUsuarioAlteracao,varOraIdUsuarioAlteracao);
    ULOG("     sgTipoPortabilidade=%+d:%s",varStatOraSgTipoPortabilidade,varOraSgTipoPortabilidade);
    ULOG("     dsAcaoPortabilidade=%+d:%s",varStatOraDsAcaoPortabilidade,varOraDsAcaoPortabilidade);
    ULOG("            dsObservacao=%+d:%s",varStatOraDsObservacao,varOraDsObservacao);
    ULOG("  sgOperadoraSolicitante=%+d:%s",varStatOraSgOperadoraSolicitante,varOraSgOperadoraSolicitante);
    ULOG("nrProtocoloPortabilidade=%+d:%s",varStatOraNrProtocoloPortabilidade,varOraNrProtocoloPortabilidade);
    ULOG("         dtJanelaPortout=%+d:%s",varStatOraDtJanelaPortout,varOraDtJanelaPortout);

    EXEC SQL
        INSERT INTO CUSTOMER.PESSOAPORTABILIDADEHIST 
            (IDPESSOAPORTABILIDADEHIST 
            ,IDTIPOLINHA 
            ,CDAREAREGISTRO 
            ,NRLINHA 
            ,IDTIPOPESSOA 
            ,NMPESSOA 
            ,IDTIPODOCUMENTO 
            ,NRDOCUMENTO 
            ,IDTIPOENDERECO 
            ,NMTIPOLOGRADOURO 
            ,NMLOGRADOURO 
            ,NRENDERECO 
            ,NMMUNICIPIO 
            ,NMBAIRRO 
            ,NRCEP 
            ,IDUSUARIOALTERACAO 
            ,DSACAOPORTABILIDADE 
            ,SGTIPOPORTABILIDADE
            ,DSOBSERVACAO
            ,SGOPERADORASOLICITANTE
            ,NRPROTOCOLOPORTABILIDADE
            ,DTJANELAPORTOUT)
        VALUES 
            (PESSOAPORTABILIDADEHISTSQ.NEXTVAL 
            ,:varOraIdTipoLinha:varStatOraIdTipoLinha 
            ,:varOraCdAreaRegistro:varStatOraCdAreaRegistro 
            ,:varOraNrLinha:varStatOraNrLinha 
            ,:varOraIdTipoPessoa:varStatOraIdTipoPessoa 
            ,:varOraNmPessoa:varStatOraNmPessoa 
            ,:varOraIdTipoDocumento:varStatOraIdTipoDocumento 
            ,:varOraNrDocumento:varStatOraNrDocumento 
            ,:varOraIdTipoEndereco:varStatOraIdTipoEndereco 
            ,:varOraNmTipoLogradouro:varStatOraNmTipoLogradouro 
            ,:varOraNmLogradouro:varStatOraNmLogradouro 
            ,:varOraNrEndereco:varStatOraNrEndereco 
            ,:varOraNmMunicipio:varStatOraNmMunicipio 
            ,:varOraNmBairro:varStatOraNmBairro 
            ,:varOraNrCep:varStatOraNrCep 
            ,:varOraIdUsuarioAlteracao:varStatOraIdUsuarioAlteracao 
            ,:varOraDsAcaoPortabilidade:varStatOraDsAcaoPortabilidade
            ,:varOraSgTipoPortabilidade:varStatOraSgTipoPortabilidade
            ,:varOraDsObservacao:varStatOraDsObservacao
            ,:varOraSgOperadoraSolicitante:varStatOraSgOperadoraSolicitante
            ,:varOraNrProtocoloPortabilidade:varStatOraNrProtocoloPortabilidade
            ,:varOraDtJanelaPortout:varStatOraDtJanelaPortout);

    ULOG_END("cRegPalitagemPC::gravaPessoaPortabilidadeHist()");
}
 
/** 
    Registra o atendimento na tabela de priorizacao. 
*/ 
void cRegPalitagemPC::registraTabelaPriorizacao(int _idTipoReabertura 
                                               ,int _idTipoPessoa 
                                               ,st_Atendimento *dadosAtendimento 
                                               ,st_vlAtendimento *statusAtendimento 
                                               ,st_AtendimentoPessoa *dadosAtendimentoPessoa 
                                               ,st_vlAtendimentoPessoa *statusAtendimentoPessoa 
                                               ) 
{ 
    ULOG_START("cRegPalitagemPC::registraTabelaPriorizacao()"); 
 
    EXEC SQL BEGIN DECLARE SECTION; 
        struct 
        { 
            struct st_Atendimento *dadosAtd; 
            char *peso; 
            int idAlerta; 
            int idAtividade; 
            VARCHAR nmCor[256]; 
            VARCHAR dtReabertura[21+1]; 
            int idPessoaDePara; 
            int idTipoRelacionamento; 
            int idTipoPessoa; 
        } oDados; 
 
        struct 
        { 
            struct st_vlAtendimento *statusAtd; 
            short peso; 
            short idAtividade; 
            short idAlerta; 
            short nmCor; 
            short dtReabertura; 
            short idPessoaDePara; 
            short idTipoRelacionamento; 
            short idTipoPessoa; 
        } oStatus; 
 
        struct 
        { 
            long idPessoa; 
            int idDocumento; 
        } oDadosDocumentoProcesso; 
 
        struct 
        { 
            short idPessoa; 
            short idDocumento; 
        } oStatusDocumentoProcesso; 
 
        int nrAtendimentoAgrupado; 
        short i_nrAtendimentoAgrupado;
        int iCount;
 
    EXEC SQL END DECLARE SECTION; 
   
    memset(&sqlca, 0, sizeof(sqlca)); 
    
    memset(&oDados.dtReabertura,0, sizeof(oDados.dtReabertura)); 
    oStatus.dtReabertura = -1; 
 
    memset(&oDados.nmCor,0, sizeof(oDados.nmCor)); 
    oStatus.nmCor = -1; 
 
    oDados.idAlerta = 0; 
    oStatus.idAlerta = -1; 
 
    oDados.dadosAtd = dadosAtendimento; 
    oStatus.statusAtd = statusAtendimento; 
 
    oDados.idPessoaDePara = dadosAtendimentoPessoa->idPessoaDePara; 
    oStatus.idPessoaDePara = statusAtendimentoPessoa->idPessoaDePara; 
 
    oDados.idTipoRelacionamento = dadosAtendimentoPessoa->idTipoRelacionamento; 
    oStatus.idTipoRelacionamento = statusAtendimentoPessoa->idTipoRelacionamento; 
 
    oDados.idTipoPessoa = _idTipoPessoa; 
    oStatus.idTipoPessoa = 1; 
 
    oDados.peso = oDados.dadosAtd->vlPesoAtendimento; 
    if ( atol(oDados.peso) < 0 ) oDados.peso = "1"; 
    oStatus.peso = 1; 
 
    if (_idTipoReabertura == 3) { oDados.idAtividade = 12; } 
    else if (_idTipoReabertura == 2) { oDados.idAtividade = 15; } 
    else { oDados.idAtividade = 0; } 
    oStatus.idAtividade = 1; 
 
    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegPalitagemPC(&sqlca); 
    EXEC SQL WHENEVER NOT FOUND CONTINUE; 
 
    ULOG("Obtendo Alerta..."); 
 
    EXEC SQL  
        SELECT  
            al.nmCor, 
            al.idAlerta 
        INTO  
            :oDados.nmCor:oStatus.nmCor, 
            :oDados.idAlerta:oStatus.idAlerta 
        FROM  
            workflow.Alerta al, 
            workflow.AtividadeAlerta a 
        WHERE  
            a.idAlerta = al.idAlerta 
        AND a.idAtividade = :oDados.idAtividade; 
     
    CONVIND(oDados.nmCor,oStatus.nmCor); 
 
    // Pesquisa a data primeira abertura processo sendo criado 
    ULOG("Vai pesquisar a data da primeira abertura do processo"); 
      
     EXEC SQL 
        SELECT 
            TO_CHAR(A.DTABERTURA,'DD/MM/YYYY HH24:MI:SS') AS DTABERTURA 
        INTO  
            :oDados.dtReabertura:oStatus.dtReabertura 
        FROM  
            ATENDIMENTO.ATENDIMENTO A 
        WHERE  
            A.IDATENDIMENTO =  
            ( 
                SELECT 
                    IDATENDIMENTOORIGEM 
                FROM 
                ( 
                    SELECT 
                        NIVEL,IDATENDIMENTOORIGEM 
                    FROM 
                    ( 
                        SELECT 
                            AO.IDATENDIMENTOORIGEM,LEVEL AS NIVEL 
                        FROM 
                            ATENDIMENTO.ATENDIMENTOORIGEM AO 
                        START WITH 
                            AO.IDATENDIMENTO = :oDados.dadosAtd->idAtendimento 
                        CONNECT BY PRIOR 
                            AO.IDATENDIMENTOORIGEM = AO.IDATENDIMENTO 
                    ) 
                    ORDER BY NIVEL DESC 
                ) 
                WHERE ROWNUM < 2 
            ); 
 
    if ( (char*)oDados.dtReabertura.len > 0 ) 
    { 
        ULOG("dtReabertura [%s]", (char*)oDados.dtReabertura.arr); 
    } 
    else 
    { 
        ULOG("data de primeira abertura não localizada"); 
    } 
     
    ULOG("Inserindo processo %d em AtendimentoPriorizacao",oDados.dadosAtd->idAtendimento); 
     
    EXEC SQL 
        INSERT INTO 
            atendimento.AtendimentoPriorizacao 
            ( 
                idAtendimento, 
                dtAbertura, 
                idContato, 
                dtPrazoFinalInterno, 
                qtInsistencia, 
                inAlarme, 
                idCanal, 
                idProcedencia, 
                idTipoCarteira, 
                idSegmentacao, 
                idPessoaUsuarioAbertura,  
                idGrupoAbertura, 
                dtPrazoFinalAnatel, 
                nrNivel, 
                idFase, 
                qtHorasPrazoAtendimento, 
                vlPesoAtendimento, 
                idTipoRetornoContato, 
                idUsuarioAlteracao, 
                dtUltimaAlteracao, 
                dtPrazoFinalCPrevio, 
                idTipoAbertura, 
                nrCriticidade, 
                nmCor, 
                idPessoaDePara, 
                idPessoaLinhaHistorico, 
                idTipoRelacionamento, 
                idLinhaTelefonica, 
                idTipoPessoa, 
                idUFOperadora, 
                idTipoLinha, 
                dtAtualizacao, 
                idAlerta, 
                dtReabertura, 
                cdAreaRegistro, 
                idAgrupamentoEstadoTpProc, 
                idAndamentoAtual, 
                idGrupoAnterior, 
                idGrupoAtual, 
                idPessoaUsuarioAnterior, 
                idPessoaUsuarioAtual, 
                idEstadoLinha, 
                idPessoaConta, 
                idAtendimentoProtocolo, 
                sgTipoPortabilidade, 
                sgOperadoraSolicitante, 
                nrProtocoloPortabilidade, 
                dtJanelaPortout, 
                dtUltimaOperacaoExcFila 
            ) 
        VALUES 
            ( 
                :oDados.dadosAtd->idAtendimento, 
                DECODE(:oStatus.statusAtd->dtAbertura,-1,SYSDATE,TO_DATE(:oDados.dadosAtd->dtAbertura,'DD/MM/YYYY HH24:MI:SS')), 
                :oDados.dadosAtd->idContato, 
                DECODE(:oStatus.statusAtd->dtPrazoFinalInterno,-1,NULL,TO_DATE(:oDados.dadosAtd->dtPrazoFinalInterno,'DD/MM/YYYY HH24:MI:SS')), 
                DECODE(:oStatus.statusAtd->qtInsistencia,-1,0,:oDados.dadosAtd->qtInsistencia), 
                DECODE(:oStatus.statusAtd->inAlarme,-1,0,:oDados.dadosAtd->inAlarme), 
                :oDados.dadosAtd->idCanal, 
                :oDados.dadosAtd->idProcedencia, 
                DECODE(:oStatus.statusAtd->idTipoCarteira,-1,0,:oDados.dadosAtd->idTipoCarteira), 
                DECODE(:oStatus.statusAtd->idSegmentacao,-1,0,:oDados.dadosAtd->idSegmentacao), 
                :oDados.dadosAtd->idPessoaUsuarioAbertura, 
                :oDados.dadosAtd->idGrupoAbertura, 
                DECODE(:oStatus.statusAtd->dtPrazoFinalAnatel,-1,NULL,TO_DATE(:oDados.dadosAtd->dtPrazoFinalAnatel,'DD/MM/YYYY HH24:MI:SS')), 
                DECODE(:oStatus.statusAtd->nrNivel,-1,NULL,:oDados.dadosAtd->nrNivel), 
                :oDados.dadosAtd->idFase, 
                DECODE(:oStatus.statusAtd->qtHorasPrazoAtendimento,-1,NULL,:oDados.dadosAtd->qtHorasPrazoAtendimento), 
                DECODE(:oStatus.statusAtd->vlPesoAtendimento,-1,0,:oDados.dadosAtd->vlPesoAtendimento), 
                DECODE(:oStatus.statusAtd->idTipoRetornoContato,-1,0,:oDados.dadosAtd->idTipoRetornoContato), 
                DECODE(:oStatus.statusAtd->idUsuarioAlteracao,-1,NULL,:oDados.dadosAtd->idUsuarioAlteracao), 
                DECODE(:oStatus.statusAtd->dtUltimaAlteracao,-1,SYSDATE,TO_DATE(:oDados.dadosAtd->dtUltimaAlteracao,'DD/MM/YYYY HH24:MI:SS')), 
                DECODE(:oStatus.statusAtd->dtPrazoFinalCPrevio,-1,NULL,TO_DATE(:oDados.dadosAtd->dtPrazoFinalCPrevio,'DD/MM/YYYY HH24:MI:SS')), 
                DECODE(:oStatus.statusAtd->idTipoAbertura,-1,0,:oDados.dadosAtd->idTipoAbertura), 
                :oDados.peso, 
                DECODE(:oStatus.nmCor,-1,NULL,:oDados.nmCor), 
                DECODE(:oStatus.idPessoaDePara,-1,NULL,:oDados.idPessoaDePara), 
                DECODE(:oStatus.statusAtd->idPessoaLinhaHistorico,-1,NULL,:oDados.dadosAtd->idPessoaLinhaHistorico), 
                DECODE(:oStatus.idTipoRelacionamento,-1,NULL,:oDados.idTipoRelacionamento), 
                DECODE(:oStatus.statusAtd->idLinhaTelefonica,-1,NULL,:oDados.dadosAtd->idLinhaTelefonica), 
                DECODE(:oStatus.idTipoPessoa,-1,NULL,:oDados.idTipoPessoa), 
                DECODE(:oStatus.statusAtd->idUFOperadora,-1,NULL,:oDados.dadosAtd->idUFOperadora), 
                DECODE(:oStatus.statusAtd->idTipoLinha,-1,NULL,:oDados.dadosAtd->idTipoLinha), 
                DECODE(:oStatus.statusAtd->dtUltimaAlteracao,-1,SYSDATE,TO_DATE(:oDados.dadosAtd->dtUltimaAlteracao,'DD/MM/YYYY HH24:MI:SS')), 
                :oDados.idAlerta, 
                DECODE(:oDados.dtReabertura,NULL,DECODE(:oStatus.statusAtd->dtAbertura,-1,SYSDATE,TO_DATE(:oDados.dadosAtd->dtAbertura,'DD/MM/YYYY HH24:MI:SS')),TO_DATE(:oDados.dtReabertura, 'DD/MM/YYYY HH24:MI:SS')), 
                DECODE(:oStatus.statusAtd->cdAreaRegistro,-1,NULL,:oDados.dadosAtd->cdAreaRegistro), 
                DECODE(:oStatus.statusAtd->idAgrupamentoEstadoTpProc,-1,NULL,:oDados.dadosAtd->idAgrupamentoEstadoTpProc), 
                NULL, // idAndamentoAtual 
                NULL, // idGrupoAnterior 
                NULL, // idGrupoAtual 
                NULL, // idPessoaUsuarioAnterior 
                NULL, // idPessoaUsuarioAtual 
                DECODE(:oStatus.statusAtd->idEstadoLinha,-1,NULL,:oDados.dadosAtd->idEstadoLinha), 
                DECODE(:oStatus.statusAtd->idPessoaConta,-1,NULL,:oDados.dadosAtd->idPessoaConta), 
                :oDados.dadosAtd->nrProtocolo, 
                DECODE(:oStatus.statusAtd->sgTipoPortabilidade,-1,NULL,:oDados.dadosAtd->sgTipoPortabilidade), 
                DECODE(:oStatus.statusAtd->sgOperadoraSolicitante,-1,NULL,:oDados.dadosAtd->sgOperadoraSolicitante), 
                DECODE(:oStatus.statusAtd->nrProtocoloPortabilidade,-1,NULL,:oDados.dadosAtd->nrProtocoloPortabilidade), 
                DECODE(:oStatus.statusAtd->dtJanelaPortout,-1,NULL,TO_DATE(:oDados.dadosAtd->dtJanelaPortout,'DD/MM/YYYY HH24:MI:SS')), 
                NULL // dtUltimaOperacaoExcFila 
            ); 
 
    if (oStatus.nmCor != -1) 
    { 
        ULOG("Inserindo Alerta..."); 
 
        EXEC SQL  
            INSERT INTO 
                Atendimento.AtendimentoAlerta 
                ( 
                    idAtendimentoAlerta, 
                    idAlerta, 
                    idAtendimento, 
                    dsMensagem, 
                    idUsuarioAlteracao, 
                    dtUltimaAlteracao 
                ) 
                VALUES 
                ( 
                    Atendimento.AtendimentoAlertaSQ.NEXTVAL, 
                    :oDados.idAlerta, 
                    :oDados.dadosAtd->idAtendimento, 
                    NULL, 
                    :oDados.dadosAtd->idUsuarioAlteracao, 
                    SYSDATE 
                ); 
    } 
 
    // Portabilidade - Associação de processos 
    if ( strcmp(oDados.dadosAtd->sgTipoPortabilidade,PROCESSO_PORTOUT)==0 ) 
    { 
        ULOG("Vai verificar se já existe agrupamento para a mesma linha..."); 
        
        // Em produção não vão ocorrer casos de port-out para a mesma linha telefônica
        // ocorrem mais de 1x, mas em ambiente de testes é comum serem feitos testes
        // repetidas vezes com a mesma linha e por isso estamos evitando a inclusão da
        // mesma linha no agrupamento e com isso afetar a camada web de retenção.
        //
        EXEC SQL
            SELECT
                COUNT(1)
            INTO
                :iCount
            FROM
                ATENDIMENTO.ATENDIMENTOAGRUPADO ATENDIMENTOAGRUPADO,
                ATENDIMENTO.ATENDIMENTOPRIORIZACAO ATENDIMENTOPRIORIZACAO
            WHERE
                ATENDIMENTOPRIORIZACAO.IDATENDIMENTO = ATENDIMENTOAGRUPADO.IDATENDIMENTO
            AND ATENDIMENTOPRIORIZACAO.IDLINHATELEFONICA = :oDados.dadosAtd->idLinhaTelefonica
            AND ROWNUM < 2;

        if ( iCount == 0 )
        {
            ULOG("Vai associar processos de portabilidade..."); 
 
            EXEC SQL DECLARE curDocumentos CURSOR FOR 
                SELECT DISTINCT 
                    PESSOADOCUMENTO.IDPESSOA, 
                    PESSOADOCUMENTO.IDDOCUMENTO 
                FROM 
                    ATENDIMENTO.ATENDIMENTOPRIORIZACAO ATENDIMENTOPRIORIZACAO, 
                    ATENDIMENTO.ATENDIMENTOPESSOA ATENDIMENTOPESSOA, 
                    CUSTOMER.PESSOADEPARA PESSOADEPARA, 
                    CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO, 
                    CUSTOMER.DOCUMENTO DOCUMENTO, 
                    APOIO.TIPODOCUMENTO TIPODOCUMENTO 
                WHERE  
                    ATENDIMENTOPRIORIZACAO.IDATENDIMENTO = :oDados.dadosAtd->idAtendimento 
                AND ATENDIMENTOPRIORIZACAO.IDATENDIMENTO = ATENDIMENTOPESSOA.IDATENDIMENTO 
                AND ATENDIMENTOPESSOA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA  
                AND PESSOADEPARA.IDPESSOA = PESSOADOCUMENTO.IDPESSOA 
                AND PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO 
                AND DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO 
                AND TIPODOCUMENTO.SGCLASSIFICACAO IN ('CPF','CNPJ'); 
 
            EXEC SQL OPEN curDocumentos; 
 
            EXEC SQL WHENEVER NOT FOUND DO BREAK; 
 
            while (true) 
            { 
                memset(&oStatusDocumentoProcesso,0,sizeof(oStatusDocumentoProcesso));
                i_nrAtendimentoAgrupado = -1;
                nrAtendimentoAgrupado = 0;
 
                EXEC SQL FETCH curDocumentos INTO :oDadosDocumentoProcesso:oStatusDocumentoProcesso; 
 
                EXEC SQL WHENEVER NOT FOUND CONTINUE; 
 
                EXEC SQL 
                    SELECT 
                        NRATENDIMENTOAGRUPADO 
                    INTO 
                        :nrAtendimentoAgrupado:i_nrAtendimentoAgrupado 
                    FROM 
                        ATENDIMENTO.ATENDIMENTOAGRUPADO 
                    WHERE 
                        IDDOCUMENTO = :oDadosDocumentoProcesso.idDocumento 
                    AND 
                        ROWNUM < 2; 
 
                    if ( sqlca.sqlcode ) 
                    { 
                        EXEC SQL 
                            SELECT 
                                ATENDIMENTOAGRUPADOSQ.NEXTVAL  
                            INTO  
                                :nrAtendimentoAgrupado:i_nrAtendimentoAgrupado
                            FROM 
                                DUAL; 
                        ULOG("Obtida nova sequence de ATENDIMENTO.ATENDIMENTOAGRUPADO"); 
                    } 
 
                ULOG("nrAtendimentoAgrupado=%d",nrAtendimentoAgrupado); 
                ULOG("idPessoa=%ld",oDadosDocumentoProcesso.idPessoa); 
                ULOG("idDocumento=%d",oDadosDocumentoProcesso.idDocumento); 
 
                // Insere o processo no contexto de associação 
                EXEC SQL 
                    INSERT INTO 
                        ATENDIMENTO.ATENDIMENTOAGRUPADO 
                            (NRATENDIMENTOAGRUPADO,IDATENDIMENTO,IDPESSOA,IDDOCUMENTO) 
                    VALUES 
                            (:nrAtendimentoAgrupado 
                            ,:oDados.dadosAtd->idAtendimento 
                            ,:oDadosDocumentoProcesso.idPessoa 
                            ,:oDadosDocumentoProcesso.idDocumento); 
            } 
 
            EXEC SQL CLOSE curDocumentos; 
        } // if ( iCount == 0 )
        else
        {
            ULOG("ja existe agrupamento para a mesma linha, inserção em ATENDIMENTOAGRUPADO ignorada."); 
        }
 
    } // se portout ... 
 
    ULOG_END("cRegPalitagemPC::registraTabelaPriorizacao()"); 
} 
 
void cRegPalitagemPC::gravarAtendimentoLinhas(long idAtendimento,Collection *atendimentoLinhas) 
{ 
    ULOG_START("cRegPalitagemPC::gravarAtendimentoLinhas()"); 
 
    EXEC SQL BEGIN DECLARE SECTION; 
 
        long listaIdAtendimento[TAM_MAX_BLC_ORA]; 
        char listaCdConta[TAM_MAX_BLC_ORA][101]; 
        char listaNrTelefone[TAM_MAX_BLC_ORA][13]; 
 
        int rows_to_insert; 
 
    EXEC SQL END DECLARE SECTION; 
 
    ULOG("Alteracao nono digito listaNrTelefone[TAM_MAX_BLC_ORA][11] para listaNrTelefone[TAM_MAX_BLC_ORA][13]"); 
 
    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegPalitagemPC(&sqlca); 
 
    int iCount = atendimentoLinhas->GetCount(); 
    int i=0, j=0; 
 
    ULOG("Foram enviadas %d linhas para associacao",iCount); 
 
    while ( i < iCount ) 
    { 
        memset(&listaIdAtendimento,0,sizeof(listaIdAtendimento)); 
        memset(&listaCdConta,0,sizeof(listaCdConta)); 
        memset(&listaNrTelefone,0,sizeof(listaNrTelefone)); 
 
        for ( j = 0; j < TAM_MAX_BLC_ORA; j++ ) 
        { 
            if ( i >= iCount ) { break; } 
 
            listaIdAtendimento[j] = idAtendimento; 
            SAFE_STRNCPY(listaCdConta[j],((AtendimentoLinhas*)atendimentoLinhas->GetItem(i))->cdConta); 
            SAFE_STRNCPY(listaNrTelefone[j],((AtendimentoLinhas*)atendimentoLinhas->GetItem(i))->nrTelefone); 
 
            i++; 
        } 
 
        if ( j )  
        { 
            ULOG("Vai inserir bloco com %d linhas em ATENDIMENTOLINHAS",j); 
 
            rows_to_insert = j; 
 
            EXEC SQL FOR :rows_to_insert 
                INSERT INTO 
                    ATENDIMENTO.ATENDIMENTOLINHAS 
                    ( 
                        IDATENDIMENTOLINHAS, 
                        IDATENDIMENTO, 
                        CDCONTA, 
                        NRTELEFONE 
                    ) 
                VALUES 
                    ( 
                        ATENDIMENTO.ATENDIMENTOLINHASSQ.NEXTVAL, 
                        :listaIdAtendimento, 
                        :listaCdConta, 
                        :listaNrTelefone 
                    ); 
        } 
    } 
 
    ULOG_END("cRegPalitagemPC::gravarAtendimentoLinhas()"); 
} 
 
void cRegPalitagemPC::gravarSmsProtocolo(long idAtendimento,int idContato,char *nrProtocolo 
                                      ,char *msgSMS,char *dataAtualSMS) 
{ 
    ULOG_START("cRegPalitagemPC::gravarSmsProtocolo()"); 
 
    EXEC SQL BEGIN DECLARE SECTION; 
 
        char *oraNrProtocolo = nrProtocolo; 

        long oraIdAtendimento = idAtendimento; 
        int oraIdContato = idContato; 
        int inSMS; 

        //VARCHAR dsSMS[51]; 
        //VARCHAR nmPath[2001]; 
        //VARCHAR dsMensagemEnvio[600]; 
        //short i_dsSMS = -1; 
        //short i_nmPath = -1;
        short i_inSMS = -1;
 
    EXEC SQL END DECLARE SECTION; 
 
    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegPalitagemPC(&sqlca); 
 
    EXEC SQL 
        SELECT 
            INSMS
           //,DSSMS 
        INTO 
            :inSMS:i_inSMS
            //,:dsSMS:i_dsSMS 
        FROM 
            CONTATOADM.CONTATOFOLHA CONTATOFOLHA 
        WHERE 
            IDCONTATO = :oraIdContato; 
 
    // se não encontrou a folha do contato, sai sem inserir na tabela de SMS ... 
    if ( sqlca.sqlcode )
    { 
        ULOGW(">>> Folha de contato %d não encontrada",idContato); 
        ULOG_START("cRegPalitagemPC::gravarSmsProtocolo()"); 
        return; 
    } 
 
    // se envio de sms = sim (1) então enfileira 
    if ( inSMS==1 ) 
    {
        // CONVIND(dsSMS,i_dsSMS); 
 
        // if ( (msgSMS && *msgSMS) ) 
        // { 
        //     strcpy((char*)dsSMS.arr,msgSMS); 
        //     dsSMS.len = strlen((char*)dsSMS.arr); 
        // } 
 
        // // Se não tem descrição incluida, aplica regra de obtenção de nós da árvore 
        // if ( *dsSMS.arr == 0 ) 
        // { 
        //     EXEC SQL 
        //         SELECT 
        //             NMPATH 
        //         INTO 
        //             :nmPath:i_nmPath 
        //         FROM 
        //             CONTATOADM.CONTATO 
        //         WHERE 
        //             IDCONTATO = :oraIdContato; 
        // 
        //     if ( sqlca.sqlcode == 0 ) 
        //     { 
        //         CONVIND(nmPath,i_nmPath); 
        // 
        //         obterDescricaoPath((char*)nmPath.arr,(char*)dsSMS.arr); 
        // 
        //         if ( *dsSMS.arr == 0 ) 
        //         { // se não conseguiu montar a mensagem obtém pelo nome da folha 
        //             EXEC SQL 
        //                 SELECT 
        //                     NOMECONTATO.NMCONTATO 
        //                 INTO 
        //                     :dsSMS:i_dsSMS 
        //                 FROM  
        //                     CONTATOADM.NOMECONTATO NOMECONTATO, 
        //                     CONTATOADM.CONTATO CONTATO 
        //                 WHERE 
        //                     CONTATO.IDCONTATO = :oraIdContato 
        //                 AND CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO; 
        //         } 
        // 
        //         dsSMS.arr[sizeof(dsSMS.arr)-1] = 0; 
        //         dsSMS.len = strlen((char*)dsSMS.arr); 
        //         i_dsSMS = 1; 
        //     } 
        // 
        //     if ( sqlca.sqlcode || *dsSMS.arr == 0 ) 
        //     { 
        //         throw new TuxException("04E0001","Não foi possivel montar mensagem SMS"); 
        //     } 
        } 
 
        // Monta mensagem de envio de acordo com a documentação 
        // sprintf((char*)dsMensagemEnvio.arr,"Vivo: Numero do protocolo: %s - %s - %s" 
        //             ,nrProtocolo,(char*)dsSMS.arr,dataAtualSMS);
 
        EXEC SQL 
            INSERT INTO 
                ATENDIMENTO.SMSPROTOCOLO 
                ( 
                    IDATENDIMENTO, 
                    IDATENDIMENTOPROTOCOLO, 
                    DSMENSAGEMENVIO, 
                    DSMENSAGEMOBS, 
                    DTENVIO, 
                    INESTADOSMS 
                ) 
            VALUES 
                ( 
                    :oraIdAtendimento, 
                    :oraNrProtocolo, 
                    ' ', //:dsMensagemEnvio (isso é montado pelo progr.de envio de SMS),
                    'CRIADO EM '||TO_CHAR(SYSDATE,'DD/MM/YYYY HH24:MI:SS'), //DSMENSAGEMOBS
                    NULL, 
                    0 
                ); 
    }
 
    ULOG_END("cRegPalitagemPC::gravarSmsProtocolo()"); 
} 
 
void cRegPalitagemPC::registraTerminalVOL(long * _idAtendimento, int* _idTerminal) 
{ 
    ULOG_START("cRegPalitagemPC::registraTerminalVOL()"); 
 
        EXEC SQL BEGIN DECLARE SECTION; 
 
        long idAtendimento = *_idAtendimento; 
        int idTerminal    = *_idTerminal; 
 
        EXEC SQL END DECLARE SECTION; 
 
        EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegPalitagemPC(&sqlca); 
 
    EXEC SQL 
        INSERT INTO 
            vol.AtendimentoTerminal 
            ( 
                idAtendimento, 
                idTerminal 
            ) 
        VALUES 
            ( 
                :idAtendimento, 
                :idTerminal 
            ); 
 
    ULOG_END("cRegPalitagemPC::registraTerminalVOL()"); 
} 

int cRegPalitagemPC::buscarRegional(int prefixoPrm)
{
    ULOG_START("cRegPalitagemPC::buscarRegional()");

    EXEC SQL BEGIN DECLARE SECTION;

        int   prefixo = prefixoPrm;
        int   idUFOperadora;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFcRegPalitagemPC(&sqlca);

    EXEC SQL
        SELECT 
            AR.IDUFOPERADORA
        INTO
            :idUFOperadora
        FROM 
            APOIO.AREAREGISTRO AR
           ,CUSTOMER.UFOPERADORA UFO
           ,CUSTOMER.PESSOADEPARA PDP
           ,CUSTOMER.PESSOA P
        WHERE 
            AR.IDUFOPERADORA = UFO.IDUFOPERADORA
        AND UFO.IDPESSOADEPARAOPERADORA = PDP.IDPESSOADEPARA
        AND PDP.IDPESSOA = P.IDPESSOA
        AND AR.CDAREAREGISTRO = :prefixo
        AND ROWNUM < 2;

    ULOG("idUFOperadora = [%d]",idUFOperadora);

    ULOG_END("cRegPalitagemPC::buscarRegional()");

    return sqlca.sqlcode == 0 ? idUFOperadora : -1;
}

bool cRegPalitagemPC::proCOperadoraNaoCliente( const int _idPessoaDePara, int *_idUFOperadoraNaoCliente )
{
    ULOG_START( "cRegPalitagemPC::proCOperadoraNaoCliente()" );

    bool retorno = false;

    EXEC SQL BEGIN DECLARE SECTION;

        int idPessoaDePara = _idPessoaDePara;
        int idUFOperadora;
        int inNaoCliente = 0;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegPalitagemPC(&sqlca);

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        SELECT
            UFOPERADORA.IDUFOPERADORA, 
            DECODE(PESSOA.IDPESSOA,26,1,0) AS NAO_CLIENTE
        INTO
            :idUFOperadora,
            :inNaoCliente
        FROM 
            CUSTOMER.UFOPERADORA UFOPERADORA,
            CUSTOMER.PESSOA PESSOA
        WHERE 
            UFOPERADORA.IDUF = PESSOA.IDUF
        AND PESSOA.IDPESSOA = :idPessoaDePara
        AND ROWNUM < 2;

    // Caso este seja o atendimento de um NÃO-CLIENTE, retornamos o UFOperadora do mesmo
    if( sqlca.sqlcode == 0 && inNaoCliente == 1 )
    {
        *_idUFOperadoraNaoCliente = idUFOperadora;
        retorno = true;
    }

    ULOG_END( "cRegPalitagemPC::proCOperadoraNaoCliente()" );

    return retorno;
}

bool cRegPalitagemPC::proCObterConsultorRelacionamento(const char *cdConta
                                                    ,const char *cdDigitoConta
                                                    ,const int idPessoaDeParaCliente
                                                    ,int *idPessoaConta)
{
    ULOG_START( "cRegPalitagemPC::proCObterConsultorRelacionamento()" );

    bool retorno = false;

    EXEC SQL BEGIN DECLARE SECTION;
        int parOraIdPessoaDeParaCliente = idPessoaDeParaCliente;
        const char *parOraCdConta = cdConta;
        const char *parOraCdDigitoConta = cdDigitoConta;

        VARCHAR varOraIdConta[101];
        short statOraIdConta = -1;

        int varOraIdPessoaConta;
        short statOraIdPessoaConta = -1;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegPalitagemPC(&sqlca);

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    // Busca a conta do cliente
    ULOG("Vai buscar conta do cliente idPessoaDePara=%d...",parOraIdPessoaDeParaCliente);
    EXEC SQL
        SELECT
            PESSOACONTA.IDCONTA
        INTO
            :varOraIdConta:statOraIdConta
        FROM
            CUSTOMER.PESSOACONTA PESSOACONTA,
            CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTO 
        WHERE
            PESSOACONTA.IDPESSOADEPARA = :parOraIdPessoaDeParaCliente
        AND PESSOACONTA.IDTIPORELACIONAMENTO = TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
        AND TIPORELACIONAMENTO.NMTIPORELACIONAMENTO = 'CLIENTE';

    if ( 0==sqlca.sqlcode )
    { // se o cliente possui conta, verifica se tem consultor de relacionamento
        CONVIND(varOraIdConta,statOraIdConta);

        ULOG("Vai buscar idPessoaConta para a conta %s...",varOraIdConta.arr);

        EXEC SQL
            SELECT
                PESSOACONTA.IDPESSOACONTA
            INTO
                :varOraIdPessoaConta:statOraIdPessoaConta
            FROM
                CUSTOMER.PESSOACONTA PESSOACONTA,
                CUSTOMER.PESSOADEPARA PESSOADEPARA,
                CUSTOMER.PESSOA PESSOA,
                ACESSO.USUARIO USUARIO,
                APOIO.STATUSUSUARIO STATUSUSUARIO,
                CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTO
            WHERE
                PESSOACONTA.IDCONTA = :varOraIdConta
            AND PESSOACONTA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA
            AND PESSOADEPARA.IDPESSOA = PESSOA.IDPESSOA
            AND PESSOA.IDPESSOA = USUARIO.IDPESSOAUSUARIO
            AND USUARIO.IDSTATUSUSUARIO = STATUSUSUARIO.IDSTATUSUSUARIO
            AND STATUSUSUARIO.SGSTATUSUSUARIO = 'ATIVO'
            AND PESSOACONTA.IDTIPORELACIONAMENTO = TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
            AND TIPORELACIONAMENTO.NMTIPORELACIONAMENTO = 'CONSULTOR RELACIONAMENTO';

        if ( 0==sqlca.sqlcode )
        {
            *idPessoaConta = varOraIdPessoaConta;
            retorno = true;
            ULOG("idPessoaConta para a conta %s=%d",varOraIdConta.arr,varOraIdPessoaConta);
        }
        else
        {
            ULOG("Consultor de relacionamento da conta %s não encontrado ou não ativo",varOraIdConta.arr);
        }
    }
    else
    {
        ULOG("Não encontrou conta para o cliente com idPessoaDePara=%d",parOraIdPessoaDeParaCliente);
    }

    ULOG_END( "cRegPalitagemPC::proCObterConsultorRelacionamento()" );

    return retorno;
}

void cRegPalitagemPC::registraErro(DOMNode *dnode,const char *_msgErro)
{
    ULOG_START("cRegPalitagemPC::registraErro()");

    char *p = tx.getNodeAsString(dnode);
    string valor = p;
    if ( p ) { free(p); }

    EXEC SQL BEGIN DECLARE SECTION;
        long idAtendimentoRegPalitagemErr;
        char idContato[21];
        char idCanal[21];
        char idGrupoAbertura[21];
        char idUsuarioBKO[21];
        char idProcedencia[21];
        char idSegmentacao[21];
        char idTipoCarteira[21];
        const char *xmlEntrada = valor.c_str();
        const char *msgErro = _msgErro;
    EXEC SQL END DECLARE SECTION;

    if ( dados->idContato )
    {
        sprintf(idContato,"%d",dados->idContato);
    }
    else
    {
        idContato[0] = 0;
    }

    if ( dados->idCanal )
    {
        sprintf(idCanal,"%d",dados->idCanal);
    }
    else
    {
        idCanal[0] = 0;
    }

    if ( dados->idGrupoAbertura )
    {
        sprintf(idGrupoAbertura,"%d",dados->idGrupoAbertura);
    }
    else
    {
        idGrupoAbertura[0] = 0;
    }

    if ( dados->idUsuarioBKO )
    {
        sprintf(idUsuarioBKO,"%d",dados->idUsuarioBKO);
    }
    else
    {
        idUsuarioBKO[0] = 0;
    }

    if ( dados->idProcedencia )
    {
        sprintf(idProcedencia,"%d",dados->idProcedencia);
    }
    else
    {
        idProcedencia[0] = 0;
    }

    if ( dados->idSegmentacao )
    {
        sprintf(idSegmentacao,"%d",dados->idSegmentacao);
    }
    else
    {
        idSegmentacao[0] = 0;
    }

    if ( dados->idTipoCarteira )
    {
        sprintf(idTipoCarteira,"%d",dados->idTipoCarteira);
    }
    else
    {
        idTipoCarteira[0] = 0;
    }

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegPalitagemPC(&sqlca);

    EXEC SQL
        SELECT ATENDIMENTO.ATENDIMENTOREGCONTATOERRSQ.NEXTVAL 
          INTO :idAtendimentoRegPalitagemErr
          FROM DUAL;

    ULOG("idAtendimentoRegPalitagemErr=%d",idAtendimentoRegPalitagemErr);
    ULOG("idContato=%s",idContato);
    ULOG("idCanal=%s",idCanal);
    ULOG("idGrupoAbertura=%s",idGrupoAbertura);
    ULOG("idUsuarioBKO=%s",idUsuarioBKO);
    ULOG("idProcedencia=%s",idProcedencia);
    ULOG("idSegmentacao=%s",idSegmentacao);
    ULOG("idTipoCarteira=%s",idTipoCarteira);
    ULOG("xmlEntrada=%s",xmlEntrada);
    ULOG("msgErro=%s",msgErro);

    EXEC SQL
        INSERT INTO
            ATENDIMENTO.ATENDIMENTOREGCONTATOERR
            (
                IDATENDIMENTOREGCONTATOERR,
                IDCONTATOERR,
                IDCANALERR,
                IDGRUPOABERTURAERR,
                IDPESSOAUSUARIOABERTURAERR,
                IDPROCEDENCIAERR,
                IDSEGMENTACAOERR,
                IDTIPOCARTEIRAERR,
                DTOCORRENCIA,
                XMLENTRADA,
                MENSAGEMERRO
            )
        VALUES
            (
                :idAtendimentoRegPalitagemErr,
                :idContato,
                :idCanal,
                :idGrupoAbertura,
                :idUsuarioBKO,
                :idProcedencia,
                :idSegmentacao,
                :idTipoCarteira,
                SYSDATE,
                :xmlEntrada,
                :msgErro
            );

    ULOG("sqlca.sqlcode=%d",sqlca.sqlcode);

    ULOG_END("cRegPalitagemPC::registraErro()");
}

bool cRegPalitagemPC::proCObterIdUserUra(const char *userNN,char *idPessoaUsuario)
{
    ULOG_START("cRegPalitagemPC::proCObterIdUserUra()");

    EXEC SQL BEGIN DECLARE SECTION;
        char paraOraNmLoginUsuario[256];
        VARCHAR varOraIdPessoaUsuario[256];
        short statOraIdPessoaUsuario = -1;

    EXEC SQL END DECLARE SECTION;

    sprintf(paraOraNmLoginUsuario,"ura%s",userNN);

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegPalitagemPC(&sqlca);

    EXEC SQL
        SELECT
            IDPESSOAUSUARIO
        INTO
            :varOraIdPessoaUsuario:statOraIdPessoaUsuario
        FROM
            ACESSO.USUARIO
        WHERE
            NMLOGINUSUARIO = :paraOraNmLoginUsuario;

    ULOG("(1) sqlca.sqlcode=%d",sqlca.sqlcode);

    if ( sqlca.sqlcode )
    {
        EXEC SQL
            SELECT
                IDPESSOAUSUARIO
            INTO
                :varOraIdPessoaUsuario:statOraIdPessoaUsuario
            FROM
                ACESSO.USUARIO
            WHERE
                NMLOGINUSUARIO = 'usuario URA';
    }

    ULOG("(2) sqlca.sqlcode=%d",sqlca.sqlcode);

    if ( sqlca.sqlcode )
    {
        ULOG_END("cRegPalitagemPC::proCObterIdUserUra() --> não encontrou usuário");
        return false;
    }

    strcpy(idPessoaUsuario,(char*)varOraIdPessoaUsuario.arr);

    ULOG_END("cRegPalitagemPC::proCObterIdUserUra()");

    return true;
}

bool cRegPalitagemPC::proCVerificarUserNumericoSimNao(const char *userNN)
{
    ULOG_START("cRegPalitagemPC::proCVerificarUserNumericoSimNao()");

    bool retorno = true;

    EXEC SQL BEGIN DECLARE SECTION;
        char paramOraCdParametro[256];
        VARCHAR varOraDsValorParametro[256];
        short statOraDsValorParametro = -1;
    EXEC SQL END DECLARE SECTION;

    sprintf(paramOraCdParametro,"REGC_NAOANALISAR_IDUSER_%s",userNN);

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFcRegPalitagemPC(&sqlca);

    EXEC SQL
        SELECT
            DSVALORPARAMETRO
        INTO
            :varOraDsValorParametro:statOraDsValorParametro
        FROM
            APOIO.PARAMETRO;

    ULOG("sqlca.sqlcode=%d",sqlca.sqlcode);

    if ( 0==sqlca.sqlcode )
    {
        CONVIND(varOraDsValorParametro,statOraDsValorParametro);

        ULOG("varOraDsValorParametro=%s",varOraDsValorParametro.arr);
        if ( strcmp((char*)varOraDsValorParametro.arr,"false")==0 )
        {
            retorno = false;
        }
    }

    ULOG("retorno=%d",retorno);

    ULOG_END("cRegPalitagemPC::proCVerificarUserNumericoSimNao()");

    return retorno;
}

void cRegPalitagemPC::sql_error_WFcRegPalitagemPC( sqlca * sqlca )
{
    ULOGE("sql_error_WFcRegPalitagemPC:sqlcode=%d,sqlerrmc=%.70s"
                            ,sqlca->sqlcode
                            ,sqlca->sqlerrm.sqlerrmc);

    throw new TuxBasicOraException(sqlca->sqlcode
                                  ,sqlca->sqlerrm.sqlerrmc
                                  ,sqlca->sqlerrm.sqlerrml);
}
 
//============================================================================== 
// Funções de apoio 
char *cRegPalitagemPC::obterDescricaoPath(char *stringIn, char *stringOut) 
{ 
    ULOG_START("cRegPalitagemPC::obterDescricaoPath()"); 
 
    char seps[] = "/"; 
    char *token; 
    int nivel = 1; 
    char stringTmp[2001]; 
 
    SAFE_STRNCPY(stringTmp,stringIn); 
 
    int niveis = 0; 
 
    token = strtok(stringTmp, seps); 
 
    while( token ) 
    { 
        niveis++; 
        token = strtok( NULL, seps ); 
    } 
 
    if ( stringOut ) 
    { 
        *stringOut = 0; 
 
        if ( niveis ) 
        { // tem path? 
            token = strtok(stringIn, seps); 
 
            while( token ) 
            { 
                nivel++; 
 
                token = strtok( NULL, seps ); 
 
                if ( niveis > 3 && (nivel < 2 || nivel > 3) ) { continue; } 
                if ( niveis == 3 && nivel < 3 ) { continue; } 
 
                if ( token ) 
                { 
                    if ( *stringOut ) { strcat(stringOut," "); } 
                    strcat(stringOut,token); 
                } 
            } 
        } 
    } 
 
    ULOG_END("cRegPalitagemPC::obterDescricaoPath()"); 
 
    return stringOut; 
} 
