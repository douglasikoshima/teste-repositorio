#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"
#include "../../../commons/Collection/include/Collection.h"
#include "../../../commons/msgPadrao.h"
#include "../../../commons/definesAtendimento.h"


#include "../include/cWFAtendimentoNivel.h"
#include "../include/stWFAtendimentoNivel.h"

void sql_error_WFAtendimentoNivel(sqlca*sqlca);

    // Declara as estruturas compatíveis ao ProC.
    EXEC SQL BEGIN DECLARE SECTION;
        #include "../include/stWFAtendimentoNivel.h"
    EXEC SQL END DECLARE SECTION;

long proCIncluirWFAtendimentoNivel(st_AtendimentoNivel* dados, st_vlAtendimentoNivel* status)
{
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        struct st_AtendimentoNivel *oDados = dados;
        struct st_vlAtendimentoNivel *oStatus = status;

        int varOraCount=0;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoNivel(&sqlca);

    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL
        SELECT
            COUNT(1)
        INTO
            :varOraCount
        FROM
            ATENDIMENTO.ATENDIMENTONIVEL
        WHERE
            IDATENDIMENTO = :oDados->idAtendimento
        AND IDGRUPO = :oDados->idGrupo
        AND IDFASE = :oDados->idFase
        AND IDATIVIDADE = :oDados->idAtividade
        AND NRNIVEL = :oDados->nrNivel;

    if ( 0==varOraCount )
    {
        EXEC SQL SELECT atendimento.AtendimentoNivelSQ.NEXTVAL INTO :oDados->idAtendimentoNivel FROM DUAL;

        EXEC SQL 
            INSERT INTO
                atendimento.AtendimentoNivel
                (
                    idAtendimentoNivel,
                    idAtendimento,
                    idGrupo,
                    idFase,
                    idAtividade,
                    nrNivel,
                    dtNivel,
                    inConcluido,
                    idUsuarioAlteracao,
                    dtUltimaAlteracao
                )
                VALUES
                (
                    :oDados->idAtendimentoNivel,
                    :oDados->idAtendimento,
                    :oDados->idGrupo,
                    :oDados->idFase,
                    :oDados->idAtividade,
                    :oDados->nrNivel,
                    TO_DATE(:oDados->dtNivel,'DD/MM/YYYY HH24:MI:SS'),
                    :oDados->inConcluido,
                    DECODE(:oStatus->idUsuarioAlteracao, -1, NULL, :oDados->idUsuarioAlteracao),
                    TO_DATE(DECODE(:oStatus->dtUltimaAlteracao, -1, NULL, :oDados->dtUltimaAlteracao),'DD/MM/YYYY HH24:MI:SS')
                );
        return oDados->idAtendimentoNivel;
    }

    return -1;
}

bool proCAlterarWFAtendimentoNivel(st_AtendimentoNivel* dados, st_vlAtendimentoNivel* status, XMLGen* saida)
{

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        struct st_AtendimentoNivel   oDados;
        struct st_vlAtendimentoNivel oStatus;

        char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoNivel(&sqlca);

    memcpy(&oDados,  dados,  sizeof(oDados));
    memcpy(&oStatus, status, sizeof(oStatus));

    sprintf(query,"%s", "UPDATE atendimento.AtendimentoNivel SET ");

    bool separa = false;

    if (status->idAtendimento != -1) 
        montaUpdate("idAtendimento", oDados.idAtendimento, 1);

    if (status->idGrupo != -1) 
        montaUpdate("idGrupo", oDados.idGrupo, 1);

    if (status->idFase != -1) 
        montaUpdate("idFase", oDados.idFase, 1);

    if (status->idAtividade != -1) 
        montaUpdate("idAtividade", oDados.idAtividade, 1);

    if (status->idUsuarioAlteracao != -1) 
        montaUpdate("idUsuarioAlteracao", oDados.idUsuarioAlteracao, TIPO_INT);

    if (status->dtUltimaAlteracao != -1) 
        montaUpdate("dtUltimaAlteracao", oDados.dtUltimaAlteracao, TIPO_DATAHORA);

    sprintf(query, "%s WHERE idAtendimentoNivel = %ld", query, dados->idAtendimentoNivel);

    EXEC SQL EXECUTE IMMEDIATE :query;

    return true;
}

bool proCExcluirWFAtendimentoNivel(st_AtendimentoNivel* dados, st_vlAtendimentoNivel* status, XMLGen* saida)
{

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimentoNivel = dados->idAtendimentoNivel;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoNivel(&sqlca);

    EXEC SQL 
        DELETE
            atendimento.AtendimentoNivel
        WHERE
            idAtendimentoNivel = :idAtendimentoNivel;

    return true;
}

bool proCConcluirWFAtendimentoNivel(st_AtendimentoNivel* dados, st_vlAtendimentoNivel* status, XMLGen* saida)
{

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = dados->idAtendimento;
        int idFase = dados->idFase;


    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoNivel(&sqlca);

    EXEC SQL 
        UPDATE
            atendimento.AtendimentoNivel
        SET
            inConcluido = 1
        WHERE
            idAtendimento = :idAtendimento
        AND idFase >= :idFase;

    return true;
}

bool proCConsultaWFAtendimentoNivel(st_AtendimentoNivel* dados, st_vlAtendimentoNivel* status, char* order, XMLGen* saida)
{

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimentoNivel;
        long idAtendimento;
        int idGrupo;
        int idFase;
        int idAtividade;
        int idUsuarioAlteracao;
        VARCHAR dtUltimaAlteracao[256];

        short i_idUsuarioAlteracao;
        short i_dtUltimaAlteracao;

        short i_idGrupo;
        short i_idFase;
        short i_idAtividade;

        char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoNivel(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    sprintf(query,"SELECT idAtendimentoNivel, idAtendimento, idGrupo, idFase, idAtividade, idUsuarioAlteracao, TO_CHAR(dtUltimaAlteracao, 'DD/MM/YYYY HH24:MI') AS dtUltimaAlteracao FROM atendimento.AtendimentoNivel ");

    bool separa = false;

    if (status->idAtendimentoNivel != -1) 
        montaWhere("idAtendimentoNivel", dados->idAtendimentoNivel, 1);

    if (status->idAtendimento != -1)
        montaWhere("idAtendimento", dados->idAtendimento, 1);

    if (status->idGrupo != -1)
        montaWhere("idGrupo", dados->idGrupo, 1);

    if (status->idFase != -1)
        montaWhere("idFase", dados->idFase, 1);

    if (status->idAtividade != -1)
        montaWhere("idAtendimento", dados->idAtendimento, 1);

    if (status->idUsuarioAlteracao != -1) 
        montaWhere("idUsuarioAlteracao", dados->idUsuarioAlteracao, TIPO_INT);

    if (status->dtUltimaAlteracao != -1) 
        montaWhere("dtUltimaAlteracao", dados->dtUltimaAlteracao, TIPO_DATAHORA);

    if (strlen(order) > 0) 
        sprintf( query, "%s ORDER BY %s ", query, order);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoNivel(&sqlca);

    EXEC SQL PREPARE consultaAtendimentoNivel FROM :query;
    EXEC SQL DECLARE consulta CURSOR FOR consultaAtendimentoNivel;

    EXEC SQL OPEN consulta;

    while (true)
    {
        EXEC SQL FETCH consulta INTO 
                                    :idAtendimentoNivel, 
                                    :idAtendimento,
                                    :idGrupo:i_idGrupo,
                                    :idFase:i_idFase,
                                    :idAtividade:i_idAtividade,
                                    :idUsuarioAlteracao:i_idUsuarioAlteracao,
                                    :dtUltimaAlteracao:i_dtUltimaAlteracao;

        CONVIND(dtUltimaAlteracao, i_dtUltimaAlteracao);

        saida->createTag("WFAtendimentoNivelVO");
            saida->addItem("idAtendimentoNivel", idAtendimentoNivel);
            saida->addItem("idAtendimento", idAtendimento);
            saida->addItem("idGrupo", idGrupo);
            saida->addItem("idFase", idFase);
            saida->addItem("idAtividade", idAtividade);
            saida->addItem("idUsuarioAlteracao", idUsuarioAlteracao);
            saida->addItem("dtUltimaAlteracao", (char*)dtUltimaAlteracao.arr);
        saida->closeTag();
    }

    EXEC SQL CLOSE consulta;

    return true;

}

bool proCObtemWFNivelAtendimento(long sIdAtendimento, int sIdFase, XMLGen* saida)
{

    struct sqlca sqlca;
    
    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = sIdAtendimento;
        int  idFase = sIdFase;
        int  idGrupo;
        int  nrNivel;
        VARCHAR nmGrupo[256];
        int  idAtividade;
        VARCHAR dsAtividade[256];

        short i_idGrupo;
        short i_nrNivel;
        short i_nmGrupo;
        short i_idAtividade;
        short i_dsAtividade;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoNivel(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    // =========================================================================
    // A query abaixo utilizava a view ATENDIMENTO.ATENDIMENTONIVELV01.
    // Esta view foi desativada por ser usada apenas neste ponto do sistema
    // Fev/2007 - Cassio
    EXEC SQL DECLARE consultaNivelAtendimento CURSOR FOR
        SELECT 
            ATENDIMENTONIVEL.IDGRUPO,
            ATENDIMENTONIVEL.NRNIVEL,
            GRUPO.NMGRUPO,
            ATIVIDADE.IDATIVIDADE,
            ATIVIDADE.DSATIVIDADE
        FROM
            ATENDIMENTO.ATENDIMENTONIVEL ATENDIMENTONIVEL,
            ACESSO.GRUPO GRUPO,
            WORKFLOW.ATIVIDADE ATIVIDADE
        WHERE
            ATENDIMENTONIVEL.IDGRUPO = GRUPO.IDGRUPO
        AND ATENDIMENTONIVEL.IDATIVIDADE = ATIVIDADE.IDATIVIDADE
        AND ATENDIMENTONIVEL.IDATENDIMENTO = :idAtendimento
        AND ATENDIMENTONIVEL.IDFASE = :idFase
        AND NVL(ATENDIMENTONIVEL.INCONCLUIDO,0) = 0
        ORDER BY
            ATENDIMENTONIVEL.DTULTIMAALTERACAO;

    EXEC SQL OPEN consultaNivelAtendimento;

    while (true)
    {
        EXEC SQL FETCH consultaNivelAtendimento INTO
            :idGrupo:i_idGrupo,
            :nrNivel:i_nrNivel,
            :nmGrupo:i_nmGrupo,
            :idAtividade:i_idAtividade,
            :dsAtividade:i_dsAtividade;

        CONVIND(nmGrupo, i_nmGrupo);
        CONVIND(dsAtividade, i_dsAtividade);

        saida->createTag("NivelVO");

            saida->addItem("idGrupo", idGrupo);
            saida->addItem("nrNivel", nrNivel);
            saida->addItem("nmGrupo", (char *)nmGrupo.arr);
            saida->addItem("idAtividade", idAtividade);
            saida->addItem("dsAtividade", (char *)dsAtividade.arr);
            saida->addItem("status", "0");

        saida->closeTag();

    }

    EXEC SQL CLOSE consultaNivelAtendimento;

    return true;

}

bool proCObtemWFHistoricoNivelAtendimento(long sIdAtendimento,int sIdFase,int sIdFaseAtual,XMLGen* saida)
{
    struct sqlca sqlca;
    
    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = sIdAtendimento;
        int  idFase = sIdFase;
        int  idGrupo;
        int  nrNivel=0;
        VARCHAR nmGrupo[256];
        int  idAtividade=0;
        VARCHAR dsAtividade[256];

        short i_idGrupo;
        short i_nrNivel;
        short i_nmGrupo;
        short i_idAtividade;
        short i_dsAtividade;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoNivel(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE cursorNivelAtendimento CURSOR FOR
        SELECT
             TEMP1.IDGRUPO
            ,TEMP1.NMGRUPO 
            ,TEMP1.DSATIVIDADE
            ,TEMP1.DTULTIMAALTERACAO 
        FROM
        (           
            SELECT
                 TEMP0.IDGRUPO
                ,TEMP0.NMGRUPO 
                ,TEMP0.DSATIVIDADE
                ,MAX(TEMP0.DTULTIMAALTERACAO) AS DTULTIMAALTERACAO 
            FROM
            (   
                SELECT 
                     AN.IDGRUPO
                    ,GRUPO.NMGRUPO
                    ,ATIVIDADE.DSATIVIDADE
                    ,AN.DTULTIMAALTERACAO 
                FROM
                     ATENDIMENTO.ATENDIMENTONIVEL AN
                    ,ACESSO.GRUPO GRUPO
                    ,WORKFLOW.ATIVIDADE ATIVIDADE
                WHERE
                     GRUPO.IDGRUPO = AN.IDGRUPO
                AND  ATIVIDADE.IDATIVIDADE=AN.IDATIVIDADE
                AND  AN.IDATENDIMENTO = :idAtendimento
                AND  AN.IDFASE = :idFase
                AND (AN.INCONCLUIDO IS NULL OR AN.INCONCLUIDO = 0)
            ) TEMP0
            GROUP BY
                 TEMP0.IDGRUPO
                ,TEMP0.NMGRUPO
                ,TEMP0.DSATIVIDADE
        ) TEMP1
        GROUP BY
             TEMP1.IDGRUPO
            ,TEMP1.NMGRUPO 
            ,TEMP1.DSATIVIDADE
            ,TEMP1.DTULTIMAALTERACAO 
        ORDER BY    
              TEMP1.DTULTIMAALTERACAO;
    //
    // Esta versão de query repete as ações pois considera o idAtividade
    //
    //    SELECT
    //         TEMP1.IDGRUPO
    //        ,TEMP1.NRNIVEL
    //        ,GRUPO.NMGRUPO 
    //        ,TEMP1.IDATIVIDADE
    //        ,ATIVIDADE.DSATIVIDADE
    //        ,TEMP1.DTULTIMAALTERACAO 
    //    FROM
    //    (           
    //        SELECT
    //             TEMP0.IDGRUPO
    //            ,TEMP0.NRNIVEL 
    //            ,TEMP0.IDATIVIDADE
    //            ,MAX(TEMP0.DTULTIMAALTERACAO) AS DTULTIMAALTERACAO 
    //        FROM
    //        (   
    //            SELECT 
    //                 AN.IDATENDIMENTO
    //                ,AN.IDFASE
    //                ,AN.IDATENDIMENTONIVEL
    //                ,AN.INCONCLUIDO
    //                ,AN.IDGRUPO
    //                ,AN.NRNIVEL 
    //                ,AN.IDATIVIDADE
    //                ,AN.DTULTIMAALTERACAO 
    //            FROM 
    //                 ATENDIMENTO.ATENDIMENTONIVEL AN
    //            WHERE
    //                 AN.IDATENDIMENTO = :idAtendimento
    //            AND  AN.IDFASE = :idFase
    //            AND (AN.INCONCLUIDO IS NULL OR AN.INCONCLUIDO = 0)
    //        ) TEMP0
    //        GROUP BY
    //             TEMP0.IDGRUPO
    //            ,TEMP0.NRNIVEL 
    //            ,TEMP0.IDATIVIDADE
    //    ) TEMP1,
    //      ACESSO.GRUPO GRUPO,
    //      WORKFLOW.ATIVIDADE ATIVIDADE
    //    WHERE
    //         GRUPO.IDGRUPO = TEMP1.IDGRUPO
    //    AND
    //         ATIVIDADE.IDATIVIDADE=TEMP1.IDATIVIDADE  
    //    ORDER BY    
    //          TEMP1.DTULTIMAALTERACAO;

    EXEC SQL OPEN cursorNivelAtendimento;

    while (true)
    {
        i_idGrupo=i_nrNivel=i_nmGrupo=i_idAtividade=i_dsAtividade=-1;

        EXEC SQL FETCH cursorNivelAtendimento INTO
            :idGrupo:i_idGrupo,
            :nmGrupo:i_nmGrupo,
            :dsAtividade:i_dsAtividade;

        CONVIND(nmGrupo, i_nmGrupo);
        CONVIND(dsAtividade, i_dsAtividade);

        saida->createTag("NivelVO");
            saida->addItem("idGrupo", idGrupo);
            saida->addItem("nmGrupo", (char *)nmGrupo.arr);
            saida->addItem("idAtividade", idAtividade);
            saida->addItem("dsAtividade", (char *)dsAtividade.arr);
            saida->addItem("status", "0");
        saida->closeTag();
    }

    EXEC SQL CLOSE cursorNivelAtendimento;

    //if ( idFase != TRATAMENTO || sIdFaseAtual != RETORNO )
    //{
        // Exibe o grupo atual do processo para as fases de TRATAMENTO e RETORNO
        if ( idFase == sIdFaseAtual )
        {
            i_idGrupo=i_nmGrupo=-1;

            EXEC SQL WHENEVER NOT FOUND CONTINUE;

            // ==> Remodelagem Atendimento--Fev/2007--Cassio 
            // EXEC SQL
            //     SELECT
            //          GRUPO.IDGRUPO
            //         ,GRUPO.NMGRUPO
            //     INTO
            //         :idGrupo:i_idGrupo,
            //         :nmGrupo:i_nmGrupo
            //     FROM
            //         ATENDIMENTO.ATENDIMENTOGRUPOATUAL ATENDIMENTOGRUPOATUAL
            //        ,ACESSO.GRUPO GRUPO
            //     WHERE
            //         ATENDIMENTOGRUPOATUAL.IDATENDIMENTO = :idAtendimento
            //     AND GRUPO.IDGRUPO = ATENDIMENTOGRUPOATUAL.IDGRUPO;

            EXEC SQL
                SELECT
                     GRUPO.IDGRUPO
                    ,GRUPO.NMGRUPO
                INTO
                    :idGrupo:i_idGrupo,
                    :nmGrupo:i_nmGrupo
                FROM
                    ATENDIMENTO.ATENDIMENTO ATENDIMENTO
                   ,ACESSO.GRUPO GRUPO
                WHERE
                    ATENDIMENTO.IDATENDIMENTO = :idAtendimento
                AND GRUPO.IDGRUPO = ATENDIMENTO.IDGRUPOATUAL;

            CONVIND(nmGrupo, i_nmGrupo);

            if ( !sqlca.sqlcode )
            {
                saida->createTag("NivelVO");
                    saida->addItem("idGrupo", idGrupo);
                    saida->addItem("nmGrupo", (char *)nmGrupo.arr);
                    saida->addItem("idAtividade", "");
                    saida->addItem("dsAtividade", "");
                    saida->addItem("status", 1);
                saida->closeTag();
            }
        }
    //}

    return true;
}


bool proCObtemWFHistoricoNivelAtendimentoMC1(long sIdAtendimento,XMLGen* saida)
{
    ULOG_START("proCObtemWFHistoricoNivelAtendimentoMC1()");

    struct sqlca sqlca;
    
    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = sIdAtendimento;
        int idGrupo;
        VARCHAR nmGrupo[256];

        short i_idGrupo=-1;
        short i_nmGrupo=-1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoNivel(&sqlca);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        SELECT
             GRUPO.IDGRUPO,
             GRUPO.NMGRUPO
        INTO
            :idGrupo:i_idGrupo,
            :nmGrupo:i_nmGrupo
        FROM
            ATENDIMENTO.ATENDIMENTO ATENDIMENTO
           ,ACESSO.GRUPO GRUPO
        WHERE
            ATENDIMENTO.IDATENDIMENTO = :idAtendimento
        AND GRUPO.IDGRUPO = ATENDIMENTO.IDGRUPOABERTURA;

    ULOG("sqlcode=%d",sqlca.sqlcode);

    if ( !sqlca.sqlcode )
    {
        CONVIND(nmGrupo,i_nmGrupo);

        saida->createTag("NivelVO");
            saida->addItem("idGrupo", idGrupo);
            saida->addItem("nmGrupo", (char *)nmGrupo.arr);
            saida->addItem("idAtividade", "");
            saida->addItem("dsAtividade", "");
            saida->addItem("status", 2);
        saida->closeTag();
    }

    ULOG_END("proCObtemWFHistoricoNivelAtendimentoMC1()");

    return true;
}


bool proCObtemWFHistoricoNivelAtendimentoEx(long sIdAtendimento,int sIdFase,int sIdFaseAtual,XMLGen* saida)
{
    struct sqlca sqlca;
    
    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = sIdAtendimento;
        int  idFase = sIdFase;
        int  idGrupo;
        int  nrNivel=0;
        VARCHAR nmGrupo[256];
        int  idAtividade=0;
        VARCHAR dsAtividade[256];

        short i_idGrupo;
        short i_nrNivel;
        short i_nmGrupo;
        short i_idAtividade;
        short i_dsAtividade;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoNivel(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE cursorNivelAtendimentoEx CURSOR FOR
    SELECT
         TEMP1.IDGRUPO
        ,TEMP1.NMGRUPO 
        ,TEMP1.DSATIVIDADE
        ,TEMP1.DTULTIMAALTERACAO 
    FROM
    (           
        SELECT
             TEMP0.IDGRUPO
            ,TEMP0.NMGRUPO 
            ,TEMP0.DSATIVIDADE
            ,MAX(TEMP0.DTULTIMAALTERACAO) AS DTULTIMAALTERACAO 
        FROM
        (   
            SELECT 
                 AN.IDGRUPO
                ,GRUPO.NMGRUPO
                ,ATIVIDADE.DSATIVIDADE
                ,NULL AS DTULTIMAALTERACAO 
            FROM
                 FOHIST_OW.ATENDIMENTONIVEL AN
                ,ACESSO.GRUPO GRUPO
                ,WORKFLOW.ATIVIDADE ATIVIDADE
            WHERE
                 GRUPO.IDGRUPO = AN.IDGRUPO
            AND  ATIVIDADE.IDATIVIDADE=AN.IDATIVIDADE
            AND  AN.IDATENDIMENTO = :idAtendimento
            AND  AN.IDFASE = :idFase
            AND (AN.INCONCLUIDO IS NULL OR AN.INCONCLUIDO = 0)
        ) TEMP0
        GROUP BY
             TEMP0.IDGRUPO
            ,TEMP0.NMGRUPO
            ,TEMP0.DSATIVIDADE
    ) TEMP1
    GROUP BY
         TEMP1.IDGRUPO
        ,TEMP1.NMGRUPO 
        ,TEMP1.DSATIVIDADE
        ,TEMP1.DTULTIMAALTERACAO 
    ORDER BY    
          TEMP1.DTULTIMAALTERACAO;

    EXEC SQL OPEN cursorNivelAtendimentoEx;

    while (true)
    {
        i_idGrupo=i_nrNivel=i_nmGrupo=i_idAtividade=i_dsAtividade=-1;

        EXEC SQL FETCH cursorNivelAtendimentoEx INTO
            :idGrupo:i_idGrupo,
            :nmGrupo:i_nmGrupo,
            :dsAtividade:i_dsAtividade;

        CONVIND(nmGrupo, i_nmGrupo);
        CONVIND(dsAtividade, i_dsAtividade);

        saida->createTag("NivelVO");
            saida->addItem("idGrupo", idGrupo);
            saida->addItem("nmGrupo", (char *)nmGrupo.arr);
            saida->addItem("idAtividade", idAtividade);
            saida->addItem("dsAtividade", (char *)dsAtividade.arr);
            saida->addItem("status", "0");
        saida->closeTag();
    }

    EXEC SQL CLOSE cursorNivelAtendimentoEx;

    if ( idFase == sIdFaseAtual )
    {
        i_idGrupo=i_nmGrupo=-1;

        EXEC SQL WHENEVER NOT FOUND CONTINUE;

        EXEC SQL
            SELECT
                 ATENDIMENTO.IDGRUPOATUAL
                ,ATENDIMENTO.NMGRUPOATUAL
            INTO
                :idGrupo:i_idGrupo,
                :nmGrupo:i_nmGrupo
            FROM
                FOHIST_OW.ATENDIMENTO ATENDIMENTO
            WHERE
                ATENDIMENTO.IDATENDIMENTO = :idAtendimento;

        CONVIND(nmGrupo, i_nmGrupo);

        if ( !sqlca.sqlcode )
        {
            saida->createTag("NivelVO");
                saida->addItem("idGrupo", idGrupo);
                saida->addItem("nmGrupo", (char *)nmGrupo.arr);
                saida->addItem("idAtividade", "");
                saida->addItem("dsAtividade", "");
                saida->addItem("status", 1);
            saida->closeTag();
        }
    }

    return true;
}



bool proCObtemWFNivelGrAt(long sIdAtendimento, int sNrNivel, XMLGen* saida, int *contadorLinhas)
{

    struct sqlca sqlca;

    int numLinhas = 0;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = sIdAtendimento;
        int  nrNivel = sNrNivel;
        int  idGrupo;
        VARCHAR nmGrupo[256];
        
        short i_idGrupo;
        short i_nmGrupo;
 
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoNivel(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;


    EXEC SQL DECLARE consultaNivelGrAt CURSOR FOR
    SELECT 
        IDGRUPOATUAL,
        NMGRUPO
    FROM
	(SELECT 
		IDGRUPOATUAL,
	        NMGRUPO
	FROM 
		WORKFLOW.WFCONCLUIRANALISEV01
	WHERE 
		IDATENDIMENTO = :idAtendimento
		AND (NRNIVEL = :nrNivel OR -1 = :nrNivel)
	ORDER BY
		NRNIVEL, SQORDEM)
    WHERE ROWNUM <= 1;
    
    EXEC SQL OPEN consultaNivelGrAt;

    while (true)
    {
        EXEC SQL FETCH consultaNivelGrAt INTO
            :idGrupo:i_idGrupo,
            :nmGrupo:i_nmGrupo;
                        
        CONVIND(nmGrupo, i_nmGrupo);

        saida->createTag("NivelVO");
    
            saida->addItem("idGrupo", idGrupo);
            saida->addItem("nmGrupo", (char *)nmGrupo.arr);
            saida->addItem("idAtividade", "");
            saida->addItem("dsAtividade", "");
            saida->addItem("status", "2");
            
        saida->closeTag();

        if ( contadorLinhas ) { numLinhas++; }

    }

    EXEC SQL CLOSE consultaNivelGrAt;
    if ( contadorLinhas )    
	*contadorLinhas = numLinhas;

    return true;

}

bool proCObtemWFNivelGrAt(long sIdAtendimento, Collection* _grupos)
{
    ULOG_START( "proCObtemWFNivelGrAt()" );

    char *p;
    struct sqlca sqlca;
    
    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = sIdAtendimento;
        VARCHAR idGrupo[256];
        
        short i_idGrupo;
 
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoNivel(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;


    EXEC SQL DECLARE consultaNivelGrProxNivel CURSOR FOR
	SELECT 
		IDGRUPOATUAL
	FROM 
		WORKFLOW.WFCONCLUIRANALISEV01
	WHERE 
		IDATENDIMENTO = :idAtendimento
	ORDER BY
		NRNIVEL, SQORDEM;
    
    EXEC SQL OPEN consultaNivelGrProxNivel;

    while (true)
    {
        EXEC SQL FETCH consultaNivelGrProxNivel INTO
            :idGrupo:i_idGrupo;
                        
        CONVIND(idGrupo, i_idGrupo);

            if ( strlen((char*)idGrupo.arr) )
            {
                if ( p = new char[strlen((char*)idGrupo.arr)+1],p  )
                {
                    strcpy(p,(char*)idGrupo.arr);
                    _grupos->AddItem( (void*) p );
                }
                else
                {
                    ULOGE("Erro de alocacao de memoria");
                }
            }

    }

    EXEC SQL CLOSE consultaNivelGrProxNivel;

    ULOG_END( "proCObtemWFNivelGrAt()" );

    return true;

}

bool proCObtemWFNivelContato(int sIdContato, int sIdFase, XMLGen* saida)
{
    bool retorno = false;
    struct sqlca sqlca;
    
    EXEC SQL BEGIN DECLARE SECTION;

        int  idFase = sIdFase;
        int  idContato = sIdContato;
        int  idGrupo;
        VARCHAR nmGrupo[256];
        
        short i_idGrupo;
        short i_nmGrupo;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoNivel(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE consultaNivelContato CURSOR FOR
    SELECT 
        IDGRUPO,
        NMGRUPO
    FROM 
	    (SELECT 
		    IDGRUPO,
		    NMGRUPO
	    FROM 
		    ATENDIMENTO.SEQUENCIAV01
	    WHERE 
		    IDCONTATO = :idContato
		AND IDTIPOSEQUENCIA = :idFase
	    ORDER BY SQORDEM
        )
    WHERE ROWNUM <= 1;
    
    EXEC SQL OPEN consultaNivelContato;

    while (true)
    {
        i_idGrupo = i_nmGrupo = -1;

        EXEC SQL FETCH consultaNivelContato INTO
            :idGrupo:i_idGrupo,
            :nmGrupo:i_nmGrupo;
                        
        CONVIND(nmGrupo, i_nmGrupo);

        saida->createTag("NivelVO");
    
            saida->addItem("idGrupo", idGrupo);
            saida->addItem("nmGrupo", (char *)nmGrupo.arr);
            saida->addItem("idAtividade", "");
            saida->addItem("dsAtividade", "");
            saida->addItem("status", "2");
            
        saida->closeTag();

        retorno = true;
    }

    EXEC SQL CLOSE consultaNivelContato;

    return retorno;
}

void sql_error_WFAtendimentoNivel(sqlca*sqlca)
{
    throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
