#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../../../commons/queryMacro.h"
#include "../../../commons/msgPadrao.h"


#include "../include/cWFAtendimentoFechamento.h"
#include "../include/stWFAtendimentoFechamento.h"

void sql_error_WFAtendimentoFechamento(sqlca*sqlca);

    // Declara as estruturas compatíveis ao ProC.
    EXEC SQL BEGIN DECLARE SECTION;
        #include "../include/stWFAtendimentoFechamento.h"
    EXEC SQL END DECLARE SECTION;

long proCIncluirWFAtendimentoFechamento(st_AtendimentoFechamento* dados, st_vlAtendimentoFechamento* status, XMLDPR *xmlDpr)
{

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        struct st_AtendimentoFechamento   *oDados = dados;
        struct st_vlAtendimentoFechamento *oStatus = status;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoFechamento(&sqlca);

    if ( -1 == oStatus->dtFechamento )
    {
        EXEC SQL
            SELECT SYSDATE INTO :oDados->dtFechamento FROM DUAL;
    }

    // ==> Remodelagem Atendimento--Fev/2007--Cassio 
    // EXEC SQL 
    //  INSERT INTO
    //      atendimento.AtendimentoFechamento
    //      (
    //          idAtendimento,
    //          dtFechamento,
    //          idAndamento,
    //          idPessoaUsuario,
    //          idUsuarioAlteracao,
    //          dtUltimaAlteracao
    //      )
    //      VALUES
    //      (
    //          :oDados->idAtendimento,
    //           TO_DATE(:oDados->dtFechamento,'DD/MM/YYYY HH24:MI:SS'),
    //          :oDados->idAndamento,
    //          :oDados->idPessoaUsuario,
    //          :oDados->idPessoaUsuario,
    //           SYSDATE
    //      );

    // ==> Remodelagem Atendimento--Fev/2007--Cassio
    //
    // Esta tabela não é usada no sistema de FO, existem apenas
    // rotinas e métodos que executam INSERT/DELETE/UPDATE
    // nesta tabela, mas os dados persistidos nunca são usados
    //
    // EXEC SQL 
    //  DELETE
    //      atendimento.AtendimentoContatoLinha
    //  WHERE
    //      idAtendimento = :oDados->idAtendimento;

    // ==> Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
    // Versão piloto. Nesta versão devido a data de entrega muito próxima
    // estou apenas atualizando os campos novos que foram desnormalizados
    // junto com as tabelas respectivas para em uma segunda versão, com mais
    // tempo poder criar métodos especificos e mais rápidos para a atualização
    // destes campos em objetos respectivos às tabelas sendo atualizadas->
    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTO
        SET
            DTFECHAMENTO = TO_DATE(:oDados->dtFechamento,'DD/MM/YYYY HH24:MI:SS'),
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :oDados->idAtendimento;
    // <== Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio

    // ==> SM324--DPR--DEZ/2006--Cassio
    if ( xmlDpr )
    {
        AtendimentoFechamentoDPR atendimentofechamentodpr;

        atendimentofechamentodpr.setIdAtendimento(oDados->idAtendimento);
        atendimentofechamentodpr.setIdAndamento(oDados->idAndamento);
        atendimentofechamentodpr.setDtFechamento(oDados->dtFechamento);
        atendimentofechamentodpr.setIdPessoaUsuario(oDados->idPessoaUsuario);
        atendimentofechamentodpr.setOpCode(OPCODE_INSERT);

        xmlDpr->atendimentofechamentovo.inserir(&atendimentofechamentodpr);
    }
    // <== SM324--DPR--DEZ/2006--Cassio

    return oDados->idAtendimento;
}

bool proCAlterarWFAtendimentoFechamento(st_AtendimentoFechamento* dados, st_vlAtendimentoFechamento* status, XMLGen* saida)
{

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        struct st_AtendimentoFechamento   oDados;
        struct st_vlAtendimentoFechamento oStatus;

        char query[800];

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoFechamento(&sqlca);

    memcpy(&oDados,  dados,  sizeof(oDados));
    memcpy(&oStatus, status, sizeof(oStatus));

    sprintf(query,"%s", "UPDATE atendimento.AtendimentoFechamento SET ");

    bool separa = false;

    if (status->dtFechamento != -1)
        montaUpdate("dtFechamento", oDados.dtFechamento, 4);

    if (status->idPessoaUsuario != -1) 
        montaUpdate("idPessoaUsuario", oDados.idPessoaUsuario, 1);

    sprintf(query, "%s WHERE idAtendimento = %ld", query, dados->idAtendimento);

    EXEC SQL EXECUTE IMMEDIATE :query;

    return true;
}

bool proCExcluirWFAtendimentoFechamento(st_AtendimentoFechamento* dados, st_vlAtendimentoFechamento* status, XMLGen* saidam, XMLDPR *xmlDpr)
{
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento = dados->idAtendimento;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoFechamento(&sqlca);

    // ==> Remodelagem Atendimento--Fev/2007--Cassio 
    // EXEC SQL 
    //     DELETE
    //         atendimento.AtendimentoFechamento
    //     WHERE
    //         idAtendimento = :idAtendimento;

    // ==> Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio
    // Versão piloto. Nesta versão devido a data de entrega muito próxima
    // estou apenas atualizando os campos novos que foram desnormalizados
    // junto com as tabelas respectivas para em uma segunda versão, com mais
    // tempo poder criar métodos especificos e mais rápidos para a atualização
    // destes campos em objetos respectivos às tabelas sendo atualizadas->
    EXEC SQL
        UPDATE
            ATENDIMENTO.ATENDIMENTO
        SET
            DTFECHAMENTO = NULL,
            DTULTIMAALTERACAO = SYSDATE
        WHERE
            IDATENDIMENTO = :idAtendimento;
    // <== Remodelagem de ATENDIMENTO.ATENDIMENTO - Fev/2007 - Cassio

    // ==> SM324--DPR--DEZ/2006--Cassio
    if ( xmlDpr )
    {
        AtendimentoFechamentoDPR atendimentofechamentodpr;

        atendimentofechamentodpr.setIdAtendimento(idAtendimento);
        //atendimentofechamentodpr.setIdAndamento(oDados.idAndamento);
        //atendimentofechamentodpr.setDtFechamento(oStatus.dtFechamento==-1?sysDate:oDados.dtFechamento);
        //atendimentofechamentodpr.setIdPessoaUsuario(oDados.idPessoaUsuario);
        atendimentofechamentodpr.setOpCode(OPCODE_DELETE);

        xmlDpr->atendimentofechamentovo.inserir(&atendimentofechamentodpr);
    }
    // <== SM324--DPR--DEZ/2006--Cassio

    return true;
}

bool proCConsultaWFAtendimentoFechamento(st_AtendimentoFechamento* dados, st_vlAtendimentoFechamento* status, char* order, XMLGen* saida)
{

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        long idAtendimento;
        VARCHAR dtFechamento[256];
        int idPessoaUsuario;

        char query[800] = "SELECT idAtendimento, TO_CHAR(dtFechamento,'dd/mm/yyyy hh24:mi'), "
                                 "idPessoaUsuario "
                            "FROM atendimento.AtendimentoFechamento ";

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFEstado(&sqlca);
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    bool separa = false;

    if (status->idAtendimento != -1) 
        montaWhere("idAtendimento", dados->idAtendimento, 1);

    if (status->dtFechamento != -1) 
        montaWhere("dtFechamento", dados->dtFechamento, 4);

    if (status->idPessoaUsuario != -1)
        montaWhere("idPessoaUsuario", dados->idPessoaUsuario, 1);

    if (strlen(order) > 0) 
        sprintf( query, "%s ORDER BY %s ", query, order);

    EXEC SQL WHENEVER SQLERROR  DO sql_error_WFAtendimentoFechamento(&sqlca);

    EXEC SQL PREPARE consultaAtendimentoFechamento FROM :query;
    EXEC SQL DECLARE consulta CURSOR FOR consultaAtendimentoFechamento;

    EXEC SQL OPEN consulta;

    while (true)
    {
        EXEC SQL FETCH consulta INTO :idAtendimento, :dtFechamento, :idPessoaUsuario;

        CONV(dtFechamento);

        saida->createTag("WFAtendimentoFechamentoVO");
            saida->addItem("idAtendimento", idAtendimento);
            saida->addItem("dtFechamento", (char *)dtFechamento.arr);
            saida->addItem("idPessoaUsuario", idPessoaUsuario);
        saida->closeTag();
    }

    EXEC SQL CLOSE consulta;

    return true;

}

bool procExisteAtendimentoFechamento(long _idAtendimento)
{
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        long idAtendimento = _idAtendimento;
        int isFechado;
        short i_isFechado = -1;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL WHENEVER SQLERROR DO sql_error_WFAtendimentoFechamento(&sqlca);

    // ==> Remodelagem Atendimento--Fev/2007--Cassio 
    // EXEC SQL
    //     SELECT IDATENDIMENTO
    //     FROM ATENDIMENTO.ATENDIMENTOFECHAMENTO
    //     WHERE idAtendimento = :idAtendimento;

    EXEC SQL
        SELECT
            DECODE(DTFECHAMENTO,NULL,0,1)
        INTO
            :isFechado:i_isFechado
        FROM
            ATENDIMENTO.ATENDIMENTO
        WHERE
            IDATENDIMENTO = :idAtendimento;

    if ( 0 == sqlca.sqlcode && 1 == isFechado )
    {
        return true;
    }

    return false;
}

void sql_error_WFAtendimentoFechamento(sqlca*sqlca)
{
    throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}
