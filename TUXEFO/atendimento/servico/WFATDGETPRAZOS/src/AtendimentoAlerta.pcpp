// AtendimentoAlerta.cpp: implementation of the AtendimentoAlerta class.
//
//////////////////////////////////////////////////////////////////////
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
#include "../include/AtendimentoAlerta.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

AtendimentoAlerta::AtendimentoAlerta()
{

}

AtendimentoAlerta::~AtendimentoAlerta()
{

}

int AtendimentoAlerta::getWorkflowAlerta(XMLGen*xml_g)
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct param
        {
			VARCHAR idAlerta[21+1];
			VARCHAR dsAlerta[255+1];
        } m_param;

		struct iparam
        {
		    short idAlerta;
		    short dsAlerta;
        } m_iparam;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE CURSOR1 CURSOR FOR
		SELECT
            IDALERTA,DSALERTA
		FROM
            WORKFLOW.ALERTA
		WHERE
		    QTTEMPODECORRIDO > 0
		ORDER BY 
            DSALERTA ASC;

	EXEC SQL OPEN CURSOR1;

	for(;;)
	{
		memset(&m_param,0,sizeof(param));
		memset(&m_iparam,-1,sizeof(iparam));

		EXEC SQL FETCH CURSOR1 INTO :m_param:m_iparam;

		if( !sqlca.sqlcode )
		{
			xml_g->createTag("AlertaVO");
			xml_g->addItem("idAlerta",(char*)m_param.idAlerta.arr);
			xml_g->addItem("dsAlerta",(char*)m_param.dsAlerta.arr);
			xml_g->closeTag();
		}
	}

	EXEC SQL CLOSE CURSOR1;

	return 1;
Error:
	ULOG("\nAtendimentoAlerta::getWorkflowAlerta sqlca.sqlcode = ");
	ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}


//
// Tratamento específico para INBOX CRI
//
int AtendimentoAlerta::getWorkflowAlertaCRI(XMLGen*xml_g,unsigned long _idPessoaUsuario)
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
        unsigned long idPessoaUsuario = _idPessoaUsuario;

		struct param
        {
			VARCHAR idAlerta[21+1];
			VARCHAR dsAlerta[255+1];
        } m_param;

		struct iparam
        {
			short idAlerta;
			short dsAlerta;
        } m_iparam;

        int regCount=0;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL DECLARE CURSORCRI CURSOR FOR
        SELECT DISTINCT 
             ALERTA.IDALERTA,ALERTA.DSALERTA 
        FROM 
             ATENDIMENTO.ATENDIMENTOPRIORIZACAO ATENDIMENTOPRIORIZACAO,
             ATENDIMENTO.TRATAMENTOCRI TRATAMENTOCRI,
             ATENDIMENTO.GRUPOCRI GRUPOCRI,
             WORKFLOW.ALERTA ALERTA
        WHERE
             ATENDIMENTOPRIORIZACAO.IDATENDIMENTO = TRATAMENTOCRI.IDATENDIMENTO
         AND ATENDIMENTOPRIORIZACAO.IDATENDIMENTO = GRUPOCRI.IDATENDIMENTO
         AND ATENDIMENTOPRIORIZACAO.IDALERTA = ALERTA.IDALERTA
         AND TRATAMENTOCRI.IDPESSOAUSUARIO = :idPessoaUsuario
        ORDER BY 
              UPPER(ALERTA.DSALERTA);

	EXEC SQL OPEN CURSORCRI;

	for(;;)
	{
		memset(&m_param,0,sizeof(param));
		memset(&m_iparam,-1,sizeof(iparam));

		EXEC SQL FETCH CURSORCRI INTO :m_param:m_iparam;

		if( !sqlca.sqlcode )
		{
            regCount++;

            if ( stricmp((char*)(m_param.dsAlerta.arr),"novo") == 0 )
            {
                strcpy((char*)(m_param.dsAlerta.arr),"No Prazo");
            }

			xml_g->createTag("AlertaVO");
			xml_g->addItem("idAlerta",(char*)m_param.idAlerta.arr);
			xml_g->addItem("dsAlerta",(char*)m_param.dsAlerta.arr);
			xml_g->closeTag();
		}
	}

	EXEC SQL CLOSE CURSORCRI;

    if ( regCount == 0 )
    { // Ambiente Web dá problema se o XML de saída retornar vazio
        xml_g->createTag("AlertaVO");
        xml_g->addItem("idAlerta","0");
        xml_g->addItem("dsAlerta","No Prazo");
        xml_g->closeTag();
    }

	return 1;
Error:
	ULOG("\nAtendimentoAlerta::getWorkflowAlertaCRI ");
	ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}
