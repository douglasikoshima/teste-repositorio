//
// $Id: get_listas.pcpp,v 1.1 2009/07/31 15:33:22 a5110702 Exp $
//

#include <string>
#include "../../negocio/fidutil/include/retencao.hpp"

#include <string>
#include <list>
#include <iterator>
using namespace std;

typedef list<int> LISTA_ID;
list<int>::iterator itRegional;
list<int>::iterator itCliente;
list<int>::iterator itSegmento;
list<int>::iterator itTpLinha;
list<int>::iterator itDestino;
list<int>::iterator itGrupo;


// Prototipos
void get_listaGruposPacote( XMLGen *xml );
void sel_Script( char * idScriptPrm, XMLGen * xml );
void sel_TipoLinhaScript( char * idScriptPrm, XMLGen * xml );
void sel_TipoPessoaScript( char * idScriptPrm, XMLGen * xml );
void sel_SegmentacaoScript( char * idScriptPrm, XMLGen * xml );
void sel_UFScript( char * idScriptPrm, XMLGen * xml );
void sel_GrupoScript( char * idScriptPrm, XMLGen * xml );
void sel_OfertaScript( char * idScriptPrm, XMLGen * xml );
void sel_RDestinoScript( char * idScriptPrm, XMLGen * xml );
void sel_RIntencaoScript( char * idScriptPrm, XMLGen * xml );
void BuscaRespostaUnidade( LISTA_ID * pRegional, LISTA_ID * pRespostaUnidade, int idRespostaIntencao, LISTA_ID * pDestino, LISTA_ID * pTpLinha, LISTA_ID * pCliente );
//void BuscaUFOperadora(int idRegionalPrm, int * idUFOperadoraPrm );
void get_listaOferta( XMLGen *xml );
void get_listaTipoCliente( XMLGen *xml );
void get_listaTipoLinha( XMLGen *xml );
void get_listaRegionais( XMLGen *xml );
void get_listaSegmentacao( XMLGen *xml );
void get_listaTipoServico( XMLGen *xml );
void get_listaIntencao( XMLGen *xml );
void get_listaDestino( XMLGen *xml );
void get_listaGrupo( XMLGen *xml );

void get_ListaIntencaoOfertas( LISTA_ID * pRegional, 
                               LISTA_ID * pCliente, 
                               LISTA_ID * pTpLinha, 
                               LISTA_ID * pGrupo, 
                               LISTA_ID * pSegmento, 
                               XMLGen   * xml );

void sel_Destinos( int idIntencao,
                   LISTA_ID * pRegional, 
                   LISTA_ID * pCliente, 
                   LISTA_ID * pTpLinha, 
                   LISTA_ID * pGrupo, 
                   LISTA_ID * pSegmento, 
                   XMLGen   * xml );

void sel_Ofertas( int idIntencao,
                  LISTA_ID * pGrupo, 
                  LISTA_ID * pSegmento, 
                  LISTA_ID * pDestino, 
                  XMLGen   * xml );


void ListaOfertas( char * sgOfertaPrm, char * nmOfertaPrm, XMLGen *xml );

void ListaBonus( char * idRegionalPrm, char * idTipoClientePrm, char * idTipoLinhaPrm, char * idSegmentacaoPrm, char * idTipoBonusPrm, XMLGen *xml );
void get_listaTipoBonus( XMLGen *xml );
void sel_RegionaisBonus( int idBonusPrm, XMLGen *xml );
void sel_TipoClienteBonus( int idBonusPrm, XMLGen *xml );
void sel_SegmentacaoBonus( int idBonusPrm, XMLGen *xml );
void ConsultaBonus( int idBonusPrm, XMLGen *xml );

void ListaMigracao( int idRegionalPrm, char * idTipoClientePrm, int idTipoLinhaPrm, XMLGen *xml );
void ConsultaMigracao( int idPlanoPrm, XMLGen *xml );
void sel_RegionaisMigracao( int idMigracaoPrm, XMLGen *xml );
void sel_TipoClienteMigracao( int idMigraPrm, XMLGen *xml );
void sel_TipoLinhaMigracao( int idMigracaoPrm, XMLGen *xml );

void ListaPlanos( int idRegionalPrm, char * idTipoClientePrm, int idTipoLinhaPrm, XMLGen *xml );
void ConsultaPlano( int idPlanoPrm, XMLGen *xml );

void sel_TipoClientePlano( int idPlanoPrm, XMLGen *xml );
void sel_RegionaisPlano( int idPlanoPrm, XMLGen *xml );


void sel_RegionaisIntencao( int idIntencaoPrm, XMLGen *xml );
void sel_TipoClienteIntencao( int idIntencaoPrm, XMLGen *xml );
void sel_TipoLinhaIntencao( int idIntencaoPrm, XMLGen *xml );
void sel_DestinoIntencao( int idIntencaoPrm, XMLGen *xml );
void ConsultaIntencao( int idIntencaoPrm, XMLGen *xml );

void sel_Aparelhos( LISTA_ID * pRegional, 
                    LISTA_ID * pCliente, 
                    LISTA_ID * pGrupo, 
                    LISTA_ID * pSegmento, 
                    XMLGen *xml );


using namespace std;

void get_listaGruposPacote( XMLGen *xml )
{
    ULOG_START( "get_listaGruposPacote()" );

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR   idTipoGrupoPacote[40];
        short   i_idTipoGrupoPacote = -1;
        VARCHAR   dsTipoGrupoPacote[256]; 
        short   i_dsTipoGrupoPacote = -1;
    EXEC SQL END DECLARE SECTION;

    memset( &idTipoGrupoPacote, 0x0, sizeof(idTipoGrupoPacote) );
    memset( &dsTipoGrupoPacote, 0x0, sizeof(dsTipoGrupoPacote) );

    try
    {
        EXEC SQL DECLARE crsGRPPACOTE CURSOR FOR
        SELECT
            IDTIPOGRUPOPACOTE ,
            DSTIPOGRUPOPACOTE
        FROM
            RETENCAO.TIPOGRUPOPACOTE
        WHERE
            INATIVO = 1
        ORDER BY 
            DSTIPOGRUPOPACOTE;

        xml->createTag( "Lista" );
            xml->addItem( "nmSelect","GRPPACOTE" );
            xml->createTag( "Disponivel" );
            
            EXEC SQL OPEN crsGRPPACOTE;
            
            EXEC SQL WHENEVER NOT FOUND DO BREAK;
            for(;;)
            {
                EXEC SQL FETCH crsGRPPACOTE INTO :idTipoGrupoPacote:i_idTipoGrupoPacote, 
                                                 :dsTipoGrupoPacote:i_dsTipoGrupoPacote;
                
                endOraStr( idTipoGrupoPacote );
                endOraStr( dsTipoGrupoPacote );
                xml->createTag("It");
                    xml->addItem( "id",(char*)idTipoGrupoPacote.arr );
                    xml->addItem( "ds",(char*)dsTipoGrupoPacote.arr );
                xml->closeTag();
            
            }                      
            EXEC SQL CLOSE crsGRPPACOTE;

            xml->closeTag();
        xml->closeTag();
        
        ULOG_END( "get_listaGruposPacote()" );
    }
    catch(...)
    {
            ULOGE( "*** SAIDA ANORMAL: get_listaGruposPacote()" );
            throw;
    }

}



void get_listaTipoServico( XMLGen *xml )
{
	ULOG_START( "get_listaTipoServico()" );
		
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR   idSistemaOrigem[256];
		short   i_idSistemaOrigem = -1;
		VARCHAR   cdTipoServico[256]; 
		short   i_cdTipoServico = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &cdTipoServico  , 0x0, sizeof(cdTipoServico) );
	memset( &idSistemaOrigem, 0x0, sizeof(idSistemaOrigem) );
	
	try
	{
		EXEC SQL DECLARE crsTPSERVICO CURSOR FOR
		Select
		   TIPOSERVICOATLYS.IDTIPOSERVICO ,
		   TIPOSERVICOATLYS.DSTIPOSERVICO
		from
		   RETENCAO.TIPOSERVICOATLYS TIPOSERVICOATLYS
		Where
		   TIPOSERVICOATLYS.IDTIPOSERVICO > 0
		Order By TIPOSERVICOATLYS.DSTIPOSERVICO;
	
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","TPSERVICO" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsTPSERVICO;
			
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTPSERVICO INTO :cdTipoServico:i_cdTipoServico, 
					                             :idSistemaOrigem:i_idSistemaOrigem;
				
				endOraStr( cdTipoServico );
				endOraStr( idSistemaOrigem );
				xml->createTag("It");
					xml->addItem( "id",(char*)cdTipoServico.arr );
					xml->addItem( "ds",(char*)idSistemaOrigem.arr );
				xml->closeTag();
			
			}                      
			EXEC SQL CLOSE crsTPSERVICO;
	
			xml->closeTag();
		xml->closeTag();
		
		ULOG_END( "get_listaTipoServico()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: get_listaTipoServico()" );
		throw;
	}

}



void get_listaOferta( XMLGen *xml )
{
	ULOG_START( "get_listaOferta()" );
		
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR idOferta[256]; 
		VARCHAR dsOferta[256]; 
		short i_idOferta = -1;
		short i_dsOferta = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &idOferta, 0x0, sizeof(idOferta) );
	memset( &dsOferta, 0x0, sizeof(dsOferta) );
	
	try
	{
		EXEC SQL DECLARE crsOferta CURSOR FOR
        SELECT   idunidadeoferta, nmoferta
            FROM retencao.oferta
           WHERE inativo = 1
        ORDER BY (TRIM (UPPER (nmoferta)));	

		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","OFERTAS" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsOferta;
			
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsOferta INTO :idOferta:i_idOferta, 
					                            :dsOferta:i_dsOferta;
				
				endOraStr( idOferta );
				endOraStr( dsOferta );
				xml->createTag("It");
					xml->addItem( "id",(char*)idOferta.arr );
					xml->addItem( "ds",(char*)dsOferta.arr );
				xml->closeTag();
			
			}                      
			EXEC SQL CLOSE crsOferta;
	
			xml->closeTag();
		xml->closeTag();
		
		ULOG_END( "get_listaOferta()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: get_listaOferta()" );
		throw;
	}

}



void get_listaTipoCliente( XMLGen *xml )
{
	ULOG_START( "get_listaTipoCliente()" );
		
	EXEC SQL BEGIN DECLARE SECTION;

		int     idTipoPessoa; 
		VARCHAR dsTipoPessoa[256]; 
		
		short i_dsTipoPessoa = -1;

	EXEC SQL END DECLARE SECTION;

	memset( &dsTipoPessoa, 0x0, sizeof(dsTipoPessoa) );
	
	try
	{
		EXEC SQL DECLARE crsTPPESSOA CURSOR FOR
		SELECT
		   IDTIPOPESSOA ,
		   DSTIPOPESSOA
		FROM
		   APOIO.TIPOPESSOA
		ORDER BY UPPER(TRIM(DSTIPOPESSOA));
	
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","TPCLIENTE" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsTPPESSOA;
			
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTPPESSOA INTO :idTipoPessoa, 
					                            :dsTipoPessoa:i_dsTipoPessoa;
				
				endOraStr( dsTipoPessoa );
				xml->createTag("It");
					xml->addItem( "id",idTipoPessoa );
					xml->addItem( "ds",(char*)dsTipoPessoa.arr );
				xml->closeTag();
			
			}                      
			EXEC SQL CLOSE crsTPPESSOA;
	
			xml->closeTag();
		xml->closeTag();
		
		ULOG_END( "get_listaTipoCliente()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: get_listaTipoCliente()" );
		throw;
	}

}



void get_listaTipoLinha( XMLGen *xml )
{
	ULOG_START( "get_listaTipoLinha()" );

	EXEC SQL BEGIN DECLARE SECTION;

		int     idTipoLinha; 
		VARCHAR dsTipoLinha[256]; 
		
		short i_dsTipoLinha = -1;

	EXEC SQL END DECLARE SECTION;

	memset( &dsTipoLinha, 0x0, sizeof(dsTipoLinha) );

	try
	{
		EXEC SQL DECLARE crsTPLINHA CURSOR FOR
		SELECT
		   IDTIPOLINHA ,
		   DSTIPOLINHA
		FROM
		   APOIO.TIPOLINHA
		ORDER BY UPPER(TRIM(DSTIPOLINHA));
	
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","TPLINHA" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsTPLINHA;
	
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTPLINHA INTO :idTipoLinha, 
					                           :dsTipoLinha:i_dsTipoLinha;
					endOraStr( dsTipoLinha );
					xml->createTag("It");
						xml->addItem( "id",idTipoLinha );
						xml->addItem( "ds",(char*)dsTipoLinha.arr );
					xml->closeTag();
			}                      
			EXEC SQL CLOSE crsTPLINHA;

			xml->closeTag();
		xml->closeTag();
		ULOG_END( "get_listaTipoLinha()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: get_listaTipoLinha()" );
		throw;
	}
	
}



void get_listaRegionais( XMLGen *xml )
{
	ULOG_START( "get_listaRegionais()" );
	
	EXEC SQL BEGIN DECLARE SECTION;

		int     idUF; 
		VARCHAR dsUF[256]; 
		
		short i_dsUF = -1;

	EXEC SQL END DECLARE SECTION;

	memset( &dsUF, 0x0, sizeof(dsUF) );

	try
	{
		EXEC SQL DECLARE crsRegionais CURSOR FOR
        SELECT
           UFOP.IDUFOPERADORA ,
           UF.NMUF
        FROM
           APOIO.UF UF,
           CUSTOMER.UFOPERADORA UFOP
        WHERE
           UF.IDUF IN
           (
                SELECT
                   IDUF
                FROM
                   CUSTOMER.UFOPERADORA
                WHERE IDUF > 0
           )
           AND UF.IDUF = UFOP.IDUF
        ORDER BY UPPER(TRIM(NMUF));
        
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","REGIONAL" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsRegionais;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsRegionais INTO :idUF, 
					                             :dsUF:i_dsUF;
				endOraStr( dsUF );
				xml->createTag("It");
					xml->addItem( "id",idUF );
					xml->addItem( "ds",(char*)dsUF.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsRegionais;

			xml->closeTag();
		xml->closeTag();

		ULOG_END( "get_listaRegionais()" );

	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: get_listaRegionais()" );
		throw;
	}

}



void get_listaSegmentacao( XMLGen *xml )
{

	ULOG_START( "get_listaSegmentacao()" );

	EXEC SQL BEGIN DECLARE SECTION;

		int     idSegmentacao; 
		VARCHAR dsSegmentacao[256]; 
		
		short i_dsSegmentacao = -1;

	EXEC SQL END DECLARE SECTION;

	memset( &dsSegmentacao, 0x0, sizeof(dsSegmentacao) );

	try
	{
		EXEC SQL DECLARE crsSEGMENTACAO CURSOR FOR
		SELECT
		   IDSEGMENTACAO ,
		   DSSEGMENTACAO
		FROM
		   APOIO.SEGMENTACAO
		WHERE
		   IDSEGMENTACAO > 0
		ORDER BY UPPER(TRIM(DSSEGMENTACAO));
	
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","SEGMENTACAO" );
			xml->createTag( "Disponivel" );

			EXEC SQL OPEN crsSEGMENTACAO;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsSEGMENTACAO INTO :idSegmentacao, 
					                               :dsSegmentacao:i_dsSegmentacao;

				endOraStr( dsSegmentacao );
				xml->createTag("It");
					xml->addItem( "id",idSegmentacao );
					xml->addItem( "ds",(char*)dsSegmentacao.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsSEGMENTACAO;

			xml->closeTag();
		xml->closeTag();
		
		ULOG_END( "get_listaSegmentacao()" );

	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: get_listaSegmentacao()" );
		throw;
	}

}



void get_listaTipoOferta( XMLGen *xml )
{

	ULOG_START( "get_listaTipoOferta()" );

	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR sgTipoOferta[5]; 
		VARCHAR dsTipoOferta[256]; 
		
		short   i_dsTipoOferta = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &sgTipoOferta, 0x0, sizeof(sgTipoOferta) );
	memset( &dsTipoOferta, 0x0, sizeof(dsTipoOferta) );

	try
	{
		EXEC SQL DECLARE crsTipoOferta CURSOR FOR
		SELECT
		   SGTIPOOFERTA ,
		   DSTIPOOFERTA
		FROM
		   RETENCAO.TIPOOFERTA
		WHERE
		   SGTIPOOFERTA IS NOT NULL
		ORDER BY
		   UPPER(TRIM(DSTIPOOFERTA));
	
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","TPOFERTA" );
			xml->createTag( "Disponivel" );

			EXEC SQL OPEN crsTipoOferta;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTipoOferta INTO :sgTipoOferta, 
					                              :dsTipoOferta:i_dsTipoOferta;

				endOraStr( sgTipoOferta );
				endOraStr( dsTipoOferta );
				xml->createTag("It");
					xml->addItem( "id",(char*)sgTipoOferta.arr );
					xml->addItem( "ds",(char*)dsTipoOferta.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTipoOferta;

			xml->closeTag();
		xml->closeTag();
		
		ULOG_END( "get_listaTipoOferta()" );

	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: get_listaTipoOferta()" );
		throw;
	}

}



void get_listaTipoBonus( XMLGen *xml )
{

	ULOG_START( "get_listaTipoBonus()" );

	EXEC SQL BEGIN DECLARE SECTION;
		int     idTipoBonus; 
		VARCHAR dsTipoBonus[256]; 
		short   i_dsTipoBonus = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &dsTipoBonus, 0x0, sizeof(dsTipoBonus) );

	try
	{
		EXEC SQL DECLARE crsTipoBonus CURSOR FOR
        SELECT
            OFERTA.IDUNIDADEOFERTA ,
            OFERTA.NMOFERTA
        FROM
            RETENCAO.OFERTA          OFERTA
        WHERE
            OFERTA.IDUNIDADEOFERTA IN
        (
            SELECT
                OFERTATIPOBONUS.IDUNIDADEOFERTA
            FROM
                RETENCAO.OFERTATIPOBONUS OFERTATIPOBONUS
        )
        ORDER BY UPPER(TRIM(OFERTA.NMOFERTA));
        	
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","TPBONUS" );
			xml->createTag( "Disponivel" );

			EXEC SQL OPEN crsTipoBonus;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTipoBonus INTO :idTipoBonus, 
					                             :dsTipoBonus:i_dsTipoBonus;
				endOraStr( dsTipoBonus );
				xml->createTag("It");
					xml->addItem( "id",idTipoBonus );
					xml->addItem( "ds",(char*)dsTipoBonus.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTipoBonus;

			xml->closeTag();
		xml->closeTag();
		
		ULOG_END( "get_listaTipoBonus()" );

	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: get_listaTipoBonus()" );
		throw;
	}

}



void sel_RegionaisBonus( int idBonusPrm, XMLGen *xml )
{
	ULOG_START( "sel_RegionaisBonus()" );

	EXEC SQL BEGIN DECLARE SECTION;
		int     idBonus = idBonusPrm;
		int     idUF; 
		VARCHAR dsUF[256]; 
		short i_dsUF = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &dsUF, 0x0, sizeof(dsUF) );
	ULOG( "idBonus [%d]",idBonus );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsRegionaisDispBonus CURSOR FOR
        SELECT
            UFOPERADORA.IDUFOPERADORA ,
            UF.NMUF
        FROM
            APOIO.UF UF ,
            CUSTOMER.UFOPERADORA UFOPERADORA
        WHERE
            UFOPERADORA.IDUF = UF.IDUF
        AND
            UF.IDUF > 0
        AND
            UFOPERADORA.IDUFOPERADORA NOT IN
        (
            SELECT
               MATRIZBONUS.IDUFOPERADORA
            FROM
               RETENCAO.MATRIZBONUS MATRIZBONUS
            WHERE 1 = MATRIZBONUS.INATIVO
            AND MATRIZBONUS.IDBONUS = :idBonus
        )
        ORDER BY UPPER(TRIM(UF.NMUF));
        
		// Selecionados
		EXEC SQL DECLARE crsRegionaisSelBonus CURSOR FOR
        SELECT
            UFOPERADORA.IDUFOPERADORA ,
            UF.NMUF
        FROM
            APOIO.UF UF ,
            CUSTOMER.UFOPERADORA UFOPERADORA
        WHERE
            UFOPERADORA.IDUF = UF.IDUF
        AND
            UFOPERADORA.IDUFOPERADORA IN
        (
            SELECT
               MATRIZBONUS.IDUFOPERADORA
            FROM
               RETENCAO.MATRIZBONUS MATRIZBONUS
            WHERE 1 = MATRIZBONUS.INATIVO 
            AND MATRIZBONUS.IDBONUS = :idBonus
        )
        ORDER BY UPPER(TRIM(UF.NMUF));
        
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","REGIONAL" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsRegionaisDispBonus;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsRegionaisDispBonus INTO :idUF, 
					                                      :dsUF:i_dsUF;
				endOraStr( dsUF );
				xml->createTag("It");
					xml->addItem( "id",idUF );
					xml->addItem( "ds",(char*)dsUF.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsRegionaisDispBonus;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsRegionaisSelBonus;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsRegionaisSelBonus INTO :idUF, 
					                             :dsUF:i_dsUF;
				endOraStr( dsUF );
				xml->createTag("It");
					xml->addItem( "id",idUF );
					xml->addItem( "ds",(char*)dsUF.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsRegionaisSelBonus;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_RegionaisBonus()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_RegionaisBonus()" );
		throw;
	}

}



void sel_RegionaisPlano( int idPlanoPrm, XMLGen *xml )
{
	ULOG_START( "sel_RegionaisPlano()" );

	EXEC SQL BEGIN DECLARE SECTION;
		int     idPlano = idPlanoPrm;
		int     idUF; 
		VARCHAR dsUF[256]; 
		short i_dsUF = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &dsUF, 0x0, sizeof(dsUF) );
	ULOG( "idPlano [%d]",idPlano );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsRegionaisDispPlano CURSOR FOR
        SELECT
            UFOPERADORA.IDUFOPERADORA ,
            UF.NMUF
        FROM
            APOIO.UF UF ,
            CUSTOMER.UFOPERADORA UFOPERADORA
        WHERE
            UFOPERADORA.IDUF = UF.IDUF
        AND
            UF.IDUF > 0
        AND
            UFOPERADORA.IDUFOPERADORA NOT IN
        (
            SELECT
               MATRIZPLANOS.IDUFOPERADORA
            FROM
               RETENCAO.MATRIZPLANOS MATRIZPLANOS
            WHERE MATRIZPLANOS.IDPLANO = :idPlano
        )
        ORDER BY UPPER(TRIM(UF.NMUF));
        
		// Selecionados
		EXEC SQL DECLARE crsRegionaisSelPlano CURSOR FOR
        SELECT
            UFOPERADORA.IDUFOPERADORA ,
            UF.NMUF
        FROM
            APOIO.UF UF ,
            CUSTOMER.UFOPERADORA UFOPERADORA
        WHERE
            UFOPERADORA.IDUF = UF.IDUF
        AND
            UFOPERADORA.IDUFOPERADORA IN
        (
            SELECT
               MATRIZPLANOS.IDUFOPERADORA
            FROM
               RETENCAO.MATRIZPLANOS MATRIZPLANOS
            WHERE MATRIZPLANOS.IDPLANO = :idPlano
        )
        ORDER BY UPPER(TRIM(UF.NMUF));
        
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","REGIONAL" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsRegionaisDispPlano;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsRegionaisDispPlano INTO :idUF, 
					                                      :dsUF:i_dsUF;
				endOraStr( dsUF );
				xml->createTag("It");
					xml->addItem( "id",idUF );
					xml->addItem( "ds",(char*)dsUF.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsRegionaisDispPlano;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsRegionaisSelPlano;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsRegionaisSelPlano INTO :idUF, 
					                             :dsUF:i_dsUF;
				endOraStr( dsUF );
				xml->createTag("It");
					xml->addItem( "id",idUF );
					xml->addItem( "ds",(char*)dsUF.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsRegionaisSelPlano;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_RegionaisPlano()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_RegionaisPlano()" );
		throw;
	}

}



void sel_SegmentacaoBonus( int idBonusPrm, XMLGen *xml )
{
	ULOG_START( "sel_SegmentacaoBonus()" );

	EXEC SQL BEGIN DECLARE SECTION;
		int     idBonus = idBonusPrm;
		int     idSegmento; 
		VARCHAR dsSegmento[256]; 
		short i_dsSegmento = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &dsSegmento, 0x0, sizeof(dsSegmento) );
	ULOG( "idBonus [%d]",idBonus );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsSegmentoDispBonus CURSOR FOR
		SELECT
		   SEGMENTACAO.IDSEGMENTACAO ,
		   SEGMENTACAO.DSSEGMENTACAO
		FROM
		   APOIO.SEGMENTACAO SEGMENTACAO
		WHERE
		   SEGMENTACAO.IDSEGMENTACAO > 0
		AND
		   SEGMENTACAO.IDSEGMENTACAO NOT IN
		(
		   SELECT
		      MATRIZBONUS.IDSEGMENTACAO
		   FROM
		      RETENCAO.MATRIZBONUS MATRIZBONUS
		   WHERE 1 = MATRIZBONUS.INATIVO
		   AND MATRIZBONUS.IDBONUS = :idBonus
		)
		ORDER BY UPPER(TRIM(SEGMENTACAO.DSSEGMENTACAO));
        
		// Selecionados
		EXEC SQL DECLARE crsSegmentoSelBonus CURSOR FOR
		SELECT
		   SEGMENTACAO.IDSEGMENTACAO ,
		   SEGMENTACAO.DSSEGMENTACAO
		FROM
		   APOIO.SEGMENTACAO SEGMENTACAO
		WHERE
		   SEGMENTACAO.IDSEGMENTACAO > 0
		AND
		   SEGMENTACAO.IDSEGMENTACAO IN
		(
		   SELECT
		      MATRIZBONUS.IDSEGMENTACAO
		   FROM
		      RETENCAO.MATRIZBONUS MATRIZBONUS
		   WHERE 1 = MATRIZBONUS.INATIVO 
		   AND MATRIZBONUS.IDBONUS = :idBonus
		)
		ORDER BY UPPER(TRIM(SEGMENTACAO.DSSEGMENTACAO));
        
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","SEGMENTACAO" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsSegmentoDispBonus;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsSegmentoDispBonus INTO :idSegmento, 
					                                     :dsSegmento:i_dsSegmento;
				endOraStr( dsSegmento );
				xml->createTag("It");
					xml->addItem( "id",idSegmento );
					xml->addItem( "ds",(char*)dsSegmento.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsSegmentoDispBonus;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsSegmentoSelBonus;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsSegmentoSelBonus INTO :idSegmento, 
					                                    :dsSegmento:i_dsSegmento;
				endOraStr( dsSegmento );
				xml->createTag("It");
					xml->addItem( "id",idSegmento );
					xml->addItem( "ds",(char*)dsSegmento.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsSegmentoSelBonus;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_SegmentacaoBonus()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_SegmentacaoBonus()" );
		throw;
	}

}



void sel_RegionaisMigracao( int idMigracaoPrm, XMLGen *xml )
{
	ULOG_START( "sel_RegionaisMigracao()" );

	EXEC SQL BEGIN DECLARE SECTION;
		int     idMigracao = idMigracaoPrm;
		int     idUF; 
		VARCHAR dsUF[256]; 
		short i_dsUF = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &dsUF, 0x0, sizeof(dsUF) );
	ULOG( "idMigracao [%d]",idMigracao );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsRegionaisMigDisp CURSOR FOR
        SELECT
            UFOPERADORA.IDUFOPERADORA ,
            UF.NMUF
        FROM
            APOIO.UF UF ,
            CUSTOMER.UFOPERADORA UFOPERADORA
        WHERE
            UFOPERADORA.IDUF = UF.IDUF
        AND
            UF.IDUF > 0
        AND
            UFOPERADORA.IDUFOPERADORA NOT IN
        (
            SELECT
               MATRIZMIGRACAO.IDUFOPERADORA
            FROM
               RETENCAO.MATRIZMIGRACAO MATRIZMIGRACAO
            WHERE 
            //   MATRIZMIGRACAO.INATIVO = 1
            //AND
               MATRIZMIGRACAO.IDMIGRACAO = :idMigracao
        )
        ORDER BY UPPER(TRIM(UF.NMUF));

		// Selecionados
		EXEC SQL DECLARE crsRegionaisMigSel CURSOR FOR
        SELECT
            UFOPERADORA.IDUFOPERADORA ,
            UF.NMUF
        FROM
            APOIO.UF UF ,
            CUSTOMER.UFOPERADORA UFOPERADORA
        WHERE
            UFOPERADORA.IDUF = UF.IDUF
        AND
            UFOPERADORA.IDUFOPERADORA IN
        (
            SELECT
               MATRIZMIGRACAO.IDUFOPERADORA
            FROM
               RETENCAO.MATRIZMIGRACAO MATRIZMIGRACAO
            WHERE 
               //MATRIZMIGRACAO.INATIVO = 1
            //AND
               MATRIZMIGRACAO.IDMIGRACAO = :idMigracao
        )
        ORDER BY UPPER(TRIM(UF.NMUF));
        
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","REGIONAL" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsRegionaisMigDisp;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsRegionaisMigDisp INTO :idUF, 
					                                    :dsUF:i_dsUF;
				endOraStr( dsUF );
				xml->createTag("It");
					xml->addItem( "id",idUF );
					xml->addItem( "ds",(char*)dsUF.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsRegionaisMigDisp;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsRegionaisMigSel;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsRegionaisMigSel INTO :idUF, 
					                                   :dsUF:i_dsUF;
				endOraStr( dsUF );
				xml->createTag("It");
					xml->addItem( "id",idUF );
					xml->addItem( "ds",(char*)dsUF.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsRegionaisMigSel;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_RegionaisMigracao()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_RegionaisMigracao()" );
		throw;
	}

}



void sel_TipoClienteBonus( int idBonusPrm, XMLGen *xml )
{
	ULOG_START( "sel_TipoClienteBonus()" );

	EXEC SQL BEGIN DECLARE SECTION;
		int     idBonus = idBonusPrm;
		int     idTipoCliente; 
		VARCHAR dsTipoCliente[256]; 
		short   i_dsTipoCliente = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &dsTipoCliente, 0x0, sizeof(dsTipoCliente) );
	ULOG( "idBonus [%d]",idBonus );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsTPClienteDispBonus CURSOR FOR
		SELECT
		   TIPOPESSOA.IDTIPOPESSOA ,
		   TIPOPESSOA.DSTIPOPESSOA
		FROM
		   APOIO.TIPOPESSOA TIPOPESSOA
		WHERE
		   TIPOPESSOA.IDTIPOPESSOA NOT IN
		(
		   SELECT
		      MATRIZBONUS.IDTIPOPESSOA
		   FROM
		      RETENCAO.MATRIZBONUS MATRIZBONUS
		   WHERE 1 = MATRIZBONUS.INATIVO
		   AND MATRIZBONUS.IDBONUS = :idBonus
		)
		ORDER BY UPPER(TRIM(TIPOPESSOA.DSTIPOPESSOA));
		
		// Selecionados
		EXEC SQL DECLARE crsTPClienteSelBonus CURSOR FOR
		SELECT
		   TIPOPESSOA.IDTIPOPESSOA ,
		   TIPOPESSOA.DSTIPOPESSOA
		FROM
		   APOIO.TIPOPESSOA TIPOPESSOA
		WHERE
		   TIPOPESSOA.IDTIPOPESSOA IN
		(
		   SELECT
		      MATRIZBONUS.IDTIPOPESSOA
		   FROM
		      RETENCAO.MATRIZBONUS MATRIZBONUS
		   WHERE 1 = MATRIZBONUS.INATIVO
		   AND MATRIZBONUS.IDBONUS = :idBonus
		)
		ORDER BY UPPER(TRIM(TIPOPESSOA.DSTIPOPESSOA));
				
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","TPCLIENTE" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsTPClienteDispBonus;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTPClienteDispBonus INTO :idTipoCliente, 
					                             	      :dsTipoCliente:i_dsTipoCliente;
				endOraStr( dsTipoCliente );
				xml->createTag("It");
					xml->addItem( "id",idTipoCliente );
					xml->addItem( "ds",(char*)dsTipoCliente.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTPClienteDispBonus;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsTPClienteSelBonus;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTPClienteSelBonus INTO :idTipoCliente, 
					                             	     :dsTipoCliente:i_dsTipoCliente;
				endOraStr( dsTipoCliente );
				xml->createTag("It");
					xml->addItem( "id",idTipoCliente );
					xml->addItem( "ds",(char*)dsTipoCliente.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTPClienteSelBonus;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_TipoClienteBonus()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_TipoClienteBonus()" );
		throw;
	}

}



void sel_TipoClienteMigracao( int idMigraPrm, XMLGen *xml )
{
	ULOG_START( "sel_TipoClienteMigracao()" );

	EXEC SQL BEGIN DECLARE SECTION;
		int     idMigra = idMigraPrm;
		int     idTipoCliente; 
		VARCHAR dsTipoCliente[256]; 
		short   i_dsTipoCliente = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &dsTipoCliente, 0x0, sizeof(dsTipoCliente) );
	ULOG( "idMigracao [%d]",idMigra );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsTPClienteDispMigra CURSOR FOR
		SELECT
		   TIPOPESSOA.IDTIPOPESSOA ,
		   TIPOPESSOA.DSTIPOPESSOA
		FROM
		   APOIO.TIPOPESSOA TIPOPESSOA
		WHERE
		   TIPOPESSOA.IDTIPOPESSOA NOT IN
		(
		   SELECT
		      MATRIZMIGRACAO.IDTIPOPESSOA
		   FROM
		      RETENCAO.MATRIZMIGRACAO MATRIZMIGRACAO
		   WHERE
               //MATRIZMIGRACAO.INATIVO = 1
            //AND
		      MATRIZMIGRACAO.IDMIGRACAO = :idMigra
		)
		ORDER BY UPPER(TRIM(TIPOPESSOA.DSTIPOPESSOA));
		
		// Selecionados
		EXEC SQL DECLARE crsTPClienteSelMigra CURSOR FOR
		SELECT
		   TIPOPESSOA.IDTIPOPESSOA ,
		   TIPOPESSOA.DSTIPOPESSOA
		FROM
		   APOIO.TIPOPESSOA TIPOPESSOA
		WHERE
		   TIPOPESSOA.IDTIPOPESSOA IN
		(
		   SELECT
		      MATRIZMIGRACAO.IDTIPOPESSOA
		   FROM
		      RETENCAO.MATRIZMIGRACAO MATRIZMIGRACAO
		   WHERE
               //MATRIZMIGRACAO.INATIVO = 1
            //AND
		      MATRIZMIGRACAO.IDMIGRACAO = :idMigra
		)
		ORDER BY UPPER(TRIM(TIPOPESSOA.DSTIPOPESSOA));
				
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","TPCLIENTE" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsTPClienteDispMigra;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTPClienteDispMigra INTO :idTipoCliente, 
					                             	      :dsTipoCliente:i_dsTipoCliente;
				endOraStr( dsTipoCliente );
				xml->createTag("It");
					xml->addItem( "id",idTipoCliente );
					xml->addItem( "ds",(char*)dsTipoCliente.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTPClienteDispMigra;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsTPClienteSelMigra;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTPClienteSelMigra INTO :idTipoCliente, 
					                             	     :dsTipoCliente:i_dsTipoCliente;
				endOraStr( dsTipoCliente );
				xml->createTag("It");
					xml->addItem( "id",idTipoCliente );
					xml->addItem( "ds",(char*)dsTipoCliente.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTPClienteSelMigra;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_TipoClienteMigracao()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_TipoClienteMigracao()" );
		throw;
	}

}



void sel_TipoClientePlano( int idPlanoPrm, XMLGen *xml )
{
	ULOG_START( "sel_TipoClientePlano()" );

	EXEC SQL BEGIN DECLARE SECTION;
		int     idPlano = idPlanoPrm;
		int     idTipoCliente; 
		VARCHAR dsTipoCliente[256]; 
		short   i_dsTipoCliente = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &dsTipoCliente, 0x0, sizeof(dsTipoCliente) );
	ULOG( "idPlano [%d]",idPlano );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsTPClienteDisp CURSOR FOR
		SELECT
		   TIPOPESSOA.IDTIPOPESSOA ,
		   TIPOPESSOA.DSTIPOPESSOA
		FROM
		   APOIO.TIPOPESSOA TIPOPESSOA
		WHERE
		   TIPOPESSOA.IDTIPOPESSOA NOT IN
		(
		   SELECT
		      MATRIZPLANOS.IDTIPOPESSOA
		   FROM
		      RETENCAO.MATRIZPLANOS MATRIZPLANOS
		   WHERE
		      MATRIZPLANOS.IDPLANO = :idPlano
		)
		ORDER BY UPPER(TRIM(TIPOPESSOA.DSTIPOPESSOA));

		// Selecionados
		EXEC SQL DECLARE crsTPClienteSel CURSOR FOR
		SELECT
		   TIPOPESSOA.IDTIPOPESSOA ,
		   TIPOPESSOA.DSTIPOPESSOA
		FROM
		   APOIO.TIPOPESSOA TIPOPESSOA
		WHERE
		   TIPOPESSOA.IDTIPOPESSOA IN
		(
		   SELECT
		      MATRIZPLANOS.IDTIPOPESSOA
		   FROM
		      RETENCAO.MATRIZPLANOS MATRIZPLANOS
		   WHERE
		      MATRIZPLANOS.IDPLANO = :idPlano
		)
		ORDER BY UPPER(TRIM(TIPOPESSOA.DSTIPOPESSOA));
		
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","TPCLIENTE" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsTPClienteDisp;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTPClienteDisp INTO :idTipoCliente, 
					                             	 :dsTipoCliente:i_dsTipoCliente;
				endOraStr( dsTipoCliente );
				xml->createTag("It");
					xml->addItem( "id",idTipoCliente );
					xml->addItem( "ds",(char*)dsTipoCliente.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTPClienteDisp;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsTPClienteSel;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTPClienteSel INTO :idTipoCliente, 
					                             	:dsTipoCliente:i_dsTipoCliente;
				endOraStr( dsTipoCliente );
				xml->createTag("It");
					xml->addItem( "id",idTipoCliente );
					xml->addItem( "ds",(char*)dsTipoCliente.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTPClienteSel;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_TipoClientePlano()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_TipoClientePlano()" );
		throw;
	}

}



void ConsultaPlano( int idPlanoPrm, XMLGen *xml )
{
	ULOG_START( "ConsultaPlano()" );

    string queryStr;
    char sbf[64];
    
	EXEC SQL BEGIN DECLARE SECTION;
		int     idPlano = idPlanoPrm;
		VARCHAR nmPlano[256];
		short   i_nmPlano = -1;
		int     idTpServico;
		VARCHAR cdServico[256];
		short   i_cdServico = -1;
		int     idTipoLinha;
	EXEC SQL END DECLARE SECTION;

	memset( &nmPlano  , 0x0, sizeof(nmPlano) );
	memset( &cdServico, 0x0, sizeof(cdServico) );

	ULOG( "idPlano [%d]",idPlano );

	try
	{
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL
        SELECT
           PLANO.NMPLANO ,
           PLANO.CDSERVICO ,
           MATRIZPLANOS.IDTIPOLINHA ,
           PLANO.IDTIPOSERVICO
		INTO
		   :nmPlano:i_nmPlano ,
		   :cdServico:i_cdServico ,
		   :idTipoLinha ,
		   :idTpServico
        FROM
           RETENCAO.PLANO PLANO ,
           RETENCAO.MATRIZPLANOS MATRIZPLANOS
        WHERE
           MATRIZPLANOS.IDPLANO = PLANO.IDPLANO
        AND
           PLANO.IDPLANO = :idPlano;
		
		endOraStr( nmPlano );
		endOraStr( cdServico );

		xml->createTag( "Manter" );
			xml->addItem( "dsPlano"  ,(char *)nmPlano.arr );
			xml->addItem( "tpServico",idTpServico );
			xml->addItem( "cdServico",(char *)cdServico.arr );
			xml->addItem( "tpLinha"  ,idTipoLinha );
		xml->closeTag();

		xml->createTag("ListasVO");
		sel_RegionaisPlano( idPlano, xml );
		sel_TipoClientePlano( idPlano, xml );
        get_listaTipoLinha( xml );
		get_listaTipoServico( xml );
		xml->closeTag();
		
		ULOG_END( "ConsultaPlano()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: ConsultaPlano()" );
		throw;
	}

}



void ConsultaMigracao( int idMigracaoPrm, XMLGen *xml )
{
	ULOG_START( "ConsultaMigracao()" );

    string queryStr;
    char sbf[64];
    
	EXEC SQL BEGIN DECLARE SECTION;
		int     idMigracao = idMigracaoPrm;
		VARCHAR nmMigracao[256];
		short   i_nmMigracao = -1;
		VARCHAR vlBonus[64];
		int     qtDias;
	EXEC SQL END DECLARE SECTION;

	memset( &nmMigracao, 0x0, sizeof(nmMigracao) );

	ULOG( "idMigracao [%d]",idMigracao );

	try
	{
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL
		SELECT
		   MIGRACAO.DSMIGRACAO ,
		   TO_CHAR(MIGRACAO.VLBONUS,'999999999D99') ,
		   MIGRACAO.NRVALIDADE
		INTO
		   :nmMigracao:i_nmMigracao ,
		   :vlBonus ,
		   :qtDias
		FROM
		   RETENCAO.MIGRACAO MIGRACAO
		WHERE
           MIGRACAO.INATIVO = 1
        AND
		   MIGRACAO.IDMIGRACAO = :idMigracao;
		
		endOraStr( nmMigracao );
		endOraStr( vlBonus );

		xml->createTag( "Manter" );
			xml->addItem( "dsMigra"  ,(char *)nmMigracao.arr );
			xml->addItem( "vlBonus",(char *)vlBonus.arr );
			xml->addItem( "vdMigra"  ,qtDias );
		xml->closeTag();

		xml->createTag("ListasVO");
		sel_RegionaisMigracao( idMigracao, xml );
		sel_TipoClienteMigracao( idMigracao, xml );
		sel_TipoLinhaMigracao( idMigracao, xml );
		xml->closeTag();
		
		ULOG_END( "ConsultaMigracao()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: ConsultaPlano()" );
		throw;
	}

}



void ConsultaBonus( int idBonusPrm, XMLGen *xml )
{
	ULOG_START( "ConsultaBonus()" );

    string queryStr;
    char sbf[64];
    
	EXEC SQL BEGIN DECLARE SECTION;
		int     idBonus = idBonusPrm;
		int     idTpServico;
		VARCHAR nmBonus[256];
		short   i_nmBonus = -1;
		VARCHAR cdServico[256];
		short   i_cdServico = -1;
		int     idTipoLinha;
		int     idUnidadeOferta;
		VARCHAR dsTpBonus[256];
		short   i_dsTpBonus = -1;
		int     vdBonus;
	EXEC SQL END DECLARE SECTION;

	memset( &nmBonus  , 0x0, sizeof(nmBonus) );
	memset( &cdServico, 0x0, sizeof(cdServico) );

	ULOG( "idBonus [%d]",idBonus );

	try
	{
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL
		SELECT 
            BONUS.DSBONUS ,
            BONUS.IDTIPOSERVICO ,
            BONUS.CDSERVICO ,
            MATRIZBONUS.IDTIPOLINHA ,
            BONUS.NRVALIDADE ,
            BONUS.IDUNIDADEOFERTA
		INTO
		   :nmBonus:i_nmBonus ,
		   :idTpServico ,
		   :cdServico:i_cdServico ,
		   :idTipoLinha ,
		   :vdBonus ,
		   :idUnidadeOferta
		FROM
            RETENCAO.BONUS BONUS ,
            RETENCAO.MATRIZBONUS MATRIZBONUS
		WHERE
            MATRIZBONUS.IDBONUS = BONUS.IDBONUS
        AND
            1 = MATRIZBONUS.INATIVO
        AND
            1 = BONUS.INATIVO
        AND
            BONUS.IDBONUS = :idBonus;
            			
		EXEC SQL
		SELECT 
		    OFERTA.NMOFERTA 
		INTO
		   :dsTpBonus:i_dsTpBonus
		FROM
		    RETENCAO.OFERTA OFERTA
		WHERE
		    OFERTA.INATIVO = 1
		AND
		    OFERTA.IDUNIDADEOFERTA = :idUnidadeOferta;
		
		endOraStr( nmBonus );
		endOraStr( cdServico );
		endOraStr( dsTpBonus );

		xml->createTag( "Manter" );
			xml->addItem( "nmBonus"  ,(char *)nmBonus.arr );
			xml->addItem( "tpServico",idTpServico );
			xml->addItem( "cdServico",(char *)cdServico.arr );
			xml->addItem( "dsTpBonus",(char *)dsTpBonus.arr );
			xml->addItem( "tpLinha"  ,idTipoLinha );
			xml->addItem( "vdBonus"  ,vdBonus );
			xml->addItem( "tpBonus"  ,idUnidadeOferta );
		xml->closeTag();

		xml->createTag("ListasVO");
		sel_RegionaisBonus( idBonus, xml );
		sel_TipoClienteBonus( idBonus, xml );
		sel_SegmentacaoBonus( idBonus, xml );
        get_listaTipoLinha( xml );
		get_listaTipoBonus( xml );
		get_listaTipoServico( xml );
		xml->closeTag();
		
		ULOG_END( "ConsultaBonus()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: ConsultaBonus()" );
		throw;
	}

}



void ListaPlanos( int idRegionalPrm, char * idTipoClientePrm, int idTipoLinhaPrm, XMLGen *xml )
{
	ULOG_START( "ListaPlanos()" );

    string queryStr;
    char sbf[64];
    
	EXEC SQL BEGIN DECLARE SECTION;
		int     idRegional    = idRegionalPrm;
		VARCHAR idTipoCliente[32];
		int     idTipoLinha   = idTipoLinhaPrm;
		int     idPlano;
		VARCHAR nmPlano[256];
		short   i_nmPlano = -1;
        char   *query;
        int     idUFOperadora;
	EXEC SQL END DECLARE SECTION;

	memset( &nmPlano, 0x0, sizeof(nmPlano) );
	strToOra( idTipoCliente,idTipoClientePrm );
	ULOG( "idRegional    [%d]",idRegional );
	ULOG( "idTipoCliente [%s]",(char*)idTipoCliente.arr );
	ULOG( "idTipoLinha   [%d]",idTipoLinha );

	try
	{
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL
			SELECT
			   UFOPERADORA.IDUFOPERADORA
			INTO
			  :idUFOperadora
			FROM
			   CUSTOMER.UFOPERADORA UFOPERADORA
			WHERE
			   UFOPERADORA.IDUF = :idRegional;
		
		queryStr = 
			"SELECT DISTINCT "
			"   PLANO.IDPLANO , "
			"   PLANO.NMPLANO "
			"FROM "
			"   RETENCAO.PLANO PLANO , "
			"   RETENCAO.MATRIZPLANOS MATRIZPLANOS "
			"WHERE "
			"   PLANO.IDPLANO > 0 "
			" AND PLANO.INATIVO > 0 "
            " AND MATRIZPLANOS.IDPLANO = PLANO.IDPLANO ";

		if ( idRegional > 0 )
		{
			queryStr += 
				" AND "
				"   MATRIZPLANOS.IDUFOPERADORA = ";
			sprintf( sbf, "%d", idUFOperadora );
		    queryStr += sbf;
		}   
   
		if ( (char *)idTipoCliente.arr[0] != 0x0 )
		{
			queryStr += 
				" AND "
				"   MATRIZPLANOS.IDTIPOPESSOA = ";
			sprintf( sbf, "%s", (char *)idTipoCliente.arr );
		    queryStr += sbf;
		}   

		if ( idTipoLinha > 0 )
		{
			queryStr += 
				" AND "
				"   MATRIZPLANOS.IDTIPOLINHA = ";
			sprintf( sbf, "%d", idTipoLinha );
		    queryStr += sbf;
		}   
		queryStr += 
			"   ORDER BY PLANO.NMPLANO";
   
		query = (char *)queryStr.c_str();
		ULOG( "QUERY=%s",query );

	    EXEC SQL PREPARE qryListaPlanos FROM :query;
	    EXEC SQL DECLARE crsListaPlanos CURSOR FOR qryListaPlanos;

		xml->createTag( "Tabelas" );
			xml->createTag( "Planos" );
			
			EXEC SQL OPEN crsListaPlanos;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsListaPlanos INTO :idPlano, 
					                               :nmPlano:i_nmPlano;
				endOraStr( nmPlano );
				
				xml->createTag("It");
					xml->addItem( "id",idPlano );
					xml->addItem( "ds",(char*)nmPlano.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsListaPlanos;
			
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "ListaPlanos()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: ListaPlanos()" );
		throw;
	}

}



void ListaBonus( char * idRegionalPrm, char * idTipoClientePrm, char * idTipoLinhaPrm, char * idSegmentacaoPrm, char * idTipoBonusPrm, XMLGen *xml )
{
	ULOG_START( "ListaBonus()" );

    string queryStr;
    char sbf[64];
    
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR idRegional[32] ;
		VARCHAR idTipoCliente[32] ;
		VARCHAR idTipoLinha[32] ;
		VARCHAR idSegmentacao[32] ;
		VARCHAR idTipoBonus[32] ;
		int     qtDias;
		int     idBonus;
		VARCHAR dsTpBonus[256];
		short   i_dsTpBonus = -1;
		VARCHAR nmBonus[256];
		short   i_nmBonus = -1;
        char   *query;
        int     idUFOperadora;
	EXEC SQL END DECLARE SECTION;

	memset( &nmBonus, 0x0, sizeof(nmBonus) );
	
	memset( &idRegional, 0x0, sizeof(idRegional) );
	memset( &idTipoCliente, 0x0, sizeof(idTipoCliente) );
	memset( &idTipoLinha, 0x0, sizeof(idTipoLinha) );
	memset( &idSegmentacao, 0x0, sizeof(idSegmentacao) );
	memset( &idTipoBonus, 0x0, sizeof(idTipoBonus) );
	
	memset( &nmBonus, 0x0, sizeof(nmBonus) );
	
	strToOra( idRegional,idRegionalPrm );
	strToOra( idTipoCliente,idTipoClientePrm );
	strToOra( idTipoLinha,idTipoLinhaPrm );
	strToOra( idSegmentacao,idSegmentacaoPrm );
	strToOra( idTipoBonus,idTipoBonusPrm );

	ULOG( "idRegional    [%s]",(char*)idRegional.arr );
	ULOG( "idTipoCliente [%s]",(char*)idTipoCliente.arr );
	ULOG( "idTipoLinha   [%s]",(char*)idTipoLinha.arr );
	ULOG( "idSegmentacao [%s]",(char*)idSegmentacao.arr );
	ULOG( "idTipoBonus    [%s]",(char*)idTipoBonus.arr );

	try
	{
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL
			SELECT
			   UFOPERADORA.IDUFOPERADORA
			INTO
			  :idUFOperadora
			FROM
			   CUSTOMER.UFOPERADORA UFOPERADORA
			WHERE
			   UFOPERADORA.IDUF = :idRegional;
		
		queryStr = 
			"SELECT DISTINCT "
			"   BONUS.IDBONUS , "
			"   BONUS.IDUNIDADEOFERTA , "
			"   BONUS.NRVALIDADE , "
			"   BONUS.DSBONUS "
			"FROM "
			"   RETENCAO.BONUS BONUS , "
			"   RETENCAO.MATRIZBONUS MATRIZBONUS "
			"WHERE "
            "   MATRIZBONUS.IDBONUS = BONUS.IDBONUS "
            "AND   BONUS.INATIVO = 1 ";

		if ( (char *)idRegional.arr[0] != NULL )
		{
			queryStr += 
				" AND "
				"   MATRIZBONUS.IDUFOPERADORA = ";
			sprintf( sbf, "%d", idUFOperadora );
		    queryStr += sbf;
		}   
   
		if ( (char *)idTipoCliente.arr[0] != NULL )
		{
			queryStr += 
				" AND "
				"   MATRIZBONUS.IDTIPOPESSOA = ";
			sprintf( sbf, "%s", (char *)idTipoCliente.arr );
		    queryStr += sbf;
		}   

		if ( (char *)idTipoLinha.arr[0] != NULL )
		{
			queryStr += 
				" AND "
				"   MATRIZBONUS.IDTIPOLINHA = ";
			sprintf( sbf, "%s", (char *)idTipoLinha.arr );
		    queryStr += sbf;
		}   

		if ( (char *)idSegmentacao.arr[0] != NULL )
		{
			queryStr += 
				" AND "
				"   MATRIZBONUS.IDSEGMENTACAO = ";
			sprintf( sbf, "%s", (char *)idSegmentacao.arr );
		    queryStr += sbf;
		}   

		if ( (char *)idTipoBonus.arr[0] != NULL )
		{
			queryStr += 
				" AND "
				"   BONUS.IDUNIDADEOFERTA = ";
			sprintf( sbf, "%s", (char *)idTipoBonus.arr );
		    queryStr += sbf;
		}   

		queryStr += 
			"   ORDER BY BONUS.DSBONUS";
   
		query = (char *)queryStr.c_str();
		ULOG( "QUERY=%s",query );

	    EXEC SQL PREPARE qryListaBonus FROM :query;
	    EXEC SQL DECLARE crsListaBonus CURSOR FOR qryListaBonus;

		xml->createTag( "Tabelas" );
			xml->createTag( "Bonus" );
			
			EXEC SQL OPEN crsListaBonus;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsListaBonus INTO :idBonus ,
					                              :idTipoBonus ,
					                              :qtDias , 
					                              :nmBonus:i_nmBonus;
				
				EXEC SQL
				select nmoferta
				INTO
				   :dsTpBonus:i_dsTpBonus
				from retencao.oferta o,
					 retencao.ofertatipobonus otb
				where o.IDUNIDADEOFERTA=otb.IDUNIDADEOFERTA
				and o.idunidadeoferta = :idTipoBonus;				
				
				
				endOraStr( nmBonus );
				endOraStr( dsTpBonus );
				endOraStr( idTipoBonus );
				
				xml->createTag("Linha");
					xml->addItem( "idBonus",idBonus );
					xml->addItem( "tpBonus",(char *)idTipoBonus.arr );
					xml->addItem( "vdBonus",qtDias );
					xml->addItem( "dsBonus",(char*)nmBonus.arr );
					xml->addItem( "dsTpBonus",(char*)dsTpBonus.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsListaBonus;
			
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "ListaBonus()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: ListaBonus()" );
		throw;
	}

}



void ListaMigracao( int idRegionalPrm, char * idTipoClientePrm, int idTipoLinhaPrm, XMLGen *xml )
{
	ULOG_START( "ListaMigracao()" );

    string queryStr;
    char sbf[64];
    
	EXEC SQL BEGIN DECLARE SECTION;
		int     idRegional    = idRegionalPrm;
		VARCHAR idTipoCliente[32];
		int     idTipoLinha   = idTipoLinhaPrm;
		VARCHAR vlBonus[64];
		int     qtDias;
		int     idMigracao;
		VARCHAR nmMigracao[256];
		short   i_nmMigracao = -1;
        char   *query;
        int     idUFOperadora;
	EXEC SQL END DECLARE SECTION;

	memset( &nmMigracao, 0x0, sizeof(nmMigracao) );
	strToOra( idTipoCliente,idTipoClientePrm );
	ULOG( "idRegional    [%d]",idRegional );
	ULOG( "idTipoCliente [%s]",(char*)idTipoCliente.arr );
	ULOG( "idTipoLinha   [%d]",idTipoLinha );

	try
	{
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL
			SELECT
			   UFOPERADORA.IDUFOPERADORA
			INTO
			  :idUFOperadora
			FROM
			   CUSTOMER.UFOPERADORA UFOPERADORA
			WHERE
			   UFOPERADORA.IDUF = :idRegional;
		
		queryStr = 
			"SELECT DISTINCT "
            "   MIGRACAO.IDMIGRACAO , "
            "   MIGRACAO.DSMIGRACAO , "
            "   TO_CHAR(MIGRACAO.VLBONUS,'999999999D99') , "
            "   MIGRACAO.NRVALIDADE "
			"FROM "
			"   RETENCAO.MIGRACAO MIGRACAO , "
			"   RETENCAO.MATRIZMIGRACAO MATRIZMIGRACAO "
			"WHERE "
			"   MIGRACAO.IDMIGRACAO > 0 "
            " AND MIGRACAO.INATIVO = 1 AND MATRIZMIGRACAO.IDMIGRACAO = MIGRACAO.IDMIGRACAO ";

		if ( idRegional > 0 )
		{
			queryStr += 
				" AND "
				"   MATRIZMIGRACAO.IDUFOPERADORA = ";
			sprintf( sbf, "%d", idUFOperadora );
		    queryStr += sbf;
		}   
   
		if ( (char *)idTipoCliente.arr[0] != 0x0 )
		{
			queryStr += 
				" AND "
				"   MATRIZMIGRACAO.IDTIPOPESSOA = ";
			sprintf( sbf, "%s", (char*)idTipoCliente.arr );
		    queryStr += sbf;
		}   

		if ( idTipoLinha > 0 )
		{
			queryStr += 
				" AND "
				"   MATRIZMIGRACAO.IDTIPOLINHA = ";
			sprintf( sbf, "%d", idTipoLinha );
		    queryStr += sbf;
		}   

		queryStr += 
			"   ORDER BY MIGRACAO.DSMIGRACAO";
   
		query = (char *)queryStr.c_str();
		ULOG( "QUERY=%s",query );

	    EXEC SQL PREPARE qryListaMigracao FROM :query;
	    EXEC SQL DECLARE crsListaMigracao CURSOR FOR qryListaMigracao;

		xml->createTag( "Tabelas" );
			xml->createTag( "Migracao" );
			
			EXEC SQL OPEN crsListaMigracao;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsListaMigracao INTO :idMigracao ,
					                                 :nmMigracao:i_nmMigracao ,
					                                 :vlBonus ,
					                                 :qtDias ;
				endOraStr( nmMigracao );
				endOraStr( vlBonus );
				
				xml->createTag("Linha");
					xml->addItem( "idMigra",idMigracao );
					xml->addItem( "dsMigra",(char*)nmMigracao.arr );
					xml->addItem( "vlBonus",(char*)vlBonus.arr );
					xml->addItem( "vdMigra",qtDias );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsListaMigracao;
			
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "ListaMigracao()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: ListaMigracao()" );
		throw;
	}

}



void ListaOfertas( char * sgOfertaPrm, char * nmOfertaPrm, XMLGen *xml )
{
	ULOG_START( "ListaOfertas()" );

    string queryStr;

	EXEC SQL BEGIN DECLARE SECTION;
		char nmOfe[256];
		char sgOfe[256];
		int      idOferta;
		VARCHAR  tpOferta[256];
		short    i_tpOferta = -1;
		VARCHAR  nmOferta[256];
		short    i_nmOferta = -1;
		VARCHAR  sgTpOferta[256];
		short    i_sgTpOferta = -1;
	EXEC SQL END DECLARE SECTION;

	if ( nmOfertaPrm[0] != NULL )
	{
	    sprintf(nmOfe,"%%%s%%%",nmOfertaPrm);
		ULOG( "nmOfe [%s]",nmOfe );
	}
	
	if ( sgOfertaPrm[0] != NULL )
	{
	    sprintf(sgOfe,"%%%s%%%",sgOfertaPrm);
		ULOG( "sgOfe [%s]",sgOfe );
	}
	
	memset( &nmOferta, 0x0, sizeof(nmOferta) );
	memset( &tpOferta, 0x0, sizeof(tpOferta) );
	

	try
	{
		EXEC SQL WHENEVER NOT FOUND DO BREAK;

		if ( nmOfertaPrm[0] != 0x0 && sgOfertaPrm[0] == 0x0 )
		{
			EXEC SQL DECLARE crsOfertas CURSOR FOR
            SELECT
               OFERTA.IDUNIDADEOFERTA ,
               TIPOOFERTA.DSTIPOOFERTA ,
               TIPOOFERTA.SGTIPOOFERTA ,
               OFERTA.NMOFERTA
            FROM   
               RETENCAO.OFERTA OFERTA ,
               RETENCAO.TIPOOFERTA TIPOOFERTA
            WHERE
               OFERTA.IDUNIDADEOFERTA > 0
            AND
               OFERTA.INATIVO = 1
            AND
               UPPER(OFERTA.NMOFERTA) LIKE UPPER(TRIM(:nmOfe))
            AND
               TIPOOFERTA.SGTIPOOFERTA = OFERTA.SGCLASSIFICACAO 
            ORDER BY TRIM(UPPER(OFERTA.NMOFERTA));
            
			EXEC SQL OPEN crsOfertas;
			xml->createTag( "Tabelas" );
				xml->createTag( "ParamOfertas" );
				for(;;)
				{
					EXEC SQL FETCH crsOfertas INTO :idOferta ,
						                           :tpOferta:i_tpOferta , 
						                           :sgTpOferta:i_sgTpOferta ,
						                           :nmOferta:i_nmOferta ;
					endOraStr( tpOferta );
					endOraStr( nmOferta );
					endOraStr( sgTpOferta );
					xml->createTag("Linha");
						xml->addItem( "idOferta",idOferta );
						xml->addItem( "dsOferta",(char*)nmOferta.arr );
						xml->addItem( "sgTpOferta",(char*)sgTpOferta.arr );
						xml->addItem( "dsTpOferta",(char*)tpOferta.arr );
					xml->closeTag();
		
				}                      
				EXEC SQL CLOSE crsOfertas;
				xml->closeTag();
			xml->closeTag();

		}
		if ( nmOfertaPrm[0] != 0x0 && sgOfertaPrm[0] != 0x0 )
		{
			EXEC SQL DECLARE crsOfertas1 CURSOR FOR
            SELECT
               OFERTA.IDUNIDADEOFERTA ,
               TIPOOFERTA.DSTIPOOFERTA ,
               TIPOOFERTA.SGTIPOOFERTA ,
               OFERTA.NMOFERTA
            FROM   
               RETENCAO.OFERTA OFERTA ,
               RETENCAO.TIPOOFERTA TIPOOFERTA
            WHERE
               OFERTA.IDUNIDADEOFERTA > 0
            AND
               OFERTA.INATIVO = 1
            AND
               UPPER(OFERTA.NMOFERTA) LIKE UPPER(TRIM(:nmOfe))
            AND
               UPPER(TIPOOFERTA.SGTIPOOFERTA) LIKE UPPER(TRIM(:sgOfe))
            AND
               TIPOOFERTA.SGTIPOOFERTA = OFERTA.SGCLASSIFICACAO 
            ORDER BY TRIM(UPPER(OFERTA.NMOFERTA));
            
			EXEC SQL OPEN crsOfertas1;
			xml->createTag( "Tabelas" );
				xml->createTag( "ParamOfertas" );
				for(;;)
				{
					EXEC SQL FETCH crsOfertas1 INTO :idOferta ,
						                           :tpOferta:i_tpOferta , 
						                           :sgTpOferta:i_sgTpOferta ,
						                           :nmOferta:i_nmOferta ;
					endOraStr( tpOferta );
					endOraStr( nmOferta );
					endOraStr( sgTpOferta );
					xml->createTag("Linha");
						xml->addItem( "idOferta",idOferta );
						xml->addItem( "dsOferta",(char*)nmOferta.arr );
						xml->addItem( "sgTpOferta",(char*)sgTpOferta.arr );
						xml->addItem( "dsTpOferta",(char*)tpOferta.arr );
					xml->closeTag();
		
				}                      
				EXEC SQL CLOSE crsOfertas1;
				xml->closeTag();
			xml->closeTag();

		}	
		if ( nmOfertaPrm[0] == 0x0 && sgOfertaPrm[0] != 0x0 )
		{
			EXEC SQL DECLARE crsOfertas2 CURSOR FOR
            SELECT
               OFERTA.IDUNIDADEOFERTA ,
               TIPOOFERTA.DSTIPOOFERTA ,
               TIPOOFERTA.SGTIPOOFERTA ,
               OFERTA.NMOFERTA
            FROM   
               RETENCAO.OFERTA OFERTA ,
               RETENCAO.TIPOOFERTA TIPOOFERTA
            WHERE
               OFERTA.IDUNIDADEOFERTA > 0
            AND
               OFERTA.INATIVO = 1
            AND
               UPPER(TIPOOFERTA.SGTIPOOFERTA) LIKE UPPER(TRIM(:sgOfe))
            AND
               TIPOOFERTA.SGTIPOOFERTA = OFERTA.SGCLASSIFICACAO 
            ORDER BY TRIM(UPPER(OFERTA.NMOFERTA));
                        
			EXEC SQL OPEN crsOfertas2;
			xml->createTag( "Tabelas" );
				xml->createTag( "ParamOfertas" );
				for(;;)
				{
					EXEC SQL FETCH crsOfertas2 INTO :idOferta ,
						                           :tpOferta:i_tpOferta , 
						                           :sgTpOferta:i_sgTpOferta ,
						                           :nmOferta:i_nmOferta ;
					endOraStr( tpOferta );
					endOraStr( sgTpOferta );
					endOraStr( nmOferta );
					xml->createTag("Linha");
						xml->addItem( "idOferta",idOferta );
						xml->addItem( "dsOferta",(char*)nmOferta.arr );
						xml->addItem( "sgTpOferta",(char*)sgTpOferta.arr );
						xml->addItem( "dsTpOferta",(char*)tpOferta.arr );
					xml->closeTag();
		
				}                      
				EXEC SQL CLOSE crsOfertas2;
				xml->closeTag();
			xml->closeTag();

		}
		if ( nmOfertaPrm[0] == 0x0 && sgOfertaPrm[0] == 0x0 )
		{
			EXEC SQL DECLARE crsOfertas3 CURSOR FOR
            SELECT
               OFERTA.IDUNIDADEOFERTA ,
               TIPOOFERTA.DSTIPOOFERTA ,
               TIPOOFERTA.SGTIPOOFERTA ,
               OFERTA.NMOFERTA
            FROM   
               RETENCAO.OFERTA OFERTA ,
               RETENCAO.TIPOOFERTA TIPOOFERTA
            WHERE
               OFERTA.IDUNIDADEOFERTA > 0
            AND
               OFERTA.INATIVO = 1
            AND
               TIPOOFERTA.SGTIPOOFERTA = OFERTA.SGCLASSIFICACAO 
            ORDER BY TRIM(UPPER(OFERTA.NMOFERTA));
                                    
			EXEC SQL OPEN crsOfertas3;
			xml->createTag( "Tabelas" );
				xml->createTag( "ParamOfertas" );
				for(;;)
				{
					EXEC SQL FETCH crsOfertas3 INTO :idOferta ,
						                           :tpOferta:i_tpOferta , 
						                           :sgTpOferta:i_sgTpOferta ,
						                           :nmOferta:i_nmOferta ;
					endOraStr( tpOferta );
					endOraStr( sgTpOferta );
					endOraStr( nmOferta );
					xml->createTag("Linha");
						xml->addItem( "idOferta",idOferta );
						xml->addItem( "dsOferta",(char*)nmOferta.arr );
						xml->addItem( "sgTpOferta",(char*)sgTpOferta.arr );
						xml->addItem( "dsTpOferta",(char*)tpOferta.arr );
					xml->closeTag();
		
				}                      
				EXEC SQL CLOSE crsOfertas3;
				xml->closeTag();
			xml->closeTag();

		}


		ULOG_END( "ListaOfertas()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: ListaOfertas()" );
		throw;
	}

}



void sel_TipoLinhaMigracao( int idMigracaoPrm, XMLGen *xml )
{
	ULOG_START( "sel_TipoLinhaMigracao()" );

	EXEC SQL BEGIN DECLARE SECTION;
		int     idMigracao = idMigracaoPrm;
		int     idTipoLinha; 
		VARCHAR dsTipoLinha[256]; 
		short   i_dsTipoLinha = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &dsTipoLinha, 0x0, sizeof(dsTipoLinha) );
	ULOG( "idMigracao [%d]",idMigracaoPrm );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsTPLinhaDispMigra CURSOR FOR
		SELECT
		   TIPOLINHA.IDTIPOLINHA ,
		   TIPOLINHA.DSTIPOLINHA
		FROM
		   APOIO.TIPOLINHA TIPOLINHA
		WHERE
		   TIPOLINHA.IDTIPOLINHA NOT IN
		(
		   SELECT
		      MATRIZMIGRACAO.IDTIPOLINHA
		   FROM
		      RETENCAO.MATRIZMIGRACAO MATRIZMIGRACAO
		   WHERE
		      MATRIZMIGRACAO.IDMIGRACAO = :idMigracao
		)
		ORDER BY TRIM(UPPER(TIPOLINHA.DSTIPOLINHA));
		
		// Selecionados
		EXEC SQL DECLARE crsTPLinhaSelMigra CURSOR FOR
		SELECT
		   TIPOLINHA.IDTIPOLINHA ,
		   TIPOLINHA.DSTIPOLINHA
		FROM
		   APOIO.TIPOLINHA TIPOLINHA
		WHERE
		   TIPOLINHA.IDTIPOLINHA IN
		(
		   SELECT
		      MATRIZMIGRACAO.IDTIPOLINHA
		   FROM
		      RETENCAO.MATRIZMIGRACAO MATRIZMIGRACAO
		   WHERE
		      MATRIZMIGRACAO.IDMIGRACAO = :idMigracao
		)
		ORDER BY TRIM(UPPER(TIPOLINHA.DSTIPOLINHA));
				
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","TPLINHA" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsTPLinhaDispMigra;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTPLinhaDispMigra INTO :idTipoLinha, 
					                             	      :dsTipoLinha:i_dsTipoLinha;
				endOraStr( dsTipoLinha );
				xml->createTag("It");
					xml->addItem( "id",idTipoLinha );
					xml->addItem( "ds",(char*)dsTipoLinha.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTPLinhaDispMigra;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsTPLinhaSelMigra;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTPLinhaSelMigra INTO :idTipoLinha, 
					                             	     :dsTipoLinha:i_dsTipoLinha;
				endOraStr( dsTipoLinha );
				xml->createTag("It");
					xml->addItem( "id",idTipoLinha );
					xml->addItem( "ds",(char*)dsTipoLinha.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTPLinhaSelMigra;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_TipoLinhaMigracao()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_TipoLinhaMigracao()" );
		throw;
	}

}



void sel_RIntencaoScript( char * idScriptPrm, XMLGen * xml )
{
	ULOG_START( "sel_RIntencaoScript()" );

	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR idScript[256];
		VARCHAR idRIntencao[256]; 
		VARCHAR dsRIntencao[256]; 
		short   i_idRIntencao = -1;
		short   i_dsRIntencao = -1;
	EXEC SQL END DECLARE SECTION;

	strToOra( idScript,idScriptPrm );
	ULOG( "idScript [%s]",(char*)idScript.arr );

	memset( &idRIntencao, 0x0, sizeof(idRIntencao) );
	memset( &dsRIntencao, 0x0, sizeof(dsRIntencao) );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsRIntencaoDispScript CURSOR FOR
		SELECT RESPOSTA.IDRESPOSTA ,
		       RESPOSTA.DSRESPOSTA
		  FROM QUESTIONARIO.RESPOSTA RESPOSTA 
         WHERE 1 = RESPOSTA.INDISPONIBILIDADE
         AND 1 = RESPOSTA.IDPERGUNTA
         AND RESPOSTA.IDRESPOSTA NOT IN
		(
            SELECT   
                sintencao.IDRESPOSTAINTENCAO
            FROM 
               retencao.scriptrespostaintencao sintencao
            where
               sintencao.IDSCRIPT = :idScript
        )
		ORDER BY TRIM(UPPER(RESPOSTA.DSRESPOSTA));
		
		// Selecionados
		EXEC SQL DECLARE crsRIntencaoSelScript CURSOR FOR
		SELECT RESPOSTA.IDRESPOSTA ,
		       RESPOSTA.DSRESPOSTA
		  FROM QUESTIONARIO.RESPOSTA RESPOSTA 
         WHERE 1 = RESPOSTA.INDISPONIBILIDADE
         AND 1 = RESPOSTA.IDPERGUNTA
         AND RESPOSTA.IDRESPOSTA IN
		(
            SELECT   
                sintencao.IDRESPOSTAINTENCAO
            FROM 
               retencao.scriptrespostaintencao sintencao
            where
               sintencao.IDSCRIPT = :idScript
        )
		ORDER BY TRIM(UPPER(RESPOSTA.DSRESPOSTA));

		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","INTENCAO" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsRIntencaoDispScript;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsRIntencaoDispScript INTO :idRIntencao:i_idRIntencao, 
					                             	     :dsRIntencao:i_dsRIntencao;
				endOraStr( idRIntencao );
				endOraStr( dsRIntencao );
				xml->createTag("It");
					xml->addItem( "id",(char*)idRIntencao.arr );
					xml->addItem( "ds",(char*)dsRIntencao.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsRIntencaoDispScript;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsRIntencaoSelScript;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsRIntencaoSelScript INTO :idRIntencao:i_idRIntencao, 
					                             	    :dsRIntencao:i_dsRIntencao;
				endOraStr( idRIntencao );
				endOraStr( dsRIntencao );
				xml->createTag("It");
					xml->addItem( "id",(char*)idRIntencao.arr );
					xml->addItem( "ds",(char*)dsRIntencao.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsRIntencaoSelScript;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_RIntencaoScript()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_RIntencaoScript()" );
		throw;
	}

}



void sel_RDestinoScript( char * idScriptPrm, XMLGen * xml )
{
	ULOG_START( "sel_RDestinoScript()" );

	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR idScript[256];
		VARCHAR idRDestino[256]; 
		VARCHAR dsRDestino[256]; 
		short   i_idRDestino = -1;
		short   i_dsRDestino = -1;
	EXEC SQL END DECLARE SECTION;

	strToOra( idScript,idScriptPrm );
	ULOG( "idScript [%s]",(char*)idScript.arr );

	memset( &idRDestino, 0x0, sizeof(idRDestino) );
	memset( &dsRDestino, 0x0, sizeof(dsRDestino) );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsRDestinoDispScript CURSOR FOR
		SELECT RESPOSTA.IDRESPOSTA ,
		       RESPOSTA.DSRESPOSTA
		  FROM QUESTIONARIO.RESPOSTA RESPOSTA 
         WHERE 1 = RESPOSTA.INDISPONIBILIDADE
         AND 2 = RESPOSTA.IDPERGUNTA
         AND RESPOSTA.IDRESPOSTA NOT IN
		(
            SELECT   
                sdestino.IDRESPOSTADESTINO
            FROM 
               retencao.scriptrespostadestino sdestino
            where
               sdestino.IDSCRIPT = :idScript
        )
		ORDER BY TRIM(UPPER(RESPOSTA.DSRESPOSTA));
		
		// Selecionados
		EXEC SQL DECLARE crsRDestinoSelScript CURSOR FOR
		SELECT RESPOSTA.IDRESPOSTA ,
		       RESPOSTA.DSRESPOSTA
		  FROM QUESTIONARIO.RESPOSTA RESPOSTA 
         WHERE 1 = RESPOSTA.INDISPONIBILIDADE
         AND 2 = RESPOSTA.IDPERGUNTA
         AND RESPOSTA.IDRESPOSTA IN
		(
            SELECT   
                sdestino.IDRESPOSTADESTINO
            FROM 
               retencao.scriptrespostadestino sdestino
            where
               sdestino.IDSCRIPT = :idScript
        )
		ORDER BY TRIM(UPPER(RESPOSTA.DSRESPOSTA));

		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","DESTINO" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsRDestinoDispScript;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsRDestinoDispScript INTO :idRDestino:i_idRDestino, 
					                             	     :dsRDestino:i_dsRDestino;
				endOraStr( idRDestino );
				endOraStr( dsRDestino );
				xml->createTag("It");
					xml->addItem( "id",(char*)idRDestino.arr );
					xml->addItem( "ds",(char*)dsRDestino.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsRDestinoDispScript;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsRDestinoSelScript;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsRDestinoSelScript INTO :idRDestino:i_idRDestino, 
					                             	    :dsRDestino:i_dsRDestino;
				endOraStr( idRDestino );
				endOraStr( dsRDestino );
				xml->createTag("It");
					xml->addItem( "id",(char*)idRDestino.arr );
					xml->addItem( "ds",(char*)dsRDestino.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsRDestinoSelScript;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_RDestinoScript()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_RDestinoScript()" );
		throw;
	}

}



void sel_OfertaScript( char * idScriptPrm, XMLGen * xml )
{
	ULOG_START( "sel_OfertaScript()" );

	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR idScript[256];
		VARCHAR idOferta[256]; 
		VARCHAR dsOferta[256]; 
		short   i_idOferta = -1;
		short   i_dsOferta = -1;
	EXEC SQL END DECLARE SECTION;

	strToOra( idScript,idScriptPrm );
	ULOG( "idScript [%s]",(char*)idScript.arr );

	memset( &idOferta, 0x0, sizeof(idOferta) );
	memset( &dsOferta, 0x0, sizeof(dsOferta) );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsOfertaDispScript CURSOR FOR
		SELECT OFERTA.IDUNIDADEOFERTA ,
		       OFERTA.NMOFERTA
		  FROM RETENCAO.OFERTA OFERTA 
         WHERE 1 = OFERTA.INATIVO 
         AND OFERTA.IDUNIDADEOFERTA NOT IN
		(
            SELECT   
                soferta.IDOFERTA
            FROM 
               retencao.scriptoferta soferta
            where
               soferta.IDSCRIPT = :idScript
        )
		ORDER BY TRIM(UPPER(OFERTA.NMOFERTA));
		
		// Selecionados
		EXEC SQL DECLARE crsOfertaSelScript CURSOR FOR
		SELECT OFERTA.IDUNIDADEOFERTA ,
		       OFERTA.NMOFERTA
		  FROM RETENCAO.OFERTA OFERTA 
         WHERE 1 = OFERTA.INATIVO 
         AND OFERTA.IDUNIDADEOFERTA IN
		(
            SELECT   
                soferta.IDOFERTA
            FROM 
               retencao.scriptoferta soferta
            where
               soferta.IDSCRIPT = :idScript
        )
		ORDER BY TRIM(UPPER(OFERTA.NMOFERTA));        
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","OFERTAS" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsOfertaDispScript;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsOfertaDispScript INTO :idOferta:i_idOferta, 
					                             	     :dsOferta:i_dsOferta;
				endOraStr( idOferta );
				endOraStr( dsOferta );
				xml->createTag("It");
					xml->addItem( "id",(char*)idOferta.arr );
					xml->addItem( "ds",(char*)dsOferta.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsOfertaDispScript;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsOfertaSelScript;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsOfertaSelScript INTO :idOferta:i_idOferta, 
					                             	    :dsOferta:i_dsOferta;
				endOraStr( idOferta );
				endOraStr( dsOferta );
				xml->createTag("It");
					xml->addItem( "id",(char*)idOferta.arr );
					xml->addItem( "ds",(char*)dsOferta.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsOfertaSelScript;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_OfertaScript()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_OfertaScript()" );
		throw;
	}

}



void sel_GrupoScript( char * idScriptPrm, XMLGen * xml )
{
	ULOG_START( "sel_GrupoScript()" );

	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR idScript[256];
		VARCHAR idGrupo[256]; 
		VARCHAR dsGrupo[256]; 
		short   i_idGrupo = -1;
		short   i_dsGrupo = -1;
	EXEC SQL END DECLARE SECTION;

	strToOra( idScript,idScriptPrm );
	ULOG( "idScript [%s]",(char*)idScript.arr );

	memset( &idGrupo, 0x0, sizeof(idGrupo) );
	memset( &dsGrupo, 0x0, sizeof(dsGrupo) );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsGrupoDispScript CURSOR FOR
        SELECT   grupo.idgrupo, grupo.nmgrupo
            FROM acesso.grupo grupo
           WHERE grupo.idgrupo IN (SELECT grupomotivoordem.idgrupo
                                     FROM retencao.grupomotivoordem grupomotivoordem)
             AND grupo.idgrupo NOT IN (SELECT sgrupo.idgrupo
                                         FROM retencao.scriptgrupo sgrupo
                                        WHERE sgrupo.idscript = :idScript)
        ORDER BY TRIM (UPPER (grupo.nmgrupo));
		
		// Selecionados
		EXEC SQL DECLARE crsGrupoSelScript CURSOR FOR
        SELECT   grupo.idgrupo, grupo.nmgrupo
            FROM acesso.grupo grupo
           WHERE grupo.idgrupo IN (SELECT grupomotivoordem.idgrupo
                                     FROM retencao.grupomotivoordem grupomotivoordem)
             AND grupo.idgrupo IN (SELECT sgrupo.idgrupo
                                         FROM retencao.scriptgrupo sgrupo
                                        WHERE sgrupo.idscript = :idScript)
        ORDER BY TRIM (UPPER (grupo.nmgrupo));
        
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","GRUPOS" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsGrupoDispScript;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsGrupoDispScript INTO :idGrupo:i_idGrupo, 
					                             	     :dsGrupo:i_dsGrupo;
				endOraStr( idGrupo );
				endOraStr( dsGrupo );
				xml->createTag("It");
					xml->addItem( "id",(char*)idGrupo.arr );
					xml->addItem( "ds",(char*)dsGrupo.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsGrupoDispScript;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsGrupoSelScript;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsGrupoSelScript INTO :idGrupo:i_idGrupo, 
					                             	    :dsGrupo:i_dsGrupo;
				endOraStr( idGrupo );
				endOraStr( dsGrupo );
				xml->createTag("It");
					xml->addItem( "id",(char*)idGrupo.arr );
					xml->addItem( "ds",(char*)dsGrupo.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsGrupoSelScript;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_GrupoScript()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_GrupoScript()" );
		throw;
	}

}



void sel_UFScript( char * idScriptPrm, XMLGen * xml )
{
	ULOG_START( "sel_UFScript()" );

	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR idScript[256];
		VARCHAR idUFOperadora[256]; 
		VARCHAR dsUFOperadora[256]; 
		short   i_idUFOperadora = -1;
		short   i_dsUFOperadora = -1;
	EXEC SQL END DECLARE SECTION;

	strToOra( idScript,idScriptPrm );
	ULOG( "idScript [%s]",(char*)idScript.arr );

	memset( &idUFOperadora, 0x0, sizeof(idUFOperadora) );
	memset( &dsUFOperadora, 0x0, sizeof(dsUFOperadora) );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsUFOperadoraDispScript CURSOR FOR
		SELECT UFOPERADORA.IDUFOPERADORA, 
		       UF.NMUF 
		  FROM APOIO.UF UF, 
		       CUSTOMER.UFOPERADORA UFOPERADORA 
         WHERE UFOPERADORA.IDUF = UF.IDUF		   
         and UFOPERADORA.IDUFOPERADORA NOT IN
		(
            SELECT   
                sufoperadora.IDUFOPERADORA
            FROM 
               retencao.scriptufoperadora sufoperadora
            where
               sufoperadora.IDSCRIPT = :idScript
        )
		AND UF.IDUF IN
		   (
		        SELECT
		           IDUF
		        FROM
		           CUSTOMER.UFOPERADORA
                WHERE IDUF > 0
           )
        ORDER BY TRIM(UPPER(UF.NMUF));
		
		// Selecionados
		EXEC SQL DECLARE crsUFOperadoraSelScript CURSOR FOR
		SELECT UFOPERADORA.IDUFOPERADORA, 
		       UF.NMUF 
		  FROM APOIO.UF UF, 
		       CUSTOMER.UFOPERADORA UFOPERADORA 
         WHERE UFOPERADORA.IDUF = UF.IDUF		   
         and UFOPERADORA.IDUFOPERADORA IN
		(
            SELECT   
                sufoperadora.IDUFOPERADORA
            FROM 
               retencao.scriptufoperadora sufoperadora
            where
               sufoperadora.IDSCRIPT = :idScript
        )
		AND UF.IDUF IN
		   (
		        SELECT
		           IDUF
		        FROM
		           CUSTOMER.UFOPERADORA
                WHERE IDUF > 0
           )
        ORDER BY TRIM(UPPER(UF.NMUF));
        
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","REGIONAL" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsUFOperadoraDispScript;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsUFOperadoraDispScript INTO :idUFOperadora:i_idUFOperadora, 
					                             	     :dsUFOperadora:i_dsUFOperadora;
				endOraStr( idUFOperadora );
				endOraStr( dsUFOperadora );
				xml->createTag("It");
					xml->addItem( "id",(char*)idUFOperadora.arr );
					xml->addItem( "ds",(char*)dsUFOperadora.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsUFOperadoraDispScript;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsUFOperadoraSelScript;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsUFOperadoraSelScript INTO :idUFOperadora:i_idUFOperadora, 
					                             	    :dsUFOperadora:i_dsUFOperadora;
				endOraStr( idUFOperadora );
				endOraStr( dsUFOperadora );
				xml->createTag("It");
					xml->addItem( "id",(char*)idUFOperadora.arr );
					xml->addItem( "ds",(char*)dsUFOperadora.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsUFOperadoraSelScript;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_UFScript()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_UFScript()" );
		throw;
	}

}



void sel_TipoLinhaScript( char * idScriptPrm, XMLGen * xml )
{
	ULOG_START( "sel_TipoLinhaScript()" );

	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR idScript[256];
		VARCHAR idTipoLinha[256]; 
		VARCHAR dsTipoLinha[256]; 
		short   i_idTipoLinha = -1;
		short   i_dsTipoLinha = -1;
	EXEC SQL END DECLARE SECTION;

	strToOra( idScript,idScriptPrm );
	ULOG( "idScript [%s]",(char*)idScript.arr );

	memset( &idTipoLinha, 0x0, sizeof(idTipoLinha) );
	memset( &dsTipoLinha, 0x0, sizeof(dsTipoLinha) );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsTPLinhaDispScript CURSOR FOR
		SELECT
		   TIPOLINHA.IDTIPOLINHA ,
		   TIPOLINHA.DSTIPOLINHA
		FROM
		   APOIO.TIPOLINHA TIPOLINHA
		WHERE
		   TIPOLINHA.IDTIPOLINHA NOT IN
		(
            SELECT   
                stipolinha.IDTIPOLINHA 
            FROM 
               retencao.scripttipolinha stipolinha
            where
               stipolinha.IDSCRIPT = :idScript
        )
		ORDER BY TRIM(UPPER(TIPOLINHA.DSTIPOLINHA));
		
		// Selecionados
		EXEC SQL DECLARE crsTPLinhaSelScript CURSOR FOR
		SELECT
		   TIPOLINHA.IDTIPOLINHA ,
		   TIPOLINHA.DSTIPOLINHA
		FROM
		   APOIO.TIPOLINHA TIPOLINHA
		WHERE
		   TIPOLINHA.IDTIPOLINHA IN
		(
            SELECT   
                stipolinha.IDTIPOLINHA 
            FROM 
               retencao.scripttipolinha stipolinha
            where
               stipolinha.IDSCRIPT = :idScript
		)
		ORDER BY TRIM(UPPER(TIPOLINHA.DSTIPOLINHA));
				
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","TPLINHA" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsTPLinhaDispScript;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTPLinhaDispScript INTO :idTipoLinha:i_idTipoLinha, 
					                             	     :dsTipoLinha:i_dsTipoLinha;
				endOraStr( idTipoLinha );
				endOraStr( dsTipoLinha );
				xml->createTag("It");
					xml->addItem( "id",(char*)idTipoLinha.arr );
					xml->addItem( "ds",(char*)dsTipoLinha.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTPLinhaDispScript;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsTPLinhaSelScript;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTPLinhaSelScript INTO :idTipoLinha:i_idTipoLinha, 
					                             	    :dsTipoLinha:i_dsTipoLinha;
				endOraStr( idTipoLinha );
				endOraStr( dsTipoLinha );
				xml->createTag("It");
					xml->addItem( "id",(char*)idTipoLinha.arr );
					xml->addItem( "ds",(char*)dsTipoLinha.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTPLinhaSelScript;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_TipoLinhaScript()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_TipoLinhaScript()" );
		throw;
	}

}



void sel_TipoPessoaScript( char * idScriptPrm, XMLGen * xml )
{
	ULOG_START( "sel_TipoPessoaScript()" );

	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR idScript[256];
		VARCHAR idTipoPessoa[256]; 
		VARCHAR dsTipoPessoa[256]; 
		short   i_idTipoPessoa = -1;
		short   i_dsTipoPessoa = -1;
	EXEC SQL END DECLARE SECTION;

	strToOra( idScript,idScriptPrm );
	ULOG( "idScript [%s]",(char*)idScript.arr );

	memset( &idTipoPessoa, 0x0, sizeof(idTipoPessoa) );
	memset( &dsTipoPessoa, 0x0, sizeof(dsTipoPessoa) );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsTPPessoaDispScript CURSOR FOR
		SELECT
		   TIPOPESSOA.IDTIPOPESSOA ,
		   TIPOPESSOA.DSTIPOPESSOA
		FROM
		   APOIO.TIPOPESSOA TIPOPESSOA
		WHERE
           TIPOPESSOA.IDTIPOPESSOA NOT IN
        (
            SELECT   
                stipopessoa.IDTIPOPESSOA
            FROM 
               retencao.scripttipopessoa stipopessoa
            where
               stipopessoa.IDSCRIPT = :idScript
        )
        ORDER BY TRIM(UPPER(TIPOPESSOA.DSTIPOPESSOA));
		
		// Selecionados
		EXEC SQL DECLARE crsTPPessoaSelScript CURSOR FOR
		SELECT
		   TIPOPESSOA.IDTIPOPESSOA ,
		   TIPOPESSOA.DSTIPOPESSOA
		FROM
		   APOIO.TIPOPESSOA TIPOPESSOA
		WHERE
           TIPOPESSOA.IDTIPOPESSOA IN
        (
            SELECT   
                stipopessoa.IDTIPOPESSOA
            FROM 
               retencao.scripttipopessoa stipopessoa
            where
               stipopessoa.IDSCRIPT = :idScript
        )
        ORDER BY TRIM(UPPER(TIPOPESSOA.DSTIPOPESSOA));				
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","TPCLIENTE" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsTPPessoaDispScript;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTPPessoaDispScript INTO :idTipoPessoa:i_idTipoPessoa, 
					                             	     :dsTipoPessoa:i_dsTipoPessoa;
				endOraStr( idTipoPessoa );
				endOraStr( dsTipoPessoa );
				xml->createTag("It");
					xml->addItem( "id",(char*)idTipoPessoa.arr );
					xml->addItem( "ds",(char*)dsTipoPessoa.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTPPessoaDispScript;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsTPPessoaSelScript;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTPPessoaSelScript INTO :idTipoPessoa:i_idTipoPessoa, 
					                             	    :dsTipoPessoa:i_dsTipoPessoa;
				endOraStr( idTipoPessoa );
				endOraStr( dsTipoPessoa );
				xml->createTag("It");
					xml->addItem( "id",(char*)idTipoPessoa.arr );
					xml->addItem( "ds",(char*)dsTipoPessoa.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTPPessoaSelScript;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_TipoPessoaScript()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_TipoPessoaScript()" );
		throw;
	}

}



void sel_SegmentacaoScript( char * idScriptPrm, XMLGen * xml )
{
	ULOG_START( "sel_SegmentacaoScript()" );

	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR idScript[256];
		VARCHAR idSegmentacao[256]; 
		VARCHAR dsSegmentacao[256]; 
		short   i_idSegmentacao = -1;
		short   i_dsSegmentacao = -1;
	EXEC SQL END DECLARE SECTION;

	strToOra( idScript,idScriptPrm );
	ULOG( "idScript [%s]",(char*)idScript.arr );

	memset( &idSegmentacao, 0x0, sizeof(idSegmentacao) );
	memset( &dsSegmentacao, 0x0, sizeof(dsSegmentacao) );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsSegmentacaoDispScript CURSOR FOR
		SELECT
		   SEGMENTACAO.IDSEGMENTACAO ,
		   SEGMENTACAO.DSSEGMENTACAO
		FROM
		   APOIO.SEGMENTACAO SEGMENTACAO
		WHERE
           SEGMENTACAO.IDSEGMENTACAO NOT IN
        (
            SELECT   
                ssegmentacao.IDSEGMENTACAO
            FROM 
               retencao.scriptsegmentacao ssegmentacao
            where
               ssegmentacao.IDSCRIPT = :idScript
        )
        ORDER BY TRIM(UPPER(SEGMENTACAO.DSSEGMENTACAO));
		
		// Selecionados
		EXEC SQL DECLARE crsSegmentacaoSelScript CURSOR FOR
		SELECT
		   SEGMENTACAO.IDSEGMENTACAO ,
		   SEGMENTACAO.DSSEGMENTACAO
		FROM
		   APOIO.SEGMENTACAO SEGMENTACAO
		WHERE
           SEGMENTACAO.IDSEGMENTACAO IN
        (
            SELECT   
                ssegmentacao.IDSEGMENTACAO
            FROM 
               retencao.scriptsegmentacao ssegmentacao
            where
               ssegmentacao.IDSCRIPT = :idScript
        )
        ORDER BY TRIM(UPPER(SEGMENTACAO.DSSEGMENTACAO));
        
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","SEGMENTACAO" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsSegmentacaoDispScript;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsSegmentacaoDispScript INTO :idSegmentacao:i_idSegmentacao, 
					                             	     :dsSegmentacao:i_dsSegmentacao;
				endOraStr( idSegmentacao );
				endOraStr( dsSegmentacao );
				xml->createTag("It");
					xml->addItem( "id",(char*)idSegmentacao.arr );
					xml->addItem( "ds",(char*)dsSegmentacao.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsSegmentacaoDispScript;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsSegmentacaoSelScript;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsSegmentacaoSelScript INTO :idSegmentacao:i_idSegmentacao, 
					                             	    :dsSegmentacao:i_dsSegmentacao;
				endOraStr( idSegmentacao );
				endOraStr( dsSegmentacao );
				xml->createTag("It");
					xml->addItem( "id",(char*)idSegmentacao.arr );
					xml->addItem( "ds",(char*)dsSegmentacao.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsSegmentacaoSelScript;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_SegmentacaoScript()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_SegmentacaoScript()" );
		throw;
	}

}



void get_listaIntencao( XMLGen *xml )
{
	ULOG_START( "get_listaIntencao()" );

	EXEC SQL BEGIN DECLARE SECTION;
		int     idResposta; 
		VARCHAR dsResposta[2001]; 
		short i_dsResposta = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &dsResposta, 0x0, sizeof(dsResposta) );

	try
	{
		EXEC SQL DECLARE crsIntencao CURSOR FOR
		SELECT
		   RESPOSTA.IDRESPOSTA ,
		   RESPOSTA.DSRESPOSTA
		FROM
		   QUESTIONARIO.RESPOSTA RESPOSTA
		WHERE
		   RESPOSTA.INDISPONIBILIDADE = 1
		AND
		   RESPOSTA.IDPERGUNTA = 1
		AND
		   RESPOSTA.IDRESPOSTA > 0
		ORDER BY
		   TRIM(UPPER(RESPOSTA.DSRESPOSTA));
	
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","INTENCAO" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsIntencao;
	
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsIntencao INTO :idResposta, 
					                            :dsResposta:i_dsResposta;
					endOraStr( dsResposta );
					xml->createTag("It");
						xml->addItem( "id",idResposta );
						xml->addItem( "ds",(char*)dsResposta.arr );
					xml->closeTag();
			}                      
			EXEC SQL CLOSE crsIntencao;

			xml->closeTag();
		xml->closeTag();
		ULOG_END( "get_listaIntencao()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: get_listaIntencao()" );
		throw;
	}
	
}



void get_listaDestino( XMLGen *xml )
{
	ULOG_START( "get_listaDestino()" );

	EXEC SQL BEGIN DECLARE SECTION;
		int     idResposta; 
		VARCHAR dsResposta[2001]; 
		short i_dsResposta = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &dsResposta, 0x0, sizeof(dsResposta) );

	try
	{
		EXEC SQL DECLARE crsDestino CURSOR FOR
		SELECT
		   RESPOSTA.IDRESPOSTA ,
		   RESPOSTA.DSRESPOSTA
		FROM
		   QUESTIONARIO.RESPOSTA RESPOSTA
		WHERE
		   RESPOSTA.INDISPONIBILIDADE = 1
		AND
		   RESPOSTA.IDPERGUNTA = 2
		AND
		   RESPOSTA.IDRESPOSTA > 0
		ORDER BY
		   TRIM(UPPER(RESPOSTA.DSRESPOSTA));
	
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","DESTINO" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsDestino;
	
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsDestino INTO :idResposta, 
					                           :dsResposta:i_dsResposta;
					endOraStr( dsResposta );
					xml->createTag("It");
						xml->addItem( "id",idResposta );
						xml->addItem( "ds",(char*)dsResposta.arr );
					xml->closeTag();
			}                      
			EXEC SQL CLOSE crsDestino;

			xml->closeTag();
		xml->closeTag();
		ULOG_END( "get_listaDestino()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: get_listaDestino()" );
		throw;
	}
	
}



void sel_RegionaisIntencao( int idIntencaoPrm, XMLGen *xml )
{
	ULOG_START( "sel_RegionaisIntencao()" );

	EXEC SQL BEGIN DECLARE SECTION;
		int     idIntencao = idIntencaoPrm;
		int     idUF; 
		VARCHAR dsUF[256]; 
		short i_dsUF = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &dsUF, 0x0, sizeof(dsUF) );
	ULOG( "idIntencao [%d]",idIntencao );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsRegionaisDispIntencao CURSOR FOR
		SELECT UFOPERADORA.IDUFOPERADORA, 
		       UF.NMUF 
		  FROM APOIO.UF UF, 
		       CUSTOMER.UFOPERADORA UFOPERADORA 
		 WHERE UFOPERADORA.IDUF = UF.IDUF 
		   AND UF.IDUF > 0 
		   AND UFOPERADORA.IDUFOPERADORA NOT IN (SELECT /*+ INDEX(RESPOSTAUNIDADE) */ RESPOSTAUNIDADE.IDUFOPERADORA 
		                                           FROM RETENCAO.RESPOSTAUNIDADE RESPOSTAUNIDADE 
		                                          WHERE RESPOSTAUNIDADE.INATIVO > 0 
		                                            AND RESPOSTAUNIDADE.IDRESPOSTA1 = :idIntencao) 
		 ORDER BY TRIM(UPPER(UF.NMUF));
        
		// Selecionados
		EXEC SQL DECLARE crsRegionaisSelIntencao CURSOR FOR
		SELECT UFOPERADORA.IDUFOPERADORA, 
		       UF.NMUF 
		  FROM APOIO.UF UF, 
		       CUSTOMER.UFOPERADORA UFOPERADORA 
		 WHERE UFOPERADORA.IDUF = UF.IDUF 
		   AND UF.IDUF > 0 
		   AND UFOPERADORA.IDUFOPERADORA IN (SELECT /*+ INDEX(RESPOSTAUNIDADE) */ RESPOSTAUNIDADE.IDUFOPERADORA 
		                                           FROM RETENCAO.RESPOSTAUNIDADE RESPOSTAUNIDADE 
		                                          WHERE RESPOSTAUNIDADE.INATIVO > 0 
		                                            AND RESPOSTAUNIDADE.IDRESPOSTA1 = :idIntencao) 
		 ORDER BY TRIM(UPPER(UF.NMUF));
        
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","REGIONAL" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsRegionaisDispIntencao;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsRegionaisDispIntencao INTO :idUF, 
					                                      :dsUF:i_dsUF;
				endOraStr( dsUF );
				xml->createTag("It");
					xml->addItem( "id",idUF );
					xml->addItem( "ds",(char*)dsUF.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsRegionaisDispIntencao;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsRegionaisSelIntencao;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsRegionaisSelIntencao INTO :idUF, 
					                             :dsUF:i_dsUF;
				endOraStr( dsUF );
				xml->createTag("It");
					xml->addItem( "id",idUF );
					xml->addItem( "ds",(char*)dsUF.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsRegionaisSelIntencao;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_RegionaisIntencao()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_RegionaisIntencao()" );
		throw;
	}

}



void sel_TipoClienteIntencao( int idIntencaoPrm, XMLGen *xml )
{
	ULOG_START( "sel_TipoClienteIntencao()" );

	EXEC SQL BEGIN DECLARE SECTION;
		int     idIntencao = idIntencaoPrm;
		int     idTipoCliente; 
		VARCHAR dsTipoCliente[256]; 
		short i_dsTipoCliente = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &dsTipoCliente, 0x0, sizeof(dsTipoCliente) );
	ULOG( "idIntencao [%d]",idIntencao );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsTipoClienteDispIntencao CURSOR FOR
		SELECT
		   TIPOPESSOA.IDTIPOPESSOA ,
		   TIPOPESSOA.DSTIPOPESSOA
		FROM
		   APOIO.TIPOPESSOA TIPOPESSOA
		WHERE
		   TIPOPESSOA.IDTIPOPESSOA NOT IN
		(
		    SELECT
		       RESPOSTAUNIDADE.IDTIPOPESSOA 
		    FROM
		       RETENCAO.RESPOSTAUNIDADE RESPOSTAUNIDADE
		    WHERE
		       RESPOSTAUNIDADE.INATIVO > 0
		    AND
		       RESPOSTAUNIDADE.IDRESPOSTA1 = :idIntencao
		)
		ORDER BY
		   TRIM(UPPER(TIPOPESSOA.DSTIPOPESSOA));        

		// Selecionados
		EXEC SQL DECLARE crsTipoClienteSelIntencao CURSOR FOR
		SELECT
		   TIPOPESSOA.IDTIPOPESSOA ,
		   TIPOPESSOA.DSTIPOPESSOA
		FROM
		   APOIO.TIPOPESSOA TIPOPESSOA
		WHERE
		   TIPOPESSOA.IDTIPOPESSOA IN
		(
		    SELECT
		       RESPOSTAUNIDADE.IDTIPOPESSOA 
		    FROM
		       RETENCAO.RESPOSTAUNIDADE RESPOSTAUNIDADE
		    WHERE
		       RESPOSTAUNIDADE.INATIVO > 0
		    AND
		       RESPOSTAUNIDADE.IDRESPOSTA1 = :idIntencao
		)
		ORDER BY
		   TRIM(UPPER(TIPOPESSOA.DSTIPOPESSOA));        
        
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","TPCLIENTE" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsTipoClienteDispIntencao;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTipoClienteDispIntencao INTO :idTipoCliente, 
					                                      :dsTipoCliente:i_dsTipoCliente;
				endOraStr( dsTipoCliente );
				xml->createTag("It");
					xml->addItem( "id",idTipoCliente );
					xml->addItem( "ds",(char*)dsTipoCliente.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTipoClienteDispIntencao;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsTipoClienteSelIntencao;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTipoClienteSelIntencao INTO :idTipoCliente, 
					                             :dsTipoCliente:i_dsTipoCliente;
				endOraStr( dsTipoCliente );
				xml->createTag("It");
					xml->addItem( "id",idTipoCliente );
					xml->addItem( "ds",(char*)dsTipoCliente.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTipoClienteSelIntencao;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_TipoClienteIntencao()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_TipoClienteIntencao()" );
		throw;
	}

}



void sel_TipoLinhaIntencao( int idIntencaoPrm, XMLGen *xml )
{
	ULOG_START( "sel_TipoLinhaIntencao()" );

	EXEC SQL BEGIN DECLARE SECTION;
		int     idIntencao = idIntencaoPrm;
		int     idTipoLinha; 
		VARCHAR dsTipoLinha[256]; 
		short i_dsTipoLinha = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &dsTipoLinha, 0x0, sizeof(dsTipoLinha) );
	ULOG( "idIntencao [%d]",idIntencao );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsTipoLinhaDispIntencao CURSOR FOR
		SELECT
		   TIPOLINHA.IDTIPOLINHA ,
		   TIPOLINHA.DSTIPOLINHA
		FROM
		   APOIO.TIPOLINHA TIPOLINHA
		WHERE
		   TIPOLINHA.IDTIPOLINHA > 0
		AND
		   TRIM(UPPER(TIPOLINHA.DSTIPOLINHA)) <> 'NO CLASSIFICADO'
		AND
		   TIPOLINHA.IDTIPOLINHA NOT IN
		(
		    SELECT
		       NVL(RESPOSTAUNIDADE.IDTIPOLINHA,0) 
		    FROM
		       RETENCAO.RESPOSTAUNIDADE RESPOSTAUNIDADE
		    WHERE
		       RESPOSTAUNIDADE.INATIVO > 0
		    AND
		       RESPOSTAUNIDADE.IDRESPOSTA1 = :idIntencao
		)
		ORDER BY
		   TRIM(UPPER(TIPOLINHA.DSTIPOLINHA));
   
		// Selecionados
		EXEC SQL DECLARE crsTipoLinhaSelIntencao CURSOR FOR
		SELECT
		   TIPOLINHA.IDTIPOLINHA ,
		   TIPOLINHA.DSTIPOLINHA
		FROM
		   APOIO.TIPOLINHA TIPOLINHA
		WHERE
		   TIPOLINHA.IDTIPOLINHA > 0
		AND
		   TRIM(UPPER(TIPOLINHA.DSTIPOLINHA)) <> 'NO CLASSIFICADO'
		AND
		   TIPOLINHA.IDTIPOLINHA IN
		(
		    SELECT
		       RESPOSTAUNIDADE.IDTIPOLINHA 
		    FROM
		       RETENCAO.RESPOSTAUNIDADE RESPOSTAUNIDADE
		    WHERE
		       RESPOSTAUNIDADE.INATIVO > 0
		    AND
		       RESPOSTAUNIDADE.IDRESPOSTA1 = :idIntencao
		)
		ORDER BY
		   TRIM(UPPER(TIPOLINHA.DSTIPOLINHA));
           
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","TPLINHA" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsTipoLinhaDispIntencao;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTipoLinhaDispIntencao INTO :idTipoLinha, 
					                                      :dsTipoLinha:i_dsTipoLinha;
				endOraStr( dsTipoLinha );
				xml->createTag("It");
					xml->addItem( "id",idTipoLinha );
					xml->addItem( "ds",(char*)dsTipoLinha.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTipoLinhaDispIntencao;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsTipoLinhaSelIntencao;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsTipoLinhaSelIntencao INTO :idTipoLinha, 
					                             :dsTipoLinha:i_dsTipoLinha;
				endOraStr( dsTipoLinha );
				xml->createTag("It");
					xml->addItem( "id",idTipoLinha );
					xml->addItem( "ds",(char*)dsTipoLinha.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsTipoLinhaSelIntencao;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_TipoLinhaIntencao()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_TipoLinhaIntencao()" );
		throw;
	}

}



void sel_DestinoIntencao( int idIntencaoPrm, XMLGen *xml )
{
	ULOG_START( "sel_DestinoIntencao()" );

	EXEC SQL BEGIN DECLARE SECTION;
		int     idIntencao = idIntencaoPrm;
		int     idDestino; 
		VARCHAR dsDestino[256]; 
		short i_dsDestino = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &dsDestino, 0x0, sizeof(dsDestino) );
	ULOG( "idIntencao [%d]",idIntencao );

	try
	{
		// Disponiveis
		EXEC SQL DECLARE crsDestinoDispIntencao CURSOR FOR
		SELECT /*+ INDEX_DESC(RESPOSTA RESPOSTAPK) */ RESPOSTA.IDRESPOSTA, 
		       RESPOSTA.DSRESPOSTA 
		  FROM QUESTIONARIO.RESPOSTA RESPOSTA 
		 WHERE RESPOSTA.INDISPONIBILIDADE > 0 
		   AND RESPOSTA.IDRESPOSTA > 0 
		   AND RESPOSTA.IDPERGUNTA = 2 
		   AND NOT EXISTS (SELECT 'X' 
		                     FROM RETENCAO.RESPOSTAUNIDADE RESPOSTAUNIDADE 
		                    WHERE RESPOSTAUNIDADE.INATIVO > 0 
		                      AND RESPOSTAUNIDADE.IDRESPOSTA1 = :idIntencao 
		                      AND RESPOSTAUNIDADE.IDRESPOSTA2 = RESPOSTA.IDRESPOSTA) 
		 ORDER BY TRIM(UPPER(RESPOSTA.DSRESPOSTA));   
		
		
		// Selecionados
		EXEC SQL DECLARE crsDestinoSelIntencao CURSOR FOR
		SELECT RESPOSTA.IDRESPOSTA, 
		       RESPOSTA.DSRESPOSTA 
		  FROM QUESTIONARIO.RESPOSTA RESPOSTA 
		 WHERE RESPOSTA.INDISPONIBILIDADE > 0 
		   AND RESPOSTA.IDRESPOSTA > 0 
		   AND RESPOSTA.IDPERGUNTA = 2 
		   AND RESPOSTA.IDRESPOSTA IN (SELECT /*+ INDEX(RESPOSTAUNIDADE) */ RESPOSTAUNIDADE.IDRESPOSTA2 
		                                 FROM RETENCAO.RESPOSTAUNIDADE RESPOSTAUNIDADE 
		                                WHERE RESPOSTAUNIDADE.INATIVO > 0 
		                                  AND RESPOSTAUNIDADE.IDRESPOSTA1 = :idIntencao) 
		 ORDER BY TRIM(UPPER(RESPOSTA.DSRESPOSTA));
           
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","DESTINO" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsDestinoDispIntencao;

			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsDestinoDispIntencao INTO :idDestino, 
					                                      :dsDestino:i_dsDestino;
				endOraStr( dsDestino );
				xml->createTag("It");
					xml->addItem( "id",idDestino );
					xml->addItem( "ds",(char*)dsDestino.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsDestinoDispIntencao;
			xml->closeTag();

			xml->createTag( "Selecionado" );
			EXEC SQL OPEN crsDestinoSelIntencao;
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsDestinoSelIntencao INTO :idDestino, 
					                             :dsDestino:i_dsDestino;
				endOraStr( dsDestino );
				xml->createTag("It");
					xml->addItem( "id",idDestino );
					xml->addItem( "ds",(char*)dsDestino.arr );
				xml->closeTag();

			}                      
			EXEC SQL CLOSE crsDestinoSelIntencao;
			xml->closeTag();

		xml->closeTag();

		ULOG_END( "sel_DestinoIntencao()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_DestinoIntencao()" );
		throw;
	}

}



void ConsultaIntencao( int idIntencaoPrm, XMLGen *xml )
{
	ULOG_START( "ConsultaIntencao()" );
    
	EXEC SQL BEGIN DECLARE SECTION;
		int     idIntencao = idIntencaoPrm;
	EXEC SQL END DECLARE SECTION;


	ULOG( "idIntencao [%d]",idIntencao );

	try
	{
		xml->createTag("ListasVO");
			sel_RegionaisIntencao( idIntencao, xml );
			sel_TipoClienteIntencao( idIntencao, xml );
			sel_TipoLinhaIntencao( idIntencao, xml );
			sel_DestinoIntencao( idIntencao, xml );
			get_listaIntencao( xml );
		xml->closeTag();
		
		ULOG_END( "ConsultaIntencao()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: ConsultaIntencao()" );
		throw;
	}

}



void get_listaGrupo( XMLGen *xml )
{
	ULOG_START( "get_listaGrupo()" );

	EXEC SQL BEGIN DECLARE SECTION;
		int     idGrupo; 
		VARCHAR dsGrupo[256]; 
		short i_dsGrupo = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &dsGrupo, 0x0, sizeof(dsGrupo) );

	try
	{
		EXEC SQL DECLARE crsGrupo CURSOR FOR
		SELECT
		   GRUPO.IDGRUPO ,
		   GRUPO.NMGRUPO
		FROM
		   ACESSO.GRUPO GRUPO
		WHERE
		   GRUPO.IDGRUPO IN
		(
		   SELECT
		      GRUPOMOTIVOORDEM.IDGRUPO
		   FROM
		      RETENCAO.GRUPOMOTIVOORDEM GRUPOMOTIVOORDEM
		)
		ORDER BY
		   TRIM(UPPER(GRUPO.NMGRUPO));
   	
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","GRUPOS" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsGrupo;
	
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsGrupo INTO :idGrupo, 
					                           :dsGrupo:i_dsGrupo;
					endOraStr( dsGrupo );
					xml->createTag("It");
						xml->addItem( "id",idGrupo );
						xml->addItem( "ds",(char*)dsGrupo.arr );
					xml->closeTag();
			}                      
			EXEC SQL CLOSE crsGrupo;

			xml->closeTag();
		xml->closeTag();
		ULOG_END( "get_listaGrupo()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: get_listaGrupo()" );
		throw;
	}
	
}



void sel_Aparelhos( LISTA_ID * pRegional, 
                    LISTA_ID * pCliente, 
                    LISTA_ID * pGrupo, 
                    LISTA_ID * pSegmento, 
                    XMLGen *xml )
{
	ULOG_START( "sel_Aparelhos()" );

    string consulta;
    int j;
    char buffer[256];

	EXEC SQL BEGIN DECLARE SECTION;
       char * query;
       int     idAparelho;
       int     idUFOperadora;
       int     idRegional;
	   VARCHAR nmAparelho[256];
	   short i_nmAparelho = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &nmAparelho, 0x0, sizeof(nmAparelho) );
	
	try
	{
		
		xml->createTag( "Lista" );
		xml->addItem( "nmSelect","APARELHOS" );

		consulta =
		"SELECT   idaparelho, dsmodelo  || ' - ' || tipoaparelho.dstipoaparelho "
		"    FROM retencao.aparelho ap, "
        "         apoio.tipoaparelho tipoaparelho "
		"   WHERE inativo = 1 "
        "     AND tipoaparelho.idtipoaparelho = ap.idtipoaparelho "
		"     AND idaparelho NOT IN ( "
		"            SELECT aparelho.idaparelho "
		"              FROM retencao.aparelho aparelho, "
		"                   retencao.aparelhotipopessoa aptipopessoa, "
		"                   retencao.aparelhoufoperadora apufoperadora, "
		"                   retencao.aparelhosegmentacao apsegmentacao, "
		"                   retencao.aparelhogrupo apgrupo "
		"             WHERE aparelho.inativo = 1 "
		"                      and aptipopessoa.inativo = 1 "
		"                      and apufoperadora.inativo = 1 "
		"                      and apsegmentacao.inativo = 1 "
		"                      and apgrupo.inativo = 1 "
		"               AND aparelho.idaparelho = apgrupo.idaparelho "
		"               AND aptipopessoa.idaparelho = apgrupo.idaparelho "
		"               AND apufoperadora.idaparelho = apgrupo.idaparelho "
		"               AND apsegmentacao.idaparelho = apgrupo.idaparelho ";
		
		int var = 0;
		if ( pRegional->size() > 1 ) var = 1;
		if ( pCliente->size()  > 1 ) var = 1;
		if ( pGrupo->size() > 1 ) var = 1;
		if ( pSegmento->size() > 1 ) var = 1;
		// Regionais
		if ( pRegional->size() == 1 && var == 0 )
		{
			consulta +=
			"AND "
			"   apufoperadora.IDUFOPERADORA IN ( ";
			j=0;  
			for ( itRegional = pRegional->begin(); itRegional != pRegional->end(); itRegional++ )
			{

				if ( j > 0 ) consulta += ",";
				
				sprintf( buffer, "%d", *itRegional );
				consulta += buffer;
				j++;
			}
	        consulta += " ) ";
   		}
		
		// Tipo de Cliente
		if ( pCliente->size() == 1 && var == 0 )
		{
			consulta +=
			"AND "
			"   aptipopessoa.IDTIPOPESSOA IN ( ";
			j=0;  
			for ( itCliente = pCliente->begin(); itCliente != pCliente->end(); itCliente++ )
			{
				if ( j > 0 ) consulta += ",";
				
				sprintf( buffer, "%d", *itCliente );
				consulta += buffer;
				j++;
			}
	        consulta += " ) ";
   		}
		
		// Grupos
		if ( pGrupo->size() == 1 && var == 0 )
		{
			consulta +=
			"AND "
			"   apgrupo.IDGRUPO IN ( ";
			j=0;  
			for ( itGrupo = pGrupo->begin(); itGrupo != pGrupo->end(); itGrupo++ )
			{
				if ( j > 0 ) consulta += ",";
				
				sprintf( buffer, "%d", *itGrupo );
				consulta += buffer;
				j++;
			}
	        consulta += " ) ";
   		}
		
		
		// Segmento
		if ( pSegmento->size() == 1 && var == 0 )
		{
			consulta +=
			"AND "
			"   apsegmentacao.IDSEGMENTACAO IN ( ";
			j=0;  
			for ( itSegmento = pSegmento->begin(); itSegmento != pSegmento->end(); itSegmento++ )
			{
				if ( j > 0 ) consulta += ",";
				
				sprintf( buffer, "%d", *itSegmento );
				consulta += buffer;
				j++;
			}
	        consulta += " ) ";
   		}
   		
   		consulta += 
   		" ) ORDER BY TRIM(UPPER(DSMODELO))";

		if ( var == 0 )
		{
			query = (char *)consulta.c_str();
			
			ULOG( query );
			
			EXEC SQL PREPARE ConsultaAparelhos FROM :query;
			EXEC SQL DECLARE AparelhosSel CURSOR FOR ConsultaAparelhos;
	
			EXEC SQL WHENEVER NOT FOUND DO break;
			EXEC SQL OPEN AparelhosSel;
	
			xml->createTag( "Disponivel" );
			for( ;; )
			{
			    
			    EXEC SQL FETCH AparelhosSel INTO 
			        :idAparelho ,
			        :nmAparelho:i_nmAparelho ;
	
					endOraStr( nmAparelho );
					xml->createTag("It");
						xml->addItem( "id",idAparelho );
						xml->addItem( "ds",(char*)nmAparelho.arr );
					xml->closeTag();
			}
			xml->closeTag();
			
			EXEC SQL CLOSE AparelhosSel;
		}



		int flag;
		
		if ( pRegional->size() == 1 && pCliente->size() == 1 && pGrupo->size() == 1 && pSegmento->size() == 1 )
		{
			flag = 0;
			
			consulta =
		"SELECT   idaparelho, dsmodelo  || ' - ' || tipoaparelho.dstipoaparelho "
		"   FROM retencao.aparelho ap ,"
        "        apoio.tipoaparelho tipoaparelho "
		"   WHERE inativo = 1 "
        "     AND tipoaparelho.idtipoaparelho = ap.idtipoaparelho "
		"   and idaparelho IN ( "
		"            SELECT aparelho.idaparelho "
		"              FROM retencao.aparelho aparelho, "
		"                   retencao.aparelhotipopessoa aptipopessoa, "
		"                   retencao.aparelhoufoperadora apufoperadora, "
		"                   retencao.aparelhosegmentacao apsegmentacao, "
		"                   retencao.aparelhogrupo apgrupo "
		"             WHERE aparelho.inativo = 1 "
		"                      and aptipopessoa.inativo = 1 "
		"                      and apufoperadora.inativo = 1 "
		"                      and apsegmentacao.inativo = 1 "
		"                      and apgrupo.inativo = 1 "
		"               AND aparelho.idaparelho = apgrupo.idaparelho "
		"               AND aptipopessoa.idaparelho = apgrupo.idaparelho "
		"               AND apufoperadora.idaparelho = apgrupo.idaparelho "
		"               AND apsegmentacao.idaparelho = apgrupo.idaparelho ";
		}
		else
		{
			flag = 1;
			
			consulta =
			"SELECT   idaparelho, dsmodelo "
			"    FROM retencao.aparelho "
			"   WHERE inativo = 1 ";
		}
		
						
		var = 0;
		if ( pRegional->size() > 1 ) var = 1;
		if ( pCliente->size()  > 1 ) var = 1;
		if ( pGrupo->size() > 1 ) var = 1;
		if ( pSegmento->size() > 1 ) var = 1;

		// Regionais
		if ( pRegional->size() == 1 )
		{
			if ( var != 1 )
			{

    			consulta +=
    			"AND "
    			"   apufoperadora.IDUFOPERADORA IN ( ";
    			j=0;  
    			for ( itRegional = pRegional->begin(); itRegional != pRegional->end(); itRegional++ )
    			{
    				if ( j > 0 ) consulta += ",";
    				sprintf( buffer, "%d", *itRegional );
    				consulta += buffer;
    				j++;
    			}
    	        consulta += " ) ";
            }
   		}
		
		// Tipo de Cliente
		if ( pCliente->size()  == 1 )
		{
			if ( var != 1 )
			{
				consulta +=
				"AND "
				"   aptipopessoa.IDTIPOPESSOA IN ( ";
				j=0;  
				for ( itCliente = pCliente->begin(); itCliente != pCliente->end(); itCliente++ )
				{
					if ( j > 0 ) consulta += ",";
					
					sprintf( buffer, "%d", *itCliente );
					consulta += buffer;
					j++;
				}
		        consulta += " ) ";
	    	}
   		}
		
	
		// Grupos
		if ( pGrupo->size()  == 1 )
		{
			if ( var != 1 )
			{
				consulta +=
				"AND "
				"   apgrupo.IDGRUPO IN ( ";
				j=0;  
				for ( itGrupo = pGrupo->begin(); itGrupo != pGrupo->end(); itGrupo++ )
				{
					if ( j > 0 ) consulta += ",";
					
					sprintf( buffer, "%d", *itGrupo );
					consulta += buffer;
					j++;
				}
		        consulta += " ) ";
		    }
   		}
		
		
		// Segmento
		if ( pSegmento->size()  == 1 )
		{
			if ( var != 1 )
			{
				consulta +=
				"AND "
				"   apsegmentacao.IDSEGMENTACAO IN ( ";
				j=0;  
				for ( itSegmento = pSegmento->begin(); itSegmento != pSegmento->end(); itSegmento++ )
				{
					if ( j > 0 ) consulta += ",";
					
					sprintf( buffer, "%d", *itSegmento );
					consulta += buffer;
					j++;
				}
		        consulta += " ) ) ";
		    }
   		}
   		
   		consulta += 
   		" ORDER BY TRIM(UPPER(dsmodelo))";

		query = (char *)consulta.c_str();

		ULOG( query );

		EXEC SQL PREPARE ConsultaAparelhos FROM :query;
		EXEC SQL DECLARE AparelhosDisp CURSOR FOR ConsultaAparelhos;

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL OPEN AparelhosDisp;

		if ( flag == 1)
			xml->createTag( "Disponivel" );
	    else
			xml->createTag( "Selecionado" );
	    	
		for( ;; )
		{
		    
		    EXEC SQL FETCH AparelhosDisp INTO 
		        :idAparelho ,
		        :nmAparelho:i_nmAparelho ;

				endOraStr( nmAparelho );
				xml->createTag("It");
					xml->addItem( "id",idAparelho );
					xml->addItem( "ds",(char*)nmAparelho.arr );
				xml->closeTag();
		}
		xml->closeTag();
		
		EXEC SQL CLOSE AparelhosDisp;


		xml->closeTag();

		ULOG_END( "sel_Aparelhos()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_Aparelhos()" );
		throw;
	}

}



void get_ListaIntencaoOfertas( LISTA_ID * pRegional, 
                               LISTA_ID * pCliente, 
                               LISTA_ID * pTpLinha, 
                               LISTA_ID * pGrupo, 
                               LISTA_ID * pSegmento, 
                               XMLGen   * xml )
{
	ULOG_START( "get_ListaIntencao()" );

    string consulta;
    int j;
    char buffer[256];

	EXEC SQL BEGIN DECLARE SECTION;
       char * query;
       int     idResposta;
       int     idRegional;
       int     idUFOperadora;
	   VARCHAR nmResposta[256];
	   short i_nmResposta = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &nmResposta, 0x0, sizeof(nmResposta) );
	
	try
	{
		
		xml->createTag( "Lista" );
		xml->addItem( "nmSelect","INTENCAO" );

		consulta =
		"SELECT DISTINCT"
		"   RESPOSTAUNIDADE.IDRESPOSTA1 , "
		"   RESPOSTA.DSRESPOSTA "
		"FROM "
		"   RETENCAO.RESPOSTAUNIDADE RESPOSTAUNIDADE , "
		"   QUESTIONARIO.RESPOSTA RESPOSTA "
		"WHERE "
		"   RESPOSTA.IDRESPOSTA = RESPOSTAUNIDADE.IDRESPOSTA1 "
		"AND "
		"   RESPOSTA.INDISPONIBILIDADE = 1 "
		"AND "
		"   RESPOSTAUNIDADE.INATIVO = 1 ";
		
		
		int var = 0;
		if ( pRegional->size() > 1 ) var = 1;
		if ( pCliente->size()  > 1 ) var = 1;
		if ( pTpLinha->size() > 1 ) var = 1;
		if ( pGrupo->size() > 1 ) var = 1;
		if ( pSegmento->size() > 1 ) var = 1;

		// Regionais
		if ( pRegional->size() == 1 )
		{
			consulta +=
			"AND "
			"   RESPOSTAUNIDADE.IDUFOPERADORA IN ( ";
			j=0;  
			for ( itRegional = pRegional->begin(); itRegional != pRegional->end(); itRegional++ )
			{
				//idRegional = *itRegional;
				
				if ( j > 0 ) consulta += ",";
				
				sprintf( buffer, "%d", *itRegional );
				consulta += buffer;
				j++;
			}
	        consulta += " ) ";
   		}
		
		// Tipo de Cliente
		if ( pCliente->size() == 1 && var == 0)
		{
			consulta +=
			"AND "
			"   RESPOSTAUNIDADE.IDTIPOPESSOA IN ( ";
			j=0;  
			for ( itCliente = pCliente->begin(); itCliente != pCliente->end(); itCliente++ )
			{
				if ( j > 0 ) consulta += ",";
				
				sprintf( buffer, "%d", *itCliente );
				consulta += buffer;
				j++;
			}
	        consulta += " ) ";
   		}
		
		// Tipo de Linha
		if ( pTpLinha->size() == 1 && var == 0 )
		{
			consulta +=
			"AND "
			"   RESPOSTAUNIDADE.IDTIPOLINHA IN ( ";
			j=0;  
			for ( itTpLinha = pTpLinha->begin(); itTpLinha != pTpLinha->end(); itTpLinha++ )
			{
				if ( j > 0 ) consulta += ",";
				
				sprintf( buffer, "%d", *itTpLinha );
				consulta += buffer;
				j++;
			}
	        consulta += " ) ";
   		}
		
   		
   		consulta += 
   		" ORDER BY UPPER(TRIM(RESPOSTA.DSRESPOSTA))";

		query = (char *)consulta.c_str();
		
		ULOG( query );
		
		EXEC SQL PREPARE ConsultaIntencaoCancel FROM :query;
		EXEC SQL DECLARE IntencaoCancel CURSOR FOR ConsultaIntencaoCancel;

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL OPEN IntencaoCancel;

		xml->createTag( "Disponivel" );
		for( ;; )
		{
		    
		    EXEC SQL FETCH IntencaoCancel INTO 
		        :idResposta ,
		        :nmResposta:i_nmResposta ;

				endOraStr( nmResposta );
				xml->createTag("It");
					xml->addItem( "id",idResposta );
					xml->addItem( "ds",(char*)nmResposta.arr );
				xml->closeTag();
		}
		xml->closeTag();
		
		EXEC SQL CLOSE IntencaoCancel;

		xml->closeTag();


		ULOG_END( "get_ListaIntencao()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: get_ListaIntencao()" );
		throw;
	}

}



void sel_Destinos( int idIntencao,
                   LISTA_ID * pRegional, 
                   LISTA_ID * pCliente, 
                   LISTA_ID * pTpLinha, 
                   LISTA_ID * pGrupo, 
                   LISTA_ID * pSegmento, 
                   XMLGen   * xml )
{
	ULOG_START( "sel_Destinos()" );

    string consulta;
    int j;
    char buffer[256];

	EXEC SQL BEGIN DECLARE SECTION;
       char * query;
       int     idResposta;
       int     idRegional;
       int     idUFOperadora;
	   VARCHAR nmResposta[256];
	   short i_nmResposta = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &nmResposta, 0x0, sizeof(nmResposta) );
	
	try
	{
		
		xml->createTag( "Lista" );
		xml->addItem( "nmSelect","DESTINOS" );

		consulta =
		"SELECT DISTINCT "
		"   RESPOSTAUNIDADE.IDRESPOSTA2 , "
		"   RESPOSTA.DSRESPOSTA "
		"FROM "
		"   RETENCAO.RESPOSTAUNIDADE RESPOSTAUNIDADE , "
		"   QUESTIONARIO.RESPOSTA RESPOSTA "
		"WHERE "
		"   RESPOSTAUNIDADE.IDRESPOSTA1 = ";

		sprintf( buffer, "%d", idIntencao );
		consulta += buffer;

		consulta +=
		" AND "
		"   RESPOSTA.IDRESPOSTA = RESPOSTAUNIDADE.IDRESPOSTA2 "
		"AND "
		"   RESPOSTA.INDISPONIBILIDADE = 1 "
		"AND "
		"   RESPOSTAUNIDADE.INATIVO = 1 ";

		if ( pRegional->size() > 0 )
		{
			consulta +=
			"AND "
			"   RESPOSTAUNIDADE.IDUFOPERADORA IN ( ";
			j=0;  
			for ( itRegional = pRegional->begin(); itRegional != pRegional->end(); itRegional++ )
			{

				if ( j > 0 ) consulta += ",";
				
				sprintf( buffer, "%d", *itRegional );
				consulta += buffer;
				j++;
			}
	        consulta += " ) ";
   		}
		
		// Tipo de Cliente
		if ( pCliente->size() > 0 )
		{
			consulta +=
			"AND "
			"   RESPOSTAUNIDADE.IDTIPOPESSOA IN ( ";
			j=0;  
			for ( itCliente = pCliente->begin(); itCliente != pCliente->end(); itCliente++ )
			{
				if ( j > 0 ) consulta += ",";
				
				sprintf( buffer, "%d", *itCliente );
				consulta += buffer;
				j++;
			}
	        consulta += " ) ";
   		}
		
		// Tipo de Linha
		if ( pTpLinha->size() > 0 )
		{
			consulta +=
			"AND "
			"   NVL(RESPOSTAUNIDADE.IDTIPOLINHA,0) IN ( ";
			j=0;  
			for ( itTpLinha = pTpLinha->begin(); itTpLinha != pTpLinha->end(); itTpLinha++ )
			{
				if ( j > 0 ) consulta += ",";
				
				sprintf( buffer, "%d", *itTpLinha );
				consulta += buffer;
				j++;
			}
	        consulta += " ) ";
   		}
   		consulta += " ORDER BY UPPER(TRIM(RESPOSTA.DSRESPOSTA))";

   		query = (char *)consulta.c_str();
		
		ULOG( query );
		
		EXEC SQL PREPARE ConsultaDestinosDisp FROM :query;
		EXEC SQL DECLARE DestinosDisp CURSOR FOR ConsultaDestinosDisp;

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL OPEN DestinosDisp;

		xml->createTag( "Disponivel" );
		for( ;; )
		{
		    
		    EXEC SQL FETCH DestinosDisp INTO 
		        :idResposta ,
		        :nmResposta:i_nmResposta ;

				endOraStr( nmResposta );
				xml->createTag("It");
					xml->addItem( "id",idResposta );
					xml->addItem( "ds",(char*)nmResposta.arr );
				xml->closeTag();
		}
		xml->closeTag();
		EXEC SQL CLOSE DestinosDisp;

		ULOG_END( "sel_Destinos()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_Destinos()" );
		throw;
	}

}



void sel_Ofertas( int idIntencao,
                  LISTA_ID * pGrupo, 
                  LISTA_ID * pSegmento, 
                  LISTA_ID * pDestino, 
                  XMLGen   * xml )
{
	ULOG_START( "sel_Ofertas()" );

    string consulta;
    int j;
    char buffer[256];

	EXEC SQL BEGIN DECLARE SECTION;
       char * query;
       VARCHAR idUnidadeOferta[32];
       int     idRegional;
       int     idUFOperadora;
	   VARCHAR nmOferta[256];
	   short i_nmOferta = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &idUnidadeOferta, 0x0, sizeof(idUnidadeOferta) );
	memset( &nmOferta, 0x0, sizeof(nmOferta) );
	
	try
	{
    	EXEC SQL WHENEVER NOT FOUND DO break;

		xml->createTag( "Lista" );
		xml->addItem( "nmSelect","OFERTAS" );

		consulta =
        " SELECT "
        "   oferta.idunidadeoferta, oferta.nmoferta "
        " FROM "
        "   retencao.oferta "
        " WHERE "
        "   1 = oferta.inativo "
        " AND "
        "   oferta.idunidadeoferta "
        " NOT IN ( "
        "   SELECT DISTINCT "
        "      ru.idoferta "
        "   FROM "
        "      RETENCAO.ofertarespostaunidade ru, "
        "      RETENCAO.ofertagrupo ofertagrupo, "
        "      RETENCAO.ofertasegmentacao ofertasegmentacao "
        "   WHERE "
        "      1 = ru.inativo ";

		// Destino
		if ( pDestino->size() > 0 )
		{
			consulta +=
            "   AND ru.idrespostaunidade IN ( ";
			j=0;  
			for ( itDestino = pDestino->begin(); itDestino != pDestino->end(); itDestino++ )
			{
				if ( j > 0 ) consulta += ",";
				
				sprintf( buffer, "%d", *itDestino );
				consulta += buffer;
				j++;
			}
	        consulta += " ) ";
   		}
   		
		   
		// Grupos
		if ( pGrupo->size() > 0 )
		{
			consulta +=
			" AND "
			"   ofertagrupo.IDGRUPO IN ( ";
			j=0;  
			for ( itGrupo = pGrupo->begin(); itGrupo != pGrupo->end(); itGrupo++ )
			{
				if ( j > 0 ) consulta += ",";
				
				sprintf( buffer, "%d", *itGrupo );
				consulta += buffer;
				j++;
			}
	        consulta += " ) ";
   		}
        
   		consulta +=
        " AND ofertagrupo.idoferta = ru.idoferta "
        " AND 1 = ofertagrupo.inativo "
        " AND ofertasegmentacao.idoferta = ru.idoferta "
        " AND 1 = ofertasegmentacao.inativo ";
		
		// Segmento
		if ( pSegmento->size() > 0 )
		{
			consulta +=
			" AND "
			"   ofertasegmentacao.IDSEGMENTACAO IN ( ";
			j=0;  
			for ( itSegmento = pSegmento->begin(); itSegmento != pSegmento->end(); itSegmento++ )
			{
				if ( j > 0 ) consulta += ",";
				
				sprintf( buffer, "%d", *itSegmento );
				consulta += buffer;
				j++;
			}
	        consulta += " )) and oferta.inativo = 1 ";
   		}
		
   		consulta += 
   		" ORDER BY TRIM(UPPER(OFERTA.NMOFERTA))";

		query = (char *)consulta.c_str();
		
		ULOG( query );
		
		EXEC SQL PREPARE ConsultaOfertaDisp FROM :query;
		EXEC SQL DECLARE OfertaDisp CURSOR FOR ConsultaOfertaDisp;

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL OPEN OfertaDisp;

		xml->createTag( "Disponivel" );
		for( ;; )
		{
		    
		    EXEC SQL FETCH OfertaDisp INTO 
		        :idUnidadeOferta ,
		        :nmOferta:i_nmOferta ;

				endOraStr( idUnidadeOferta );
				endOraStr( nmOferta );
		        ULOG( "idUnidadeOferta [%s]",(char *)idUnidadeOferta.arr );
		        ULOG( "nmOferta        [%s]",(char *)nmOferta.arr );

		        ULOG( "1.Valor de SQL Code [%d]",sqlca.sqlcode );
		        if (sqlca.sqlcode != 0) break;
				
				xml->createTag("It");
					xml->addItem( "id",(char*)idUnidadeOferta.arr );
					xml->addItem( "ds",(char*)nmOferta.arr );
				xml->closeTag();
		}
		xml->closeTag();
		
		EXEC SQL CLOSE OfertaDisp;

		consulta =
        " SELECT "
        "   oferta.idunidadeoferta, oferta.nmoferta "
        " FROM "
        "   retencao.oferta "
        " WHERE "
        "   1 = oferta.inativo "
        " AND "
        "   oferta.idunidadeoferta "
        " IN ( "
        "   SELECT DISTINCT "
        "      ru.idoferta "
        "   FROM "
        "      RETENCAO.ofertarespostaunidade ru, "
        "      RETENCAO.ofertagrupo ofertagrupo, "
        "      RETENCAO.ofertasegmentacao ofertasegmentacao "
        "   WHERE "
        "      1 = ru.inativo ";
         
		// Destino
		if ( pDestino->size() > 0 )
		{
			consulta +=
            "   AND ru.idrespostaunidade IN ( ";
			j=0;  
			for ( itDestino = pDestino->begin(); itDestino != pDestino->end(); itDestino++ )
			{
				if ( j > 0 ) consulta += ",";
				
				sprintf( buffer, "%d", *itDestino );
				consulta += buffer;
				j++;
			}
	        consulta += " ) ";
   		}
   		
		// Grupos
		if ( pGrupo->size() > 0 )
		{
			consulta +=
			" AND "
			"   ofertagrupo.IDGRUPO IN ( ";
			j=0;  
			for ( itGrupo = pGrupo->begin(); itGrupo != pGrupo->end(); itGrupo++ )
			{
				if ( j > 0 ) consulta += ",";
				
				sprintf( buffer, "%d", *itGrupo );
				consulta += buffer;
				j++;
			}
	        consulta += " ) ";
   		}
		
   		consulta +=
        " AND ofertagrupo.idoferta = ru.idoferta  "
        " AND 1 = ofertagrupo.inativo "
        " AND ofertasegmentacao.idoferta = ru.idoferta  "
        " AND 1 = ofertasegmentacao.inativo ";
        		
		// Segmento
		if ( pSegmento->size() > 0 )
		{
			consulta +=
			" AND "
			"   ofertasegmentacao.IDSEGMENTACAO IN ( ";
			j=0;  
			for ( itSegmento = pSegmento->begin(); itSegmento != pSegmento->end(); itSegmento++ )
			{
				if ( j > 0 ) consulta += ",";
				
				sprintf( buffer, "%d", *itSegmento );
				consulta += buffer;
				j++;
			}
	        consulta += " )) and oferta.inativo = 1 ";
   		}
		
   		consulta += 
   		" ORDER BY TRIM(UPPER(OFERTA.NMOFERTA))";
	
		query = (char *)consulta.c_str();
		
		ULOG( query );
		
		EXEC SQL PREPARE ConsultaOfertaSel FROM :query;
		EXEC SQL DECLARE OfertaSel CURSOR FOR ConsultaOfertaSel;

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL OPEN OfertaSel;

		xml->createTag( "Selecionado" );
		for( ;; )
		{
		    
		    EXEC SQL FETCH OfertaSel INTO 
		        :idUnidadeOferta ,
		        :nmOferta:i_nmOferta ;

		        if (sqlca.sqlcode != 0) break;
				endOraStr( idUnidadeOferta );
				endOraStr( nmOferta );
				xml->createTag("It");
					xml->addItem( "id",(char*)idUnidadeOferta.arr );
					xml->addItem( "ds",(char*)nmOferta.arr );
				xml->closeTag();
		}
		xml->closeTag();
		
		EXEC SQL CLOSE OfertaSel;



		xml->closeTag();

		ULOG_END( "sel_Ofertas()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_Ofertas()" );
		throw;
	}

}



/*
void BuscaUFOperadora(int idRegionalPrm, int * idUFOperadoraPrm )
{
	ULOG_START( "BuscaUFOperadora()" );
		
	EXEC SQL BEGIN DECLARE SECTION;
	    int idRegional = idRegionalPrm;
	    int idUFOperadora;
	EXEC SQL END DECLARE SECTION;

	
	try
	{
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL
		SELECT 
		   UFOPERADORA.IDUFOPERADORA 
		INTO 
		   :idUFOperadora
		FROM 
		   CUSTOMER.UFOPERADORA UFOPERADORA 
		WHERE 
		   UFOPERADORA.IDUF = :idRegional;
	
	    *idUFOperadoraPrm = idUFOperadora;
		
		ULOG_END( "BuscaUFOperadora()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: BuscaUFOperadora()" );
		throw;
	}

}
*/


void BuscaRespostaUnidade( LISTA_ID * pRegional, LISTA_ID * pRespostaUnidade, int idRespostaIntencao, LISTA_ID * pDestino, LISTA_ID * pTpLinha, LISTA_ID * pCliente )
{
	ULOG_START( "BuscaRespostaUnidade()" );

    string consulta;
    int j;
    char buffer[256];


	EXEC SQL BEGIN DECLARE SECTION;
	    char * query;
		int nrLinhas = 1;
		int idRespostaUnidade;
   	EXEC SQL END DECLARE SECTION;

	try
	{

		EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);
		EXEC SQL WHENEVER NOT FOUND CONTINUE;

		consulta =
		"SELECT "
		   "RESPOSTAUNIDADE.IDRESPOSTAUNIDADE "
		"FROM "
		   "RETENCAO.RESPOSTAUNIDADE RESPOSTAUNIDADE "
		"WHERE "
		   "RESPOSTAUNIDADE.INATIVO = 1 "
		"AND "
		   "RESPOSTAUNIDADE.IDTIPOLINHA IN (";
		j=0;  
		for ( itTpLinha = pTpLinha->begin(); itTpLinha != pTpLinha->end(); itTpLinha++ )
		{
			if ( j > 0 ) consulta += ",";
			
			sprintf( buffer, "%d", *itTpLinha );
			consulta += buffer;
			j++;
		}
        consulta += ") ";

		consulta +=
		"AND "
		   "RESPOSTAUNIDADE.IDTIPOPESSOA IN (";
		j=0;  
		for ( itCliente = pCliente->begin(); itCliente != pCliente->end(); itCliente++ )
		{
			if ( j > 0 ) consulta += ",";
			
			sprintf( buffer, "%d", *itCliente );
			consulta += buffer;
			j++;
		}
        consulta += ") ";

		consulta +=
		"AND "
		   "RESPOSTAUNIDADE.IDRESPOSTA1 = ";
		sprintf( buffer, "%d", idRespostaIntencao );
		consulta += buffer;

		consulta +=
		" AND "
		   "RESPOSTAUNIDADE.IDRESPOSTA2 IN (";
		j=0;  
		for ( itDestino = pDestino->begin(); itDestino != pDestino->end(); itDestino++ )
		{
			if ( j > 0 ) consulta += ",";
			
			sprintf( buffer, "%d", *itDestino );
			consulta += buffer;
			j++;
		}
        consulta += ")";

		consulta +=
		" AND "
		   "RESPOSTAUNIDADE.IDUFOPERADORA IN (";
		j=0;  
		for ( itRegional = pRegional->begin(); itRegional != pRegional->end(); itRegional++ )
		{
			if ( j > 0 ) consulta += ",";
			
			sprintf( buffer, "%d", *itRegional );
			consulta += buffer;
			j++;
		}
        consulta += ")";

		query = (char *)consulta.c_str();
		
		ULOG( query );
		
		EXEC SQL PREPARE ConsultaRespostaUnidade FROM :query;
		EXEC SQL DECLARE crsRespostaUnidade CURSOR FOR ConsultaRespostaUnidade;

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL OPEN crsRespostaUnidade;

		for( ;; )
		{
		    
		    EXEC SQL FETCH crsRespostaUnidade INTO 
		        :idRespostaUnidade ;
		    pRespostaUnidade->push_back(idRespostaUnidade);
		}
		
		EXEC SQL CLOSE crsRespostaUnidade;
    	ULOG_END( "BuscaRespostaUnidade()" );

	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: BuscaRespostaUnidade()" );
		throw;
	}

}



void GetScripts( XMLGen *xml )
{
	ULOG_START( "GetScripts()" );
		
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR idScript[40]; 
		VARCHAR dsScript[256]; 
		short i_idScript = -1;
		short i_dsScript = -1;
	EXEC SQL END DECLARE SECTION;

	memset( &idScript, 0x0, sizeof(idScript) );
	memset( &dsScript, 0x0, sizeof(dsScript) );
	
	try
	{
		EXEC SQL DECLARE crsScript CURSOR FOR
        SELECT   idscript, nmscript
            FROM retencao.script
        ORDER BY TRIM (UPPER (nmscript));
	
		xml->createTag( "Lista" );
			xml->addItem( "nmSelect","LSTSCRIPT" );
			xml->createTag( "Disponivel" );
			
			EXEC SQL OPEN crsScript;
			
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			for(;;)
			{
				EXEC SQL FETCH crsScript INTO :idScript:i_idScript, 
					                          :dsScript:i_dsScript;
				
				endOraStr( idScript );
				endOraStr( dsScript );
				xml->createTag("It");
					xml->addItem( "id",(char*)idScript.arr );
					xml->addItem( "ds",(char*)dsScript.arr );
				xml->closeTag();
			
			}                      
			EXEC SQL CLOSE crsScript;
			EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
			xml->closeTag();
		xml->closeTag();
		
		ULOG_END( "GetScripts()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: GetScripts()" );
		throw;
	}

}



void sel_Script( char * idScriptPrm, XMLGen * xml )
{
	ULOG_START( "sel_Script()" );
		
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR idScript[40]; 
		VARCHAR dsScript[128]; 
		VARCHAR inHabilitado[2]; 
		VARCHAR nmUsuario[128]; 
		VARCHAR dtAlteracao[40]; 
		VARCHAR idUsuario[40]; 
	EXEC SQL END DECLARE SECTION;

	strToOra( idScript,idScriptPrm );

	try
	{
		EXEC SQL
        SELECT nmscript, inativo, idusuarioalteracao,
               TO_CHAR (dtalteracao, 'DD/MM/YYYY HH:mm:SS')
          INTO :dsScript, :inHabilitado, :idUsuario, :dtAlteracao
          FROM retencao.script
         WHERE idscript = :idScript;
 
		EXEC SQL
        SELECT nmloginusuario
          INTO :nmUsuario
          FROM acesso.usuario
         WHERE idpessoausuario = :idUsuario;

        endOraStr( dsScript );
        endOraStr( inHabilitado );
        endOraStr( idUsuario );
        endOraStr( nmUsuario );
        endOraStr( dtAlteracao );

        xml->createTag( "Manter" );
            xml->addItem( "idCadastrado",(char*)idScript.arr );
            xml->addItem( "nmCadastrado",(char*)dsScript.arr );
            xml->addItem( "inHabilitado",(char*)inHabilitado.arr );
            xml->addItem( "nmUsuario",(char*)nmUsuario.arr );
            xml->addItem( "dtAlteracao",(char*)dtAlteracao.arr );
		xml->closeTag();
		
		ULOG_END( "sel_Script()" );
	}
	catch(...)
	{
		ULOGE( "*** SAIDA ANORMAL: sel_Script()" );
		throw;
	}
}

