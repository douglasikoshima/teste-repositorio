#include "../../negocio/fidutil/include/retencao.hpp"

char* trim(char *pStr);

int  cad_pp_seg(int usuario, DOMNode*dnode,XMLGen*xml)
{
  char parm[50];
    
	ULOG_START( "cad_pp_seg" );
  
  EXEC SQL BEGIN DECLARE SECTION;
  	
	char  O_CDERRO[256];
	char  O_DSERRO[1024];
	
	char szProcedure[10000];
	char szProcedure2[10000];
	
	EXEC SQL END DECLARE SECTION;
	
	int iCDERRO = -1;	
	
    EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);
	
    ULOG( "Entrando no servico CADPPSEG." );		

    memset(O_CDERRO, 0x0, sizeof(O_CDERRO));
    memset(O_DSERRO, 0x0, sizeof(O_DSERRO));
    memset( szProcedure, 0x0, sizeof( szProcedure ) );
    memset( szProcedure2, 0x0, sizeof( szProcedure2 ) );

	
    try
    {

		get_tag(parm, dnode, "PROCEDURE", 0, 0);
		strcpy(szProcedure,parm);
		
        ULOG( "szProcedure [%s]", szProcedure );
		
	  sprintf(szProcedure2, "BEGIN %s END;",szProcedure);
        ULOG( "szProcedure2 [%s]", szProcedure2 );

        ULOG( "--------------------------------------------------------------------");  
	  
        ULOG( "Realizando chamada no DB do Programa de Pontos para os parametros.." );
        ULOG( "Executando PLSQL[%s] no DB do Programa de Pontos." , szProcedure2);
	  
	  EXEC SQL PREPARE CALLPROC FROM :szProcedure2;
	  
	  EXEC SQL EXECUTE CALLPROC USING :O_CDERRO, :O_DSERRO;
		
	  try
	  {
		trim(O_CDERRO);
		trim(O_DSERRO);
		
		if(O_CDERRO != NULL)
			ULOGE( "Retorno do CDERRO[%s]", O_CDERRO );
		if(O_DSERRO != NULL)
			ULOGE( "Retorno do DSERRO[%s]", O_DSERRO );
			
		iCDERRO = atoi(O_CDERRO);
	  }
	  catch(...)
	  {
      }
	
	  if ( iCDERRO != 0 )
	  {
		ULOGE( "ERRO no retorno da chamada da PROCEDURE");
	  }
	  ULOGE( "--------------------------------------------------------------------");  
	  
	  // Operacao OK
      xml->addItem("descricao","CADASTROONLINEVIVONET");
	  xml->addItem("O_CDERRO",O_CDERRO);
      xml->addItem("O_DSERRO",O_DSERRO);

    }
    catch(...)
    {
        
        throw;
    }
    
    if ( iCDERRO != 0 )
    {
        ULOGE( "ERRO no retorno da chamada da PROCEDURE");
        return -1;
    }
    else
    {
        return 1;
    }
}



char* trim(char *pStr)
{
    int lInd = 0;
    int iSize = strlen(pStr);

    if (pStr == NULL)
       return NULL;

    while (isspace(pStr[lInd])){
        lInd++;
    }

    strncpy(pStr,(pStr+lInd), iSize-lInd);
    pStr = pStr + lInd;

    register int iPos;

    for(iPos=strlen(pStr)-1; iPos >= 0; iPos--)
        if(pStr[iPos] == 0x20)
            pStr[iPos] = 0x00;
        else
            break;
    return pStr;
}





