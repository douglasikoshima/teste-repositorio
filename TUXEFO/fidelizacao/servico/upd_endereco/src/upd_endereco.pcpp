//
// $Id: upd_endereco.pcpp,v 1.1.118.1 2013/02/06 12:37:06 a5114878 Exp $
//

#include "../../negocio/fidutil/include/retencao.hpp"
#include "../../negocio/fidutil/include/SmallString.h"

#define PARAMATRO_ID_ARVORE_BAIXA "PARAMATRO_ID_ARVORE_BAIXA_ENDERECO"
#define SERVICO_PARA_FECHAR_PREOCESSO   "CERRAMEFEC"
#define ATIVIDADE_FECHAMENTO      10 
#define REPROVADO_ANALISATA_ENDERECO_BKO   5
#define APROVADO_ANALISATA_ENDERECO_BKO    0

////////////////////////////////////////////////////////////////////////////////////////
// Tipo de retorno do contato (CONTATOADM.TIPORETORNOCONTATO)
//  estes difene estao no arquivo  > #include "definesAtendimento.h"
#define TP_RET_SEM_RETORNO     0
#define TP_RET_COM_RET_GRP_BKO 1
#define TP_RET_COM_RET_GRP_RET 2
#define TP_RET_SEM_RET_ONLINE  3
#define TP_RET_COM_RET_GRP_CRI 4


//  esta strutura contem os dados necessarios para chamar o servico fechamento de forma remota
typedef  struct _stDadosAtendimento 
{
 unsigned long  idAtendimento;                         // OK a ser fechado no workflow
 int            idTipoRetornoContato;                  // OK 
 int            idFase;                                // OK fase do processo 
 int            idAtividade;                           // OK FECHAMENTO  10 
 int            idAgrupamentoEstadoTProcFut;           // OK esta informacao vira da tela 
 int            idAgrupamentoEstadoTProcAt;            // OK esta informacao e obtida com o idatendimento no metodo  proCObtemWFDetalheAtendimento
 int            idPessoaUsuario;                       // OK
 char           nmUrlDestino[256];                     // OK 
 char           dsObservacao[256];                     // OK  
 int            idMotivo;     
 int            idBaixa;
 int            idBaixaMensagem;
} stDadosAtendimento ;


EXEC SQL BEGIN DECLARE SECTION;

typedef struct _stEnderecoAlterado
{
  long int  IDRETENCAO;                //  NUMBER(16)         NOT NULL,
  char DSENDERECO[71];                //  VARCHAR2(70 BYTE),
  char NRNUMERO[6];                   //  VARCHAR2(5 BYTE),
  char DSCOMPLEMENTO[21];             //  VARCHAR2(20 BYTE),
  char DSBAIRRO[41];                  //  VARCHAR2(40 BYTE),
  char DSCIDADE[41];                  //  VARCHAR2(40 BYTE),
  char DSESTADO[3];                   //  VARCHAR2(2 BYTE),
  char DSCEP[71];                     //  VARCHAR2(70 BYTE),
  int IDMOTIVOALTERACAOENDERECO;      //   NUMBER(2)          NOT NULL,
  int INMODIFICACAO;                  //  NUMBER(1)          DEFAULT 0,
  char DSOBSERVACAO[257];             //  VARCHAR2(256 BYTE),
  char DTULTIMAALTERACAO[70];         //  DATE,
  long int IDUSUARIOALTERACAO;        //  NUMBER,
  long int IDUSUARIOINCLUSAO;         //  NUMBER,
  int  INAPROVADO;                    //  NUMBER(1),
  char NMTERCEIRO[71];                //  VARCHAR2(70 BYTE),
  char NRRGTERCEIRO[21];              //  VARCHAR2(20 BYTE),
  char NRTELTERCEIRO[21];             //  VARCHAR2(20 BYTE)
} stEnderecoAlterado;

typedef struct _st_IEnderecoAlterado
{
  short i_IDRETENCAO;                //  NUMBER(16)         NOT NULL,
  short i_DSENDERECO;                //  VARCHAR2(70 BYTE),
  short i_NRNUMERO;                   //  VARCHAR2(5 BYTE),
  short i_DSCOMPLEMENTO;             //  VARCHAR2(20 BYTE),
  short i_DSBAIRRO;                  //  VARCHAR2(40 BYTE),
  short i_DSCIDADE;                  //  VARCHAR2(40 BYTE),
  short i_DSESTADO;                   //  VARCHAR2(2 BYTE),
  short i_DSCEP;                     //  VARCHAR2(70 BYTE),
  short i_IDMOTIVOALTERACAOENDERECO;      //   NUMBER(2)          NOT NULL,
  short i_INMODIFICACAO;                  //  NUMBER(1)          DEFAULT 0,
  short i_DSOBSERVACAO;             //  VARCHAR2(256 BYTE),
  short i_DTULTIMAALTERACAO;         //  DATE,
  short i_IDUSUARIOALTERACAO;        //  NUMBER,
  short i_IDUSUARIOINCLUSAO;         //  NUMBER,
  short i_INAPROVADO;                    //  NUMBER(1),
  short i_NMTERCEIRO;                //  VARCHAR2(70 BYTE),
  short i_NRRGTERCEIRO;              //  VARCHAR2(20 BYTE),
  short i_NRTELTERCEIRO;             //  VARCHAR2(20 BYTE)
} st_IEnderecoAlterado;

EXEC SQL END DECLARE SECTION;

void Get_Endereco( stEnderecoAlterado *psEnderecoAlterado );
void Call(char *labelServico,char *sUsuario,SmallString &strDomScr);
void FormataDados(SmallString &strDomScr, stDadosAtendimento  DadosAtendimento);
bool proCObtemWFDetalheAtendimento( unsigned long _idAtendimento , stDadosAtendimento *pstDadosAtendimento    );
bool proCObterTipoRetornoContato(unsigned long _idAtendimento,int *_idUFOperadora,int *_idTipoRetornoContato,  int *_idBaixa ,int * _idBaixaMensagem );
bool proCObterEstadoFuturo(unsigned long _idAtendimento,int *_EstadoFut);

int get_Parametro(char *_cdParametro, char *_dsValorParametro);
int get_idBiaxaMensagem(char *_idBaixa, char *_idBaixaMensagem);

int upd_endereco(int usuario, DOMNode*dnode, XMLGen*xml)
{
  ULOG_START("upd_endereco()");
  char parm[255];
  int iRet=0;
  
  stEnderecoAlterado sEnderecoAlterado;
  stDadosAtendimento DadosAtendimento;
  
  memset(&DadosAtendimento,0,sizeof(stDadosAtendimento));
  memset(&sEnderecoAlterado,0,sizeof(stEnderecoAlterado));
  
  

  SmallString strDomScr;  
  
  char sUsuario[21];
  sprintf( sUsuario, "%d", usuario );
  

  EXEC SQL BEGIN DECLARE SECTION;
  	  VARCHAR        dsEndereco[70];    			  //  ENDERECO ALTERADO PELO ATENDENTE RETENCAO
  	  VARCHAR        nrNumero[05];    				  //  NUMERO ALTERADO PELO ATENDENTE RETENCAO
  	  VARCHAR        dsComplemento[20];    			  //  NUMERO ALTERADO PELO ATENDENTE RETENCAO
  	  VARCHAR        dsBairro[40];    				  //  NUMERO ALTERADO PELO ATENDENTE RETENCAO
  	  VARCHAR        dsCidade[40];    				  //  NUMERO ALTERADO PELO ATENDENTE RETENCAO
  	  VARCHAR        dsEstado[2];     				  //  NUMERO ALTERADO PELO ATENDENTE RETENCAO
  	  VARCHAR        dsCep[70];    				      //  CEP ALTERADO PELO ATENDENTE RETENCAO
//      VARCHAR        nmTerceiro2[70];
      VARCHAR        nmTerceiro[70];
      VARCHAR        nrRGTerceiro[20];
      VARCHAR        nrTelTerceiro[20];
      VARCHAR        dsObsAnalista[256];    			      //  ENDERECO ALTERADO PELO ATENDENTE RETENCAO
  	  int inAprovado = 0 ;                                    // defalt da retencao e reprovado
//  	  int 		     idMotivoAlteracaoEndereco;       //  CHAVE ESTRANGEIRA   
// 	  VARCHAR        dsObservacao[256];               //  OBSERVACAO ESCRITA PELO ANALISTA BKA NA MODIFIFCACAO DO ENDERECO 
// 	  int            indModificacao;                  //  indicador de modificacao do registro pelo analisata bko
  	  int            idRetencao; 				      //  CHAVE PRIMARIA   		
  	  long int            idTipoAnalise;
  	  
  	  
  	  VARCHAR     idCaracteristicaOfertaAceita[21+1]; 
      VARCHAR     idCaracteristicaOferta[21+1];
      VARCHAR     nmPropriedade[255];
      VARCHAR     vlPropriedade[255];

      VARCHAR     vlChip[256];
      short       i_vlChip = -1;

      VARCHAR     cdChip[256];
      short       i_cdChip = -1;
      
      VARCHAR     idOfertaRealizada[21+1]; //para ofertas aceitas!      

       char           nrOrdemVenda[50];	  
  	  
      unsigned long  idPessoaUsuarioAlteracao;
      
      short i_idOfertaRealizada;
      short i_idCaracteristicaOferta;
      short i_nmPropriedade;
      short i_idCaracteristicaOfertaAceita=0;

  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);
  

  memset( &cdChip,0x0,sizeof(cdChip) );
  memset( &vlChip,0x0,sizeof(vlChip) );

  
  
  memset(nrOrdemVenda,0,sizeof(nrOrdemVenda));
  memset(&idCaracteristicaOfertaAceita,0,sizeof(idCaracteristicaOfertaAceita));

  try{

        
        // verifica se aprovado pelo analista BKO
	    get_tag(parm,dnode,"dsObsAnalista",0,0);
//	    strToOra(dsObsAnalista,parm);
	    strcpy(DadosAtendimento.dsObservacao,parm );
	    ULOG("DadosAtendimento.dsObservacao = [%s]",DadosAtendimento.dsObservacao);
    
        get_tag(parm,dnode,"idTipoAnalise",0,0);
        idTipoAnalise=atoi(parm);
        ULOG(" idTipoAnalise = [%d]",idTipoAnalise);
        
        memset(nrOrdemVenda,0,sizeof(nrOrdemVenda));
        get_tag(nrOrdemVenda,dnode,"nrOrdemVenda",0,-1);
        ULOG(" nrOrdemVenda = [%s]",nrOrdemVenda);
        
        
        
        if ( idTipoAnalise == APROVADO_ANALISATA_ENDERECO_BKO )
        {
            
            inAprovado = 1 ;
            DadosAtendimento.idMotivo = 51 ;   // nao existe na tabela motivo deve ser incluido 
             
            if ( strlen(DadosAtendimento.dsObservacao) == 0 )
                strcpy(DadosAtendimento.dsObservacao,"Retenção Aprovada pelo analista BKO");
        }    
            
        if ( idTipoAnalise == REPROVADO_ANALISATA_ENDERECO_BKO )
        {
             DadosAtendimento.idMotivo = 52 ;   // nao existe na tabela motivo deve ser incluido 
             if ( strlen(DadosAtendimento.dsObservacao) == 0 )
                strcpy(DadosAtendimento.dsObservacao,"Retenção Reprovada pelo analista BKO");
        }   
        
	    strToOra(dsObsAnalista,DadosAtendimento.dsObservacao);        

        //  Obtendo dados do xml idAtendiemento
        get_tag(parm,dnode,"idAtendimento",0,-1);
        DadosAtendimento.idAtendimento = atoi(parm);
        if(DadosAtendimento.idAtendimento != 0)
        {            
            proCObterEstadoFuturo(DadosAtendimento.idAtendimento,&DadosAtendimento.idAgrupamentoEstadoTProcFut);
            
    
    	    DadosAtendimento.idAtividade = ATIVIDADE_FECHAMENTO ;
    	    DadosAtendimento.idPessoaUsuario = usuario;
    
            // recupera dados para executar o servico de forma remota
            
            proCObtemWFDetalheAtendimento( DadosAtendimento.idAtendimento , &DadosAtendimento );
    
    
    		// cria o xml de saida
    		FormataDados(strDomScr, DadosAtendimento);
    		ULOG( "XML IN DFECHAMENTO [%s]", (char *)strDomScr.c_str() );
    
            Call(SERVICO_PARA_FECHAR_PREOCESSO, sUsuario,strDomScr);
        
        } 
  	    // Dados de entrada do Endereco
  	    get_tag(parm,dnode,"idRetencao",0,0);
  	    idRetencao=atoi(parm);
  	    sEnderecoAlterado.IDRETENCAO = idRetencao ;
  	    
  	    // recupera os dados da retencao
  	    
  	    Get_Endereco(&sEnderecoAlterado);

	    get_tag(sEnderecoAlterado.DSENDERECO,dnode,"dsEndereco",0,-1);
	    strToOra(dsEndereco,sEnderecoAlterado.DSENDERECO);
	    
	    get_tag(sEnderecoAlterado.NRNUMERO,dnode,"nmNumero",0,-1);
	    strToOra(nrNumero,sEnderecoAlterado.NRNUMERO);
	
	    get_tag(sEnderecoAlterado.DSCOMPLEMENTO,dnode,"dsComplemento",0,-1);
	    strToOra(dsComplemento,sEnderecoAlterado.DSCOMPLEMENTO);
	
	    get_tag(sEnderecoAlterado.DSBAIRRO,dnode,"dsBairro",0,-1);
	    strToOra(dsBairro,sEnderecoAlterado.DSBAIRRO);
	  	
	    get_tag(sEnderecoAlterado.DSCIDADE,dnode,"dsCidade",0,-1);
	    strToOra(dsCidade,sEnderecoAlterado.DSCIDADE);
	  	
	    get_tag(sEnderecoAlterado.DSESTADO,dnode,"dsUF",0,-1);
	    strToOra(dsEstado,sEnderecoAlterado.DSESTADO);
	    
	    get_tag(sEnderecoAlterado.DSCEP,dnode,"dsCEP",0,-1);
	    strToOra(dsCep,sEnderecoAlterado.DSCEP);

//        get_tag(sEnderecoAlterado.DSOBSERVACAO,dnode,"dsObservacao",0,-1);
//	    strToOra(dsObservacao,sEnderecoAlterado.DSOBSERVACAO);
 	    
// 	    get_tag(parm,dnode,"indModificacao",0,0);
// 	    indModificacao =atoi(parm);     
 	    
        
        get_tag(sEnderecoAlterado.NMTERCEIRO,dnode,"nmTerceiro",0,-1);
        strToOra(nmTerceiro,sEnderecoAlterado.NMTERCEIRO);

        get_tag(sEnderecoAlterado.NRRGTERCEIRO,dnode,"nrRGTerceiro",0,-1);
        strToOra(nrRGTerceiro,sEnderecoAlterado.NRRGTERCEIRO);

        get_tag(sEnderecoAlterado.NRTELTERCEIRO,dnode,"nrTelTerceiro",0,-1);
        strToOra(nrTelTerceiro,sEnderecoAlterado.NRTELTERCEIRO);        

        // Pegando id do usuario
        idPessoaUsuarioAlteracao = usuario;

        ULOG("UPDATE EM RETENCAO.ENDERECOALTERADO ");
  
		/* Update linha */
		EXEC SQL UPDATE RETENCAO.ENDERECOALTERADO
			 SET 
			  DSENDERECO 	 			=  :dsEndereco,       
			  NRNUMERO   	 			=  :nrNumero,      
			  DSCOMPLEMENTO  			=  :dsComplemento,
			  DSBAIRRO      			=  :dsBairro,   
			  DSCIDADE       			=  :dsCidade,   
			  DSESTADO       			=  :dsEstado,     
			  DSCEP          			=  :dsCep,     
//			  IDMOTIVOALTERACAOENDERECO =  :idMotivoAlteracaoEndereco,
			  DTULTIMAALTERACAO         =   SYSDATE ,
			  IDUSUARIOALTERACAO        =  :idPessoaUsuarioAlteracao,
//              INMODIFICACAO             =  :indModificacao,
              NRRGTERCEIRO              =  :nrRGTerceiro,
              NMTERCEIRO                =  :nmTerceiro,
              NRTELTERCEIRO             =  :nrTelTerceiro,
              DSOBSERVACAO              =  :dsObsAnalista 
			WHERE IDRETENCAO = :idRetencao;
			    
     ULOG("idTipoAnalise = [%d] ",idTipoAnalise);			    
     ULOG("idRetencao = [%d] ",idRetencao);			    
	 // atualiza o estado do aparelho		    
     EXEC SQL UPDATE RETENCAO.RETENCAOANALISE 			    
     	  SET IDTIPOANALISE = :idTipoAnalise
		  WHERE IDRETENCAO = :idRetencao;
		    
     // cria historico 		    
     if ( strlen(nrOrdemVenda)>0 )
     {

         EXEC SQL
         SELECT
            VLCHIP,
            CDCHIP
         INTO
         :vlChip:i_vlChip,
         :cdChip:i_cdChip
         FROM
            RETENCAO.RETENCAOAPARELHO
         WHERE
            IDRETENCAO = :idRetencao;
         
        endOraStr(vlChip);
        endOraStr(cdChip);
        
        // GRAVA NA TABELA RETENCAOAPARELHO MODELO NOVO 
        ULOG(
             "UPDATE RETENCAO.RETENCAOAPARELHO "			    
             " SET NRORDEMVENDA = %s "
    		 " WHERE IDRETENCAO = %lu;",nrOrdemVenda ,idRetencao
             );
         // compatibilidade com o sistema novo
        EXEC SQL 
             UPDATE RETENCAO.RETENCAOAPARELHO 			    
             SET NRORDEMVENDA = :nrOrdemVenda
    		 WHERE IDRETENCAO = :idRetencao;

        memset(&idCaracteristicaOferta,0x0,sizeof(idCaracteristicaOferta));
        memset(&nmPropriedade,0x0,sizeof(nmPropriedade));
        
    	// obtem => idCaracteristicaOferta e nmPropriedade da Tavela = CARACTERISTICAOFERTA 
    	ULOG(
            "SELECT "
               " IDCARACTERISTICAOFERTA,"
               " DSCARACTERISTICAOFERTA "
            "FROM "
            "    RETENCAO.CARACTERISTICAOFERTA "          
            "WHERE "
            "    TRIM(NMCOLUNA) = TRIM('NRORDEMVENDA')  AND ROWNUM < 2 ; "
    	    );

        EXEC SQL 
        SELECT 
            IDCARACTERISTICAOFERTA,
            DSCARACTERISTICAOFERTA
        INTO 
            :idCaracteristicaOferta:i_idCaracteristicaOferta,
            :nmPropriedade:i_nmPropriedade
        FROM 
            RETENCAO.CARACTERISTICAOFERTA           
        WHERE 
            TRIM(NMCOLUNA) = TRIM('NRORDEMVENDA')  AND ROWNUM < 2 ;

        endOraStr(idCaracteristicaOferta);
        endOraStr(nmPropriedade);
         
        ULOG("idCaracteristicaOferta = [%s]",(char*)idCaracteristicaOferta.arr);
        ULOG("nmPropriedade = [%s]",(char*)nmPropriedade.arr);

        
        memset(&idOfertaRealizada,0x0,sizeof(idOfertaRealizada));
        
        // "obtem => IDOFERTAREALIZADA Tavela = OFERTAREALIZADA "
        
        ULOG(
            "SELECT   IDOFERTAREALIZADA  "
            "FROM "
            "    RETENCAO.OFERTAREALIZADA  OFERTAREALIZADA      "
            "WHERE "
            "    OFERTAREALIZADA.IDRETENCAO = %lu; ",idRetencao
            );
        
        EXEC SQL 
            SELECT   IDOFERTAREALIZADA  
            INTO    :idOfertaRealizada:i_idOfertaRealizada
            FROM 
                RETENCAO.OFERTAREALIZADA  OFERTAREALIZADA      
            WHERE 
                OFERTAREALIZADA.IDRETENCAO = :idRetencao
            and INOFERTAACEITA=1;

        
        endOraStr(idOfertaRealizada);        
        ULOG("idOfertaRealizada = [%s]",(char*)idOfertaRealizada.arr);
        
        // conteudo da tag  nrOrdemVenda
        memset(&vlPropriedade,0x0,sizeof(vlPropriedade));
        strToOra(vlPropriedade,nrOrdemVenda);
        endOraStr(vlPropriedade);
        
        ULOG("vlPropriedade = [%s]",(char*)vlPropriedade.arr);
        ULOG(
              "SELECT IDCARACTERISTICAOFERTAACEITA "
              "FROM RETENCAO.CARACTERISTICAOFERTAACEITA "
              "WHERE IDCARACTERISTICAOFERTA = %s "
                "AND IDOFERTAREALIZADA = %s ",(char*)idCaracteristicaOferta.arr ,(char*)idOfertaRealizada.arr
             );
        
        EXEC SQL 
          SELECT IDCARACTERISTICAOFERTAACEITA 
          INTO   :idCaracteristicaOfertaAceita:i_idCaracteristicaOfertaAceita
          FROM RETENCAO.CARACTERISTICAOFERTAACEITA 
          WHERE IDCARACTERISTICAOFERTA = :idCaracteristicaOferta
            AND IDOFERTAREALIZADA = :idOfertaRealizada;
        
        ULOG("idCaracteristicaOfertaAceita = [%s]",(char*)idCaracteristicaOfertaAceita.arr);
        if ( idCaracteristicaOfertaAceita.len > 0 )
        {
           EXEC SQL 
             UPDATE RETENCAO.CARACTERISTICAOFERTAACEITA 			    
               SET VLPROPRIEDADE = :vlPropriedade
             WHERE IDCARACTERISTICAOFERTA = :idCaracteristicaOferta
               AND IDOFERTAREALIZADA = :idOfertaRealizada;
        }    
        else
        {    
            ULOG(
            "insert "
            "into retencao.CaracteristicaOfertaAceita(idCaracteristicaOfertaAceita,"
                                                      "  idOfertaRealizada, "
                                                      "  nmPropriedade,"
                                                      "  vlPropriedade,"
                                                      "  idPessoaUsuarioInclusao,"
                                                      "  dtInclusao,"
                                                      "  idPessoaUsuarioAlteracao,"
                                                      "  dtAlteracao,"
                                                      "  idUsuarioAlteracao,"
                                                      "  dtUltimaAlteracao,"
                                                      "  idCaracteristicaOferta)"
            "values( retencao.CaracteristicaOfertaAceitaSQ.nextval,%s,'%s','%s',%d,sysdate,%d,sysdate,%d,sysdate,%s)",
            (char*)idOfertaRealizada.arr,   
            (char*)nmPropriedade.arr,
            (char*)vlPropriedade.arr,
            idPessoaUsuarioAlteracao,
            idPessoaUsuarioAlteracao,
            idPessoaUsuarioAlteracao ,
            (char*)idCaracteristicaOferta.arr);
            
            
            
            EXEC SQL 
            insert 
            into retencao.CaracteristicaOfertaAceita(idCaracteristicaOfertaAceita,
                                                        idOfertaRealizada, 
                                                        nmPropriedade,
                                                        vlPropriedade,
                                                        idPessoaUsuarioInclusao,
                                                        dtInclusao,
                                                        idPessoaUsuarioAlteracao,
                                                        dtAlteracao,
                                                        idUsuarioAlteracao,
                                                        dtUltimaAlteracao,
                                                        idCaracteristicaOferta)
            values( retencao.CaracteristicaOfertaAceitaSQ.nextval,
                    :idOfertaRealizada,
                    :nmPropriedade,
                    :vlPropriedade,
                    :idPessoaUsuarioAlteracao,
                    sysdate,
                    :idPessoaUsuarioAlteracao,
                    sysdate,
                    :idPessoaUsuarioAlteracao,
                    sysdate,
                    :idCaracteristicaOferta);

        
        

// Codigo do Chip


      if ( i_cdChip != -1 )
      {

            EXEC SQL 
            insert 
            into retencao.CaracteristicaOfertaAceita(idCaracteristicaOfertaAceita,
                                                        idOfertaRealizada, 
                                                        nmPropriedade,
                                                        vlPropriedade,
                                                        idPessoaUsuarioInclusao,
                                                        dtInclusao,
                                                        idPessoaUsuarioAlteracao,
                                                        dtAlteracao,
                                                        idUsuarioAlteracao,
                                                        dtUltimaAlteracao,
                                                        idCaracteristicaOferta)
            values( retencao.CaracteristicaOfertaAceitaSQ.nextval,
                    :idOfertaRealizada,
                    'CDSAPCHIP',
                    :cdChip,
                    :idPessoaUsuarioAlteracao,
                    sysdate,
                    :idPessoaUsuarioAlteracao,
                    sysdate,
                    :idPessoaUsuarioAlteracao,
                    sysdate,
                    1556);
            
        
      }
        
// Valor do Chip

      if ( i_vlChip != -1 )
      {

            EXEC SQL 
            insert 
            into retencao.CaracteristicaOfertaAceita(idCaracteristicaOfertaAceita,
                                                        idOfertaRealizada, 
                                                        nmPropriedade,
                                                        vlPropriedade,
                                                        idPessoaUsuarioInclusao,
                                                        dtInclusao,
                                                        idPessoaUsuarioAlteracao,
                                                        dtAlteracao,
                                                        idUsuarioAlteracao,
                                                        dtUltimaAlteracao,
                                                        idCaracteristicaOferta)
            values( retencao.CaracteristicaOfertaAceitaSQ.nextval,
                    :idOfertaRealizada,
                    'Valor do Chip',
                    :vlChip,
                    :idPessoaUsuarioAlteracao,
                    sysdate,
                    :idPessoaUsuarioAlteracao,
                    sysdate,
                    :idPessoaUsuarioAlteracao,
                    sysdate,
                    1555);
        
        
      }
        
        }
     }   
	
  }
  catch(...)
  {
	throw;
  }
  
  // ULOG_EMD("upd_endereco()");
  return 1;
}

// esta funcao tem por objetivo incluir um registro de consolidacao para gerar relatorio com maio facilidade
void Get_Endereco( stEnderecoAlterado *psEnderecoAlterado )
{
    ULOG_START( "Get_Endereco()" );
    
    
    EXEC SQL BEGIN DECLARE SECTION;
        
        int  idRetencao;         
        stEnderecoAlterado *sEnderecoAlterado=psEnderecoAlterado;
        st_IEnderecoAlterado IEnderecoAlterado;

    EXEC SQL END DECLARE SECTION;

    idRetencao = psEnderecoAlterado->IDRETENCAO;

    
    ULOG( " INSERT INTO RETENCAO.ENDERECOALTERADO" );
    
    EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        SELECT 
           IDRETENCAO,                //  NUMBER(16)         NOT NULL,
           DSENDERECO,                //  VARCHAR2(70 BYTE),
           NRNUMERO,                   //  VARCHAR2(5 BYTE),
           DSCOMPLEMENTO,             //  VARCHAR2(20 BYTE),
           DSBAIRRO,                 //  VARCHAR2(40 BYTE),
           DSCIDADE,                  //  VARCHAR2(40 BYTE),
           DSESTADO,                   //  VARCHAR2(2 BYTE),
           DSCEP,                     //  VARCHAR2(70 BYTE),
           IDMOTIVOALTERACAOENDERECO,      //   NUMBER(2)          NOT NULL,
           INMODIFICACAO,                  //  NUMBER(1)          DEFAULT 0,
           DSOBSERVACAO,             //  VARCHAR2(256 BYTE),
           DTULTIMAALTERACAO,         //  DATE,
           IDUSUARIOALTERACAO,        //  NUMBER,
           IDUSUARIOINCLUSAO,         //  NUMBER,
           INAPROVADO,                    //  NUMBER(1),
           NMTERCEIRO,                //  VARCHAR2(70 BYTE),
           NRRGTERCEIRO,              //  VARCHAR2(20 BYTE),
           NRTELTERCEIRO             //  VARCHAR2(20 BYTE)
        INTO :sEnderecoAlterado:IEnderecoAlterado
        FROM  RETENCAO.ENDERECOALTERADO
        WHERE   IDRETENCAO =  :idRetencao;

 

    ULOG_END( "Get_Endereco()" );

}

void Call(char *labelServico,char *sUsuario,SmallString &strDomScr)
{
    ULOG_START("Call()");
    
    TuxRemoteService *rc = new TuxRemoteService;

    if ( !rc )
    {
        char *err = "Erro na alocacao de objeto TuxRemoteService";
        ULOGE("%s",err);
        throw new TuxBasicSvcException("00E0000",err);
    }

    TuxMessage *tmIn = new TuxMessage();

    if ( !tmIn )
    {
        delete rc;

        char *err = "Erro na alocacao de objeto TuxMessage";
        ULOGE("%s",err);
        throw new TuxBasicSvcException("00E0000",err);
    }

    try 
    {
        // sprintf( m_stDados.sequence,"%d",cWFCoreWorkflow::tuxSeqRemoteCall++ );

        tmIn->setService( labelServico );
        tmIn->setUser(sUsuario);
        
        // NAO NECESSARIO tmIn->setSequence( m_stDados.sequence );
        
        tmIn->setMessageBody( strDomScr.c_str() );

        rc->setServiceName( labelServico );
        rc->setInputMessage( tmIn );

        ULOGE("TuxRemoteService::remoteCall chamando servico '%s'" ,labelServico);

        if ( rc->remoteCall() != TUXFWRET_OK )
        {
            SmallString err;
            err = "Erro na chamada ao servico ";
            err += labelServico;
            err += " (";
            err += labelServico;
            err += ")";
            throw new TuxException("00E0000",err.c_str());
        }

        TuxMessage* outTm = rc->getOutputMessage();

        char *codigoRetorno = outTm->getStatusCode();
        char *statusText = outTm->getStatusText();

        ULOG("outTm->getMessageBody()=\"%s\"",outTm->getMessageBody());

        if ( *(codigoRetorno+2) == 'E' )
        {
            ULOGE("servico %s  retornou status code =\"%c\"",labelServico,*(codigoRetorno+2));
            throw new TuxException(codigoRetorno,statusText);
        }
    }
    catch (...)
    {
        delete rc;
        delete tmIn;
        ULOGE("erro na execucao do servico");
        ULOG_END("Call()");

        throw;
    }

    delete rc;
    delete tmIn;

    ULOG_END("Call()");

}

void FormataDados(SmallString &strDomScr, stDadosAtendimento  DadosAtendimento)
{                
    ULOG_START("FormataDados()");
    
    strDomScr = "<WFExecucao>";
    strDomScr += "\n\t<ScriptExecucaoVO>";
    strDomScr += "\n\t\t<idAtendimento>";
    strDomScr += DadosAtendimento.idAtendimento;
    strDomScr += "</idAtendimento>";
    strDomScr += "\n\t\t<idTipoRetornoContato>";
    strDomScr += DadosAtendimento.idTipoRetornoContato;
    strDomScr += "</idTipoRetornoContato>";
    strDomScr += "\n\t\t<idFase>";
    strDomScr += DadosAtendimento.idFase;
    strDomScr += "</idFase>";
    strDomScr += "\n\t\t<inCRI>0</inCRI>";
    strDomScr += "\n\t\t<inRC>0</inRC>";
    strDomScr += "\n\t\t<idAtividade>";
    strDomScr += DadosAtendimento.idAtividade;
    strDomScr += "</idAtividade>";
    strDomScr += "\n\t\t<idAtividadeMassa>";
    strDomScr += DadosAtendimento.idAtividade;
    strDomScr += "</idAtividadeMassa>";
    strDomScr += "\n\t\t<idAgrupamentoEstadoTProcFut>";
    strDomScr += DadosAtendimento.idAgrupamentoEstadoTProcFut;
    strDomScr += "</idAgrupamentoEstadoTProcFut>";
    strDomScr += "\n\t\t<idAgrupamentoEstadoTProcAt>";
    strDomScr += DadosAtendimento.idAgrupamentoEstadoTProcAt;
    strDomScr += "</idAgrupamentoEstadoTProcAt>";
    strDomScr += "\n\t\t<idPessoaUsuario>";
    strDomScr += DadosAtendimento.idPessoaUsuario;
    strDomScr += "</idPessoaUsuario>";		
    strDomScr += "\n\t\t<nmUrlDestino>";
    strDomScr += DadosAtendimento.nmUrlDestino;
    strDomScr += "</nmUrlDestino>";
    strDomScr += "\n\t</ScriptExecucaoVO>";
    strDomScr += "\n\t<AtendimentoWorkflowVO xmlns=\"admsistemas.fo.vivo.com.br/vo\" xmlns:ns1=\"workflow.fo.vivo.com.br/vo\">";
    strDomScr += "\n\t\t<AtendimentoWorkflowComumVO>";
    strDomScr += "\n\t\t\t<dsObservacao>";
    strDomScr += DadosAtendimento.dsObservacao;
    strDomScr += "</dsObservacao>";
    strDomScr += "\n\t\t\t<WFMotivoVO>";
    strDomScr += "\n\t\t\t\t<idMotivo>";
    strDomScr += DadosAtendimento.idMotivo;
    strDomScr += "</idMotivo>";
    strDomScr += "\n\t\t\t</WFMotivoVO>";
    strDomScr += "\n\t\t</AtendimentoWorkflowComumVO>";
    strDomScr += "\n\t\t<AtendimentoWorkflowEncerramentoVO>";
    strDomScr += "\n\t\t\t<ArvoreEncerramentoVO>";
    strDomScr += "\n\t\t\t\t<EncerramentoVO>";
	strDomScr += "\n\t\t\t\t\t<idBaixa>";
	strDomScr += DadosAtendimento.idBaixa;
	strDomScr += "</idBaixa>";
	strDomScr += "\n\t\t\t\t\t<idBaixaMensagem>";
	strDomScr += DadosAtendimento.idBaixaMensagem;
	strDomScr += "</idBaixaMensagem>";
	strDomScr += "\n\t\t\t\t\t<dsComentario/>";
	strDomScr += "\n\t\t\t\t\t<dsDocumentoAssociado/>";
    strDomScr += "\n\t\t\t\t</EncerramentoVO>";    
    strDomScr += "\n\t\t\t\t<FormularioVO/>";
    strDomScr += "\n\t\t\t</ArvoreEncerramentoVO>";
    strDomScr += "\n\t\t</AtendimentoWorkflowEncerramentoVO>";
    strDomScr += "\n\t</AtendimentoWorkflowVO>";
    strDomScr += "</WFExecucao>";            
    
    ULOG_END("FormataDados()");
}		

// ESTES METODO FOI COPIADO DO ATENDIMENTO PARA MANTER A INDEPENDENCIA DE COMPILACAO E 
// MANTERA O MESMO NOME PARA COMPATIBILIDADE  DA REGRA E MODIFICACAO FUTURA
bool proCObtemWFDetalheAtendimento( unsigned long _idAtendimento , stDadosAtendimento *pstDadosAtendimento    )
{
    ULOG_START( "proCObtemWFDetalheAtendimento()" );

    ULOG("idAtendimento= [%lu]",_idAtendimento);

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int idAtendimento = _idAtendimento;
        int idTipoRetornoContatoST;
        int idFase;
        int idAgrEstadoTProc;                //  idAgrupamentoEstadoTProcAt
        VARCHAR  nmUrlDestino[255];          // NMURLDESTINO        VARCHAR2(255 BYTE)
        short i_idTipoRetornoContato;
        short i_idFase;
        short i_idAgrEstadoTProc;
        short i_nmUrlDestino;
        
        int idBaixa =0 ;
        int idBaixaMensagem = 0  ;
        

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error(NULL);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        SELECT 
            ATD.IDTIPORETORNOCONTATO,
            ATD.IDFASE, 
            ATD.IDAGRUPAMENTOESTADOTPPROC
        INTO
           :idTipoRetornoContatoST:i_idTipoRetornoContato,
           :idFase:i_idFase,
           :idAgrEstadoTProc:i_idAgrEstadoTProc
        FROM 
            ATENDIMENTO.ATENDIMENTODETALHEV01 ATD,
            ATENDIMENTO.ATENDIMENTOPESSOA AP
        WHERE 
            ATD.IDATENDIMENTO = :idAtendimento
        AND
            AP.IDATENDIMENTO = ATD.IDATENDIMENTO
        AND
            AP.IDTIPORELACIONAMENTO IN (2,3,6,7); //M0007 (Melhoria) - Set, 2006 - Cassio


    if ( sqlca.sqlcode == 0 )
    {
        ULOG( "idTipoRetornoContato=%d",idTipoRetornoContatoST );

        if ( idTipoRetornoContatoST > TP_RET_SEM_RETORNO && 
             idTipoRetornoContatoST < TP_RET_COM_RET_GRP_CRI )
        { // se o processo foi criado para ir para grupo de retorno, então determina em
          // tempo real o tipo de retorno (vide DES BUG_3271_DES - Atualizada Gestão de Processos - Fase Retorno v.2.3.doc)
            int idUFOperadora;
            int idTipoRetornoContato;
            proCObterTipoRetornoContato(idAtendimento,&idUFOperadora,&idTipoRetornoContato,  &idBaixa ,&idBaixaMensagem);
            if ( -1 != idTipoRetornoContato )
            { // se processo em tratamento, assume o tipo do retorno do contato definido em tempo real
                // oDadosSaida.idUFOperadora = idUFOperadora;
                idTipoRetornoContatoST = idTipoRetornoContato;
            }
        }

		ULOG("idBaixa=[%d]",idBaixa);                
        if (idBaixa == 0)
        {
            char sidBaixa[33];
            char sidBaixaMensagem[33];
            char pesq[33];
            memset(sidBaixa,0,sizeof(sidBaixa));
            memset(sidBaixaMensagem,0,sizeof(sidBaixaMensagem));
            memset(pesq,0,sizeof(sidBaixaMensagem));
            strcpy(pesq,PARAMATRO_ID_ARVORE_BAIXA);
            get_Parametro(pesq,sidBaixa);
            get_idBiaxaMensagem(sidBaixa,sidBaixaMensagem);
            idBaixa = atoi(sidBaixa);
            idBaixaMensagem = atoi(sidBaixaMensagem);    
			ULOG("idBaixa=[%d]",idBaixa);        
			ULOG("idBaixaMensagem=[%d]",idBaixaMensagem);
        }    
            
        pstDadosAtendimento->idBaixa = idBaixa;
        pstDadosAtendimento->idBaixaMensagem = idBaixaMensagem;            

        pstDadosAtendimento->idTipoRetornoContato = idTipoRetornoContatoST;
        pstDadosAtendimento->idFase = idFase;
        pstDadosAtendimento->idAgrupamentoEstadoTProcAt = idAgrEstadoTProc;

        ULOG("idTipoRetornoContato=[%d]",pstDadosAtendimento->idTipoRetornoContato);        
        ULOG("idFase=[%d]",pstDadosAtendimento->idFase);
        ULOG("idAgrupamentoEstadoTProcAt=[%d]",pstDadosAtendimento->idAgrupamentoEstadoTProcAt);
        
        // recupera a  nmUrlDestino 
        // esta parte do codigo nao pertence a funcao original
        EXEC SQL
        	SELECT  DISTINCT   NMURLDESTINO
            INTO	:nmUrlDestino:i_nmUrlDestino	    
        	FROM    WORKFLOW.FLUXOACOESBKORCV01
        	WHERE   IDATIVIDADE = 10
        	AND     IDFASE = idFase
            AND     ROWNUM < 2;        
                
        // copia o NMURLDESTINO para a estrutura de saida
        endOraStr(nmUrlDestino);
        
        ULOG("nmUrlDestino=%s",pstDadosAtendimento->nmUrlDestino);
        
        strcpy(pstDadosAtendimento->nmUrlDestino,(char *)nmUrlDestino.arr);
        
    }
    else
    {
        ULOG("proCObtemWFDetalheAtendimento()::Processo não encontrado.");
    }

    ULOG_END( "proCObtemWFDetalheAtendimento()" );
    
    

    return sqlca.sqlcode == 0 ? true : false;
}


// ESTES METODO FOI COPIADO DO ATENDIMENTO PARA MANTER A INDEPENDENCIA DE COMPILACAO E MANTERA O MESMO NOME PARA COMPATIBILIDADE  DA REGRA E MODIFICACAO FUTURA
//  bool proCObterTipoRetornoContato(unsigned long _idAtendimento,int *_idUFOperadora,int *_idTipoRetornoContato)     
bool proCObterTipoRetornoContato(unsigned long _idAtendimento,int *_idUFOperadora,int *_idTipoRetornoContato,  int *_idBaixa ,int * _idBaixaMensagem )
{
    ULOG_START("proCObterTipoRetornoContato()");

    struct sqlca sqlca;
    ULOG("_idAtendimento=[%lu]",_idAtendimento);
    EXEC SQL BEGIN DECLARE SECTION;
        // struct VariaveisRetorno variaveisretorno;

        // Estrutura com as variáveis da aba 'retorno' da árvore de contato
        struct VariaveisRetorno
        {
            int idCanal;
            int idContato;
            int idGrupo;
            int idProcedencia;
            int idSegmentacao;
            int idTipoCarteira;
            int idTipoLinha;
            int idTipoPessoa;
            int idTipoRelacionamento;
            int idUFOperadora;
            int idBaixa;
            int idBaixaMensagem;
            
        } variaveisretorno ;

        int *idTipoRetornoContato = _idTipoRetornoContato;
        unsigned long idAtendimento = _idAtendimento;    
        

        short i_idContato;
        short i_idCanal;
        short i_idProcedencia;
        short i_idTipoCarteira;
        short i_idSegmentacao;
        short i_idGrupo;
        short i_idTipoRelacionamento;
        short i_idTipoPessoa;
        short i_idUFOperadora;
        short i_idTipoLinha;
        short i_idTipoRetornoContato;
        short i_idBaixa;
        short i_idBaixaMensagem;


    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error( NULL );
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL 
        SELECT
            NVL(IDCONTATO,-1) AS IDCONTATO,
            NVL(IDCANAL,-1) AS IDCANAL,
            NVL(IDPROCEDENCIA,-1) AS IDPROCEDENCIA,
            NVL(IDTIPOCARTEIRA,-1) AS IDTIPOCARTEIRA,
            NVL(IDSEGMENTACAO,-1) AS IDSEGMENTACAO,
            NVL(IDGRUPOABERTURA,-1) AS IDGRUPOABERTURA,
            NVL(IDTIPORELACIONAMENTO,-1) AS IDTIPORELACIONAMENTO,
            NVL(IDTIPOPESSOA,-1) AS IDTIPOPESSOA,
            NVL(IDUFOPERADORA,-1) AS IDUFOPERADORA,
            NVL(IDTIPOLINHA,-1) AS IDTIPOLINHA
        INTO
            :variaveisretorno.idContato:i_idContato,
            :variaveisretorno.idCanal:i_idCanal,
            :variaveisretorno.idProcedencia:i_idProcedencia,
            :variaveisretorno.idTipoCarteira:i_idTipoCarteira,
            :variaveisretorno.idSegmentacao:i_idSegmentacao,
            :variaveisretorno.idGrupo:i_idGrupo,
            :variaveisretorno.idTipoRelacionamento:i_idTipoRelacionamento,
            :variaveisretorno.idTipoPessoa:i_idTipoPessoa,
            :variaveisretorno.idUFOperadora:i_idUFOperadora,
            :variaveisretorno.idTipoLinha:i_idTipoLinha
        FROM
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        WHERE
            IDATENDIMENTO = :idAtendimento;

    ULOG("idContato=[%d]",variaveisretorno.idContato);
    ULOG("idCanal=[%d]",variaveisretorno.idCanal);
    ULOG("idProcedencia=[%d]",variaveisretorno.idProcedencia);
    ULOG("idTipoCarteira=[%d]",variaveisretorno.idTipoCarteira);
    ULOG("idSegmentacao=[%d]",variaveisretorno.idSegmentacao);
    ULOG("idGrupo=[%d]",variaveisretorno.idGrupo);
    ULOG("idTipoRelacionamento=[%d]",variaveisretorno.idTipoRelacionamento);
    ULOG("idTipoPessoa=[%d]",variaveisretorno.idTipoPessoa);
    ULOG("idUFOperadora=[%d]",variaveisretorno.idUFOperadora);
    ULOG("idTipoLinha=[%d]",variaveisretorno.idTipoLinha);
    
    ULOG(
          " SELECT BAIXAMENSAGEM.IDBAIXA,"
          "        BAIXAMENSAGEM.IDMENSAGEMBAIXA "
          " FROM"
          "        CONTATOADM.CONTATOFOLHABAIXA CONTATOFOLHABAIXA ,"
          "        CONTATOADM.BAIXAMENSAGEM"
          " WHERE "
          " 	   BAIXAMENSAGEM.IDBAIXA = CONTATOFOLHABAIXA.IDBAIXA"
          "   AND BAIXAMENSAGEM.IDFORMARETORNO = 1 "
          "   AND CONTATOFOLHABAIXA.IDCONTATO = %d "
          "   AND ROWNUM <2",variaveisretorno.idContato
         );



    EXEC SQL 
        SELECT BAIXAMENSAGEM.IDBAIXA,
               BAIXAMENSAGEM.IDMENSAGEMBAIXA 
         INTO
              :variaveisretorno.idBaixa:i_idBaixa,
              :variaveisretorno.idBaixaMensagem:i_idBaixaMensagem
        FROM
               CONTATOADM.CONTATOFOLHABAIXA CONTATOFOLHABAIXA ,
               CONTATOADM.BAIXAMENSAGEM
        WHERE 
        	   BAIXAMENSAGEM.IDBAIXA = CONTATOFOLHABAIXA.IDBAIXA
          AND BAIXAMENSAGEM.IDFORMARETORNO = 1                    // RETORNO EM SMS 
          AND CONTATOFOLHABAIXA.IDCONTATO = :variaveisretorno.idContato
          AND ROWNUM <2;
      
    ULOG("idBaixa=[%d]",variaveisretorno.idBaixa);
    ULOG("idBaixaMensagem=[%d]",variaveisretorno.idBaixaMensagem);

    if ( sqlca.sqlcode == 0 )
    {
        // Salva o idUFOperadora encontrado
        *_idUFOperadora = variaveisretorno.idUFOperadora;

        // Se ocorrer erro Oracle de mais de uma linha resultante da query abaixo (too many rows)
        // o erro não é da query e sim da configuração de administração que esta permitindo que 
        // um mesmo grupo de variáveis seja parametrizado para mais de um tipo de retorno de contato
        // para um mesmo contato. Veja se o serviço que faz esta parametrização não esta com falha
        // na consistência deste tipo de configuração repetida.
        //
        // Julho,2006 - Cassio.
        //
        EXEC SQL
            SELECT /*+ NO_CPU_COSTING */
                IDTIPORETORNOCONTATO
            INTO
                :*idTipoRetornoContato:i_idTipoRetornoContato
            FROM 
                ATENDIMENTO.ATDVARIAVEISRETORNOV01
            WHERE
                IDCONTATO            = :variaveisretorno.idContato
            AND IDGRUPO              = :variaveisretorno.idGrupo
            AND IDPROCEDENCIA        = :variaveisretorno.idProcedencia
            AND IDSEGMENTACAO        = :variaveisretorno.idSegmentacao
            AND IDCANAL              = :variaveisretorno.idCanal
            AND IDTIPOCARTEIRA       = :variaveisretorno.idTipoCarteira
            AND IDTIPOLINHA          = :variaveisretorno.idTipoLinha
            AND IDTIPOPESSOA         = :variaveisretorno.idTipoPessoa
            AND IDTIPORELACIONAMENTO = :variaveisretorno.idTipoRelacionamento
            AND IDUFOPERADORA        = :variaveisretorno.idUFOperadora;

        // Esta operação é chamada somente para aqueles processos em que o cliente/usuário/prospect
        // solicitou retorno, assim se o contato estiver configurado para SEM RETORNO é assumido
        // por default RETORNO POR GRUPO BKO.
        // Se o tipo de retorno do contato não for encontrado, o valor default fica
        // RETORNO POR GRUPO BKO.
        // Estas definições se encontram no DES V2.3 para a incidência 3273 de homologação VIVO
        // Julho de 2006, Cassio.

        if ( sqlca.sqlcode == 1403 || *idTipoRetornoContato == TP_RET_SEM_RET_ONLINE )
        {
            ULOG("idTipoRetornoContato=[%d]",*idTipoRetornoContato);
            *idTipoRetornoContato = TP_RET_COM_RET_GRP_BKO;
        }
    }
    else
    {
        ULOGW("resultadoNaoEncontradoSql()");
        *idTipoRetornoContato = -1;
    }


    *_idBaixa = variaveisretorno.idBaixa ;
    *_idBaixaMensagem = variaveisretorno.idBaixaMensagem ;
    
    ULOG_END("proCObterTipoRetornoContato()");

    return true;
}


// ESTES METODO FOI COPIADO DO ATENDIMENTO PARA MANTER A INDEPENDENCIA DE COMPILACAO E MANTERA O MESMO NOME PARA COMPATIBILIDADE  DA REGRA E MODIFICACAO FUTURA
bool proCObterEstadoFuturo(unsigned long _idAtendimento,int *_EstadoFut)
{
    ULOG_START("proCObterEstadoFuturo()");

    struct sqlca sqlca;
    ULOG("_idAtendimento=[%lu]",_idAtendimento);
    EXEC SQL BEGIN DECLARE SECTION;
        // struct VariaveisRetorno variaveisretorno;

        int IDGRUPAMENTOESTADOTPPROCFT;
        short I_IDGRUPAMENTOESTADOTPPROCFT;
        
        unsigned long idAtendimento = _idAtendimento;    

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error( NULL );
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL 
        SELECT DECODE (CONTATOFOLHA.IDTIPOPROCESSO,2, 23,10) AS IDGRUPAMENTOESTADOTPPROCFT
          INTO :IDGRUPAMENTOESTADOTPPROCFT:I_IDGRUPAMENTOESTADOTPPROCFT
          FROM CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
               ATENDIMENTO.ATENDIMENTO ATENDIMENTO
         WHERE ATENDIMENTO.IDCONTATO = CONTATOFOLHA.IDCONTATO
           AND ATENDIMENTO.IDATENDIMENTO = :idAtendimento;
    
    ULOG("IDGRUPAMENTOESTADOTPPROCFT=[%d]",IDGRUPAMENTOESTADOTPPROCFT);


    if ( sqlca.sqlcode == 0 )
    {
        // Salva o idUFOperadora encontrado
        *_EstadoFut = IDGRUPAMENTOESTADOTPPROCFT;
    }
    else
    {
        ULOGE("ERRO *_EstadoFut = 10;");
        *_EstadoFut = 10;
    }

    ULOG_END("proCObterEstadoFuturo()");

    return true;
}


int get_Parametro(char *_cdParametro ,char *_dsValorParametro)
{
    
  ULOG_START("int get_Parametro()");
  ULOG("_cdParametro = [%s]",_cdParametro);

  
  EXEC SQL BEGIN DECLARE SECTION;
  VARCHAR iValor[256]; 
  VARCHAR cdParametro[256];
 
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);

  try
  {
    
   
    strToOra(cdParametro,_cdParametro);     
    // Definicao dos cursores  
    EXEC SQL SELECT DSVALORPARAMETRO
			  INTO  :iValor 
			   FROM apoio.parametro
			  WHERE CDPARAMETRO=:cdParametro
			    AND ROWNUM=1;
  
          
    endOraStr(iValor);
    ULOG("iValor = [%s]",(char*)iValor.arr);
	strcpy(_dsValorParametro,(char*)iValor.arr);
    
  }
  catch(...)
  {
		throw;
  }
  ULOG_END("get_Parametro()");
  return 1;
}


int get_idBiaxaMensagem(char *_idBaixa, char *_idBaixaMensagem)
{
  ULOG_START("get_idBiaxaMensagem()");
  ULOG("_idBaixa = [%s]",_idBaixa);
  
  EXEC SQL BEGIN DECLARE SECTION;
  VARCHAR idMensagemBaixa[256]; 
  VARCHAR idBaica[256];
  short i_idMensagemBaixa=-1; 
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);

  try
  {
   
    strToOra(idBaica,_idBaixa);
    ULOG(
          " SELECT "
          "        BAIXAMENSAGEM.IDMENSAGEMBAIXA "
          " FROM"
          "        CONTATOADM.BAIXAMENSAGEM"
          " WHERE "
          " 	   BAIXAMENSAGEM.IDBAIXA = %s "
          "   AND BAIXAMENSAGEM.IDFORMARETORNO = 1 "
          "   AND ROWNUM <2",_idBaixa
         );

    
   
         
    // Definicao dos cursores  
    EXEC SQL 
       SELECT 
               BAIXAMENSAGEM.IDMENSAGEMBAIXA 
         INTO
              :idMensagemBaixa:i_idMensagemBaixa
        FROM
               CONTATOADM.BAIXAMENSAGEM
        WHERE 
        	  BAIXAMENSAGEM.IDBAIXA = :idBaica
          AND BAIXAMENSAGEM.IDFORMARETORNO = 1     
          AND ROWNUM <2;
          
    endOraStr(idMensagemBaixa);
    ULOG("idMensagemBaixa = [%s]",(char*)idMensagemBaixa.arr);
	strcpy(_idBaixaMensagem,(char*)idMensagemBaixa.arr);
  }
  catch(...)
  {
		throw;
  }
  ULOG_END("get_idBiaxaMensagem()");
  return 1;
}
    
