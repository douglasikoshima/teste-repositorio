
#include "../../negocio/fidutil/include/retencao.hpp"
#include <string>

using namespace std;


struct RegistroChip
{
	int  idChip;
    int  idAreaRegistro;
    char chipAvulso[61];
    char chipPre[61];
    char vlrChipAvulso[32];
    char vlrChipPre[32];
    int  flgIncluir;
    int  idUsuario;
};

// Prototipos
void VerificaBase( RegistroChip * pRegChip );
void InsereBase( RegistroChip * pRegChip );
void AtualizaBase( RegistroChip * pRegChip );
void ValidaCodigoSAP( int idCodigoArea, char * parm );
void ObtemIDArea( RegistroChip * pRegChip );

int ins_chip( int usuario, DOMNode *dnode, XMLGen *xml )
{
    ULOG_START( "ins_chip()" );

    char parm[256];
    char bf[33];
    int i;
    int k;
    memset (bf,0x0,sizeof(bf));
    RegistroChip pRegChip;


    EXEC SQL BEGIN DECLARE SECTION;
        int  idChipExcluir = -1;
        int cdDDD = -1;
        int  existeBase    = 0;
        int  idUsuario     = usuario;
        int  idAreaRegistro = -1;
        char Manut[2];

        VARCHAR cdChipAvulso[61];
        VARCHAR cdChipPreProgramado[61];
        VARCHAR vlrChipAvulso[33];
        VARCHAR vlrChipPre[33];
    EXEC SQL END DECLARE SECTION;

    memset( parm                 , 0x0, sizeof(parm) );
    memset( &cdChipAvulso        , 0x0, sizeof(cdChipAvulso) );
    memset( &cdChipPreProgramado , 0x0, sizeof(cdChipPreProgramado) );
    memset( &vlrChipAvulso       , 0x0, sizeof(vlrChipAvulso) );
    memset( &vlrChipPre          , 0x0, sizeof(vlrChipPre) );
    memset( &pRegChip            , 0x0, sizeof(pRegChip) );
    memset( Manut                , 0x0, sizeof(Manut) );
    
    EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);

    try
    {
        pRegChip.idUsuario = usuario;

        //  Obtendo dados do xml    
        get_tag( parm,dnode,"idChipExcluir",0,-1 );
        if ( parm[0] != NULL )
        {
            idChipExcluir = atoi(parm);
            EXEC SQL
            DELETE FROM RETENCAO.CHIP WHERE IDCHIP = :idChipExcluir;

            ULOG("Processamento OK\n");
            xml->addItem("descricao","INSERIDO");
            ULOG_END( "ins_chip()" );
            return 1;
        }


        get_tag( parm,dnode,"idChip",0,-1 );
        if ( parm[0] != NULL )
        {
        	pRegChip.idChip = atoi( parm );  // Nao deve executar VerificaBase();
            ObtemIDArea( &pRegChip );
            //idAreaRegistro = pRegChip.idAreaRegistro;
        }
        
        get_tag( parm,dnode,"idDDD",0,-1 );
        if ( parm[0] != NULL )
        {
            cdDDD = atoi(parm);
            EXEC SQL
            SELECT
               IDAREAREGISTRO
            INTO
               :idAreaRegistro
            FROM
               APOIO.AREAREGISTRO
            WHERE
               CDAREAREGISTRO = :cdDDD;
            pRegChip.idAreaRegistro = idAreaRegistro;
            //idAreaRegistro = pRegChip.idAreaRegistro;
        }

        parm[0] = 0x0;
        get_tag( parm,dnode,"cdChipAvulsoSAP",0,-1 );
        if ( parm[0] != NULL )
        {
            strcpy( pRegChip.chipAvulso,parm );
		}
		
        parm[0] = 0x0;
        get_tag( parm,dnode,"cdChipPreProgSAP",0,-1 );
        if ( parm[0] != NULL )
        {
            strcpy( pRegChip.chipPre,parm );
		}

        if ( pRegChip.idChip == 0 )  // Deve incluir na base
        	VerificaBase( &pRegChip );

        parm[0] = 0x0;
        get_tag( parm,dnode,"vlChipAvulsoSAP",0,-1 );
        /*----- ATEH A PROXIMA CFG DO BANCO ---  March 25, 2010
        if ( parm[0] != NULL )
        {
            for ( i=0;i<33;i++)
            {
                if ( parm[i] == 0x0)
                   break;
                if (parm[i] == ',')
                   parm[i] = '.';
                bf[i] = parm[i];
            }
            ULOG( "Valor Avulso [%s]",bf );
            strcpy( pRegChip.vlrChipAvulso,bf );
        }
        */
        
        int len;
        
        if ( parm[0] != NULL )
        {
            len = strlen(parm);
            for ( k=i=0;i<len;i++)
            {
                if ( parm[i] == '.' )
                   continue;
                if ( parm[i] == ',' )
                {
                   parm[i] = '.';
                }
                bf[k] = parm[i];
                k++;
            }
            ULOG( "Valor Avulso [%s]",bf );
            strcpy( pRegChip.vlrChipAvulso,bf );
        }

        parm[0] = 0x0;
        memset( bf, 0x0, sizeof(bf) );
        get_tag( parm,dnode,"vlChipPreProgSAP",0,-1 );
        /*----- ATEH A PROXIMA CFG DO BANCO ---  March 25, 2010
        if ( parm[0] != NULL )
        {
            for ( i=0;i<33;i++)
            {
                if ( parm[i] == 0x0)
                   break;
                if (parm[i] == ',')
                   parm[i] = '.';
                bf[i] = parm[i];
            }
            ULOG( "Valor Pre-Prog [%s]",bf );
            strcpy( pRegChip.vlrChipPre,bf );
        }
        */
        if ( parm[0] != NULL )
        {
            len = strlen(parm);
            for ( k=i=0;i<len;i++)
            {
                if ( parm[i] == '.' )
                   continue;
                if ( parm[i] == ',' )
                {
                   parm[i] = '.';
                }
                bf[k] = parm[i];
                k++;
            }
            ULOG( "Valor Pre-Prog [%s]",bf );
            strcpy( pRegChip.vlrChipPre,bf );
        }
        
        if ( pRegChip.flgIncluir == 0 )
        {
            //VerificaBase( &pRegChip );
            AtualizaBase( &pRegChip );
            Manut[0] = '2';   // Alteracao
        }
        else
        {
            InsereBase( &pRegChip );
            Manut[0] = '1';   // Inclusao
        }
        
        
        if ( pRegChip.chipAvulso[0] != NULL )
        {
            strToOra( cdChipAvulso,pRegChip.chipAvulso );
            ULOG( "Codigo de CHIP Avulso [%s]", pRegChip.chipAvulso );
        }


        if ( pRegChip.chipPre[0] != NULL )
        {
            strToOra( cdChipPreProgramado,pRegChip.chipPre );
            ULOG( "Codigo de CHIP Pré-Programado [%s]", pRegChip.chipPre );
        }
          
        ULOG("Processamento OK\n");
        xml->addItem("descricao","INSERIDO");

      }
      catch(...)
      {
            throw;
      }

    ULOG_END( "ins_chip()" );

    return 1;
}



void AtualizaBase( RegistroChip * pRegChip )
{
    ULOG_START( "AtualizaBase()" );

    string dynstmt;
    char buffer[256];
    int  flgSeparador = 0;
    
    memset( buffer, 0x0, sizeof(buffer) );
    EXEC SQL BEGIN DECLARE SECTION;

        char * query;
        int idChip = pRegChip->idChip;
        int idAreaRegistro = pRegChip->idAreaRegistro;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error( NULL );
    
    dynstmt = 
        "UPDATE "
            "RETENCAO.CHIP "
        "SET ";
    
    sprintf( buffer, "IDAREAREGISTRO = %d ", idAreaRegistro );
    dynstmt += buffer;
    
    if ( pRegChip->chipAvulso[0] != NULL )
    {
        sprintf( buffer, ",CDSAPCHIPAVULSO = '%s' ", pRegChip->chipAvulso );
        dynstmt += buffer;
        flgSeparador = 1;
    }

    if ( pRegChip->chipPre[0] != NULL )
    {
        if ( flgSeparador == 1 )
            sprintf( buffer, ",CDSAPCHIPPREPROGRAMADO = '%s' ", pRegChip->chipPre );
        else
            sprintf( buffer, "CDSAPCHIPPREPROGRAMADO = '%s' ", pRegChip->chipPre );

        dynstmt += buffer;
        flgSeparador = 1;
    }
    else
        flgSeparador = 0;

    if ( pRegChip->vlrChipAvulso[0] != NULL )
    {
        if ( flgSeparador == 1 )
            sprintf( buffer, ",VLCHIPAVULSO = '%s' ", pRegChip->vlrChipAvulso );
        else
            sprintf( buffer, "VLCHIPAVULSO = '%s' ", pRegChip->vlrChipAvulso );

        dynstmt += buffer;
        flgSeparador = 1;
    }
    else
        flgSeparador = 0;

    
    if ( pRegChip->vlrChipPre[0] != NULL )
    {
        if ( flgSeparador == 1 )
            sprintf( buffer, ",VLCHIPPREPROGRAMADO = '%s' ", pRegChip->vlrChipPre );
        else
            sprintf( buffer, "VLCHIPPREPROGRAMADO = '%s' ", pRegChip->vlrChipPre );

        dynstmt += buffer;
        flgSeparador = 1;
    }
    else
        flgSeparador = 0;

    dynstmt += "WHERE IDCHIP = ";

    sprintf( buffer, "%d", idChip );
    dynstmt += buffer;

    query = (char *)dynstmt.c_str();

    ULOG( "Executando [%s]", query );

    EXEC SQL EXECUTE IMMEDIATE :query;

    ULOG_END( "AtualizaBase()" );

}



void InsereBase( RegistroChip * pRegChip )
{
    ULOG_START( "InsereBase()" );

    string dynstmt;
    char buffer[256];
    int  flgSeparador = 0;
    
    memset( buffer, 0x0, sizeof(buffer) );
    EXEC SQL BEGIN DECLARE SECTION;

        char * query;

    EXEC SQL END DECLARE SECTION;


    EXEC SQL WHENEVER SQLERROR DO sql_error( NULL );

    dynstmt = 
        "INSERT INTO RETENCAO.CHIP "
        "( IDCHIP,";
    
    if ( pRegChip->chipAvulso[0] != NULL )
    {
        dynstmt += "CDSAPCHIPAVULSO, VLCHIPAVULSO, ";
    }    
    if ( pRegChip->chipPre[0] != NULL )
    {
        dynstmt += "CDSAPCHIPPREPROGRAMADO, VLCHIPPREPROGRAMADO, ";
    }        
        
       
    dynstmt += 
    "IDAREAREGISTRO, IDUSUARIOALTERAAO, DTULTIMAALTERACAO ) "
    "VALUES ( RETENCAO.CHIPSQ.nextval,";
    
    if ( pRegChip->chipAvulso[0] != NULL )
    {
        sprintf( buffer, " '%s', ",pRegChip->chipAvulso );
        dynstmt += buffer;
        sprintf( buffer, " '%s', ",pRegChip->vlrChipAvulso );
        dynstmt += buffer;
    }
    if ( pRegChip->chipPre[0] != NULL )
    {
        sprintf( buffer, " '%s', ",pRegChip->chipPre );
        dynstmt += buffer;
        sprintf( buffer, " '%s', ",pRegChip->vlrChipPre );
        dynstmt += buffer;
    }
    
    sprintf( buffer, " %d ,",pRegChip->idAreaRegistro );
    dynstmt += buffer;
    sprintf( buffer, " %d ,",pRegChip->idUsuario );
    dynstmt += buffer;
    strcpy( buffer, " SYSDATE )" );
    dynstmt += buffer;

    query = (char *)dynstmt.c_str();

    ULOG( "Executando [%s]", query );

    EXEC SQL EXECUTE IMMEDIATE :query;

    ULOG_END( "InsereBase()" );

}



void VerificaBase( RegistroChip * pRegChip )
{
    ULOG_START( "VerificaBase()" );

    EXEC SQL BEGIN DECLARE SECTION;

        int  idAreaRegistro = pRegChip->idAreaRegistro;

        VARCHAR ChipAvulso[61];
        VARCHAR ChipPre[61];
        VARCHAR vlrChipAvulso[32];
        VARCHAR vlrChipPre[32];

        short i_ChipAvulso = -1;
        short i_ChipPre = -1;
        short i_vlrChipAvulso = -1;
        short i_vlrChipPre = -1;

    EXEC SQL END DECLARE SECTION;

    memset( &ChipAvulso    , 0x0, sizeof(ChipAvulso) );
    memset( &ChipPre       , 0x0, sizeof(ChipPre) );
    memset( &vlrChipAvulso , 0x0, sizeof(vlrChipAvulso) );
    memset( &vlrChipPre    , 0x0, sizeof(vlrChipPre) );

    EXEC SQL WHENEVER SQLERROR DO sql_error( NULL );
    EXEC SQL 
    SELECT 
        CDSAPCHIPAVULSO,
        CDSAPCHIPPREPROGRAMADO           
    INTO
        :ChipAvulso:i_ChipAvulso,
        :ChipPre:i_ChipPre            
    FROM
        RETENCAO.CHIP
    WHERE
        IDAREAREGISTRO = :idAreaRegistro
    AND
        ROWNUM < 2;

    // Encontrou Registro na base
    if ( i_ChipAvulso != -1 || i_ChipPre != -1 )  
    {
    	int flgNaoAtualizar = 0;  // Usado para identificar chips na base
    	
        if ( i_ChipAvulso != -1 )
            endOraStr(ChipAvulso);
        if ( i_ChipPre != -1 )
            endOraStr(ChipPre);

        if ( pRegChip->chipAvulso[0] != NULL )
        {
            if ( i_ChipAvulso != -1 )
            {
                if( strcmp(pRegChip->chipAvulso,(char *)ChipAvulso.arr) == 0 )
                {
                    throw new TuxBasicSvcException( NOKFID,"CHIP avulso para este DDD já está cadastrado" );
                }
                else
                {
                	flgNaoAtualizar++;  // Primeiro chip identificado
                }
            }
        }
        if ( pRegChip->chipPre[0] != NULL )
        {
            if ( i_ChipPre != -1 )
            {
                if( strcmp(pRegChip->chipPre,(char *)ChipPre.arr) == 0 )
                {
                    throw new TuxBasicSvcException( NOKFID,"CHIP pré-programado para este DDD já está cadastrado" );
                }
                else
                {
                	flgNaoAtualizar++;  // Segundo chip identificado, ou seja, deve emitir mensagem de erro.
                }
            }
        }

        if ( flgNaoAtualizar == 2 )
        {
            throw new TuxBasicSvcException( NOKFID,"Já existem CHIPs cadastrados com este código" );
        }
        
        pRegChip->flgIncluir = 0;   // Jah existe um chip gravado, sera atualizado para dois chips
    }
    else
        pRegChip->flgIncluir = 1;  // Registro deverah ser incluido

    ULOG_END( "VerificaBase()" );

}



void ValidaCodigoSAP( int idCodigoAreaPrm, char * parm )
{
    ULOG_START( "ValidaCodigoSAP()" );

    char sMsg[512];
    char bfCompare[3];
    char sDDD[3];
    int pos = -1;

    EXEC SQL BEGIN DECLARE SECTION;
        int idCodigoArea = idCodigoAreaPrm;
        int ddd = -1; 
        short i_ddd = -1;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);
    EXEC SQL 
    SELECT 
        CDAREAREGISTRO
    INTO
       :ddd:i_ddd
    FROM
        APOIO.AREAREGISTRO
    WHERE
        IDAREAREGISTRO = :idCodigoArea
    AND
        ROWNUM < 2;

    memset( sMsg, 0x0, sizeof(sMsg) );
    memset( sDDD, 0x0, sizeof(sDDD) );
    memset( bfCompare, 0x0, sizeof(bfCompare) );

    ULOG( "Validando código SAP [%s]",parm );

    if ( parm[1] != 'G' )    // Verifica se realmente trata de código de CHIP
    {
        sprintf( sMsg,"Código: %s - Inválido para cadastro de CHIP",parm );
        throw new TuxBasicSvcException( NOKFID,sMsg );
    }

    ULOG_END( "ValidaCodigoSAP()" );
}



void ObtemIDArea( RegistroChip * pRegChip )
{
    ULOG_START( "ObtemIDArea()" );

    EXEC SQL BEGIN DECLARE SECTION;
        int idEstoqueChip = pRegChip->idChip;
        int idAreaRegistro = -1;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);
    EXEC SQL 
    SELECT 
        IDAREAREGISTRO 
    INTO 
        :idAreaRegistro 
    FROM 
        RETENCAO.CHIP 
    WHERE 
        IDCHIP = :idEstoqueChip
    AND
        ROWNUM < 2;

    pRegChip->idAreaRegistro = idAreaRegistro;
    pRegChip->flgIncluir = 0;  // Executar UPDATE

    ULOG( "Obteve IDAREAREGISTRO [%d]", pRegChip->idAreaRegistro );

    ULOG_END( "ObtemIDArea()" );
}
