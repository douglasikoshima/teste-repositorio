//
// $Id: ins_mtoferta.pcpp,v 1.1 2009/07/31 15:34:16 a5110702 Exp $
//

#include "../../negocio/fidutil/include/retencao.hpp"
#include <string>
#include <list>
#define NRO_MAX_REG 2000

using namespace std;

typedef list<int> LISTA_OFERTAS;

EXEC SQL BEGIN DECLARE SECTION;
   #define  NRO_MAX_REG_ORA     450
EXEC SQL END DECLARE SECTION;

struct stRegistro
{
   int idPessoaUsuarioInclusao;
   int idUfOperadora;
   int idTipoPessoa;
   int idSegmentacao;
   int idRespostaIntencao;
   int idRespostaDestino;
   int idGrupo;
   int inFidelizacao;
};



// Prototipos
void InsertOfertas( stRegistro * pRegistro, LISTA_OFERTAS * pOfertaINS );
void UpdateOfertas( stRegistro * pRegistro, LISTA_OFERTAS * pOfertaUPD );

void AtualizaOfertas( int idOfertaPrm[], int qtOfertas, stRegistro *  );
void AtualizaDestino( stRegistro * pRegistro, 
                      int qtSegmentacao, 
                      int qtRespDestino, 
                      int idSegmParam[], 
                      int idRespDestino[] );

void OrganizaMatrizOferta( stRegistro * pRegistro, 
                           int qtSegmentacao, 
                           int qtRespDestino, 
                           int idSegmParam[], 
                           int idRespDestino[] );

void Fideliza( stRegistro * pRegistro, 
                           int qtSegmentacao, 
                           int qtRespDestino,
                           int qtOfertas, 
                           int idSegmParam[], 
                           int idRespDestino[],
                           int idOfertas[] );

int ins_mtoferta( int usuario, DOMNode * dnode, XMLGen * xml )
{
   char parm[255];
   int i = 0;

   int idSegmentacaoArr[NRO_MAX_REG];    
   int idRespostaDestinoArr[NRO_MAX_REG];
   int idOfertaArr[NRO_MAX_REG];
   int iOferta;
  
   
   stRegistro pRegistro;

  
  //variaveis de controle de manipulação do dom
  int idnSegmentacao=0;
  int idnDestino=0;
  int inFidelizacao=0;


  int qtSegmentacao=0;
  int qtDestino=0;
  int qtOfertas=0;

  DOMNode* dnSegmentacao=NULL;
  DOMNode* dnDestino=NULL;
   
  TuxHelper txh;

  EXEC SQL BEGIN DECLARE SECTION;
   
     int iFid=0;
 
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);

  try
  {
      //  Obtendo dados do xml
      get_tag(parm,dnode,"idUfOperadora",0,0);
      pRegistro.idUfOperadora = atoi(parm);

      // Pegando id do usuario
      pRegistro.idPessoaUsuarioInclusao = usuario;
      
      get_tag(parm,dnode,"idTipoPessoa",0,0);
      pRegistro.idTipoPessoa = atoi(parm);
      
      get_tag(parm,dnode,"idIntencao",0,0);
      pRegistro.idRespostaIntencao = atoi(parm);
      
      get_tag(parm,dnode,"idGrupo",0,0);
      pRegistro.idGrupo = atoi(parm);
      
      get_tag(parm,dnode,"inFidelizacao",0,0);
      pRegistro.inFidelizacao = atoi(parm);
      
      //gera um dom a partir do no segmentacao do xml in
      dnSegmentacao = txh.walkDOM(dnode, "segmentacao", 0);
      
      //gera um dom a partir do no destino do xml in
      dnDestino   = txh.walkDOM(dnode, "destinoprevisto", 0);
      
      get_tag(parm,dnode,"qtSegmentacao",0,0);
      qtSegmentacao = atoi(parm);
      get_tag(parm,dnode,"qtDestino",0,0);
      qtDestino = atoi(parm);
      get_tag(parm,dnode,"qtOfertas",0,0);
      qtOfertas = atoi(parm);

      idnSegmentacao = 0;
      while(get_tag(parm,dnSegmentacao,"idSegmentacao",idnSegmentacao,-1)!=-1)
      {
         idSegmentacaoArr[idnSegmentacao] = atoi(parm);
         idnSegmentacao++;
      }

      idnDestino=0;
      while(get_tag(parm,dnDestino,"idDestino",idnDestino,-1)!=-1)
      {
         idRespostaDestinoArr[idnDestino] = atoi(parm);
         idnDestino++;
      }

      iOferta=0;
      while( get_tag(parm,dnode,"idOferta",iOferta,-1) != -1 )
      {
         idOfertaArr[iOferta] = atoi(parm);
         ULOG("update para 1");  
         iOferta++;
      }

      //operação para apagar todos as matrizes do banco
      //para aquela idUfOperadora,idTipoPessoa,idIntencao,
      //segmentacao,destinoprevisto especifico
      //Parece que para performance é mais rápido
      //apagar tudo e inserir novamente
      if ( ( qtDestino == 1 && qtSegmentacao == 1 ) || (( qtDestino > 1 || qtSegmentacao > 1 ) && qtOfertas == 0 ))
      {
         ULOG("Toco fogo em tudo!!!"); 
         AtualizaDestino( &pRegistro,
                          qtSegmentacao,
                          qtDestino,
                          idSegmentacaoArr,
                          idRespostaDestinoArr );
      }
      else
      {
         ULOG("Não toco fogo..!!"); 
      }

      if ( iOferta > 0 )
      {
            OrganizaMatrizOferta( &pRegistro, 
                                  qtSegmentacao,
                                  qtDestino,
                                  idSegmentacaoArr,
                                  idRespostaDestinoArr );

            for ( int a = 0; a < qtSegmentacao; a++ )
            {
               pRegistro.idSegmentacao = idSegmentacaoArr[a];
               for ( int b = 0; b < qtDestino; b++ )
               {
                  pRegistro.idRespostaDestino = idRespostaDestinoArr[b];
                  AtualizaOfertas( idOfertaArr, iOferta, &pRegistro );
               }
            }

            if( pRegistro.inFidelizacao > 0 )
            {
               Fideliza( &pRegistro, 
                       qtSegmentacao, 
                       qtDestino,
                       iOferta, 
                       idSegmentacaoArr, 
                       idRespostaDestinoArr,
                       idOfertaArr );
            }
      }
         
      ULOG_INT(idnDestino);
      ULOG_INT(idnSegmentacao);

      //Insert OK
      xml->addItem("descricao","INSERIDO");
      xml->addItem("valor",idnDestino);
   }
   catch(...)
   {
      throw;
   }

   return 1;
}




void AtualizaOfertas( int idOfertaPrm[], int qtOfertas, stRegistro * pRegistro )
{
    ULOG_START( "AtualizaOfertas()" );
    
    LISTA_OFERTAS pOfertaUPD;
    LISTA_OFERTAS pOfertaINS;
    
    EXEC SQL BEGIN DECLARE SECTION;
   
/*
      int idOferta[NRO_MAX_REG_ORA];
      int idUsuario[NRO_MAX_REG_ORA];
      int idUFOperadora[NRO_MAX_REG_ORA];
      int idTipoPessoa[NRO_MAX_REG_ORA];
      int idSegmentacao[NRO_MAX_REG_ORA];
      int idRespostaIntencao[NRO_MAX_REG_ORA];
      int idRespostaDestino[NRO_MAX_REG_ORA];
      int idGrupo[NRO_MAX_REG_ORA];
      int inAtivo[NRO_MAX_REG_ORA];
*/
      
      int idOferta;
      
      int   idOfertaTmp;
      short i_idOfertaTmp;
      
      int idUsuario;
      int idUFOperadora;
      int idTipoPessoa;
      int idSegmentacao;
      int idRespostaIntencao;
      int idRespostaDestino;
      int idGrupo;
      int inAtivo;

      int encontrou = -1;

      int idMatrizOferta = -1;
      int idOfertaSingle = -1;
      int idUFOperadoraSingle = -1;
      int idTipoPessoaSingle = -1;
      int idSegmentacaoSingle = -1;
      int idRespostaIntencaoSingle =-1;
      int idRespostaDestinoSingle = -1;
      int idGrupoSingle = -1;
      
      int inAtivoAux;
      int idPessoaUsuarioAlteracaoAux;
      VARCHAR dtAlteracaoAux[64];
      int idUsuarioAlteracaoAux;
      VARCHAR dtUltimaAlteracaoAux[64];
      
      
    EXEC SQL END DECLARE SECTION;

// ---> Para uso de BULK COLLECTION
//    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);

/* ---> Para uso com BULK COLLECTION
    memset( (void *)idOferta,0,sizeof(idOferta));
    memset( (void *)idUsuario,0,sizeof(idUsuario));
    memset( (void *)idUFOperadora,0,sizeof(idUFOperadora));
    memset( (void *)idTipoPessoa,0,sizeof(idTipoPessoa));
    memset( (void *)idSegmentacao,0,sizeof(idSegmentacao));
    memset( (void *)idRespostaIntencao,0,sizeof(idRespostaIntencao));
    memset( (void *)idRespostaDestino,0,sizeof(idRespostaDestino));
    memset( (void *)idGrupo,0,sizeof(idGrupo));
*/    
    if ( pRegistro == 0 )
    {
        ULOG( "ponteiro 'pRegistro' invalido" ); //@cassio
        return;
    }
   
    ULOG( "Quantidade de Ofertas [%d]",qtOfertas );
    ULOG( "idUsuario [%d], idUFOperadora [%d], idTipoPessoa [%d], idSegmentacao [%d], idRespostaIntencao [%d], idRespostaDestino [%d], idGrupo [%d]"
          ,pRegistro->idPessoaUsuarioInclusao
          ,pRegistro->idUfOperadora
          ,pRegistro->idTipoPessoa
          ,pRegistro->idSegmentacao
          ,pRegistro->idRespostaIntencao
          ,pRegistro->idRespostaDestino
          ,pRegistro->idGrupo
       );

/*
 *  ---> Para uso de BULK COLLECTION
 *
   int i,k;
   for ( i = k = 0; i < qtOfertas; i++ )
   {
      if ( k == NRO_MAX_REG_ORA ) // Insere bloco maximo de ocorrencias no Oracle
      {
         k = 0;
         EXEC SQL 
            INSERT INTO RETENCAO.MATRIZOFERTA
            (
               IDMATRIZOFERTA,
               IDUFOPERADORA, 
               IDTIPOPESSOA, 
               IDSEGMENTACAO,
               IDRESPOSTAINTENCAO,
               IDRESPOSTADESTINO,
               DTINICIOVIGENCIA,
               IDPESSOAUSUARIOINCLUSAO,
               DTINCLUSAO,
               IDPESSOAUSUARIOALTERACAO,
               DTALTERACAO,
               IDUSUARIOALTERACAO,
               DTULTIMAALTERACAO,
               IDOFERTA,
               INATIVO,
               IDGRUPO
            )
            VALUES 
            (
               retencao.MatrizOfertaSQ.nextval,
               :idUFOperadora, 
               :idTipoPessoa,
               :idSegmentacao,
               :idRespostaIntencao,
               :idRespostaDestino,
               SYSDATE,
               :idUsuario, 
               SYSDATE,      
               :idUsuario, 
               SYSDATE,      
               :idUsuario, 
               SYSDATE,
               :idOferta,
               :inAtivo,
               :idGrupo
            );
      }
      idOferta[k] = idOfertaPrm[i];
      idUsuario[k] = pRegistro->idPessoaUsuarioInclusao;
      idUFOperadora[k] = pRegistro->idUfOperadora;
      idTipoPessoa[k] = pRegistro->idTipoPessoa;
      idSegmentacao[k] = pRegistro->idSegmentacao;
      idRespostaIntencao[k] = pRegistro->idRespostaIntencao;
      idRespostaDestino[k] = pRegistro->idRespostaDestino;
      inAtivo[k] = 1;
      idGrupo[k] = pRegistro->idGrupo;
      k++; // Bloco de NRO_MAX_REG_ORA Ocorrencias para insert em BLOCO no Oracle
   }
*/

    idUsuario = pRegistro->idPessoaUsuarioInclusao;
    idUFOperadora = pRegistro->idUfOperadora;
    idTipoPessoa = pRegistro->idTipoPessoa;
    idSegmentacao = pRegistro->idSegmentacao;
    idRespostaIntencao = pRegistro->idRespostaIntencao;
    idRespostaDestino = pRegistro->idRespostaDestino;
    inAtivo = 1;
    idGrupo = pRegistro->idGrupo;

    for ( int i = 0; i < qtOfertas; i++ )
    {
        idOferta = idOfertaPrm[i];
        idOfertaTmp = 0;
        
        EXEC SQL
              SELECT
                 IDOFERTA
			  INTO
			     :idOfertaTmp:i_idOfertaTmp
			  FROM
                 RETENCAO.MATRIZOFERTA
			  WHERE 
			     IDUFOPERADORA = :idUFOperadora
			  AND   
			     IDTIPOPESSOA = :idTipoPessoa
			  AND   
			     IDSEGMENTACAO = :idSegmentacao
			  AND   
			     IDRESPOSTAINTENCAO = :idRespostaIntencao
			  AND   
			     IDRESPOSTADESTINO = :idRespostaDestino
			  AND	
			     IDGRUPO = :idGrupo
			  AND   
			     IDOFERTA = :idOferta;
		
		 if ( idOfertaTmp > 0 )
		 {
		    ULOG( "Update em oferta %d",idOfertaTmp );
            pOfertaUPD.push_back( idOfertaTmp );		        
		 }
		 else
  	     {
		    ULOG( "Insert em oferta %d",idOferta );
            pOfertaINS.push_back( idOferta );		        
	     }
			        

   }
   pOfertaUPD.sort();
   pOfertaUPD.unique();
   
   pOfertaINS.sort();
   pOfertaINS.unique();

    if ( pOfertaUPD.size() > 0 )
        UpdateOfertas( pRegistro, &pOfertaUPD );

    if ( pOfertaINS.size() > 0 )
        InsertOfertas( pRegistro, &pOfertaINS );

   ULOG_END( "AtualizaOfertas()" );
}




void UpdateOfertas( stRegistro * pRegistro, LISTA_OFERTAS * pOfertaUPD )
{
    ULOG_START( "UpdateOfertas()" );
    list<int>::iterator it;

    EXEC SQL BEGIN DECLARE SECTION;
   
      int idOferta[NRO_MAX_REG_ORA];
      int idUsuario[NRO_MAX_REG_ORA];
      int idUFOperadora[NRO_MAX_REG_ORA];
      int idTipoPessoa[NRO_MAX_REG_ORA];
      int idSegmentacao[NRO_MAX_REG_ORA];
      int idRespostaIntencao[NRO_MAX_REG_ORA];
      int idRespostaDestino[NRO_MAX_REG_ORA];
      int idGrupo[NRO_MAX_REG_ORA];
      int inAtivo[NRO_MAX_REG_ORA];
      
      int linhas = 0;

    EXEC SQL END DECLARE SECTION;
//    EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);
    EXEC SQL WHENEVER SQLERROR CONTINUE;

    
    memset( (void *)idOferta,0,sizeof(idOferta));
    memset( (void *)idUsuario,0,sizeof(idUsuario));
    memset( (void *)idUFOperadora,0,sizeof(idUFOperadora));
    memset( (void *)idTipoPessoa,0,sizeof(idTipoPessoa));
    memset( (void *)idSegmentacao,0,sizeof(idSegmentacao));
    memset( (void *)idRespostaIntencao,0,sizeof(idRespostaIntencao));
    memset( (void *)idRespostaDestino,0,sizeof(idRespostaDestino));
    memset( (void *)idGrupo,0,sizeof(idGrupo));

    if ( pRegistro == 0 )
    {
        ULOG( "ponteiro 'pRegistro' invalido" ); //@cassio
        return;
    }

    ULOG( "Vai atualizar RETENCAO.MATRIZOFERTA..." );        

    int k = 0;
    for( it = pOfertaUPD->begin(); it != pOfertaUPD->end(); it++ )
    {
        linhas++;
        if ( k == NRO_MAX_REG_ORA ) // Insere bloco maximo de ocorrencias no Oracle
        {
            k = 0;
            linhas = NRO_MAX_REG_ORA;
            ULOG( "BLOCANDO: Atualizando %d linhas", linhas );
            EXEC SQL FOR :linhas
                UPDATE
                    RETENCAO.MATRIZOFERTA
                SET
                    INATIVO = 1,
                    IDPESSOAUSUARIOALTERACAO = :idUsuario,
                    DTALTERACAO = SYSDATE,
                    IDUSUARIOALTERACAO = :idUsuario,
                    DTULTIMAALTERACAO = SYSDATE
                WHERE 
                    IDUFOPERADORA = :idUFOperadora
                AND   
                    IDTIPOPESSOA = :idTipoPessoa
                AND   
                    IDSEGMENTACAO = :idSegmentacao
                AND   
                    IDRESPOSTAINTENCAO = :idRespostaIntencao
                AND   
                    IDRESPOSTADESTINO = :idRespostaDestino
                AND	
                    IDGRUPO = :idGrupo
                AND   
                    IDOFERTA = :idOferta;
        
            if (sqlca.sqlcode < 0 && sqlca.sqlcode != -2051 ) sql_error(NULL);
                        
            linhas = 1;
        }
        idOferta[k] = *it;
        idUsuario[k] = pRegistro->idPessoaUsuarioInclusao;
        idUFOperadora[k] = pRegistro->idUfOperadora;
        idTipoPessoa[k] = pRegistro->idTipoPessoa;
        idSegmentacao[k] = pRegistro->idSegmentacao;
        idRespostaIntencao[k] = pRegistro->idRespostaIntencao;
        idRespostaDestino[k] = pRegistro->idRespostaDestino;
        inAtivo[k] = 1;
        idGrupo[k] = pRegistro->idGrupo;
        k++; // Bloco de NRO_MAX_REG_ORA Ocorrencias para insert em BLOCO no Oracle
    }

    ULOG( "Atualizando %d linhas", linhas );
    EXEC SQL FOR :linhas
        UPDATE 
            RETENCAO.MATRIZOFERTA
        SET
            INATIVO = 1,
            IDPESSOAUSUARIOALTERACAO = :idUsuario,
            DTALTERACAO = SYSDATE,
            IDUSUARIOALTERACAO = :idUsuario,
            DTULTIMAALTERACAO = SYSDATE
        WHERE 
            IDUFOPERADORA = :idUFOperadora
        AND   
            IDTIPOPESSOA = :idTipoPessoa
        AND   
            IDSEGMENTACAO = :idSegmentacao
        AND   
            IDRESPOSTAINTENCAO = :idRespostaIntencao
        AND   
            IDRESPOSTADESTINO = :idRespostaDestino
        AND	
            IDGRUPO = :idGrupo
        AND   
            IDOFERTA = :idOferta;

    if (sqlca.sqlcode < 0)
    {
        if ( sqlca.sqlcode != -2051 )
            sql_error(NULL);
    }
                

    ULOG_END( "UpdateOfertas()" );

}




void InsertOfertas( stRegistro * pRegistro, LISTA_OFERTAS * pOfertaINS )
{
    ULOG_START( "InsertOfertas()" );
    list<int>::iterator it;

    EXEC SQL BEGIN DECLARE SECTION;
   
      int idOferta[NRO_MAX_REG_ORA];
      int idUsuario[NRO_MAX_REG_ORA];
      int idUFOperadora[NRO_MAX_REG_ORA];
      int idTipoPessoa[NRO_MAX_REG_ORA];
      int idSegmentacao[NRO_MAX_REG_ORA];
      int idRespostaIntencao[NRO_MAX_REG_ORA];
      int idRespostaDestino[NRO_MAX_REG_ORA];
      int idGrupo[NRO_MAX_REG_ORA];
      int inAtivo[NRO_MAX_REG_ORA];
      
      int linhas = 0;

    EXEC SQL END DECLARE SECTION;
//    EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);
    EXEC SQL WHENEVER SQLERROR CONTINUE;


    
    memset( (void *)idOferta,0,sizeof(idOferta));
    memset( (void *)idUsuario,0,sizeof(idUsuario));
    memset( (void *)idUFOperadora,0,sizeof(idUFOperadora));
    memset( (void *)idTipoPessoa,0,sizeof(idTipoPessoa));
    memset( (void *)idSegmentacao,0,sizeof(idSegmentacao));
    memset( (void *)idRespostaIntencao,0,sizeof(idRespostaIntencao));
    memset( (void *)idRespostaDestino,0,sizeof(idRespostaDestino));
    memset( (void *)idGrupo,0,sizeof(idGrupo));

    if ( pRegistro == 0 )
    {
        ULOG( "ponteiro 'pRegistro' invalido" ); //@cassio
        return;
    }

    ULOG( "Vai inserir em RETENCAO.MATRIZOFERTA..." );        

    int k = 0;
    for( it = pOfertaINS->begin(); it != pOfertaINS->end(); it++ )
    {
        linhas++;
        if ( k == NRO_MAX_REG_ORA ) // Insere bloco maximo de ocorrencias no Oracle
        {
            k = 0;
            linhas = NRO_MAX_REG_ORA;
            ULOG( "BLOCANDO: Inserindo %d linhas", linhas );
            EXEC SQL FOR :linhas
            INSERT INTO RETENCAO.MATRIZOFERTA
            (
                IDMATRIZOFERTA,
                IDUFOPERADORA, 
                IDTIPOPESSOA, 
                IDSEGMENTACAO,
                IDRESPOSTAINTENCAO,
                IDRESPOSTADESTINO,
                DTINICIOVIGENCIA,
                IDPESSOAUSUARIOINCLUSAO,
                DTINCLUSAO,
                IDPESSOAUSUARIOALTERACAO,
                DTALTERACAO,
                IDUSUARIOALTERACAO,
                DTULTIMAALTERACAO,
                IDOFERTA,
                INATIVO,
                IDGRUPO
            )
            VALUES 
            (
                retencao.MatrizOfertaSQ.nextval,
                :idUFOperadora, 
                :idTipoPessoa,
                :idSegmentacao,
                :idRespostaIntencao,
                :idRespostaDestino,
                SYSDATE,
                :idUsuario, 
                SYSDATE,      
                :idUsuario, 
                SYSDATE,      
                :idUsuario, 
                SYSDATE,
                :idOferta,
                :inAtivo,
                :idGrupo
            );
                        
            linhas = 1;
        }
        idOferta[k] = *it;
        idUsuario[k] = pRegistro->idPessoaUsuarioInclusao;
        idUFOperadora[k] = pRegistro->idUfOperadora;
        idTipoPessoa[k] = pRegistro->idTipoPessoa;
        idSegmentacao[k] = pRegistro->idSegmentacao;
        idRespostaIntencao[k] = pRegistro->idRespostaIntencao;
        idRespostaDestino[k] = pRegistro->idRespostaDestino;
        inAtivo[k] = 1;
        idGrupo[k] = pRegistro->idGrupo;
        k++; // Bloco de NRO_MAX_REG_ORA Ocorrencias para insert em BLOCO no Oracle
    }

    ULOG( "Inserindo %d linhas", linhas );
    EXEC SQL FOR :linhas
            INSERT INTO RETENCAO.MATRIZOFERTA
            (
                IDMATRIZOFERTA,
                IDUFOPERADORA, 
                IDTIPOPESSOA, 
                IDSEGMENTACAO,
                IDRESPOSTAINTENCAO,
                IDRESPOSTADESTINO,
                DTINICIOVIGENCIA,
                IDPESSOAUSUARIOINCLUSAO,
                DTINCLUSAO,
                IDPESSOAUSUARIOALTERACAO,
                DTALTERACAO,
                IDUSUARIOALTERACAO,
                DTULTIMAALTERACAO,
                IDOFERTA,
                INATIVO,
                IDGRUPO
            )
            VALUES 
            (
                retencao.MatrizOfertaSQ.nextval,
                :idUFOperadora, 
                :idTipoPessoa,
                :idSegmentacao,
                :idRespostaIntencao,
                :idRespostaDestino,
                SYSDATE,
                :idUsuario, 
                SYSDATE,      
                :idUsuario, 
                SYSDATE,      
                :idUsuario, 
                SYSDATE,
                :idOferta,
                :inAtivo,
                :idGrupo
            );
    if (sqlca.sqlcode < 0)
    {
        if ( sqlca.sqlcode != -2051 )
            sql_error(NULL);
    }

    ULOG_END( "InsertOfertas()" );

}



void AtualizaDestino( stRegistro * pRegistro, 
                      int qtSegmentacao, 
                      int qtRespDestino, 
                      int idSegmParam[], 
                      int idRespDestino[] )
{
   ULOG_START( "AtualizaDestino()" );
   
   string buffer;
   char aux[32];

   EXEC SQL BEGIN DECLARE SECTION;
   
      char * query;
      
   EXEC SQL END DECLARE SECTION;

   EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);
   
   if ( pRegistro == 0 )
   {
      ULOG( "ponteiro 'pRegistro' invalido" ); //@cassio
      ULOG_END( "*** TERMINO ANORMAL AtualizaDestino()" );
      return;
   }

   buffer = 
      "UPDATE "
         " RETENCAO.MATRIZOFERTA "
      " SET "
         " INATIVO = 0, "
         " IDPESSOAUSUARIOALTERACAO = ";           // :idUsuario, "
   sprintf( aux, "%d", pRegistro->idPessoaUsuarioInclusao );
   buffer += aux;
   buffer +=
         " ,DTALTERACAO = SYSDATE "
         " ,IDUSUARIOALTERACAO = ";                 // :idUsuario, "
   buffer += aux;
   buffer += 
         " ,DTULTIMAALTERACAO = SYSDATE "
      " WHERE "
         " IDUFOPERADORA = ";                      // :idUFOperadora "
   sprintf( aux, "%d", pRegistro->idUfOperadora );
   buffer += aux;
   buffer +=
      " AND "
         " IDTIPOPESSOA = ";                       // :idTipoPessoa "
   sprintf( aux, "%d", pRegistro->idTipoPessoa );
   buffer += aux;
   buffer +=
      " AND "
         " IDSEGMENTACAO IN ( ";                   // = :idSegmentacao
   for ( int i = 0; i < qtSegmentacao; i++ )
   {
      if ( i > 0 )
      {
         buffer += ",";
      }
      sprintf( aux, "%d", idSegmParam[i] );
      buffer += aux;
   }
   buffer += " )";
   buffer +=
      " AND "
         " IDRESPOSTAINTENCAO = ";                 // :idRespostaIntencao
   sprintf( aux, "%d", pRegistro->idRespostaIntencao );
   buffer += aux;
   buffer +=
      " AND "
         " IDRESPOSTADESTINO IN ( ";               //  :idRespostaDestino
   for ( int k = 0; k < qtRespDestino; k++ )
   {
      if ( k > 0 )
      {
         buffer += ",";
      }
      sprintf( aux, "%d", idRespDestino[k] );
      buffer += aux;
   }
   buffer += " )";
   buffer +=
      " AND "
         " IDGRUPO = ";                            // :idGrupo
   sprintf( aux, "%d", pRegistro->idGrupo );
   buffer += aux;

   query = (char *)buffer.c_str();

   ULOG("Update Query {%s]\n",query);

   EXEC SQL EXECUTE IMMEDIATE :query;       
            
   buffer =
         "DELETE FROM "
            "RETENCAO.MATRIZOFERTAFIDELIZACAO "
         "WHERE "
            "IDMATRIZOFERTA "
            "IN ( "
                  "SELECT "
                     "IDMATRIZOFERTA "
                  "FROM "
                     "RETENCAO.MATRIZOFERTA "
                  "WHERE "
                     "IDUFOPERADORA = ";
                  sprintf( aux, "%d", pRegistro->idUfOperadora );
                  buffer += aux;
                  buffer +=
                  " AND "
                     "IDTIPOPESSOA = ";
                  sprintf( aux, "%d", pRegistro->idTipoPessoa );
                  buffer += aux;
                  buffer +=
                  " AND " 
                     "IDSEGMENTACAO IN (";
                  for ( int a = 0; a < qtSegmentacao; a++ )
                  {
                     if ( a > 0 )
                     {
                        buffer += ",";
                     }
                     sprintf( aux, "%d", idSegmParam[a] );
                     buffer += aux;
                  }
                  buffer += " )";
                  buffer +=
                  " AND " 
                     "IDRESPOSTAINTENCAO = ";
                  sprintf( aux, "%d", pRegistro->idRespostaIntencao );
                  buffer += aux;
                  buffer +=
                  " AND " 
                     "IDRESPOSTADESTINO IN ("; 
                  for ( int b = 0; b < qtRespDestino; b++ )
                  {
                     if ( b > 0 )
                     {
                        buffer += ",";
                     }
                     sprintf( aux, "%d", idRespDestino[b] );
                     buffer += aux;
                  }
                  buffer += " )";
                  buffer +=
                  " AND "
                     "IDGRUPO = ";  
                  sprintf( aux, "%d", pRegistro->idGrupo );
                  buffer += aux;
                  buffer +=
                  " AND "
                    "IDMATRIZOFERTA NOT IN "
                       "( "
                          "SELECT IDMATRIZOFERTA FROM RETENCAO.OFERTAREALIZADA "
                       ") ";
                  buffer += " )";
                                   
   query = (char *)buffer.c_str();
   ULOG("Delete Query [%s]\n",query);

   EXEC SQL EXECUTE IMMEDIATE :query;       


   ULOG_END( "AtualizaDestino()" );
   
}




void OrganizaMatrizOferta( stRegistro * pRegistro, 
                           int qtSegmentacao, 
                           int qtRespDestino, 
                           int idSegmParam[], 
                           int idRespDestino[] )
{
   ULOG_START( "OrganizaMatrizOferta()" );
   
   string buffer;
   char aux[32];

   EXEC SQL BEGIN DECLARE SECTION;
   
      char * query;
      
   EXEC SQL END DECLARE SECTION;

   EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);
   
   if ( pRegistro == 0 )
   {
      ULOG( "ponteiro 'pRegistro' invalido" ); //@cassio
      ULOG_END( "*** TERMINO ANORMAL AtualizaDestino()" );
      return;
   }

            
   buffer =
      "DELETE FROM "
         "RETENCAO.MATRIZOFERTA "
      "WHERE "
         "IDUFOPERADORA = ";
      sprintf( aux, "%d", pRegistro->idUfOperadora );
      buffer += aux;
      buffer +=
      " AND "
         "IDTIPOPESSOA = "; 
      sprintf( aux, "%d", pRegistro->idTipoPessoa );
      buffer += aux;
      buffer +=
      " AND "
         "IDSEGMENTACAO IN ( ";
      for ( int a = 0; a < qtSegmentacao; a++ )
      {
         if ( a > 0 )
         {
            buffer += ",";
         }
         sprintf( aux, "%d", idSegmParam[a] );
         buffer += aux;
      }
      buffer += " )";
      buffer +=
      " AND "
         "IDRESPOSTAINTENCAO = ";
      sprintf( aux, "%d", pRegistro->idRespostaIntencao );
      buffer += aux;
      buffer +=
      " AND "
         "IDRESPOSTADESTINO IN ( "; 
      for ( int b = 0; b < qtRespDestino; b++ )
      {
         if ( b > 0 )
         {
            buffer += ",";
         }
         sprintf( aux, "%d", idRespDestino[b] );
         buffer += aux;
      }
      buffer += " )";
      buffer +=
      " AND "
         "IDGRUPO = "; 
      sprintf( aux, "%d", pRegistro->idGrupo );
      buffer += aux;
      buffer +=
      " AND "
        "IDMATRIZOFERTA NOT IN "
           "( "
              "SELECT IDMATRIZOFERTA FROM RETENCAO.OFERTAREALIZADA "
           ") "
      " AND "
        "IDMATRIZOFERTA NOT IN "
           "( "
              "SELECT IDMATRIZOFERTA FROM RETENCAO.MATRIZOFERTAFIDELIZACAO "
           ") ";
      


   query = (char *)buffer.c_str();
   ULOG( "Delete Query [%s]\n",query );

   EXEC SQL EXECUTE IMMEDIATE :query;       


   ULOG_END( "OrganizaMatrizOferta()" );
   
}




void Fideliza( stRegistro * pRegistro, 
                           int qtSegmentacao, 
                           int qtRespDestino,
                           int qtOfertas, 
                           int idSegmParam[], 
                           int idRespDestino[],
                           int idOfertas[] )
{
   ULOG_START( "Fideliza()" );
   
   string buffer;
   char aux[32];

   EXEC SQL BEGIN DECLARE SECTION;
   
      char * query;
      
   EXEC SQL END DECLARE SECTION;

   EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);
   

   if ( pRegistro == 0 )
   {
      ULOG( "ponteiro 'pRegistro' invalido" ); //@cassio
      ULOG_END( "*** TERMINO ANORMAL AtualizaDestino()" );
      return;
   }

            
   buffer =
      "INSERT INTO RETENCAO.MATRIZOFERTAFIDELIZACAO "
      "( "
         "IDMATRIZOFERTA "
      ") "
      "SELECT "
         "IDMATRIZOFERTA "
      "FROM "
         "RETENCAO.MATRIZOFERTA "
      "WHERE "
         "IDUFOPERADORA = ";
      sprintf( aux, "%d", pRegistro->idUfOperadora );
      buffer += aux;
      buffer +=
      "AND "
         "IDTIPOPESSOA = ";
      sprintf( aux, "%d", pRegistro->idTipoPessoa );
      buffer += aux;
      buffer +=
      "AND "
         "IDSEGMENTACAO IN ( ";
      for ( int a = 0; a < qtSegmentacao; a++ )
      {
         if ( a > 0 )
         {
            buffer += ",";
         }
         sprintf( aux, "%d", idSegmParam[a] );
         buffer += aux;
      }
      buffer += " )";
      buffer +=
      "AND "
         "IDRESPOSTAINTENCAO = ";
      sprintf( aux, "%d", pRegistro->idRespostaIntencao );
      buffer += aux;
      buffer +=
      "AND "
         "IDRESPOSTADESTINO IN ( ";
      for ( int b = 0; b < qtRespDestino; b++ )
      {
         if ( b > 0 )
         {
            buffer += ",";
         }
         sprintf( aux, "%d", idRespDestino[b] );
         buffer += aux;
      }
      buffer += " )";
      buffer +=   
      "AND "
         "IDGRUPO = ";
      sprintf( aux, "%d", pRegistro->idGrupo );
      buffer += aux;
      buffer +=
      "AND "
         "IDOFERTA IN ( ";
      for ( int c = 0; c < qtOfertas; c++ )
      {
         if ( c > 0 )
         {
            buffer += ",";
         }
         sprintf( aux, "%d", idOfertas[c] );
         buffer += aux;
      }
      buffer += " )";


   query = (char *)buffer.c_str();
   ULOG("Insert Query {%s]\n",query);

   EXEC SQL EXECUTE IMMEDIATE :query;       


   ULOG_END( "Fideliza()" );
   
}
