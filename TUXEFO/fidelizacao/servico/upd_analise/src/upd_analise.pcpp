//
// $Id: upd_analise.pcpp,v 1.1.118.1 2013/02/06 12:37:06 a5114878 Exp $
//

#include "../../negocio/fidutil/include/retencao.hpp"
#include "../../negocio/fidutil/include/SmallString.h"

#define PARAMATRO_ID_ARVORE_BAIXA "PARAMATRO_ID_ARVORE_BAIXA_ANALISECREDITO"

#define SERVICO_PARA_FECHAR_PREOCESSO   "CERRAMEFEC"
#define ATIVIDADE_FECHAMENTO      10 
#define REPROVADO_ANALISATA_BKO   3 
#define APROVADO_ANALISATA_BKO    2 

////////////////////////////////////////////////////////////////////////////////////////
// Tipo de retorno do contato (CONTATOADM.TIPORETORNOCONTATO)
//  estes difene estao no arquivo  > #include "definesAtendimento.h"
#define TP_RET_SEM_RETORNO     0
#define TP_RET_COM_RET_GRP_BKO 1
#define TP_RET_COM_RET_GRP_RET 2
#define TP_RET_SEM_RET_ONLINE  3
#define TP_RET_COM_RET_GRP_CRI 4

//  esta strutura contem os dados necessarios para chamar o servico fechamento de forma remota
typedef  struct _stDadosAtendimento 
{
 unsigned long  idAtendimento;                         // OK a ser fechado no workflow
 int            idTipoRetornoContato;                  // OK 
 int            idFase;                                // OK fase do processo 
 int            idAtividade;                           // OK FECHAMENTO  10 
 int            idAgrupamentoEstadoTProcFut;           // OK esta informacao vira da tela 
 int            idAgrupamentoEstadoTProcAt;            // OK esta informacao e obtida com o idatendimento no metodo  proCObtemWFDetalheAtendimento
 int            idPessoaUsuario;                       // OK
 char           nmUrlDestino[256];                     // OK 
 char           dsObservacao[256];                     // OK  
 int            idMotivo;     
 int            idBaixa;
 int            idBaixaMensagem;
} stDadosAtendimento ;



bool proCObtemWFDetalheAtendimento( unsigned long _idAtendimento , stDadosAtendimento *_pstDadosAtendimento    );
// bool proCObterTipoRetornoContato(unsigned long _idAtendimento,int *_idUFOperadora,int *_idTipoRetornoContato,  int *idBaixa ,int * idBaixaMensagem );
//bool proCObterTipoRetornoContato(unsigned long _idAtendimento,int *_idUFOperadora,int *_idTipoRetornoContato,  int *_idBaixa ,int *_idBaixaMensagem );
bool proCObterTipoRetornoContato(unsigned long _idAtendimento,int *_idUFOperadora,int *_idTipoRetornoContato,  int *_idBaixa ,int * _idBaixaMensagem );
void FormataDados(SmallString &strDomScr, stDadosAtendimento  DadosAtendimento);

// executa o servico fecamento de forma remota
void Call(char *labelServico,char  *idUsuario,SmallString &strDomScr);
bool proCObterEstadoFuturo(unsigned long _idAtendimento,int *_EstadoFut);

int get_Parametro(char *_cdParametro, char *_dsValorParametro);
int get_idBiaxaMensagem(char *_idBaixa, char *_idBaixaMensagem);


int upd_analise(int usuario, DOMNode*dnode, XMLGen*xml)
{
    
  ULOG_START("upd_analise()");
  
  SmallString strDomScr;  
  
  stDadosAtendimento DadosAtendimento;
  
  char parm[255];
  int iRet=0;
  char sUsuario[21];

  sprintf( sUsuario, "%d", usuario );
  memset(&DadosAtendimento,0,sizeof(stDadosAtendimento));
  
  

  EXEC SQL BEGIN DECLARE SECTION;
  	  VARCHAR        dsObsAnalista[256];    			      //  ENDERECO ALTERADO PELO ATENDENTE RETENCAO
  	  int            idTipoAnalise;                         
  	  unsigned long  idRetencao; 				              //  CHAVE PRIMARIA   		
      int inAprovado = 0 ;                                    // defalt da retencao e reprovado
      unsigned long  idAtendiemento = 0  ; 				      //  CHAVE PRIMARIA   		
  	  
      int            idPessoaUsuarioAlteracao;

  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);

  try{

        
  	    // Dados de entrada do Endereco
  	    get_tag(parm,dnode,"idRetencao",0,0);
  	    idRetencao=atoi(parm);
  	    ULOG(" idRetencao = [%lu]",idRetencao);
  	    
  	    memset(parm,0,sizeof(parm));
        //  Obtendo dados do xml
        get_tag(parm,dnode,"idTipoAnalise",0,0);
        idTipoAnalise=atoi(parm);
        ULOG(" idTipoAnalise = [%d]",idTipoAnalise);
                
        
        
        // verifica se aprovado pelo analista BKO
	    get_tag(parm,dnode,"dsObsAnalista",0,0);
	    strToOra(dsObsAnalista,parm);
	    strcpy(DadosAtendimento.dsObservacao,(char*)dsObsAnalista.arr);
	    
	    ULOG(" dsObsAnalista = [%s]",(char*)dsObsAnalista.arr);
	    
	    ULOG(" (char*)dsObsAnalista.arr = [%s]",(char*)dsObsAnalista.arr);
	    
        if ( idTipoAnalise == APROVADO_ANALISATA_BKO )
        {
            inAprovado = 1 ;
            DadosAtendimento.idMotivo = 51 ;   // nao existe na tabela motivo deve ser incluido 
             
            if ( strlen(DadosAtendimento.dsObservacao) == 0 )
                strcpy(DadosAtendimento.dsObservacao,"Retenção Aprovada pelo analista BKO");
        }    
            
        if ( idTipoAnalise == REPROVADO_ANALISATA_BKO )
        {
             DadosAtendimento.idMotivo = 52 ;   // nao existe na tabela motivo deve ser incluido 
             if ( strlen(DadosAtendimento.dsObservacao) == 0 )
                strcpy(DadosAtendimento.dsObservacao,"Retenção Reprovada pelo analista BKO");
        }    

        memset(parm,0,sizeof(parm));        
        //  Obtendo dados do xml idAtendiemento
        get_tag(parm,dnode,"idAtendimento",0,-1);
        DadosAtendimento.idAtendimento = atoi(parm);
        
        ULOG(" DadosAtendimento.idAtendimento = [%lu]",DadosAtendimento.idAtendimento);
        
        // esta vaidacao existe para o caso de erro na geracao do processo no workflow
        if ( DadosAtendimento.idAtendimento != 0 )
        {    
            proCObterEstadoFuturo(DadosAtendimento.idAtendimento,&DadosAtendimento.idAgrupamentoEstadoTProcFut);
    	    
    	    DadosAtendimento.idAtividade = ATIVIDADE_FECHAMENTO ;
    	    DadosAtendimento.idPessoaUsuario = usuario;
    
            // Pegando id do usuario
            idPessoaUsuarioAlteracao = usuario;

            // recupera dados para executar o servico de forma remota
            proCObtemWFDetalheAtendimento( DadosAtendimento.idAtendimento , &DadosAtendimento );
    
    		// cria o xml de saida
    		FormataDados(strDomScr, DadosAtendimento);
    		ULOG( "XML IN DFECHAMENTO [%s]", (char *)strDomScr.c_str() );
    
            Call(SERVICO_PARA_FECHAR_PREOCESSO, sUsuario,strDomScr);

        }
        ULOG("UPDATE EM RETENCAO.RETENCAOANALISE ");
  
		/* Update linha */
		EXEC SQL UPDATE RETENCAO.RETENCAOANALISE
			 SET 
              DSOBSANALISE    = :dsObsAnalista,
              IDTIPOANALISE   = :idTipoAnalise
			WHERE IDRETENCAO  = :idRetencao;
			    
	    // atualiza o estado do aparelho		    
        EXEC SQL UPDATE RETENCAO.RELANALISECREDITO
     	     SET INAPROVADO   = :inAprovado
		     WHERE IDRETENCAO = :idRetencao;
		        
  }
  catch(...)
  {
	throw;
  }
  
  ULOG_END("upd_analise()");
  return 1;
}

void Call(char *labelServico,char *sUsuario,SmallString &strDomScr)
{
    ULOG_START("Call()");
    
    TuxRemoteService *rc = new TuxRemoteService;

    if ( !rc )
    {
        char *err = "Erro na alocacao de objeto TuxRemoteService";
        ULOGE("%s",err);
        throw new TuxBasicSvcException("00E0000",err);
    }

    TuxMessage *tmIn = new TuxMessage();

    if ( !tmIn )
    {
        delete rc;

        char *err = "Erro na alocacao de objeto TuxMessage";
        ULOGE("%s",err);
        throw new TuxBasicSvcException("00E0000",err);
    }

    try 
    {
        // sprintf( m_stDados.sequence,"%d",cWFCoreWorkflow::tuxSeqRemoteCall++ );

        tmIn->setService( labelServico );
        tmIn->setUser(sUsuario);
        
        // NAO NECESSARIO tmIn->setSequence( m_stDados.sequence );
        
        tmIn->setMessageBody( strDomScr.c_str() );

        rc->setServiceName( labelServico );
        rc->setInputMessage( tmIn );

        ULOGE("TuxRemoteService::remoteCall chamando servico '%s'" ,labelServico);

        if ( rc->remoteCall() != TUXFWRET_OK )
        {
            SmallString err;
            err = "Erro na chamada ao servico ";
            err += labelServico;
            err += " (";
            err += labelServico;
            err += ")";
            throw new TuxException("00E0000",err.c_str());
        }

        TuxMessage* outTm = rc->getOutputMessage();

        char *codigoRetorno = outTm->getStatusCode();
        char *statusText = outTm->getStatusText();

        ULOG("outTm->getMessageBody()=\"%s\"",outTm->getMessageBody());

        if ( *(codigoRetorno+2) == 'E' )
        {
            ULOGE("servico %s  retornou status code =\"%c\"",labelServico,*(codigoRetorno+2));
            throw new TuxException(codigoRetorno,statusText);
        }
    }
    catch (...)
    {
        delete rc;
        delete tmIn;
        ULOGE("erro na execucao do servico");
        ULOG_END("Call()");

        throw;
    }

    delete rc;
    delete tmIn;

    ULOG_END("Call()");

}


void FormataDados(SmallString &strDomScr, stDadosAtendimento  DadosAtendimento)
{                
    ULOG_START("FormataDados()");
    
    strDomScr = "<WFExecucao>";
    strDomScr += "\n\t<ScriptExecucaoVO>";
    strDomScr += "\n\t\t<idAtendimento>";
    strDomScr += DadosAtendimento.idAtendimento;
    strDomScr += "</idAtendimento>";
    strDomScr += "\n\t\t<idTipoRetornoContato>";
    strDomScr += DadosAtendimento.idTipoRetornoContato;
    strDomScr += "</idTipoRetornoContato>";
    strDomScr += "\n\t\t<idFase>";
    strDomScr += DadosAtendimento.idFase;
    strDomScr += "</idFase>";
    strDomScr += "\n\t\t<inCRI>0</inCRI>";
    strDomScr += "\n\t\t<inRC>0</inRC>";
    strDomScr += "\n\t\t<idAtividade>";
    strDomScr += DadosAtendimento.idAtividade;
    strDomScr += "</idAtividade>";
    strDomScr += "\n\t\t<idAtividadeMassa>";
    strDomScr += DadosAtendimento.idAtividade;
    strDomScr += "</idAtividadeMassa>";
    strDomScr += "\n\t\t<idAgrupamentoEstadoTProcFut>";
    strDomScr += DadosAtendimento.idAgrupamentoEstadoTProcFut;
    strDomScr += "</idAgrupamentoEstadoTProcFut>";
    strDomScr += "\n\t\t<idAgrupamentoEstadoTProcAt>";
    strDomScr += DadosAtendimento.idAgrupamentoEstadoTProcAt;
    strDomScr += "</idAgrupamentoEstadoTProcAt>";
    strDomScr += "\n\t\t<idPessoaUsuario>";
    strDomScr += DadosAtendimento.idPessoaUsuario;
    strDomScr += "</idPessoaUsuario>";		
    strDomScr += "\n\t\t<nmUrlDestino>";
    strDomScr += DadosAtendimento.nmUrlDestino;
    strDomScr += "</nmUrlDestino>";
    strDomScr += "\n\t</ScriptExecucaoVO>";
    strDomScr += "\n\t<AtendimentoWorkflowVO xmlns=\"admsistemas.fo.vivo.com.br/vo\" xmlns:ns1=\"workflow.fo.vivo.com.br/vo\">";
    strDomScr += "\n\t\t<AtendimentoWorkflowComumVO>";
    strDomScr += "\n\t\t\t<dsObservacao>";
    strDomScr += DadosAtendimento.dsObservacao;
    strDomScr += "</dsObservacao>";
    strDomScr += "\n\t\t\t<WFMotivoVO>";
    strDomScr += "\n\t\t\t\t<idMotivo>";
    strDomScr += DadosAtendimento.idMotivo;
    strDomScr += "</idMotivo>";
    strDomScr += "\n\t\t\t</WFMotivoVO>";
    strDomScr += "\n\t\t</AtendimentoWorkflowComumVO>";
    strDomScr += "\n\t\t<AtendimentoWorkflowEncerramentoVO>";
    strDomScr += "\n\t\t\t<ArvoreEncerramentoVO>";
    strDomScr += "\n\t\t\t\t<EncerramentoVO>";
	strDomScr += "\n\t\t\t\t\t<idBaixa>";
	strDomScr += DadosAtendimento.idBaixa;
	strDomScr += "</idBaixa>";
	strDomScr += "\n\t\t\t\t\t<idBaixaMensagem>";
	strDomScr += DadosAtendimento.idBaixaMensagem;
	strDomScr += "</idBaixaMensagem>";
	strDomScr += "\n\t\t\t\t\t<dsComentario/>";
	strDomScr += "\n\t\t\t\t\t<dsDocumentoAssociado/>";
    strDomScr += "\n\t\t\t\t</EncerramentoVO>";    
    strDomScr += "\n\t\t\t\t<FormularioVO/>";
    strDomScr += "\n\t\t\t</ArvoreEncerramentoVO>";
    strDomScr += "\n\t\t</AtendimentoWorkflowEncerramentoVO>";
    strDomScr += "\n\t</AtendimentoWorkflowVO>";
    strDomScr += "</WFExecucao>";            
    
    ULOG_END("FormataDados()");
}		

// ESTES METODO FOI COPIADO DO ATENDIMENTO PARA MANTER A INDEPENDENCIA DE COMPILACAO E 
// MANTERA O MESMO NOME PARA COMPATIBILIDADE  DA REGRA E MODIFICACAO FUTURA
bool proCObtemWFDetalheAtendimento( unsigned long _idAtendimento , stDadosAtendimento *pstDadosAtendimento    )
{
    ULOG_START( "proCObtemWFDetalheAtendimento()" );

    ULOG("idAtendimento= [%lu]",_idAtendimento);

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int idAtendimento = _idAtendimento;
        int idTipoRetornoContatoST;
        int idFase;
        int idAgrEstadoTProc;                //  idAgrupamentoEstadoTProcAt
        VARCHAR  nmUrlDestino[255];          // NMURLDESTINO        VARCHAR2(255 BYTE)
        short i_idTipoRetornoContato;
        short i_idFase;
        short i_idAgrEstadoTProc;
        short i_nmUrlDestino;
        
        int idBaixa = 0 ;
        int idBaixaMensagem =0 ;
        

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error(NULL);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        SELECT 
            ATD.IDTIPORETORNOCONTATO,
            ATD.IDFASE, 
            ATD.IDAGRUPAMENTOESTADOTPPROC
        INTO
           :idTipoRetornoContatoST:i_idTipoRetornoContato,
           :idFase:i_idFase,
           :idAgrEstadoTProc:i_idAgrEstadoTProc
        FROM 
            ATENDIMENTO.ATENDIMENTODETALHEV01 ATD,
            ATENDIMENTO.ATENDIMENTOPESSOA AP
        WHERE 
            ATD.IDATENDIMENTO = :idAtendimento
        AND
            AP.IDATENDIMENTO = ATD.IDATENDIMENTO
        AND
            AP.IDTIPORELACIONAMENTO IN (2,3,6,7); //M0007 (Melhoria) - Set, 2006 - Cassio


    if ( sqlca.sqlcode == 0 )
    {
        ULOG( "idTipoRetornoContato=%d",idTipoRetornoContatoST );

        if ( idTipoRetornoContatoST > TP_RET_SEM_RETORNO && 
             idTipoRetornoContatoST < TP_RET_COM_RET_GRP_CRI )
        { // se o processo foi criado para ir para grupo de retorno, então determina em
          // tempo real o tipo de retorno (vide DES BUG_3271_DES - Atualizada Gestão de Processos - Fase Retorno v.2.3.doc)
            int idUFOperadora;
            int idTipoRetornoContato;
            proCObterTipoRetornoContato(idAtendimento,&idUFOperadora,&idTipoRetornoContato,  &idBaixa ,&idBaixaMensagem);
            if ( -1 != idTipoRetornoContato )
            { // se processo em tratamento, assume o tipo do retorno do contato definido em tempo real
                // oDadosSaida.idUFOperadora = idUFOperadora;
                idTipoRetornoContatoST = idTipoRetornoContato;
            }
        }

		ULOG("idBaixa=[%d]",idBaixa);                
        if (idBaixa == 0)
        {
            char sidBaixa[33];
            char sidBaixaMensagem[33];
            char pesq[33];
            memset(sidBaixa,0,sizeof(sidBaixa));
            memset(sidBaixaMensagem,0,sizeof(sidBaixaMensagem));
            memset(pesq,0,sizeof(sidBaixaMensagem));
            strcpy(pesq,PARAMATRO_ID_ARVORE_BAIXA);
            get_Parametro(pesq,sidBaixa);
            get_idBiaxaMensagem(sidBaixa,sidBaixaMensagem);
            idBaixa = atoi(sidBaixa);
            idBaixaMensagem = atoi(sidBaixaMensagem);    
			ULOG("idBaixa=[%d]",idBaixa);        
			ULOG("idBaixaMensagem=[%d]",idBaixaMensagem);
        }    
        
            
        pstDadosAtendimento->idBaixa = idBaixa;
        pstDadosAtendimento->idBaixaMensagem = idBaixaMensagem;            

        pstDadosAtendimento->idTipoRetornoContato = idTipoRetornoContatoST;
        pstDadosAtendimento->idFase = idFase;
        pstDadosAtendimento->idAgrupamentoEstadoTProcAt = idAgrEstadoTProc;

        ULOG("idTipoRetornoContato=[%d]",pstDadosAtendimento->idTipoRetornoContato);        
        ULOG("idFase=[%d]",pstDadosAtendimento->idFase);
        ULOG("idAgrupamentoEstadoTProcAt=[%d]",pstDadosAtendimento->idAgrupamentoEstadoTProcAt);
        
        // recupera a  nmUrlDestino 
        // esta parte do codigo nao pertence a funcao original
        EXEC SQL
        	SELECT  DISTINCT   NMURLDESTINO
            INTO	:nmUrlDestino:i_nmUrlDestino	    
        	FROM    WORKFLOW.FLUXOACOESBKORCV01
        	WHERE   IDATIVIDADE = 10
        	AND     IDFASE = idFase
            AND     ROWNUM < 2;        
                
        // copia o NMURLDESTINO para a estrutura de saida
        endOraStr(nmUrlDestino);
        
        ULOG("nmUrlDestino=%s",pstDadosAtendimento->nmUrlDestino);
        
        strcpy(pstDadosAtendimento->nmUrlDestino,(char *)nmUrlDestino.arr);
        
    }
    else
    {
        ULOG("proCObtemWFDetalheAtendimento()::Processo não encontrado.");
    }

    ULOG_END( "proCObtemWFDetalheAtendimento()" );
    
    

    return sqlca.sqlcode == 0 ? true : false;
}

// ESTES METODO FOI COPIADO DO ATENDIMENTO PARA MANTER A INDEPENDENCIA DE COMPILACAO E MANTERA O MESMO NOME PARA COMPATIBILIDADE  DA REGRA E MODIFICACAO FUTURA
//  bool proCObterTipoRetornoContato(unsigned long _idAtendimento,int *_idUFOperadora,int *_idTipoRetornoContato)     
bool proCObterTipoRetornoContato(unsigned long _idAtendimento,int *_idUFOperadora,int *_idTipoRetornoContato,  int *_idBaixa ,int * _idBaixaMensagem )
{
    ULOG_START("proCObterTipoRetornoContato()");

    struct sqlca sqlca;
    ULOG("_idAtendimento=[%lu]",_idAtendimento);
    EXEC SQL BEGIN DECLARE SECTION;
        // struct VariaveisRetorno variaveisretorno;

        // Estrutura com as variáveis da aba 'retorno' da árvore de contato
        struct VariaveisRetorno
        {
            int idCanal;
            int idContato;
            int idGrupo;
            int idProcedencia;
            int idSegmentacao;
            int idTipoCarteira;
            int idTipoLinha;
            int idTipoPessoa;
            int idTipoRelacionamento;
            int idUFOperadora;
            int idBaixa;
            int idBaixaMensagem;
            
        } variaveisretorno ;

        int *idTipoRetornoContato = _idTipoRetornoContato;
        unsigned long idAtendimento = _idAtendimento;    
        

        short i_idContato;
        short i_idCanal;
        short i_idProcedencia;
        short i_idTipoCarteira;
        short i_idSegmentacao;
        short i_idGrupo;
        short i_idTipoRelacionamento;
        short i_idTipoPessoa;
        short i_idUFOperadora;
        short i_idTipoLinha;
        short i_idTipoRetornoContato;
        short i_idBaixa;
        short i_idBaixaMensagem;


    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error( NULL );
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL 
        SELECT
            NVL(IDCONTATO,-1) AS IDCONTATO,
            NVL(IDCANAL,-1) AS IDCANAL,
            NVL(IDPROCEDENCIA,-1) AS IDPROCEDENCIA,
            NVL(IDTIPOCARTEIRA,-1) AS IDTIPOCARTEIRA,
            NVL(IDSEGMENTACAO,-1) AS IDSEGMENTACAO,
            NVL(IDGRUPOABERTURA,-1) AS IDGRUPOABERTURA,
            NVL(IDTIPORELACIONAMENTO,-1) AS IDTIPORELACIONAMENTO,
            NVL(IDTIPOPESSOA,-1) AS IDTIPOPESSOA,
            NVL(IDUFOPERADORA,-1) AS IDUFOPERADORA,
            NVL(IDTIPOLINHA,-1) AS IDTIPOLINHA
        INTO
            :variaveisretorno.idContato:i_idContato,
            :variaveisretorno.idCanal:i_idCanal,
            :variaveisretorno.idProcedencia:i_idProcedencia,
            :variaveisretorno.idTipoCarteira:i_idTipoCarteira,
            :variaveisretorno.idSegmentacao:i_idSegmentacao,
            :variaveisretorno.idGrupo:i_idGrupo,
            :variaveisretorno.idTipoRelacionamento:i_idTipoRelacionamento,
            :variaveisretorno.idTipoPessoa:i_idTipoPessoa,
            :variaveisretorno.idUFOperadora:i_idUFOperadora,
            :variaveisretorno.idTipoLinha:i_idTipoLinha
        FROM
            ATENDIMENTO.ATENDIMENTOPRIORIZACAO
        WHERE
            IDATENDIMENTO = :idAtendimento;

    ULOG("idContato=[%d]",variaveisretorno.idContato);
    ULOG("idCanal=[%d]",variaveisretorno.idCanal);
    ULOG("idProcedencia=[%d]",variaveisretorno.idProcedencia);
    ULOG("idTipoCarteira=[%d]",variaveisretorno.idTipoCarteira);
    ULOG("idSegmentacao=[%d]",variaveisretorno.idSegmentacao);
    ULOG("idGrupo=[%d]",variaveisretorno.idGrupo);
    ULOG("idTipoRelacionamento=[%d]",variaveisretorno.idTipoRelacionamento);
    ULOG("idTipoPessoa=[%d]",variaveisretorno.idTipoPessoa);
    ULOG("idUFOperadora=[%d]",variaveisretorno.idUFOperadora);
    ULOG("idTipoLinha=[%d]",variaveisretorno.idTipoLinha);

    ULOG(
          " SELECT BAIXAMENSAGEM.IDBAIXA,"
          "        BAIXAMENSAGEM.IDMENSAGEMBAIXA "
          " FROM"
          "        CONTATOADM.CONTATOFOLHABAIXA CONTATOFOLHABAIXA ,"
          "        CONTATOADM.BAIXAMENSAGEM"
          " WHERE "
          " 	   BAIXAMENSAGEM.IDBAIXA = CONTATOFOLHABAIXA.IDBAIXA"
          "   AND BAIXAMENSAGEM.IDFORMARETORNO = 1 "
          "   AND CONTATOFOLHABAIXA.IDCONTATO = %d "
          "   AND ROWNUM <2",variaveisretorno.idContato
         );


    EXEC SQL 
        SELECT BAIXAMENSAGEM.IDBAIXA,
               BAIXAMENSAGEM.IDMENSAGEMBAIXA 
         INTO
              :variaveisretorno.idBaixa:i_idBaixa,
              :variaveisretorno.idBaixaMensagem:i_idBaixaMensagem
        FROM
               CONTATOADM.CONTATOFOLHABAIXA CONTATOFOLHABAIXA ,
               CONTATOADM.BAIXAMENSAGEM
        WHERE 
        	   BAIXAMENSAGEM.IDBAIXA = CONTATOFOLHABAIXA.IDBAIXA
          AND BAIXAMENSAGEM.IDFORMARETORNO = 1                    // RETORNO EM SMS 
          AND CONTATOFOLHABAIXA.IDCONTATO = :variaveisretorno.idContato
          AND ROWNUM <2;
      
    ULOG("idBaixa=[%d]",variaveisretorno.idBaixa);
    ULOG("idBaixaMensagem=[%d]",variaveisretorno.idBaixaMensagem);

    if ( sqlca.sqlcode == 0 )
    {
        // Salva o idUFOperadora encontrado
        *_idUFOperadora = variaveisretorno.idUFOperadora;

        // Se ocorrer erro Oracle de mais de uma linha resultante da query abaixo (too many rows)
        // o erro não é da query e sim da configuração de administração que esta permitindo que 
        // um mesmo grupo de variáveis seja parametrizado para mais de um tipo de retorno de contato
        // para um mesmo contato. Veja se o serviço que faz esta parametrização não esta com falha
        // na consistência deste tipo de configuração repetida.
        //
        // Julho,2006 - Cassio.
        //
        EXEC SQL
            SELECT /*+ NO_CPU_COSTING */
                IDTIPORETORNOCONTATO
            INTO
                :*idTipoRetornoContato:i_idTipoRetornoContato
            FROM 
                ATENDIMENTO.ATDVARIAVEISRETORNOV01
            WHERE
                IDCONTATO            = :variaveisretorno.idContato
            AND IDGRUPO              = :variaveisretorno.idGrupo
            AND IDPROCEDENCIA        = :variaveisretorno.idProcedencia
            AND IDSEGMENTACAO        = :variaveisretorno.idSegmentacao
            AND IDCANAL              = :variaveisretorno.idCanal
            AND IDTIPOCARTEIRA       = :variaveisretorno.idTipoCarteira
            AND IDTIPOLINHA          = :variaveisretorno.idTipoLinha
            AND IDTIPOPESSOA         = :variaveisretorno.idTipoPessoa
            AND IDTIPORELACIONAMENTO = :variaveisretorno.idTipoRelacionamento
            AND IDUFOPERADORA        = :variaveisretorno.idUFOperadora;

        // Esta operação é chamada somente para aqueles processos em que o cliente/usuário/prospect
        // solicitou retorno, assim se o contato estiver configurado para SEM RETORNO é assumido
        // por default RETORNO POR GRUPO BKO.
        // Se o tipo de retorno do contato não for encontrado, o valor default fica
        // RETORNO POR GRUPO BKO.
        // Estas definições se encontram no DES V2.3 para a incidência 3273 de homologação VIVO
        // Julho de 2006, Cassio.

        if ( sqlca.sqlcode == 1403 || *idTipoRetornoContato == TP_RET_SEM_RET_ONLINE )
        {
            ULOG("idTipoRetornoContato=[%d]",*idTipoRetornoContato);
            *idTipoRetornoContato = TP_RET_COM_RET_GRP_BKO;
        }
    }
    else
    {
        ULOGW("resultadoNaoEncontradoSql()");
        *idTipoRetornoContato = -1;
    }


    *_idBaixa = variaveisretorno.idBaixa ;
    *_idBaixaMensagem = variaveisretorno.idBaixaMensagem ;
    
    ULOG_END("proCObterTipoRetornoContato()");

    return true;
}


// ESTES METODO FOI COPIADO DO ATENDIMENTO PARA MANTER A INDEPENDENCIA DE COMPILACAO E MANTERA O MESMO NOME PARA COMPATIBILIDADE  DA REGRA E MODIFICACAO FUTURA
bool proCObterEstadoFuturo(unsigned long _idAtendimento,int *_EstadoFut)
{
    ULOG_START("proCObterEstadoFuturo()");

    struct sqlca sqlca;
    ULOG("_idAtendimento=[%lu]",_idAtendimento);
    EXEC SQL BEGIN DECLARE SECTION;
        // struct VariaveisRetorno variaveisretorno;

        int IDGRUPAMENTOESTADOTPPROCFT;
        short I_IDGRUPAMENTOESTADOTPPROCFT;
        
        unsigned long idAtendimento = _idAtendimento;    

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO sql_error( NULL );
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL 
        SELECT DECODE (CONTATOFOLHA.IDTIPOPROCESSO,2, 23,10) AS IDGRUPAMENTOESTADOTPPROCFT
          INTO :IDGRUPAMENTOESTADOTPPROCFT:I_IDGRUPAMENTOESTADOTPPROCFT
          FROM CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
               ATENDIMENTO.ATENDIMENTO ATENDIMENTO
         WHERE ATENDIMENTO.IDCONTATO = CONTATOFOLHA.IDCONTATO
           AND ATENDIMENTO.IDATENDIMENTO = :idAtendimento;
    
    ULOG("IDGRUPAMENTOESTADOTPPROCFT=[%d]",IDGRUPAMENTOESTADOTPPROCFT);


    if ( sqlca.sqlcode == 0 )
    {
        // Salva o idUFOperadora encontrado
        *_EstadoFut = IDGRUPAMENTOESTADOTPPROCFT;
    }
    else
    {
        ULOGE("ERRO *_EstadoFut = 10;");
        *_EstadoFut = 10;
    }

    ULOG_END("proCObterEstadoFuturo()");

    return true;
}


int get_Parametro(char *_cdParametro ,char *_dsValorParametro)
{
    
  ULOG_START("int get_Parametro()");
  ULOG("_cdParametro = [%s]",_cdParametro);
  
  EXEC SQL BEGIN DECLARE SECTION;
  VARCHAR iValor[256]; 
  VARCHAR cdParametro[256];
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);

  try
  {
    
   
    strToOra(cdParametro,_cdParametro);     
    // Definicao dos cursores  
    EXEC SQL SELECT DSVALORPARAMETRO
			  INTO  :iValor 
			   FROM apoio.parametro
			  WHERE CDPARAMETRO=:cdParametro
			    AND ROWNUM=1;
  
          
    endOraStr(iValor);
    ULOG("iValor = [%s]",(char*)iValor.arr);
	strcpy(_dsValorParametro,(char*)iValor.arr);
  }
  catch(...)
  {
		throw;
  }
  ULOG_END("get_Parametro()");
  return 1;
}


int get_idBiaxaMensagem(char *_idBaixa, char *_idBaixaMensagem)
{
  ULOG_START("get_idBiaxaMensagem()");
  ULOG("_idBaixa = [%s]",_idBaixa);
  
  EXEC SQL BEGIN DECLARE SECTION;
  VARCHAR idMensagemBaixa[256]; 
  VARCHAR idBaica[256];
  short i_idMensagemBaixa=-1; 
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);

  try
  {
   
    strToOra(idBaica,_idBaixa);
    ULOG(
          " SELECT "
          "        BAIXAMENSAGEM.IDMENSAGEMBAIXA "
          " FROM"
          "        CONTATOADM.BAIXAMENSAGEM"
          " WHERE "
          " 	   BAIXAMENSAGEM.IDBAIXA = %s "
          "   AND BAIXAMENSAGEM.IDFORMARETORNO = 1 "
          "   AND ROWNUM <2",_idBaixa
         );

    
   
         
    // Definicao dos cursores  
    EXEC SQL 
       SELECT 
               BAIXAMENSAGEM.IDMENSAGEMBAIXA 
         INTO
              :idMensagemBaixa:i_idMensagemBaixa
        FROM
               CONTATOADM.BAIXAMENSAGEM
        WHERE 
        	  BAIXAMENSAGEM.IDBAIXA = :idBaica
          AND BAIXAMENSAGEM.IDFORMARETORNO = 1     
          AND ROWNUM <2;
          
    endOraStr(idMensagemBaixa);
    ULOG("idMensagemBaixa = [%s]",(char*)idMensagemBaixa.arr);
	strcpy(_idBaixaMensagem,(char*)idMensagemBaixa.arr);
  }
  catch(...)
  {
		throw;
  }
  ULOG_END("get_idBiaxaMensagem()");
  return 1;
}
    
