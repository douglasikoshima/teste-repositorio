//
// $Id: get_criterios.pcpp,v 1.1 2009/07/31 15:34:48 a5110702 Exp $
//

#include "../../negocio/fidutil/include/retencao.hpp"

int getTipoCliente(XMLGen*xml);
int getClasificacao(XMLGen*xml);
int getGrupo( XMLGen*xml);
int getOferta( XMLGen*xml);
int getOperadora( XMLGen*xml);

int getTipoCliente(XMLGen*xml)
{
	int iCont = 0;
  EXEC SQL BEGIN DECLARE SECTION;
  struct {
			int     idTipoPessoa;
			VARCHAR dsTipoPessoa[255];
	}stTipoCliente;

	struct {
			short   iidTipoPessoa;
			short	idsTipoPessoa;
	}stTipoClienteIndicator;

  EXEC SQL END DECLARE SECTION;

  try{
  
		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		
		//Declara um cursor para listar os Registros
		EXEC SQL DECLARE crsCli CURSOR FOR
		SELECT idTipoPessoa, dsTipoPessoa 
		FROM   apoio.TipoPessoa
		where idTipoPessoa>0
		ORDER BY dsTipoPessoa;

		EXEC SQL WHENEVER SQLERROR GOTO GotoTipoCliente;
		EXEC SQL OPEN crsCli;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			xml->createTag("tns:TipoCliente");
			for(;;) 
			{
					memset(&stTipoCliente,0,sizeof(stTipoCliente));
					EXEC SQL FETCH crsCli INTO :stTipoCliente:stTipoClienteIndicator;
					endOraStr(stTipoCliente.dsTipoPessoa);
					xml->createTag("tns:FidelizacaoTipoClienteVO");
					xml->addItem("id",stTipoCliente.idTipoPessoa);
					xml->addItem("descricao",(char *)stTipoCliente.dsTipoPessoa.arr);
					xml->closeTag();
					iCont++;
			}
			xml->closeTag();
		}

    EXEC SQL CLOSE crsCli;
  }
  catch(...)
  {
	throw;
  }
 
  //Retorna a quantidade de registros
	return iCont;

GotoTipoCliente:
	throw TuxBasicOraException(sqlca.sqlcode);
}


int getClasificacao(XMLGen*xml)
{
	int iCont = 0;
  EXEC SQL BEGIN DECLARE SECTION;
  struct{
			int     idSegmentacao; 
			VARCHAR dsSegmentacao[255]; 
		}stClasificacao;

	struct{
			short iidSegmentacao; 
			short idsSegmentacao;
		}stClasificacaoIndicator;

  EXEC SQL END DECLARE SECTION;
  try{
		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		
		//Declara um cursor para listar os Registros
		
		//Declara um cursor para listar os Registros
		EXEC SQL DECLARE crsClasificacao CURSOR FOR
		SELECT  idSegmentacao, dsSegmentacao 
		FROM    apoio.Segmentacao
		where idSegmentacao>0
		ORDER BY dsSegmentacao;
  
		EXEC SQL WHENEVER SQLERROR GOTO GotoClasificacao;
		EXEC SQL OPEN crsClasificacao;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;

			xml->createTag("tns:Classificacao");
    
			for(;;){
			  memset(&stClasificacao,0,sizeof(stClasificacao));
			  EXEC SQL FETCH crsClasificacao INTO :stClasificacao:stClasificacaoIndicator;
      
			  endOraStr(stClasificacao.dsSegmentacao);
			  xml->createTag("tns:ClassificacaoVO");
			  xml->addItem("id",stClasificacao.idSegmentacao);
			  xml->addItem("descricao",(char*)stClasificacao.dsSegmentacao.arr);
			  xml->closeTag();
			  iCont ++;
			}
			xml->closeTag();

			EXEC SQL CLOSE crsClasificacao;
		}
	}
  catch(...)
  {
	throw;
  }
 
  //Retorna a quantidade de registros
	return iCont;

GotoClasificacao:
	throw TuxBasicOraException(sqlca.sqlcode);
}


int getGrupo( XMLGen*xml )
{
	int iCont = 0;
  EXEC SQL BEGIN DECLARE SECTION;
  struct {
		int     idGrupo;
		VARCHAR nmGrupo[255];
	}stGrupo;
  
  struct {
		short iidGrupo;
		short inmGrupo;
	}stGrupoIndicator;

  EXEC SQL END DECLARE SECTION;
	try{
		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		
		//Declara um cursor para listar os Registros
		EXEC SQL DECLARE crsGrupo CURSOR FOR
		SELECT IDGRUPO,NMGRUPO
		FROM acesso.grupo
		where idGrupo in (select idgrupo 
						  from  retencao.grupomotivoordem)
		ORDER BY nmGrupo;
  
		EXEC SQL WHENEVER SQLERROR GOTO GotoGrupo;
		EXEC SQL OPEN crsGrupo;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;

			xml->createTag("tns:Grupo");
			for(;;) 
			{
				memset(&stGrupo,0,sizeof(stGrupo));
				//EXEC SQL FETCH crsGrupo INTO :idGrupo,:nmGrupo;
				EXEC SQL FETCH crsGrupo INTO :stGrupo:stGrupoIndicator;
				endOraStr(stGrupo.nmGrupo);
				xml->createTag("tns:FidelizacaoGrupoVO");
				xml->addItem("id",stGrupo.idGrupo);
				xml->addItem("descricao",(char *)stGrupo.nmGrupo.arr);
				xml->closeTag();
				iCont++;
			}
			
			xml->closeTag();
  
			EXEC SQL CLOSE crsGrupo;
		}
  }
  catch(...)
  {
	throw;
  }
 
  //Retorna a quantidade de registros
	return iCont;

GotoGrupo:
	throw TuxBasicOraException(sqlca.sqlcode);
  
}


int getOferta( XMLGen*xml )
{
	int iCont = 0;
  EXEC SQL BEGIN DECLARE SECTION;
	struct{
			int     idUnidadeOferta;
			VARCHAR nmOferta[255];
		}stOferta;
	struct{
			short  iidUnidadeOferta;
			short  inmOferta;
		}stOfertaIndicator;


  EXEC SQL END DECLARE SECTION;
  try{
		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		
		//Declara um cursor para listar os Registros
		EXEC SQL DECLARE crsOferta CURSOR FOR
		  SELECT idUnidadeOferta, nmOferta
		  FROM   retencao.oferta 
		  WHERE  inAtivo != 0 and idUnidadeOferta>0
		  ORDER BY nmOferta;

		EXEC SQL WHENEVER SQLERROR GOTO GotoOferta;
		EXEC SQL OPEN crsOferta;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;

			xml->createTag("tns:Oferta");
			for(;;) {
				memset(&stOferta,0,sizeof(stOferta));
				//EXEC SQL FETCH crsOferta INTO :idUnidadeOferta,:nmOferta;
				EXEC SQL FETCH crsOferta INTO :stOferta:stOfertaIndicator;
    
				endOraStr(stOferta.nmOferta);
				ULOG_INT(stOferta.idUnidadeOferta);
				ULOG_VAR(stOferta.nmOferta);
				xml->createTag("tns:OfertaFidelizacaoVO");
				xml->addItem("id",stOferta.idUnidadeOferta);
				xml->addItem("descricao",(char *)stOferta.nmOferta.arr);
				xml->closeTag();
				iCont++;
			}
			xml->closeTag();
			EXEC SQL CLOSE crsOferta;
		}
	  }
  catch(...)
  {
	throw;
  }
 
  //Retorna a quantidade de registros
	return iCont;

GotoOferta:
	throw TuxBasicOraException(sqlca.sqlcode);
}


int getOperadora(XMLGen*xml)
{
	int iCont= 0;
  EXEC SQL BEGIN DECLARE SECTION;
  struct {
			int     idUFOperadora; 
			VARCHAR nmUF[255]; 
		}stOperadora;
	struct {
			short	iidUFOperadora; 
			short	inmUF[255]; 
		}stOperadoraIndicator;
  EXEC SQL END DECLARE SECTION;
  try{
		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;

		//Declara um cursor para listar os Registros
		EXEC SQL DECLARE crsOperadora CURSOR FOR
		 SELECT ufo.IDUFOPERADORA,
			    u.NMUF 
		 FROM apoio.uf u,
		  	  customer.ufoperadora ufo
		 WHERE u.IDUF=ufo.IDUF
		 ORDER BY nmuf;

		EXEC SQL WHENEVER SQLERROR GOTO GotoOperadora;
		EXEC SQL OPEN crsOperadora;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;

			xml->createTag("tns:Operadora");
			for(;;)
			{
				memset(&stOperadora,0,sizeof(stOperadora));
				//EXEC SQL FETCH crsOperadora INTO :idUFOperadora, :nmUF;
				EXEC SQL FETCH crsOperadora INTO :stOperadora:stOperadoraIndicator;
      
				endOraStr(stOperadora.nmUF);
				xml->createTag("tns:OperadoraVO");
				xml->addItem("id",stOperadora.idUFOperadora);
				xml->addItem("descricao",(char*)stOperadora.nmUF.arr);
				xml->closeTag();
				iCont++;
			}
			
			xml->closeTag();
			EXEC SQL CLOSE crsOperadora;
		}
   }
  catch(...)
  {
	throw;
  }
 
  //Retorna a quantidade de registros
	return iCont;

GotoOperadora:
	throw TuxBasicOraException(sqlca.sqlcode);
}
