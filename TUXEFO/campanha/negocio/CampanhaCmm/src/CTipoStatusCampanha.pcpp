#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <CTipoStatusCampanha.h>

CTipoStatusCampanha::CTipoStatusCampanha()
{
}

CTipoStatusCampanha::~CTipoStatusCampanha()
{
}

int CTipoStatusCampanha::Insert( char* csgTipoStatusCampanha, 
					   char* cdsTipoStatusCampanha )
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cAuxidTipoStatusCampanha[21+1];
		char* cAuxsgTipoStatusCampanha  = csgTipoStatusCampanha;
		char* cAuxdsTipoStatusCampanha  = cdsTipoStatusCampanha;
	EXEC SQL END DECLARE SECTION;
	
	ZeraTipoStatusCampanha();
	
	memset( &cAuxidTipoStatusCampanha, 0, sizeof(cAuxidTipoStatusCampanha) );
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
	sqlca.sqlcode=0;
	
	//Pega um id unico e sequencia para a insercao
	EXEC SQL
		SELECT APOIO.TIPOSTATUSCAMPANHASQ.NEXTVAL
		INTO :cAuxidTipoStatusCampanha
		FROM DUAL;

	EXEC SQL 
		INSERT INTO APOIO.TIPOSTATUSCAMPANHA
		  (IDTIPOSTATUSCAMPANHA, 
		   SGTIPOSTATUSCAMPANHA, 
		   DSTIPOSTATUSCAMPANHA)
		VALUES
		  (:cAuxidTipoStatusCampanha, 
		   :cAuxsgTipoStatusCampanha, 
		   :cAuxdsTipoStatusCampanha);  
	
	if( sqlca.sqlcode == 0 )
		return 1;
	else
		return 0;

GotoInsert:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CTipoStatusCampanha::Update( char* cidTipoStatusCampanha, 
                        char* csgTipoStatusCampanha, 
						char* cdsTipoStatusCampanha )
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidTipoStatusCampanha  = cidTipoStatusCampanha;
		char* cAuxsgTipoStatusCampanha  = csgTipoStatusCampanha;
		char* cAuxdsTipoStatusCampanha  = cdsTipoStatusCampanha;
	EXEC SQL END DECLARE SECTION;

	ZeraTipoStatusCampanha();
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
	sqlca.sqlcode=0;
	
	EXEC SQL 
		UPDATE APOIO.TIPOSTATUSCAMPANHA
		   SET SGTIPOSTATUSCAMPANHA  = :cAuxsgTipoStatusCampanha,
		       DSTIPOSTATUSCAMPANHA  = :cAuxdsTipoStatusCampanha
		 WHERE IDTIPOSTATUSCAMPANHA = :cAuxidTipoStatusCampanha;   
	
	if( sqlca.sqlcode == 0 )
		return 1;
	else
		return 0;

GotoUpdate:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}


int CTipoStatusCampanha::ListId( char* cid )
{
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidOra = cid;
		struct
		{
			VARCHAR stidTipoStatusCampanha[21+1];
			VARCHAR stsgTipoStatusCampanha[256+1];
			VARCHAR stdsTipoStatusCampanha[256+1];
		} stTipoStatusCampanhaRegistro;
		struct
		{
			short iidTipoStatusCampanha;
			short isgTipoStatusCampanha;
			short idsTipoStatusCampanha;
		} stTipoStatusCampanhaIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraTipoStatusCampanha();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
	sqlca.sqlcode=0;

   	EXEC SQL DECLARE CursorTipoStatusCampanhaId CURSOR FOR
		SELECT IDTIPOSTATUSCAMPANHA, 
		       SGTIPOSTATUSCAMPANHA, 
		       DSTIPOSTATUSCAMPANHA
		  FROM APOIO.TIPOSTATUSCAMPANHA TIPOSTATUSCAMPANHA
		 WHERE IDMOTIVOTIPOSTATUSCAMPANHA = :cidOra;

	EXEC SQL OPEN CursorTipoStatusCampanhaId;

	if(sqlca.sqlcode)
		return 0;
	else
	{
		for(;;)
		{
			memset( &stTipoStatusCampanhaRegistro, 0, sizeof(stTipoStatusCampanhaRegistro) );
			EXEC SQL FETCH CursorTipoStatusCampanhaId INTO :stTipoStatusCampanhaRegistro:stTipoStatusCampanhaIndicator;

			Add( (char*)stTipoStatusCampanhaRegistro.stidTipoStatusCampanha.arr, 
			     (char*)stTipoStatusCampanhaRegistro.stsgTipoStatusCampanha.arr,
			     (char*)stTipoStatusCampanhaRegistro.stdsTipoStatusCampanha.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorTipoStatusCampanhaId;
	}

	return iCont;

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CTipoStatusCampanha::ListAll( void )
{
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidTipoStatusCampanha[21+1];
			VARCHAR stsgTipoStatusCampanha[256+1];
			VARCHAR stdsTipoStatusCampanha[256+1];
		} stTipoStatusCampanhaRegistro;
		struct
		{
			short iidTipoStatusCampanha;
			short isgTipoStatusCampanha;
			short idsTipoStatusCampanha;
		} stTipoStatusCampanhaIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraTipoStatusCampanha();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
	sqlca.sqlcode=0;

   	EXEC SQL DECLARE CursorTipoStatusCampanhaAll CURSOR FOR
		SELECT IDTIPOSTATUSCAMPANHA, 
		       SGTIPOSTATUSCAMPANHA, 
		       DSTIPOSTATUSCAMPANHA
		  FROM APOIO.TIPOSTATUSCAMPANHA TIPOSTATUSCAMPANHA;

	EXEC SQL OPEN CursorTipoStatusCampanhaAll;

	if(sqlca.sqlcode)
		return 0;
	else
	{
		for(;;)
		{
			memset( &stTipoStatusCampanhaRegistro, 0, sizeof(stTipoStatusCampanhaRegistro) );
			EXEC SQL FETCH CursorTipoStatusCampanhaAll INTO :stTipoStatusCampanhaRegistro:stTipoStatusCampanhaIndicator;

			Add( (char*)stTipoStatusCampanhaRegistro.stidTipoStatusCampanha.arr, 
			     (char*)stTipoStatusCampanhaRegistro.stsgTipoStatusCampanha.arr,
			     (char*)stTipoStatusCampanhaRegistro.stdsTipoStatusCampanha.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorTipoStatusCampanhaAll;
	}

	return iCont;

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CTipoStatusCampanha::GetXml( char* cNomeTag, XMLGen*xml )
{
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			xml->addProp( "xmlns", "campanha.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{
				xml->addItem("idTipoStatusCampanha"  , Registro(x)->cidTipoStatusCampanha );
				xml->addItem("sgTipoStatusCampanha"  , Registro(x)->csgTipoStatusCampanha );
				xml->addItem("dsTipoStatusCampanha"  , Registro(x)->cdsTipoStatusCampanha );
			}
			xml->closeTag();
		}
	}
}
