#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <CTipoApresentacaoPergunta.h>

CTipoApresentacaoPergunta::CTipoApresentacaoPergunta()
{
}

CTipoApresentacaoPergunta::~CTipoApresentacaoPergunta()
{
}

int CTipoApresentacaoPergunta::Insert( char* csgTipoApresentacaoPergunta, 
									   char* cdsTipoApresentacaoPergunta )
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cAuxidTipoApresentacaoPergunta[21+1];
		char* cAuxsgTipoApresentacaoPergunta = csgTipoApresentacaoPergunta;
		char* cAuxdsTipoApresentacaoPergunta = cdsTipoApresentacaoPergunta;
	EXEC SQL END DECLARE SECTION;
	
	ZeraTipoApresentacaoPergunta();
	
	memset( &cAuxidTipoApresentacaoPergunta, 0, sizeof(cAuxidTipoApresentacaoPergunta) );
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
	sqlca.sqlcode=0;
	
	//Pega um id unico e sequencia para a insercao
	EXEC SQL
		SELECT APOIO.TIPOAPRESENTACAOPERGUNTASQ.NEXTVAL
		INTO :cAuxidTipoApresentacaoPergunta
		FROM DUAL;

	EXEC SQL 
		INSERT INTO APOIO.TIPOAPRESENTACAOPERGUNTA
		  (IDTIPOAPRESENTACAOPERGUNTA, 
		   SGTIPOAPRESENTACAOPERGUNTA, 
		   DSTIPOAPRESENTACAOPERGUNTA)
		VALUES
		  (:cAuxidTipoApresentacaoPergunta, 
		   :cAuxsgTipoApresentacaoPergunta, 
		   :cAuxdsTipoApresentacaoPergunta);

	if( sqlca.sqlcode == 0 )
		return 1;
	else
		return 0;

GotoInsert:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CTipoApresentacaoPergunta::Update( char* cidTipoApresentacaoPergunta, 
			                           char* csgTipoApresentacaoPergunta, 
								       char* cdsTipoApresentacaoPergunta )
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidTipoApresentacaoPergunta  = cidTipoApresentacaoPergunta;
		char* cAuxsgTipoApresentacaoPergunta  = csgTipoApresentacaoPergunta;
		char* cAuxdsTipoApresentacaoPergunta  = cdsTipoApresentacaoPergunta;
	EXEC SQL END DECLARE SECTION;

	ZeraTipoApresentacaoPergunta();
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
	sqlca.sqlcode=0;
	
	EXEC SQL 
		UPDATE APOIO.TIPOAPRESENTACAOPERGUNTA
		   SET SGTIPOAPRESENTACAOPERGUNTA = :cAuxsgTipoApresentacaoPergunta,
		       DSTIPOAPRESENTACAOPERGUNTA = :cAuxdsTipoApresentacaoPergunta
		 WHERE IDTIPOAPRESENTACAOPERGUNTA = :cAuxidTipoApresentacaoPergunta;  
	
	if( sqlca.sqlcode == 0 )
		return 1;
	else
		return 0;

GotoUpdate:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}


int CTipoApresentacaoPergunta::ListId( char* cid )
{
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidOra = cid;
		struct
		{
			VARCHAR stidTipoApresentacaoPergunta[21+1];
			VARCHAR stsgTipoApresentacaoPergunta[256+1];
			VARCHAR stdsTipoApresentacaoPergunta[256+1];
		} stTipoApresentacaoPerguntaRegistro;
		struct
		{
			short iidTipoApresentacaoPergunta;
			short isgTipoApresentacaoPergunta;
			short idsTipoApresentacaoPergunta;
		} stTipoApresentacaoPerguntaIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraTipoApresentacaoPergunta();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
	sqlca.sqlcode=0;

   	EXEC SQL DECLARE CursorTipoApresentacaoPerguntaId CURSOR FOR
		SELECT IDTIPOAPRESENTACAOPERGUNTA, 
		       SGTIPOAPRESENTACAOPERGUNTA, 
		       DSTIPOAPRESENTACAOPERGUNTA
		  FROM APOIO.TIPOAPRESENTACAOPERGUNTA TIPOAPRESENTACAOPERGUNTA
		 WHERE IDTIPOAPRESENTACAOPERGUNTA = :cidOra;

	EXEC SQL OPEN CursorTipoApresentacaoPerguntaId;

	if(sqlca.sqlcode)
		return 0;
	else
	{
		for(;;)
		{
			memset( &stTipoApresentacaoPerguntaRegistro, 0, sizeof(stTipoApresentacaoPerguntaRegistro) );
			EXEC SQL FETCH CursorTipoApresentacaoPerguntaId INTO :stTipoApresentacaoPerguntaRegistro:stTipoApresentacaoPerguntaIndicator;

			Add( (char*)stTipoApresentacaoPerguntaRegistro.stidTipoApresentacaoPergunta.arr, 
			     (char*)stTipoApresentacaoPerguntaRegistro.stsgTipoApresentacaoPergunta.arr,
			     (char*)stTipoApresentacaoPerguntaRegistro.stdsTipoApresentacaoPergunta.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorTipoApresentacaoPerguntaId;
	}

	return iCont;

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CTipoApresentacaoPergunta::ListAll( void )
{
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidTipoApresentacaoPergunta[21+1];
			VARCHAR stsgTipoApresentacaoPergunta[256+1];
			VARCHAR stdsTipoApresentacaoPergunta[256+1];
		} stTipoApresentacaoPerguntaRegistro;
		struct
		{
			short iidTipoApresentacaoPergunta;
			short isgTipoApresentacaoPergunta;
			short idsTipoApresentacaoPergunta;
		} stTipoApresentacaoPerguntaIndicator;

	EXEC SQL END DECLARE SECTION;

	ZeraTipoApresentacaoPergunta();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
	sqlca.sqlcode=0;

   	EXEC SQL DECLARE CursorTipoApresentacaoPerguntaAll CURSOR FOR
		SELECT IDTIPOAPRESENTACAOPERGUNTA, 
		       SGTIPOAPRESENTACAOPERGUNTA, 
		       DSTIPOAPRESENTACAOPERGUNTA 
		  FROM APOIO.TIPOAPRESENTACAOPERGUNTA TIPOAPRESENTACAOPERGUNTA;

	EXEC SQL OPEN CursorTipoApresentacaoPerguntaAll;

	if(sqlca.sqlcode)
		return 0;
	else
	{
		for(;;)
		{
			memset( &stTipoApresentacaoPerguntaRegistro, 0, sizeof(stTipoApresentacaoPerguntaRegistro) );
			EXEC SQL FETCH CursorTipoApresentacaoPerguntaAll INTO :stTipoApresentacaoPerguntaRegistro:stTipoApresentacaoPerguntaIndicator;

			Add( (char*)stTipoApresentacaoPerguntaRegistro.stidTipoApresentacaoPergunta.arr, 
			     (char*)stTipoApresentacaoPerguntaRegistro.stsgTipoApresentacaoPergunta.arr,
			     (char*)stTipoApresentacaoPerguntaRegistro.stdsTipoApresentacaoPergunta.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorTipoApresentacaoPerguntaAll;
	}

	return iCont;

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CTipoApresentacaoPergunta::GetXml( char* cNomeTag, XMLGen*xml )
{
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			xml->addProp( "xmlns", "campanha.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{
				xml->addItem("idApresentacao" , Registro(x)->cidTipoApresentacaoPergunta );
				xml->addItem("sgApresentacao" , Registro(x)->csgTipoApresentacaoPergunta );
				xml->addItem("dsApresentacao" , Registro(x)->cdsTipoApresentacaoPergunta );
			}
			xml->closeTag();
		}
	}
}
