#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <CRspPxm.h>


CRespostaProximaPergunta::CRespostaProximaPergunta()
{
}

CRespostaProximaPergunta::~CRespostaProximaPergunta()
{
}

int CRespostaProximaPergunta::Insert( 
				     char* cidResposta,
				     char* cidPergunta,
				     char* cidUsuarioAlteracao )
{
  //Variavel de status do oracle para PROC
  struct sqlca sqlca;
  //Declaracao das variaveis para o PROC
  EXEC SQL BEGIN DECLARE SECTION;
  VARCHAR cAuxidRespPxPerg[21+1];
  char* cAuxinAtivo = "1";
  char* cAuxidResposta = cidResposta;
  char* cAuxidPergunta = cidPergunta;
  char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
  EXEC SQL END DECLARE SECTION;
	
  //Processamento Principal
  try
    {
      //Zera a estrutura da classe
      ZeraRespostaProximaPergunta();
		
      memset( &cAuxidRespPxPerg, 0, sizeof(cAuxidRespPxPerg) ); 
		
      EXEC SQL WHENEVER NOT FOUND CONTINUE;
      EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
		
      //Pega um id unico e sequencia para a insercao
      EXEC SQL SELECT questionario.RespostaProximaPerguntaSQ.NEXTVAL INTO :cAuxidRespPxPerg FROM DUAL;

      //Realiza o insert
      EXEC SQL INSERT INTO questionario.RespostaProximaPergunta 
	(	idRespPxPerg,
		inAtivo,
		idResposta,
		idPergunta,
		idUsuarioAlteracao,
		dtUltimaAlteracao) 
	VALUES 
	(	:cAuxidRespPxPerg,
		:cAuxinAtivo,
		:cAuxidResposta,
		:cAuxidPergunta,
		:cAuxidUsuarioAlteracao,
		SYSDATE);

      //Verifica se houve ou nao erro ORACLE
      if(sqlca.sqlcode) {
	return 0;//Erro
      }
      else {
	return 1;//Sucesso
      }
    }
  catch(...)
    {
      throw;
    }
	
 GotoInsert:
  throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CRespostaProximaPergunta::Update( 
				     char* cidRespPxPerg,
				     char* cinAtivo,
				     char* cidResposta,
				     char* cidPergunta,
				     char* cidUsuarioAlteracao )
{
  //Variavel de status do oracle para PROC
  struct sqlca sqlca;
  //Declaracao das variaveis para o PROC
  EXEC SQL BEGIN DECLARE SECTION;
		
  char* cAuxidRespPxPerg = cidRespPxPerg;
  char* cAuxinAtivo = cinAtivo;
  char* cAuxidResposta = cidResposta;
  char* cAuxidPergunta = cidPergunta;
  char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
  EXEC SQL END DECLARE SECTION;

  //Processamento Principal
  try
    {
      //Zera a estrutura da classe
      ZeraRespostaProximaPergunta();
		
      //Ativa as acoes decorrentes de erros ORACLE
      EXEC SQL WHENEVER NOT FOUND CONTINUE;
      EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
		
      //Executa a instrucao de update
      EXEC SQL 
	UPDATE questionario.RespostaProximaPergunta 
	SET 	inAtivo = :cAuxinAtivo,
	idResposta = :cAuxidResposta,
	idPergunta = :cAuxidPergunta,
	idUsuarioAlteracao = :cAuxidUsuarioAlteracao,
	dtUltimaAlteracao = SYSDATE
	WHERE 	idRespPxPerg = :cAuxidRespPxPerg;   
		
      //Verifica se houve ou nao erro ORACLE
      if(sqlca.sqlcode)
	return 0;//Erro
      else
	return sqlca.sqlerrd[2];//Quantidade de linhas afetadas
    }
  catch(...)
    {
      throw;
    }

 GotoUpdate:
  throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CRespostaProximaPergunta::UpdIns( char* cidResposta,
				      char* cidPergunta,
				      char* cidUsuarioAlteracao )
{
  //Variavel de status do oracle para PROC
  struct sqlca sqlca;
  //Declaracao das variaveis para o PROC
  EXEC SQL BEGIN DECLARE SECTION;
  char* cAuxidResposta = cidResposta;
  char* cAuxidPergunta = cidPergunta;
  char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
  int idRespPxPerg=0; 	
  EXEC SQL END DECLARE SECTION;

  //Processamento Principal
  try
    {
      //Zera a estrutura da classe
      ZeraRespostaProximaPergunta();
		
      //Ativa as acoes decorrentes de erros ORACLE
      EXEC SQL WHENEVER NOT FOUND CONTINUE;
      EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;

      if(atoi(cAuxidPergunta) > 0)
      {
      //Executa a instrucao de update
      EXEC SQL 
	UPDATE questionario.RespostaProximaPergunta 
	SET  idPergunta = :cAuxidPergunta,
	idUsuarioAlteracao = :cAuxidUsuarioAlteracao,
	dtUltimaAlteracao = SYSDATE
	WHERE 	idResposta = :cAuxidResposta
	AND     inAtivo = 1;
      }		
      else if(atoi(cAuxidPergunta) == 0)
      {
      //Executa a instrucao de update
      EXEC SQL 
	UPDATE questionario.RespostaProximaPergunta 
	SET    idUsuarioAlteracao = :cAuxidUsuarioAlteracao,
	       dtUltimaAlteracao = SYSDATE,
               inativo = 0
	WHERE  idResposta = :cAuxidResposta;
      }		

      // Verificar se existia o registro, caso contrario inserir
      // if(!sqlca.sqlcode)
      if (sqlca.sqlerrd[2] == 0)
      {
		EXEC SQL
		
		  SELECT idRespPxPerg INTO :idRespPxPerg
		  FROM   questionario.RespostaProximaPergunta
		  WHERE  idResposta = :cAuxidResposta
		  AND    idpergunta=:cAuxidPergunta
		  AND	 inativo=0;

		
		if(idRespPxPerg>0)
		 {
		  EXEC SQL
		  update questionario.RespostaProximaPergunta
		  set inativo=1
		  where  idRespPxPerg  = :idRespPxPerg;
		 }
		else
		{
		
		EXEC SQL INSERT INTO questionario.RespostaProximaPergunta
          (     idRespPxPerg,
                inAtivo,
                idResposta,
                idPergunta,
                idUsuarioAlteracao,
                dtUltimaAlteracao)
          VALUES
          (     questionario.RespostaProximaPerguntaSQ.NEXTVAL,
                1,
                :cAuxidResposta,
                :cAuxidPergunta,
                :cAuxidUsuarioAlteracao,
                SYSDATE);
		}
      }

      //Verifica se houve ou nao erro ORACLE
      if(sqlca.sqlcode)
	return 0;//Erro
      else
	return sqlca.sqlerrd[2];//Quantidade de linhas afetadas
    }
  catch(...)
    {
      throw;
    }

 GotoUpdate:
  throw TuxBasicOraException(sqlca.sqlcode);
	
}


int CRespostaProximaPergunta::Delete( char* cidRespPxPerg )
{
  //Variavel de status do oracle para PROC
  struct sqlca sqlca;
  //Declaracao das variaveis para o PROC
  EXEC SQL BEGIN DECLARE SECTION;	
  char* cAuxidRespPxPerg = cidRespPxPerg; 
  EXEC SQL END DECLARE SECTION;
	
  //Processamento Principal
  try
    {
      //Zera a estrutura da classe
      ZeraRespostaProximaPergunta();
		
      //Ativa as acoes decorrentes de erros ORACLE
      EXEC SQL WHENEVER NOT FOUND CONTINUE;
      EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
      sqlca.sqlcode=0;
		
      //Executa a instrucao de delecao
      EXEC SQL DELETE FROM questionario.RespostaProximaPergunta 		
	WHERE (idRespPxPerg = :cAuxidRespPxPerg);
		
      //Verifica se houve ou nao erro ORACLE
      if(sqlca.sqlcode)
	return 0;//Erro
      else
	return sqlca.sqlerrd[2];//Quantidade de linhas afetadas
    }
  catch(...)
    {
      throw;
    }

 GotoDelete:
  throw TuxBasicOraException(sqlca.sqlcode);
}

int CRespostaProximaPergunta::ListId( char* cidRespPxPerg ) 
{
  //Variavel de controle para a quantidade de registros retornada
  int    iCont = 0;
  //Variavel de status do oracle para PROC
  struct sqlca sqlca;
  //Declaracao das variaveis para o PROC
  EXEC SQL BEGIN DECLARE SECTION;
  char* cAuxidRespPxPerg = cidRespPxPerg; 
  struct
  {
    VARCHAR stidRespPxPerg[21+1];
    VARCHAR stinAtivo[21+1];
    VARCHAR stidResposta[21+1];
    VARCHAR stidPergunta[21+1];
  } stRespostaProximaPerguntaRegistro;
  struct
  {
    short iidRespPxPerg;
    short iinAtivo;
    short iidResposta;
    short iidPergunta;
  } stRespostaProximaPerguntaIndicator;
  EXEC SQL END DECLARE SECTION;

  //Processamento Principal
  try
    {
      //Zera a estrutura da classe
      ZeraRespostaProximaPergunta();

      //Ativa as acoes decorrentes de erros ORACLE
      EXEC SQL WHENEVER NOT FOUND DO break;
      EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
      sqlca.sqlcode=0;

      //Declara um cursor para listar os IDs
      EXEC SQL DECLARE CursorRespostaProximaPerguntaId CURSOR FOR 
	SELECT 	idRespPxPerg,
	inAtivo,
	idResposta,
	idPergunta
	FROM questionario.RespostaProximaPergunta
	WHERE idRespPxPerg = :cAuxidRespPxPerg;

      //Abre o cursor
      EXEC SQL OPEN CursorRespostaProximaPerguntaId;

      //Verifica se nao house erro ORACLE
      if(sqlca.sqlcode)
	return 0;//Erro
      else
	{
	  //Caso inexista registros sair do loop
	  EXEC SQL WHENEVER NOT FOUND DO break;
	  for(;;)
	    {
	      //Zera a estrutura de restorno
	      memset( &stRespostaProximaPerguntaRegistro, 0, sizeof(stRespostaProximaPerguntaRegistro) );
	      //Pega um registro no CURSOR
	      EXEC SQL FETCH CursorRespostaProximaPerguntaId INTO :stRespostaProximaPerguntaRegistro:stRespostaProximaPerguntaIndicator;
	      //Adiciona a classe
	      Add((char*)stRespostaProximaPerguntaRegistro.stidRespPxPerg.arr,
			(char*)stRespostaProximaPerguntaRegistro.stinAtivo.arr,
			(char*)stRespostaProximaPerguntaRegistro.stidResposta.arr,
			(char*)stRespostaProximaPerguntaRegistro.stidPergunta.arr );
	      //conta quantos existem
	      iCont++;
	    }
	  //Fecha o CURSOR
	  EXEC SQL CLOSE CursorRespostaProximaPerguntaId;
	}
      //Retorna a quantidade de registros
      return iCont;
    }
  catch(...)
    {
      throw;
    }

 GotoListId:
  throw TuxBasicOraException(sqlca.sqlcode);

}

int CRespostaProximaPergunta::ListAll( void )
{
  //Variavel de controle para a quantidade de registros retornada
  int    iCont = 0;
  //Variavel de status do oracle para PROC
  struct sqlca sqlca;
  //Declaracao das variaveis para o PROC
  EXEC SQL BEGIN DECLARE SECTION;
  struct
  {
    VARCHAR stidRespPxPerg[21+1];
    VARCHAR stinAtivo[21+1];
    VARCHAR stidResposta[21+1];
    VARCHAR stidPergunta[21+1];
  } stRespostaProximaPerguntaRegistro;
  struct
  {
    short iidRespPxPerg;
    short iinAtivo;
    short iidResposta;
    short iidPergunta;
  } stRespostaProximaPerguntaIndicator;
  EXEC SQL END DECLARE SECTION;

  //Processamento Principal
  try
    {
      //Zera a estrutura da classe
      ZeraRespostaProximaPergunta();

      //Ativa as acoes decorrentes de erros ORACLE
      EXEC SQL WHENEVER NOT FOUND DO break;
      EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
      sqlca.sqlcode=0;

      //Declara um cursor para listar todos os registros
      EXEC SQL DECLARE CursorRespostaProximaPerguntaAll CURSOR FOR
	SELECT 	idRespPxPerg,
	inAtivo,
	idResposta,
	idPergunta
	FROM questionario.RespostaProximaPergunta; 

      //Abre o cursor
      EXEC SQL OPEN CursorRespostaProximaPerguntaAll;

      //Verifica se nao house erro ORACLE
      if(sqlca.sqlcode)
	return 0;//Erro
      else
	{
	  //Caso inexista registros sair do loop
	  EXEC SQL WHENEVER NOT FOUND DO break;
	  for(;;)
	    {
	      //Zera a estrutura de restorno
	      memset( &stRespostaProximaPerguntaRegistro, 0, sizeof(stRespostaProximaPerguntaRegistro) );
	      //Pega um registro no CURSOR
	      EXEC SQL FETCH CursorRespostaProximaPerguntaAll INTO :stRespostaProximaPerguntaRegistro:stRespostaProximaPerguntaIndicator;
	      
		  //Adiciona a classe
	      Add( 	(char*)stRespostaProximaPerguntaRegistro.stidRespPxPerg.arr,
			(char*)stRespostaProximaPerguntaRegistro.stinAtivo.arr,
			(char*)stRespostaProximaPerguntaRegistro.stidResposta.arr,
			(char*)stRespostaProximaPerguntaRegistro.stidPergunta.arr );
	      
		  //conta quantos existem
	      iCont++;
	    }
	  //Fecha o cursor
	  EXEC SQL CLOSE CursorRespostaProximaPerguntaAll;
	}
      //Retorna a quantidade de registros
      return iCont;
    }
  catch(...)
    {
      throw;
    }

 GotoListAll:
  throw TuxBasicOraException(sqlca.sqlcode);

}

void CRespostaProximaPergunta::GetXml( char* cNomeTag, XMLGen*xml )
{
  //Soh monta o XML padrao se existir algum registro para isto
  if( Quantidade() > 0 )
    {
      //Corre todos os registros do iterator
      for( int x = 0; x < Quantidade(); x++ )
	{
	  //Caso nao tenha recebido uma tag padrao, deixa sem
	  xml->createTag(cNomeTag);
	  
	  //Adiciona a proprieda necessaria para o Weblogic
	  xml->addProp( "xmlns", "campanhas.fo.vivo.com.br/vo" );

	  //Para garantir que existe um registro
	  if( Registro( x ) != NULL )
	    { 
	      //Adiciona as tags necessarias

	      xml->addItem("idRespPxPerg", Registro(x)->cidRespPxPerg );
	      xml->addItem("inAtivo", Registro(x)->cinAtivo );
	      xml->addItem("idResposta", Registro(x)->cidResposta );
	      xml->addItem("idPergunta", Registro(x)->cidPergunta ); 
	    }
	  
	  //So fecha um tag se abriu anteriormente
	  xml->closeTag();
	}
  }
}

//#################################################################
//#  Retorno de idrepostaproxima pergunta e inativo				  #
//#################################################################

int  CRespostaProximaPergunta::DelIdRespProximaPergunta(char* cidResposta,char* cidPergunta)
{

 //Variavel de status do oracle para PROC
  struct sqlca sqlca;
  //Declaracao das variaveis para o PROC
  EXEC SQL BEGIN DECLARE SECTION;	
  char* idResposta = cidResposta; 
  EXEC SQL END DECLARE SECTION;
	
  //Processamento Principal
  try
    {
      //Zera a estrutura da classe
      ZeraRespostaProximaPergunta();
		
      //Ativa as acoes decorrentes de erros ORACLE
      EXEC SQL WHENEVER NOT FOUND CONTINUE;
      EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
      sqlca.sqlcode=0;
		
      //Executa a instrucao de delecao
      EXEC SQL UPDATE questionario.RespostaProximaPergunta 		
	  SET INATIVO=0
	  WHERE (idResposta = :idResposta);

	if(sqlca.sqlcode<0)
	{
		return 0;
	}	
	else 
	{
		return 1;
	}
	 
    }
  catch(...)
    {
      throw;
    }

 GotoDelete:
return 0; 
  //throw TuxBasicOraException(sqlca.sqlcode);
 

}
