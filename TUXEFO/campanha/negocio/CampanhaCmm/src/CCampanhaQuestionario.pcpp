#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
#include <tuxfw.h>

#include <CCampanhaQuestionario.h>

CCampanhaQuestionario::CCampanhaQuestionario()
{
}

CCampanhaQuestionario::~CCampanhaQuestionario()
{
}

int CCampanhaQuestionario::Insert( char* cidCanalCampanha, 
							       char* cidPergunta,
							       char* cidUser )
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cAuxidCampanhaQuestionario[21+1];
		char* cAuxidCanalCampanha = cidCanalCampanha;
		char* cAuxidPergunta = cidPergunta;
		char* cAuxidUser = cidUser;
		int	iCount = 0;
	EXEC SQL END DECLARE SECTION;
		
	ZeraCampanhaQuestionario();
	memset( &cAuxidCampanhaQuestionario, 0,sizeof( cAuxidCampanhaQuestionario ) );
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
	sqlca.sqlcode=0;

	
	EXEC SQL
		SELECT CAMPANHA.CAMPANHAQUESTIONARIOSQ.NEXTVAL
		  INTO :cAuxidCampanhaQuestionario
		  FROM DUAL;

	EXEC SQL 
		INSERT INTO CAMPANHA.CAMPANHAQUESTIONARIO
		  (IDCAMPANHAQUESTIONARIO, 
		   IDCANALCAMPANHA, 
		   IDPERGUNTA,
		   IDUSUARIOALTERACAO,
		   DTULTIMAALTERACAO )
		VALUES
		  (:cAuxidCampanhaQuestionario, 
		   :cAuxidCanalCampanha, 
		   :cAuxidPergunta,
		   :cAuxidUser,
		   SYSDATE );
		   
	Add( (char*)cAuxidCampanhaQuestionario.arr, 
         cAuxidCanalCampanha, 
         cAuxidPergunta,
         ""
	   );
	
	return 0;
GotoInsert:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CCampanhaQuestionario::Insert( char* cidCanalCampanha, 
							       char* cidPergunta,
							       char* cinAtivo,
							       char* cidUser )
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR stidCampanhaQuestionario[21+1];
		char* cAuxidCanalCampanha = cidCanalCampanha;
		char* cAuxidPergunta = cidPergunta;
		char* cAuxinAtivo = cinAtivo;
		char* cAuxidUser = cidUser;
				
		int	iCount = 0;
	EXEC SQL END DECLARE SECTION;
		
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert2;
	sqlca.sqlcode=0;
	memset( &stidCampanhaQuestionario, 0,sizeof( stidCampanhaQuestionario ) );
	
	EXEC SQL
		SELECT 
			CAMPANHA.CAMPANHAQUESTIONARIOSQ.NEXTVAL
		INTO 
			:stidCampanhaQuestionario
		FROM DUAL;

	EXEC SQL 
		INSERT INTO CAMPANHA.CAMPANHAQUESTIONARIO
		(
			IDCAMPANHAQUESTIONARIO, 
		   	IDCANALCAMPANHA, 
		   	IDPERGUNTA,
		   	INATIVO,
		   	IDUSUARIOALTERACAO,
		   	DTULTIMAALTERACAO 
		)
		VALUES
		(
			:stidCampanhaQuestionario, 
		   	:cAuxidCanalCampanha, 
		   	:cAuxidPergunta,
		   	:cAuxinAtivo,
		   	:cAuxidUser,
		   	SYSDATE
		);
		
		Add( (char*)stidCampanhaQuestionario.arr,
		     cAuxidCanalCampanha,
		     cAuxidPergunta,
		     cAuxinAtivo
		);
	
	return 1;

GotoInsert2:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CCampanhaQuestionario::Update( char* cidCampanhaQuestionario, 
							       char* cidCanalCampanha, 
							       char* cidPergunta,
							       char* cidUser )
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidCampanhaQuestionario = cidCampanhaQuestionario;
		char* cAuxidCanalCampanha = cidCanalCampanha;
		char* cAuxidPergunta = cidPergunta;
		char* cAuxidUser = cidUser;
	EXEC SQL END DECLARE SECTION;

	ZeraCampanhaQuestionario();
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
	sqlca.sqlcode=0;
	
	EXEC SQL 
		UPDATE CAMPANHA.CAMPANHAQUESTIONARIO
		   SET IDCANALCAMPANHA = :cAuxidCanalCampanha,
		       IDPERGUNTA = :cAuxidPergunta,
		       IDUSUARIOALTERACAO = :cAuxidUser,
		       DTULTIMAALTERACAO = SYSDATE
		 WHERE IDCAMPANHAQUESTIONARIO = :cAuxidCampanhaQuestionario;   
	
	if( sqlca.sqlcode == 0 )
		return 1;
	else
		return 0;

GotoUpdate:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CCampanhaQuestionario::Remove( char* cidCampanhaQuestionario,
							       char* cidUser )
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidCampanhaQuestionario = cidCampanhaQuestionario;
		char* cAuxidUser = cidUser;
	EXEC SQL END DECLARE SECTION;

	ZeraCampanhaQuestionario();
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoRemove;
	sqlca.sqlcode=0;
	
//Coloque seu codigo de delecao aqui abaixo
	EXEC SQL 
		UPDATE CAMPANHA.CAMPANHAQUESTIONARIO
		   SET IDUSUARIOALTERACAO = :cAuxidUser,
		       DTULTIMAALTERACAO = SYSDATE
		 WHERE IDCAMPANHAQUESTIONARIO = :cAuxidCampanhaQuestionario;
//Coloque seu codigo de delecao aqui acima
	
	if( sqlca.sqlcode == 0 )
		return 1;
	else
		return 0;

GotoRemove:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CCampanhaQuestionario::ListId( char* cid )
{
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidOra = cid;
		struct
		{
			VARCHAR stidCampanhaQuestionario[21+1];
			VARCHAR stidCanalCampanha[21+1];
			VARCHAR stidPergunta[21+1];
			VARCHAR stidUser[21+1];
			VARCHAR stdtUltimaAlteracao[21+1];
		} stCampanhaQuestionarioRegistro;
		struct
		{
			short iidCampanhaQuestionario;
			short iidCanalCampanha;
			short iidPergunta;
			short iidUser;
			short idtUltimaAlteracao;
		} stCampanhaQuestionarioIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraCampanhaQuestionario();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
	sqlca.sqlcode=0;

   	EXEC SQL DECLARE CursorCampanhaQuestionarioId CURSOR FOR
		SELECT IDCAMPANHAQUESTIONARIO, 
		       IDPERGUNTA, 
		       IDCANALCAMPANHA,
		       IDUSUARIOALTERACAO,
		       DTULTIMAALTERACAO
		  FROM CAMPANHA.CAMPANHAQUESTIONARIO
		 WHERE IDCAMPANHAQUESTIONARIO = :cidOra;

	EXEC SQL OPEN CursorCampanhaQuestionarioId;

	if(sqlca.sqlcode)
		return 0;
	else
	{
		for(;;)
		{
			memset( &stCampanhaQuestionarioRegistro, 0, sizeof(stCampanhaQuestionarioRegistro) );
			EXEC SQL FETCH CursorCampanhaQuestionarioId INTO :stCampanhaQuestionarioRegistro:stCampanhaQuestionarioIndicator;

			Add( (char*)stCampanhaQuestionarioRegistro.stidCampanhaQuestionario.arr,
			     (char*)stCampanhaQuestionarioRegistro.stidCanalCampanha.arr,
			     (char*)stCampanhaQuestionarioRegistro.stidPergunta.arr,
			     (char*)stCampanhaQuestionarioRegistro.stidUser.arr,
			     (char*)stCampanhaQuestionarioRegistro.stdtUltimaAlteracao.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorCampanhaQuestionarioId;
	}

	return iCont;

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CCampanhaQuestionario::ListIdCanalCampanha( char* cidCanalCampanha )
{
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidCanalCampanha = cidCanalCampanha;
		struct
		{
			VARCHAR stidCampanhaQuestionario[21+1];
			VARCHAR stidCanalCampanha[21+1];
			VARCHAR stidPergunta[21+1];
			VARCHAR stinAtivo[21+1];
		} stRegistro;
		struct
		{
			short iidCampanhaQuestionario;
			short iidCanalCampanha;
			short iidPergunta;
			short iinAtivo;
		} stIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraCampanhaQuestionario();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListIdCanalCampanha;
	sqlca.sqlcode=0;

   	EXEC SQL DECLARE CursorListIdCanalCampanha CURSOR FOR
		SELECT 
			IDCAMPANHAQUESTIONARIO, 
		    IDCANALCAMPANHA,
		    IDPERGUNTA, 
		    INATIVO
		FROM 
		 	CAMPANHA.CAMPANHAQUESTIONARIO
		WHERE 
			IDCANALCAMPANHA = :cAuxidCanalCampanha;

	EXEC SQL OPEN CursorListIdCanalCampanha;

	for(;;)
	{
		memset( &stRegistro, 0, sizeof(stRegistro) );
		EXEC SQL FETCH CursorListIdCanalCampanha INTO :stRegistro:stIndicator;

		Add( (char*)stRegistro.stidCampanhaQuestionario.arr,
		     (char*)stRegistro.stidCanalCampanha.arr,
		     (char*)stRegistro.stidPergunta.arr,
		     (char*)stRegistro.stinAtivo.arr
		);

		iCont++;

	}
	EXEC SQL CLOSE CursorListIdCanalCampanha;

	return iCont;

GotoListIdCanalCampanha:
	throw TuxBasicOraException(sqlca.sqlcode);

}


int CCampanhaQuestionario::ListAll( void )
{
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidCampanhaQuestionario[21+1];
			VARCHAR stidCanalCampanha[21+1];
			VARCHAR stidPergunta[21+1];
			VARCHAR stidUser[21+1];
			VARCHAR stdtUltimaAlteracao[21+1];
		} stCampanhaQuestionarioRegistro;
		struct
		{
			short iidCampanhaQuestionario;
			short iidCanalCampanha;
			short iidPergunta;
			short iidUser;
			short idtUltimaAlteracao;
		} stCampanhaQuestionarioIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraCampanhaQuestionario();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
	sqlca.sqlcode=0;

   	EXEC SQL DECLARE CursorCampanhaQuestionarioAll CURSOR FOR
		SELECT IDCAMPANHAQUESTIONARIO, 
		       IDPERGUNTA, 
		       IDCANALCAMPANHA,
		       IDUSUARIOALTERACAO,
		       DTULTIMAALTERACAO
		  FROM CAMPANHA.CAMPANHAQUESTIONARIO;

	EXEC SQL OPEN CursorCampanhaQuestionarioAll;

	if(sqlca.sqlcode)
		return 0;
	else
	{
		for(;;)
		{
			memset( &stCampanhaQuestionarioRegistro, 0, sizeof(stCampanhaQuestionarioRegistro) );
			EXEC SQL FETCH CursorCampanhaQuestionarioAll INTO :stCampanhaQuestionarioRegistro:stCampanhaQuestionarioIndicator;

			Add( (char*)stCampanhaQuestionarioRegistro.stidCampanhaQuestionario.arr,
			     (char*)stCampanhaQuestionarioRegistro.stidCanalCampanha.arr,
			     (char*)stCampanhaQuestionarioRegistro.stidPergunta.arr,
			     (char*)stCampanhaQuestionarioRegistro.stidUser.arr,
			     (char*)stCampanhaQuestionarioRegistro.stdtUltimaAlteracao.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorCampanhaQuestionarioAll;
	}

	return iCont;

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CCampanhaQuestionario::GetXml( char* cNomeTag, XMLGen*xml )
{
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			xml->addProp(	"xmlns", "camapanha.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{
				xml->addItem("idCampanhaQuestionario", Registro(x)->cidCampanhaQuestionario  );
				xml->addItem("idCanalCampanha", Registro(x)->cidCanalCampanha    );
				xml->addItem("idPergunta", Registro(x)->cidPergunta    );
			}
			xml->closeTag();
		}
	}
}


int CCampanhaQuestionario::ExistePergunta(	DOMNode*dnode,
											char* cdsScriptPergunta,int op,char *idperg)
{
	struct sqlca sqlca;
	int iExiste = 0;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxdsScriptPergunta  = cdsScriptPergunta;
		char* cidAuxCanalCampanha;
		int	  cidCanalCampanha = 0;
		int   iCanalCampanha = 0;
		int   idPergunta=atoi(idperg);
		//short iiCanalCampanhaIndicator;
	EXEC SQL END DECLARE SECTION;

	TuxHelper tuxHelper;
	int iSubno = 0;
    int iNroObjCta = 0;
    DOMNode *pNoConta;
	DOMNode *pConta;

	ULOGI("CampanhaQuestionario - Entrou");

	//Processamento Principal
try
{
	if(!op)
	{	EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoExisteCanalCampanha;
		sqlca.sqlcode=0;

		iNroObjCta = 0;

		ULOGI("CampanhaQuestionario - 1 if");
		
		pConta = tuxHelper.walkDOM(dnode, "CanalUtil", iNroObjCta);
		
		for(iNroObjCta = 0; (pNoConta = tuxHelper.walkDOM(dnode, "ApoioCanalVO", iNroObjCta)) ;  iNroObjCta++)
		{
//			cidAuxCanalCampanha= tuxHelper.walkTree( pNoConta, "idCanalCampanha", iNroObjCta ); 
			cidAuxCanalCampanha= tuxHelper.walkTree( dnode, "idCanalCampanha", iNroObjCta ); 
			
			EXEC SQL 
			SELECT COUNT(a.IDCANALCAMPANHA)
			into  :iCanalCampanha
			FROM	campanha.campanhaquestionario a,
					questionario.pergunta b
			WHERE a.IDPERGUNTA=b.IDPERGUNTA
			AND  idcanalcampanha=:cidAuxCanalCampanha
			AND UPPER(TRIM(dsscriptpergunta)) = UPPER(TRIM(:cAuxdsScriptPergunta))
			AND inativo = 1;
			
			if (iCanalCampanha != 0)
				{
					//return iCanalCampanha;
					iExiste = iCanalCampanha;
				}
			iCanalCampanha  = 0;
	
		}//for
	}
	else
	{

		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoExisteCanalCampanha;
		sqlca.sqlcode=0;

		iNroObjCta = 0;

		ULOGI("CampanhaQuestionario - 2 if");

		pConta = tuxHelper.walkDOM(dnode, "CanalUtil", iNroObjCta);
		
		for(iNroObjCta = 0; (pNoConta = tuxHelper.walkDOM(dnode, "ApoioCanalVO", iNroObjCta)) ;  iNroObjCta++)
		{
			cidAuxCanalCampanha= tuxHelper.walkTree( dnode, "idCanalCampanha", iNroObjCta ); 
		
			EXEC SQL 
			SELECT COUNT(a.IDCANALCAMPANHA)
			into  :iCanalCampanha
			FROM	campanha.campanhaquestionario a,
					questionario.pergunta b
			WHERE a.IDPERGUNTA=b.IDPERGUNTA
			AND  idcanalcampanha=:cidAuxCanalCampanha
			and  a.idpergunta!=:idPergunta
			AND UPPER(TRIM(dsscriptpergunta)) = UPPER(TRIM(:cAuxdsScriptPergunta));
			
			if (iCanalCampanha != 0)
			{
				//return iCanalCampanha;
				iExiste = iCanalCampanha;
			}
			iCanalCampanha  = 0;
		
		}//for
	}
		
		return iExiste;

	}
	catch(...)
	{
		throw;
	}

GotoExisteCanalCampanha:
	throw TuxBasicOraException(sqlca.sqlcode);
}



int CCampanhaQuestionario::ExistePerguntaEnCanal( char* cidCanalCampanha, char *cidPergunta )
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidCanalCampanha = cidCanalCampanha;
		char* cAuxidPergunta = cidPergunta;
		int iCont = 0;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoExistePerguntaEnCanal;
	sqlca.sqlcode=0;
	
	EXEC SQL

	SELECT	COUNT(idpergunta)
		INTO :iCont	
		FROM CAMPANHA.CAMPANHAQUESTIONARIO
		WHERE IDPERGUNTA = :cAuxidPergunta 
		AND IDCANALCAMPANHA =:cAuxidCanalCampanha;


	if(sqlca.sqlcode)
		return 0;
	else
		return ( iCont <= 0 ? 0 : 1 );

GotoExistePerguntaEnCanal:
	throw TuxBasicOraException(sqlca.sqlcode);

}