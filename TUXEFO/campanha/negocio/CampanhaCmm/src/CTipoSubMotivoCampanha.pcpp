#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <CTipoSubMotivoCampanha.h>

CTipoSubMotivoCampanha::CTipoSubMotivoCampanha()
{
}

CTipoSubMotivoCampanha::~CTipoSubMotivoCampanha()
{
}

int CTipoSubMotivoCampanha::Insert( char* csgTipoSubMotivoCampanha, 
									char* cdsTipoSubMotivoCampanha, 
									char* cinDisponibilidade, 
									char* cidPessoaUsuarioInclusao,
									char* cidPessoaUsuarioAlteracao,
								    char* cdtInclusao,
								    char* cdtAlteracao,
									char* cinAtivo )
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cAuxidTipoSubMotivoCampanha[21+1];
		char* cAuxsgTipoSubMotivoCampanha = csgTipoSubMotivoCampanha;
		char* cAuxdsTipoSubMotivoCampanha = cdsTipoSubMotivoCampanha;
		char* cAuxinDisponibilidade = cinDisponibilidade;
		char* cAuxidPessoaUsuarioInclusao = cidPessoaUsuarioInclusao;
		char* cAuxidPessoaUsuarioAlteracao = cidPessoaUsuarioAlteracao;
		char* cAuxdtInclusao = cdtInclusao;
		char* cAuxdtAlteracao = cdtAlteracao;
		char* cAuxinAtivo = cinAtivo;
	EXEC SQL END DECLARE SECTION;
	
	ZeraTipoSubMotivoCampanha();
	
	memset( &cAuxidTipoSubMotivoCampanha, 0, sizeof(cAuxidTipoSubMotivoCampanha) );
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
	sqlca.sqlcode=0;
	
	//Pega um id unico e sequencia para a insercao
	EXEC SQL
		SELECT APOIO.TIPOSUBMOTIVOCAMPANHASQ.NEXTVAL
		INTO :cAuxidTipoSubMotivoCampanha
		FROM DUAL;

	EXEC SQL 
		INSERT INTO APOIO.TIPOSUBMOTIVOCAMPANHA
		  (IDTIPOSUBMOTIVOCAMPANHA, 
		   SGTIPOSUBMOTIVOCAMPANHA, 
		   DSTIPOSUBMOTIVOCAMPANHA, 
		   INDISPONIBILIDADE, 
		   IDPESSOAUSUARIOINCLUSAO, 
		   IDPESSOAUSUARIOALTERACAO, 
		   DTINCLUSAO, 
		   DTALTERACAO, 
		   INATIVO)
		VALUES
		  (:cAuxidTipoSubMotivoCampanha, 
		   :cAuxsgTipoSubMotivoCampanha, 
		   :cAuxdsTipoSubMotivoCampanha, 
		   :cAuxinDisponibilidade, 
		   :cAuxidPessoaUsuarioInclusao, 
		   :cAuxidPessoaUsuarioAlteracao, 
		   :cAuxdtInclusao, 
		   :cAuxdtAlteracao, 
		   :cAuxinAtivo);
		   
	if( sqlca.sqlcode == 0 )
		return 1;
	else
		return 0;

GotoInsert:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CTipoSubMotivoCampanha::Update( char* cidTipoSubMotivoCampanha, 
			                        char* csgTipoSubMotivoCampanha, 
								    char* cdsTipoSubMotivoCampanha, 
								    char* cinDisponibilidade, 
								    char* cidPessoaUsuarioInclusao,
								    char* cidPessoaUsuarioAlteracao,
								    char* cdtInclusao,
								    char* cdtAlteracao,
								    char* cinAtivo )
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidTipoSubMotivoCampanha  = cidTipoSubMotivoCampanha;
		char* cAuxsgTipoSubMotivoCampanha  = csgTipoSubMotivoCampanha;
		char* cAuxdsTipoSubMotivoCampanha  = cdsTipoSubMotivoCampanha;
		char* cAuxinDisponibilidade  = cinDisponibilidade;
		char* cAuxidPessoaUsuarioInclusao = cidPessoaUsuarioInclusao;
		char* cAuxidPessoaUsuarioAlteracao  = cidPessoaUsuarioAlteracao;
		char* cAuxdtInclusao = cdtInclusao;
		char* cAuxdtAlteracao     = cdtAlteracao;
		char* cAuxinAtivo = cinAtivo;
	EXEC SQL END DECLARE SECTION;

	ZeraTipoSubMotivoCampanha();
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
	sqlca.sqlcode=0;
	
	EXEC SQL 
		UPDATE APOIO.SUBCAMPANHAHISTORICO
		   SET SGTIPOSUBMOTIVOCAMPANHA = :cAuxsgTipoSubMotivoCampanha,
		       DSTIPOSUBMOTIVOCAMPANHA = :cAuxdsTipoSubMotivoCampanha,
		       INDISPONIBILIDADE = :cAuxinDisponibilidade,
		       IDPESSOAUSUARIOINCLUSAO = :cAuxidPessoaUsuarioInclusao,
		       IDPESSOAUSUARIOALTERACAO = :cAuxidPessoaUsuarioAlteracao,
		       DTINCLUSAO = :cAuxdtInclusao,
		       DTALTERACAO = :cAuxdtAlteracao,
		       INATIVO = :cAuxinAtivo
		 WHERE IDTIPOSUBMOTIVOCAMPANHA = :cAuxidTipoSubMotivoCampanha;  
	
	if( sqlca.sqlcode == 0 )
		return 1;
	else
		return 0;

GotoUpdate:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}


int CTipoSubMotivoCampanha::ListId( char* cid )
{
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidOra = cid;
		struct
		{
			VARCHAR stidTipoSubMotivoCampanha[21+1];
			VARCHAR stsgTipoSubMotivoCampanha[256+1];
			VARCHAR stdsTipoSubMotivoCampanha[256+1];
			VARCHAR stinDisponibilidade[12+1];
			VARCHAR stidPessoaUsuarioInclusao[12+1];
			VARCHAR stidPessoaUsuarioAlteracao[21+1];
			VARCHAR stdtInclusao[12+1];
			VARCHAR stdtAlteracao[12+1];
			VARCHAR stinAtivo[21+1];
		} stTipoSubMotivoCampanhaRegistro;
		struct
		{
			short iidTipoSubMotivoCampanha;
			short isgTipoSubMotivoCampanha;
			short idsTipoSubMotivoCampanha;
			short iinDisponibilidade;
			short iidPessoaUsuarioInclusao;
			short iidPessoaUsuarioAlteracao;
			short idtInclusao;
			short idtAlteracao;
			short iinAtivo;
		} stTipoSubMotivoCampanhaIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraTipoSubMotivoCampanha();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
	sqlca.sqlcode=0;

   	EXEC SQL DECLARE CursorTipoSubMotivoCampanhaId CURSOR FOR
		SELECT IDTIPOSUBMOTIVOCAMPANHA, 
		       SGTIPOSUBMOTIVOCAMPANHA, 
		       DSTIPOSUBMOTIVOCAMPANHA, 
		       INDISPONIBILIDADE, 
		       IDPESSOAUSUARIOINCLUSAO, 
		       IDPESSOAUSUARIOALTERACAO, 
		       DTINCLUSAO, 
		       DTALTERACAO, 
		       INATIVO 
		  FROM APOIO.TIPOSUBMOTIVOCAMPANHA TIPOSUBMOTIVOCAMPANHA
		 WHERE IDTIPOSUBMOTIVOCAMPANHA = :cidOra;

	EXEC SQL OPEN CursorTipoSubMotivoCampanhaId;

	if(sqlca.sqlcode)
		return 0;
	else
	{
		for(;;)
		{
			memset( &stTipoSubMotivoCampanhaRegistro, 0, sizeof(stTipoSubMotivoCampanhaRegistro) );
			EXEC SQL FETCH CursorTipoSubMotivoCampanhaId INTO :stTipoSubMotivoCampanhaRegistro:stTipoSubMotivoCampanhaIndicator;

			Add( (char*)stTipoSubMotivoCampanhaRegistro.stidTipoSubMotivoCampanha.arr, 
			     (char*)stTipoSubMotivoCampanhaRegistro.stsgTipoSubMotivoCampanha.arr,
			     (char*)stTipoSubMotivoCampanhaRegistro.stdsTipoSubMotivoCampanha.arr,
			     (char*)stTipoSubMotivoCampanhaRegistro.stinDisponibilidade.arr,
			     (char*)stTipoSubMotivoCampanhaRegistro.stidPessoaUsuarioInclusao.arr,
			     (char*)stTipoSubMotivoCampanhaRegistro.stidPessoaUsuarioAlteracao.arr,
			     (char*)stTipoSubMotivoCampanhaRegistro.stdtInclusao.arr,
			     (char*)stTipoSubMotivoCampanhaRegistro.stdtAlteracao.arr,
			     (char*)stTipoSubMotivoCampanhaRegistro.stinAtivo.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorTipoSubMotivoCampanhaId;
	}

	return iCont;

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CTipoSubMotivoCampanha::ListAll( void )
{
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidTipoSubMotivoCampanha[21+1];
			VARCHAR stsgTipoSubMotivoCampanha[256+1];
			VARCHAR stdsTipoSubMotivoCampanha[256+1];
			VARCHAR stinDisponibilidade[12+1];
			VARCHAR stidPessoaUsuarioInclusao[12+1];
			VARCHAR stidPessoaUsuarioAlteracao[21+1];
			VARCHAR stdtInclusao[12+1];
			VARCHAR stdtAlteracao[12+1];
			VARCHAR stinAtivo[21+1];
		} stTipoSubMotivoCampanhaRegistro;
		struct
		{
			short iidTipoSubMotivoCampanha;
			short isgTipoSubMotivoCampanha;
			short idsTipoSubMotivoCampanha;
			short iinDisponibilidade;
			short iidPessoaUsuarioInclusao;
			short iidPessoaUsuarioAlteracao;
			short idtInclusao;
			short idtAlteracao;
			short iinAtivo;
		} stTipoSubMotivoCampanhaIndicator;

	EXEC SQL END DECLARE SECTION;

	ZeraTipoSubMotivoCampanha();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
	sqlca.sqlcode=0;

   	EXEC SQL DECLARE CursorTipoSubMotivoCampanhaAll CURSOR FOR
		SELECT IDTIPOSUBMOTIVOCAMPANHA, 
		       SGTIPOSUBMOTIVOCAMPANHA, 
		       DSTIPOSUBMOTIVOCAMPANHA, 
		       INDISPONIBILIDADE, 
		       IDPESSOAUSUARIOINCLUSAO, 
		       IDPESSOAUSUARIOALTERACAO, 
		       DTINCLUSAO, 
		       DTALTERACAO, 
		       INATIVO 
		  FROM APOIO.TIPOSUBMOTIVOCAMPANHA TIPOSUBMOTIVOCAMPANHA;

	EXEC SQL OPEN CursorTipoSubMotivoCampanhaAll;

	if(sqlca.sqlcode)
		return 0;
	else
	{
		for(;;)
		{
			memset( &stTipoSubMotivoCampanhaRegistro, 0, sizeof(stTipoSubMotivoCampanhaRegistro) );
			EXEC SQL FETCH CursorTipoSubMotivoCampanhaAll INTO :stTipoSubMotivoCampanhaRegistro:stTipoSubMotivoCampanhaIndicator;

			Add( (char*)stTipoSubMotivoCampanhaRegistro.stidTipoSubMotivoCampanha.arr, 
			     (char*)stTipoSubMotivoCampanhaRegistro.stsgTipoSubMotivoCampanha.arr,
			     (char*)stTipoSubMotivoCampanhaRegistro.stdsTipoSubMotivoCampanha.arr,
			     (char*)stTipoSubMotivoCampanhaRegistro.stinDisponibilidade.arr,
			     (char*)stTipoSubMotivoCampanhaRegistro.stidPessoaUsuarioInclusao.arr,
			     (char*)stTipoSubMotivoCampanhaRegistro.stidPessoaUsuarioAlteracao.arr,
			     (char*)stTipoSubMotivoCampanhaRegistro.stdtInclusao.arr,
			     (char*)stTipoSubMotivoCampanhaRegistro.stdtAlteracao.arr,
			     (char*)stTipoSubMotivoCampanhaRegistro.stinAtivo.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorTipoSubMotivoCampanhaAll;
	}

	return iCont;

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CTipoSubMotivoCampanha::GetXml( char* cNomeTag, XMLGen*xml )
{
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			xml->addProp( "xmlns", "campanha.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{
				xml->addItem("idTipoSubMotivoCampanha" , Registro(x)->cidTipoSubMotivoCampanha );
				xml->addItem("sgTipoSubMotivoCampanha" , Registro(x)->csgTipoSubMotivoCampanha );
				xml->addItem("dsTipoSubMotivoCampanha" , Registro(x)->cdsTipoSubMotivoCampanha );
				xml->addItem("idPessoaUsuarioInclusao" , Registro(x)->cidPessoaUsuarioInclusao );
				xml->addItem("idPessoaUsuarioAlteracao" , Registro(x)->cidPessoaUsuarioAlteracao );
				xml->addItem("dtInclusao" , Registro(x)->cdtInclusao );
				xml->addItem("dtAlteracao" , Registro(x)->cdtAlteracao );
				xml->addItem("inDisponibilidade" , Registro(x)->cinDisponibilidade );
				xml->addItem("inAtivo" , Registro(x)->cinAtivo );
			}
			xml->closeTag();
		}
	}
}
