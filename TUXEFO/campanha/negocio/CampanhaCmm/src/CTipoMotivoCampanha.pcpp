#undef SQLCA
#define SQLCA_NONE

#include<sqlca.h>
#include<sqlda.h>

#include <CTipoMotivoCampanha.h>
#include <CRelatorioCampanha.h>
#include <SRelatorioCampanha.h>

CTipoMotivoCampanha::CTipoMotivoCampanha()
{
}

CTipoMotivoCampanha::~CTipoMotivoCampanha()
{
}

int CTipoMotivoCampanha::Insert( char* csgTipoMotivoCampanha, 
									char* cdsTipoMotivoCampanha, 
									char* cidPessoaUsuarioInclusao,
									char* cidPessoaUsuarioAlteracao,
								    char* cdtInclusao,
								    char* cdtAlteracao,
									char* cinAtivo )
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cAuxidTipoMotivoCampanha[21+1];
		char* cAuxsgTipoMotivoCampanha = csgTipoMotivoCampanha;
		char* cAuxdsTipoMotivoCampanha = cdsTipoMotivoCampanha;
		char* cAuxidPessoaUsuarioInclusao = cidPessoaUsuarioInclusao;
		char* cAuxidPessoaUsuarioAlteracao = cidPessoaUsuarioAlteracao;
		char* cAuxdtInclusao = cdtInclusao;
		char* cAuxdtAlteracao = cdtAlteracao;
		char* cAuxinAtivo = cinAtivo;
	EXEC SQL END DECLARE SECTION;
	
	ZeraTipoMotivoCampanha();
	
	memset( &cAuxidTipoMotivoCampanha, 0, sizeof(cAuxidTipoMotivoCampanha) );
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
	sqlca.sqlcode=0;
	
	//Pega um id unico e sequencia para a insercao
	EXEC SQL
		SELECT APOIO.TIPOMOTIVOCAMPANHASQ.NEXTVAL
		INTO :cAuxidTipoMotivoCampanha
		FROM DUAL;

	EXEC SQL 
		INSERT INTO APOIO.TIPOMOTIVOCAMPANHA
		  (IDTIPOMOTIVOCAMPANHA, 
		   SGTIPOMOTIVOCAMPANHA, 
		   DSTIPOMOTIVOCAMPANHA, 
		   IDPESSOAUSUARIOINCLUSAO, 
		   IDPESSOAUSUARIOALTERACAO, 
		   DTINCLUSAO, 
		   DTALTERACAO, 
		   INATIVO)
		VALUES
		  (:cAuxidTipoMotivoCampanha, 
		   :cAuxsgTipoMotivoCampanha, 
		   :cAuxdsTipoMotivoCampanha, 
		   :cAuxidPessoaUsuarioInclusao, 
		   :cAuxidPessoaUsuarioAlteracao, 
		   :cAuxdtInclusao, 
		   :cAuxdtAlteracao, 
		   :cAuxinAtivo);

	if( sqlca.sqlcode == 0 )
		return 1;
	else
		return 0;

GotoInsert:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CTipoMotivoCampanha::Update( char* cidTipoMotivoCampanha, 
			                        char* csgTipoMotivoCampanha, 
								    char* cdsTipoMotivoCampanha, 
								    char* cidPessoaUsuarioInclusao,
								    char* cidPessoaUsuarioAlteracao,
								    char* cdtInclusao,
								    char* cdtAlteracao,
								    char* cinAtivo )
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidTipoMotivoCampanha  = cidTipoMotivoCampanha;
		char* cAuxsgTipoMotivoCampanha  = csgTipoMotivoCampanha;
		char* cAuxdsTipoMotivoCampanha  = cdsTipoMotivoCampanha;
		char* cAuxidPessoaUsuarioInclusao = cidPessoaUsuarioInclusao;
		char* cAuxidPessoaUsuarioAlteracao  = cidPessoaUsuarioAlteracao;
		char* cAuxdtInclusao = cdtInclusao;
		char* cAuxdtAlteracao     = cdtAlteracao;
		char* cAuxinAtivo = cinAtivo;
	EXEC SQL END DECLARE SECTION;

	ZeraTipoMotivoCampanha();
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
	sqlca.sqlcode=0;
	
	EXEC SQL 
		UPDATE APOIO.TIPOMOTIVOCAMPANHA
		   SET SGTIPOMOTIVOCAMPANHA = :cAuxsgTipoMotivoCampanha,
		       DSTIPOMOTIVOCAMPANHA = :cAuxdsTipoMotivoCampanha,
		       IDPESSOAUSUARIOINCLUSAO = :cAuxidPessoaUsuarioInclusao,
		       IDPESSOAUSUARIOALTERACAO = :cAuxidPessoaUsuarioAlteracao,
		       DTINCLUSAO = :cAuxdtInclusao,
		       DTALTERACAO = :cAuxdtAlteracao,
		       INATIVO = :cAuxinAtivo
		 WHERE IDTIPOMOTIVOCAMPANHA = :cAuxidTipoMotivoCampanha;  
	
	if( sqlca.sqlcode == 0 )
		return 1;
	else
		return 0;

GotoUpdate:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}


int CTipoMotivoCampanha::ListId( char* cid )
{
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidOra = cid;
		struct
		{
			VARCHAR stidTipoMotivoCampanha[21+1];
			VARCHAR stsgTipoMotivoCampanha[256+1];
			VARCHAR stdsTipoMotivoCampanha[256+1];
			VARCHAR stidPessoaUsuarioInclusao[21+1];
			VARCHAR stidPessoaUsuarioAlteracao[21+1];
			VARCHAR stdtInclusao[12+1];
			VARCHAR stdtAlteracao[12+1];
			VARCHAR stinAtivo[21+1];
		} stTipoMotivoCampanhaRegistro;
		struct
		{
			short iidTipoMotivoCampanha;
			short isgTipoMotivoCampanha;
			short idsTipoMotivoCampanha;
			short iidPessoaUsuarioInclusao;
			short iidPessoaUsuarioAlteracao;
			short idtInclusao;
			short idtAlteracao;
			short iinAtivo;
		} stTipoMotivoCampanhaIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraTipoMotivoCampanha();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
	sqlca.sqlcode=0;

   	EXEC SQL DECLARE CursorTipoMotivoCampanhaId CURSOR FOR
		SELECT IDTIPOMOTIVOCAMPANHA, 
		       SGTIPOMOTIVOCAMPANHA, 
		       DSTIPOMOTIVOCAMPANHA, 
		       IDPESSOAUSUARIOINCLUSAO, 
		       IDPESSOAUSUARIOALTERACAO, 
		       DTINCLUSAO, 
		       DTALTERACAO, 
		       INATIVO 
		  FROM APOIO.TIPOMOTIVOCAMPANHA TIPOMOTIVOCAMPANHA
		 WHERE IDTIPOMOTIVOCAMPANHA = :cidOra;

	EXEC SQL OPEN CursorTipoMotivoCampanhaId;

	if(sqlca.sqlcode)
		return 0;
	else
	{
		for(;;)
		{
			memset( &stTipoMotivoCampanhaRegistro, 0, sizeof(stTipoMotivoCampanhaRegistro) );
			EXEC SQL FETCH CursorTipoMotivoCampanhaId INTO :stTipoMotivoCampanhaRegistro:stTipoMotivoCampanhaIndicator;

			Add( (char*)stTipoMotivoCampanhaRegistro.stidTipoMotivoCampanha.arr, 
			     (char*)stTipoMotivoCampanhaRegistro.stsgTipoMotivoCampanha.arr,
			     (char*)stTipoMotivoCampanhaRegistro.stdsTipoMotivoCampanha.arr,
			     (char*)stTipoMotivoCampanhaRegistro.stidPessoaUsuarioInclusao.arr,
			     (char*)stTipoMotivoCampanhaRegistro.stidPessoaUsuarioInclusao.arr,
			     (char*)stTipoMotivoCampanhaRegistro.stdtInclusao.arr,
			     (char*)stTipoMotivoCampanhaRegistro.stdtAlteracao.arr,
			     (char*)stTipoMotivoCampanhaRegistro.stinAtivo.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorTipoMotivoCampanhaId;
	}

	return iCont;

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CTipoMotivoCampanha::ListAll( void )
{
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidTipoMotivoCampanha[21+1];
			VARCHAR stsgTipoMotivoCampanha[256+1];
			VARCHAR stdsTipoMotivoCampanha[256+1];
			VARCHAR stidPessoaUsuarioInclusao[21+1];
			VARCHAR stidPessoaUsuarioAlteracao[21+1];
			VARCHAR stdtInclusao[12+1];
			VARCHAR stdtAlteracao[12+1];
			VARCHAR stinAtivo[21+1];
		} stTipoMotivoCampanhaRegistro;
		struct
		{
			short iidTipoMotivoCampanha;
			short isgTipoMotivoCampanha;
			short idsTipoMotivoCampanha;
			short iidPessoaUsuarioInclusao;
			short iidPessoaUsuarioAlteracao;
			short idtInclusao;
			short idtAlteracao;
			short iinAtivo;
		} stTipoMotivoCampanhaIndicator;

	EXEC SQL END DECLARE SECTION;

	ULOGI("TipoMotivoCampanha - ListAll");

	ZeraTipoMotivoCampanha();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
	sqlca.sqlcode=0;

   	EXEC SQL DECLARE CursorTipoMotivoCampanhaAll CURSOR FOR
		SELECT IDTIPOMOTIVOCAMPANHA, 
		       SGTIPOMOTIVOCAMPANHA, 
		       DSTIPOMOTIVOCAMPANHA, 
		       IDPESSOAUSUARIOINCLUSAO, 
		       IDPESSOAUSUARIOALTERACAO, 
		       DTINCLUSAO, 
		       DTALTERACAO, 
		       INATIVO 
		  FROM APOIO.TIPOMOTIVOCAMPANHA TIPOMOTIVOCAMPANHA;
	
	EXEC SQL OPEN CursorTipoMotivoCampanhaAll;

	if(sqlca.sqlcode)
		return 0;
	else
	{
		for(;;)
		{
			memset( &stTipoMotivoCampanhaRegistro, 0, sizeof(stTipoMotivoCampanhaRegistro) );
			EXEC SQL FETCH CursorTipoMotivoCampanhaAll INTO :stTipoMotivoCampanhaRegistro:stTipoMotivoCampanhaIndicator;

			//Coloca tamanho nas variaveis
			stTipoMotivoCampanhaRegistro.stidTipoMotivoCampanha.arr[stTipoMotivoCampanhaRegistro.stidTipoMotivoCampanha.len]=0;
			stTipoMotivoCampanhaRegistro.stsgTipoMotivoCampanha.arr[stTipoMotivoCampanhaRegistro.stsgTipoMotivoCampanha.len]=0;
			stTipoMotivoCampanhaRegistro.stdsTipoMotivoCampanha.arr[stTipoMotivoCampanhaRegistro.stdsTipoMotivoCampanha.len]=0;
			stTipoMotivoCampanhaRegistro.stidPessoaUsuarioInclusao.arr[stTipoMotivoCampanhaRegistro.stidPessoaUsuarioInclusao.len]=0;
			stTipoMotivoCampanhaRegistro.stidPessoaUsuarioInclusao.arr[stTipoMotivoCampanhaRegistro.stidPessoaUsuarioInclusao.len]=0;
			stTipoMotivoCampanhaRegistro.stdtInclusao.arr[stTipoMotivoCampanhaRegistro.stdtInclusao.len]=0;
			stTipoMotivoCampanhaRegistro.stdtAlteracao.arr[stTipoMotivoCampanhaRegistro.stdtAlteracao.len]=0;
			stTipoMotivoCampanhaRegistro.stinAtivo.arr[stTipoMotivoCampanhaRegistro.stinAtivo.len]=0;

			Add( (char*)stTipoMotivoCampanhaRegistro.stidTipoMotivoCampanha.arr, 
			     (char*)stTipoMotivoCampanhaRegistro.stsgTipoMotivoCampanha.arr,
			     (char*)stTipoMotivoCampanhaRegistro.stdsTipoMotivoCampanha.arr,
			     (char*)stTipoMotivoCampanhaRegistro.stidPessoaUsuarioInclusao.arr,
			     (char*)stTipoMotivoCampanhaRegistro.stidPessoaUsuarioInclusao.arr,
			     (char*)stTipoMotivoCampanhaRegistro.stdtInclusao.arr,
			     (char*)stTipoMotivoCampanhaRegistro.stdtAlteracao.arr,
			     (char*)stTipoMotivoCampanhaRegistro.stinAtivo.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorTipoMotivoCampanhaAll;

		ULOGI("TipoMotivoCampanha - ListAll saindo do fetch");

	}

	return iCont;

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CTipoMotivoCampanha::GetXml( char* cNomeTag, XMLGen*xml )
{
	ULOGI("TipoMotivoCampanha - GetXml");

	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			xml->addProp( "xmlns", "campanha.fo.vivo.com.br/vo" );

			if( Registro( x ) != NULL )
			{
				xml->addItem("idTipoMotivoCampanha" ,	  Registro(x)->cidTipoMotivoCampanha.c_str() );
				xml->addItem("sgTipoMotivoCampanha" ,	  Registro(x)->csgTipoMotivoCampanha.c_str() );
				xml->addItem("dsTipoMotivoCampanha" ,	  Registro(x)->cdsTipoMotivoCampanha.c_str() );
				xml->addItem("idPessoaUsuarioInclusao" ,  Registro(x)->cidPessoaUsuarioInclusao.c_str() );
				xml->addItem("idPessoaUsuarioAlteracao" , Registro(x)->cidPessoaUsuarioAlteracao.c_str() );
				xml->addItem("dtInclusao" ,				  Registro(x)->cdtInclusao.c_str() );
				xml->addItem("dtAlteracao" ,			  Registro(x)->cdtAlteracao.c_str() );
				xml->addItem("inAtivo" ,			      Registro(x)->cinAtivo.c_str() );
			}
			xml->closeTag();
		}
	}
	ULOGI("TipoMotivoCampanha - GetXml Saindo");
}

//Os campos desta estrutura estão sendo aproveitados para o relatório de Gerenciamento

void CTipoMotivoCampanha::GetXmlRelGerMot(	XMLGen* xml, struct SRelatorioCampanha* sRelatorioCampanha )  
{

	TString tpMotivo, Total;
	ULOGI("TipoMotivoCampanha - GetXmlRelGerMot");

	for( int x = 0; x < Quantidade(); x++ )
	{
		if( Registro( x ) != NULL )
		{
			tpMotivo = Registro(x)->cidTipoMotivoCampanha;
			if ( Registro(x)->csgTipoMotivoCampanha == "Aderiu" ) 
			{
				Total =   CountByIdAtendimentoCampanha("-2", sRelatorioCampanha) - 
						  CountByIdAtendimentoCampanha(tpMotivo.c_str(), sRelatorioCampanha);
				xml->createTag("numerico");
					xml->addItem("descricao" ,	"Quantos Faltam para a Meta" );
					xml->addItem("valor" ,	Total.c_str() ); 
				xml->closeTag();
			}

			Total = (float)CountByIdAtendimentoCampanha(tpMotivo.c_str(), sRelatorioCampanha);
			xml->createTag("numerico");
				xml->addItem("descricao" ,	Registro(x)->cdsTipoMotivoCampanha.c_str() );
				xml->addItem("valor" ,	Total.c_str() ); 
			xml->closeTag();
		}
	}

	ULOGI("TipoMotivoCampanha - GetXmlRelGerMot Saindo");
}

//Os campos desta estrutura estão sendo aproveitados para o relatório de Gerenciamento
void CTipoMotivoCampanha::GetXmlRelGerDP( char* cNomeTag, 
										  XMLGen*xml,
									      struct SRelatorioCampanha* sRelatorioCampanha )
{
	float	fTMAMedioCampanha	= 0.0, 
			fDivisor			= 0.0, 
			fDividendo			= 0.0;
	float	fElemento			= 0.0, 
			fDesvioPadrao		= 0.0, 
			fSomatorio			= 0.0;
	TString stDesvioPadrao;

	ULOGI("TipoMotivoCampanha - GetXmlRelGerDP");

	try 
	{
		fTMAMedioCampanha	= CountByIdAtendimentoCampanha("-5", sRelatorioCampanha);
		fDivisor			= CountByIdAtendimentoCampanha("-1", sRelatorioCampanha) - 1;
	} 
	catch(...) 
	{
		fTMAMedioCampanha	= 0.0;
		fDivisor			= 0.0;
	}

	for( int x = 0; x < Quantidade(); x++ )
	{
		if( Quantidade() > 0 ) 
		{
			if( Registro( x ) != NULL)
			{
				if( Registro(x)->cinAtivo.ToInt() > 0 )
				{
					TString cidTipoMotivoCampanha = Registro(x)->cidTipoMotivoCampanha;

					try 
					{
						fElemento = 0.0;
						if (fDivisor>0.0) 
						{
							fElemento = CountByIdAtendimentoCampanha(cidTipoMotivoCampanha.c_str(), sRelatorioCampanha);
							fDividendo = ( (fElemento - fTMAMedioCampanha)*(fElemento - fTMAMedioCampanha) )/fDivisor;
						}
					} catch(...) 
					{
						fDividendo = 0.0;
					}

					fSomatorio = fSomatorio + fDividendo;

				}
			}
		}
	}

	if (fSomatorio>0.0)
		fDesvioPadrao = MatematicaSQRT(fSomatorio);

	stDesvioPadrao = fDesvioPadrao;

	xml->createTag(cNomeTag);
	xml->addItem("descricao" ,	"Desvio Padrão do TMA do Operador" );
	xml->addItem("valor" ,		stDesvioPadrao.c_str() ); 
	xml->closeTag();

	ULOGI("TipoMotivoCampanha - GetXmlRelGerDP Saindo");
}


// Calcula a raiz quadrada 
float CTipoMotivoCampanha::MatematicaSQRT( float fNumero )
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		float fAuxNumero = fNumero;
		float fResultado;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoMatematicaSQRT;
	sqlca.sqlcode=0;

	ULOGI("TipoMotivoCampanha - MatematicaSQRT");

	EXEC SQL SELECT	NVL(SQRT(:fAuxNumero),0.0) INTO :fResultado FROM DUAL;

	ULOGI("TipoMotivoCampanha - MatematicaSQRT Saindo");

	if(sqlca.sqlcode)
		return 0.0;

	return fResultado;

GotoMatematicaSQRT:
	throw TuxBasicOraException(sqlca.sqlcode);

}

//Lista de ids dos motivos do relatório

int CTipoMotivoCampanha::ListRelGerMot(char * sidsubcampanhahistorico)
{
	int    iCont = 0;
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR idsubcampanhahistorico[256];

		struct	{
			VARCHAR stidTipoMotivoCampanha[21+1];
			VARCHAR stsgTipoMotivoCampanha[256+1];
			VARCHAR stdsTipoMotivoCampanha[256+1];
		} 
		stTipoMotivoCampanhaRegistro;

		struct	{
			short iidTipoMotivoCampanha;
			short isgTipoMotivoCampanha;
			short idsTipoMotivoCampanha;
		} 
		stTipoMotivoCampanhaIndicator;

	EXEC SQL END DECLARE SECTION;

	STRCPY_TO_ORA (idsubcampanhahistorico, sidsubcampanhahistorico); 

	ULOGI("TipoMotivoCampanha - ListRelGerMot");

	ZeraTipoMotivoCampanha();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListRelGerMot;

	sqlca.sqlcode=0;

   	EXEC SQL DECLARE CursorTipoMotivoCampanhaRelGerMot CURSOR FOR
		SELECT DISTINCT 
				TIP.IDTIPOMOTIVOCAMPANHA, 
				TIP.DSTIPOMOTIVOCAMPANHA, 
				'Contatos com o motivo '||TIP.SGTIPOMOTIVOCAMPANHA
			FROM 
				CAMPANHA.MOTIVOCAMPANHA MOT,
				CAMPANHA.SUBCAMPANHAHISTORICO SUB,
				APOIO.TIPOMOTIVOCAMPANHA TIP
			WHERE 
			(    
				 (SUB.IDSUBCAMPANHAHISTORICO	= MOT.IDSUBCAMPANHAHISTORICO)
             AND (TIP.IDTIPOMOTIVOCAMPANHA		= MOT.IDTIPOMOTIVOCAMPANHA)
             AND (TIP.INATIVO					= 1)
             AND (SUB.IDSUBCAMPANHAHISTORICO	= :idsubcampanhahistorico)
			)
			ORDER BY UPPER(TRIM(3));	

	EXEC SQL OPEN CursorTipoMotivoCampanhaRelGerMot;

	if(sqlca.sqlcode)
		return 0;
	else
	{
		for(;;)
		{
			memset( &stTipoMotivoCampanhaRegistro, 0, sizeof(stTipoMotivoCampanhaRegistro) );
			EXEC SQL FETCH CursorTipoMotivoCampanhaRelGerMot INTO :stTipoMotivoCampanhaRegistro:stTipoMotivoCampanhaIndicator;

			Add( (char*)stTipoMotivoCampanhaRegistro.stidTipoMotivoCampanha.arr, 
			     (char*)stTipoMotivoCampanhaRegistro.stsgTipoMotivoCampanha.arr,
			     (char*)stTipoMotivoCampanhaRegistro.stdsTipoMotivoCampanha.arr);

			iCont++;
		}

		Add( "-5", "TMA Diário do Operador",  "TMA Diário do Operado",		 GRAFICO2 );
		Add( "-4", "TMA Médio do Operador", " TMA Médio do Operador", GRAFICO2 );
		Add( "-3", "Meta Diária de Contatos Efetivos","Meta Diária de Contatos Efetivos", GRAFICO  );
		Add( "-2", "Qtd. Adesões","Qtd. Adesões",GRAFICO  );
		Add( "-1", "Qtd. não Adesões",  "Qtd. não Adesões",GRAFICO );
				
		iCont+=5;

		/*
		-> TMA Diário do Operador;
		-> TMA Médio do Operador;
		-> Meta Diária de Contatos Efetivos;
		-> Qtd. Adesões;
		-> Qtd. não Adesões
		*/

		EXEC SQL CLOSE CursorTipoMotivoCampanhaRelGerMot;
	}

	ULOGI("TipoMotivoCampanha - ListRelGerMot Saindo");

	return iCont;

GotoListRelGerMot:
	throw TuxBasicOraException(sqlca.sqlcode);

}


char* CTipoMotivoCampanha::FiltroRelatorioGerenciamento( char* pcsgOperador )
{
	if (strcmp(pcsgOperador,"-1")==0)
	{
    	return pcsgOperador;
	}

	int iCont = 0;

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		char pcsgOperadorOraAux[255+1];
		VARCHAR pcsgOperadorOra[255+1];
	EXEC SQL END DECLARE SECTION;

	ULOGI("TipoMotivoCampanha - FiltroRelatorioGerenciamento");

	strcpy(pcsgOperadorOraAux,pcsgOperador);

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoFiltroRelatorioGerenciamento;
	sqlca.sqlcode=0;

   	EXEC SQL 
   	SELECT 	NMLOGINUSUARIO
	INTO	:pcsgOperadorOra
	FROM 	ACESSO.USUARIO
	WHERE 	UPPER(TRIM(NMLOGINUSUARIO)) = UPPER(TRIM(:pcsgOperadorOraAux));

	ULOGI("TipoMotivoCampanha - FiltroRelatorioGerenciamento Saindo");

	if (sqlca.sqlcode)
	  return NULL;

	return pcsgOperador;

GotoFiltroRelatorioGerenciamento:
	throw TuxBasicOraException(sqlca.sqlcode);
}

char* CTipoMotivoCampanha::FiltroRelatorioOperador( char* pcsgOperador, char *pcidOperador )
{
	ULOGI("TipoMotivoCampanha - FiltroRelatorioOperador");

	if ((strcmp(pcsgOperador,"-1")==0)&&(strcmp(pcidOperador,"-1")==0))
	{
    	return NULL;
	}
	
	if (strcmp(pcsgOperador,"-1")==0)
	{
    	return pcsgOperador;
	}

	int iCont = 0;

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		char pcsgOperadorOraAux[255+1];
		VARCHAR pcsgOperadorOra[255+1];
	EXEC SQL END DECLARE SECTION;

	strcpy(pcsgOperadorOraAux,pcsgOperador);

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoFiltroRelatorioOperador;
	sqlca.sqlcode=0;

   	EXEC SQL 
   	SELECT 	NMLOGINUSUARIO
	INTO	:pcsgOperadorOra
	FROM 	ACESSO.USUARIO
	WHERE 	UPPER(TRIM(NMLOGINUSUARIO)) = UPPER(TRIM(:pcsgOperadorOraAux));

	ULOGI("TipoMotivoCampanha - FiltroRelatorioOperador Saindo");

	if (sqlca.sqlcode)
	  return NULL;

	return pcsgOperador;

GotoFiltroRelatorioOperador:
	throw TuxBasicOraException(sqlca.sqlcode);
}


// Calcula a quantidade de um determinado motivo 
float CTipoMotivoCampanha::CountByIdAtendimentoCampanha( char* cidTipoMotivoCampanha, struct SRelatorioCampanha* sRelatorioCampanha )
{
	int    iCont = 0;

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;

		float fTotal = 0.0;
		char* cidTipoMotivoCampanhaOra = cidTipoMotivoCampanha;

		char pcidCampanhaOra[21+1];
		char pcidSubCampanhaOra[21+1];
		char pcidCanalOra[21+1];
		char pcidPerfilOra[21+1];
		char pcidRegionalOra[21+1];
		char pcdtInicioOra[21+1];
		char pcdtFimOra[21+1];
		char pcidMotivoOra[21+1];
		char pcidPerguntaOra[21+1];
		char pcidOperadorOra[21+1];
		char pcsgOperadorOra[255+1];
		char pcidAreaRegistroOra[21+1];

	EXEC SQL END DECLARE SECTION;

	ULOGI("TipoMotivoCampanha - CountByIdAtendimentoCampanha");

	strcpy( pcdtInicioOra, sRelatorioCampanha->pcdtInicio );
	strcpy( pcdtFimOra, sRelatorioCampanha->pcdtFim );
	strcpy( pcidCampanhaOra, sRelatorioCampanha->pcidCampanha );
	strcpy( pcidSubCampanhaOra, sRelatorioCampanha->pcidSubCampanha );
	strcpy( pcidCanalOra, sRelatorioCampanha->pcidCanalCampanha );
	strcpy( pcidPerfilOra, sRelatorioCampanha->pcidGrupo );
	strcpy( pcidRegionalOra, sRelatorioCampanha->pcidRegional );
	strcpy( pcidMotivoOra, sRelatorioCampanha->pcidMotivo );
	strcpy( pcidPerguntaOra, sRelatorioCampanha->pcidPergunta );
	strcpy( pcidOperadorOra, sRelatorioCampanha->pcidOperador );
	strcpy( pcidAreaRegistroOra, sRelatorioCampanha->pcidAreaRegistro );
	strcpy( pcsgOperadorOra, sRelatorioCampanha->pcsgOperador );

	ULOGI("TipoMotivoCampanha - CountByIdAtendimentoCampanha [%s]",
		cidTipoMotivoCampanhaOra);

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListTipoMotivoId;
	sqlca.sqlcode=0;

	if (strcmp(cidTipoMotivoCampanhaOra,"-8")==0)  // Calcula a quantidade de todos os motivos
	{		
		EXEC SQL
		SELECT	NVL(COUNT(DISTINCT(AC.IDATENDIMENTOCAMPANHA)),0.0) AS QUANTIDADEDEUMMOTIVO
		INTO	:fTotal
		FROM	CAMPANHA.SUBCAMPANHAHISTORICO SCH, CAMPANHA.MOTIVOCAMPANHA MC, APOIO.TIPOMOTIVOCAMPANHA TMC,
				CAMPANHA.CANALCAMPANHA CC, CAMPANHA.CANALUFOPERADORA CO, 
				CUSTOMER.UFOPERADORA UF, CAMPANHA.ATENDIMENTOCAMPANHA AC,	ACESSO.USUARIO U
		WHERE	SCH.IDSUBCAMPANHAHISTORICO = MC.IDSUBCAMPANHAHISTORICO
		AND		MC.IDTIPOMOTIVOCAMPANHA = TMC.IDTIPOMOTIVOCAMPANHA
		AND		(SCH.IDSUBCAMPANHAHISTORICO = :pcidSubCampanhaOra OR -1 = :pcidSubCampanhaOra)
		AND		SCH.IDSUBCAMPANHAHISTORICO = CC.IDSUBCAMPANHAHISTORICO
		AND		CC.IDCANALUFOPERADORA = CO.IDCANALUFOPERADORA 
		AND		CO.IDUFOPERADORA = UF.IDUFOPERADORA
		AND		(UF.IDUFOPERADORA = :pcidRegionalOra OR -1 = :pcidRegionalOra)	
		AND		(CC.IDCANALCAMPANHA = :pcidCanalOra OR -1 = :pcidCanalOra)
		AND		AC.IDCANALCAMPANHA = CC.IDCANALCAMPANHA
		AND		AC.IDMOTIVOCAMPANHA = MC.IDMOTIVOCAMPANHA	
		AND		AC.DTATENDIMENTO >= TO_DATE(:pcdtInicioOra,'DD/MM/YYYY') 
		AND		AC.DTATENDIMENTO <=	TO_DATE(:pcdtFimOra,'DD/MM/YYYY')	
		AND		AC.IDPESSOAUSUARIO = U.IDPESSOAUSUARIO
		AND		(U.IDPESSOAUSUARIO = :pcidOperadorOra OR -1 = :pcidOperadorOra )
		AND		(UPPER(U.NMLOGINUSUARIO) LIKE UPPER(:pcsgOperadorOra) OR '-1' = :pcsgOperadorOra);
	}
	else if (strcmp(cidTipoMotivoCampanhaOra,"-5")==0) //Calcula o valor de TMA Médio Campanha  
	{
		EXEC SQL
		SELECT	NVL(COUNT(AC.QTTEMPOATENDIMENTO),0.0) AS TMAMedioCampanha
		INTO	:fTotal
		FROM	CAMPANHA.SUBCAMPANHAHISTORICO SCH, CAMPANHA.MOTIVOCAMPANHA MC, APOIO.TIPOMOTIVOCAMPANHA TMC,
				CAMPANHA.CANALCAMPANHA CC, CAMPANHA.CANALUFOPERADORA CO, 
				CUSTOMER.UFOPERADORA UF, CAMPANHA.ATENDIMENTOCAMPANHA AC,	ACESSO.USUARIO U
		WHERE	SCH.IDSUBCAMPANHAHISTORICO = MC.IDSUBCAMPANHAHISTORICO
		AND		MC.IDTIPOMOTIVOCAMPANHA = TMC.IDTIPOMOTIVOCAMPANHA
		AND		(SCH.IDSUBCAMPANHAHISTORICO = :pcidSubCampanhaOra OR -1 = :pcidSubCampanhaOra)
		AND		SCH.IDSUBCAMPANHAHISTORICO = CC.IDSUBCAMPANHAHISTORICO
		AND		CC.IDCANALUFOPERADORA = CO.IDCANALUFOPERADORA 
		AND		CO.IDUFOPERADORA = UF.IDUFOPERADORA
		AND		(UF.IDUFOPERADORA = :pcidRegionalOra OR -1 = :pcidRegionalOra)	
		AND		(CC.IDCANALCAMPANHA = :pcidCanalOra OR -1 = :pcidCanalOra)
		AND		AC.IDCANALCAMPANHA = CC.IDCANALCAMPANHA
		AND		AC.IDMOTIVOCAMPANHA = MC.IDMOTIVOCAMPANHA	
		AND		AC.DTATENDIMENTO >= TO_DATE(:pcdtInicioOra,'DD/MM/YYYY') 
		AND		AC.DTATENDIMENTO <=	TO_DATE(:pcdtFimOra,'DD/MM/YYYY')	
		AND		AC.IDPESSOAUSUARIO = U.IDPESSOAUSUARIO
		AND		(U.IDPESSOAUSUARIO = :pcidOperadorOra OR -1 = :pcidOperadorOra )
		AND		(UPPER(U.NMLOGINUSUARIO) LIKE UPPER(:pcsgOperadorOra) OR '-1' = :pcsgOperadorOra);

		if (fTotal>0.0) 
		{
			EXEC SQL
			SELECT	NVL((SUM(AC.QTTEMPOATENDIMENTO)/COUNT(AC.QTTEMPOATENDIMENTO)),0.0) AS TMAMedioCampanha
			INTO	:fTotal
			FROM	CAMPANHA.SUBCAMPANHAHISTORICO SCH, CAMPANHA.MOTIVOCAMPANHA MC, APOIO.TIPOMOTIVOCAMPANHA TMC,
					CAMPANHA.CANALCAMPANHA CC, CAMPANHA.CANALUFOPERADORA CO, 
					CUSTOMER.UFOPERADORA UF, CAMPANHA.ATENDIMENTOCAMPANHA AC,	ACESSO.USUARIO U
			WHERE	SCH.IDSUBCAMPANHAHISTORICO = MC.IDSUBCAMPANHAHISTORICO
			AND		MC.IDTIPOMOTIVOCAMPANHA = TMC.IDTIPOMOTIVOCAMPANHA
			AND		(SCH.IDSUBCAMPANHAHISTORICO = :pcidSubCampanhaOra OR -1 = :pcidSubCampanhaOra)
			AND		SCH.IDSUBCAMPANHAHISTORICO = CC.IDSUBCAMPANHAHISTORICO
			AND		CC.IDCANALUFOPERADORA = CO.IDCANALUFOPERADORA 
			AND		CO.IDUFOPERADORA = UF.IDUFOPERADORA
			AND		(UF.IDUFOPERADORA = :pcidRegionalOra OR -1 = :pcidRegionalOra)	
			AND		(CC.IDCANALCAMPANHA = :pcidCanalOra OR -1 = :pcidCanalOra)
			AND		AC.IDCANALCAMPANHA = CC.IDCANALCAMPANHA
			AND		AC.IDMOTIVOCAMPANHA = MC.IDMOTIVOCAMPANHA	
			AND		AC.DTATENDIMENTO >= TO_DATE(:pcdtInicioOra,'DD/MM/YYYY') 
			AND		AC.DTATENDIMENTO <=	TO_DATE(:pcdtFimOra,'DD/MM/YYYY')	
			AND		AC.IDPESSOAUSUARIO = U.IDPESSOAUSUARIO
			AND		(U.IDPESSOAUSUARIO = :pcidOperadorOra OR -1 = :pcidOperadorOra)
			AND		(UPPER(U.NMLOGINUSUARIO) LIKE UPPER(:pcsgOperadorOra) OR '-1' = :pcsgOperadorOra);
		}
	}
	else if (strcmp(cidTipoMotivoCampanhaOra,"-4")==0) //Calcula o valor de TMA Campanha
	{
		EXEC SQL
		SELECT	NVL(COUNT(PC.NRTEMPOMEDIOCONTATO),0.0) AS TMACampanha
		INTO	:fTotal
		FROM	CAMPANHA.SUBCAMPANHAHISTORICO SCH, CAMPANHA.CANALCAMPANHA CC, CAMPANHA.CANALUFOPERADORA CO, 
				CUSTOMER.UFOPERADORA UF, CAMPANHA.PARAMETRIZACAOCAMPANHA PC
		WHERE	(SCH.IDSUBCAMPANHAHISTORICO = :pcidSubCampanhaOra OR -1 = :pcidSubCampanhaOra)
		AND		SCH.IDSUBCAMPANHAHISTORICO = CC.IDSUBCAMPANHAHISTORICO
		AND		CC.IDCANALUFOPERADORA = CO.IDCANALUFOPERADORA 
		AND		CO.IDUFOPERADORA = UF.IDUFOPERADORA
		AND		(UF.IDUFOPERADORA = :pcidRegionalOra OR -1 = :pcidRegionalOra) 		 
		AND		(CC.IDCANALCAMPANHA = :pcidCanalOra OR -1 = :pcidCanalOra)
		AND		PC.IDCANALCAMPANHA = CC.IDCANALCAMPANHA;

		if (fTotal>0.0) 
		{
			EXEC SQL
			SELECT	NVL((SUM(PC.NRTEMPOMEDIOCONTATO)/COUNT(PC.NRTEMPOMEDIOCONTATO)),0.0) AS TMACampanha
			INTO	:fTotal
			FROM	CAMPANHA.SUBCAMPANHAHISTORICO SCH, CAMPANHA.CANALCAMPANHA CC, CAMPANHA.CANALUFOPERADORA CO, 
					CUSTOMER.UFOPERADORA UF, CAMPANHA.PARAMETRIZACAOCAMPANHA PC
			WHERE	(SCH.IDSUBCAMPANHAHISTORICO = :pcidSubCampanhaOra OR -1 = :pcidSubCampanhaOra)
			AND		SCH.IDSUBCAMPANHAHISTORICO = CC.IDSUBCAMPANHAHISTORICO
			AND		CC.IDCANALUFOPERADORA = CO.IDCANALUFOPERADORA 
			AND		CO.IDUFOPERADORA = UF.IDUFOPERADORA
			AND		(UF.IDUFOPERADORA = :pcidRegionalOra OR -1 = :pcidRegionalOra) 		 
			AND		(CC.IDCANALCAMPANHA = :pcidCanalOra OR -1 = :pcidCanalOra)
			AND		PC.IDCANALCAMPANHA = CC.IDCANALCAMPANHA;
		}
	}
	else if (strcmp(cidTipoMotivoCampanhaOra,"-3")==0) //Calcula a quantidade de Contatos Efetivos
	{
		EXEC SQL
		SELECT	NVL(COUNT(DISTINCT(AC.IDATENDIMENTOCAMPANHA)),0.0) AS CONTATOSEFETIVOS
		INTO	:fTotal
		FROM	CAMPANHA.SUBCAMPANHAHISTORICO SCH, CAMPANHA.MOTIVOCAMPANHA MC, APOIO.TIPOMOTIVOCAMPANHA TMC,
				CAMPANHA.CANALCAMPANHA CC, CAMPANHA.CANALUFOPERADORA CO, 
				CUSTOMER.UFOPERADORA UF, CAMPANHA.ATENDIMENTOCAMPANHA AC, ACESSO.USUARIO U
		WHERE	SCH.IDSUBCAMPANHAHISTORICO = MC.IDSUBCAMPANHAHISTORICO
		AND		MC.IDTIPOMOTIVOCAMPANHA = TMC.IDTIPOMOTIVOCAMPANHA
		AND		(TMC.SGTIPOMOTIVOCAMPANHA = 'Aderiu' OR TMC.SGTIPOMOTIVOCAMPANHA = 'Não Aderiu') 
		AND		(SCH.IDSUBCAMPANHAHISTORICO = :pcidSubCampanhaOra OR -1 = :pcidSubCampanhaOra)
		AND		SCH.IDSUBCAMPANHAHISTORICO = CC.IDSUBCAMPANHAHISTORICO
		AND		CC.IDCANALUFOPERADORA = CO.IDCANALUFOPERADORA 
		AND		CO.IDUFOPERADORA = UF.IDUFOPERADORA
		AND		(UF.IDUFOPERADORA = :pcidRegionalOra OR -1 = :pcidRegionalOra)	
		AND		(CC.IDCANALCAMPANHA = :pcidCanalOra OR -1 = :pcidCanalOra)
		AND		AC.IDCANALCAMPANHA = CC.IDCANALCAMPANHA
		AND		AC.IDMOTIVOCAMPANHA = MC.IDMOTIVOCAMPANHA	
		AND		AC.DTATENDIMENTO >= TO_DATE(:pcdtInicioOra,'DD/MM/YYYY') 
		AND		AC.DTATENDIMENTO <=	TO_DATE(:pcdtFimOra,'DD/MM/YYYY')	
		AND		AC.IDPESSOAUSUARIO = U.IDPESSOAUSUARIO
		AND		(U.IDPESSOAUSUARIO = :pcidOperadorOra OR -1 = :pcidOperadorOra )
		AND		(UPPER(U.NMLOGINUSUARIO) LIKE UPPER(:pcsgOperadorOra) OR '-1' = :pcsgOperadorOra);
	}
	else if (strcmp(cidTipoMotivoCampanhaOra,"-2")==0) //Calcula Meta Diária da Campanha
	{
		EXEC SQL
		SELECT	NVL(SUM(PC.NRMETADIARIACAMPANHA),0.0) AS METADIARIACAMPANHA
		INTO	:fTotal
		FROM	CAMPANHA.SUBCAMPANHAHISTORICO SCH, CAMPANHA.CANALCAMPANHA CC, CAMPANHA.CANALUFOPERADORA CO, 
				CUSTOMER.UFOPERADORA UF, CAMPANHA.PARAMETRIZACAOCAMPANHA PC
		WHERE	(SCH.IDSUBCAMPANHAHISTORICO = :pcidSubCampanhaOra OR -1 = :pcidSubCampanhaOra)
		AND		SCH.IDSUBCAMPANHAHISTORICO = CC.IDSUBCAMPANHAHISTORICO
		AND		CC.IDCANALUFOPERADORA = CO.IDCANALUFOPERADORA AND CO.IDUFOPERADORA = UF.IDUFOPERADORA
		AND		(UF.IDUFOPERADORA = :pcidRegionalOra OR -1 = :pcidRegionalOra) 		 
		AND		(CC.IDCANALCAMPANHA = :pcidCanalOra OR -1 = :pcidCanalOra)
		AND		PC.IDCANALCAMPANHA = CC.IDCANALCAMPANHA;

	}
	else if (strcmp(cidTipoMotivoCampanhaOra,"-1")==0) //Calcula Valores de cada Público Total
	{
		EXEC SQL
		SELECT	NVL(SUM(PC.NRPUBLICOTOTAL),0.0) AS PUBLICOTOTAL
		INTO	:fTotal
		FROM	CAMPANHA.SUBCAMPANHAHISTORICO SCH, CAMPANHA.CANALCAMPANHA CC, CAMPANHA.CANALUFOPERADORA CO, 
				CUSTOMER.UFOPERADORA UF, CAMPANHA.PARAMETRIZACAOCAMPANHA PC
		WHERE	(SCH.IDSUBCAMPANHAHISTORICO = :pcidSubCampanhaOra OR -1 = :pcidSubCampanhaOra)
		AND		SCH.IDSUBCAMPANHAHISTORICO = CC.IDSUBCAMPANHAHISTORICO
		AND		CC.IDCANALUFOPERADORA = CO.IDCANALUFOPERADORA 
		AND		CO.IDUFOPERADORA = UF.IDUFOPERADORA
		AND		(UF.IDUFOPERADORA = :pcidRegionalOra OR -1 = :pcidRegionalOra) 		 
		AND		(CC.IDCANALCAMPANHA = :pcidCanalOra OR -1 = :pcidCanalOra)
		AND		PC.IDCANALCAMPANHA = CC.IDCANALCAMPANHA;
	}
	else // Calcula a quantidade de um determinado motivo
	{		
		EXEC SQL
		SELECT	NVL(COUNT(DISTINCT(AC.IDATENDIMENTOCAMPANHA)),0.0) AS QUANTIDADEDEUMMOTIVO
		INTO	:fTotal
		FROM	CAMPANHA.SUBCAMPANHAHISTORICO SCH, CAMPANHA.MOTIVOCAMPANHA MC, APOIO.TIPOMOTIVOCAMPANHA TMC,
				CAMPANHA.CANALCAMPANHA CC, CAMPANHA.CANALUFOPERADORA CO, 
				CUSTOMER.UFOPERADORA UF, CAMPANHA.ATENDIMENTOCAMPANHA AC,	ACESSO.USUARIO U
		WHERE	SCH.IDSUBCAMPANHAHISTORICO = MC.IDSUBCAMPANHAHISTORICO
		AND		MC.IDTIPOMOTIVOCAMPANHA = TMC.IDTIPOMOTIVOCAMPANHA
		AND		(TMC.IDTIPOMOTIVOCAMPANHA = :cidTipoMotivoCampanhaOra OR -1 = :cidTipoMotivoCampanhaOra)
		AND		(SCH.IDSUBCAMPANHAHISTORICO = :pcidSubCampanhaOra OR -1 = :pcidSubCampanhaOra)
		AND		SCH.IDSUBCAMPANHAHISTORICO = CC.IDSUBCAMPANHAHISTORICO
		AND		CC.IDCANALUFOPERADORA = CO.IDCANALUFOPERADORA 
		AND		CO.IDUFOPERADORA = UF.IDUFOPERADORA
		AND		(UF.IDUFOPERADORA = :pcidRegionalOra OR -1 = :pcidRegionalOra)	
		AND		(CC.IDCANALCAMPANHA = :pcidCanalOra OR -1 = :pcidCanalOra)
		AND		AC.IDCANALCAMPANHA = CC.IDCANALCAMPANHA
		AND		AC.IDMOTIVOCAMPANHA = MC.IDMOTIVOCAMPANHA	
		AND		AC.DTATENDIMENTO >= TO_DATE(:pcdtInicioOra,'DD/MM/YYYY') 
		AND		AC.DTATENDIMENTO <=	TO_DATE(:pcdtFimOra,'DD/MM/YYYY')	
		AND		AC.IDPESSOAUSUARIO = U.IDPESSOAUSUARIO
		AND		(U.IDPESSOAUSUARIO = :pcidOperadorOra OR -1 = :pcidOperadorOra )
		AND		(UPPER(U.NMLOGINUSUARIO) LIKE UPPER(:pcsgOperadorOra) OR '-1' = :pcsgOperadorOra);
	}

	ULOGI("TipoMotivoCampanha - CountByIdAtendimentoCampanha Saindo");

	if(sqlca.sqlcode)
		return 0.0;

	return fTotal;

GotoListTipoMotivoId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

//-------------------------------------------------------------------------------------------------------------------------------------
// Calcula a quantidade de um determinado motivo, utilizando o nome texto
// Segundo prametro opcional, pode ser NULL
//-------------------------------------------------------------------------------------------------------------------------------------

long CTipoMotivoCampanha::CountByText( char* texto1, char * texto2, struct SRelatorioCampanha* sRelatorioCampanha )
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		long lTotal	= 0L;
		char Texto1					[128]; 
		char Texto2					[128]; 
		char pcidCampanhaOra		[21+1];
		char pcidSubCampanhaOra		[21+1];
		char pcidCanalOra			[21+1];
		char pcidPerfilOra			[21+1];
		char pcidRegionalOra		[21+1];
		char pcdtInicioOra			[21+1];
		char pcdtFimOra				[21+1];
		char pcidMotivoOra			[21+1];
		char pcidPerguntaOra		[21+1];
		char pcidOperadorOra		[21+1];
		char pcsgOperadorOra		[255+1];
		char pcidAreaRegistroOra	[21+1];
	EXEC SQL END DECLARE SECTION;

	ULOGI("TipoMotivoCampanha - CountByText");

	strcpy( Texto1,					texto1								);
	strcpy( Texto2,					texto2								);
	strcpy( pcdtInicioOra,			sRelatorioCampanha->pcdtInicio		);
	strcpy( pcdtFimOra,				sRelatorioCampanha->pcdtFim			);
	strcpy( pcidCampanhaOra,		sRelatorioCampanha->pcidCampanha	);
	strcpy( pcidSubCampanhaOra,		sRelatorioCampanha->pcidSubCampanha );
	strcpy( pcidCanalOra,			sRelatorioCampanha->pcidCanalCampanha );
	strcpy( pcidPerfilOra,			sRelatorioCampanha->pcidGrupo		);
	strcpy( pcidRegionalOra,		sRelatorioCampanha->pcidRegional	);
	strcpy( pcidMotivoOra,			sRelatorioCampanha->pcidMotivo		);
	strcpy( pcidPerguntaOra,		sRelatorioCampanha->pcidPergunta	);
	strcpy( pcidOperadorOra,		sRelatorioCampanha->pcidOperador	);
	strcpy( pcidAreaRegistroOra,	sRelatorioCampanha->pcidAreaRegistro);
	strcpy( pcsgOperadorOra,		sRelatorioCampanha->pcsgOperador	);

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO CountByTextError;

	sqlca.sqlcode=0;

	EXEC SQL
	SELECT 
		COUNT(1)
	INTO 
		:lTotal
	FROM 
		CAMPANHA.SUBCAMPANHAHISTORICO	SCH, 
		CAMPANHA.MOTIVOCAMPANHA			MC, 
		APOIO.TIPOMOTIVOCAMPANHA			TMC,
		CAMPANHA.CANALCAMPANHA			CC, 
		CAMPANHA.CANALUFOPERADORA		CO, 
		CAMPANHA.ATENDIMENTOCAMPANHA		AC
	WHERE 
		SCH.IDSUBCAMPANHAHISTORICO		=	MC.IDSUBCAMPANHAHISTORICO
	AND 
		MC.IDTIPOMOTIVOCAMPANHA		=	TMC.IDTIPOMOTIVOCAMPANHA
	AND 
		UPPER(TMC.SGTIPOMOTIVOCAMPANHA) IN ( UPPER(:Texto1), UPPER(:Texto2) )
	AND 
		(SCH.IDSUBCAMPANHAHISTORICO	= :pcidSubCampanhaOra OR  -1 = :pcidSubCampanhaOra)
	AND 
		SCH.IDSUBCAMPANHAHISTORICO	= CC.IDSUBCAMPANHAHISTORICO
	AND 
		CC.IDCANALUFOPERADORA		= CO.IDCANALUFOPERADORA 
	AND 
		(CO.IDUFOPERADORA			= :pcidRegionalOra OR  -1 = :pcidRegionalOra)				
	AND		
		AC.IDCANALCAMPANHA			= CC.IDCANALCAMPANHA
	AND 
		AC.IDMOTIVOCAMPANHA			= MC.IDMOTIVOCAMPANHA	
	AND 
		TRUNC(AC.DTATENDIMENTO)	BETWEEN TO_DATE(:pcdtInicioOra, 'DD/MM/YYYY' ) AND TO_DATE(:pcdtFimOra, 'DD/MM/YYYY' );

	ULOGI("TipoMotivoCampanha - CountByText Saindo");

	if(sqlca.sqlcode)
		return 0L;

	return lTotal;

CountByTextError:
	throw TuxBasicOraException(sqlca.sqlcode);

}


long CTipoMotivoCampanha::getContatosEfetivos( struct SRelatorioCampanha* sRelatorioCampanha )
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		long lTotal	= 0L;
		char pcidCampanhaOra		[21+1];
		char pcidSubCampanhaOra		[21+1];
		char pcidCanalOra			[21+1];
		char pcidPerfilOra			[21+1];
		char pcidRegionalOra		[21+1];
		char pcdtInicioOra			[21+1];
		char pcdtFimOra				[21+1];
		char pcidMotivoOra			[21+1];
		char pcidPerguntaOra		[21+1];
		char pcidOperadorOra		[21+1];
		char pcsgOperadorOra		[255+1];
		char pcidAreaRegistroOra	[21+1];
	EXEC SQL END DECLARE SECTION;

	ULOGI("TipoMotivoCampanha - getContatosEfetivos");

	strcpy( pcdtInicioOra,			sRelatorioCampanha->pcdtInicio		);
	strcpy( pcdtFimOra,				sRelatorioCampanha->pcdtFim			);
	strcpy( pcidCampanhaOra,		sRelatorioCampanha->pcidCampanha	);
	strcpy( pcidSubCampanhaOra,		sRelatorioCampanha->pcidSubCampanha );
	strcpy( pcidCanalOra,			sRelatorioCampanha->pcidCanalCampanha );
	strcpy( pcidPerfilOra,			sRelatorioCampanha->pcidGrupo		);
	strcpy( pcidRegionalOra,		sRelatorioCampanha->pcidRegional	);
	strcpy( pcidMotivoOra,			sRelatorioCampanha->pcidMotivo		);
	strcpy( pcidPerguntaOra,		sRelatorioCampanha->pcidPergunta	);
	strcpy( pcidOperadorOra,		sRelatorioCampanha->pcidOperador	);
	strcpy( pcidAreaRegistroOra,	sRelatorioCampanha->pcidAreaRegistro);
	strcpy( pcsgOperadorOra,		sRelatorioCampanha->pcsgOperador	);

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO getContatosEfetivosError;

	sqlca.sqlcode=0;

	EXEC SQL
	SELECT 
		COUNT(1)
	INTO 
		:lTotal
	FROM 
		CAMPANHA.SUBCAMPANHAHISTORICO	SCH, 
		CAMPANHA.MOTIVOCAMPANHA			MC, 
		APOIO.TIPOMOTIVOCAMPANHA			TMC,
		CAMPANHA.CANALCAMPANHA			CC, 
		CAMPANHA.CANALUFOPERADORA		CO, 
		APOIO.CANAL						C, 
		CAMPANHA.ATENDIMENTOCAMPANHA		AC
	WHERE 
		SCH.IDSUBCAMPANHAHISTORICO		=	MC.IDSUBCAMPANHAHISTORICO
	AND 
		MC.IDTIPOMOTIVOCAMPANHA		=	TMC.IDTIPOMOTIVOCAMPANHA
	AND 
		UPPER(TMC.SGTIPOMOTIVOCAMPANHA) IN ('ADERIU', 'NÃO ADERIU', 'VAI AVALIAR', 'REAGENDAR' )
	AND 
		(SCH.IDSUBCAMPANHAHISTORICO	= :pcidSubCampanhaOra OR  -1 = :pcidSubCampanhaOra)
	AND 
		SCH.IDSUBCAMPANHAHISTORICO	= CC.IDSUBCAMPANHAHISTORICO
	AND 
		CC.IDCANALUFOPERADORA		= CO.IDCANALUFOPERADORA 
	AND 
		(CO.IDUFOPERADORA			= :pcidRegionalOra OR  -1 = :pcidRegionalOra)				
	AND 
		CO.IDCANAL					= C.IDCANAL	
	AND 
		AC.IDCANALCAMPANHA			= CC.IDCANALCAMPANHA
	AND 
		AC.IDMOTIVOCAMPANHA			= MC.IDMOTIVOCAMPANHA	
	AND 
		TRUNC( AC.DTATENDIMENTO	 )	BETWEEN TO_DATE( :pcdtInicioOra, 'DD/MM/YYYY' ) AND TO_DATE( :pcdtFimOra, 'DD/MM/YYYY' );

	ULOGI("TipoMotivoCampanha - getContatosEfetivos Saindo");

	if(sqlca.sqlcode)
		return 0L;

	return lTotal;

getContatosEfetivosError:
	throw TuxBasicOraException(sqlca.sqlcode);

}
