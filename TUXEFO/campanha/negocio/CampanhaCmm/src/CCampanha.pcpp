#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <CCampanha.h>

CCampanha::CCampanha()
{
}

CCampanha::~CCampanha()
{
}


int CCampanha::Insert( char* csgCampanha, 
					   char* cdsCampanha, 
					   char* cdtInclusao, 
					   char* cdtAlteracao,
					   char* cidPessoaUsuarioInclusao,
					   char* cidPessoaUsuarioAlteracao,
					   char* cinAtivo )
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cAuxidCampanha[21+1];
		char* cAuxsgCampanha  = csgCampanha;
		char* cAuxdsCampanha  = cdsCampanha;
		char* cAuxdtInclusao  = cdtInclusao;
		char* cAuxdtAlteracao = cdtAlteracao;
		char* cAuxidPessoaUsuarioInclusao  = cidPessoaUsuarioInclusao;
		char* cAuxidPessoaUsuarioAlteracao = cidPessoaUsuarioAlteracao;
		char* cAuxinAtivo     = cinAtivo;
	EXEC SQL END DECLARE SECTION;
	
	ZeraCampanha();
	
	memset( &cAuxidCampanha, 0, sizeof(cAuxidCampanha) );
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
	sqlca.sqlcode=0;
	
	//Pega um id unico e sequencia para a insercao
	EXEC SQL
		SELECT APOIO.CAMPANHASQ.NEXTVAL
		INTO :cAuxidCampanha
		FROM DUAL;

	EXEC SQL 
		INSERT INTO APOIO.CAMPANHA
		  (IDCAMPANHA, 
		   SGCAMPANHA, 
		   DSCAMPANHA, 
		   IDPESSOAUSUARIOINCLUSAO, 
		   IDPESSOAUSUARIOALTERACAO, 
		   DTINCLUSAO, 
		   DTALTERACAO, 
		   INATIVO)
		VALUES
		  (:cAuxidCampanha, 
		   :cAuxsgCampanha, 
		   :cAuxdsCampanha, 
		   :cAuxidPessoaUsuarioInclusao, 
		   :cAuxidPessoaUsuarioAlteracao, 
		   :cAuxdtInclusao, 
		   :cAuxdtAlteracao, 
		   :cAuxinAtivo);  
	
	if( sqlca.sqlcode == 0 )
		return 1;
	else
		return 0;

GotoInsert:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CCampanha::Update( char* cidCampanha, 
                        char* csgCampanha, 
						char* cdsCampanha, 
						char* cdtInclusao, 
						char* cdtAlteracao,
						char* cidPessoaUsuarioInclusao,
					    char* cidPessoaUsuarioAlteracao,
					    char* cinAtivo )
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidCampanha  = cidCampanha;
		char* cAuxsgCampanha  = csgCampanha;
		char* cAuxdsCampanha  = cdsCampanha;
		char* cAuxdtInclusao  = cdtInclusao;
		char* cAuxdtAlteracao = cdtAlteracao;
		char* cAuxidPessoaUsuarioInclusao  = cidPessoaUsuarioInclusao;
		char* cAuxidPessoaUsuarioAlteracao = cidPessoaUsuarioAlteracao;
		char* cAuxinAtivo     = cinAtivo;
	EXEC SQL END DECLARE SECTION;

	ZeraCampanha();
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
	sqlca.sqlcode=0;
	
	EXEC SQL 
		UPDATE APOIO.CAMPANHA
		   SET SGCAMPANHA  = :cAuxsgCampanha,
		       DSCAMPANHA  = :cAuxdsCampanha,
		       IDPESSOAUSUARIOINCLUSAO  = :cAuxidPessoaUsuarioInclusao,
		       IDPESSOAUSUARIOALTERACAO = :cAuxidPessoaUsuarioAlteracao,
		       DTINCLUSAO  = :cAuxdtInclusao,
		       DTALTERACAO = :cAuxdtAlteracao,
		       INATIVO     = :cAuxinAtivo
		 WHERE IDCAMPANHA = :cAuxidCampanha;   
	
	if( sqlca.sqlcode == 0 )
		return 1;
	else
		return 0;

GotoUpdate:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}


int CCampanha::ListId( char* cid )
{
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidOra = cid;
		struct
		{
			VARCHAR stidCampanha[21+1];
			VARCHAR stsgCampanha[256+1];
			VARCHAR stdsCampanha[256+1];
			VARCHAR stidPessoaUsuarioInclusao[21+1];
			VARCHAR stidPessoaUsuarioAlteracao[21+1];
			VARCHAR stdtInclusao[12+1];
			VARCHAR stdtAlteracao[12+1];
			VARCHAR stinAtivo[21+1];
		} stCampanhaRegistro;
		struct
		{
			short iidCampanha;
			short isgCampanha;
			short idsCampanha;
			short iidPessoaUsuarioInclusao;
			short iidPessoaUsuarioAlteracao;
			short idtInclusao;
			short idtAlteracao;
			short iinAtivo;
		} stCampanhaIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraCampanha();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
	sqlca.sqlcode=0;

   	EXEC SQL DECLARE CursorCampanhaId CURSOR FOR
		SELECT IDCAMPANHA, 
		       SGCAMPANHA, 
		       DSCAMPANHA, 
		       IDPESSOAUSUARIOINCLUSAO, 
		       IDPESSOAUSUARIOALTERACAO, 
		       DTINCLUSAO, 
		       DTALTERACAO, 
		       INATIVO 
		  FROM APOIO.CAMPANHA CAMPANHA
		 WHERE IDMOTIVOCAMPANHA = :cidOra;

	EXEC SQL OPEN CursorCampanhaId;

	if(sqlca.sqlcode)
		return 0;
	else
	{
		for(;;)
		{
			memset( &stCampanhaRegistro, 0, sizeof(stCampanhaRegistro) );
			EXEC SQL FETCH CursorCampanhaId INTO :stCampanhaRegistro:stCampanhaIndicator;

			Add( (char*)stCampanhaRegistro.stidCampanha.arr, 
			     (char*)stCampanhaRegistro.stsgCampanha.arr,
			     (char*)stCampanhaRegistro.stdsCampanha.arr,
			     (char*)stCampanhaRegistro.stdtInclusao.arr,
			     (char*)stCampanhaRegistro.stdtAlteracao.arr,
			     (char*)stCampanhaRegistro.stidPessoaUsuarioInclusao.arr,
			     (char*)stCampanhaRegistro.stidPessoaUsuarioAlteracao.arr,
			     (char*)stCampanhaRegistro.stinAtivo.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorCampanhaId;
	}

	return iCont;

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CCampanha::ListAll( void )
{
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidCampanha[21+1];
			VARCHAR stsgCampanha[256+1];
			VARCHAR stdsCampanha[256+1];
			VARCHAR stidPessoaUsuarioInclusao[21+1];
			VARCHAR stidPessoaUsuarioAlteracao[21+1];
			VARCHAR stdtInclusao[12+1];
			VARCHAR stdtAlteracao[12+1];
			VARCHAR stinAtivo[21+1];
		} stCampanhaRegistro;
		struct
		{
			short iidCampanha;
			short isgCampanha;
			short idsCampanha;
			short iidPessoaUsuarioInclusao;
			short iidPessoaUsuarioAlteracao;
			short idtInclusao;
			short idtAlteracao;
			short iinAtivo;
		} stCampanhaIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraCampanha();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
	sqlca.sqlcode=0;

   	EXEC SQL DECLARE CursorCampanhaAll CURSOR FOR
		SELECT IDCAMPANHA, 
		       SGCAMPANHA, 
		       DSCAMPANHA, 
		       IDPESSOAUSUARIOINCLUSAO, 
		       IDPESSOAUSUARIOALTERACAO, 
		       DTINCLUSAO, 
		       DTALTERACAO, 
		       INATIVO 
		  FROM APOIO.CAMPANHA;

	EXEC SQL OPEN CursorCampanhaAll;

	if(sqlca.sqlcode)
		return 0;
	else
	{
		for(;;)
		{
			memset( &stCampanhaRegistro, 0, sizeof(stCampanhaRegistro) );
			EXEC SQL FETCH CursorCampanhaAll INTO :stCampanhaRegistro:stCampanhaIndicator;

			Add( (char*)stCampanhaRegistro.stidCampanha.arr, 
			     (char*)stCampanhaRegistro.stsgCampanha.arr,
			     (char*)stCampanhaRegistro.stdsCampanha.arr,
			     (char*)stCampanhaRegistro.stdtInclusao.arr,
			     (char*)stCampanhaRegistro.stdtAlteracao.arr,
			     (char*)stCampanhaRegistro.stidPessoaUsuarioInclusao.arr,
			     (char*)stCampanhaRegistro.stidPessoaUsuarioAlteracao.arr,
			     (char*)stCampanhaRegistro.stinAtivo.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorCampanhaAll;
	}

	return iCont;

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CCampanha::GetXml( char* cNomeTag, XMLGen*xml )
{
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			xml->addProp( "xmlns", "campanha.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{
				xml->addItem("idCampanha"  , Registro(x)->cidCampanha );
				xml->addItem("sgCampanha"  , Registro(x)->csgCampanha );
				xml->addItem("dsCampanha"  , Registro(x)->cdsCampanha );
				xml->addItem("idPessoaUsuarioInclusao" , Registro(x)->cidPessoaUsuarioInclusao );
				xml->addItem("idPessoaUsuarioAlteracao" , Registro(x)->cidPessoaUsuarioAlteracao );
				xml->addItem("dtInclusao"  , Registro(x)->cdtInclusao );
				xml->addItem("dtAlteracao" , Registro(x)->cdtAlteracao );
				xml->addItem("inAtivo"     , Registro(x)->cinAtivo );
			}
			xml->closeTag();
		}
	}
}
