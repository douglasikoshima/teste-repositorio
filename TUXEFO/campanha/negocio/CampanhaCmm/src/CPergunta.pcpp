#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <CPergunta.h>

CPergunta::CPergunta()
{
}

CPergunta::~CPergunta()
{
}

int CPergunta::Insert( 
               char* cidTipoApresentacaoPergunta, 
		       char* cdsPergunta, 
		       char* cdsScriptPergunta, 
		       char* csqApresentacao,
		       char* cinEncerramento,
		       char* cinDisponibilidade,
		       char* cinObrigatoria )
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
	VARCHAR cAuxidPergunta[21+1];
	char* cAuxidTipoApresentacaoPergunta  = cidTipoApresentacaoPergunta;
	char* cAuxdsPergunta  = cdsPergunta;
	char* cAuxdsScriptPergunta  = cdsScriptPergunta;
	char* cAuxsqApresentacao = csqApresentacao;
	char* cAuxinEncerramento  = cinEncerramento;
	char* cAuxinDisponibilidade = cinDisponibilidade;
	char* cAuxinObrigatoria     = cinObrigatoria;
	int existe=0;	
	EXEC SQL END DECLARE SECTION;
	
	ZeraPergunta();
	
	  memset( &cAuxidPergunta, 0, sizeof(cAuxidPergunta) );
		
	  EXEC SQL WHENEVER NOT FOUND CONTINUE;
	  EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
	  sqlca.sqlcode=0;
 

		//Pega um id unico e sequencia para a insercao
		EXEC SQL
			SELECT QUESTIONARIO.PERGUNTASQ.NEXTVAL
			INTO :cAuxidPergunta
			FROM DUAL;

		EXEC SQL 
		INSERT INTO QUESTIONARIO.PERGUNTA
							(	IDPERGUNTA, 
								IDTIPOAPRESENTACAOPERGUNTA, 
								DSPERGUNTA, 
								INOBRIGATORIA,
								INDISPONIBILIDADE, 
								SQAPRESENTACAO, 
								DSSCRIPTPERGUNTA, 
								INENCERRAMENTO)
		VALUES
							(	:cAuxidPergunta, 
								:cAuxidTipoApresentacaoPergunta, 
								:cAuxdsPergunta, 
								:cAuxinObrigatoria, 
								:cAuxinDisponibilidade, 
								:cAuxsqApresentacao, 
								:cAuxdsScriptPergunta, 
								:cAuxinEncerramento);
	
	Add( (char*)cAuxidPergunta.arr, 
         cAuxidTipoApresentacaoPergunta, 
	     cAuxdsPergunta, 
	     cAuxdsScriptPergunta, 
	     cAuxsqApresentacao,
	     cAuxinEncerramento,
	     cAuxinDisponibilidade,
	     cAuxinObrigatoria );
					    
	return 0;

GotoInsert:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CPergunta::Update( char* cidPergunta, 
                       char* cidTipoApresentacaoPergunta, 
		       char* cdsPergunta, 
		       char* cdsScriptPergunta, 
		       char* csqApresentacao,
		       char* cinEncerramento,
		       char* cinDisponibilidade,
		       char* cinObrigatoria )
{
	int ret=0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
	char* cAuxidPergunta  = cidPergunta;
	char* cAuxidTipoApresentacaoPergunta  = cidTipoApresentacaoPergunta;
	char* cAuxdsPergunta  = cdsPergunta;
	char* cAuxdsScriptPergunta  = cdsScriptPergunta;
	char* cAuxsqApresentacao = csqApresentacao;
	char* cAuxinEncerramento  = cinEncerramento;
	char* cAuxinDisponibilidade = cinDisponibilidade;
	char* cAuxinObrigatoria     = cinObrigatoria;
	int	  existe=0;
	EXEC SQL END DECLARE SECTION;

	ZeraPergunta();

	//Testa para verificar se existe pergunta com mesma
	//descrição
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;


	
	sqlca.sqlcode=0;

	EXEC SQL 
	UPDATE QUESTIONARIO.PERGUNTA
		SET IDTIPOAPRESENTACAOPERGUNTA  = :cAuxidTipoApresentacaoPergunta,
				DSPERGUNTA        = :cAuxdsPergunta,
				INENCERRAMENTO    = :cAuxinEncerramento,
				INDISPONIBILIDADE = :cAuxinDisponibilidade,
				DSSCRIPTPERGUNTA  = :cAuxdsScriptPergunta,
				SQAPRESENTACAO    = :cAuxsqApresentacao,
				INOBRIGATORIA     = :cAuxinObrigatoria
   		WHERE IDPERGUNTA = :cAuxidPergunta;   

	if( sqlca.sqlcode == 0 ) 
	{
		ret=atoi(cAuxidPergunta);
	 }
   else
   {

	ret=-1;

   } 

	return ret;

	GotoUpdate:
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CPergunta::Update( char* cidPergunta, 
                       char* cidTipoApresentacaoPergunta, 
		       char* cdsPergunta, 
		       char* cdsScriptPergunta, 
		       char* cinEncerramento,
		       char* cinDisponibilidade,
		       char* cinObrigatoria )
{
	int ret=0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
	char* cAuxidPergunta  = cidPergunta;
	char* cAuxidTipoApresentacaoPergunta  = cidTipoApresentacaoPergunta;
	char* cAuxdsPergunta  = cdsPergunta;
	char* cAuxdsScriptPergunta  = cdsScriptPergunta;
	char* cAuxinEncerramento  = cinEncerramento;
	char* cAuxinDisponibilidade = cinDisponibilidade;
	char* cAuxinObrigatoria     = cinObrigatoria;
	int	  existe=0;
	EXEC SQL END DECLARE SECTION;

	ZeraPergunta();

	//Testa para verificar se existe pergunta com mesma
	//descrição
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate2;


	
	sqlca.sqlcode=0;

	EXEC SQL 
	UPDATE QUESTIONARIO.PERGUNTA
		SET IDTIPOAPRESENTACAOPERGUNTA  = :cAuxidTipoApresentacaoPergunta,
				DSPERGUNTA        = :cAuxdsPergunta,
				INENCERRAMENTO    = :cAuxinEncerramento,
				INDISPONIBILIDADE = :cAuxinDisponibilidade,
				DSSCRIPTPERGUNTA  = :cAuxdsScriptPergunta,
				INOBRIGATORIA     = :cAuxinObrigatoria
   		WHERE IDPERGUNTA = :cAuxidPergunta;   

	if( sqlca.sqlcode == 0 ) 
	{
		ret=atoi(cAuxidPergunta);
	 }
   else
   {

	ret=-1;

   } 

	return ret;

	GotoUpdate2:
	throw TuxBasicOraException(sqlca.sqlcode);
}


int CPergunta::ListAll( void )
{
  int    iCont = 0;
  struct sqlca sqlca;
  EXEC SQL BEGIN DECLARE SECTION;
  struct
  {
    VARCHAR stidPergunta[21+1];
    VARCHAR stidTipoApresentacaoPergunta[21+1];
    VARCHAR stdsPergunta[2000+1];
    VARCHAR stinObrigatoria[21+1];
    VARCHAR stinDisponibilidade[21+1];
    VARCHAR stsqApresentacao[21+1];
    VARCHAR stdsScriptPergunta[2000+1];
    VARCHAR stinEncerramento[21+1];
  } stPerguntaRegistro;
  struct
  {
    short iidPergunta;
    short iidTipoApresentacaoPergunta;
    short idsPergunta;
    short iinObrigatoria;
    short iinDisponibilidade;
    short isqApresentacao;
    short idsScriptPergunta;
    short iinEncerramento;
  } stPerguntaIndicator;
  EXEC SQL END DECLARE SECTION;

  ZeraPergunta();

  EXEC SQL WHENEVER NOT FOUND DO break;
  EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
  sqlca.sqlcode=0;

  EXEC SQL DECLARE CursorPerguntaAll CURSOR FOR
    SELECT IDPERGUNTA, 
    IDTIPOAPRESENTACAOPERGUNTA, 
    DSPERGUNTA, 
    INOBRIGATORIA, 
    INDISPONIBILIDADE, 
    SQAPRESENTACAO, 
    DSSCRIPTPERGUNTA, 
    INENCERRAMENTO 
    FROM QUESTIONARIO.PERGUNTA PERGUNTA
    ORDER BY SQAPRESENTACAO;

  EXEC SQL OPEN CursorPerguntaAll;

  if(sqlca.sqlcode)
    return 0;
  else
    {
      for(;;)
	{
	  memset( &stPerguntaRegistro, 0, sizeof(stPerguntaRegistro) );
	  EXEC SQL FETCH CursorPerguntaAll INTO :stPerguntaRegistro:stPerguntaIndicator;

	  Add( (char*)stPerguntaRegistro.stidPergunta.arr, 
	       (char*)stPerguntaRegistro.stidTipoApresentacaoPergunta.arr,
	       (char*)stPerguntaRegistro.stdsPergunta.arr,
	       (char*)stPerguntaRegistro.stdsScriptPergunta.arr,
	       (char*)stPerguntaRegistro.stsqApresentacao.arr,
	       (char*)stPerguntaRegistro.stinEncerramento.arr,
	       (char*)stPerguntaRegistro.stinDisponibilidade.arr,
	       (char*)stPerguntaRegistro.stinObrigatoria.arr );

	  iCont++;

	}
      EXEC SQL CLOSE CursorPerguntaAll;
    }

  return iCont;

 GotoListAll:
  throw TuxBasicOraException(sqlca.sqlcode);

}

int CPergunta::ListId( char* cid )
{
  int    iCont = 0;
  struct sqlca sqlca;
  EXEC SQL BEGIN DECLARE SECTION;
  char* cidOra = cid;
  struct
  {
    VARCHAR stidPergunta[21+1];
    VARCHAR stidTipoApresentacaoPergunta[256+1];
    VARCHAR stdsPergunta[2000+1];
    VARCHAR stinObrigatoria[21+1];
    VARCHAR stinDisponibilidade[21+1];
    VARCHAR stsqApresentacao[12+1];
    VARCHAR stdsScriptPergunta[2000+1];
    VARCHAR stinEncerramento[21+1];
  } stPerguntaRegistro;
  struct
  {
    short iidPergunta;
    short iidTipoApresentacaoPergunta;
    short idsPergunta;
    short iinObrigatoria;
    short iinDisponibilidade;
    short isqApresentacao;
    short idsScriptPergunta;
    short iinEncerramento;
  } stPerguntaIndicator;
  EXEC SQL END DECLARE SECTION;

  ZeraPergunta();

  EXEC SQL WHENEVER NOT FOUND DO break;
  EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
  sqlca.sqlcode=0;

  EXEC SQL DECLARE CursorPerguntaId CURSOR FOR
    SELECT IDPERGUNTA, 
    IDTIPOAPRESENTACAOPERGUNTA, 
    DSPERGUNTA, 
    INOBRIGATORIA, 
    INDISPONIBILIDADE, 
    SQAPRESENTACAO, 
    DSSCRIPTPERGUNTA, 
    INENCERRAMENTO 
    FROM QUESTIONARIO.PERGUNTA PERGUNTA
    WHERE IDPERGUNTA = :cidOra;

  EXEC SQL OPEN CursorPerguntaId;

  if(sqlca.sqlcode)
    return 0;
  else
    {
      for(;;)
	{
	  memset( &stPerguntaRegistro, 0, sizeof(stPerguntaRegistro) );
	  EXEC SQL FETCH CursorPerguntaId INTO :stPerguntaRegistro:stPerguntaIndicator;

	  Add( (char*)stPerguntaRegistro.stidPergunta.arr, 
	       (char*)stPerguntaRegistro.stidTipoApresentacaoPergunta.arr,
	       (char*)stPerguntaRegistro.stdsPergunta.arr,
	       (char*)stPerguntaRegistro.stdsScriptPergunta.arr,
	       (char*)stPerguntaRegistro.stsqApresentacao.arr,
	       (char*)stPerguntaRegistro.stinEncerramento.arr,
	       (char*)stPerguntaRegistro.stinDisponibilidade.arr,
	       (char*)stPerguntaRegistro.stinObrigatoria.arr );

	  iCont++;

	}
      EXEC SQL CLOSE CursorPerguntaId;
    }

  return iCont;

 GotoListId:
  throw TuxBasicOraException(sqlca.sqlcode);

}


int CPergunta::ListIdCanalCampanha( char* cid )
{
  int    iCont = 0;
  struct sqlca sqlca;
  EXEC SQL BEGIN DECLARE SECTION;
  char* cidOra = cid;
  struct
  {
    VARCHAR stidPergunta[21+1];
    VARCHAR stidTipoApresentacaoPergunta[21+1];
    VARCHAR stdsPergunta[2000+1];
    VARCHAR stinObrigatoria[21+1];
    VARCHAR stinDisponibilidade[21+1];
    VARCHAR stsqApresentacao[21+1];
    VARCHAR stdsScriptPergunta[2000+1];
    VARCHAR stinEncerramento[21+1];
  } stPerguntaRegistro;
  struct
  {
    short iidPergunta;
    short iidTipoApresentacaoPergunta;
    short idsPergunta;
    short iinObrigatoria;
    short iinDisponibilidade;
    short isqApresentacao;
    short idsScriptPergunta;
    short iinEncerramento;
  } stPerguntaIndicator;
  EXEC SQL END DECLARE SECTION;

  ZeraPergunta();

  EXEC SQL WHENEVER NOT FOUND DO break;
  EXEC SQL WHENEVER SQLERROR GOTO GotoListIdCanalCampanha;
  sqlca.sqlcode=0;

  EXEC SQL DECLARE CursorPerguntaIdCanalCampanha CURSOR FOR
    SELECT 
	    IDPERGUNTA, 
	    IDTIPOAPRESENTACAOPERGUNTA, 
	    DSPERGUNTA, 
	    INOBRIGATORIA, 
	    INDISPONIBILIDADE, 
	    SQAPRESENTACAO, 
	    DSSCRIPTPERGUNTA, 
	    INENCERRAMENTO 
    FROM 
    	CAMPANHA.CAMPANHAQUESTIONARIOV01
    WHERE 
    	IDCANALCAMPANHA = :cidOra
    AND 
    	INDISPONIBILIDADE = 1
    ORDER BY 
    	SQAPRESENTACAO; 

  EXEC SQL OPEN CursorPerguntaIdCanalCampanha;

  if(sqlca.sqlcode)
    return 0;
  else
    {
      for(;;)
	{
	  memset( &stPerguntaRegistro, 0, sizeof(stPerguntaRegistro) );
	  EXEC SQL FETCH CursorPerguntaIdCanalCampanha INTO :stPerguntaRegistro:stPerguntaIndicator;

	  Add( (char*)stPerguntaRegistro.stidPergunta.arr, 
	       (char*)stPerguntaRegistro.stidTipoApresentacaoPergunta.arr,
	       (char*)stPerguntaRegistro.stdsPergunta.arr,
	       (char*)stPerguntaRegistro.stdsScriptPergunta.arr,
	       (char*)stPerguntaRegistro.stsqApresentacao.arr,
	       (char*)stPerguntaRegistro.stinEncerramento.arr,
	       (char*)stPerguntaRegistro.stinDisponibilidade.arr,
	       (char*)stPerguntaRegistro.stinObrigatoria.arr );

	  iCont++;

	}
      EXEC SQL CLOSE CursorPerguntaIdCanalCampanha;
    }

  return iCont;

 GotoListIdCanalCampanha:
  throw TuxBasicOraException(sqlca.sqlcode);

}

void CPergunta::GetXml( char* cNomeTag, XMLGen*xml )
{
  if( Quantidade() > 0 )
    {
      for( int x = 0; x < Quantidade(); x++ )
	{
	  xml->createTag(cNomeTag);
	  xml->addProp( "xmlns", "campanha.fo.vivo.com.br/vo" );
	  if( Registro( x ) != NULL )
	    {
	      xml->addItem("idPergunta"       , Registro(x)->cidPergunta );
	      xml->addItem("idTipoApresentacaoPergunta" , Registro(x)->cidTipoApresentacaoPergunta );
	      xml->addItem("dsPergunta"       , Registro(x)->cdsPergunta );
	      xml->addItem("inEncerramento"   , Registro(x)->cinEncerramento );
	      xml->addItem("inDisponibilidade", Registro(x)->cinDisponibilidade );
	      xml->addItem("dsScriptPergunta" , Registro(x)->cdsScriptPergunta );
	      xml->addItem("sqApresentacao"   , Registro(x)->csqApresentacao );
	      xml->addItem("inObrigatoria"    , Registro(x)->cinObrigatoria );
	    }
	  xml->closeTag();
	}
    }
}




int CPergunta::UpdateSQApresentacao( char* cidPergunta,
								     char* csqApresentacao)
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidPergunta  = cidPergunta;
		char* cAuxsqApresentacao  = csqApresentacao;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate3;

	EXEC SQL
			UPDATE QUESTIONARIO.PERGUNTA
			SET SQAPRESENTACAO=:cAuxsqApresentacao
			WHERE IDPERGUNTA=:cAuxidPergunta;

  return 1;

  GotoUpdate3:
  throw TuxBasicOraException(sqlca.sqlcode);


}
		
int CPergunta::GetMaxSQAPresentacao(char* cidCanal)
{

	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidCanal  = cidCanal;
		int cAuxSQApresentacao=0;
	EXEC SQL END DECLARE SECTION;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoGetMaxSQAPresentacao;
	

	EXEC SQL 
		SELECT MAX(SQAPRESENTACAO)
		into cAuxSQApresentacao
		FROM QUESTIONARIO.PERGUNTA
		WHERE IDPERGUNTA IN(SELECT IDPERGUNTA 
			  			 	FROM CAMPANHA.CAMPANHAQUESTIONARIO
							WHERE IDCANALCAMPANHA =:cAuxidCanal);
	
	return cAuxSQApresentacao;
 
GotoGetMaxSQAPresentacao:
  throw TuxBasicOraException(sqlca.sqlcode);



}

