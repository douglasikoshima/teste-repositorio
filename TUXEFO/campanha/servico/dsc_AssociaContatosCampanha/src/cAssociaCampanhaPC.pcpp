/**
	Executa as buscas ao banco de dados dos atributos de campanha e
	dos usuários que fazem parte dos grupos da campanha.
 
	@modulo  Campanha
	@usecase Função de associação de campanhas no discador.
	@author  Renato Teixeira
	@version $Revision: 1.1 $
	@CVS     $Author: a5110702 $ - $Date: 2009/07/31 15:34:42 $
*/

#include "../include/cAssocCampanhaPC.h"

	// Declara as estruturas compatíveis ao ProC.
    EXEC SQL BEGIN DECLARE SECTION;
		#include "../include/stAssocCampanha.h"
    EXEC SQL END DECLARE SECTION;

cAssocCampanhaPC::cAssocCampanhaPC()
{}

/**
	Busca os dados que serão escritos no arquivo de carga do discador.
*/
st_DadosCampanha cAssocCampanhaPC::buscaDadosCampanha(int idSubCampanhaHistorico)
{

	struct sqlca sqlca;

	st_DadosCampanha dadosCampanha;

    EXEC SQL BEGIN DECLARE SECTION;

		int idsubcampanhahistorico = idSubCampanhaHistorico;

		int     npu;
		int     idCampanha;
		VARCHAR horaInicioLigacoes[256];
		VARCHAR horaFimLigacoes[256];
		VARCHAR dataHoraInicioCampanha[256];
		VARCHAR dataHoraFimCampanha[256];
		int     numeroTentativas;
		int     intervaloEntreTentativas;

		short i_npu;
		short i_idCampanha;
		short i_horaInicioLigacoes;
		short i_horaFimLigacoes;
		short i_dataHoraInicioCampanha;
		short i_dataHoraFimCampanha;
		short i_numeroTentativas;
		short i_intervaloEntreTentativas;

    EXEC SQL END DECLARE SECTION;

	EXEC SQL
		SELECT 
			0 npu,
			idSubCampanhaHistorico,
			'08:00' horaInicioLigacoes,
			'21:00' horaFimLigacoes,
			TO_CHAR(dtInicio, 'DD/MM/YYYY')||' 00:00:00' dataHoraInicioCampanha,
			TO_CHAR(dtTermino, 'DD/MM/YYYY')||' 23:59:59' dataHoraFimCampanha,
			3 numeroTentativas,
			1 intervaloEntreTentativas
		INTO
			:npu:i_npu,
			:idCampanha:i_idCampanha,
			:horaInicioLigacoes:i_horaInicioLigacoes,
			:horaFimLigacoes:i_horaFimLigacoes,
			:dataHoraInicioCampanha:i_dataHoraInicioCampanha,
			:dataHoraFimCampanha:i_dataHoraFimCampanha,
			:numeroTentativas:i_numeroTentativas,
			:intervaloEntreTentativas:i_intervaloEntreTentativas
		FROM
			campanha.SubCampanhaHistorico
		where 
			idSubCampanhaHistorico = :idsubcampanhahistorico;

		memset(&dadosCampanha, 0, sizeof(dadosCampanha));

		CONVIND(horaInicioLigacoes, i_horaInicioLigacoes);
		CONVIND(horaFimLigacoes, i_horaFimLigacoes);
		CONVIND(dataHoraInicioCampanha, i_dataHoraInicioCampanha);
		CONVIND(dataHoraFimCampanha, i_dataHoraFimCampanha);

		dadosCampanha.npu = npu;
		dadosCampanha.idCampanha = idCampanha;
		strcpy(dadosCampanha.horaInicioLigacoes ,(char*)horaInicioLigacoes.arr);
		strcpy(dadosCampanha.horaFimLigacoes , (char*)horaFimLigacoes.arr);
		strcpy(dadosCampanha.dataHoraInicioCampanha , (char*)dataHoraInicioCampanha.arr);
		strcpy(dadosCampanha.dataHoraFimCampanha , (char*)dataHoraFimCampanha.arr);
		dadosCampanha.numeroTentativas = numeroTentativas;
		dadosCampanha.intervaloEntreTentativas = intervaloEntreTentativas;

	return dadosCampanha;
}

/**
	Busca os dados que serão escritos no arquivo de carga do discador.
*/
Collection* cAssocCampanhaPC::buscaDadosCarga(int idSubCampanhaHistorico)
{

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idsubcampanhahistorico = idSubCampanhaHistorico;

		int nrTelefone;
		int idListaConteudo;

		short i_idListaConteudo;
		short i_nrTelefone;

    EXEC SQL END DECLARE SECTION;

	EXEC SQL DECLARE listaChamadas CURSOR FOR 
		select 
			nrtelefone, 
			min(idlistaconteudo)
		from 
			c_reteixeira.SubCampListaConteudoV01 
		where 
			idSubCampanhaHistorico = :idsubcampanhahistorico 
		group by 
			nrtelefone;

	EXEC SQL WHENEVER SQLERROR DO sql_error_DiscadorCampanha( &sqlca );
    EXEC SQL WHENEVER NOT FOUND DO break;

    EXEC SQL OPEN listaChamadas;

	Collection* cl = new Collection(); 
	RegistroContato* rc = new RegistroContato();

	while (true)
	{
          EXEC SQL FETCH listaChamadas INTO 
											:nrTelefone:i_nrTelefone,
											:idListaConteudo:i_idListaConteudo;

			rc->idListaConteudo = idListaConteudo;
			rc->nrTelefone = nrTelefone;
			cl->AddItem( (void*)rc);
			rc = new RegistroContato();
    }


	EXEC SQL CLOSE listaChamadas;


	return cl;
}

void cAssocCampanhaPC::sql_error_DiscadorCampanha( sqlca * sqlca )
{
	throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
}

/**
	Busca os dados que serão escritos no arquivo de carga do discador.
*/
Collection* cAssocCampanhaPC::buscaDadosUsuarioCampanha(int idSubCampanhaHistorico)
{

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		int idsubcampanhahistorico = idSubCampanhaHistorico;

		int     idPessoaUsuario;
		VARCHAR nmLoginUsuarioCTI[256];

		short i_idPessoaUsuario;
		short i_nmLoginUsuarioCTI;

    EXEC SQL END DECLARE SECTION;

	EXEC SQL DECLARE listaUsuariosCampanha CURSOR FOR 
		SELECT 
			idPessoaUsuario,
			nmLoginUsuarioCTI
		FROM
			c_reteixeira.SubCampanhaUsuarioCTIV01
		WHERE 
			    idSubCampanhaHistorico = :idsubcampanhahistorico
			AND inAtivo = 1
			AND nmLoginUsuarioCTI IS NOT NULL;

	EXEC SQL WHENEVER SQLERROR DO sql_error_DiscadorCampanha( &sqlca );
    EXEC SQL WHENEVER NOT FOUND DO break;

    EXEC SQL OPEN listaUsuariosCampanha;

	Collection* cl = new Collection(); 
	AssociaUsuario* au = new AssociaUsuario();

	while (true)
	{
          EXEC SQL FETCH listaUsuariosCampanha INTO 
											:idPessoaUsuario:i_idPessoaUsuario,
											:nmLoginUsuarioCTI:i_nmLoginUsuarioCTI;

			CONVIND(nmLoginUsuarioCTI, i_nmLoginUsuarioCTI)

			au->idPessoaUsuario = idPessoaUsuario;
			strcpy(au->nmLoginUsuarioCTI, (char*)nmLoginUsuarioCTI.arr);
			cl->AddItem( (void*)au);
			au = new AssociaUsuario();
    }


	EXEC SQL CLOSE listaUsuariosCampanha;
	
	return cl;
}

RegistroContato::RegistroContato()
{}
RegistroContato::~RegistroContato()
{}

AssociaUsuario::AssociaUsuario()
{}
AssociaUsuario::~AssociaUsuario()
{}




