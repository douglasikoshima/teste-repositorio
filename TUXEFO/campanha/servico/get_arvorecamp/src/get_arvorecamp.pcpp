#undef SQLCA
#define SQLCA_NONE

#include "../../negocio/cmputil/include/campanha.hpp"

// definicao de testes dos loops
#define EXISTE_REGISTRO  (!fimLista)
#define MESMO_STATUS ( EXISTE_REGISTRO && (idTipoStatusCampanha == idTipoStatusCampanhaOri))
#define MESMO_MOTIVO ( MESMO_STATUS && (idTipoMotivoCampanha == idTipoMotivoCampanhaOri))

int ConsultaResposta(int usuario, DOMNode*XMLIn, XMLGen*XMLOut)
{
  
  struct sqlca sqlca;
  char parm[255];
  int iCanal=0;
  int iArvoreVazia=0;
  int iCaso=0;
  int counter=0;

  int   iCanalSelecionado=0;
  int	iPerguntaSel=0;
  int   idTipoStatusCampanhaOri;
  int   idTipoMotivoCampanhaOri;
  int   fimLista = 0;
  
  char  respPerg[4000];
  int   idTpApresetacaoProxima;
  //char  Root[255];

  EXEC SQL BEGIN DECLARE SECTION;
  VARCHAR     idCampanha[21+1];
  VARCHAR     idSubCampanha[21+1];
  VARCHAR     idCanalCampanha[21+1];
  VARCHAR     idSubCampanhaHist[21+1];
  VARCHAR     idPergunta[21+1];
  VARCHAR     idResposta[21+1];
  int	      inEncerramento;
  int		  idTipoApresentacao;
  VARCHAR     nmCanal[255+1];
  VARCHAR     dsPergunta[2000];
  VARCHAR     dsResposta[2000];
  VARCHAR     dsProxPerg[2000];
  VARCHAR     idTipoStatusCampanha[21+1];
  VARCHAR     dsTipoStatusCampanha[255];
  VARCHAR     idTipoMotivoCampanha[21+1];
  VARCHAR     dsTipoMotivoCampanha[255+1];
  VARCHAR     idTipoSubMotivoCampanha[21+1];
  VARCHAR     dsTipoSubMotivoCampanha[255+1];
  int	      sqApresentacao;
  int		  sqVersao; 
  VARCHAR	  nmSubCampanha[255+1];
  VARCHAR	  sgTipoApresentacaoPergunta[255+1];
  EXEC SQL END DECLARE SECTION;
  EXEC SQL WHENEVER SQLERROR DO sql_error(NULL);
 

  try
  {

  //obetendo dados do xml
  iArvoreVazia=get_tag(parm, XMLIn, "inCanal", 0, -1);
  if(iArvoreVazia==0)  iCanal=atoi(parm);

  get_tag(parm, XMLIn, "idCampanha", 0, 0);
  strToOra(idCampanha,parm);
  
  get_tag(parm, XMLIn, "idSubCampanha", 0, 0);
  strToOra(idSubCampanha,parm);
  strToOra(idSubCampanhaHist,parm);//para não ter que alterar as comparações no
								   //caso de ser status-motivo-submotivo

  //criando cabeçalho da arvore
	XMLOut->createTag("ItemArvoreVO");
    XMLOut->addProp("xmlns","campanha.fo.vivo.com.br/vo");
    XMLOut->addProp("xsi:schemaLocation","campanha.fo.vivo.com.br/vo");
    XMLOut->addProp("xmlns:xsi","http://www.w3.org/2001/XMLSchema-instance");
  
  //procedimento para verificar se é um canal ou um status motivo submotivo
  if(iArvoreVazia)
  {
	//monta apenas o cabeçalho da arvore
	//com os canais e status-motivo-submotivo

	EXEC SQL 
		SELECT 
				SUBCAMPANHAHISTORICO.IDSUBCAMPANHAHISTORICO, 
				SUBCAMPANHAHISTORICO.SQVERSAO ,
				SUBCAMPANHAFIXA.NMSUBCAMPANHAFIXA
				INTO 
					:idSubCampanhaHist, 
					:sqVersao,
					:nmSubCampanha
				FROM CAMPANHA.SUBCAMPANHAHISTORICO SUBCAMPANHAHISTORICO,
				     CAMPANHA.SUBCAMPANHAFIXA SUBCAMPANHAFIXA
				WHERE
					SUBCAMPANHAHISTORICO.IDSUBCAMPANHAFIXA = SUBCAMPANHAFIXA.IDSUBCAMPANHAFIXA
				AND
					IDSUBCAMPANHAHISTORICO = :idSubCampanha;  

		 endOraStr(idSubCampanhaHist);
		 //endOraStr(sqVersao);
		 endOraStr(nmSubCampanha);
  
	  
		XMLOut->addItem( "codigo",(char *)idSubCampanhaHist.arr);
		XMLOut->addItem( "tipo","1" );
		XMLOut->addItem( "descricao",(char *)nmSubCampanha.arr);
		XMLOut->addItem( "idTipoApresentacao",0 );
		XMLOut->addItem( "inFinal",0 );
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		//Primeiro nível de canais
		 EXEC SQL 
			DECLARE QueryCannal CURSOR FOR 
				SELECT	CANALCAMPANHA.IDCANALCAMPANHA,
						CANAL.NMCANAL|| ' - ' || UF.SGUF, 
						CANALCAMPANHA.SQAPRESENTACAO
				FROM	CAMPANHA.CANALCAMPANHA CANALCAMPANHA,
						CAMPANHA.CANALUFOPERADORA CANALUFOPERADORA,
						CUSTOMER.UFOPERADORA UFOPERADORA,
						APOIO.CANAL CANAL,
						APOIO.UF UF
				WHERE	CANALCAMPANHA.IDCANALUFOPERADORA = CANALUFOPERADORA.IDCANALUFOPERADORA
				AND		CANALUFOPERADORA.IDUFOPERADORA = UFOPERADORA.IDUFOPERADORA
				AND 	UFOPERADORA.IDUF = UF.IDUF
				AND		CANALUFOPERADORA.IDCANAL = CANAL.IDCANAL
				AND 	CANALCAMPANHA.IDSUBCAMPANHAHISTORICO = :idSubCampanhaHist
				AND 	CANALCAMPANHA.INATIVO = 1    
		    	ORDER BY 2; 		

		  EXEC SQL OPEN QueryCannal;
			for( ;; )	
			{
				EXEC SQL FETCH QueryCannal INTO :idCanalCampanha, 
												:nmCanal, 
												:sqApresentacao;

					endOraStr(nmCanal);
					endOraStr(idCanalCampanha);
					counter++;

					XMLOut->createTag("ItemArvoreVO");
						XMLOut->addItem( "codigo",(char*)idCanalCampanha.arr );
						XMLOut->addItem( "tipo",2 );
						XMLOut->addItem( "descricao",( char *)nmCanal.arr );
						XMLOut->addItem( "idTipoApresentacao",0 );
						XMLOut->addItem( "inFinal", 0 );
					XMLOut->closeTag(); 
			}
	
	//status-motivo-sub-motivo
	XMLOut->createTag("ItemArvoreVO");
		XMLOut->addItem( "codigo",0 );
		XMLOut->addItem( "tipo",0 );
		XMLOut->addItem( "descricao","Status - Motivo - SubMotivo");
		XMLOut->addItem( "idTipoApresentacao",0 );
	XMLOut->closeTag(); 
  

  }
  else 
  {
	//escolhe se o objeto clickado é um canal
	// ou status-motivo-submotivo
	//
    if(iCanal)//é um canal
	{

	 iCanalSelecionado=get_tag(parm, XMLIn, "idCanal", 0, 0);
	 strToOra(idCanalCampanha,parm);

	 iPerguntaSel=get_tag(parm, XMLIn, "idPergunta", 0, -1);
	 strToOra(idPergunta,parm);

	iCaso=(iPerguntaSel!=-1)?1:0; //se possui uma pergunta ou apenas um canal(o canal é obrigatório)
		
	switch(iCaso) //Com um switch fica um pouco mais legível
	  {
		case 0:
			
			EXEC SQL DECLARE QueryPergunta CURSOR FOR 
				SELECT	CAMPANHAQUESTIONARIO.IDPERGUNTA, 
						PERGUNTA.SQAPRESENTACAO,
						TIPOAPRESENTACAO.SGTIPOAPRESENTACAOPERGUNTA
				FROM 	CAMPANHA.CAMPANHAQUESTIONARIO CAMPANHAQUESTIONARIO,
						QUESTIONARIO.PERGUNTA PERGUNTA,
						APOIO.TIPOAPRESENTACAOPERGUNTA TIPOAPRESENTACAO
				WHERE	PERGUNTA.IDPERGUNTA = CAMPANHAQUESTIONARIO.IDPERGUNTA
				AND		CAMPANHAQUESTIONARIO.INATIVO = 1 
				AND	    PERGUNTA.IDTIPOAPRESENTACAOPERGUNTA=TIPOAPRESENTACAO.IDTIPOAPRESENTACAOPERGUNTA
				AND		CAMPANHAQUESTIONARIO.IDCANALCAMPANHA = :idCanalCampanha
				ORDER BY PERGUNTA.SQAPRESENTACAO;

		
			EXEC SQL OPEN QueryPergunta;
			for( ;; )			
			{
				EXEC SQL FETCH QueryPergunta INTO :idPergunta, 
												  :sqApresentacao, 
												  :sgTipoApresentacaoPergunta;
				 
				
				endOraStr(idPergunta);
				XMLOut->createTag("ItemArvoreVO");
					XMLOut->addItem( "codigo",(char *)idPergunta.arr);
					XMLOut->addItem( "tipo",3 );
				
				EXEC SQL SELECT DSSCRIPTPERGUNTA, 
								IDTIPOAPRESENTACAOPERGUNTA, 
								INENCERRAMENTO,  
								SQAPRESENTACAO
						 INTO	:dsPergunta, 
								:idTipoApresentacao, 
								:inEncerramento,
								:sqApresentacao
						FROM 	QUESTIONARIO.PERGUNTA 
						WHERE	IDPERGUNTA = :idPergunta 
						ORDER BY SQAPRESENTACAO DESC;

				//endOraStr(idPergunta);
				endOraStr(dsPergunta);
				endOraStr(sgTipoApresentacaoPergunta);
				//endOraStr(idTipoApresentacao);

					XMLOut->addItem( "descricao",(char *)dsPergunta.arr);
					XMLOut->addItem( "idTipoApresentacao",idTipoApresentacao);
					XMLOut->addItem( "sgTipoApresentacaoPergunta",(char *)sgTipoApresentacaoPergunta.arr);
					XMLOut->addItem( "inFinal", inEncerramento);
					XMLOut->addItem( "counter", counter);

				XMLOut->closeTag();
			}
	
		break;
		case 1:
			ULOG("Entrou no case 1");
			EXEC SQL DECLARE QueryResposta CURSOR FOR 
					SELECT	IDRESPOSTA ,
							DSSCRIPTRESPOSTA, 
							INENCERRAMENTO, 
							SQAPRESENTACAO
					FROM	QUESTIONARIO.RESPOSTA
					WHERE	IDPERGUNTA = :idPergunta 
					ORDER BY SQAPRESENTACAO ASC;
		
		EXEC SQL OPEN QueryResposta;
		for( ;; ) 					
		{
		
			EXEC SQL FETCH QueryResposta  INTO :idResposta , 
											   :dsResposta, 
											   :inEncerramento, 
											   :sqApresentacao;
															 
					endOraStr(idResposta);
					endOraStr(dsResposta);

					EXEC SQL WHENEVER NOT FOUND CONTINUE;
											// todo: criar uma view 
					ULOG_INT(idResposta);
					EXEC SQL 
					SELECT 	PERGUNTA.DSSCRIPTPERGUNTA
					INTO 	:dsProxPerg
					FROM  QUESTIONARIO.RESPOSTAPROXIMAPERGUNTA RESPOSTAPROXIMAPERGUNTA,
						  QUESTIONARIO.PERGUNTA PERGUNTA
					WHERE RESPOSTAPROXIMAPERGUNTA.IDPERGUNTA = PERGUNTA.IDPERGUNTA
					AND   RESPOSTAPROXIMAPERGUNTA.IDRESPOSTA = :idResposta
					AND   RESPOSTAPROXIMAPERGUNTA.INATIVO != 0;
  
					if (!sqlca.sqlerrd[2])						
					{
						strToOra(dsProxPerg,"null");
						strcpy(respPerg,( char *)dsResposta.arr);
						idTpApresetacaoProxima=0;
					}						
					else						
					{
						endOraStr(dsProxPerg);
						sprintf(respPerg,"%s - (%s)",(char*)dsResposta.arr,( char *)dsProxPerg.arr);
						idTpApresetacaoProxima=8;
					}
					// ulog_var(dsProxPerg);

					XMLOut->createTag("ItemArvoreVO");
					XMLOut->addItem( "codigo",(char*)idResposta.arr );
					XMLOut->addItem( "tipo",4 );
					XMLOut->addItem( "descricao",respPerg);
					XMLOut->addItem( "idTipoApresentacao",idTpApresetacaoProxima);
					XMLOut->addItem( "inFinal",inEncerramento );
					XMLOut->closeTag();

				} // for_resposta
				
				EXEC SQL CLOSE QueryResposta;
		break;
	  }
	}
	else //é um status-motivo-submotivo
	{
		idTipoStatusCampanhaOri=get_tag(parm, XMLIn, "idStatus", 0,-1);
		strToOra(idTipoStatusCampanha,parm);
	
		idTipoMotivoCampanhaOri=get_tag(parm, XMLIn, "idMotivo", 0, -1);
		strToOra(idTipoMotivoCampanha,parm);
		
		//Nennhum dos itens é obrigatório.	
		iCaso=(idTipoMotivoCampanhaOri!=-1)?2:(idTipoStatusCampanhaOri!=-1)?1:0; 
		ULOG_INT(iCaso);
	  switch(iCaso)
	  {
		case 0:
		ULOG("fuck off");
		ULOG_VAR(idSubCampanhaHist);
			EXEC SQL WHENEVER NOT FOUND DO break;
			EXEC SQL DECLARE QueryStatus CURSOR FOR 
					SELECT IDTIPOSTATUSCAMPANHA,
						   DSTIPOSTATUSCAMPANHA
					FROM apoio.tipostatuscampanha
					WHERE  IDTIPOSTATUSCAMPANHA IN (  SELECT IDTIPOSTATUSCAMPANHA 
	   						   						  FROM	CAMPANHA.MOTIVOCAMPANHAV01
													  WHERE	IDSUBCAMPANHAHISTORICO = :idSubCampanhaHist     
													  AND		INATIVO = 1)
					ORDER BY	IDTIPOSTATUSCAMPANHA;
	
			EXEC SQL OPEN QueryStatus;

		for(;;)
		{
				EXEC SQL FETCH QueryStatus	INTO :idTipoStatusCampanha, 		
												 :dsTipoStatusCampanha;
					 
				
						endOraStr(idTipoStatusCampanha);
						endOraStr(dsTipoStatusCampanha);

						XMLOut->createTag("ItemArvoreVO");
							XMLOut->addItem( "codigo",( char *)idTipoStatusCampanha.arr);
							XMLOut->addItem( "tipo",5 );
							XMLOut->addItem( "descricao",( char *)dsTipoStatusCampanha.arr);
							XMLOut->addItem( "idTipoApresentacao",0 );
							XMLOut->addItem( "inFinal",0 );
						XMLOut->closeTag();
		}
			EXEC SQL CLOSE QueryStatus;
          
		break;
		case 1:
			EXEC SQL DECLARE QueryMotivo CURSOR FOR 
					SELECT IDTIPOMOTIVOCAMPANHA,
						   DSTIPOMOTIVOCAMPANHA
					FROM apoio.tipoMOTIVOcampanha 
					WHERE  IDTIPOMOTIVOCAMPANHA IN(  SELECT IDTIPOMOTIVOCAMPANHA FROM CAMPANHA.MOTIVOCAMPANHAV01
													 WHERE IDSUBCAMPANHAHISTORICO = :idSubCampanhaHist     
											    	 AND	IDTIPOSTATUSCAMPANHA=:idTipoStatusCampanha
													 AND INATIVO = 1)
					ORDER BY IDTIPOMOTIVOCAMPANHA;
			EXEC SQL OPEN QueryMotivo;
            for(;;)
			{
				// Pegando raiz da arvore
				EXEC SQL FETCH QueryMotivo	INTO :idTipoMotivoCampanha, 		
												 :dsTipoMotivoCampanha;
				endOraStr(idTipoMotivoCampanha);
				endOraStr(dsTipoMotivoCampanha);
			
				XMLOut->createTag("ItemArvoreVO");
					XMLOut->addItem( "codigo",( char *)idTipoMotivoCampanha.arr);
					XMLOut->addItem( "tipo",6 );
					XMLOut->addItem( "descricao",( char *)dsTipoMotivoCampanha.arr);
					XMLOut->addItem( "idTipoApresentacao",0 );
					XMLOut->addItem( "inFinal",0 );
				XMLOut->closeTag();
			}
			EXEC SQL CLOSE QueryMotivo;		
		break;
		case 2:
				EXEC SQL DECLARE QuerySubMotivo CURSOR FOR 
						 SELECT IDTIPOSUBMOTIVOCAMPANHA, 
							   DSTIPOSUBMOTIVOCAMPANHA
						FROM apoio.tipoSUBMOTIVOcampanha 
						WHERE  IDTIPOSUBMOTIVOCAMPANHA IN(	SELECT IDTIPOSUBMOTIVOCAMPANHA								
	   													    FROM	CAMPANHA.MOTIVOCAMPANHAV01
															WHERE	IDSUBCAMPANHAHISTORICO = :idSubCampanhaHist
															AND	IDTIPOSTATUSCAMPANHA=:idTipoStatusCampanha
															AND 	IDTIPOMOTIVOCAMPANHA=:idTipoMotivoCampanha
															AND	INATIVO = 1)
						ORDER BY IDTIPOSUBMOTIVOCAMPANHA;

			EXEC SQL OPEN QuerySubMotivo;	
			for(;;)
			{
				// Pegando raiz da arvore
				EXEC SQL FETCH QuerySubMotivo	INTO :idTipoSubMotivoCampanha,
													 :dsTipoSubMotivoCampanha;
				
				endOraStr(idTipoSubMotivoCampanha);
				endOraStr(dsTipoSubMotivoCampanha);
			
				XMLOut->createTag("ItemArvoreVO");
					XMLOut->addItem( "codigo",( char *)idTipoSubMotivoCampanha.arr);
					XMLOut->addItem( "tipo",7 );
					XMLOut->addItem( "descricao",( char *)dsTipoSubMotivoCampanha.arr);
					XMLOut->addItem( "idTipoApresentacao",0 );
					XMLOut->addItem( "inFinal",0 );
				XMLOut->closeTag();
			}
			EXEC SQL CLOSE QuerySubMotivo;
		break;
	  }

	}


  }

  XMLOut->closeTag();
  }  
  catch(...)  
  {	
	  throw;  
  }

  return 1;

}

