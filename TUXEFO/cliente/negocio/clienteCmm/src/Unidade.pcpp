// Unidade.pcpp: implementation for the 
// CUnidade class.
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw.h>
#include "../include/Global.h"
EXEC SQL INCLUDE "../include/Unidade.h";

//
// Construtor e Destrutor
CUnidade::CUnidade() {
}

CUnidade::CUnidade(int iIdUn) {
    
    ULOG_START("CUnidade::CUnidade()"); 
	struct sqlca sqlca;

	iIdUnidade = iIdUn;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL SELECT
	 CdUnidade,
	 NmUnidade
	INTO
	 cCdUnidade,
	 cNmUnidade
	FROM
	 acesso.Unidade
	WHERE
	 IdUnidade = :iIdUnidade;

	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND)
		iIdUnidade = -1;
		
    ULOG_END("CUnidade::CUnidade()"); 
	return;

	sqlErrorConstrutor:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
	    ULOG_END("CUnidade::CUnidade()"); 
		throw TuxBasicOraException(sqlca.sqlcode);
}

CUnidade::~CUnidade() {
}

//
// Metodos getter
int CUnidade::getIdUnidade(){
	return iIdUnidade;
}

char* CUnidade::getCdUnidade(){
	return cCdUnidade;
}

char* CUnidade::getNmUnidade(){
	return cNmUnidade;
}

//
// Metodos setter
void CUnidade::setIdUnidade(int value){
	iIdUnidade = value;
}

void CUnidade::setCdUnidade(char* value){
	strncpy(cCdUnidade, value, 255);
	cCdUnidade[255]='\0';
}

void CUnidade::setNmUnidade(char* value){
	strncpy(cNmUnidade, value, 255);
	cNmUnidade[255]='\0';
}

CUnidade* CUnidade::lista(int* iNroObjetos){
    
    ULOG_START("CUnidade::lista()"); 
	struct sqlca sqlca;
	CUnidade* listaUnidade = NULL;
	int iNroObjLocal = 1;

	EXEC SQL BEGIN DECLARE SECTION;
	int iIdUnidade;
	char cCdUnidade[256];
	char cNmUnidade[256];
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL DECLARE Unidades CURSOR FOR
	SELECT
	 IdUnidade,
	 CdUnidade,
	 NmUnidade
	FROM
	 acesso.Unidade
    WHERE
     cdunidade like 'CORR%';

	EXEC SQL OPEN Unidades;

	// Corre os dados e monta a lista de objetos
	EXEC SQL WHENEVER NOT FOUND DO break;
	for (;; iNroObjLocal++) {
		
		EXEC SQL FETCH Unidades INTO
		 :iIdUnidade,
		 :cCdUnidade,
		 :cNmUnidade;

		// Aloca memória para o objeto atual.
		if ((listaUnidade = (CUnidade*) realloc((void *)listaUnidade, (sizeof(CUnidade) * iNroObjLocal))) != NULL) {
			
			// Coloca os dados do objeto atual.
            int index = iNroObjLocal-1;
			listaUnidade[index].setIdUnidade(iIdUnidade);
			listaUnidade[index].setCdUnidade(cCdUnidade);
			listaUnidade[index].setNmUnidade(cNmUnidade);

		} else {
			if (listaUnidade)
				free(listaUnidade);
				
			ULOG_END("CUnidade::lista()"); 
			throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
		}
	}

	*iNroObjetos = iNroObjLocal - 1;
	ULOG_END("CUnidade::lista()"); 
	return listaUnidade;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
	    ULOG_END("CUnidade::lista()"); 
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CUnidade::getIdFakeUnidade(){
	return 1;
}
