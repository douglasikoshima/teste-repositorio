#undef SQLCA
#define SQLCA_NONE
#include <sqlca.h>

#include <tuxfw.h>
#include "../include/Funcoes.h"

EXEC SQL BEGIN DECLARE SECTION;
EXEC SQL INCLUDE "../include/Global.h";
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE "../include/classPessoaEndereco.h";


// Usuário de alteração
void CPessoaEndereco::setUsuarioAlteracao(char* value) {
	if (value != NULL) {
		strncpy(sIdUsuarioAlteracao,value, 255);
		sIdUsuarioAlteracao[255]='\0';
	}
}

CPessoaEndereco::CPessoaEndereco()
{
    memset(&tPessEnd, 0x00, sizeof(tPessEnd));
	memset(sIdUsuarioAlteracao,0,256);
}

CPessoaEndereco::~CPessoaEndereco()
{
}

char* CPessoaEndereco::getIdPessoa(void)
{
    return ((char *)tPessEnd.sIdPessoa.arr);
}
char* CPessoaEndereco::getIdEndereco(void)
{
    return ((char *)tPessEnd.sIdEndereco.arr);
}
char* CPessoaEndereco::getIdTipoEndereco(void)
{
    return ((char *)tPessEnd.sIdTipoEndereco.arr);
}
char* CPessoaEndereco::getSgTipoEndereco(void)
{
    return ((char *)tPessEnd.sSgTipoEndereco.arr);
}
char* CPessoaEndereco::getDsTipoEndereco(void)
{
    return ((char *)tPessEnd.sDsTipoEndereco.arr);
}
char* CPessoaEndereco::getCodLogradouro(void)
{
    return ((char *)tPessEnd.sCodLogradouro.arr);
}
char* CPessoaEndereco::getInCnl(void)
{
    return ((char *)tPessEnd.sInCnl.arr);
}
char* CPessoaEndereco::getInCodigoIBGE(void)
{
    return ((char *)tPessEnd.sInCodigoIBGE.arr);
}
char* CPessoaEndereco::getNmTipoLogradouro(void)
{
    return ((char *)tPessEnd.sNmTipoLogradouro.arr);
}
char* CPessoaEndereco::getNmTituloLogradouro(void)
{
    return ((char *)tPessEnd.sNmTituloLogradouro.arr);
}
char* CPessoaEndereco::getNmLogradouro(void)
{
    return ((char *)tPessEnd.sNmLogradouro.arr);
}
char* CPessoaEndereco::getNmLogradouro1(void)
{
    return ((char *)tPessEnd.sNmLogradouro1.arr);
}
char* CPessoaEndereco::getNmBairro(void)
{
    return ((char *)tPessEnd.sNmBairro.arr);
}
char* CPessoaEndereco::getNmMunicipio(void)
{
    return ((char *)tPessEnd.sNmMunicipio.arr);
}
char* CPessoaEndereco::getNrEndereco(void)
{
    return ((char *)tPessEnd.sNrEndereco.arr);
}
char* CPessoaEndereco::getDsEnderecoComplemento(void)
{
    return ((char *)tPessEnd.sDsEnderecoComplemento.arr);
}
char* CPessoaEndereco::getNrLinhaAssociada(void)
{
    return ((char *)tPessEnd.sNrLinhaAssociada.arr);
}
char* CPessoaEndereco::getNrCep(void)
{
    return ((char *)tPessEnd.sNrCep.arr);
}
char* CPessoaEndereco::getIdUF(void)
{
    return ((char *)tPessEnd.sIdUF.arr);
}
char* CPessoaEndereco::getSgUF(void)
{
    return ((char *)tPessEnd.sSgUF.arr);
}
char* CPessoaEndereco::getNmUF(void)
{
    return ((char *)tPessEnd.sNmUF.arr);
}
char* CPessoaEndereco::getIdPais(void)
{
    return ((char *)tPessEnd.sIdPais.arr);
}
char* CPessoaEndereco::getSgPais(void)
{
    return ((char *)tPessEnd.sSgPais.arr);
}
char* CPessoaEndereco::getNmPais(void)
{
    return ((char *)tPessEnd.sNmPais.arr);
}
char* CPessoaEndereco::getDsNacionalidade(void)
{
    return ((char *)tPessEnd.sDsNacionalidade.arr);
}
char* CPessoaEndereco::getDtCadastroOut(void)
{
    return ((char *)tPessEnd.sDtCadastroOut.arr);
}
char* CPessoaEndereco::getNmPessoaContato(void)
{
    return ((char *)tPessEnd.sNmPessoaContato.arr);
}
char* CPessoaEndereco::getInEnderecoPreferencial(void)
{
    return ((char *)tPessEnd.sInEnderecoPreferencial.arr);
}
char* CPessoaEndereco::getDtExpiracaoOut(void)
{
    return ((char *)tPessEnd.sDtExpiracaoOut.arr);
}
long CPessoaEndereco::getTsSincronismo(void)
{
    return (tPessEnd.lTsSincronismo);
}
long CPessoaEndereco::getSqSincronismo(void)
{
    return (tPessEnd.lSqSincronismo);
}
char* CPessoaEndereco::getIdSistemaOrigem(void)
{
    return ((char *)tPessEnd.sIdSistemaOrigem.arr);
}
char* CPessoaEndereco::getIdSistemaOrigemBase(void)
{
    return ((char *)tPessEnd.sIdSistemaOrigemBase.arr);
}
char* CPessoaEndereco::getDtUltimaAlteracao(void)
{
    return ((char *)tPessEnd.sDtUltimaAlteracao.arr);
}

//
// Metodos setter
void CPessoaEndereco::setIdPessoa(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sIdPessoa, pDado);
}
void CPessoaEndereco::setIdEndereco(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sIdEndereco, pDado);
}
void CPessoaEndereco::setIdTipoEndereco(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sIdTipoEndereco, pDado);
}
void CPessoaEndereco::setSgTipoEndereco(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sSgTipoEndereco, pDado);
}
void CPessoaEndereco::setDsTipoEndereco(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sDsTipoEndereco, pDado);
}
void CPessoaEndereco::setNmTipoLogradouro(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sNmTipoLogradouro, pDado);
}
void CPessoaEndereco::setCodLogradouro(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sCodLogradouro, pDado);
}
void CPessoaEndereco::setInCnl(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sInCnl, pDado);
}
void CPessoaEndereco::setInCodigoIBGE(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sInCodigoIBGE, pDado);
}
void CPessoaEndereco::setNmTituloLogradouro(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sNmTituloLogradouro, pDado);
}
void CPessoaEndereco::setNmLogradouro(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sNmLogradouro, pDado);
}
void CPessoaEndereco::setNmLogradouro1(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sNmLogradouro1, pDado);
}
void CPessoaEndereco::setNmBairro(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sNmBairro, pDado);
}
void CPessoaEndereco::setNmMunicipio(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sNmMunicipio, pDado);
}
void CPessoaEndereco::setNrEndereco(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sNrEndereco, pDado);
}
void CPessoaEndereco::setNrLinhaAssociada(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sNrLinhaAssociada, pDado);
}
void CPessoaEndereco::setDsEnderecoComplemento(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sDsEnderecoComplemento, pDado);
}
void CPessoaEndereco::setNrCep(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sNrCep, pDado);
}
void CPessoaEndereco::setIdUF(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sIdUF, pDado);
}
void CPessoaEndereco::setSgUF(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sSgUF, pDado);
}
void CPessoaEndereco::setNmUF(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sNmUF, pDado);
}
void CPessoaEndereco::setIdPais(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sIdPais, pDado);
}
void CPessoaEndereco::setSgPais(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sSgPais, pDado);
}
void CPessoaEndereco::setNmPais(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sNmPais, pDado);
}
void CPessoaEndereco::setDsNacionalidade(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sDsNacionalidade, pDado);
}
void CPessoaEndereco::setDtCadastroOut(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sDtCadastroOut, pDado);
}
void CPessoaEndereco::setNmPessoaContato(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sNmPessoaContato, pDado);
}
void CPessoaEndereco::setInEnderecoPreferencial(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sInEnderecoPreferencial, pDado);
}
void CPessoaEndereco::setDtExpiracaoOut(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sDtExpiracaoOut, pDado);
}
void CPessoaEndereco::setTsSincronismo(long lDado)
{
    tPessEnd.lTsSincronismo =  lDado;
}
void CPessoaEndereco::setSqSincronismo(long lDado)
{
    tPessEnd.lSqSincronismo=  lDado;
}
void CPessoaEndereco::setIdSistemaOrigem(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sIdSistemaOrigem, pDado);
}
void CPessoaEndereco::setIdSistemaOrigemBase(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sIdSistemaOrigemBase, pDado);
}
void CPessoaEndereco::setDtUltimaAlteracao(char* pDado)
{
    STRCPY_TO_ORA(tPessEnd.sDtUltimaAlteracao, pDado);
}


/*************************************************************************************************/
int CPessoaEndereco::Incluir()
{
    ULOG_START("CPessoaEndereco::Incluir()");    
    struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR dsSequence[255];
	EXEC SQL END DECLARE SECTION;

    char szAux[255 + 1];

	EXEC SQL
        SELECT COUNT(1)
        INTO :dsSequence
        FROM customer.pessoaendereco
        WHERE idPessoa = :tPessEnd.sIdPessoa;

    STRCPY_FROM_ORA(szAux, dsSequence);

	if(atoi(szAux) == 0) {
		STRCPY_TO_ORA(dsSequence,"1");
    }

    ULOGI("PessoaEndereco, valor da nrSequencia [%.*s]" ,dsSequence.len, dsSequence.arr);

    /* Obtendo a sequence */
    EXEC SQL SELECT customer.pessoaenderecosq.NEXTVAL 
               INTO :tPessEnd.sIdEndereco:tPessEnd.iIdEndereco_ora
               FROM dual;

    ULOGI("Local1");
	EXEC SQL WHENEVER SQLERROR	goto erro;

    ULOGI("Local2");
    EXEC SQL INSERT INTO customer.pessoaendereco (
                         idpessoaendereco
                        ,idpais
                        ,idpessoa
                        ,idsistemaorigem
                        ,idtipoendereco
                        ,iduf
                        ,cdcaixapostal
                        ,dsaoscuidados
                        ,dsenderecocomplemento
                        ,dtcadastro
                        ,dtexpiracao
                        ,dtultimaalteracao
                        ,idenderecosistemaorigem
                        ,idusuarioalteracao
                        ,inenderecopreferencial
                        ,nmbairro
                        ,nmlocalidade
                        ,nmlogradouro
                        ,nmmunicipio
                        ,nmtipologradouro
                        ,nmtitulologradouro
                        ,nrcep
                        ,nrendereco
                        ,nrsequencia
                        ,sqsincronismo
                        ,tssincronismo)
                VALUES ( :tPessEnd.sIdEndereco:tPessEnd.iIdEndereco_ora
                        ,:tPessEnd.sIdPais:tPessEnd.iIdPais_ora
                        ,:tPessEnd.sIdPessoa:tPessEnd.iIdPessoa_ora
                        ,7
                        ,:tPessEnd.sIdTipoEndereco:tPessEnd.iIdTipoEndereco_ora
                        ,:tPessEnd.sIdUF:tPessEnd.iIdUF_ora
                        ,''
                        ,''
                        ,:tPessEnd.sDsEnderecoComplemento:tPessEnd.iDsEnderecoComplemento_ora
                        ,SYSDATE
                        ,''
                        ,SYSDATE
                        ,:tPessEnd.sIdEndereco:tPessEnd.iIdEndereco_ora
                        ,:sIdUsuarioAlteracao
                        ,''
                        ,:tPessEnd.sNmBairro:tPessEnd.iNmBairro_ora
                        ,''
                        ,:tPessEnd.sNmLogradouro:tPessEnd.iNmLogradouro_ora
                        ,:tPessEnd.sNmMunicipio:tPessEnd.iNmMunicipio_ora
                        ,:tPessEnd.sNmTipoLogradouro:tPessEnd.iNmTipoLogradouro_ora
                        ,:tPessEnd.sNmTituloLogradouro:tPessEnd.iNmTituloLogradouro_ora
                        ,:tPessEnd.sNrCep:tPessEnd.iNrCep_ora
                        ,:tPessEnd.sNrEndereco:tPessEnd.iNrEndereco_ora
                        ,:dsSequence
                        ,''
                        ,'');

    ULOG_END("CPessoaEndereco::Incluir() - OK");
    if (!sqlca.sqlerrd[2])
        return NOK;
    else
        return OK;

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::Incluir() - ERROR"); 
		throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/*************************************************************************************************/
int CPessoaEndereco::Excluir()
{
    ULOG_START("CPessoaEndereco::Excluir()");    
    struct sqlca sqlca;

	EXEC SQL WHENEVER SQLERROR	goto erro;

    /* Exclusao logica */
    EXEC SQL UPDATE customer.pessoaendereco
                SET dtexpiracao        = SYSDATE,
                    idusuarioalteracao = :sIdUsuarioAlteracao,
                    dtultimaalteracao  = SYSDATE
              WHERE idpessoaendereco = :tPessEnd.sIdEndereco;

  
    ULOG_END("CPessoaEndereco::Excluir()");    
    if (!sqlca.sqlerrd[2])
        return NOK;
    else
        return OK;

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::Excluir()");    
		throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,
					sqlca.sqlerrm.sqlerrml);
}

/*************************************************************************************************/
bool CPessoaEndereco::existePessoaEnderecoContaEndereco(void)
{
    ULOG_START("CPessoaEndereco::existePessoaEnderecoContaEndereco()");
    struct sqlca sqlca;

    ULOG("local10");
    ULOG("(char *)&tPessEnd.sIdEndereco.arr[%s]", (char *)&tPessEnd.sIdEndereco.arr);

	EXEC SQL BEGIN DECLARE SECTION;
        int oiCount;
        VARCHAR oszIdPessoaEndereco[21];
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR	goto erro;

    STRCPY_TO_ORA(oszIdPessoaEndereco, (char *)&tPessEnd.sIdEndereco.arr);

    ULOG("oszIdPessoaEndereco[%.*s]", oszIdPessoaEndereco.len, oszIdPessoaEndereco.arr);

    EXEC SQL
        SELECT
            COUNT(*)
        INTO
            :oiCount
        FROM
            customer.pessoaendereco cpe,
            customer.contaendereco cce
        WHERE
            cpe.idpessoaendereco = cce.idpessoaendereco
        AND
            cpe.dtexpiracao is null
        AND
            cpe.idpessoaendereco = :oszIdPessoaEndereco;

    ULOG("oiCount(%d)", oiCount);
	ULOG_END("CPessoaEndereco::existePessoaEnderecoContaEndereco()");

    return (oiCount?true:false);

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::existePessoaEnderecoContaEndereco()");
		throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/*************************************************************************************************/
bool CPessoaEndereco::existePessoaEnderecoIdSistemaOrigem1(void)
{
    ULOG_START("CPessoaEndereco::existePessoaEnderecoIdSistemaOrigem1()");
    struct sqlca sqlca;

    ULOG("(char *)&tPessEnd.sIdEndereco.arr[%s]", (char *)&tPessEnd.sIdEndereco.arr);

	EXEC SQL BEGIN DECLARE SECTION;
        int oiCount;
        VARCHAR oszIdPessoaEndereco[21];
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR	goto erro;

    STRCPY_TO_ORA(oszIdPessoaEndereco, (char *)&tPessEnd.sIdEndereco.arr);

    EXEC SQL
        SELECT
            COUNT(*)
        INTO
            :oiCount
        FROM
            customer.pessoaendereco cpe
        WHERE
            cpe.dtexpiracao is null
        AND
            cpe.idsistemaorigem = 1
        AND
            cpe.idpessoaendereco = :oszIdPessoaEndereco;

    ULOG("oiCount(%d)", oiCount);
	ULOG_END("CPessoaEndereco::existePessoaEnderecoIdSistemaOrigem1()");

    return (oiCount?true:false);

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::existePessoaEnderecoIdSistemaOrigem1()");
		throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/*************************************************************************************************/
bool CPessoaEndereco::existePessoaEnderecoIdSistemaOrigem4ou7(void)
{
    ULOG_START("CPessoaEndereco::existePessoaEnderecoIdSistemaOrigem4ou7()");
    struct sqlca sqlca;

    ULOG("(char *)&tPessEnd.sIdEndereco.arr[%s]", (char *)&tPessEnd.sIdEndereco.arr);

	EXEC SQL BEGIN DECLARE SECTION;
        int oiCount;
        VARCHAR oszIdPessoaEndereco[21];
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR	goto erro;

    STRCPY_TO_ORA(oszIdPessoaEndereco, (char *)&tPessEnd.sIdEndereco.arr);


    EXEC SQL
        SELECT
            COUNT(*)
        INTO
            :oiCount
        FROM
            customer.pessoaendereco cpe
        WHERE
            cpe.dtexpiracao IS NULL
        AND
            cpe.idsistemaorigem = 1
        AND
            cpe.idpessoaendereco in (SELECT idpessoaendereco from customer.contaendereco where idpessoaendereco = :oszIdPessoaEndereco)
        AND
            cpe.idpessoaendereco = :oszIdPessoaEndereco;


    ULOG("oiCount(%d)", oiCount);
	ULOG_END("CPessoaEndereco::existePessoaEnderecoIdSistemaOrigem4ou7()");

    return (oiCount?true:false);

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::existePessoaEnderecoIdSistemaOrigem4ou7()");
		throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/*************************************************************************************************/
bool CPessoaEndereco::existeCEnderecoePessoaIdSO7(void)
{
    ULOG_START("CPessoaEndereco::existeCEnderecoePessoaIdSO7()");
    struct sqlca sqlca;

    ULOG("(char *)&tPessEnd.sIdEndereco.arr[%s]", (char *)&tPessEnd.sIdEndereco.arr);

	EXEC SQL BEGIN DECLARE SECTION;
        int oiCount;
        VARCHAR oszIdPessoaEndereco[21];
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR	goto erro;

    STRCPY_TO_ORA(oszIdPessoaEndereco, (char *)&tPessEnd.sIdEndereco.arr);

    EXEC SQL
        SELECT
            COUNT(*)
        INTO
            :oiCount
        FROM
            customer.pessoaendereco cpe,
            customer.pessoa cp,
            customer.contaendereco cce
        WHERE
            cp.idpessoa = cpe.idpessoa
        AND
            cpe.idpessoaendereco = cce.idpessoaendereco
        AND
            cce.dtexpiracao IS NULL
        AND
            cp.idsistemaorigem in (7,9,28)
        AND
            cce.idpessoaendereco = :oszIdPessoaEndereco;

    ULOG("oiCount(%d)", oiCount);
	ULOG_END("CPessoaEndereco::existeCEnderecoePessoaIdSO7()");

    return (oiCount?true:false);

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::existeCEnderecoePessoaIdSO7()");
		throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/*************************************************************************************************/
bool CPessoaEndereco::existePessoaEnderecoIdSistemaOrigem7(void)
{
    ULOG_START("CPessoaEndereco::existePessoaEnderecoIdSistemaOrigem7()");
    struct sqlca sqlca;

    ULOG("(char *)&tPessEnd.sIdEndereco.arr[%s]", (char *)&tPessEnd.sIdEndereco.arr);

	EXEC SQL BEGIN DECLARE SECTION;
        int oiCount;
        VARCHAR oszIdPessoaEndereco[21];
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR	goto erro;

    STRCPY_TO_ORA(oszIdPessoaEndereco, (char *)&tPessEnd.sIdEndereco.arr);

    EXEC SQL
        SELECT
            COUNT(1)
        INTO
            :oiCount
        FROM
            customer.pessoaendereco
        WHERE
            idsistemaorigem in (7,9,28)
        AND
            dtexpiracao IS NULL
        AND
            idpessoaendereco = :oszIdPessoaEndereco;

    ULOG("oiCount(%d)", oiCount);
	ULOG_END("CPessoaEndereco::existePessoaEnderecoIdSistemaOrigem7()");

    return (oiCount?true:false);

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::existePessoaEnderecoIdSistemaOrigem7()");
		throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/*************************************************************************************************/
int CPessoaEndereco::Alterar()
{
    ULOG_START("CPessoaEndereco::Alterar()");    
    struct sqlca sqlca;

	EXEC SQL WHENEVER SQLERROR	goto erro;

    EXEC SQL UPDATE customer.pessoaendereco
                SET nrcep                 = :tPessEnd.sNrCep:tPessEnd.iNrCep_ora,
                    idtipoendereco        = :tPessEnd.sIdTipoEndereco:tPessEnd.iIdTipoEndereco_ora,
                    nmtipologradouro      = :tPessEnd.sNmTipoLogradouro:tPessEnd.iNmTipoLogradouro_ora,
                    nmtitulologradouro    = :tPessEnd.sNmTituloLogradouro:tPessEnd.iNmTituloLogradouro_ora,
                    nmlogradouro          = :tPessEnd.sNmLogradouro:tPessEnd.iNmLogradouro_ora,
                    nrendereco            = :tPessEnd.sNrEndereco:tPessEnd.iNrEndereco_ora,
                    dsenderecocomplemento = :tPessEnd.sDsEnderecoComplemento:tPessEnd.iDsEnderecoComplemento_ora,
                    nmbairro              = :tPessEnd.sNmBairro:tPessEnd.iNmBairro_ora,
                    nmmunicipio           = :tPessEnd.sNmMunicipio:tPessEnd.iNmMunicipio_ora,
                    iduf                  = :tPessEnd.sIdUF:tPessEnd.iIdUF_ora,
                    idpais                = :tPessEnd.sIdPais:tPessEnd.iIdPais_ora,
                    idusuarioalteracao    = :sIdUsuarioAlteracao,
                    dtultimaalteracao     = SYSDATE
              WHERE idpessoaendereco = :tPessEnd.sIdEndereco;

    ULOG_END("CPessoaEndereco::Alterar()");    
    if (!sqlca.sqlerrd[2])
        return NOK;
    else
        return OK;

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::Alterar()");    
		throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/******************************************************************************************************/
int CPessoaEndereco::buscarPorIdLinhaTelefonica(char *pIdPessoa, char *pIdLinhaTelefonica)
{
    ULOG_START("CPessoaEndereco::buscarPorIdLinhaTelefonica()");
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        char *pORAIdPessoa = pIdPessoa;
        char *pORAIdLinhaTelefonica = pIdLinhaTelefonica;
	EXEC SQL END DECLARE SECTION;

    ULOG("pORAIdPessoa[%s]", pORAIdPessoa);
    ULOG("pORAIdLinhaTelefonica[%s]", pORAIdLinhaTelefonica);

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorPorIdConta;

     EXEC SQL 
          SELECT idpessoaendereco
               , idtipoendereco
               , sgtipoendereco
               , dstipoendereco
               , nmtipologradouro
               , nmtitulologradouro
               , logradouro
               , nmlogradouro
               , nmbairro
               , nmmunicipio
               , nrendereco
               , dsenderecocomplemento
               , nrcep
               , iduf
               , sguf
               , nmuf
               , idpais
               , sgpais
               , nmpais
               , dsnacionalidade
               , dtcadastro
               , dsaoscuidados
               , inenderecopreferencial
               , dtexpiracao
               , tssincronismo
               , sqsincronismo
               , dtultimaalteracao
            INTO :tPessEnd.sIdEndereco:tPessEnd.iIdEndereco_ora
               , :tPessEnd.sIdTipoEndereco:tPessEnd.iIdTipoEndereco_ora
               , :tPessEnd.sSgTipoEndereco:tPessEnd.iSgTipoEndereco_ora
               , :tPessEnd.sDsTipoEndereco:tPessEnd.iDsTipoEndereco_ora
               , :tPessEnd.sNmTipoLogradouro:tPessEnd.iNmTipoLogradouro_ora
               , :tPessEnd.sNmTituloLogradouro:tPessEnd.iNmTituloLogradouro_ora
               , :tPessEnd.sNmLogradouro:tPessEnd.iNmLogradouro_ora
               , :tPessEnd.sNmLogradouro1:tPessEnd.iNmLogradouro1_ora
               , :tPessEnd.sNmBairro:tPessEnd.iNmBairro_ora
               , :tPessEnd.sNmMunicipio:tPessEnd.iNmMunicipio_ora
               , :tPessEnd.sNrEndereco:tPessEnd.iNrEndereco_ora
               , :tPessEnd.sDsEnderecoComplemento:tPessEnd.iDsEnderecoComplemento_ora
               , :tPessEnd.sNrCep:tPessEnd.iNrCep_ora
               , :tPessEnd.sIdUF:tPessEnd.iIdUF_ora
               , :tPessEnd.sSgUF:tPessEnd.iSgUF_ora
               , :tPessEnd.sNmUF:tPessEnd.iNmUF_ora
               , :tPessEnd.sIdPais:tPessEnd.iIdPais_ora
               , :tPessEnd.sSgPais:tPessEnd.iSgPais_ora
               , :tPessEnd.sNmPais:tPessEnd.iNmPais_ora
               , :tPessEnd.sDsNacionalidade:tPessEnd.iDsNacionalidade_ora
               , :tPessEnd.sDtCadastroOut:tPessEnd.iDtCadastroOut_ora
               , :tPessEnd.sNmPessoaContato:tPessEnd.iNmPessoaContato_ora
               , :tPessEnd.sInEnderecoPreferencial:tPessEnd.iInEnderecoPreferencial_ora
               , :tPessEnd.sDtExpiracaoOut:tPessEnd.iDtExpiracaoOut_ora
               , :tPessEnd.lTsSincronismo:tPessEnd.iTsSincronismo_ora
               , :tPessEnd.lSqSincronismo:tPessEnd.iSqSincronismo_ora
               , :tPessEnd.sDtUltimaAlteracao:tPessEnd.iDtUltimaAlteracao_ora
          FROM
          (
              SELECT pessoaendereco.idpessoaendereco
                   , pessoaendereco.idtipoendereco
                   , tipoendereco.sgtipoendereco
                   , tipoendereco.dstipoendereco
                   , pessoaendereco.nmtipologradouro
                   , pessoaendereco.nmtitulologradouro
                   , pessoaendereco.nmtipologradouro||' '||pessoaendereco.nmtitulologradouro||' '||pessoaendereco.nmlogradouro as logradouro
                   , pessoaendereco.nmlogradouro
                   , pessoaendereco.nmbairro
                   , pessoaendereco.nmmunicipio
                   , pessoaendereco.nrendereco
                   , pessoaendereco.dsenderecocomplemento
                   , pessoaendereco.nrcep
                   , pessoaendereco.iduf
                   , uf.sguf
                   , uf.nmuf
                   , pessoaendereco.idpais
                   , pais.sgpais
                   , pais.nmpais
                   , pais.dsnacionalidade
                   , pessoaendereco.dtcadastro
                   , pessoaendereco.dsaoscuidados
                   , pessoaendereco.inenderecopreferencial
                   , pessoaendereco.dtexpiracao
                   , DECODE(pessoaendereco.tssincronismo, '', 0, 1) tssincronismo
                   , DECODE(pessoaendereco.sqsincronismo, '', 0, 1) sqsincronismo
                   , pessoaendereco.dtultimaalteracao
                FROM customer.contaendereco      contaendereco
                   , customer.pessoaendereco     pessoaendereco
                   , apoio.tipoendereco          tipoendereco
                   , apoio.pais                  pais
                   , apoio.uf                    uf
                   , customer.linhaconta         linhaconta
               WHERE pessoaendereco.idpessoa = :pORAIdPessoa
                 AND pais.idpais = pessoaendereco.IDPAIS
                 AND uf.iduf = pessoaendereco.iduf
                 AND tipoendereco.idtipoendereco = pessoaendereco.idtipoendereco
                 AND contaendereco.idpessoaendereco = pessoaendereco.idpessoaendereco
                 /* AND pessoaendereco.dtexpiracao IS NULL */  // Esta regra se aplica somente a linhas moveis
                 AND (( pessoaendereco.dtexpiracao IS NULL ) OR ( pessoaendereco.dtexpiracao > trunc(sysdate) ))
                 AND linhaconta.idconta = contaendereco.idconta
                 AND linhaconta.idlinhatelefonica = :pORAIdLinhaTelefonica
                 ORDER BY
                     contaendereco.idtipoenderecocobranca desc
            )
            WHERE
                 ROWNUM < 2;


	ULOG_END("CPessoaEndereco::buscarPorIdLinhaTelefonica()");
	return OK;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorPorIdConta:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::buscarPorIdLinhaTelefonica()");    
		throw new TuxBasicOraException(sqlca.sqlcode);
}

/*************************************************************************************************/
int CPessoaEndereco::buscarPorNrLinha(char *pNrLin)
{
    ULOG_START("CPessoaEndereco::buscarPorNrLinha()");    
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        long lOraIdConta;
        short iOraIdConta_ora;
	    char cOraDDD[3];
	    char cOraFone[10];
	EXEC SQL END DECLARE SECTION;

	strncpy(cOraDDD, pNrLin, 2);
	cOraDDD[2]='\0';
	strcpy( cOraFone, (char*)&pNrLin[2] );

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorPorIdConta;

    /* Recuperando o idConta da Linha Telefonica */
    EXEC SQL 
        SELECT MAX(idconta)
          INTO :lOraIdConta:iOraIdConta_ora
          FROM customer.linhaconta,
               linha.linhatelefonica,
               linha.linhabase,
               apoio.arearegistro
         WHERE linhatelefonica.idlinhatelefonica = linhaconta.idlinhatelefonica
           AND linhabase.idlinhabase             = linhatelefonica.idlinhabase
           AND arearegistro.idarearegistro       = linhabase.idarearegistro
           AND linhabase.nrlinha                 = :cOraFone
           AND arearegistro.cdarearegistro       = :cOraDDD;

	if (sqlca.sqlcode != 1403 && iOraIdConta_ora != -1)
         // Declara e abre o cursor
         EXEC SQL 
            SELECT pessoaendereco.idpessoaendereco,
                   tipoendereco.idtipoendereco,
                   tipoendereco.sgtipoendereco,
                   tipoendereco.dstipoendereco,
                   pessoaendereco.nmtipologradouro,
                   pessoaendereco.nmtitulologradouro,
                   pessoaendereco.nmtipologradouro||' '||pessoaendereco.nmtitulologradouro||' '||pessoaendereco.nmlogradouro,
                   pessoaendereco.nmlogradouro,
                   pessoaendereco.nmbairro,
                   pessoaendereco.nmmunicipio,
                   pessoaendereco.nrendereco,
                   pessoaendereco.dsenderecocomplemento,
                   pessoaendereco.nrcep,
                   uf.iduf,
                   uf.sguf,
                   uf.nmuf,
                   pais.idpais,
                   pais.sgpais,
                   pais.nmpais,
                   pais.dsnacionalidade,
                   TO_CHAR(pessoaendereco.dtcadastro, 'DD/MM/YYYY'),
                   pessoaendereco.dsaoscuidados,
                   pessoaendereco.inenderecopreferencial,
                   TO_CHAR(pessoaendereco.dtexpiracao, 'DD/MM/YYYY'),
                   DECODE(pessoaendereco.tssincronismo, '', 0, 1) tssincronismo,
                   DECODE(pessoaendereco.sqsincronismo, '', 0, 1) sqsincronismo,
                   TO_CHAR(pessoaendereco.dtultimaalteracao, 'DD/MM/YYYY')
             INTO  :tPessEnd.sIdEndereco:tPessEnd.iIdEndereco_ora
                  ,:tPessEnd.sIdTipoEndereco:tPessEnd.iIdTipoEndereco_ora
                  ,:tPessEnd.sSgTipoEndereco:tPessEnd.iSgTipoEndereco_ora
                  ,:tPessEnd.sDsTipoEndereco:tPessEnd.iDsTipoEndereco_ora
                  ,:tPessEnd.sNmTipoLogradouro:tPessEnd.iNmTipoLogradouro_ora
                  ,:tPessEnd.sNmTituloLogradouro:tPessEnd.iNmTituloLogradouro_ora
                  ,:tPessEnd.sNmLogradouro:tPessEnd.iNmLogradouro_ora
                  ,:tPessEnd.sNmLogradouro1:tPessEnd.iNmLogradouro1_ora
                  ,:tPessEnd.sNmBairro:tPessEnd.iNmBairro_ora
                  ,:tPessEnd.sNmMunicipio:tPessEnd.iNmMunicipio_ora
                  ,:tPessEnd.sNrEndereco:tPessEnd.iNrEndereco_ora
                  ,:tPessEnd.sDsEnderecoComplemento:tPessEnd.iDsEnderecoComplemento_ora
                  ,:tPessEnd.sNrCep:tPessEnd.iNrCep_ora
                  ,:tPessEnd.sIdUF:tPessEnd.iIdUF_ora
                  ,:tPessEnd.sSgUF:tPessEnd.iSgUF_ora
                  ,:tPessEnd.sNmUF:tPessEnd.iNmUF_ora
                  ,:tPessEnd.sIdPais:tPessEnd.iIdPais_ora
                  ,:tPessEnd.sSgPais:tPessEnd.iSgPais_ora
                  ,:tPessEnd.sNmPais:tPessEnd.iNmPais_ora
                  ,:tPessEnd.sDsNacionalidade:tPessEnd.iDsNacionalidade_ora
                  ,:tPessEnd.sDtCadastroOut:tPessEnd.iDtCadastroOut_ora
                  ,:tPessEnd.sNmPessoaContato:tPessEnd.iNmPessoaContato_ora
                  ,:tPessEnd.sInEnderecoPreferencial:tPessEnd.iInEnderecoPreferencial_ora
                  ,:tPessEnd.sDtExpiracaoOut:tPessEnd.iDtExpiracaoOut_ora
                  ,:tPessEnd.lTsSincronismo:tPessEnd.iTsSincronismo_ora
                  ,:tPessEnd.lSqSincronismo:tPessEnd.iSqSincronismo_ora
                  ,:tPessEnd.sDtUltimaAlteracao:tPessEnd.iDtUltimaAlteracao_ora
             FROM customer.conta,
                  customer.contaendereco,
                  customer.pessoaendereco,
                  apoio.tipoendereco,
                  apoio.uf,
                  apoio.pais
            WHERE conta.idconta                    = contaendereco.idconta
               AND pessoaendereco.idpessoaendereco = contaendereco.idpessoaendereco
               AND tipoendereco.idtipoendereco     = pessoaendereco.idtipoendereco
               AND uf.iduf                         = pessoaendereco.iduf
               AND pais.idpais                     = pessoaendereco.idpais
               AND rownum                          = 1
               AND pessoaendereco.dtexpiracao      IS NULL
               AND contaendereco.idtipoenderecocobranca = ( SELECT MAX( contaendereco1.idtipoenderecocobranca )
                                                              FROM customer.contaendereco  contaendereco1
                                                             WHERE contaendereco1.idconta     = :lOraIdConta )
               AND conta.idconta                   = :lOraIdConta
			   AND rownum = 1;

	ULOG_END("CPessoaEndereco::buscarPorNrLinha()");    
	return OK;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorPorIdConta:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::buscarPorNrLinha()");    
		throw new TuxBasicOraException(sqlca.sqlcode);
}

/*************************************************************************************************/
void CPessoaEndereco::SetData(TEnderecoXML xmlJ)
{
	STRCPY_TO_ORA( tPessEnd.sIdPessoa,				xmlJ.idPessoa ); 
 	STRCPY_TO_ORA( tPessEnd.sIdEndereco,			xmlJ.idEndereco ); 
 	STRCPY_TO_ORA( tPessEnd.sIdTipoEndereco,		xmlJ.idTipoEnderecoSelecionado); 
 	STRCPY_TO_ORA( tPessEnd.sSgTipoEndereco,		"" ); 
 	STRCPY_TO_ORA( tPessEnd.sDsTipoEndereco,		xmlJ.dsTipoEnderecoSelecionado); 
 	STRCPY_TO_ORA( tPessEnd.sNmTipoLogradouro,		xmlJ.nmTipoLogradouro ); 
 	STRCPY_TO_ORA( tPessEnd.sNmTituloLogradouro,	xmlJ.nmTituloLogradouro ); 
 	STRCPY_TO_ORA( tPessEnd.sNmLogradouro,			xmlJ.nmEndereco ); 
 	STRCPY_TO_ORA( tPessEnd.sNmBairro,				xmlJ.nmBairro ); 
 	STRCPY_TO_ORA( tPessEnd.sNmMunicipio,			xmlJ.nmMunicipio ); 
 	STRCPY_TO_ORA( tPessEnd.sNrEndereco,			xmlJ.nrEndereco ); 
 	STRCPY_TO_ORA( tPessEnd.sDsEnderecoComplemento,	xmlJ.dsEnderecoComplemento ); 
 	STRCPY_TO_ORA( tPessEnd.sNrCep,					xmlJ.nrCEP ); 
 	STRCPY_TO_ORA( tPessEnd.sIdUF,					xmlJ.idEstadoSelecionado ); 
 	STRCPY_TO_ORA( tPessEnd.sSgUF,					"" ); 
 	STRCPY_TO_ORA( tPessEnd.sNmUF,					"" ); 
 	STRCPY_TO_ORA( tPessEnd.sIdPais,				xmlJ.IdPaisSelecionado ); 
 	STRCPY_TO_ORA( tPessEnd.sSgPais,				"" ); 
 	STRCPY_TO_ORA( tPessEnd.sNmPais,				"" ); 
 	STRCPY_TO_ORA( tPessEnd.sDsNacionalidade,		"" ); 
 	STRCPY_TO_ORA( tPessEnd.sDtCadastroOut,			"" ); 
 	STRCPY_TO_ORA( tPessEnd.sNmPessoaContato,		"" ); 
 	STRCPY_TO_ORA( tPessEnd.sInEnderecoPreferencial,"" ); 
 	STRCPY_TO_ORA( tPessEnd.sDtExpiracaoOut,		"" ); 
 	STRCPY_TO_ORA( tPessEnd.sIdSistemaOrigem,		"7" ); 
 	STRCPY_TO_ORA( tPessEnd.sDtUltimaAlteracao,		"" );     
}

/*******************************************************************************************************/
TDadosDocumento *CPessoaEndereco::BuscaDocumentoPorIdPessoa(char *pszIdPessoa)
{
    static int iFlag=0;
    static TDadosDocumento tDadosDocumentoAux;
    static TDadosDocumento *ptDadosDocumentoAux;
    static int iCount=0;

    ULOG_START("CPessoaEndereco::BuscaDocumentoPorIdPessoa()");
    ULOG("pszIdPessoa[%s]", pszIdPessoa);

    if(iFlag == 0) {
        this->controleAlocacao();
        this->proCBuscaDocumentoPorIdPessoa(pszIdPessoa);
        ptDadosDocumentoAux=m_ptDadosDocumento;
        iFlag=1;
    }

    ULOG("m_ptDadosDocumento(%p)ptDadosDocumentoAux(%p)", m_ptDadosDocumento, ptDadosDocumentoAux);
    ULOG("m_iQtdElementosAlocados(%d)m_iQtdElementosObtidos(%d)iCount(%d)", m_iQtdElementosAlocados, m_iQtdElementosObtidos, iCount);

    if(iCount < m_iQtdElementosObtidos)
    {
        memcpy(&tDadosDocumentoAux, ptDadosDocumentoAux, sizeof(TDadosDocumento));
        iCount++;
        ptDadosDocumentoAux++;

        ULOG_END("CPessoaEndereco::BuscaDocumentoPorIdPessoa() <NOT NULL>");
        return &tDadosDocumentoAux;
    }
    else
    {
        ULOG("Desalocando memoria ->m_ptDadosDocumento(%p)", m_ptDadosDocumento);
        free(m_ptDadosDocumento);
        m_ptDadosDocumento=NULL;
        iFlag=0;
        iCount=0;
        m_iQtdElementosObtidos=0;

        ULOG_END("CPessoaEndereco::BuscaDocumentoPorIdPessoa() <NULL>");
        return NULL;
    }
}

/*************************************************************************************************/
int CPessoaEndereco::atualizaContaEndereco(char *pszIdContaEndereco, char *pszIdPessoaEndereco, char *pszIdUsuarioAlteracao)
{
    ULOG_START("CPessoaEndereco::atualizaContaEndereco");
    struct sqlca sqlca;

    ULOG("pszIdContaEndereco[%s]", pszIdContaEndereco);
    ULOG("pszIdPessoaEndereco[%s]", pszIdPessoaEndereco);
    ULOG("pszIdUsuarioAlteracao[%s]", pszIdUsuarioAlteracao);

	EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdContaEndereco[21];
        VARCHAR oszIdPessoaEndereco[21];
        VARCHAR oszIdUsuarioAlteracao[21];
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR goto erro;

    STRCPY_TO_ORA(oszIdContaEndereco, pszIdContaEndereco);
    STRCPY_TO_ORA(oszIdPessoaEndereco, pszIdPessoaEndereco);
    STRCPY_TO_ORA(oszIdUsuarioAlteracao, pszIdUsuarioAlteracao);

    EXEC SQL
        UPDATE
            customer.contaendereco cce
        SET
            cce.idpessoaendereco = :oszIdPessoaEndereco,
            cce.dtultimaalteracao = SYSDATE,
            cce.idusuarioalteracao = :oszIdUsuarioAlteracao
        WHERE
            cce.idcontaendereco = :oszIdContaEndereco;


    ULOG("sqlca.sqlerrd[2][%d]", sqlca.sqlerrd[2]);
    ULOG_END("CPessoaEndereco::atualizaContaEndereco()");    
    return OK;


	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::atualizaContaEndereco()");
		throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/*************************************************************************************************/
void CPessoaEndereco::associarContaEndereco(const char *pszIdPessoaEndereco,const char *pszIdPessoa,const char *pszIdLinhaTelefonica,const char *pszIdUsuarioAlteracao)
{
    ULOG_START("CPessoaEndereco::associarContaEndereco");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        const char *pInOraIdPessoaEndereco = pszIdPessoaEndereco;
        const char *pInOraIdLinhaTelefonica = pszIdLinhaTelefonica;
        const char *pInOraIdPessoa = pszIdPessoa;
        const char *pInOraIdUsuarioAlteracao = pszIdUsuarioAlteracao;
        const char *pInOraIdTipoEnderecoCobranca = getIdTipoEndereco();

        VARCHAR varOraIdConta[256];
        short statOraIdConta=-1;

        VARCHAR varOraIdTipoEnderecoCobranca[256];
        short statOraIdTipoEnderecoCobranca=-1;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR GOTO erro;
    EXEC SQL WHENEVER NOT FOUND GOTO notFoundInsert;

    ULOG("Vai buscar IDCONTA da pessoa='%s'",pInOraIdPessoa);

    EXEC SQL
        SELECT
            PESSOACONTA.IDCONTA
        INTO
            :varOraIdConta:statOraIdConta
        FROM
            CUSTOMER.PESSOACONTA PESSOACONTA,
            CUSTOMER.LINHACONTA LINHACONTA,
            CUSTOMER.PESSOADEPARA PESSOADEPARA
        WHERE
            PESSOACONTA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA
        AND LINHACONTA.IDLINHATELEFONICA = :pInOraIdLinhaTelefonica
        AND LINHACONTA.IDCONTA = PESSOACONTA.IDCONTA
        AND PESSOACONTA.IDTIPORELACIONAMENTO = 2
        AND PESSOADEPARA.IDPESSOA = :pInOraIdPessoa
        AND NVL(PESSOACONTA.DTEXPIRACAO,SYSDATE+1) > SYSDATE
        AND ROWNUM < 2;

    //EXEC SQL WHENEVER NOT FOUND CONTINUE;

    //ULOG("Vai desassociar IDCONTA ='%s'",(char*)varOraIdConta.arr);

    //EXEC SQL
    //    DELETE
    //        CUSTOMER.CONTAENDERECO
    //    WHERE
    //        IDCONTA = :varOraIdConta;

    //ULOG("sqlcode=%d",sqlca.sqlcode);

    ULOG("Vai inserir IDCONTA ='%s'",(char*)varOraIdConta.arr);

    EXEC SQL
        INSERT INTO
            CUSTOMER.CONTAENDERECO(IDCONTAENDERECO,IDPESSOAENDERECO,IDCONTA,DTEFETIVACONTAENDERECO
                                  ,IDTIPOENDERECOCOBRANCA,TSSINCRONISMO,SQSINCRONISMO,DTEXPIRACAO
                                  ,IDUSUARIOALTERACAO,DTULTIMAALTERACAO)
            VALUES(CONTAENDERECOSQ.NEXTVAL
                  ,:pInOraIdPessoaEndereco
                  ,:varOraIdConta:statOraIdConta
                  ,NULL // DTEFETIVACONTAENDERECO
                  ,:pInOraIdTipoEnderecoCobranca
                  ,NULL // TSSINCRONISMO
                  ,NULL // SQSINCRONISMO
                  ,NULL // DTEXPIRACAO
                  ,:pInOraIdUsuarioAlteracao
                  ,SYSDATE);

    ULOG_END("CPessoaEndereco::associarContaEndereco() OK");

    return;

	notFoundInsert:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::associarContaEndereco()==>NOT FOUND");
		throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::associarContaEndereco()==>ERROR");
		throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/*************************************************************************************/
bool CPessoaEndereco::proCBuscaDocumentoPorIdPessoa(char *pszIdPessoa)
{
    struct sqlca sqlca;
    int iCount;
    TDadosDocumento *ptDadosDocumentoAux;


    ULOG_START("CPessoaEndereco::proCBuscaDocumentoPorIdPessoa()");
    ULOG("pszIdPessoa[%s]", pszIdPessoa);

    EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR oszIdPessoa[LEN_IDPESSOA];

		VARCHAR oszSgTipoDocumento[LEN_SGTIPODOCUMENTO];
		VARCHAR oszNrDocumento[LEN_NRDOCUMENTO];
		VARCHAR oszSgOrgaoExpedidor[LEN_SGORGAOEXPEDIDOR];

		short iSgTipoDocumento;
		short iNrDocumento;
		short iSgOrgaoExpedidor;
    EXEC SQL END DECLARE SECTION;


    STRCPY_TO_ORA(oszIdPessoa, pszIdPessoa);

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND DO break;

	EXEC SQL DECLARE
    	CursorBuscaDocumentoPorIdPessoa CURSOR FOR
            SELECT
              DECODE(TIPODOCUMENTO.SGTIPODOCUMENTO, 'IF', 'IE', DECODE(TIPODOCUMENTO.SGTIPODOCUMENTO, 'IM', 'IE', TIPODOCUMENTO.SGTIPODOCUMENTO)) as SGTIPODOCUMENTO,
              DOCUMENTO.NRDOCUMENTO,
              DOCUMENTO.SGORGAOEXPEDIDOR
            FROM
              CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
              CUSTOMER.DOCUMENTO DOCUMENTO,
              APOIO.TIPODOCUMENTO TIPODOCUMENTO
            WHERE
              DOCUMENTO.IDDOCUMENTO = PESSOADOCUMENTO.IDDOCUMENTO
            AND
              DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
            AND
              TIPODOCUMENTO.INVISUALIZA = 1
            AND
              PESSOADOCUMENTO.IDPESSOA IN ( SELECT
                                              PESSOADEPARA.IDPESSOAORIGEM
                                            FROM
                                              CUSTOMER.PESSOADEPARA
                                            WHERE
                                              PESSOADEPARA.IDPESSOA = :oszIdPessoa
                                           );

	EXEC SQL OPEN CursorBuscaDocumentoPorIdPessoa;

    for(iCount=0, ptDadosDocumentoAux=m_ptDadosDocumento;;iCount++, ptDadosDocumentoAux++, m_iQtdElementosObtidos++)
	{
		EXEC SQL FETCH CursorBuscaDocumentoPorIdPessoa INTO
    		   :oszSgTipoDocumento:iSgTipoDocumento,
    		   :oszNrDocumento:iNrDocumento,
    		   :oszSgOrgaoExpedidor:iSgOrgaoExpedidor;

        /* Verifica se precisa realocar espaco */
        if(iCount >= m_iQtdElementosAlocados) {
            m_iQtdElementosAlocados++;

            ULOG("Realocando memoria [%p]", m_ptDadosDocumento);
            m_ptDadosDocumento = (TDadosDocumento *) realloc(m_ptDadosDocumento, sizeof(TDadosDocumento) * (m_iQtdElementosAlocados));
            ULOG("Memoria realocada [%p] bloco(%d)", m_ptDadosDocumento, sizeof(TDadosDocumento) * (m_iQtdElementosAlocados));

            /* Atribui o novo endereco obtido e posiciona o ponteiro na posicao do ultimo registro obtido antes da realocacao */
            ptDadosDocumentoAux = m_ptDadosDocumento+iCount;
        }


        /* copia as informacoes obtidas para o ponteiro */
        memset(ptDadosDocumentoAux, 0x00, sizeof(TDadosDocumento));

		if(iSgTipoDocumento != -1)   { STRCPY_FROM_ORA(ptDadosDocumentoAux->szSgTipoDocumento ,   oszSgTipoDocumento); }
		if(iNrDocumento != -1)       { STRCPY_FROM_ORA(ptDadosDocumentoAux->szNrDocumento ,       oszNrDocumento); }
		if(iSgOrgaoExpedidor != -1)  { STRCPY_FROM_ORA(ptDadosDocumentoAux->szSgOrgaoExpedidor ,  oszSgOrgaoExpedidor); }

	}

	EXEC SQL CLOSE CursorBuscaDocumentoPorIdPessoa;

	ULOG_END("CPessoaEndereco::proCBuscaDocumentoPorIdPessoa() <FOUND>");

    return true;

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::proCBuscaDocumentoPorIdPessoa() <ERROR>");
        return false;

    naoexiste:
        ULOG("Registro nao encontrado");
		ULOG_END("CPessoaEndereco::proCBuscaDocumentoPorIdPessoa() <NOT FOUND>");
        return false;
}

/*******************************************************************************************************/
void CPessoaEndereco::controleAlocacao(void)
{
    m_iQtdElementosAlocados=10;
    m_iQtdElementosObtidos=0;

    ULOG("m_iQtdElementosAlocados(%d)", m_iQtdElementosAlocados);
    ULOG("sizeof(TDadosDocumento)(%d)", sizeof(TDadosDocumento));

    if((m_ptDadosDocumento = (TDadosDocumento *) malloc((sizeof(TDadosDocumento) * (m_iQtdElementosAlocados)))) == NULL ) {
        throw new TuxBasicSvcException("13E0001", "Erro alocando memoria!");
    }
    ULOG("Memoria alocada m_ptDadosDocumento (%p)", m_ptDadosDocumento);
}

/*************************************************************************************************/
bool CPessoaEndereco::buscaDadosNGINPessoaFisica(TDadosNGIN *ptDadosNGIN)
{
    struct sqlca sqlca;
    ULOG_START("CPessoaEndereco::buscaDadosNGINPessoaFisica()");
    ULOG("(char *)&tPessEnd.sIdEndereco.arr[%s]", (char *)&tPessEnd.sIdEndereco.arr);

    memset(ptDadosNGIN, 0x00, sizeof(TDadosNGIN));

	EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoaEndereco[LEN_IDPESSOAENDERECO];

        VARCHAR oszIdPessoa[LEN_IDPESSOA];
        VARCHAR oszLogradouro[LEN_NMTIPOLOGRADOURO];
        VARCHAR oszEndereco[LEN_NMLOGRADOURO];
        VARCHAR oszComplemento[LEN_DSENDERECOCOMPLEMENTO];
        VARCHAR oszBairro[LEN_NMBAIRRO];
        VARCHAR oszCEP[LEN_NRCEP];
        VARCHAR oszCidade[LEN_NMMUNICIPIO];
        VARCHAR oszEstado[LEN_SGUF];
        VARCHAR oszPais[3];
        VARCHAR oszNumero[LEN_NRENDERECO];
        VARCHAR oszNome[LEN_NMPESSOA];
        VARCHAR oszConfidencial[1];
        VARCHAR oszDataNascimento[LEN_DATE_ORA];
        VARCHAR oszTipoCliente[1];
        VARCHAR oszEstadoCivil[1];
        VARCHAR oszCodSexo[1];

        short oiIdPessoa = 0;
        short oiLogradouro = 0;
        short oiEndereco = 0;
        short oiComplemento = 0;
        short oiBairro = 0;
        short oiCEP = 0;
        short oiCidade = 0;
        short oiEstado = 0;
        short oiPais = 0;
        short oiNumero = 0;
        short oiNome = 0;
        short oiConfidencial = 0;
        short oiDataNascimento = 0;
        short oiTipoCliente = 0;
        short oiEstadoCivil = 0;
        short oiCodSexo = 0;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    STRCPY_TO_ORA(oszIdPessoaEndereco, (char *)&tPessEnd.sIdEndereco.arr);

    EXEC SQL
          SELECT
              cp.idpessoa,
              cpe.nmtipologradouro as logradouro,
              cpe.nmtipologradouro || ' ' || cpe.nmlogradouro as endereco,
              NVL(cpe.dsenderecocomplemento,' ') as complemento,
              cpe.nmbairro as bairro,
              cpe.nrcep as CEP,
              cpe.nmmunicipio as cidade,
              auf.sguf as estado,
              'BRA' as pais,
              cpe.nrendereco as numero,
              decode(atp.idtipopessoa, 1, 'P', decode(atp.idtipopessoa, 2, 'E', '')) as tipoCliente,
              cp.nmpessoa as nome,
              'N' as confidencial,
              to_char(nvl(cpf.dtnascimento, ''), 'DD/MM/YYYY') as dataNascimento,
              decode(cpf.idestadocivil, 1, 'S', decode(cpf.idestadocivil, 2, 'C', decode(cpf.idestadocivil, 4, 'V', decode(cpf.idestadocivil, 5, 'D', '')))) as estadoCivil,
              decode(cpf.idsexo, 1, 'M', decode(cpf.idsexo, 2, 'F', '')) as codSexo
          INTO
              :oszIdPessoa:oiIdPessoa,
              :oszLogradouro:oiLogradouro,
              :oszEndereco:oiEndereco,
              :oszComplemento:oiComplemento,
              :oszBairro:oiBairro,
              :oszCEP:oiCEP,
              :oszCidade:oiCidade,
              :oszEstado:oiEstado,
              :oszPais:oiPais,
              :oszNumero:oiNumero,
              :oszTipoCliente:oiTipoCliente,
              :oszNome:oiNome,
              :oszConfidencial:oiConfidencial,
              :oszDataNascimento:oiDataNascimento,
              :oszEstadoCivil:oiEstadoCivil,
              :oszCodSexo:oiCodSexo
          FROM
              customer.pessoaendereco cpe,
              customer.pessoa cp,
              customer.pessoafisica cpf,
              apoio.uf auf,
              apoio.tipopessoa atp,
              apoio.estadocivil aec,
              apoio.sexo asex
          WHERE
              cpe.iduf = auf.iduf
          AND
              cpe.idpessoa = cp.idpessoa
          AND
              cp.idtipopessoa = atp.idtipopessoa
          AND
              cpe.idpessoa = cpf.idpessoa
          AND
              cpf.idestadocivil = aec.idestadocivil
          AND
              cpf.idsexo = asex.idsexo
          AND
              cpe.idpessoaendereco = :oszIdPessoaEndereco;


    if(oiIdPessoa != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szIdPessoa, oszIdPessoa); }
    if(oiLogradouro != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szLogradouro, oszLogradouro); }
    if(oiEndereco != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szEndereco, oszEndereco); }
    if(oiComplemento != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szComplemento, oszComplemento); }
    if(oiBairro != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szBairro, oszBairro); }
    if(oiCEP != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szCEP, oszCEP); }
    if(oiCidade != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szCidade, oszCidade); }
    if(oiEstado != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szEstado, oszEstado); }
    if(oiPais != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szPais, oszPais); }
    if(oiNumero != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szNumero, oszNumero); }
    if(oiTipoCliente != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szTipoCliente, oszTipoCliente); }
    if(oiNome != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szNome, oszNome); }
    if(oiConfidencial != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szConfidencial, oszConfidencial); }
    if(oiDataNascimento != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szDataNascimento, oszDataNascimento); }
    if(oiEstadoCivil != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szEstadoCivil, oszEstadoCivil); }
    if(oiCodSexo != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szCodSexo, oszCodSexo); }



    // translateSpecialChars(ptDadosNGIN->szIdPessoa);
    translateSpecialChars(ptDadosNGIN->szLogradouro);
    translateSpecialChars(ptDadosNGIN->szEndereco);
    translateSpecialChars(ptDadosNGIN->szComplemento);
    translateSpecialChars(ptDadosNGIN->szBairro);
    translateSpecialChars(ptDadosNGIN->szCEP);
    translateSpecialChars(ptDadosNGIN->szCidade);
    translateSpecialChars(ptDadosNGIN->szEstado);
    // translateSpecialChars(ptDadosNGIN->szPais);
    translateSpecialChars(ptDadosNGIN->szNumero);
    // translateSpecialChars(ptDadosNGIN->szTipoCliente);
    translateSpecialChars(ptDadosNGIN->szNome);
    // translateSpecialChars(ptDadosNGIN->szConfidencial);
    // translateSpecialChars(ptDadosNGIN->szDataNascimento);
    // translateSpecialChars(ptDadosNGIN->szEstadoCivil);
    // translateSpecialChars(ptDadosNGIN->szCodSexo);



    ULOG("ptDadosNGIN->szIdPessoa[%s]", ptDadosNGIN->szIdPessoa);
    ULOG("ptDadosNGIN->szLogradouro[%s]", ptDadosNGIN->szLogradouro);
    ULOG("ptDadosNGIN->szEndereco[%s]", ptDadosNGIN->szEndereco);
    ULOG("ptDadosNGIN->szComplemento[%s]", ptDadosNGIN->szComplemento);
    ULOG("ptDadosNGIN->szBairro[%s]", ptDadosNGIN->szBairro);
    ULOG("ptDadosNGIN->szCEP[%s]", ptDadosNGIN->szCEP);
    ULOG("ptDadosNGIN->szCidade[%s]", ptDadosNGIN->szCidade);
    ULOG("ptDadosNGIN->szEstado[%s]", ptDadosNGIN->szEstado);
    ULOG("ptDadosNGIN->szPais[%s]", ptDadosNGIN->szPais);
    ULOG("ptDadosNGIN->szNumero[%s]", ptDadosNGIN->szNumero);
    ULOG("ptDadosNGIN->szTipoCliente[%s]", ptDadosNGIN->szTipoCliente);
    ULOG("ptDadosNGIN->szNome[%s]", ptDadosNGIN->szNome);
    ULOG("ptDadosNGIN->szConfidencial[%s]", ptDadosNGIN->szConfidencial);
    ULOG("ptDadosNGIN->szDataNascimento[%s]", ptDadosNGIN->szDataNascimento);
    ULOG("ptDadosNGIN->szEstadoCivil[%s]", ptDadosNGIN->szEstadoCivil);
    ULOG("ptDadosNGIN->szCodSexo[%s]", ptDadosNGIN->szCodSexo);


	ULOG_END("CPessoaEndereco::buscaDadosNGINPessoaFisica() <FOUND>");

    return true;

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::buscaDadosNGINPessoaFisica() <ERROR>");
		throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);

    naoexiste:
        ULOG("Registro nao encontrado");
		ULOG_END("CPessoaEndereco::buscaDadosNGINPessoaFisica() <NOT FOUND>");
        return false;
}

/*************************************************************************************************/
bool CPessoaEndereco::buscaDadosNGINPessoaJuridica(TDadosNGIN *ptDadosNGIN)
{
    struct sqlca sqlca;
    ULOG_START("CPessoaEndereco::buscaDadosNGINPessoaJuridica()");
    ULOG("(char *)&tPessEnd.sIdEndereco.arr[%s]", (char *)&tPessEnd.sIdEndereco.arr);

    memset(ptDadosNGIN, 0x00, sizeof(TDadosNGIN));

	EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoaEndereco[LEN_IDPESSOAENDERECO];

        VARCHAR oszIdPessoa[LEN_IDPESSOA];
        VARCHAR oszLogradouro[LEN_NMTIPOLOGRADOURO];
        VARCHAR oszEndereco[LEN_NMLOGRADOURO];
        VARCHAR oszComplemento[LEN_DSENDERECOCOMPLEMENTO];
        VARCHAR oszBairro[LEN_NMBAIRRO];
        VARCHAR oszCEP[LEN_NRCEP];
        VARCHAR oszCidade[LEN_NMMUNICIPIO];
        VARCHAR oszEstado[LEN_SGUF];
        VARCHAR oszPais[3];
        VARCHAR oszNumero[LEN_NRENDERECO];
        VARCHAR oszNome[LEN_NMPESSOA];
        VARCHAR oszTipoCliente[1];

        short oiIdPessoa = 0;
        short oiLogradouro = 0;
        short oiEndereco = 0;
        short oiComplemento = 0;
        short oiBairro = 0;
        short oiCEP = 0;
        short oiCidade = 0;
        short oiEstado = 0;
        short oiPais = 0;
        short oiNumero = 0;
        short oiNome = 0;
        short oiTipoCliente = 0;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    STRCPY_TO_ORA(oszIdPessoaEndereco, (char *)&tPessEnd.sIdEndereco.arr);

    EXEC SQL
          SELECT
              cp.idpessoa,
              cpe.nmtipologradouro as logradouro,
              cpe.nmtipologradouro || ' ' || cpe.nmlogradouro as endereco,
              NVL(cpe.dsenderecocomplemento,' ') as complemento,
              cpe.nmbairro as bairro,
              cpe.nrcep as CEP,
              cpe.nmmunicipio as cidade,
              auf.sguf as estado,
              'BRA' as pais,
              cpe.nrendereco as numero,
              decode(atp.idtipopessoa, 1, 'P', decode(atp.idtipopessoa, 2, 'E', '')) as tipoCliente,
              cp.nmpessoa as nome
          INTO
              :oszIdPessoa:oiIdPessoa,
              :oszLogradouro:oiLogradouro,
              :oszEndereco:oiEndereco,
              :oszComplemento:oiComplemento,
              :oszBairro:oiBairro,
              :oszCEP:oiCEP,
              :oszCidade:oiCidade,
              :oszEstado:oiEstado,
              :oszPais:oiPais,
              :oszNumero:oiNumero,
              :oszTipoCliente:oiTipoCliente,
              :oszNome:oiNome
          FROM
              customer.pessoaendereco cpe,
              customer.pessoa cp,
              customer.pessoajuridica cpj,
              apoio.uf auf,
              apoio.tipopessoa atp
          WHERE
              cpe.iduf = auf.iduf
          AND
              cpe.idpessoa = cp.idpessoa
          AND
              cp.idtipopessoa = atp.idtipopessoa
          AND
              cpe.idpessoa = cpj.idpessoa
          AND
              cpe.idpessoaendereco = :oszIdPessoaEndereco;


    if(oiIdPessoa != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szIdPessoa, oszIdPessoa); }
    if(oiLogradouro != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szLogradouro, oszLogradouro); }
    if(oiEndereco != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szEndereco, oszEndereco); }
    if(oiComplemento != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szComplemento, oszComplemento); }
    if(oiBairro != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szBairro, oszBairro); }
    if(oiCEP != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szCEP, oszCEP); }
    if(oiCidade != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szCidade, oszCidade); }
    if(oiEstado != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szEstado, oszEstado); }
    if(oiPais != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szPais, oszPais); }
    if(oiNumero != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szNumero, oszNumero); }
    if(oiTipoCliente != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szTipoCliente, oszTipoCliente); }
    if(oiNome != -1) { STRCPY_FROM_ORA(ptDadosNGIN->szNome, oszNome); }


    // translateSpecialChars(ptDadosNGIN->szIdPessoa);
    translateSpecialChars(ptDadosNGIN->szLogradouro);
    translateSpecialChars(ptDadosNGIN->szEndereco);
    translateSpecialChars(ptDadosNGIN->szComplemento);
    translateSpecialChars(ptDadosNGIN->szBairro);
    translateSpecialChars(ptDadosNGIN->szCEP);
    translateSpecialChars(ptDadosNGIN->szCidade);
    translateSpecialChars(ptDadosNGIN->szEstado);
    // translateSpecialChars(ptDadosNGIN->szPais);
    translateSpecialChars(ptDadosNGIN->szNumero);
    // translateSpecialChars(ptDadosNGIN->szTipoCliente);
    translateSpecialChars(ptDadosNGIN->szNome);


    ULOG("ptDadosNGIN->szIdPessoa[%s]", ptDadosNGIN->szIdPessoa);
    ULOG("ptDadosNGIN->szLogradouro[%s]", ptDadosNGIN->szLogradouro);
    ULOG("ptDadosNGIN->szEndereco[%s]", ptDadosNGIN->szEndereco);
    ULOG("ptDadosNGIN->szComplemento[%s]", ptDadosNGIN->szComplemento);
    ULOG("ptDadosNGIN->szBairro[%s]", ptDadosNGIN->szBairro);
    ULOG("ptDadosNGIN->szCEP[%s]", ptDadosNGIN->szCEP);
    ULOG("ptDadosNGIN->szCidade[%s]", ptDadosNGIN->szCidade);
    ULOG("ptDadosNGIN->szEstado[%s]", ptDadosNGIN->szEstado);
    ULOG("ptDadosNGIN->szPais[%s]", ptDadosNGIN->szPais);
    ULOG("ptDadosNGIN->szNumero[%s]", ptDadosNGIN->szNumero);
    ULOG("ptDadosNGIN->szTipoCliente[%s]", ptDadosNGIN->szTipoCliente);
    ULOG("ptDadosNGIN->szNome[%s]", ptDadosNGIN->szNome);


	ULOG_END("CPessoaEndereco::buscaDadosNGINPessoaJuridica() <FOUND>");

    return true;

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::buscaDadosNGINPessoaJuridica() <ERROR>");
		throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);

    naoexiste:
        ULOG("Registro nao encontrado");
		ULOG_END("CPessoaEndereco::buscaDadosNGINPessoaJuridica() <NOT FOUND>");
        return false;
}

/*************************************************************************************************/
bool CPessoaEndereco::buscaIdLinhaTelefonicaPorNrLinha(char *szNrLinha, char *pszIdLinhaTelefonica)
{
    ULOG_START("CPessoaEndereco::buscaIdLinhaTelefonicaPorNrLinha()");
    struct sqlca sqlca;

    //ULOG("(char *)&tPessEnd.sIdEndereco.arr[%s]", (char *)&tPessEnd.sIdEndereco.arr);

	EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszCodArea[21];
        VARCHAR oszNrLinha[21];
        VARCHAR oszIdLinhaTelefonica[21];
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    // Obtém o código de área e o número
	char szCodArea[10];

    memset(szCodArea, 0x00, sizeof(szCodArea));
    memcpy(szCodArea, szNrLinha, 2);

    ULOG("CodArea[%s] e NrLinha[%s]", szCodArea, (szNrLinha+2));

    STRCPY_TO_ORA(oszCodArea, szCodArea);
    STRCPY_TO_ORA(oszNrLinha, (szNrLinha+2));


    EXEC SQL
		SELECT 
			 linhatel.idlinhatelefonica 
        INTO
            :oszIdLinhaTelefonica
		FROM 
			 linha.linhabase linhabase,
			 linha.linhatelefonica linhatel,
			 apoio.arearegistro area
		WHERE
			 linhabase.idarearegistro = area.idarearegistro
			 AND linhatel.idlinhabase = linhabase.idlinhabase
			 AND area.cdarearegistro = :oszCodArea
			 AND linhabase.nrlinha = :oszNrLinha;



    ULOG("oszIdLinhaTelefonica[%.*s]", oszIdLinhaTelefonica.len, (char*)oszIdLinhaTelefonica.arr);
    STRCPY_FROM_ORA(pszIdLinhaTelefonica, oszIdLinhaTelefonica);

	ULOG_END("CPessoaEndereco::buscaIdLinhaTelefonicaPorNrLinha() <FOUND>");

    return true;

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::buscaIdLinhaTelefonicaPorNrLinha()");
		throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);

    naoexiste:
        ULOG("Registro nao encontrado");
		ULOG_END("CPessoaEndereco::buscaIdLinhaTelefonicaPorNrLinha() <NOT FOUND>");
        return false;
}

/*************************************************************************************************/
bool CPessoaEndereco::buscaTipoPessoa(int *piTipoPessoa)
{
    ULOG_START("CPessoaEndereco::buscaTipoPessoa()");
    struct sqlca sqlca;

    ULOG("(char *)&tPessEnd.sIdEndereco.arr[%s]", (char *)&tPessEnd.sIdEndereco.arr);

	EXEC SQL BEGIN DECLARE SECTION;
        int oiTipoPessoa;
        VARCHAR oszIdPessoaEndereco[21];
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    STRCPY_TO_ORA(oszIdPessoaEndereco, (char *)&tPessEnd.sIdEndereco.arr);

    EXEC SQL
        SELECT
            cp.idtipopessoa
        INTO
            :oiTipoPessoa
        FROM
            customer.pessoaendereco cpe,
            customer.pessoa cp
        WHERE
            cpe.idpessoa = cp.idpessoa
        AND
            cpe.idpessoaendereco = :oszIdPessoaEndereco;


    ULOG("oiTipoPessoa[%d]", oiTipoPessoa);
    *piTipoPessoa = oiTipoPessoa;

	ULOG_END("CPessoaEndereco::buscaTipoPessoa() <FOUND>");

    return true;

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::buscaTipoPessoa()");
		throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);

    naoexiste:
        ULOG("Registro nao encontrado");
		ULOG_END("CPessoaEndereco::buscaTipoPessoa() <NOT FOUND>");
        return false;
}

/*************************************************************************************************/
bool CPessoaEndereco::buscaIdContaEndereco(char *pszIdPessoa, char *pszNrLinha, char *pszIdContaEndereco)
{
    ULOG_START("CPessoaEndereco::buscaIdContaEndereco()");
    struct sqlca sqlca;
    char szAux[21 + 1];

	EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoa[21];
        VARCHAR oszCdAreaRegistro[21];
        VARCHAR oszNrLinha[21];

        VARCHAR oszIdContaEndereco[21];
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    memcpy(szAux, pszNrLinha, 2); szAux[2]=0x00;
    STRCPY_TO_ORA(oszCdAreaRegistro, szAux);    ULOG("oszCdAreaRegistro[%.*s]", oszCdAreaRegistro.len, oszCdAreaRegistro.arr);
    STRCPY_TO_ORA(oszNrLinha, pszNrLinha + 2);  ULOG("oszNrLinha[%.*s]", oszNrLinha.len, oszNrLinha.arr);
    STRCPY_TO_ORA(oszIdPessoa, pszIdPessoa);    ULOG("oszIdPessoa[%.*s]", oszIdPessoa.len, oszIdPessoa.arr);

    EXEC SQL
        SELECT
            cce.idcontaendereco
        INTO
            :oszIdContaEndereco
        FROM
            customer.pessoaendereco cpe,
            customer.contaendereco cce,
            customer.linhaconta clc,
            linha.linhatelefonica llt,
            linha.linhabase llb,
            apoio.arearegistro aar
        WHERE
            cpe.idpessoaendereco = cce.idpessoaendereco
        AND
            cce.idconta = clc.idconta
        AND
            clc.idlinhatelefonica = llt.idlinhatelefonica
        AND
            llt.idlinhabase = llb.idlinhabase
        AND
            llb.idarearegistro = aar.idarearegistro
        AND
            cpe.idpessoa = :oszIdPessoa
        AND
            llb.idarearegistro = aar.idarearegistro
        AND
            llb.nrlinha = :oszNrLinha
        AND
            aar.cdarearegistro = :oszCdAreaRegistro
        AND
            ROWNUM < 2;


    STRCPY_FROM_ORA(pszIdContaEndereco, oszIdContaEndereco);
    ULOG("pszIdContaEndereco[%s]", pszIdContaEndereco);
	ULOG_END("CPessoaEndereco::buscaIdContaEndereco() <FOUND>");
    return true;

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::buscaIdContaEndereco()");
		throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);

    naoexiste:
        ULOG("Registro nao encontrado");
		ULOG_END("CPessoaEndereco::buscaIdContaEndereco() <NOT FOUND>");
        return false;
}

/*************************************************************************************************/
void CPessoaEndereco::RecuperarTodos(char *pszIdPessoa, XMLGen *pXmlG)
{
    ULOG_START("CPessoaEndereco::RecuperarTodos()");

    struct sqlca sqlca;
    char szIdSistemaOrigem[21 + 1];

	EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoa[21];
        TPESSOAEND tST;
        int varOraCount;
	EXEC SQL END DECLARE SECTION;

    STRCPY_TO_ORA(oszIdPessoa, pszIdPessoa);

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL
        SELECT
            COUNT(1)
        INTO
            :varOraCount // tem endereço preferencial? (0=não)
        FROM
            CUSTOMER.PESSOAENDERECO
        WHERE
            IDPESSOA IN (SELECT PESSOADEPARA.IDPESSOAORIGEM 
                           FROM CUSTOMER.PESSOADEPARA PESSOADEPARA
                          WHERE PESSOADEPARA.IDPESSOA = :oszIdPessoa)
        AND PESSOAENDERECO.DTEXPIRACAO IS NULL
        AND PESSOAENDERECO.IDTIPOENDERECO > 0
        AND INENDERECOPREFERENCIAL = 1
        AND ROWNUM < 2;

	EXEC SQL WHENEVER NOT FOUND DO break;

	EXEC SQL DECLARE cCursor CURSOR FOR
		SELECT DISTINCT
			PESSOAENDERECO.idpessoaendereco,
			PESSOAENDERECO.idtipoendereco,
			TIPOENDERECO.sgtipoendereco,
			TIPOENDERECO.dstipoendereco,
			PESSOAENDERECO.nmtipologradouro,
			PESSOAENDERECO.nmtitulologradouro,
			PESSOAENDERECO.nmlogradouro,
			PESSOAENDERECO.nmbairro,
			PESSOAENDERECO.nmmunicipio,
			PESSOAENDERECO.nrendereco,
			PESSOAENDERECO.dsenderecocomplemento,
			PESSOAENDERECO.nrcep,
			PESSOAENDERECO.iduf,
			UF.sguf,
			UF.nmuf,
			PESSOAENDERECO.idpais,
			PAIS.sgpais,
			PAIS.nmpais,
			PAIS.dsnacionalidade,
			PESSOAENDERECO.dsaoscuidados,
			PESSOAENDERECO.inenderecopreferencial,
			TO_CHAR(PESSOAENDERECO.dtcadastro,'DD/MM/YYYY') AS dtcadastroout,
			TO_CHAR(PESSOAENDERECO.dtexpiracao,'DD/MM/YYYY') AS dtexpiracaoout,
            PESSOAENDERECO.idsistemaorigem
       FROM APOIO.PAIS PAIS,
            APOIO.TIPOENDERECO TIPOENDERECO,
            APOIO.UF UF,
            APOIO.SISTEMAORIGEM SISTEMAORIGEM,
            CUSTOMER.PESSOAENDERECO PESSOAENDERECO
      WHERE PESSOAENDERECO.idpais = PAIS.idpais
        AND PESSOAENDERECO.idsistemaorigem = SISTEMAORIGEM.idsistemaorigem
        AND PESSOAENDERECO.idtipoendereco = TIPOENDERECO.idtipoendereco
        AND PESSOAENDERECO.iduf = UF.iduf
        AND PESSOAENDERECO.dtexpiracao IS NULL
        AND PESSOAENDERECO.idtipoendereco > 0
        AND PESSOAENDERECO.idpessoa IN (SELECT PESSOADEPARA.idpessoaorigem 
                                        FROM CUSTOMER.PESSOADEPARA PESSOADEPARA
                                        WHERE PESSOADEPARA.idpessoa = :oszIdPessoa)
   ORDER BY PESSOAENDERECO.idtipoendereco,
            PESSOAENDERECO.nrcep,
			PESSOAENDERECO.nrendereco,
            PESSOAENDERECO.nmlogradouro,
			PESSOAENDERECO.dsenderecocomplemento,
            PESSOAENDERECO.nmtipologradouro,
			PESSOAENDERECO.nmtitulologradouro,
			PESSOAENDERECO.nmbairro,
			PESSOAENDERECO.nmmunicipio,
			PESSOAENDERECO.iduf,
			PESSOAENDERECO.idpais;

	EXEC SQL OPEN cCursor;

    pXmlG->createTag("LupaClienteVO");
    pXmlG->addProp("xmlns","cliente.fo.vivo.com.br/vo");
    pXmlG->createTag("DadosAbaLupaCliente");

	for(;;) 
    {
        memset(&tST, 0x00, sizeof(tST));
        EXEC SQL FETCH cCursor INTO  :tST.sIdEndereco:tST.iIdEndereco_ora
                                    ,:tST.sIdTipoEndereco:tST.iIdTipoEndereco_ora
                                    ,:tST.sSgTipoEndereco:tST.iSgTipoEndereco_ora
                                    ,:tST.sDsTipoEndereco:tST.iDsTipoEndereco_ora
                                    ,:tST.sNmTipoLogradouro:tST.iNmTipoLogradouro_ora
                                    ,:tST.sNmTituloLogradouro:tST.iNmTituloLogradouro_ora
                                    ,:tST.sNmLogradouro:tST.iNmLogradouro_ora
                                    ,:tST.sNmBairro:tST.iNmBairro_ora
                                    ,:tST.sNmMunicipio:tST.iNmMunicipio_ora
                                    ,:tST.sNrEndereco:tST.iNrEndereco_ora
                                    ,:tST.sDsEnderecoComplemento:tST.iDsEnderecoComplemento_ora
                                    ,:tST.sNrCep:tST.iNrCep_ora
                                    ,:tST.sIdUF:tST.iIdUF_ora
                                    ,:tST.sSgUF:tST.iSgUF_ora
                                    ,:tST.sNmUF:tST.iNmUF_ora
                                    ,:tST.sIdPais:tST.iIdPais_ora
                                    ,:tST.sSgPais:tST.iSgPais_ora
                                    ,:tST.sNmPais:tST.iNmPais_ora
                                    ,:tST.sDsNacionalidade:tST.iDsNacionalidade_ora
                                    ,:tST.sNmPessoaContato:tST.iNmPessoaContato_ora
                                    ,:tST.sInEnderecoPreferencial:tST.iInEnderecoPreferencial_ora
                                    ,:tST.sDtCadastroOut:tST.iDtCadastroOut_ora
                                    ,:tST.sDtExpiracaoOut:tST.iDtExpiracaoOut_ora
                                    ,:tST.sIdSistemaOrigem:tST.iIdSistemaOrigem_ora;

        if ( varOraCount == 0)
        { // se a pessoa nao possui endereço preferencial será usado aquele que bater com contaendereço
            if ( tST.iInEnderecoPreferencial_ora == -1 || strcmp((char*)tST.sInEnderecoPreferencial.arr,"0")==0 )
            {
	            EXEC SQL WHENEVER NOT FOUND CONTINUE;
	            EXEC SQL 
                    SELECT
                        COUNT(1)
                    INTO
                        :varOraCount
                    FROM
                        CUSTOMER.CONTAENDERECO
                    WHERE
                        IDPESSOAENDERECO  = :tST.sIdEndereco
                    AND ROWNUM < 2;

                if ( varOraCount>0 )
                {
                    sprintf((char*)tST.sInEnderecoPreferencial.arr,"%d",varOraCount);
                    tST.iInEnderecoPreferencial_ora = 1;
                }
            }
        }

        pXmlG->createTag("EnderecoVO");
            pXmlG->addItem("idEndereco", tST.iIdEndereco_ora != -1?(char *)tST.sIdEndereco.arr:"");

            pXmlG->createTag("TipoEnderecoVO");
                pXmlG->addItem("idTipoEndereco", tST.iIdTipoEndereco_ora != -1 ?(char *)tST.sIdTipoEndereco.arr:"");
                pXmlG->addItem("sgTipoEndereco", tST.iSgTipoEndereco_ora != -1 ?(char *)tST.sSgTipoEndereco.arr:"");
                pXmlG->addItem("dsTipoEndereco", tST.iDsTipoEndereco_ora != -1 ?(char *)tST.sDsTipoEndereco.arr:"");
            pXmlG->closeTag();

            pXmlG->addItem("nmTipoLogradouro", tST.iNmTipoLogradouro_ora != -1?(char *)tST.sNmTipoLogradouro.arr:"");
            pXmlG->addItem("nmTituloLogradouro", tST.iNmTituloLogradouro_ora != -1?(char *)tST.sNmTituloLogradouro.arr:"");
            pXmlG->addItem("nmLogradouro", tST.iNmLogradouro_ora != -1?(char *)tST.sNmLogradouro.arr:"");
            pXmlG->addItem("nmBairro", tST.iNmBairro_ora != -1?(char *)tST.sNmBairro.arr:"");
            pXmlG->addItem("nmMunicipio", tST.iNmMunicipio_ora != -1?(char *)tST.sNmMunicipio.arr:"");
            pXmlG->addItem("nrEndereco", tST.iNrEndereco_ora != -1?(char *)tST.sNrEndereco.arr:"");
            pXmlG->addItem("dsEnderecoComplemento", tST.iDsEnderecoComplemento_ora != -1?(char *)tST.sDsEnderecoComplemento.arr:"");
            pXmlG->addItem("nrCEP", tST.iNrCep_ora != -1?(char *)tST.sNrCep.arr:"");

            pXmlG->createTag("UFVO");
                pXmlG->addItem("idUF", tST.iIdUF_ora != -1?(char *)tST.sIdUF.arr:"");
                pXmlG->addItem("sgUF", tST.iSgUF_ora != -1?(char *)tST.sSgUF.arr:"");
                pXmlG->addItem("nmUF", tST.iNmUF_ora != -1?(char *)tST.sNmUF.arr:"");
            pXmlG->closeTag();

            pXmlG->createTag("PaisVO");
                pXmlG->addItem("idPais", tST.iIdPais_ora != -1?(char *)tST.sIdPais.arr:"");
                pXmlG->addItem("sgPais", tST.iSgPais_ora != -1?(char *)tST.sSgPais.arr:"");
                pXmlG->addItem("nmPais", tST.iNmPais_ora != -1?(char *)tST.sNmPais.arr:"");
                pXmlG->addItem("dsNacionalidade", tST.iDsNacionalidade_ora != -1?(char *)tST.sDsNacionalidade.arr:"");
            pXmlG->closeTag();

            pXmlG->addItem("dtCadastro", tST.iDtCadastroOut_ora != -1?(char *)tST.sDtCadastroOut.arr:"");
            pXmlG->addItem("nmPessoaContato", tST.iNmPessoaContato_ora != -1?(char *)tST.sNmPessoaContato.arr:"");
            pXmlG->addItem("inEnderecoPreferencial", tST.iInEnderecoPreferencial_ora != -1?(char *)tST.sInEnderecoPreferencial.arr:"");
            pXmlG->addItem("dtExpiracao", tST.iDtExpiracaoOut_ora != -1 ?(char *)tST.sDtExpiracaoOut.arr:"");

			
			//Verifica se o endereco eh ou nao do FrontOffice
            memset(szIdSistemaOrigem, 0x00, sizeof(szIdSistemaOrigem));
            if(tST.iIdSistemaOrigem_ora != -1) {
                strcpy(szIdSistemaOrigem, (char *)tST.sIdSistemaOrigem.arr);
            }

		    if(strcmp(szIdSistemaOrigem, "7"))
			    pXmlG->addItem("inSincronismo", "1");
		    else
			    pXmlG->addItem("inSincronismo", "0");
        pXmlG->closeTag();

	}
    pXmlG->closeTag();
    pXmlG->closeTag();

    EXEC SQL CLOSE cCursor;

	ULOG_END("CPessoaEndereco::RecuperarTodos()");    
	return;

	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d, sqlerrmc=%.70s", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaEndereco::RecuperarTodos()");    
		throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}
