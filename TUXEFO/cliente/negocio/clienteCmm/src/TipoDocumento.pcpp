// TipoDocumento.pcpp: implementation for the 
// CTipoDocumento class.
//////////////////////////////////////////////////////////////////////

/*
 * Task force to seek potential memory leaks and exception errors - March,2005 - Cassio
 */

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw.h>
#include "../include/Global.h"
EXEC SQL INCLUDE "../include/TipoDocumento.h";

//
// Construtor e Destrutor
CTipoDocumento::CTipoDocumento() {
	icSgTipoDocumento = -1;
	icDsTipoDocumento = -1;

	memset(sIdUsuarioAlteracao,0,256);
}

CTipoDocumento::CTipoDocumento(int iIdTipoCorr) {
    
    ULOG_START("CTipoDocumento::CTipoDocumento()"); 

	struct sqlca sqlca;

	iIdTipoDocumento = iIdTipoCorr;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL SELECT
	 SgClassificacao,
	 DsTipoDocumento,
	 IdTipoPessoa
	INTO
	 :cSgTipoDocumento:icSgTipoDocumento,
	 :cDsTipoDocumento:icDsTipoDocumento,
	 :iIdTipoPessoa
	FROM
	 apoio.TipoDocumento
	WHERE
	 IdTipoDocumento = :iIdTipoDocumento;

	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND)
		iIdTipoDocumento = -1;

	ULOG_END("CTipoDocumento::CTipoDocumento()"); 
	return;

	sqlErrorConstrutor:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
		throw TuxBasicOraException(sqlca.sqlcode);
}

CTipoDocumento::~CTipoDocumento() {
}

// Usuário de alteração
void CTipoDocumento::setUsuarioAlteracao(char* value) {
	if (value != NULL) {
		strncpy(sIdUsuarioAlteracao,value, 255);
		sIdUsuarioAlteracao[255]='\0';
	}
}

//
// Metodos getter
int CTipoDocumento::getIdTipoDocumento(){
	return iIdTipoDocumento;
}

char* CTipoDocumento::getSgTipoDocumento(){
	if (icSgTipoDocumento < 0)
		return NULL;
	else
		return cSgTipoDocumento;
}

char* CTipoDocumento::getDsTipoDocumento(){
	if (icDsTipoDocumento < 0)
		return NULL;
	else
		return cDsTipoDocumento;
}

int CTipoDocumento::getIdTipoPessoa(){
	return iIdTipoPessoa;
}

//
// Metodos setter
void CTipoDocumento::setIdTipoDocumento(int value){
	iIdTipoDocumento = value;
}

void CTipoDocumento::setSgTipoDocumento(char* value){
	if (value == NULL)
		icSgTipoDocumento = -1;
	else {
		strncpy(cSgTipoDocumento, value, 255);
		cSgTipoDocumento[255]='\0';
		icSgTipoDocumento = strlen(value);
	}
}

void CTipoDocumento::setDsTipoDocumento(char* value){
	if (value == NULL)
		icDsTipoDocumento = -1;
	else {
		strncpy(cDsTipoDocumento, value, 255);
		cDsTipoDocumento[255]='\0';
		icDsTipoDocumento = strlen(value);
	}
}

void CTipoDocumento::setIdTipoPessoa(int value){
	iIdTipoPessoa = value;
}

//
// Métodos de acesso a banco de dados
void CTipoDocumento::inclui(){
    
    ULOG_START("CTipoDocumento::inclui()"); 

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		int iNovoId;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorInc;

	// Busca o novo ID da sequence.
	EXEC SQL
		SELECT apoio.TipoDocumentoSQ.NEXTVAL
		INTO :iNovoId
		FROM DUAL;
	if (sqlca.sqlcode)
	{
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
	    ULOG_END("CTipoDocumento::inclui()"); 
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	// Insere no banco de dados
	EXEC SQL
	INSERT INTO apoio.TipoDocumento
	(IdTipoDocumento,
	 SgClassificacao,
	 DsTipoDocumento,
	 IdTipoPessoa,
	 IdUsuarioAlteracao,
	 DtUltimaAlteracao)
	VALUES
	(:iNovoId,
	 :cSgTipoDocumento:icSgTipoDocumento,
	 :cDsTipoDocumento:icDsTipoDocumento,
	 :iIdTipoPessoa,
	 :sIdUsuarioAlteracao,
	 SYSDATE);

	// Inserção OK, coloca o ID no objeto
	iIdTipoDocumento = iNovoId;

    ULOG_END("CTipoDocumento::inclui()"); 
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorInc:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
	    ULOG_END("CTipoDocumento::inclui()"); 
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CTipoDocumento::exclui(){
    
    ULOG_START("CTipoDocumento::exclui()"); 

	struct sqlca sqlca;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorExc;

	// Remove do banco de dados
	EXEC SQL
	DELETE apoio.TipoDocumento
	WHERE IdTipoDocumento = :iIdTipoDocumento;

	// Remoção OK, seta ID do objeto para -1
	iIdTipoDocumento = -1;

	ULOG_END("CTipoDocumento::exclui()"); 
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorExc:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
	    ULOG_END("CTipoDocumento::exclui()"); 
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CTipoDocumento::altera(){

	ULOG_START("CTipoDocumento::altera()"); 
	struct sqlca sqlca;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorAlt;

	// Altera no banco de dados para os dados atuais
	EXEC SQL
	UPDATE apoio.TipoDocumento
	SET
	 SgTipoDocumento = :cSgTipoDocumento:icSgTipoDocumento,
	 DsTipoDocumento = :cDsTipoDocumento:icDsTipoDocumento,
	 IdTipoPessoa = :iIdTipoPessoa,
	 IdUsuarioAlteracao = :sIdUsuarioAlteracao,
	 DtUltimaAlteracao = SYSDATE
	WHERE
	 IdTipoDocumento = :iIdTipoDocumento;

	ULOG_END("CTipoDocumento::altera()"); 
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorAlt:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
	    ULOG_END("CTipoDocumento::altera()"); 
		throw TuxBasicOraException(sqlca.sqlcode);
}

CTipoDocumento* CTipoDocumento::lista(int* iNroObjetos){


	ULOG_START("CTipoDocumento::lista()"); 
	struct sqlca sqlca;
	CTipoDocumento* listaTipoDoc = NULL;
	int iNroObjLocal = 1;

	EXEC SQL BEGIN DECLARE SECTION;
	int iIdTipoDoc;
	char cSgTipoDoc[256];
	char cDsTipoDoc[256];
	int iIdTipoPess;
	short icSgTipoDoc;
	short icDsTipoDoc;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL DECLARE motivos CURSOR FOR
	SELECT
	 IdTipoDocumento,
	 SgClassificacao,
	 DsTipoDocumento,
	 IdTipoPessoa
	FROM
	 apoio.TipoDocumento
	WHERE
	 IdTipoDocumento > 0
	ORDER BY 3;
	EXEC SQL OPEN motivos;

	// Corre os dados e monta a lista de objetos
	EXEC SQL WHENEVER NOT FOUND DO break;
	for (;; iNroObjLocal++) {
		
		EXEC SQL FETCH motivos INTO
		 :iIdTipoDoc,
		 :cSgTipoDoc:icSgTipoDoc,
		 :cDsTipoDoc:icDsTipoDoc,
		 :iIdTipoPess;

		// Aloca memória para o objeto atual.
		if ((listaTipoDoc = (CTipoDocumento*) realloc((void *)listaTipoDoc, (sizeof(CTipoDocumento) * iNroObjLocal))) != NULL) {
			
			// Coloca os dados do objeto atual.
			listaTipoDoc[iNroObjLocal-1].setIdTipoDocumento(iIdTipoDoc);
			listaTipoDoc[iNroObjLocal-1].setSgTipoDocumento(icSgTipoDoc < 0 ? NULL : cSgTipoDoc);
			listaTipoDoc[iNroObjLocal-1].setDsTipoDocumento(icDsTipoDoc < 0 ? NULL : cDsTipoDoc);
			listaTipoDoc[iNroObjLocal-1].setIdTipoPessoa(iIdTipoPess);

		} else {
			if (listaTipoDoc)
				free(listaTipoDoc);
				
			ULOG_END("CTipoDocumento::lista()"); 
			throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
		}
	}

	*iNroObjetos = iNroObjLocal - 1;
	ULOG_END("CTipoDocumento::lista()"); 
	return listaTipoDoc;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
	    ULOG_END("CTipoDocumento::lista()"); 
		throw TuxBasicOraException(sqlca.sqlcode);
}

CTipoDocumento* CTipoDocumento::listaPorIdTipoPessoa(int* iNroObjetos, char *pId){

	ULOG_START("CTipoDocumento::listaPorIdTipoPessoa()"); 
	struct sqlca sqlca;
	CTipoDocumento* listaTipoDoc = NULL;
	int iNroObjLocal = 1;
    bool bFlagCPF=false;

	EXEC SQL BEGIN DECLARE SECTION;
	int iIdTipoDoc;
	char cSgTipoDoc[256];
	char cDsTipoDoc[256];
    char *pIdTipoPessoa = pId?pId:0;
	int iIdTipoPess;
	short icSgTipoDoc;
	short icDsTipoDoc;
	EXEC SQL END DECLARE SECTION;

    ULOG("listaPorIdTipoPessoa");

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
    if ( *pIdTipoPessoa == '1' )
    {
	    EXEC SQL DECLARE motivosPorIdPF CURSOR for
            SELECT 
                TD.IDTIPODOCUMENTO, 
                TD.SGCLASSIFICACAO, 
                TD.DSTIPODOCUMENTO, 
                TD.IDTIPOPESSOA,
                TD.NRPRIORIDADE 
            FROM 
                APOIO.TIPODOCUMENTO TD
            WHERE
                TD.IDTIPODOCUMENTO > 0 
            AND TD.INVISUALIZA = 1
            AND TD.SGCLASSIFICACAO IN ('RG', 'CPF', 'PAS')
            AND TD.IDTIPOPESSOA = 1
            ORDER BY
                TD.NRPRIORIDADE;
    }
    else
    {
	    EXEC SQL DECLARE motivosPorIdPJ CURSOR for
            SELECT 
                TD.IDTIPODOCUMENTO, 
                TD.SGCLASSIFICACAO, 
                TD.DSTIPODOCUMENTO, 
                TD.IDTIPOPESSOA,
                TD.NRPRIORIDADE 
            FROM 
                APOIO.TIPODOCUMENTO TD
            WHERE
                TD.IDTIPODOCUMENTO > 0 
            AND TD.INVISUALIZA = 1
            AND TD.SGCLASSIFICACAO IN ('IE','IF','IM','II','RCC','RES','RFI','RJC','CNPJ')
            AND TD.IDTIPOPESSOA = 2
            ORDER BY
                TD.NRPRIORIDADE;
    }

    if ( *pIdTipoPessoa == '1' )
    {
	    EXEC SQL OPEN motivosPorIdPF;
    }
    else
    {
	    EXEC SQL OPEN motivosPorIdPJ;
    }

	// Corre os dados e monta a lista de objetos
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	for (;;)
    {
        if ( *pIdTipoPessoa == '1' )
        {
		    EXEC SQL FETCH motivosPorIdPF INTO
		     :iIdTipoDoc,
		     :cSgTipoDoc:icSgTipoDoc,
		     :cDsTipoDoc:icDsTipoDoc,
		     :iIdTipoPess;
        }
        else
        {
		    EXEC SQL FETCH motivosPorIdPJ INTO
		     :iIdTipoDoc,
		     :cSgTipoDoc:icSgTipoDoc,
		     :cDsTipoDoc:icDsTipoDoc,
		     :iIdTipoPess;
        }

        ULOG("cDsTipoDoc[%s]", cDsTipoDoc ? cDsTipoDoc : "NULL");

        if(memcmp(cDsTipoDoc, "CPF", 3) && bFlagCPF==true)
            bFlagCPF=false;

        if(bFlagCPF == false) {
            ULOG("Local1");

    		// Aloca memória para o objeto atual.
    		if ((listaTipoDoc = (CTipoDocumento*) realloc((void *)listaTipoDoc, (sizeof(CTipoDocumento) * iNroObjLocal))) != NULL) {
    			
    			// Coloca os dados do objeto atual.
    			listaTipoDoc[iNroObjLocal-1].setIdTipoDocumento(iIdTipoDoc);
    			listaTipoDoc[iNroObjLocal-1].setSgTipoDocumento(icSgTipoDoc < 0 ? NULL : cSgTipoDoc);
    			listaTipoDoc[iNroObjLocal-1].setDsTipoDocumento(icDsTipoDoc < 0 ? NULL : cDsTipoDoc);
    			listaTipoDoc[iNroObjLocal-1].setIdTipoPessoa(iIdTipoPess);
    
    		} else {
    			if (listaTipoDoc){
    				free(listaTipoDoc);
                    if ( *pIdTipoPessoa == '1' )
                    {
                        EXEC SQL CLOSE motivosPorIdPF;
                    }
                    else
                    {
                        EXEC SQL CLOSE motivosPorIdPJ;
                    }
                }
                ULOG_END("CTipoDocumento::listaPorIdTipoPessoa()"); 
    			throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
    		}

            iNroObjLocal++;
        }

        if(!memcmp(cDsTipoDoc, "CPF", 3))
            bFlagCPF=true;
        else
            bFlagCPF=false;

        memset(cDsTipoDoc, 0x00, sizeof(cDsTipoDoc));

	}

    if ( *pIdTipoPessoa == '1' )
    {
        EXEC SQL CLOSE motivosPorIdPF;
    }
    else
    {
        EXEC SQL CLOSE motivosPorIdPJ;
    }

	*iNroObjetos = iNroObjLocal - 1;
	ULOG_END("CTipoDocumento::listaPorIdTipoPessoa()"); 
	return listaTipoDoc;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
	    ULOG_END("CTipoDocumento::listaPorIdTipoPessoa()"); 
		throw TuxBasicOraException(sqlca.sqlcode);
}

CTipoDocumento* CTipoDocumento::listaFiltrado(int* iNroObjetos){

	ULOG_START("CTipoDocumento::listaFiltrado()"); 
	struct sqlca sqlca;
	CTipoDocumento* listaTipoDoc = NULL;
	int iNroObjLocal = 1;

	EXEC SQL BEGIN DECLARE SECTION;
	int iIdTipoDoc;
	VARCHAR cSgTipoDoc[256];
	VARCHAR cDsTipoDoc[256];
	int iIdTipoPess;
	short icSgTipoDoc;
	short icDsTipoDoc;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL DECLARE CursorlistaFiltrado CURSOR FOR
	SELECT
		IDTIPODOCUMENTO,
		SGCLASSIFICACAO,
		DSTIPODOCUMENTO,
		IDTIPOPESSOA
	FROM
		APOIO.TIPODOCUMENTO TIPODOCUMENTO
	WHERE
	 	IDTIPODOCUMENTO > 0
	AND
		TIPODOCUMENTO.INVISUALIZA = 1
	ORDER BY 
        DSTIPODOCUMENTO;

	EXEC SQL OPEN CursorlistaFiltrado;

	// Corre os dados e monta a lista de objetos
	EXEC SQL WHENEVER NOT FOUND DO break;
	for (;;iNroObjLocal++)
	{
		
		memset( &cSgTipoDoc, 0, sizeof( cSgTipoDoc ) );
		memset( &cDsTipoDoc, 0, sizeof( cDsTipoDoc ) );
		EXEC SQL FETCH CursorlistaFiltrado INTO
		 :iIdTipoDoc,
		 :cSgTipoDoc:icSgTipoDoc,
		 :cDsTipoDoc:icDsTipoDoc,
		 :iIdTipoPess;

		// Aloca memória para o objeto atual.
		if ((listaTipoDoc = (CTipoDocumento*) realloc((void *)listaTipoDoc, (sizeof(CTipoDocumento) * iNroObjLocal))) != NULL) 
		{
			
			// Coloca os dados do objeto atual.
			listaTipoDoc[iNroObjLocal-1].setIdTipoDocumento(iIdTipoDoc);
			listaTipoDoc[iNroObjLocal-1].setSgTipoDocumento(icSgTipoDoc < 0 ? NULL : (char*)cSgTipoDoc.arr);
			listaTipoDoc[iNroObjLocal-1].setDsTipoDocumento(icDsTipoDoc < 0 ? NULL : (char*)cDsTipoDoc.arr);
			listaTipoDoc[iNroObjLocal-1].setIdTipoPessoa(iIdTipoPess);

		} else 
		{
			if (listaTipoDoc)
				free(listaTipoDoc);
			ULOG_END("CTipoDocumento::listaFiltrado()"); 
			throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
		}
	}
	EXEC SQL CLOSE CursorlistaFiltrado;

	*iNroObjetos = iNroObjLocal - 1;
	ULOG_END("CTipoDocumento::listaFiltrado()"); 
	return listaTipoDoc;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
	    ULOG_END("CTipoDocumento::listaFiltrado()"); 
		throw TuxBasicOraException(sqlca.sqlcode);
}
