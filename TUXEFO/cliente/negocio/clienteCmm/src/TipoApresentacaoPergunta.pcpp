// TipoApresentacaoPergunta.pcpp: implementation for the 
// CTipoApresentacaoPergunta class.
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw.h>
EXEC SQL INCLUDE "../include/TipoApresentacaoPergunta.h";

//
// Construtor e Destrutor
CTipoApresentacaoPergunta::CTipoApresentacaoPergunta() {
	icSgTipoApresentacaoPergunta = -1;
	icDsTipoApresentacaoPergunta = -1;

	memset(sIdUsuarioAlteracao,0,256);
}

CTipoApresentacaoPergunta::~CTipoApresentacaoPergunta() {
}

// Usuário de alteração
void CTipoApresentacaoPergunta::setUsuarioAlteracao(char* value) {
	if (value != NULL) {
		strncpy(sIdUsuarioAlteracao,value, 255);
		sIdUsuarioAlteracao[255]='\0';
	}
}

//
// Metodos getter
int CTipoApresentacaoPergunta::getIdTipoApresentacaoPergunta(){
	return iIdTipoApresentacaoPergunta;
}

char* CTipoApresentacaoPergunta::getSgTipoApresentacaoPergunta(){
	if (icSgTipoApresentacaoPergunta < 0)
		return NULL;
	else
		return cSgTipoApresentacaoPergunta;
}

char* CTipoApresentacaoPergunta::getDsTipoApresentacaoPergunta(){
	if (icDsTipoApresentacaoPergunta < 0)
		return NULL;
	else
		return cDsTipoApresentacaoPergunta;
}

//
// Metodos setter
void CTipoApresentacaoPergunta::setIdTipoApresentacaoPergunta(int value){
	iIdTipoApresentacaoPergunta = value;
}

void CTipoApresentacaoPergunta::setSgTipoApresentacaoPergunta(char* value){
	if (value == NULL)
		icSgTipoApresentacaoPergunta = -1;
	else {
		strncpy(cSgTipoApresentacaoPergunta, value, 255);
		cSgTipoApresentacaoPergunta[255]='\0';
		icSgTipoApresentacaoPergunta = strlen(value);
	}
}

void CTipoApresentacaoPergunta::setDsTipoApresentacaoPergunta(char* value){
	if (value == NULL)
		icDsTipoApresentacaoPergunta = -1;
	else {
		strncpy(cDsTipoApresentacaoPergunta, value, 255);
		cDsTipoApresentacaoPergunta[255]='\0';
		icDsTipoApresentacaoPergunta = strlen(value);
	}
}

//
// Métodos de acesso a banco de dados
void CTipoApresentacaoPergunta::inclui(){
    ULOG_START("CTipoApresentacaoPergunta::inclui()");
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		int iNovoId;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorInc;

	// Busca o novo ID da sequence.
	EXEC SQL
		SELECT apoio.TipoApresentacaoPerguntaSQ.NEXTVAL
		INTO :iNovoId
		FROM DUAL;
	if (sqlca.sqlcode)
	{
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CTipoApresentacaoPergunta::inclui()");
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	// Insere no banco de dados
	EXEC SQL
	INSERT INTO apoio.TipoApresentacaoPergunta
	(IdTipoApresentacaoPergunta,
	 SgTipoApresentacaoPergunta,
	 DsTipoApresentacaoPergunta,
	 IdUsuarioAlteracao,
	 DtUltimaAlteracao)
	VALUES
	(:iNovoId,
	 :cSgTipoApresentacaoPergunta:icSgTipoApresentacaoPergunta,
	 :cDsTipoApresentacaoPergunta:icDsTipoApresentacaoPergunta,
	 :sIdUsuarioAlteracao,
	 SYSDATE);

	// Inserção OK, coloca o ID no objeto
	iIdTipoApresentacaoPergunta = iNovoId;

	ULOG_END("CTipoApresentacaoPergunta::inclui()");
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorInc:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CTipoApresentacaoPergunta::inclui()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CTipoApresentacaoPergunta::exclui(){

	ULOG_START("CTipoApresentacaoPergunta::exclui()");
	struct sqlca sqlca;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorExc;

	// Remove do banco de dados
	EXEC SQL
	DELETE apoio.TipoApresentacaoPergunta
	WHERE IdTipoApresentacaoPergunta = :iIdTipoApresentacaoPergunta;

	// Remoção OK, seta ID do objeto para -1
	iIdTipoApresentacaoPergunta = -1;

	ULOG_END("CTipoApresentacaoPergunta::exclui()");
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorExc:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CTipoApresentacaoPergunta::exclui()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CTipoApresentacaoPergunta::altera(){

	ULOG_START("CTipoApresentacaoPergunta::altera()");
	struct sqlca sqlca;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorAlt;

	// Altera no banco de dados para os dados atuais
	EXEC SQL
	UPDATE apoio.TipoApresentacaoPergunta
	SET
	 SgTipoApresentacaoPergunta = :cSgTipoApresentacaoPergunta:icSgTipoApresentacaoPergunta,
	 DsTipoApresentacaoPergunta = :cDsTipoApresentacaoPergunta:icDsTipoApresentacaoPergunta,
	 IdUsuarioAlteracao = :sIdUsuarioAlteracao,
	 DtUltimaAlteracao = SYSDATE
	WHERE
	 IdTipoApresentacaoPergunta = :iIdTipoApresentacaoPergunta;

	
	ULOG_END("CTipoApresentacaoPergunta::altera()");
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorAlt:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CTipoApresentacaoPergunta::altera()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

CTipoApresentacaoPergunta* CTipoApresentacaoPergunta::lista(int* iNroObjetos){

	ULOG_START("CTipoApresentacaoPergunta::lista()");
	struct sqlca sqlca;
	CTipoApresentacaoPergunta* listaTpoApr = NULL;
	int iNroObjLocal = 1;

	EXEC SQL BEGIN DECLARE SECTION;
	int iIdTpoApr;
	char cSgTpoApr[256];
	char cDsTpoApr[256];
	short icSgTpoApr;
	short icDsTpoApr;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL DECLARE motivos CURSOR FOR
	SELECT
	 IdTipoApresentacaoPergunta,
	 SgTipoApresentacaoPergunta,
	 DsTipoApresentacaoPergunta
	FROM
	 apoio.TipoApresentacaoPergunta;
	EXEC SQL OPEN motivos;

	// Corre os dados e monta a lista de objetos
	EXEC SQL WHENEVER NOT FOUND DO break;
	for (;; iNroObjLocal++) {
		
		EXEC SQL FETCH motivos INTO
		 :iIdTpoApr,
		 :cSgTpoApr:icSgTpoApr,
		 :cDsTpoApr:icDsTpoApr;

		// Aloca memória para o objeto atual.
		if ((listaTpoApr = (CTipoApresentacaoPergunta*) realloc((void *)listaTpoApr, (sizeof(CTipoApresentacaoPergunta) * iNroObjLocal))) != NULL) {
			
			// Coloca os dados do objeto atual.
			listaTpoApr[iNroObjLocal-1].setIdTipoApresentacaoPergunta(iIdTpoApr);
			listaTpoApr[iNroObjLocal-1].setSgTipoApresentacaoPergunta(icSgTpoApr < 0 ? NULL : cSgTpoApr);
			listaTpoApr[iNroObjLocal-1].setDsTipoApresentacaoPergunta(icDsTpoApr < 0 ? NULL : cDsTpoApr);

		} else {
			if (listaTpoApr)
				free(listaTpoApr);
				
			ULOG_END("CTipoApresentacaoPergunta::lista()");
			throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
		}
	}

	*iNroObjetos = iNroObjLocal - 1;
	ULOG_END("CTipoApresentacaoPergunta::lista()");
	return listaTpoApr;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CTipoApresentacaoPergunta::lista()");
		throw TuxBasicOraException(sqlca.sqlcode);
}