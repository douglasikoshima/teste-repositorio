//---------------------------------------------------------------------
//*
//* Class: classPessoaComunicacao
//---------------------------------------------------------------------
//* Purpose:
//*
//* 
//---------------------------------------------------------------------

#undef SQLCA
#define SQLCA_NONE
#include <sqlca.h>
#include <sqlda.h>

#ifdef WIN32
#pragma warning(disable:4786)
#endif

#include <string>

using namespace std;

#include <tuxfw.h>
#include "../include/Exception.h"

#undef MSG_NONE
#define MSG_NONE
#include "../include/Messages.h"

EXEC SQL BEGIN DECLARE SECTION;
EXEC SQL INCLUDE "../include/Global.h";
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE "../include/classPessoaComunicacao.h";


// Usuário de alteração
void CPessoaComunicacao::setUsuarioAlteracao(char* value) {
	if (value != NULL) {
		strncpy(sIdUsuarioAlteracao,value, 255);
		sIdUsuarioAlteracao[255]='\0';
	}
}

//
// Construtor e Destrutor
CPessoaComunicacao::CPessoaComunicacao()
{
    memset(&tPessCom, 0x00, sizeof(tPessCom));

	memset(sIdUsuarioAlteracao,0,256);
}

CPessoaComunicacao::~CPessoaComunicacao()
{
}

//
// Metodos getter
char* CPessoaComunicacao::getIdPessoa(void)
{
    return ((char *)tPessCom.sIdPessoa.arr);
}
char* CPessoaComunicacao::getIdComunicacao(void)
{
    return ((char *)tPessCom.sIdComunicacao.arr);
}
char* CPessoaComunicacao::getIdSistemaOrigem(void)
{
    return ((char *)tPessCom.sIdSistemaOrigem.arr);
}
char* CPessoaComunicacao::getIdSistemaOrigemBase(void)
{
    return ((char *)tPessCom.sIdSistemaOrigemBase.arr);
}
char* CPessoaComunicacao::getIdTipoComunicacao(void)
{
    return ((char *)tPessCom.sIdTipoComunicacao.arr);
}
char* CPessoaComunicacao::getSgTipoComunicacao(void)
{
    return ((char *)tPessCom.sSgTipoComunicacao.arr);
}
char* CPessoaComunicacao::getDsTipoComunicacao(void)
{
    return ((char *)tPessCom.sDsTipoComunicacao.arr);
}
char* CPessoaComunicacao::getDsContato(void)
{
    return ((char *)tPessCom.sDsContato.arr);
}
char* CPessoaComunicacao::getDtCadastroOut(void)
{
    return ((char *)tPessCom.sDtCadastroOut.arr);
}
long CPessoaComunicacao::getTsSincronismo(void)
{
    return (tPessCom.lTsSincronismo);
}
long CPessoaComunicacao::getSqSincronismo(void)
{
    return (tPessCom.lSqSincronismo);
}
char* CPessoaComunicacao::getNmContato(void)
{
	return ((char *)tPessCom.sNmContato.arr);
}
char* CPessoaComunicacao::getNrSequencia(void)
{
	return ((char *)tPessCom.sNrSequencia.arr);
}

char* CPessoaComunicacao::getSgClassificacao(void)
{					      
	return ((char *)tPessCom.sSgClassificacao.arr);
}


//
// Metodos setter
void CPessoaComunicacao::setIdPessoa(char* pDado)
{
    STRCPY_TO_ORA(tPessCom.sIdPessoa, pDado);
    tPessCom.iIdPessoa_ora = 0;
}
void CPessoaComunicacao::setIdComunicacao(char* pDado)
{
    STRCPY_TO_ORA(tPessCom.sIdComunicacao, pDado);
    tPessCom.iIdComunicacao_ora = 0;
}
void CPessoaComunicacao::setIdSistemaOrigem(char* pDado)
{
    STRCPY_TO_ORA(tPessCom.sIdSistemaOrigem, pDado);
    tPessCom.iIdSistemaOrigem_ora = 0;
}
void CPessoaComunicacao::setIdSistemaOrigemBase(char* pDado)
{
    STRCPY_TO_ORA(tPessCom.sIdSistemaOrigemBase, pDado);
    tPessCom.iIdSistemaOrigemBase_ora = 0;
}
void CPessoaComunicacao::setIdTipoComunicacao(char* pDado)
{
    STRCPY_TO_ORA(tPessCom.sIdTipoComunicacao, pDado);
    tPessCom.iIdTipoComunicacao_ora = 0;
}
void CPessoaComunicacao::setSgTipoComunicacao(char* pDado)
{
    STRCPY_TO_ORA(tPessCom.sSgTipoComunicacao, pDado);
    tPessCom.iSgTipoComunicacao_ora = 0;
}
void CPessoaComunicacao::setDsTipoComunicacao(char* pDado)
{
    STRCPY_TO_ORA(tPessCom.sDsTipoComunicacao, pDado);
    tPessCom.iDsTipoComunicacao_ora = 0;
}
void CPessoaComunicacao::setDsContato(char* pDado)
{
    STRCPY_TO_ORA(tPessCom.sDsContato, pDado);
    tPessCom.iDsContato_ora = 0;
}
void CPessoaComunicacao::setDtCadastroOut(char* pDado)
{
    STRCPY_TO_ORA(tPessCom.sDtCadastroOut, pDado);
    tPessCom.iDtCadastroOut_ora = 0;
}
void CPessoaComunicacao::setTsSincronismo(long lDado)
{
    tPessCom.lTsSincronismo = lDado;
    tPessCom.iTsSincronismo_ora = 0;
}
void CPessoaComunicacao::setSqSincronismo(long lDado)
{
    tPessCom.lSqSincronismo = lDado;
    tPessCom.iSqSincronismo_ora = 0;
}
void CPessoaComunicacao::setNmContato(char* pDado)
{
    STRCPY_TO_ORA(tPessCom.sNmContato, pDado);
    tPessCom.iNmContato_ora = 0;
}
void CPessoaComunicacao::setNrSequencia(char* pDado)
{
    STRCPY_TO_ORA(tPessCom.sNrSequencia, pDado);
    tPessCom.iNrSequencia_ora = 0;
}

void CPessoaComunicacao::setSgClassificacao(char* pDado)
{
    STRCPY_TO_ORA(tPessCom.sSgClassificacao, pDado);
    tPessCom.iSgClassificacao_ora = 0;
}





int CPessoaComunicacao::isGood()
{
   return strlen( getDsContato() ) > 0 && strlen( getIdTipoComunicacao() ) > 0; 
}

void CPessoaComunicacao::SetData(TListaTelefone xm)
{
		 setIdTipoComunicacao(xm.idTipoTelefone); 
		 setIdComunicacao(xm.idTelefone); 
		 setDsContato(xm.nrTelefone);
		 setNmContato(xm.nmContato); 
}

//Metodos de acesso ao Banco de Dados

int CPessoaComunicacao::Incluir()
{
    ULOG_START("CPessoaComunicacao::Incluir()");    
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        int iTemRegistro;
	EXEC SQL END DECLARE SECTION;

    

    /* Verificando se ja existe uma entrada do tipo na base */
    EXEC SQL SELECT count(1)
               INTO :iTemRegistro
               FROM customer.pessoacomunicacao
              WHERE ( idtipocomunicacao = :tPessCom.sIdTipoComunicacao
                    AND dscontato = :tPessCom.sDsContato
                    AND idpessoa = :tPessCom.sIdPessoa )
                OR ( idpessoa = :tPessCom.sIdPessoa
                    AND  nrsequencia = :tPessCom.sNrSequencia);

    ULOGI("iTemRegistro(%d)", iTemRegistro);

    if (iTemRegistro)
        return DUPLICATE_KEY;

    /* Obtendo a sequence */
    EXEC SQL SELECT customer.pessoacomunicacaosq.NEXTVAL 
               INTO :tPessCom.sIdComunicacao:tPessCom.iIdComunicacao_ora
               FROM dual;

    ULOG("tPessCom.sIdComunicacao.arr[%s]", tPessCom.sIdComunicacao.arr);

    
	EXEC SQL WHENEVER SQLERROR	goto erro;
	
	if( strlen( (char*)tPessCom.sNmContato.arr ) <= 0 )
		tPessCom.sNmContato.len = 0;

    EXEC SQL 
        INSERT INTO customer.pessoacomunicacao (
                     IDPESSOACOMUNICACAO,
                     IDPESSOA,
                     IDTIPOCOMUNICACAO,
                     IDSISTEMAORIGEM,
                     NRSEQUENCIA,
                     DSCONTATO,
                     TSSINCRONISMO,
                     SQSINCRONISMO,
                     DTCADASTRO,
                     IDCOMUNICACAOSISTEMAORIGEM,
                     DTEXPIRACAO,
                     INCOMUNICACAOPREFERENCIAL,
                     IDUSUARIOALTERACAO,
                     DTULTIMAALTERACAO, 
		             NMCONTATO 
		     )
             VALUES( :tPessCom.sIdComunicacao:tPessCom.iIdComunicacao_ora,
                     :tPessCom.sIdPessoa:tPessCom.iIdPessoa_ora,
                     :tPessCom.sIdTipoComunicacao:tPessCom.iIdTipoComunicacao_ora,
                     7, // FO - Front-Office
                     :tPessCom.sNrSequencia:tPessCom.iNrSequencia_ora,
                     :tPessCom.sDsContato:tPessCom.iDsContato_ora,
                     '',
                     '',
                     SYSDATE,
                     :tPessCom.sIdComunicacao:tPessCom.iIdComunicacao_ora,
                     '',
                     '',
                     :sIdUsuarioAlteracao,
                     SYSDATE,
		             :tPessCom.sNmContato:tPessCom.iNmContato_ora
		    );
    ULOG_END("CPessoaComunicacao::Incluir()");    

    if (!sqlca.sqlerrd[2])
        return NOK;
    else
        return OK;

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaComunicacao::Incluir()");    
		throw  new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,
					sqlca.sqlerrm.sqlerrml);
}

int CPessoaComunicacao::Excluir()
{
	ULOG_START("CPessoaComunicacao::Excluir()");    
	struct sqlca sqlca;

	EXEC SQL WHENEVER SQLERROR	goto erro;

    /* Exclusao logica */
    EXEC SQL DELETE customer.pessoacomunicacao
             WHERE idpessoacomunicacao = :tPessCom.sIdComunicacao;
  
    ULOG_END("CPessoaComunicacao::Excluir()");    
    if (!sqlca.sqlerrd[2])
        return NOK;
    else
        return OK;

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		throw  new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,
					sqlca.sqlerrm.sqlerrml);
}

int CPessoaComunicacao::Alterar()
{
    ULOG_START("CPessoaComunicacao::Alterar()");

    struct sqlca sqlca;

    string query;
    string updt;

    short iDsContato = tPessCom.sDsContato.arr[0]==0?-1:1;
    short iNmContato = tPessCom.sNmContato.arr[0]==0?-1:1;
    short iNrSequencia = tPessCom.sNrSequencia.arr[0]==0?-1:1;
    short iIdUsuarioAlteracao = *sIdUsuarioAlteracao==0?-1:1;

    EXEC SQL BEGIN DECLARE SECTION;
        const char *pQuery;
    EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR GOTO erro;
    //
    //==========================================================================
    // Atualiza apenas as colunas informadas
    if ( 1 == iDsContato          ) { if(updt.length()>0) {updt+="\n,";} updt+="DSCONTATO         =TRIM('"+(string)(char*)(tPessCom.sDsContato.arr)+"')";}
    if ( 1 == iNmContato          ) { if(updt.length()>0) {updt+="\n,";} updt+="NMCONTATO         =TRIM('"+(string)(char*)(tPessCom.sNmContato.arr)+"')";}
    if ( 1 == iNrSequencia        ) { if(updt.length()>0) {updt+="\n,";} updt+="NRSEQUENCIA       ="+(string)(char*)(tPessCom.sNrSequencia.arr)         ;}
    if ( 1 == iIdUsuarioAlteracao ) { if(updt.length()>0) {updt+="\n,";} updt+="IDUSUARIOALTERACAO="+(string)sIdUsuarioAlteracao                        ;}

    if(updt.length()>0)
    {
        query = "\nUPDATE CUSTOMER.PESSOACOMUNICACAO"
                "\nSET\n" + updt + "\n,DTULTIMAALTERACAO =SYSDATE"
                "\nWHERE IDPESSOACOMUNICACAO="+(string)((char*)tPessCom.sIdComunicacao.arr);

        pQuery = query.c_str();

        ULOG("%s",pQuery);

        EXEC SQL EXECUTE IMMEDIATE :pQuery;

        if ( 1403 == sqlca.sqlcode )
        {
            goto erro;
        }
    }
    else
    {
        ULOGW("Nenhuma coluna passada para a alteração de endereço");
    }

    /*EXEC SQL UPDATE customer.pessoacomunicacao
                SET  dscontato          = :tPessCom.sDsContato
					,IdUsuarioAlteracao = :sIdUsuarioAlteracao
					,nmContato          = :tPessCom.sNmContato
                    ,nrsequencia        = :tPessCom.sNrSequencia
					,DtUltimaAlteracao  = SYSDATE
              WHERE idpessoacomunicacao = :tPessCom.sIdComunicacao;*/

    ULOG_END("CPessoaComunicacao::Alterar()");    
    if (!sqlca.sqlerrd[2])
        return NOK;
    else
        return OK;

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaComunicacao::Alterar()");    
		throw  new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,
					sqlca.sqlerrm.sqlerrml);
}



int CPessoaComunicacao::DeletaPorUsuario()
{
    struct sqlca sqlca;

    EXEC SQL DELETE customer.pessoacomunicacao
              WHERE idpessoa = :tPessCom.sIdPessoa and
			        idTipoComunicacao   = tPessCom.sIdTipoComunicacao; 
erro:
return OK; 
}



int CPessoaComunicacao::AlterarPorUsuario()
{
    ULOG_START("CPessoaComunicacao::AlterarPorUsuario()");    
    struct sqlca sqlca;

	EXEC SQL WHENEVER SQLERROR	goto erro;

    EXEC SQL UPDATE customer.pessoacomunicacao
                SET  dscontato          = :tPessCom.sDsContato
					,IdUsuarioAlteracao = :sIdUsuarioAlteracao
					,nmContato = :tPessCom.sNmContato
					,DtUltimaAlteracao  = SYSDATE
              WHERE idpessoa = :tPessCom.sIdPessoa and
			        idTipoComunicacao   = :tPessCom.sIdTipoComunicacao; 

    if (!sqlca.sqlerrd[2])
        return NOK;
    else
        return OK;

	erro:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaComunicacao::AlterarPorUsuario()");    
		throw  new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,
					sqlca.sqlerrm.sqlerrml);
}


CPessoaComunicacao* CPessoaComunicacao::RecuperarTodos(int* iNroObjetos, char *pID)
{
    ULOG_START("CPessoaComunicacao::RecuperarTodos()");    
    struct sqlca sqlca;
    
    CPessoaComunicacao* oObj = NULL;
    int iNroObjLocal = 1;
    int iNrSeq=-1;
    char szNrSequenciaAux[LEN_NUMBER + LEN_EOS]="0";
    char szIdPessoaComunicacaoAux[LEN_NUMBER + LEN_EOS];

	EXEC SQL BEGIN DECLARE SECTION;
        TPESSOACOMUNICACAO      tST;
        VARCHAR sWhere[255];

        VARCHAR oszNrSequencia[LEN_NUMBER+LEN_EOS];
        VARCHAR oszIdPessoaComunicacao[LEN_NUMBER+LEN_EOS];
	EXEC SQL END DECLARE SECTION;

    STRCPY_TO_ORA(sWhere, pID);

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL DECLARE cCursor CURSOR  FOR
	SELECT  
	     PESSOACOMUNICACAO.IDPESSOACOMUNICACAO
	    ,TIPOCOMUNICACAO.IDTIPOCOMUNICACAO
	    ,TIPOCOMUNICACAO.SGTIPOCOMUNICACAO
	    ,TIPOCOMUNICACAO.DSTIPOCOMUNICACAO
		,TIPOCOMUNICACAO.SGCLASSIFICACAO
	    ,PESSOACOMUNICACAO.DSCONTATO
	    ,TO_CHAR(PESSOACOMUNICACAO.DTCADASTRO, 'DD/MM/YYYY' ) DTCADASTRO
	    ,DECODE(PESSOACOMUNICACAO.TSSINCRONISMO, '', 0, 1) TSSINCRONISMO
	    ,DECODE(PESSOACOMUNICACAO.SQSINCRONISMO, '', 0, 1) SQSINCRONISMO
	    ,PESSOACOMUNICACAO.NMCONTATO
	    ,PESSOACOMUNICACAO.NRSEQUENCIA
	    ,PESSOACOMUNICACAO.IDSISTEMAORIGEM
	FROM 
	    CUSTOMER.PESSOACOMUNICACAO PESSOACOMUNICACAO,
	    APOIO.TIPOCOMUNICACAO TIPOCOMUNICACAO
	WHERE PESSOACOMUNICACAO.IDTIPOCOMUNICACAO = TIPOCOMUNICACAO.IDTIPOCOMUNICACAO
	AND   PESSOACOMUNICACAO.IDPESSOA IN
	      (
	        SELECT PESSOADEPARA.IDPESSOAORIGEM 
	        FROM CUSTOMER.PESSOADEPARA PESSOADEPARA
	        WHERE PESSOADEPARA.IDPESSOA = :sWhere
	      )
	AND PESSOACOMUNICACAO.DTEXPIRACAO IS NULL
	ORDER BY PESSOACOMUNICACAO.NRSEQUENCIA;

	EXEC SQL OPEN cCursor;
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;; iNroObjLocal++) 
    {
        memset(&tST, 0x00, sizeof(tST));
		EXEC SQL FETCH cCursor INTO :tST.sIdComunicacao:tST.iIdComunicacao_ora,
                                    :tST.sIdTipoComunicacao:tST.iIdTipoComunicacao_ora,
                                    :tST.sSgTipoComunicacao:tST.iSgTipoComunicacao_ora,
                                    :tST.sDsTipoComunicacao:tST.iDsTipoComunicacao_ora,
                                    :tST.sSgClassificacao:tST.iSgClassificacao_ora,
                                    :tST.sDsContato:tST.iDsContato_ora,
                                    :tST.sDtCadastroOut:tST.iDtCadastroOut_ora,
                                    :tST.lTsSincronismo:tST.iTsSincronismo_ora,
                                    :tST.lSqSincronismo:tST.iSqSincronismo_ora,
									:tST.sNmContato:tST.iNmContato_ora,
									:tST.sNrSequencia:tST.iNrSequencia_ora,
									:tST.sIdSistemaOrigem:tST.iIdSistemaOrigem_ora;

		// Aloca memória para o objeto atual.
		if ((oObj = (CPessoaComunicacao*) realloc((void *)oObj, (sizeof(CPessoaComunicacao) * iNroObjLocal))) != NULL)
        {
			// Coloca os dados do objeto atual.
            oObj[iNroObjLocal-1].setIdComunicacao((char*)tST.sIdComunicacao.arr);
            oObj[iNroObjLocal-1].setIdTipoComunicacao((char*)tST.sIdTipoComunicacao.arr);
            oObj[iNroObjLocal-1].setSgTipoComunicacao((char*)tST.sSgTipoComunicacao.arr);
            oObj[iNroObjLocal-1].setDsTipoComunicacao((char*)tST.sDsTipoComunicacao.arr);
			oObj[iNroObjLocal-1].setSgClassificacao((char*)tST.sSgClassificacao.arr);
            oObj[iNroObjLocal-1].setDsContato((char*)tST.sDsContato.arr);
            oObj[iNroObjLocal-1].setDtCadastroOut((char*)tST.sDtCadastroOut.arr);
            oObj[iNroObjLocal-1].setTsSincronismo(tST.lTsSincronismo);
            oObj[iNroObjLocal-1].setSqSincronismo(tST.lSqSincronismo);
            oObj[iNroObjLocal-1].setNmContato((char*)tST.sNmContato.arr);

            ULOG("A.(char*)tST.sNrSequencia.arr[%s]", (char*)tST.sNrSequencia.arr);
            ULOG("A.iNrSeq(%d)", iNrSeq);

            if(strlen((char*)tST.sNrSequencia.arr) == 0)
            {
                if(iNrSeq == -1)
                    iNrSeq = atoi(szNrSequenciaAux);

                ULOG("B.iNrSeq(%d)", iNrSeq);
                sprintf((char*)tST.sNrSequencia.arr, "%d", ++iNrSeq);


                STRCPY_TO_ORA(oszNrSequencia, (char*)tST.sNrSequencia.arr); ULOG("oszNrSequencia[%.*s]", oszNrSequencia.len, oszNrSequencia.arr);
                STRCPY_TO_ORA(oszIdPessoaComunicacao, (char*)tST.sIdComunicacao.arr); ULOG("oszIdPessoaComunicacao[%.*s]", oszIdPessoaComunicacao.len, oszIdPessoaComunicacao.arr);


                ULOG("UPDATE customer.pessoacomunicacao");
                EXEC SQL UPDATE customer.pessoacomunicacao
                            SET  nrsequencia        = :oszNrSequencia
                				,DtUltimaAlteracao  = SYSDATE
                          WHERE idpessoacomunicacao = :oszIdPessoaComunicacao;

            }
            else
            {
                strcpy(szNrSequenciaAux, (char*)tST.sNrSequencia.arr);
                ULOG("szNrSequenciaAux[%s]", szNrSequenciaAux);
            }



            ULOG("B.(char*)tST.sNrSequencia.arr[%s]", (char*)tST.sNrSequencia.arr);

            oObj[iNroObjLocal-1].setNrSequencia((char*)tST.sNrSequencia.arr);
            oObj[iNroObjLocal-1].setIdSistemaOrigem((char*)tST.sIdSistemaOrigem.arr);
		} 
        else 
        {
			if (oObj) 
                free(oObj);

	        EXEC SQL CLOSE cCursor;
			ERROR(NRO_MEMORIA);
			ULOG_END("CPessoaComunicacao::RecuperarTodos()");    
			throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
		}
	}

    EXEC SQL CLOSE cCursor;

	*iNroObjetos = iNroObjLocal - 1;
	ULOG_END("CPessoaComunicacao::RecuperarTodos()");    
	return oObj;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	        ULOG_END("CPessoaComunicacao::RecuperarTodos()");    
			throw  new TuxBasicOraException(sqlca.sqlcode);
}

int CPessoaComunicacao::buscaIdSistemaOrigem( char* csgSistemOrigem )
{
    ULOG_START("CPessoaComunicacao::buscaIdSistemaOrigem()");    
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        char* cgSistemOrigemAux = csgSistemOrigem;
        VARCHAR stIdSistemaOrigemBase[21+1];
        short   iIdSistemaOrigemBase;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO GotobuscaIdSistemaOrigem;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    
    memset( &stIdSistemaOrigemBase, 0, sizeof( stIdSistemaOrigemBase ) );

	// Declara e abre o cursor
	EXEC SQL 
	SELECT
		IDSISTEMAORIGEM
	INTO
		:stIdSistemaOrigemBase:iIdSistemaOrigemBase
	FROM
		APOIO.SISTEMAORIGEM
	WHERE
		UPPER(SGSISTEMAORIGEM) = UPPER(:cgSistemOrigemAux);
		
	setIdSistemaOrigemBase( (char*)stIdSistemaOrigemBase.arr );

	ULOG_END("CPessoaComunicacao::buscaIdSistemaOrigem()");    
	return OK;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	GotobuscaIdSistemaOrigem:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CPessoaComunicacao::buscaIdSistemaOrigem()");    
		throw new TuxBasicOraException(sqlca.sqlcode);
}
