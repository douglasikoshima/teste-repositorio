#undef SQLCA
#define SQLCA_NONE
#include <sqlca.h>
#include <sqlda.h>

#include <CPacote.h>
#include <tuxfw.h>

CPacote::CPacote()
{
}

CPacote::~CPacote()
{
}

int CPacote::ListId(char *pIdServicoSistemaOrigem, char *pIdSistemaOrigem) 
{
    ULOG_START("CPacote::ListId()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxIdServicoSistemaOrigem = pIdServicoSistemaOrigem; 
		char* cAuxIdSistemaOrigem = pIdSistemaOrigem; 
		struct
		{
			VARCHAR stIdServicoSistemaOrigem[255+1];
		} stPacoteRegistro;
		struct
		{
			short iIdServicoSistemaOrigem;
		} stPacoteIndicator;
	EXEC SQL END DECLARE SECTION;


    ULOG("pIdServicoSistemaOrigem[%s]", pIdServicoSistemaOrigem);
    ULOG("pIdSistemaOrigem[%s]", pIdSistemaOrigem);


	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraPacote();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

   		EXEC SQL 
			DECLARE 
				CursorPacoteId CURSOR FOR 
            SELECT
                PSFILHO.IDSERVICOSISTEMAORIGEM
            FROM
                LINHA.PLANOSERVICO PSPAI,
                LINHA.PLANOSERVICO PSFILHO,
                LINHA.PACOTE       P
            WHERE
                P.IDSERVICOPAI = PSPAI.IDSERVICO
                AND P.IDSERVICO = PSFILHO.IDSERVICO
                AND PSPAI.IDSISTEMAORIGEM = TO_NUMBER(:cAuxIdSistemaOrigem)
                AND PSPAI.IDSERVICOSISTEMAORIGEM = :cAuxIdServicoSistemaOrigem
                AND PSPAI.DTEXPIRACAO IS NULL
                AND PSFILHO.DTEXPIRACAO IS NULL;

		//Abre o cursor
		EXEC SQL OPEN CursorPacoteId;

        ULOG("1.sqlca.sqlcode(%d)", sqlca.sqlcode);
		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
        {
			return 0;
        }
		else
		{
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
                ULOG("LOCAL1");
				//Zera a estrutura de restorno
				memset(&stPacoteRegistro, 0x00, sizeof(stPacoteRegistro));
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorPacoteId INTO :stPacoteRegistro:stPacoteIndicator;
                ULOG("2.sqlca.sqlcode(%d)", sqlca.sqlcode);
				//Adiciona a classe
                ULOG("Adicionando.... stPacoteRegistro.stIdServicoSistemaOrigem.arr[%s]", stPacoteRegistro.stIdServicoSistemaOrigem.arr);
				Add((char*)stPacoteRegistro.stIdServicoSistemaOrigem.arr);
				//conta quantos existem
				iCont++;
			}
            ULOG("LOCAL2");
            ULOG("3.sqlca.sqlcode(%d)", sqlca.sqlcode);
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorPacoteId;
		}
		//Retorna a quantidade de registros
        ULOG("4.sqlca.sqlcode(%d)", sqlca.sqlcode);
        ULOG_END("CPacote::ListId()");
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListId:
    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    ULOG_END("CPacote::ListId()");
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CPacote::getXmlBasico(char* cNomeTag, XMLGen*xml)
{
    ULOG_START("CPacote::getXmlBasico()");
    ULOG("CPacote::getXmlBasico - cNomeTag[%s]", cNomeTag);

	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			xml->createTag(cNomeTag);
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("dsFacilidade", Registro(x)->cidServicoSistemaOrigem);
				xml->addItem("dsCanalAcesso", "");
				xml->addItem("nrIdentificador", "");
			}
			//So fecha um tag se abriu anteriormente
			xml->closeTag();
		}
	}
	ULOG_END("CPacote::getXmlBasico()");
}
