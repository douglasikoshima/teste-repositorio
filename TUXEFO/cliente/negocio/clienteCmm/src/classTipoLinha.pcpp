#undef SQLCA
#define SQLCA_NONE
#include <sqlca.h>
#include <sqlda.h>

#include <tuxfw.h>
#include "../include/Exception.h"

#undef MSG_NONE
#define MSG_NONE
#include "../include/Messages.h"


EXEC SQL BEGIN DECLARE SECTION;
#include "../include/Global.h"
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE "../include/classTipoLinha.h";


CTipoLinha::CTipoLinha()
{
    memset(&tTabela, 0x00, sizeof(tTabela));
}

void CTipoLinha::setId(char *pDado)
{
    if ( pDado == NULL )
    {
        tTabela.iId_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabela.sId, pDado);
        tTabela.iId_ora = 0;
    }
}

void CTipoLinha::setSigla(char *pDado)
{
    if ( pDado == NULL )
    {
        tTabela.iSigla_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabela.sSigla, pDado);
        tTabela.iSigla_ora = 0;
    }
}

void CTipoLinha::setDescricao(char *pDado)
{
    if ( pDado == NULL )
    {
        tTabela.iDescricao_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabela.sDescricao, pDado);
        tTabela.iDescricao_ora = 0;
    }
}

void CTipoLinha::setPeso(char *pDado)
{
    if ( pDado == NULL )
    {
        tTabela.iPeso_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabela.sPeso, pDado);
        tTabela.iPeso_ora = 0;
    }
}


char* CTipoLinha::getId()
{
        return ((char*)tTabela.sId.arr);
}
char* CTipoLinha::getSigla()
{
        return ((char*)tTabela.sSigla.arr);
}
char* CTipoLinha::getDescricao()
{
        return ((char*)tTabela.sDescricao.arr);
}
char* CTipoLinha::getPeso()
{
        return ((char*)tTabela.sPeso.arr);
}

//

int CTipoLinha::Incluir()
{
    return OK;
}

int CTipoLinha::Excluir()
{
    return OK;
}


int CTipoLinha::Alterar()
{
    return OK;
}


CTipoLinha* CTipoLinha::RecuperarTodos(int* iNroObjetos)
{
    ULOG_START("CTipoLinha::RecuperarTodos()");
    
    struct sqlca sqlca;
    
    CTipoLinha* oTL = NULL;
    int iNroObjLocal = 1;

	EXEC SQL BEGIN DECLARE SECTION;
        TAPOIO_TL tSt;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL DECLARE cCursor CURSOR FOR
            SELECT idtipolinha,
                   sgtipolinha,
                   dstipolinha,
                   vlpeso
            FROM   apoio.tipolinha
            WHERE  idtipolinha > 0
            ORDER  BY UPPER(dstipolinha);

	EXEC SQL OPEN cCursor;
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;; iNroObjLocal++) 
        {
	        //limpa tSt a cada iteração	        
	        memset(&tSt, 0x00, sizeof(tSt));	
		
		EXEC SQL FETCH cCursor 
                  INTO :tSt.sId:tSt.iId_ora,
                       :tSt.sSigla:tSt.iSigla_ora,
                       :tSt.sDescricao:tSt.iDescricao_ora,
                       :tSt.sPeso:tSt.iPeso_ora;

		// Aloca memória para o objeto atual.
		if ((oTL = (CTipoLinha*) realloc((void *)oTL, (sizeof(CTipoLinha) * iNroObjLocal))) != NULL)
                {
			oTL[iNroObjLocal-1].setId((char*)tSt.sId.arr);
			oTL[iNroObjLocal-1].setSigla((char*)tSt.sSigla.arr);
			oTL[iNroObjLocal-1].setDescricao((char*)tSt.sDescricao.arr);
			oTL[iNroObjLocal-1].setPeso((char*)tSt.sPeso.arr);
		} 
       		else 
        	{
			if (oTL) free(oTL);

            		ERROR(NRO_MEMORIA);
		        EXEC SQL CLOSE cCursor;
		    ULOG_END("CTipoLinha::RecuperarTodos()");    
			throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
		}
	}

        EXEC SQL CLOSE cCursor;

	*iNroObjetos = iNroObjLocal - 1;

	ULOG_END("CTipoLinha::RecuperarTodos()");
	return oTL;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CTipoLinha::RecuperarTodos()");
		throw TuxBasicOraException(sqlca.sqlcode);
}