//* Review:
//*
//* Task force to seek potential memory leaks and exception errors - March,2005 - Cassio

#undef SQLCA
#define SQLCA_NONE
#include <sqlca.h>
#include <sqlda.h>

#include <tuxfw.h>
#include "../include/Exception.h"

#undef MSG_NONE
#define MSG_NONE
#include "../include/Messages.h"

#define strToOra(vchar,bstr)   vchar.len = strlen(bstr);strncpy((char *)vchar.arr,bstr,vchar.len);vchar.arr[vchar.len] = 0
#define endOraStr(varstr)      varstr.arr[varstr.len]= '\0'


EXEC SQL BEGIN DECLARE SECTION;
#include "../include/Global.h"
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE "../include/classPessoaLinha.h";
EXEC SQL INCLUDE "../include/BuscaDocumentoPessoa.h";

#define CONVIND(O,I) \
{\
	if (I == -1) { \
		##O.arr[0]=0; \
	} else { \
		##O.arr[##O.len]=0; \
	} \
}

//Construtor e Destrutor

CPessoaLinha::CPessoaLinha()
{
    memset(&tTabelab01, 0x00, sizeof(tTabelab01));
}

CPessoaLinha::~CPessoaLinha()
{
}


//Setters
void CPessoaLinha::setIdPessoa(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iIdPessoa_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sIdPessoa, pDado);
        tTabelab01.iIdPessoa_ora = 0;
    }
}
void CPessoaLinha::setIdPessoaDePara(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iIdPessoaDePara_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sIdPessoaDePara, pDado);
        tTabelab01.iIdPessoaDePara_ora = 0;
    }
}
void CPessoaLinha::setNmPessoa(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iNmPessoa_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sNmPessoa, pDado);
        tTabelab01.iNmPessoa_ora = 0;
    }
}
void CPessoaLinha::setIdLinhaTelefonica(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iIdLinhaTelefonica_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sIdLinhaTelefonica, pDado);
        tTabelab01.iIdLinhaTelefonica_ora = 0;
    }
}
void CPessoaLinha::setCdAreaRegistro(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iCdAreaRegistro_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sCdAreaRegistro, pDado);
        tTabelab01.iCdAreaRegistro_ora = 0;
    }
}
void CPessoaLinha::setNrLinha(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iNrLinha_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sNrLinha, pDado);
        tTabelab01.iNrLinha_ora = 0;
    }
}
void CPessoaLinha::setIdTipoLinha(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iIdTipoLinha_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sIdTipoLinha, pDado);
        tTabelab01.iIdTipoLinha_ora = 0;
    }
}
void CPessoaLinha::setDsTipoLinha(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iDsTipoLinha_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sDsTipoLinha, pDado);
        tTabelab01.iDsTipoLinha_ora = 0;
    }
}
void CPessoaLinha::setDsEstadoLinha(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iDsEstadoLinha_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sDsEstadoLinha, pDado);
        tTabelab01.iDsEstadoLinha_ora = 0;
    }
}
void CPessoaLinha::setIdTipoRelacionamento(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iIdTipoRelacionamento_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sIdTipoRelacionamento, pDado);
        tTabelab01.iIdTipoRelacionamento_ora = 0;
    }
}

void CPessoaLinha::setDtHabilitacaoOut(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iDtHabilitacaoOut_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sDtHabilitacaoOut, pDado);
        tTabelab01.iDtHabilitacaoOut_ora = 0;
    }
}

void CPessoaLinha::setInDivulgacaoNrLinha(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iInDivulgacaoNrLinha_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sInDivulgacaoNrLinha, pDado);
        tTabelab01.iInDivulgacaoNrLinha_ora = 0;
    }
}
void CPessoaLinha::setDtChurn(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iDtChurn_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sDtChurn, pDado);
        tTabelab01.iDtChurn_ora = 0;
    }
}
void CPessoaLinha::setDsTipoCarteira(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iDsTipoCarteira_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sDsTipoCarteira, pDado);
        tTabelab01.iDsTipoCarteira_ora = 0;
    }
}
void CPessoaLinha::setIdTipoCarteira(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iIdTipoCarteira_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sIdTipoCarteira, pDado);
        tTabelab01.iIdTipoCarteira_ora = 0;
    }
}
void CPessoaLinha::setSgTipoCarteira(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iSgTipoCarteira_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sSgTipoCarteira, pDado);
        tTabelab01.iSgTipoCarteira_ora = 0;
    }
}
void CPessoaLinha::setNrTelefone(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iNrTelefone_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sNrTelefone, pDado);
        tTabelab01.iNrTelefone_ora = 0;
    }
}
void CPessoaLinha::setDsTipoPessoa(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iDsTipoPessoa_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sDsTipoPessoa, pDado);
        tTabelab01.iDsTipoPessoa_ora = 0;
    }
}

void CPessoaLinha::setSgTipoPessoa(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iSgTipoPessoa_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sSgTipoPessoa, pDado);
        tTabelab01.iSgTipoPessoa_ora = 0;
    }
}

void CPessoaLinha::setNmServico(char* pDado)
{
    if ( pDado == NULL )
    {
        tTabelab01.iDsTipoPessoa_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabelab01.sNmServico, pDado);
        tTabelab01.iNmServico_ora = 0;
    }
}
void CPessoaLinha::setUltimaPagina(int nUltimaPaginaAux)
{
	tTabelab01.nUltimaPagina = nUltimaPaginaAux;
}

//Getters
char* CPessoaLinha::getIdTipoLinha(void)
{
    return((char *)tTabelab01.sIdTipoLinha.arr);
}

char* CPessoaLinha::getIdPessoa(void)
{
    return ((char*)tTabelab01.sIdPessoa.arr); 
}

char* CPessoaLinha::getDsModalidadeCartaoItau(void)
{
    return ((char*)tTabelab01.dsModalidadeCartaoItau.arr); 
}

char* CPessoaLinha::getIdPessoaDePara(void)
{
    return ((char*)tTabelab01.sIdPessoaDePara.arr);
}
char* CPessoaLinha::getIdLinhaTelefonica(void)
{
    return ((char*)tTabelab01.sIdLinhaTelefonica.arr);
}
char* CPessoaLinha::getCdAreaRegistro(void)
{
    return ((char*)tTabelab01.sCdAreaRegistro.arr);
}
char* CPessoaLinha::getNrLinha(void)
{
    return ((char*)tTabelab01.sNrLinha.arr);
}
char* CPessoaLinha::getDsTipoLinha(void)
{
    return ((char*)tTabelab01.sDsTipoLinha.arr);
}
char* CPessoaLinha::getDsEstadoLinha(void)
{
    return ((char*)tTabelab01.sDsEstadoLinha.arr);
}
char* CPessoaLinha::getDtHabilitacaoOut(void)
{
    return ((char*)tTabelab01.sDtHabilitacaoOut.arr);
}
char* CPessoaLinha::getInDivulgacaoNrLinha(void)
{
    return ((char*)tTabelab01.sInDivulgacaoNrLinha.arr);
}
char* CPessoaLinha::getDtChurn(void)
{
    return ((char*)tTabelab01.sDtChurn.arr);
}
char* CPessoaLinha::getNmPessoa(void)
{
    return ((char*)tTabelab01.sNmPessoa.arr);
}

char* CPessoaLinha::getDsTipoCarteira(void)
{
    return ((char*)tTabelab01.sDsTipoCarteira.arr);
}
char* CPessoaLinha::getIdTipoCarteira(void)
{
    return ((char*)tTabelab01.sIdTipoCarteira.arr);
}
char* CPessoaLinha::getSgTipoCarteira(void)
{
    return ((char*)tTabelab01.sSgTipoCarteira.arr);
}
char* CPessoaLinha::getNrTelefone(void)
{
    return ((char*)tTabelab01.sNrTelefone.arr);
}
char* CPessoaLinha::getDsTipoPessoa(void)
{
    return ((char*)tTabelab01.sDsTipoPessoa.arr);
}
char* CPessoaLinha::getSgTipoPessoa(void)
{
    return ((char*)tTabelab01.sSgTipoPessoa.arr);
}
char* CPessoaLinha::getDddLinhaFormatada(void)
{
    return ((char*)tTabelab01.sDddLinhaFormatada.arr);
}

char* CPessoaLinha::getNmServico(void)
{
    return((char*)tTabelab01.sNmServico.arr);
}

int CPessoaLinha::getUltimaPagina(void)
{
    return tTabelab01.nUltimaPagina;
}


// Metodos de acesso ao BD



/*
  *   Identifica atraves do Nro. da Linha (DDD+NrLinha) se o cliente é saltador.
  *   Retorno:  true -> Indica cliente saltador
  *                   false -> Nao eh cliente saltador
  *    Demanda: OS 935 - flag saltador
  *                     Março/2009
  */
/*
bool CPessoaLinha::IsClienteSaltador( char * pNrLinha )
{
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR  nrLinha[16];
        int      ctRegistros = 0;
    EXEC SQL END DECLARE SECTION;
    struct sqlca sqlca;

    try
    {
    	ULOG_START( "CPessoaLinha::IsClienteSaltador()" );

        strToOra( nrLinha, pNrLinha );
        ULOG( ">>> nrLinha [%s]",(char *)nrLinha.arr );
        EXEC SQL WHENEVER SQLERROR GOTO sqlErrorIsClienteSaltador;
        EXEC SQL
        SELECT COUNT(1) INTO :ctRegistros FROM RETENCAO.LINHASALTADOR WHERE NRLINHA = :nrLinha;
        
    	ULOG_END( "CPessoaLinha::IsClienteSaltador()" );
     sqlErrorIsClienteSaltador:
        return (ctRegistros > 0 ? true : false);
    }
    catch ( ... )
    {
        // Nenhuma acao a ser tomada.
        
        ULOG_END( "*** ERRO: CPessoaLinha::IsClienteSaltador()" );
        return false;
    }
}
*/


int CPessoaLinha::getBlindagem(char* pnrTelefone)
{
    ULOG_START("CPessoaLinha::getBlindagem()");

	   struct sqlca sqlca;
		EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR szNrTelefone[16];
		int		isBlindagem=0;
	EXEC SQL END DECLARE SECTION;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorgetBlindagem;

	strToOra(szNrTelefone,pnrTelefone);

	EXEC SQL
		SELECT COUNT(1)
		into :isBlindagem
		FROM   RETENCAO.CLIENTEBLINDAGEM
		WHERE cdarearegistro=SUBSTR(:szNrTelefone,1,2)
		AND	 nrlinha =SUBSTR(:szNrTelefone,3)
		AND (TO_CHAR(DTBLOQUEIOEXIBICAO,'DD/MM/YYYY')<TO_CHAR(SYSDATE,'DD/MM/YYYY') 
			 OR DTBLOQUEIOEXIBICAO IS NULL)
		and  dtaceite is null;
	
	ULOG_END("CPessoaLinha::getBlindagem()");
	
	//pog para garantia de retorno
	return (isBlindagem>=1?1:0);

	sqlErrorgetBlindagem:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CPessoaLinha::getBlindagem()");
		//throw TuxBasicOraException(sqlca.sqlcode);
	return isBlindagem;
}

CPessoaLinha* CPessoaLinha::RecuperarTodosB01(int* iNroObjetos, char* pId, char* pTipo, char* pEstado)
{
    ULOG_START("CPessoaLinha::RecuperarTodosB01()");
    struct sqlca sqlca;
    CPessoaLinha* oPL = NULL;
    int iNroObjLocal = 1;

	EXEC SQL BEGIN DECLARE SECTION;
        TTABELA_01 tSt;
        VARCHAR sId[LEN_NUMBER+LEN_EOS];
        VARCHAR sTipo[LEN_DSTIPOLINHA+LEN_EOS];
        VARCHAR sEstado[LEN_DSESTADOLINHA+LEN_EOS];
	EXEC SQL END DECLARE SECTION;


    memset(&tSt, 0x00, sizeof(tSt));

    STRCPY_TO_ORA(sId, pId);

    if (!pTipo || !*pTipo){
        STRCPY_TO_ORA(sTipo, "0");
    }
    else{
        STRCPY_TO_ORA(sTipo, pTipo);
    }

    if (!pEstado || !*pEstado){
        STRCPY_TO_ORA(sEstado, "0");
    }
    else{
        STRCPY_TO_ORA(sEstado, pEstado);
    }

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL DECLARE cCursor CURSOR FOR
	SELECT 
	     PESSOA.IDPESSOA
	    ,LINHATELEFONICA.IDLINHATELEFONICA
	    ,AREAREGISTRO.CDAREAREGISTRO
	    ,LINHABASE.NRLINHA
	    ,TIPOLINHA.DSTIPOLINHA
	    ,ESTADOLINHA.DSESTADOLINHA
	    ,TO_CHAR(LINHATELEFONICA.DTHABILITACAO, 'DD/MM/YYYY' ) AS DTHABILITACAO
	    ,LINHATELEFONICA.INDIVULGACAONRLINHA
	    ,PESSOA.NMPESSOA
	FROM 
	    CUSTOMER.PESSOA PESSOA,
	    CUSTOMER.PESSOADEPARA PESSOADEPARA,
	    CUSTOMER.PESSOALINHA PESSOALINHA,
	    CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTO,
	    LINHA.LINHATELEFONICA LINHATELEFONICA,
	    LINHA.LINHABASE LINHABASE,
	    APOIO.AREAREGISTRO AREAREGISTRO,
	    APOIO.ESTADOLINHA ESTADOLINHA,
	    APOIO.TIPOLINHA TIPOLINHA
	WHERE PESSOA.IDPESSOA = PESSOADEPARA.IDPESSOA
	AND   PESSOADEPARA.IDPESSOADEPARA = PESSOALINHA.IDPESSOADEPARA
	AND   PESSOALINHA.IDTIPORELACIONAMENTO = TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
	AND   PESSOALINHA.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
	AND   LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
	AND   LINHATELEFONICA.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
	AND   LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
	AND   LINHABASE.IDESTADOLINHA = ESTADOLINHA.IDESTADOLINHA
	AND   TIPORELACIONAMENTO.SGTIPORELACIONAMENTO = 'C'
	AND   (ESTADOLINHA.DSESTADOLINHA = :sEstado OR 0 = :sEstado)
	AND   (TIPOLINHA.DSTIPOLINHA = :sTipo OR 0 = :sTipo)
	AND   PESSOADEPARA.IDPESSOA = :sId;

	EXEC SQL OPEN cCursor;
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;; iNroObjLocal++) 
    {
		EXEC SQL FETCH cCursor 
                  INTO  :tSt.sIdPessoa:tSt.iIdPessoa_ora
                       ,:tSt.sIdLinhaTelefonica:tSt.iIdLinhaTelefonica_ora
                       ,:tSt.sCdAreaRegistro:tSt.iCdAreaRegistro_ora
                       ,:tSt.sNrLinha:tSt.iNrLinha_ora
                       ,:tSt.sDsTipoLinha:tSt.iDsTipoLinha_ora
                       ,:tSt.sDsEstadoLinha:tSt.iDsEstadoLinha_ora
                       ,:tSt.sDtHabilitacaoOut:tSt.iDtHabilitacaoOut_ora
                       ,:tSt.sInDivulgacaoNrLinha:tSt.iInDivulgacaoNrLinha_ora
					   ,:tSt.sNmPessoa:tSt.iNmPessoa_ora;

		// Aloca memória para o objeto atual.
		if ((oPL = (CPessoaLinha*) realloc((void *)oPL, (sizeof(CPessoaLinha) * iNroObjLocal))) != NULL)
        {
            int index = iNroObjLocal-1;
			oPL[index].setIdPessoa((char*)tSt.sIdPessoa.arr);
			oPL[index].setIdLinhaTelefonica((char*)tSt.sIdLinhaTelefonica.arr);
			oPL[index].setCdAreaRegistro((char*)tSt.sCdAreaRegistro.arr);
			oPL[index].setNrLinha((char*)tSt.sNrLinha.arr);
			oPL[index].setDsTipoLinha((char*)tSt.sDsTipoLinha.arr);
			oPL[index].setDsEstadoLinha((char*)tSt.sDsEstadoLinha.arr);
			oPL[index].setDtHabilitacaoOut((char*)tSt.sDtHabilitacaoOut.arr);
			oPL[index].setInDivulgacaoNrLinha((char*)tSt.sInDivulgacaoNrLinha.arr);
			oPL[index].setNmPessoa((char*)tSt.sNmPessoa.arr);
		} 
        else 
        {
			if (oPL) 
                free(oPL);

            ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
            EXEC SQL CLOSE cCursor;
            ULOG_END("CPessoaLinha::RecuperarTodosB01()");
			throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
		}
	}

    EXEC SQL CLOSE cCursor;

	*iNroObjetos = iNroObjLocal - 1;
    ULOG_END("CPessoaLinha::RecuperarTodosB01()");
	return oPL;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CPessoaLinha::RecuperarTodosB01()");
		throw TuxBasicOraException(sqlca.sqlcode);
}


CPessoaLinha* CPessoaLinha::buscarPorIdPessoa(int* iNroObjetos, char* pId)
{
    ULOG_START("CPessoaLinha::buscarPorIdPessoa()");
    struct sqlca sqlca;
    CPessoaLinha* oPL = NULL;
    int iNroObjLocal = 1;
    
	EXEC SQL BEGIN DECLARE SECTION;
        TTABELA_01 tSt;
        VARCHAR sId[LEN_NUMBER+LEN_EOS];
	EXEC SQL END DECLARE SECTION;

    STRCPY_TO_ORA(sId, pId);

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL 
	DECLARE 
		cC2 CURSOR FOR
           SELECT
                NRLINHA,
                IDTIPOLINHA
            FROM
                LINHA.TIPOLINHAV01 
            WHERE IDPESSOA = :sId;


	EXEC SQL OPEN cC2;
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;;) 
    {
        memset(&tSt, 0x00, sizeof(tSt));
		EXEC SQL FETCH cC2
                  INTO :tSt.sNrLinha:tSt.iNrLinha_ora,
			           :tSt.sIdTipoLinha:tSt.iIdTipoLinha_ora;

		// Aloca memória para o objeto atual.
		if( tSt.sNrLinha.len > 0 )
		{
			if ((oPL = (CPessoaLinha*) realloc((void *)oPL, (sizeof(CPessoaLinha) * iNroObjLocal))) != NULL)
	        {
				if(tSt.iNrLinha_ora>=0)
					oPL[iNroObjLocal-1].setNrLinha((char*)tSt.sNrLinha.arr);
				else
					oPL[iNroObjLocal-1].setNrLinha("");
					
				if(tSt.iIdTipoLinha_ora>=0)
					oPL[iNroObjLocal-1].setIdTipoLinha((char*)tSt.sIdTipoLinha.arr);
				else
					oPL[iNroObjLocal-1].setIdTipoLinha("");
					
				iNroObjLocal++;
			}
	        else 
	        {
				if (oPL) 
	                free(oPL);
	
	            ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
	            EXEC SQL CLOSE cC2;
	            ULOG_END("CPessoaLinha::buscarPorIdPessoa()");
				throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
			}
		}
	}

    EXEC SQL CLOSE cC2;

	*iNroObjetos = iNroObjLocal - 1;

	ULOG_END("CPessoaLinha::buscarPorIdPessoa()");
	return oPL;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaLinha::buscarPorIdPessoa()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

CPessoaLinha* CPessoaLinha::buscarPorNrConta(int* iNroObjetos, char* pId, char* cpageNumber)
{
    ULOG_START("CPessoaLinha::buscarPorNrConta()");
    struct sqlca sqlca;
    CPessoaLinha* oPL = NULL;
    int iNroObjLocal = 0;
    int ipageNumber = atoi( cpageNumber );
    int iTotalLinhasPorPaginas = CBuscaDocumentoPessoa::getTotalLinhasPorPagina();

	EXEC SQL BEGIN DECLARE SECTION;
		int iPaginaIni = (ipageNumber-1) * iTotalLinhasPorPaginas;
		int iPaginaFim = iTotalLinhasPorPaginas + ((ipageNumber-1) * iTotalLinhasPorPaginas);
        TTABELA_01 tSt;
        VARCHAR sId[LEN_NUMBER+LEN_EOS];
        
        long idConta;
        short i_idConta = -1;
	EXEC SQL END DECLARE SECTION;

    STRCPY_TO_ORA(sId, pId);

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	ULOG( "CDCONTA[%s]", pId );
	ULOG( "pageNumber[%s]", cpageNumber );
   	ULOG("iPaginaIni[%d] iPaginaFim[%d]", iPaginaIni, iPaginaFim );

	// Declara e abre o cursor
/*
	EXEC SQL DECLARE CursorbuscarPorNrConta CURSOR FOR
	SELECT
	    NRLINHA,
	    IDTIPOLINHA,
	    CDCONTA
	FROM
	(
		SELECT
		    NRLINHA,
		    IDTIPOLINHA,
		    CDCONTA,
			ROWNUM AS LINHA
		FROM
		(
			SELECT DISTINCT 
			    (AREAREGISTRO.CDAREAREGISTRO || LINHABASE.NRLINHA) AS NRLINHA,
			    LINHATELEFONICA.IDTIPOLINHA,
			    CDCONTA
			FROM 
			    CUSTOMER.CONTA CONTA,
			    CUSTOMER.LINHACONTA LINHACONTA,
			    LINHA.LINHATELEFONICA LINHATELEFONICA,
			    LINHA.LINHABASE LINHABASE,
			    APOIO.AREAREGISTRO AREAREGISTRO
			WHERE 
			    CONTA.IDCONTA = LINHACONTA.IDCONTA
			AND
			    LINHACONTA.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
			AND
			    LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
			AND
			    LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
			AND 
			    CONTA.CDCONTA = :sId
		)
		WHERE
			ROWNUM <= :iPaginaFim+1
	)
	WHERE
		LINHA > :iPaginaIni;
*/

   EXEC SQL WHENEVER NOT FOUND CONTINUE;
   EXEC SQL
   select CONTA.IDCONTA INTO :idConta:i_idConta from CUSTOMER.CONTA CONTA where CONTA.CDCONTA = :sId;
   if ( i_idConta == -1 )
   {
      idConta = 0;
   }
   
   EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL DECLARE CursorbuscarPorNrConta CURSOR FOR
	SELECT
	    NRLINHA,
	    IDTIPOLINHA
	FROM
	(
		SELECT
		    NRLINHA,
		    IDTIPOLINHA,
			  ROWNUM AS LINHA
		FROM
		(
            SELECT 
                (AREAREGISTRO.CDAREAREGISTRO || LINHABASE.NRLINHA) AS NRLINHA,
                lc.IDTIPOLINHA 
            FROM 
                LINHA.LINHABASE LINHABASE,
                APOIO.AREAREGISTRO AREAREGISTRO,
                (
                   SELECT 
                      LINHACONTA.IDLINHATELEFONICA,  
                      LINHATELEFONICA.IDTIPOLINHA,  
                      LINHATELEFONICA.idlinhabase 
                   FROM 
                     CUSTOMER.LINHACONTA LINHACONTA,  
                     LINHA.LINHATELEFONICA LINHATELEFONICA 
                   WHERE 
                      LINHACONTA.IDCONTA = :idConta 
                   AND LINHATELEFONICA.IDLINHATELEFONICA = LINHACONTA.IDLINHATELEFONICA 
                ) lc
            WHERE
                lc.IDLINHABASE = LINHABASE.IDLINHABASE
            AND
                LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
		)
		WHERE
			ROWNUM <= :iPaginaFim+1
	)
	WHERE
		LINHA > :iPaginaIni;

	EXEC SQL OPEN CursorbuscarPorNrConta;
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;;) 
    {
        memset(&tSt, 0x00, sizeof(tSt));
		EXEC SQL FETCH CursorbuscarPorNrConta
                  INTO :tSt.sNrLinha:tSt.iNrLinha_ora,
			           :tSt.sIdTipoLinha:tSt.iIdTipoLinha_ora;

		if( iNroObjLocal == iTotalLinhasPorPaginas )
		{
			iNroObjLocal++;
			break;
		}
		// Aloca memória para o objeto atual.
		if ((oPL = (CPessoaLinha*) realloc((void *)oPL, (sizeof(CPessoaLinha) * (iNroObjLocal+1)))) != NULL)
        {
			if(tSt.iNrLinha_ora>=0)
				oPL[iNroObjLocal].setNrLinha((char*)tSt.sNrLinha.arr);
			if(tSt.iIdTipoLinha_ora>=0)
				oPL[iNroObjLocal].setIdTipoLinha((char*)tSt.sIdTipoLinha.arr);

			iNroObjLocal++;

		} 
        else 
        {
			if (oPL) 
                free(oPL);

            ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
            EXEC SQL CLOSE CursorbuscarPorNrConta;
            ULOG_END("CPessoaLinha::buscarPorNrConta()");
			throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
		}
	}

    EXEC SQL CLOSE CursorbuscarPorNrConta;

	//Verifica se eh ou nao a ultima pagina
	if( oPL != NULL )
	{
	    ULOG("Gravando o LOG iNroObjLocal[%d] > iTotalLinhasPorPaginas[%d]", iNroObjLocal, iTotalLinhasPorPaginas);
		if( iNroObjLocal > iTotalLinhasPorPaginas )
		{
			oPL[0].setUltimaPagina(0);
			iNroObjLocal--;//Como contou um a mais para saber que eh ultima pagina, tem que tirar este um.
		}
		else
			oPL[0].setUltimaPagina(1);
	}

	*iNroObjetos = iNroObjLocal;

	ULOG_END("CPessoaLinha::buscarPorNrConta()");
	return oPL;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaLinha::buscarPorNrConta()");
		throw TuxBasicOraException(sqlca.sqlcode);
}



int  CPessoaLinha::buscarDadosClientePorIdLinhaTelefonica(char* pidLinhaTelefonica)
{
    ULOG_START("CPessoaLinha::buscarDadosClientePorIdLinhaTelefonica()");
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cOraIdLinhaTelefonica[LEN_IDLINHATELEFONICA + LEN_EOS];
	EXEC SQL END DECLARE SECTION;

	STRCPY_TO_ORA(cOraIdLinhaTelefonica, pidLinhaTelefonica);

	// Marca ponto de controle de erro
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Busca os dados principais
	EXEC SQL
	SELECT
	     PESSOA.IDPESSOA
	    ,PESSOADEPARA.IDPESSOADEPARA
	    ,LINHATELEFONICA.IDLINHATELEFONICA
	    ,SUBSTR(PESSOA.NMPESSOA,1,80)
	    ,(AREAREGISTRO.CDAREAREGISTRO||LINHABASE.NRLINHA) AS NRLINHA
	    ,AREAREGISTRO.CDAREAREGISTRO
	    /* ,'(' ||AREAREGISTRO.CDAREAREGISTRO||')' || SUBSTR(LINHABASE.NRLINHA, 1, 5) || '-' || SUBSTR(LINHABASE.NRLINHA, 6, 4) AS NRLINHAFORMATADA */
        ,soa_ow.formata_nrlinha(TO_CHAR(AREAREGISTRO.CDAREAREGISTRO)||to_char(LINHABASE.NRLINHA)) AS NRLINHAFORMATADA
        ,TIPOPESSOA.DSTIPOPESSOA
        ,TIPOPESSOA.SGTIPOPESSOA
	    ,PROBABILIDADE.DSPROBABILIDADE
	    ,TO_CHAR(LINHATELEFONICA.DTHABILITACAO, 'DD/MM/YYYY' ) AS DTHABILITACAO
		,(CASE
			WHEN linhatelefonica.cdfixomovel = 'N' THEN
				'LD NÃO VIVO'
			ELSE
				SUBSTR(TIPOLINHA.DSTIPOLINHA, 1, 18)||decode(linhatelefonica.cdfixomovel,'F',' FIXO',NULL)
			END
		)	 AS DSTIPOLINHA
	    ,TIPOLINHA.IDTIPOLINHA
        ,decode (reason.SBSCRP_ID,null,(SUBSTR((ESTADOLINHA.DSESTADOLINHA || ' ' || LINHABASE.DSMOTIVOESTADO), 1, 25)),'Bloqueio Pré-Ativação')
		,LINHATELEFONICA.INDIVULGACAONRLINHA
	    ,TIPOCARTEIRA.DSTIPOCARTEIRA
	    ,TIPOCARTEIRA.IDTIPOCARTEIRA
	    ,TIPOCARTEIRA.SGTIPOCARTEIRA
	INTO
		:tTabelab01.sIdPessoa:tTabelab01.iIdPessoa_ora,
		:tTabelab01.sIdPessoaDePara:tTabelab01.iIdPessoaDePara_ora,
		:tTabelab01.sIdLinhaTelefonica:tTabelab01.iIdLinhaTelefonica_ora,
		:tTabelab01.sNmPessoa:tTabelab01.iNmPessoa_ora,
		:tTabelab01.sNrLinha:tTabelab01.iNrLinha_ora,
		:tTabelab01.sCdAreaRegistro:tTabelab01.iCdAreaRegistro_ora,
		:tTabelab01.sDddLinhaFormatada,
		:tTabelab01.sDsTipoPessoa:tTabelab01.iDsTipoPessoa_ora,
		:tTabelab01.sSgTipoPessoa:tTabelab01.iSgTipoPessoa_ora,
		:tTabelab01.sDtChurn:tTabelab01.iDtChurn_ora,
		:tTabelab01.sDtHabilitacaoOut:tTabelab01.iDtHabilitacaoOut_ora,
		:tTabelab01.sDsTipoLinha:tTabelab01.iDsTipoLinha_ora,
		:tTabelab01.sIdTipoLinha:tTabelab01.iIdTipoLinha_ora,
		:tTabelab01.sDsEstadoLinha:tTabelab01.iDsEstadoLinha_ora,
		:tTabelab01.sInDivulgacaoNrLinha:tTabelab01.iInDivulgacaoNrLinha_ora,
		:tTabelab01.sDsTipoCarteira:tTabelab01.iDsTipoCarteira_ora,
		:tTabelab01.sIdTipoCarteira:tTabelab01.iIdTipoCarteira_ora,
		:tTabelab01.sSgTipoCarteira:tTabelab01.iSgTipoCarteira_ora
	FROM
        CUSTOMER.PESSOA PESSOA,
        CUSTOMER.PESSOADEPARA PESSOADEPARA,
        CUSTOMER.PESSOALINHA PESSOALINHA,
        CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTO,
        LINHA.LINHATELEFONICA LINHATELEFONICA,
        linha.ACCESS_NBR_HOTLN_REASON REASON,
        LINHA.LINHABASE LINHABASE,
        APOIO.AREAREGISTRO AREAREGISTRO,
        APOIO.ESTADOLINHA ESTADOLINHA,
        APOIO.TIPOLINHA TIPOLINHA,
        APOIO.TIPOCARTEIRA TIPOCARTEIRA,
        APOIO.PROBABILIDADE PROBABILIDADE,
        APOIO.TIPOPESSOA TIPOPESSOA
    WHERE PESSOA.IDPESSOA = PESSOADEPARA.IDPESSOA
    AND   PESSOA.IDTIPOPESSOA = TIPOPESSOA.IDTIPOPESSOA
    AND   PESSOA.IDTIPOCARTEIRA = TIPOCARTEIRA.IDTIPOCARTEIRA
    AND   PESSOA.IDCHURNPROBABILIDADE = PROBABILIDADE.IDPROBABILIDADE
    AND   PESSOADEPARA.IDPESSOADEPARA = PESSOALINHA.IDPESSOADEPARA
    AND   PESSOALINHA.IDTIPORELACIONAMENTO = TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
    AND   PESSOALINHA.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA

    AND   LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
    AND   LINHATELEFONICA.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
    AND   LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
    AND   LINHABASE.IDESTADOLINHA = ESTADOLINHA.IDESTADOLINHA

    AND   TIPORELACIONAMENTO.SGTIPORELACIONAMENTO = 'C'
    AND   LINHATELEFONICA.IDLINHATELEFONICA = :cOraIdLinhaTelefonica
    AND   LINHATELEFONICA.IDLINHASISTEMAORIGEM=REASON.SBSCRP_ID(+)
    and   REASON.HOTLN_REASON_CD(+) = 'PRE ACTIVATION'
    AND   ROWNUM < 2;

    if ( sqlca.sqlcode )
    {
        ULOG_END("CPessoaLinha::buscarDadosClientePorIdLinhaTelefonica() -- NOT FOUND");
        return NOK;
    }

    ULOG("Depois do Select com os dados principais");

    // Busca o numero de telefone residencial
    //           AND tipocomunicacao.sgtipocomunicacao  in ('CELULAR', 'TEL COM', 'TEL REC', 'TEL RES', 'HM', 'WK', 'BS', 'BC')

	EXEC SQL
	SELECT
		PESSOACOMUNICACAO.
		DSCONTATO
	INTO
		:tTabelab01.sNrTelefone
		:tTabelab01.iNrTelefone_ora
	FROM
		CUSTOMER.PESSOACOMUNICACAO
	   ,APOIO.TIPOCOMUNICACAO
	WHERE TIPOCOMUNICACAO.IDTIPOCOMUNICACAO = PESSOACOMUNICACAO.IDTIPOCOMUNICACAO
	AND   UPPER(TIPOCOMUNICACAO.SGCLASSIFICACAO) IN ('SMS', 'TELEFONE')
	AND   IDPESSOA = :tTabelab01.sIdPessoa
	AND   ROWNUM = 1;


    ULOG_END("CPessoaLinha::buscarDadosClientePorNrLinha()");
    return OK;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaLinha::buscarDadosClientePorNrLinha()");
		throw TuxBasicOraException(sqlca.sqlcode);
}


int  CPessoaLinha::buscarDadosProspectPorIdLinhaTelefonica(char* pidLinhaTelefonica)
{
    ULOG_START("CPessoaLinha::buscarDadosProspectPorIdLinhaTelefonica()");
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cOraIdLinhaTelefonica[LEN_IDLINHATELEFONICA + LEN_EOS];
	EXEC SQL END DECLARE SECTION;

	STRCPY_TO_ORA(cOraIdLinhaTelefonica, pidLinhaTelefonica);

	// Marca ponto de controle de erro
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Busca os dados principais
	EXEC SQL
		SELECT
			 PESSOA.IDPESSOA
			,PESSOADEPARA.IDPESSOADEPARA
			,LINHATELEFONICA.IDLINHATELEFONICA
			,SUBSTR(PESSOA.NMPESSOA,1,80) AS NMPESSOA
			,(PESSOA.CDAREAREGISTROPROSPECT||PESSOA.NRLINHAPROSPECT) AS NRLINHA
			,PESSOA.CDAREAREGISTROPROSPECT
			,soa_ow.formata_nrlinha(TO_CHAR(PESSOA.CDAREAREGISTROPROSPECT||PESSOA.NRLINHAPROSPECT)) AS NRLINHAFORMATADA
			,TIPOPESSOA.DSTIPOPESSOA
			,TIPOPESSOA.SGTIPOPESSOA
			,PROBABILIDADE.DSPROBABILIDADE
			,TO_CHAR(LINHATELEFONICA.DTHABILITACAO, 'DD/MM/YYYY' ) AS DTHABILITACAO
			,SUBSTR(TIPOLINHA.DSTIPOLINHA, 1, 18) AS DSTIPOLINHA
			,TIPOLINHA.IDTIPOLINHA
			,'NÃO CLASSIFICADO' AS DSESTADOLINHA
			,LINHATELEFONICA.INDIVULGACAONRLINHA
			,TIPOCARTEIRA.DSTIPOCARTEIRA
			,TIPOCARTEIRA.IDTIPOCARTEIRA
			,TIPOCARTEIRA.SGTIPOCARTEIRA
		INTO
			:tTabelab01.sIdPessoa:tTabelab01.iIdPessoa_ora,
			:tTabelab01.sIdPessoaDePara:tTabelab01.iIdPessoaDePara_ora,
			:tTabelab01.sIdLinhaTelefonica:tTabelab01.iIdLinhaTelefonica_ora,
			:tTabelab01.sNmPessoa:tTabelab01.iNmPessoa_ora,
			:tTabelab01.sNrLinha:tTabelab01.iNrLinha_ora,
			:tTabelab01.sCdAreaRegistro:tTabelab01.iCdAreaRegistro_ora,
			:tTabelab01.sDddLinhaFormatada,
			:tTabelab01.sDsTipoPessoa:tTabelab01.iDsTipoPessoa_ora,
			:tTabelab01.sSgTipoPessoa:tTabelab01.iSgTipoPessoa_ora,
			:tTabelab01.sDtChurn:tTabelab01.iDtChurn_ora,
			:tTabelab01.sDtHabilitacaoOut:tTabelab01.iDtHabilitacaoOut_ora,
			:tTabelab01.sDsTipoLinha:tTabelab01.iDsTipoLinha_ora,
			:tTabelab01.sIdTipoLinha:tTabelab01.iIdTipoLinha_ora,
			:tTabelab01.sDsEstadoLinha:tTabelab01.iDsEstadoLinha_ora,
			:tTabelab01.sInDivulgacaoNrLinha:tTabelab01.iInDivulgacaoNrLinha_ora,
			:tTabelab01.sDsTipoCarteira:tTabelab01.iDsTipoCarteira_ora,
			:tTabelab01.sIdTipoCarteira:tTabelab01.iIdTipoCarteira_ora,
			:tTabelab01.sSgTipoCarteira:tTabelab01.iSgTipoCarteira_ora
		FROM
			CUSTOMER.PESSOA PESSOA,
			CUSTOMER.PESSOADEPARA PESSOADEPARA,
			LINHA.LINHATELEFONICA LINHATELEFONICA,
			APOIO.TIPOLINHA TIPOLINHA,
			APOIO.TIPOCARTEIRA TIPOCARTEIRA,
			APOIO.PROBABILIDADE PROBABILIDADE,
			APOIO.TIPOPESSOA TIPOPESSOA
		WHERE PESSOA.IDPESSOA = PESSOADEPARA.IDPESSOA
		AND   PESSOA.IDTIPOPESSOA = TIPOPESSOA.IDTIPOPESSOA
		AND   PESSOA.IDTIPOCARTEIRA = TIPOCARTEIRA.IDTIPOCARTEIRA
		AND   PESSOA.IDCHURNPROBABILIDADE = PROBABILIDADE.IDPROBABILIDADE
		AND   LINHATELEFONICA.IDLINHATELEFONICA = :cOraIdLinhaTelefonica
		AND   LINHATELEFONICA.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
		AND   ROWNUM < 2;

    ULOG("Depois do Select com os dados principais");

    // Busca o numero de telefone residencial
    //           AND tipocomunicacao.sgtipocomunicacao  in ('CELULAR', 'TEL COM', 'TEL REC', 'TEL RES', 'HM', 'WK', 'BS', 'BC')

	EXEC SQL
	SELECT
		PESSOACOMUNICACAO.
		DSCONTATO
	INTO
		:tTabelab01.sNrTelefone
		:tTabelab01.iNrTelefone_ora
	FROM
		CUSTOMER.PESSOACOMUNICACAO
	   ,APOIO.TIPOCOMUNICACAO
	WHERE TIPOCOMUNICACAO.IDTIPOCOMUNICACAO = PESSOACOMUNICACAO.IDTIPOCOMUNICACAO
	AND UPPER(TIPOCOMUNICACAO.SGCLASSIFICACAO) IN ('SMS', 'TELEFONE')
	AND IDPESSOA = :tTabelab01.sIdPessoa
	AND ROWNUM = 1;

    ULOG_END("CPessoaLinha::buscarDadosProspectPorIdLinhaTelefonica()");
    return OK;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaLinha::buscarDadosProspectPorIdLinhaTelefonica()");
		throw TuxBasicOraException(sqlca.sqlcode);
}



int CPessoaLinha::buscarDadosClientePorNrLinha(char* pNrLin)
{
    ULOG_START("CPessoaLinha::buscarDadosClientePorNrLinha()");
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	    char cOraDDD[3];
	    char cOraFone[16];
	EXEC SQL END DECLARE SECTION;

	strncpy(cOraDDD, pNrLin, 2);
	cOraDDD[2]='\0';
   /*
	strncpy(cOraFone, pNrLin+2, 8);
	cOraFone[8]='\0';
   */
   
   sprintf( cOraFone, "%s", (char*)&pNrLin[2]);
   

	// Marca ponto de controle de erro
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Busca os dados principais
	EXEC SQL 
	SELECT 
	     PESSOA.IDPESSOA
	    ,PESSOADEPARA.IDPESSOADEPARA
	    ,LINHATELEFONICA.IDLINHATELEFONICA
	    ,SUBSTR(PESSOA.NMPESSOA,1,80)
	    ,(AREAREGISTRO.CDAREAREGISTRO||LINHABASE.NRLINHA) AS NRLINHA
	    ,AREAREGISTRO.CDAREAREGISTRO
	    /* ,'(' ||AREAREGISTRO.CDAREAREGISTRO||')' || SUBSTR(LINHABASE.NRLINHA, 1, 5) || '-' || SUBSTR(LINHABASE.NRLINHA, 6, 4) AS NRLINHAFORMATADA */
        ,soa_ow.formata_nrlinha(TO_CHAR(AREAREGISTRO.CDAREAREGISTRO)||to_char(LINHABASE.NRLINHA)) AS NRLINHAFORMATADA
        ,TIPOPESSOA.DSTIPOPESSOA
        ,TIPOPESSOA.SGTIPOPESSOA
	    ,PROBABILIDADE.DSPROBABILIDADE
	    ,TO_CHAR(LINHATELEFONICA.DTHABILITACAO, 'DD/MM/YYYY' ) AS DTHABILITACAO
		,(CASE 
			WHEN linhatelefonica.cdfixomovel = 'N' THEN
				'LD NÃO VIVO'
			ELSE
				SUBSTR(TIPOLINHA.DSTIPOLINHA, 1, 18)||decode(linhatelefonica.cdfixomovel,'F',' FIXO',NULL)
			END
		)	 AS DSTIPOLINHA
	    ,TIPOLINHA.IDTIPOLINHA
        ,decode (reason.SBSCRP_ID,null,(SUBSTR((ESTADOLINHA.DSESTADOLINHA || ' ' || LINHABASE.DSMOTIVOESTADO), 1, 25)),'Bloqueio Pré-Ativação')
		,LINHATELEFONICA.INDIVULGACAONRLINHA
	    ,TIPOCARTEIRA.DSTIPOCARTEIRA
	    ,TIPOCARTEIRA.IDTIPOCARTEIRA
	    ,TIPOCARTEIRA.SGTIPOCARTEIRA
	INTO 
		:tTabelab01.sIdPessoa:tTabelab01.iIdPessoa_ora,
		:tTabelab01.sIdPessoaDePara:tTabelab01.iIdPessoaDePara_ora,
		:tTabelab01.sIdLinhaTelefonica:tTabelab01.iIdLinhaTelefonica_ora,
		:tTabelab01.sNmPessoa:tTabelab01.iNmPessoa_ora,
		:tTabelab01.sNrLinha:tTabelab01.iNrLinha_ora,
		:tTabelab01.sCdAreaRegistro:tTabelab01.iCdAreaRegistro_ora,
		:tTabelab01.sDddLinhaFormatada,
		:tTabelab01.sDsTipoPessoa:tTabelab01.iDsTipoPessoa_ora,
		:tTabelab01.sSgTipoPessoa:tTabelab01.iSgTipoPessoa_ora,
		:tTabelab01.sDtChurn:tTabelab01.iDtChurn_ora,
		:tTabelab01.sDtHabilitacaoOut:tTabelab01.iDtHabilitacaoOut_ora,
		:tTabelab01.sDsTipoLinha:tTabelab01.iDsTipoLinha_ora,
		:tTabelab01.sIdTipoLinha:tTabelab01.iIdTipoLinha_ora,
		:tTabelab01.sDsEstadoLinha:tTabelab01.iDsEstadoLinha_ora,
		:tTabelab01.sInDivulgacaoNrLinha:tTabelab01.iInDivulgacaoNrLinha_ora,
		:tTabelab01.sDsTipoCarteira:tTabelab01.iDsTipoCarteira_ora,
		:tTabelab01.sIdTipoCarteira:tTabelab01.iIdTipoCarteira_ora,
		:tTabelab01.sSgTipoCarteira:tTabelab01.iSgTipoCarteira_ora
	FROM 
        CUSTOMER.PESSOA PESSOA,
        CUSTOMER.PESSOADEPARA PESSOADEPARA,
        CUSTOMER.PESSOALINHA PESSOALINHA,
        CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTO,
        LINHA.LINHATELEFONICA LINHATELEFONICA,
        linha.ACCESS_NBR_HOTLN_REASON REASON,
        LINHA.LINHABASE LINHABASE,
        APOIO.AREAREGISTRO AREAREGISTRO,
        APOIO.ESTADOLINHA ESTADOLINHA,
        APOIO.TIPOLINHA TIPOLINHA,
        APOIO.TIPOCARTEIRA TIPOCARTEIRA,
        APOIO.PROBABILIDADE PROBABILIDADE,
        APOIO.TIPOPESSOA TIPOPESSOA
    WHERE PESSOA.IDPESSOA = PESSOADEPARA.IDPESSOA
    AND   PESSOA.IDTIPOPESSOA = TIPOPESSOA.IDTIPOPESSOA
    AND   PESSOA.IDTIPOCARTEIRA = TIPOCARTEIRA.IDTIPOCARTEIRA
    AND   PESSOA.IDCHURNPROBABILIDADE = PROBABILIDADE.IDPROBABILIDADE
    AND   PESSOADEPARA.IDPESSOADEPARA = PESSOALINHA.IDPESSOADEPARA
    AND   PESSOALINHA.IDTIPORELACIONAMENTO = TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
    AND   PESSOALINHA.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
    AND   LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
    AND   LINHATELEFONICA.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
    AND   LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
    AND   LINHABASE.IDESTADOLINHA = ESTADOLINHA.IDESTADOLINHA
    AND   TIPORELACIONAMENTO.SGTIPORELACIONAMENTO = 'C'
    AND   LINHABASE.NRLINHA = :cOraFone
    AND   AREAREGISTRO.CDAREAREGISTRO = :cOraDDD
    AND   LINHATELEFONICA.IDLINHASISTEMAORIGEM=REASON.SBSCRP_ID(+)
    and   REASON.HOTLN_REASON_CD(+) = 'PRE ACTIVATION'
    AND   ROWNUM < 2;

    if ( sqlca.sqlcode )
    {
        ULOG_END("CPessoaLinha::buscarDadosClientePorNrLinha() -- NOT FOUND");
        return NOK;
    }

    ULOG("Depois do Select com os dados principais");

    // Busca o numero de telefone residencial
    //           AND tipocomunicacao.sgtipocomunicacao  in ('CELULAR', 'TEL COM', 'TEL REC', 'TEL RES', 'HM', 'WK', 'BS', 'BC')

	EXEC SQL 
	SELECT 
		PESSOACOMUNICACAO.
		DSCONTATO
	INTO 
		:tTabelab01.sNrTelefone
		:tTabelab01.iNrTelefone_ora
	FROM 
		CUSTOMER.PESSOACOMUNICACAO
	   ,APOIO.TIPOCOMUNICACAO
	WHERE TIPOCOMUNICACAO.IDTIPOCOMUNICACAO = PESSOACOMUNICACAO.IDTIPOCOMUNICACAO
	AND   UPPER(TIPOCOMUNICACAO.SGCLASSIFICACAO) IN ('SMS', 'TELEFONE')
	AND   IDPESSOA = :tTabelab01.sIdPessoa
	AND   ROWNUM = 1;


    ULOG_END("CPessoaLinha::buscarDadosClientePorNrLinha()");
    return OK;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
		ULOG_END("CPessoaLinha::buscarDadosClientePorNrLinha()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CPessoaLinha::buscarDadosProspectPorNrLinha(char* pNrLin)
{
    ULOG_START("CPessoaLinha::buscarDadosProspectPorNrLinha()");
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	    char cOraDDD[3];
	    char cOraFone[10];
	EXEC SQL END DECLARE SECTION;

	strncpy(cOraDDD, pNrLin, 2);
	cOraDDD[2]='\0';
	strcpy( cOraFone, (char*)&pNrLin[2] );

	// Marca ponto de controle de erro
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Busca os dados principais
	EXEC SQL 
        SELECT 
             PESSOA.IDPESSOA
            ,PESSOADEPARA.IDPESSOADEPARA
            ,LINHATELEFONICA.IDLINHATELEFONICA
            ,SUBSTR(PESSOA.NMPESSOA,1,80) AS NMPESSOA
            ,(:cOraDDD||:cOraFone) AS NRLINHA
            ,:cOraDDD
            ,soa_ow.formata_nrlinha(TO_CHAR(:cOraDDD||:cOraFone)) AS NRLINHAFORMATADA
            ,TIPOPESSOA.DSTIPOPESSOA
            ,TIPOPESSOA.SGTIPOPESSOA
            ,PROBABILIDADE.DSPROBABILIDADE
            ,TO_CHAR(LINHATELEFONICA.DTHABILITACAO, 'DD/MM/YYYY' ) AS DTHABILITACAO
            ,SUBSTR(TIPOLINHA.DSTIPOLINHA, 1, 18) AS DSTIPOLINHA
            ,TIPOLINHA.IDTIPOLINHA
            ,'NÃO CLASSIFICADO' AS DSESTADOLINHA
            ,LINHATELEFONICA.INDIVULGACAONRLINHA
            ,TIPOCARTEIRA.DSTIPOCARTEIRA
            ,TIPOCARTEIRA.IDTIPOCARTEIRA
            ,TIPOCARTEIRA.SGTIPOCARTEIRA
	    INTO
		    :tTabelab01.sIdPessoa:tTabelab01.iIdPessoa_ora,
		    :tTabelab01.sIdPessoaDePara:tTabelab01.iIdPessoaDePara_ora,
		    :tTabelab01.sIdLinhaTelefonica:tTabelab01.iIdLinhaTelefonica_ora,
		    :tTabelab01.sNmPessoa:tTabelab01.iNmPessoa_ora,
		    :tTabelab01.sNrLinha:tTabelab01.iNrLinha_ora,
		    :tTabelab01.sCdAreaRegistro:tTabelab01.iCdAreaRegistro_ora,
		    :tTabelab01.sDddLinhaFormatada,
		    :tTabelab01.sDsTipoPessoa:tTabelab01.iDsTipoPessoa_ora,
		    :tTabelab01.sSgTipoPessoa:tTabelab01.iSgTipoPessoa_ora,
		    :tTabelab01.sDtChurn:tTabelab01.iDtChurn_ora,
		    :tTabelab01.sDtHabilitacaoOut:tTabelab01.iDtHabilitacaoOut_ora,
		    :tTabelab01.sDsTipoLinha:tTabelab01.iDsTipoLinha_ora,
		    :tTabelab01.sIdTipoLinha:tTabelab01.iIdTipoLinha_ora,
		    :tTabelab01.sDsEstadoLinha:tTabelab01.iDsEstadoLinha_ora,
		    :tTabelab01.sInDivulgacaoNrLinha:tTabelab01.iInDivulgacaoNrLinha_ora,
		    :tTabelab01.sDsTipoCarteira:tTabelab01.iDsTipoCarteira_ora,
		    :tTabelab01.sIdTipoCarteira:tTabelab01.iIdTipoCarteira_ora,
		    :tTabelab01.sSgTipoCarteira:tTabelab01.iSgTipoCarteira_ora
        FROM 
            CUSTOMER.PESSOA PESSOA,
            CUSTOMER.PESSOADEPARA PESSOADEPARA,
            LINHA.LINHATELEFONICA LINHATELEFONICA,
	        APOIO.TIPOLINHA TIPOLINHA,
	        APOIO.TIPOCARTEIRA TIPOCARTEIRA,
	        APOIO.PROBABILIDADE PROBABILIDADE,
            APOIO.TIPOPESSOA TIPOPESSOA
	    WHERE PESSOA.IDPESSOA = PESSOADEPARA.IDPESSOA
        AND   PESSOA.IDTIPOPESSOA = TIPOPESSOA.IDTIPOPESSOA
	    AND   PESSOA.IDTIPOCARTEIRA = TIPOCARTEIRA.IDTIPOCARTEIRA
	    AND   PESSOA.IDCHURNPROBABILIDADE = PROBABILIDADE.IDPROBABILIDADE
	    AND   LINHATELEFONICA.IDLINHATELEFONICA = 1
	    AND   LINHATELEFONICA.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
	    AND   PESSOA.NRLINHAPROSPECT = :cOraFone
	    AND   PESSOA.CDAREAREGISTROPROSPECT = :cOraDDD
	    AND   ROWNUM < 2;

    ULOG("Depois do Select com os dados principais");

    // Busca o numero de telefone residencial
    //           AND tipocomunicacao.sgtipocomunicacao  in ('CELULAR', 'TEL COM', 'TEL REC', 'TEL RES', 'HM', 'WK', 'BS', 'BC')

	EXEC SQL 
	SELECT 
		PESSOACOMUNICACAO.
		DSCONTATO
	INTO 
		:tTabelab01.sNrTelefone
		:tTabelab01.iNrTelefone_ora
	FROM 
		CUSTOMER.PESSOACOMUNICACAO
	   ,APOIO.TIPOCOMUNICACAO
	WHERE TIPOCOMUNICACAO.IDTIPOCOMUNICACAO = PESSOACOMUNICACAO.IDTIPOCOMUNICACAO
	AND UPPER(TIPOCOMUNICACAO.SGCLASSIFICACAO) IN ('SMS', 'TELEFONE')
	AND IDPESSOA = :tTabelab01.sIdPessoa
	AND ROWNUM = 1;


    ULOG_END("CPessoaLinha::buscarDadosProspectPorNrLinha()");
    return OK;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
		ULOG_END("CPessoaLinha::buscarDadosProspectPorNrLinha()");
		throw TuxBasicOraException(sqlca.sqlcode);
}


int CPessoaLinha::buscarDadosCartaoVivoItau(char* pNrLin)
{
    ULOG_START("CPessoaLinha::buscarDadosCartaoVivoItau()");
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	    char cOraDDD[3];
	    char *cOraFone = pNrLin+2;
	EXEC SQL END DECLARE SECTION;

	strncpy(cOraDDD, pNrLin, 2);
	cOraDDD[2]='\0';

	// Marca ponto de controle de erro
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Busca os dados principais
	memset(&tTabelab01.dsModalidadeCartaoItau,0,sizeof(tTabelab01.dsModalidadeCartaoItau));
    tTabelab01.idsModalidadeCartaoItau_ora = -1;

	EXEC SQL 
        SELECT
            TIPOCARTAOVIVOITAUCARD.DSMODALIDADE
	    INTO 
		    :tTabelab01.dsModalidadeCartaoItau:tTabelab01.idsModalidadeCartaoItau_ora
        FROM
            LINHA.LINHAITAUCARD LINHAITAUCARD,
            APOIO.TIPOCARTAOVIVOITAUCARD TIPOCARTAOVIVOITAUCARD,
            APOIO.AREAREGISTRO AREAREGISTRO
        WHERE
            LINHAITAUCARD.IDTIPOCARTAOVIVOITAUCARD = TIPOCARTAOVIVOITAUCARD.IDTIPOCARTAOVIVOITAUCARD
        AND AREAREGISTRO.IDAREAREGISTRO = LINHAITAUCARD.IDAREAREGISTRO
        AND AREAREGISTRO.CDAREAREGISTRO = :cOraDDD
	    AND LINHAITAUCARD.NRLINHA = :cOraFone;

    if ( sqlca.sqlcode )
    {
        ULOG_END("CPessoaLinha::buscarDadosCartaoVivoItau() -- NOT FOUND");
        return NOK;
    }

    CONVIND(tTabelab01.dsModalidadeCartaoItau,tTabelab01.idsModalidadeCartaoItau_ora);

    ULOG_END("CPessoaLinha::buscarDadosCartaoVivoItau()");
    return OK;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
		ULOG_END("CPessoaLinha::buscarDadosCartaoVivoItau()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CPessoaLinha::buscarDadosClienteTIPorNrLinha(char* pNrLin)
{
    ULOG_START("CPessoaLinha::buscarDadosClienteTIPorNrLinha()");
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	    char cOraDDD[3];
	    char cOraFone[10];
	EXEC SQL END DECLARE SECTION;

	strncpy(cOraDDD, pNrLin, 2);
	cOraDDD[2]='\0';
	strcpy(cOraFone, (char*)&pNrLin[2]);

	// Marca ponto de controle de erro
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Busca os dados principais
	EXEC SQL 
        select pessoa.idpessoa,
               SUBSTR(pessoa.nmpessoa, 1,80),
               tipopessoa.dstipopessoa,
               probabilidade1.dsprobabilidade,
               tipocarteira.dstipocarteira,
               tipocarteira.idtipocarteira,
               tipocarteira.sgtipocarteira
          INTO :tTabelab01.sIdPessoa:tTabelab01.iIdPessoa_ora,
               :tTabelab01.sNmPessoa:tTabelab01.iNmPessoa_ora,
               :tTabelab01.sDsTipoPessoa:tTabelab01.iDsTipoPessoa_ora,
               :tTabelab01.sDtChurn:tTabelab01.iDtChurn_ora,
               :tTabelab01.sDsTipoCarteira:tTabelab01.iDsTipoCarteira_ora,
               :tTabelab01.sIdTipoCarteira:tTabelab01.iIdTipoCarteira_ora,
               :tTabelab01.sSgTipoCarteira:tTabelab01.iSgTipoCarteira_ora 
          FROM customer.pessoa                pessoa,
               customer.pessoadepara          pessoadepara,
               customer.pessoalinha           pessoalinha,
               customer.tiporelacionamento    tiporelacionamento,
               linha.linhatelefonica          linhatelefonica,
               linha.linhabase                linhabase,
               apoio.tipocarteira             tipocarteira,
               apoio.arearegistro             arearegistro,
               apoio.tipopessoa               tipopessoa,
               apoio.probabilidade            probabilidade1,
               apoio.probabilidade            probabilidade2
         WHERE pessoa.idpessoa                         = pessoadepara.idpessoa
           AND pessoadepara.idpessoadepara             = pessoalinha.idpessoadepara
           AND tiporelacionamento.idtiporelacionamento = pessoalinha.idtiporelacionamento
           AND linhatelefonica.idlinhatelefonica       = pessoalinha.idlinhatelefonica
           AND linhabase.idlinhabase                   = linhatelefonica.idlinhabase
           AND tipocarteira.idtipocarteira             = pessoa.idtipocarteira
           AND arearegistro.idarearegistro             = linhabase.idarearegistro
           AND tipopessoa.idtipopessoa                 = pessoa.idtipopessoa
           AND probabilidade1.idprobabilidade          = pessoa.idprobinadimplencia
           AND probabilidade2.idprobabilidade          = pessoa.idchurnprobabilidade
           AND linhabase.nrlinha                       = :cOraFone
           AND arearegistro.cdarearegistro             = :cOraDDD
           AND tiporelacionamento.sgtiporelacionamento = 'C';

    ULOG("CPessoaLinha::buscarDadosClienteTIPorNrLinha:Apos a pesquisa");

    // Busca o numero de telefone residencial
    EXEC SQL 
	SELECT 
		PESSOACOMUNICACAO.DSCONTATO
	INTO 
		:tTabelab01.sNrTelefone:tTabelab01.iNrTelefone_ora
	FROM 
		CUSTOMER.PESSOACOMUNICACAO PESSOACOMUNICACAO,
        APOIO.TIPOCOMUNICACAO TIPOCOMUNICACAO
	WHERE PESSOACOMUNICACAO.IDTIPOCOMUNICACAO = TIPOCOMUNICACAO.IDTIPOCOMUNICACAO
	AND   TIPOCOMUNICACAO.SGTIPOCOMUNICACAO = 'HM'
    AND   PESSOACOMUNICACAO.IDPESSOA = :tTabelab01.sIdPessoa
    AND   ROWNUM = 1;

    ULOG_END("CPessoaLinha::buscarDadosClienteTIPorNrLinha()");
    return OK;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaLinha::buscarDadosClienteTIPorNrLinha()");
		throw TuxBasicOraException(sqlca.sqlcode);
}


int CPessoaLinha::buscarDadosLinhaTIPorNrLinha(char* pNrLin)
{
    ULOG_START("CPessoaLinha::buscarDadosLinhaTIPorNrLinha()");
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	    char cOraDDD[3];
	    char cOraFone[10];
	EXEC SQL END DECLARE SECTION;

	strncpy(cOraDDD, pNrLin, 2);
	cOraDDD[2]='\0';
	strcpy(cOraFone, (char*)&pNrLin[2]);

	// Marca ponto de controle de erro
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Busca os dados principais
	EXEC SQL 
        SELECT linhatelefonica.idlinhatelefonica,
               (arearegistro.cdarearegistro||linhabase.nrlinha) as nrlinha,
               arearegistro.cdarearegistro,
               soa_ow.formata_nrlinha(TO_CHAR(arearegistro.CdAreaRegistro||linhabase.nrlinha)) ,
               TO_CHAR(linhatelefonica.dthabilitacao, 'DD/MM/YYYY'),
               tipolinha.dstipolinha,
               estadolinha.dsestadolinha,
               linhatelefonica.indivulgacaonrlinha
          INTO :tTabelab01.sIdLinhaTelefonica:tTabelab01.iIdLinhaTelefonica_ora,
               :tTabelab01.sNrLinha:tTabelab01.iNrLinha_ora,
               :tTabelab01.sCdAreaRegistro:tTabelab01.iCdAreaRegistro_ora,
               :tTabelab01.sDddLinhaFormatada,
               :tTabelab01.sDtHabilitacaoOut:tTabelab01.iDtHabilitacaoOut_ora,
               :tTabelab01.sDsTipoLinha:tTabelab01.iDsTipoLinha_ora,
               :tTabelab01.sDsEstadoLinha:tTabelab01.iDsEstadoLinha_ora,
               :tTabelab01.sInDivulgacaoNrLinha:tTabelab01.iInDivulgacaoNrLinha_ora
          FROM linha.linhatelefonica linhatelefonica,
               linha.linhabase       linhabase,
               apoio.tipolinha       tipolinha,
               apoio.arearegistro    arearegistro,
               apoio.estadolinha     estadolinha
         WHERE linhabase.idlinhabase       = linhatelefonica.idlinhabase
           AND tipolinha.idtipolinha       = linhatelefonica.idtipolinha
           AND arearegistro.idarearegistro = linhabase.idarearegistro
           AND estadolinha.idestadolinha   = linhabase.idestadolinha
           AND linhabase.nrlinha           = :cOraFone
           AND arearegistro.cdarearegistro = :cOraDDD;

   //Busca o nome do servico da linha
	EXEC SQL 
        SELECT planoservico.nmservico
          INTO :tTabelab01.sNmServico:tTabelab01.iNmServico_ora
          FROM linha.linhatelefonica,
               linha.planoservicolinha,
               linha.planoservico
         WHERE linhatelefonica.idlinhatelefonica    = planoservicolinha.idlinhatelefonica
           AND planoservico.idservico               = planoservicolinha.idservico
           AND planoservicolinha.inplano            = 1
           AND ( planoservicolinha.dtvigenciafinal >= SYSDATE OR planoservicolinha.dtvigenciafinal IS NULL )
           AND planoservicolinha.dtexpiracao        IS NULL
           AND linhatelefonica.idlinhatelefonica =  :tTabelab01.sIdLinhaTelefonica ;


    ULOG_END("CPessoaLinha::buscarDadosLinhaTIPorNrLinha()");
    return OK;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaLinha::buscarDadosLinhaTIPorNrLinha()");
		throw TuxBasicOraException(sqlca.sqlcode);
}


int CPessoaLinha::obterQtdTipoLinha(char* pId, int iTipo)
{
    ULOG_START("CPessoaLinha::obterQtdTipoLinha()");
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR sId[LEN_NUMBER + LEN_EOS];
        int iTotReg;
        int iTipoLinha;
	EXEC SQL END DECLARE SECTION;

    ULOG("CPessoaLinha::obterQtdTipoLinha:pId[%s]", pId);
    ULOG("CPessoaLinha::obterQtdTipoLinha:iTipo(%d)", iTipo);

    STRCPY_TO_ORA(sId, pId);
    iTipoLinha = iTipo;

	// Marca ponto de controle de erro
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Busca os dados principais
	EXEC SQL 
	SELECT
	    COUNT(1)
	INTO
		:iTotReg
	FROM
	    CUSTOMER.PESSOALINHA PESSOALINHA,
	    LINHA.LINHATELEFONICA LINHATELEFONICA,
	    CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTO
	WHERE PESSOALINHA.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
	AND   PESSOALINHA.IDTIPORELACIONAMENTO = TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
	AND   TIPORELACIONAMENTO.SGTIPORELACIONAMENTO = 'C'
	AND   PESSOALINHA.IDPESSOADEPARA = :sId
	AND   LINHATELEFONICA.IDTIPOLINHA = :iTipoLinha;

    ULOG("CPessoaLinha::obterQtdTipoLinha:iTotReg(%d)", iTotReg);

    ULOG_END("CPessoaLinha::obterQtdTipoLinha()");
    return iTotReg;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaLinha::obterQtdTipoLinha()");
		throw TuxBasicOraException(sqlca.sqlcode);

}

int CPessoaLinha::obterQtdTipoLinhaCarregaTI(char* pId)
{
    ULOG_START("CPessoaLinha::obterQtdTipoLinhaCarregaTI()");
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR sId[LEN_NUMBER + LEN_EOS];
        int iTotReg;
	EXEC SQL END DECLARE SECTION;

    ULOG("CPessoaLinha::obterQtdTipoLinhaCarregaTI:pId[%s]", pId);

    STRCPY_TO_ORA(sId, pId);

	// Marca ponto de controle de erro
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Busca os dados principais
	EXEC SQL 
	SELECT
	    COUNT(1)
    INTO 
    	:iTotReg
	FROM
	    CUSTOMER.PESSOALINHA PESSOALINHA,
	    LINHA.LINHATELEFONICA LINHATELEFONICA,
	    CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTO,
        CUSTOMER.PESSOADEPARA PESSOADEPARA
	WHERE PESSOALINHA.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
	AND   PESSOALINHA.IDTIPORELACIONAMENTO = TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
	AND   TIPORELACIONAMENTO.SGTIPORELACIONAMENTO = 'C'
	AND   PESSOALINHA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA
    AND   PESSOADEPARA.IDPESSOA = :sId
	AND   LINHATELEFONICA.IDTIPOLINHA IN (1, 2, 5, 6);

    ULOG("CPessoaLinha::obterQtdTipoLinhaCarregaTI:iTotReg(%d)", iTotReg);
    ULOG_END("CPessoaLinha::obterQtdTipoLinhaCarregaTI()");
    return iTotReg;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaLinha::obterQtdTipoLinhaCarregaTI()");
		throw TuxBasicOraException(sqlca.sqlcode);

}

int CPessoaLinha::obterQtdDeLinhaAtivaPorIdPessoa(char* pId)
{
    ULOG_START("CPessoaLinha::obterQtdDeLinhaAtivaPorIdPessoa()");
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR sId[LEN_NUMBER + LEN_EOS];
        int iTotReg;
	EXEC SQL END DECLARE SECTION;

    STRCPY_TO_ORA(sId, pId);

	// Marca ponto de controle de erro
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Busca os dados principais
	EXEC SQL 
        SELECT  count(1)
          INTO  :iTotReg
          FROM  customer.pessoalinha        pessoalinha
               ,customer.tiporelacionamento tiporelacionamento
               ,linha.linhatelefonica       linhatelefonica
               ,linha.linhabase linhabase
         WHERE tiporelacionamento.idtiporelacionamento = pessoalinha.idtiporelacionamento
           AND linhatelefonica.idlinhatelefonica = pessoalinha.idlinhatelefonica
           AND linhatelefonica.idlinhabase = linhabase.idlinhabase
           AND tiporelacionamento.sgtiporelacionamento = 'C'
           AND linhabase.idestadolinha = 1
           AND pessoalinha.idpessoadepara = :sId;

    ULOG_END("CPessoaLinha::obterQtdDeLinhaAtivaPorIdPessoa()");
    return iTotReg;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaLinha::obterQtdDeLinhaAtivaPorIdPessoa()");
		throw TuxBasicOraException(sqlca.sqlcode);

}


int CPessoaLinha::obterQtdDeLinhaPorIdPessoa(char* pId)
{
    ULOG_START("CPessoaLinha::obterQtdDeLinhaPorIdPessoa()");
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR sId[LEN_NUMBER + LEN_EOS];
        int iTotReg;
	EXEC SQL END DECLARE SECTION;

    STRCPY_TO_ORA(sId, pId);

	// Marca ponto de controle de erro
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Busca os dados principais
	EXEC SQL 
        SELECT  count(1)
          INTO  :iTotReg
          FROM  customer.pessoalinha        pessoalinha
               ,customer.pessoadepara       pessoadepara
               ,customer.tiporelacionamento tiporelacionamento
               ,linha.linhatelefonica       linhatelefonica
         WHERE pessoadepara.idpessoadepara             = pessoalinha.idpessoadepara
           AND tiporelacionamento.idtiporelacionamento = pessoalinha.idtiporelacionamento
           AND linhatelefonica.idlinhatelefonica       = pessoalinha.idlinhatelefonica
           AND tiporelacionamento.sgtiporelacionamento = 'C'
           AND pessoadepara.idpessoadepara             = :sId;

    ULOG_END("CPessoaLinha::obterQtdDeLinhaPorIdPessoa()");
    return iTotReg;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CPessoaLinha::obterQtdDeLinhaPorIdPessoa()");
		throw TuxBasicOraException(sqlca.sqlcode);

}

//Este metodo difere do obterQtdEstadoLinhaCarregaTI porque busca por IDPESSOADEPARA, ja o 
//obterQtdEstadoLinhaCarregaTI busca por IDPESSOA
int CPessoaLinha::obterQtdEstadoLinha(char* pId, char* pszClassificacaoEstado)
{
    ULOG_START("CPessoaLinha::obterQtdEstadoLinha()");
    struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
        char* pszId = pId;
        char* pszClassificacaoEstadoAux = pszClassificacaoEstado;
        int iTotReg;
        int iEstadoLinha;
	EXEC SQL END DECLARE SECTION;

    ULOG("CPessoaLinha::obterQtdEstadoLinha:pId[%s]", pszId);
    ULOG("CPessoaLinha::obterQtdEstadoLinha:iEstado(%d)", pszClassificacaoEstadoAux);

	// Marca ponto de controle de erro
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// EDER MUDAR AQUI.
	// Busca os dados principais
	EXEC SQL 
      SELECT count(1)
        INTO :iTotReg
        FROM customer.pessoalinha                    pessoalinha
           , customer.tiporelacionamento             tiporelacionamento
           , linha.linhatelefonica                   linhatelefonica
           , linha.linhabase                         linhabase
           , apoio.estadolinha                       estadolinha
       WHERE pessoalinha.idpessoadepara              = :pszId
         AND tiporelacionamento.sgtiporelacionamento = 'C'
         AND tiporelacionamento.idtiporelacionamento = pessoalinha.idtiporelacionamento
         AND linhatelefonica.idlinhatelefonica       = pessoalinha.idlinhatelefonica
         AND linhatelefonica.idlinhabase             = linhabase.idlinhabase
         AND linhabase.idestadolinha                 = estadolinha.idestadolinha
         AND UPPER(estadolinha.sgclassificacao)      = UPPER(:pszClassificacaoEstadoAux);

    ULOG("CPessoaLinha::obterQtdEstadoLinha:iTotReg(%d)", iTotReg);

    ULOG_END("CPessoaLinha::obterQtdEstadoLinha()");
    return iTotReg;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CPessoaLinha::obterQtdEstadoLinha()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CPessoaLinha::obterQtdEstadoLinhaCarregaTI(char* pId, char* pszClassificacaoEstado)
{
    ULOG_START("CPessoaLinha::obterQtdEstadoLinhaCarregaTI()");
    struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
        char* pszId = pId;
        char* pszClassificacaoEstadoAux = pszClassificacaoEstado;
        int iTotReg;
        int iEstadoLinha;
	EXEC SQL END DECLARE SECTION;

    ULOG("CPessoaLinha::obterQtdEstadoLinhaCarregaTI:pId[%s]", pszId);
    ULOG("CPessoaLinha::obterQtdEstadoLinhaCarregaTI:iEstado(%d)", pszClassificacaoEstadoAux);

	// Marca ponto de controle de erro
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// EDER MUDAR AQUI.
	// Busca os dados principais
	EXEC SQL 
      SELECT count(1)
        INTO :iTotReg
        FROM customer.pessoalinha                    pessoalinha
           , customer.pessoa                         pessoa
           , customer.pessoadepara                   pessoadepara
           , customer.tiporelacionamento             tiporelacionamento
           , linha.linhatelefonica                   linhatelefonica
           , linha.linhabase                         linhabase
           , apoio.estadolinha                       estadolinha
       WHERE pessoa.idpessoa                         = :pszId
         AND pessoa.idpessoa                         = pessoadepara.idpessoa
         AND tiporelacionamento.sgtiporelacionamento = 'C'
         AND tiporelacionamento.idtiporelacionamento = pessoalinha.idtiporelacionamento
         AND pessoadepara.idpessoadepara             = pessoalinha.idpessoadepara
         AND linhatelefonica.idlinhatelefonica       = pessoalinha.idlinhatelefonica
         AND linhatelefonica.idlinhabase             = linhabase.idlinhabase
         AND linhabase.idestadolinha                 = estadolinha.idestadolinha
         AND UPPER(estadolinha.sgclassificacao)      = UPPER(:pszClassificacaoEstadoAux);

    ULOG("CPessoaLinha::obterQtdEstadoLinhaCarregaTI:iTotReg(%d)", iTotReg);

    ULOG_END("CPessoaLinha::obterQtdEstadoLinhaCarregaTI()");
    return iTotReg;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoaLinha::obterQtdEstadoLinhaCarregaTI()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

bool CPessoaLinha::obterNomeGestorConta()
{
    ULOG_START("CPessoaLinha::obterNomeGestorConta()");

    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        const char *pVarOraIdPessoa = this->getIdPessoa();
        const char *pVarOraIdLinhaTelefonica = this->getIdLinhaTelefonica();

        VARCHAR varOraNmPessoa[256];
        short statOraNmPessoa = -1;
        
        VARCHAR varOraNrTelefone[20];
        short statOraNrTelefone = -1;

	EXEC SQL END DECLARE SECTION;

    ULOG("         idPessoa=[%s]", pVarOraIdPessoa);
    ULOG("idLinhaTelefonica=[%s]", pVarOraIdLinhaTelefonica);

    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorBuscaNomGC;


    EXEC SQL 
        SELECT
            NMPESSOAGESTOR,
            /*
            DECODE(NRTEL,NULL,NULL,
                '('||SUBSTR(TO_CHAR(LPAD(NRTEL,10),'9999999999'),2,2) ||') '||
                     SUBSTR(TO_CHAR(LPAD(NRTEL,10),'9999999999'),4,4) ||'-'||
                     SUBSTR(TO_CHAR(LPAD(NRTEL,10),'9999999999'),8,4)) AS NRTELEFONEGESTOR
            */
            DECODE(NRTEL,NULL,NULL,
                   soa_ow.formata_nrlinha(SUBSTR(TO_CHAR(NRTEL),1,2)||SUBSTR(TO_CHAR(NRTEL),3))) AS NRTELEFONEGESTOR
        INTO
            :varOraNmPessoa:statOraNmPessoa,
            :varOraNrTelefone:statOraNrTelefone
        FROM
        (
            SELECT
                PESSOAGESTOR.NMPESSOAGESTOR,
                NVL(NVL(PESSOAGESTOR.NRTELEFONECELULARVIVO,PESSOAGESTOR.NRTELEFONECELULAROUTRO),PESSOAGESTOR.NRTELEFONEFIXO) AS NRTEL
            FROM
                CUSTOMER.PESSOALINHA PESSOALINHA ,
                CUSTOMER.LINHACONTA LINHACONTA ,
				customer.tiporelacionamento tiporelacionamento , 
                CUSTOMER.PESSOAGESTORCONTA PESSOAGESTORCONTA ,
                CUSTOMER.PESSOAGESTOR PESSOAGESTOR
            WHERE
                PESSOALINHA.IDLINHATELEFONICA = :pVarOraIdLinhaTelefonica
            AND PESSOALINHA.IDTIPORELACIONAMENTO = 2
            AND LINHACONTA.IDLINHATELEFONICA = PESSOALINHA.IDLINHATELEFONICA
            AND LINHACONTA.IDTIPORELACIONAMENTO = 2
		    AND LINHACONTA.IDCONTA = PESSOAGESTORCONTA.IDCONTA
			AND PESSOAGESTORCONTA.NRDOCUMENTO = PESSOAGESTOR.NRDOCUMENTO
			and tiporelacionamento.SGTIPORELACIONAMENTO = 'GC'
			and tiporelacionamento.IDTIPORELACIONAMENTO = PESSOAGESTORCONTA.IDTIPORELACIONAMENTO
            AND ROWNUM < 2
        );
    

    if ( sqlca.sqlcode )
    {
        ULOG_END("CPessoaLinha::obterNomeGestorConta() ==> NOT FOUND");
        return false;
    }
    

    CONVIND(varOraNmPessoa,statOraNmPessoa);
    CONVIND(varOraNrTelefone,statOraNrTelefone);
    
    ULOG( "Obteve varOraNmPessoa   [%s]", (char*)varOraNmPessoa.arr );
    ULOG( "Obteve varOraNrTelefone [%s]", (char*)varOraNrTelefone.arr );

    memcpy(&tTabelab01.sNmPessoa,&varOraNmPessoa,sizeof(tTabelab01.sNmPessoa));
    memcpy(&tTabelab01.sNrTelefone,&varOraNrTelefone,sizeof(tTabelab01.sNrTelefone));

    ULOG( "tTabelab01.sNmPessoa   [%s]", (char*)&tTabelab01.sNmPessoa.arr );
    ULOG( "tTabelab01.sNrTelefone [%s]", (char*)&tTabelab01.sNrTelefone.arr );

    //strcpy((char*)&tTabelab01.sNmPessoa,"  Indra");
    //strcpy((char*)&tTabelab01.sNrTelefone,"  (99)9999-9999");

    ULOG_END("CPessoaLinha::obterNomeGestorConta()");

    return true;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
sqlErrorBuscaNomGC:
	ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	ULOG_END("CPessoaLinha::obterNomeGestorConta()");
	throw TuxBasicOraException(sqlca.sqlcode);
}

/********************************************************************************/
void CPessoaLinha::InserePessoaLinha()
{
    ULOG_START("CPessoaLinha::InserePessoaLinha()");
    EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR oszIdUsuarioAlteracao[LEN_IDPESSOALINHA];
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    ULOGI("CPessoaLinha::InserePessoaLinha:Iniciando proCInserePessoaLinha");

    EXEC SQL WHENEVER SQLERROR goto erro;

    EXEC SQL SELECT to_char(Customer.PessoaLinhaSq.nextval)
        INTO :tTabelab01.sIdPessoa FROM DUAL;


    ULOGI("CPessoaLinha::InserePessoaLinha:Valor da sequence %s", tTabelab01.sIdPessoa.arr);

    STRCPY_TO_ORA(oszIdUsuarioAlteracao, ID_USUARIO_ALTERACAO);

    EXEC SQL INSERT INTO Customer.PessoaLinha
                       ( idpessoalinha
                       , dtpessoalinha
                       , idtiporelacionamento
                       , idpessoadepara
                       , idlinhatelefonica
                       , idusuarioalteracao
                       , dtultimaalteracao )
                VALUES 
					   ( :tTabelab01.sIdPessoa
                       , SYSDATE
                       , :tTabelab01.sIdTipoRelacionamento
                       , :tTabelab01.sIdPessoaDePara
                       , :tTabelab01.sIdLinhaTelefonica
                       , :oszIdUsuarioAlteracao
                       , SYSDATE );

    ULOG_END("CPessoaLinha::InserePessoaLinha()");
    return;

    erro:
        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
        ULOG_END("CPessoaLinha::InserePessoaLinha()");
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}


void CPessoaLinha::TrocaPessoaLinha()
{
    ULOG_START("CPessoaLinha::TrocaPessoaLinha()");    
    EXEC SQL BEGIN DECLARE SECTION;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    ULOGI("CPessoaLinha::TrocaPessoaLinha:Iniciando TrocaPessoaLinha");

    EXEC SQL WHENEVER SQLERROR goto erro;
 
    EXEC SQL UPDATE Customer.PessoaLinha
		SET idpessoadepara = :tTabelab01.sIdPessoaDePara 
		    WHERE idlinhatelefonica = :tTabelab01.sIdLinhaTelefonica
			and IdTipoRelacionamento = :tTabelab01.sIdTipoRelacionamento;

    ULOG_END("CPessoaLinha::TrocaPessoaLinha()");    
    return;

    erro:
        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
        ULOG_END("CPessoaLinha::TrocaPessoaLinha()");    
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}


void CPessoaLinha::TrocaUsuario()
{
    ULOG_START("CPessoaLinha::TrocaUsuario()");    
    EXEC SQL BEGIN DECLARE SECTION;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    

    EXEC SQL WHENEVER SQLERROR goto erro;

	if ( obterQtdRegUsuario() > 0 ) 
	{
         EXEC SQL UPDATE Customer.PessoaLinha
		      SET idpessoadepara = :tTabelab01.sIdPessoaDePara 
		        where idlinhatelefonica = :tTabelab01.sIdLinhaTelefonica
				  and idtiporelacionamento = :tTabelab01.sIdTipoRelacionamento; 
	}
	else
	InserePessoaLinha();

    ULOG_END("CPessoaLinha::TrocaUsuario()");    
    return;

    erro:
        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
        ULOG_END("CPessoaLinha::TrocaUsuario()");    
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}



void CPessoaLinha::RemoveAll()
{
/*
         EXEC SQL DELETE Customer.PessoaLinha
			 WHERE idpessoadepara = :tTabelab01.sIdPessoaDePara 
		      AND idlinhatelefonica = :tTabelab01.sIdLinhaTelefonica;

*/
    ULOG_START("CPessoaLinha::RemoveAll()");    
    EXEC SQL BEGIN DECLARE SECTION;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;



    EXEC SQL WHENEVER SQLERROR goto erro;

	if ( obterQtdReg() > 0 ) 
	{
         EXEC SQL UPDATE Customer.PessoaLinha
		      SET idpessoadepara = :tTabelab01.sIdPessoaDePara 
		        where idlinhatelefonica = :tTabelab01.sIdLinhaTelefonica
			     --and idpessoadepara = :tTabelab01.sIdPessoaDePara
				  and idtiporelacionamento = :tTabelab01.sIdTipoRelacionamento; 
	}
	else
	InserePessoaLinha();

    ULOG_END("CPessoaLinha::RemoveAll()");    
    return;

    erro:
        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
        ULOG_END("CPessoaLinha::RemoveAll()");    
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}


int CPessoaLinha::obterQtdRegUsuario()
{
    ULOG_START("CPessoaLinha::obterQtdRegUsuario(()");    
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        int iTotReg;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	EXEC SQL 
	SELECT 
		COUNT(1)
	INTO
		:iTotReg
	FROM
		CUSTOMER.PESSOALINHA
	WHERE IDLINHATELEFONICA = :tTabelab01.sIdLinhaTelefonica
	AND   IDTIPORELACIONAMENTO = :tTabelab01.sIdTipoRelacionamento; 


    ULOG_END("CPessoaLinha::obterQtdRegUsuario()");    
    return iTotReg;

	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CPessoaLinha::obterQtdRegUsuario()");    
		throw TuxBasicOraException(sqlca.sqlcode);
}


int CPessoaLinha::obterQtdReg()
{
    ULOG_START("CPessoaLinha::obterQtdReg()");    
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        int iTotReg;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	EXEC SQL 
	SELECT
		COUNT(1)
	INTO
		:iTotReg
	FROM
		CUSTOMER.PESSOALINHA
	WHERE IDLINHATELEFONICA = :tTabelab01.sIdLinhaTelefonica
	AND   IDTIPORELACIONAMENTO = :tTabelab01.sIdTipoRelacionamento; 

    ULOG_END("CPessoaLinha::obterQtdReg()");    
    return iTotReg;

	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CPessoaLinha::obterQtdReg()");    
		throw TuxBasicOraException(sqlca.sqlcode);
}
//
int  CPessoaLinha::obterDadosPortabilidade(char*cNrlinha,char *ctpPortada,char *cdsPortada)
{

ULOG_START("CPessoaLinha::obterDadosPortabilidade)");    
	struct sqlca sqlca;
	
	EXEC SQL BEGIN DECLARE SECTION;
      int     tam_fone;
		VARCHAR sNrLinha[16];
		
		VARCHAR tpPortabilidade[16];
		VARCHAR dsPortabilidade[256];
		
		int		isPortabilidade=0;
		
		short i_isPortabilidade = -1;
		short i_tpPortabilidade = -1;
		short i_dsPortabilidade = -1;
		
	EXEC SQL END DECLARE SECTION;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorPort;

	STRCPY_TO_ORA(sNrLinha, cNrlinha);
	ULOG( "cNrlinha [%s], ctpPortada [%s], cdsPortada [%s]",cNrlinha,ctpPortada,cdsPortada );

   // SM Nono Digito
   tam_fone = (strlen(cNrlinha) > 10) ? 9 : 8 ;

EXEC SQL
	SELECT  1,
			SGTIPOPORTABILIDADE,
			DSACAOPORTABILIDADE
	into 	:isPortabilidade:i_isPortabilidade,
			:tpPortabilidade:i_tpPortabilidade,
			:dsPortabilidade:i_dsPortabilidade
	FROM	
	(
	    SELECT 
		TEMP.SGTIPOPORTABILIDADE,
		TEMP.DTULTIMAALTERACAO,
		TEMP.DSACAOPORTABILIDADE,
		TEMP.IDACAOPORTABILIDADE
	    FROM
	    (
		SELECT
		    1 AS DEF,
		    PESSOAPORTABILIDADEHIST.DTULTIMAALTERACAO,
		    PESSOAPORTABILIDADEHIST.SGTIPOPORTABILIDADE AS SGTIPOPORTABILIDADE,
		    ACAOPORTABILIDADE.DSACAOPORTABILIDADE,
			ACAOPORTABILIDADE.IDACAOPORTABILIDADE
		FROM 
		    CUSTOMER.PESSOAPORTABILIDADEHIST PESSOAPORTABILIDADEHIST,
		    APOIO.ACAOPORTABILIDADE ACAOPORTABILIDADE
		WHERE
		    PESSOAPORTABILIDADEHIST.NRLINHA = TO_NUMBER(substr(:sNrLinha,3,:tam_fone))
		AND PESSOAPORTABILIDADEHIST.CDAREAREGISTRO = TO_NUMBER(substr(:sNrLinha,1,2))
		AND PESSOAPORTABILIDADEHIST.DSACAOPORTABILIDADE=ACAOPORTABILIDADE.DSACAOPORTABILIDADE
		AND ACAOPORTABILIDADE.IDACAOPORTABILIDADE IN (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,101)
	    UNION ALL
		SELECT
		    2 AS DEF,
		    PESSOAPORTABILIDADEHIST.DTULTIMAALTERACAO,
		    PESSOAPORTABILIDADEHIST.SGTIPOPORTABILIDADE AS SGTIPOPORTABILIDADE,
		    ' ' AS DSACAOPORTABILIDADE,
				NULL AS IDACAOPORTABILIDADE
		FROM 
		    CUSTOMER.PESSOAPORTABILIDADEHIST PESSOAPORTABILIDADEHIST,
		    APOIO.ACAOPORTABILIDADE ACAOPORTABILIDADE
		WHERE
		    PESSOAPORTABILIDADEHIST.NRLINHA =  TO_NUMBER(substr(:sNrLinha,3,:tam_fone))
		AND PESSOAPORTABILIDADEHIST.CDAREAREGISTRO = TO_NUMBER(substr(:sNrLinha,1,2))
		AND PESSOAPORTABILIDADEHIST.DSACAOPORTABILIDADE=ACAOPORTABILIDADE.DSACAOPORTABILIDADE
		AND ACAOPORTABILIDADE.IDACAOPORTABILIDADE NOT IN (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,101)
	    ) TEMP
	    ORDER BY
		TEMP.DEF,TEMP.DTULTIMAALTERACAO DESC
	)
	WHERE ROWNUM<=1;

	if (i_tpPortabilidade != -1) 
		endOraStr(tpPortabilidade);
	if (i_dsPortabilidade != -1) 
		endOraStr(dsPortabilidade);

	//*ctpPortada,char *cdsPortada
	if (i_tpPortabilidade != -1)
	   strcpy(ctpPortada,(char*)tpPortabilidade.arr);
	   
	if (i_dsPortabilidade != -1)
	   strcpy(cdsPortada,(char*)dsPortabilidade.arr);



	return isPortabilidade;
	sqlErrorPort:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CPessoaLinha::obterQtdReg()");    
		throw TuxBasicOraException(sqlca.sqlcode);
}

//
CPessoaLinha* CPessoaLinha::buscarPorNrLinha(int* iNroObjetos, char* pId)
{
	ULOG_START("CPessoaLinha::buscarPorNrLinha)");    
	struct sqlca sqlca;
	
	CPessoaLinha* oPL = NULL;
	int iNroObjLocal = 1;

	EXEC SQL BEGIN DECLARE SECTION;
		TTABELA_01 tSt;
		VARCHAR sId[LEN_NUMBER+LEN_EOS];
	EXEC SQL END DECLARE SECTION;

	STRCPY_TO_ORA(sId, pId);

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL DECLARE cNrLinha CURSOR FOR
	SELECT 
        LINHATELEFONICA.IDTIPOLINHA
	FROM
        CUSTOMER.PESSOALINHA PESSOALINHA,
        LINHA.LINHATELEFONICA LINHATELEFONICA,
        LINHA.LINHABASE LINHABASE
	WHERE PESSOALINHA.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
    AND   LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
    AND   LINHABASE.NRLINHA = :sId;

	EXEC SQL OPEN cNrLinha;
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;; iNroObjLocal++) 
	{
		memset(&tSt, 0x00, sizeof(tSt));
		EXEC SQL FETCH cNrLinha
				INTO :tSt.sIdTipoLinha:tSt.iIdTipoLinha_ora;

		// Aloca memória para o objeto atual.
		if ((oPL = (CPessoaLinha*) realloc((void *)oPL, (sizeof(CPessoaLinha) * iNroObjLocal))) != NULL)
		{
			if(tSt.iIdTipoLinha_ora>=0)
				oPL[iNroObjLocal-1].setIdTipoLinha((char*)tSt.sIdTipoLinha.arr);
		} 
		else 
		{
			if (oPL) 
				free(oPL);

			ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
			EXEC SQL CLOSE cNrLinha;
			ULOG_START("CPessoaLinha::buscarPorNrLinha)");    
			throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
		}
	}

	EXEC SQL CLOSE cNrLinha;

	*iNroObjetos = iNroObjLocal - 1;

	return oPL;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	ULOG_START("CPessoaLinha::buscarPorNrLinha)");    
	throw TuxBasicOraException(sqlca.sqlcode);
}

