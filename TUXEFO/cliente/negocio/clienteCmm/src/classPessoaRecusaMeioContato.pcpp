#undef SQLCA
#define SQLCA_NONE
#include <sqlca.h>
#include <sqlda.h>


#undef MSG_NONE
#define MSG_NONE
#include "../include/Messages.h"

#include <tuxfw.h>
#include "../include/Exception.h"

EXEC SQL BEGIN DECLARE SECTION;
#include "../include/Global.h"
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE "../include/classPessoaRecusaMeioContato.h";

#define MSG_ERR_MEMORIA		"Erro de alocação de memória"
#define NRO_ERR_MEMORIA		"24E0359"

// Usuário de alteração
void CPessoaRecusaMeioContato::setUsuarioAlteracao(char* value) {
	if (value != NULL) {
		strncpy(sIdUsuarioAlteracao,value, 255);
		sIdUsuarioAlteracao[255]='\0';
	}
}

CPessoaRecusaMeioContato::CPessoaRecusaMeioContato()
{
    memset(&tTabela, 0x00, sizeof(tTabela));

	memset(sIdUsuarioAlteracao,0,256);
}
CPessoaRecusaMeioContato::~CPessoaRecusaMeioContato()
{
}

void CPessoaRecusaMeioContato::setIdPessoaRecusaMeioContato(char *pDado)
{
    if ( pDado == NULL )
    {
        tTabela.iIdPessoaRecusaMeioContato_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabela.sIdPessoaRecusaMeioContato, pDado);
        tTabela.iIdPessoaRecusaMeioContato_ora = 0;
    }
}

void CPessoaRecusaMeioContato::setIdPessoa(char *pDado)
{
    if ( pDado == NULL )
    {
        tTabela.iIdPessoa_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabela.sIdPessoa, pDado);
        tTabela.iIdPessoa_ora = 0;
    }
}

void CPessoaRecusaMeioContato::setIdMeioContato(char *pDado)
{
    if ( pDado == NULL )
    {
        tTabela.iIdMeioContato_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabela.sIdMeioContato, pDado);
        tTabela.iIdMeioContato_ora = 0;
    }
}
void CPessoaRecusaMeioContato::setDescricao(char *pDado)
{
    if ( pDado == NULL )
    {
        tTabela.iDescricao_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tTabela.sDescricao, pDado);
        tTabela.iDescricao_ora = 0;
    }
}

//Get
char* CPessoaRecusaMeioContato::getIdPessoaRecusaMeioContato()
{
        return ((char*)tTabela.sIdPessoaRecusaMeioContato.arr);
}
char* CPessoaRecusaMeioContato::getIdPessoa()
{
        return ((char*)tTabela.sIdPessoa.arr);
}
char* CPessoaRecusaMeioContato::getIdMeioContato()
{
        return ((char*)tTabela.sIdMeioContato.arr);
}
char* CPessoaRecusaMeioContato::getDescricao()
{
    return ((char*)tTabela.sDescricao.arr);
}

// Metodos que operam com o Banco de Dados

//-----------------------------------------------------------------------------------------
//* Especiticacion:
//*     Nome:Incluir
//*     Parametro: none
//*     Retorno: OK = 
//*              sqlca.sqlcode = codigo de erro do proprio Oracle
//*
//-----------------------------------------------------------------------------------------
//* Purpose:
//*     
//*
//-----------------------------------------------------------------------------------------
//* Process:
//*     
//*
//-----------------------------------------------------------------------------------------
int CPessoaRecusaMeioContato::Incluir()
{
struct sqlca sqlca;

    /* Obtendo a sequence */
    EXEC SQL SELECT customer.pessoarecusameiocontatosq.NEXTVAL 
               INTO :tTabela.sIdPessoaRecusaMeioContato:tTabela.iIdPessoaRecusaMeioContato_ora
               FROM dual;


	EXEC SQL WHENEVER SQLERROR	goto sqlErrorLista;

    EXEC SQL 
        INSERT INTO customer.pessoarecusameiocontato
                    ( 
                         idpessoarecusameiocontato
                        ,idmeiocontato
                        ,idpessoa
						,idusuarioalteracao
						,dtultimaalteracao
                    )
            VALUES ( 
                         :tTabela.sIdPessoaRecusaMeioContato:tTabela.iIdPessoaRecusaMeioContato_ora
                        ,:tTabela.sIdMeioContato:tTabela.iIdMeioContato_ora
                        ,:tTabela.sIdPessoa:tTabela.iIdPessoa_ora
						,:sIdUsuarioAlteracao
						,SYSDATE
                    );

    if (sqlca.sqlerrd[2] == 0 )
        return NOK;
    else
        return OK;

	sqlErrorLista:
		throw TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

//-----------------------------------------------------------------------------------------
//* Especiticacion:
//*     Nome: Excluir
//*     Parametro: none
//*     Retorno: OK = 
//*              sqlca.sqlcode = codigo de erro do proprio Oracle
//*
//-----------------------------------------------------------------------------------------
//* Purpose:
//*     
//*
//-----------------------------------------------------------------------------------------
//* Process:
//*     
//*
//-----------------------------------------------------------------------------------------
int CPessoaRecusaMeioContato::Excluir()
{
struct sqlca sqlca;

	EXEC SQL WHENEVER SQLERROR	goto sqlErrorLista;

    /* Deleta os pais */
    EXEC SQL DELETE FROM customer.pessoarecusameiocontato
                   WHERE idpessoarecusameiocontato = :tTabela.sIdPessoaRecusaMeioContato;
  
    if (sqlca.sqlerrd[2] == 0 )
        return NOK;
    else
        return OK;

	sqlErrorLista:
		throw TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}


//-----------------------------------------------------------------------------------------
//* Especiticacion:
//*     Nome:
//*     Parametro:
//*     Retorno: OK = 
//*              sqlca.sqlcode = codigo de erro do proprio Oracle
//*
//-----------------------------------------------------------------------------------------
//* Purpose:
//*     
//*
//-----------------------------------------------------------------------------------------
//* Process:
//*     
//*
//-----------------------------------------------------------------------------------------
int CPessoaRecusaMeioContato::Alterar()
{
    return OK;
}


//-----------------------------------------------------------------------------------------
//* Especiticacion:
//*     Nome: RecuperarTodos
//*     Parametro:
//*     Retorno: OK = 
//*              sqlca.sqlcode = codigo de erro do proprio Oracle
//*
//-----------------------------------------------------------------------------------------
//* Purpose: Lista todas as linhas da tabela PessoaRecusaMeioContato
//*
//-----------------------------------------------------------------------------------------
//* Process: Lista todas as linha da tabela e retorna um ponteiro com os objetos.
//*
//-----------------------------------------------------------------------------------------
CPessoaRecusaMeioContato* CPessoaRecusaMeioContato::RecuperarTodos(int* iNroObjetos)
{
struct sqlca sqlca;

	CPessoaRecusaMeioContato* oLocal = NULL;
	int iNroObjLocal = 1;

	EXEC SQL BEGIN DECLARE SECTION;
        TTABELA tSt;
	EXEC SQL END DECLARE SECTION;

    memset(&tSt, 0x00, sizeof(tSt));

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL DECLARE cPRMC CURSOR FOR
            SELECT idpessoarecusameiocontato
                  ,idmeiocontato
                  ,idpessoa
             FROM customer.pessoarecusameiocontato;

	EXEC SQL OPEN cPRMC;
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;; iNroObjLocal++) 
    {
		
		EXEC SQL FETCH cPRMC 
                  INTO :tSt.sIdPessoaRecusaMeioContato:tSt.iIdPessoaRecusaMeioContato_ora
                      ,:tSt.sIdPessoa:tSt.iIdPessoa_ora
                      ,:tSt.sIdMeioContato:tSt.iIdMeioContato_ora;

		// Aloca memória para o objeto atual.
		if ((oLocal = (CPessoaRecusaMeioContato*) realloc((void *)oLocal, (sizeof(CPessoaRecusaMeioContato) * iNroObjLocal))) != NULL)
        {
			oLocal[iNroObjLocal-1].setIdPessoaRecusaMeioContato((char*)tSt.sIdPessoaRecusaMeioContato.arr);
			oLocal[iNroObjLocal-1].setIdPessoa((char*)tSt.sIdPessoa.arr);
			oLocal[iNroObjLocal-1].setIdMeioContato((char*)tSt.sIdMeioContato.arr);
		} 
        else 
        {
			if (oLocal) 
                free(oLocal);

            EXEC SQL CLOSE cPRMC;
            ERROR(NRO_MEMORIA)
			throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
            EXEC SQL CLOSE cPRMC;
		}
	}

    EXEC SQL CLOSE cPRMC;

	*iNroObjetos = iNroObjLocal - 1;

	return oLocal;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
		throw TuxBasicOraException(sqlca.sqlcode);
}

//-----------------------------------------------------------------------------------------
//* Especiticacion:
//*     Nome: RecuperarPorIdPessoa
//*     Parametro:
//*     Retorno: OK = 
//*              sqlca.sqlcode = codigo de erro do proprio Oracle
//*
//-----------------------------------------------------------------------------------------
//* Purpose: Lista todas as linhas da tabela PessoaRecusaMeioContato
//*
//-----------------------------------------------------------------------------------------
//* Process: Lista todas as linha da tabela e retorna um ponteiro com os objetos.
//*          Tendo como condicao a IdPessoa.
//*
//-----------------------------------------------------------------------------------------
CPessoaRecusaMeioContato* CPessoaRecusaMeioContato::RecuperarPorIdPessoa(int* iNroObjetos, char* pParam)
{
struct sqlca sqlca;

CPessoaRecusaMeioContato* oLocal = NULL;
int iNroObjLocal = 1;

	EXEC SQL BEGIN DECLARE SECTION;
        TTABELA tSt;
        VARCHAR sID[LEN_NUMBER+LEN_EOS];
	EXEC SQL END DECLARE SECTION;

    memset(&tSt, 0x00, sizeof(tSt));
    STRCPY_TO_ORA(sID, pParam);

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL DECLARE cC1 CURSOR FOR
	SELECT 
	    MEIOCONTATO.IDMEIOCONTATO
	   ,MEIOCONTATO.DSMEIOCONTATO
	FROM 
	    CUSTOMER.PESSOARECUSAMEIOCONTATO PESSOARECUSAMEIOCONTATO,
	    APOIO.MEIOCONTATO MEIOCONTATO
	WHERE PESSOARECUSAMEIOCONTATO.IDMEIOCONTATO = MEIOCONTATO.IDMEIOCONTATO
	AND PESSOARECUSAMEIOCONTATO.IDPESSOA = :sID;

	EXEC SQL OPEN cC1;
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;; iNroObjLocal++) 
    {
		EXEC SQL FETCH cC1 
                  INTO :tSt.sIdMeioContato:tSt.iIdMeioContato_ora
                      ,:tSt.sDescricao:tSt.iDescricao_ora;

		// Aloca memória para o objeto atual.
		if ((oLocal = (CPessoaRecusaMeioContato*) realloc((void *)oLocal, (sizeof(CPessoaRecusaMeioContato) * iNroObjLocal))) != NULL)
        {
			oLocal[iNroObjLocal-1].setIdMeioContato((char*)tSt.sIdMeioContato.arr);
			oLocal[iNroObjLocal-1].setDescricao((char*)tSt.sDescricao.arr);
		} 
        else 
        {
			if (oLocal) 
                free(oLocal);

            EXEC SQL CLOSE cC1;
            ERROR(NRO_MEMORIA)
			throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
		}
	}

    EXEC SQL CLOSE cC1;

	*iNroObjetos = iNroObjLocal - 1;

	return oLocal;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
		throw TuxBasicOraException(sqlca.sqlcode);
}


//-----------------------------------------------------------------------------------------
//* Especiticacion:
//*     Nome: ExcluirPorPessoa
//*     Parametro: sDado = ponteiro de char contendo o Id Pessoa
//*     Retorno: OK = delecao na base ocorrida com sucesso
//*              sqlca.sqlcode = codigo de erro do proprio Oracle
//*
//-----------------------------------------------------------------------------------------
//* Purpose: Deleta registro(s) tabela PessoaRecusaMeioContato
//*
//-----------------------------------------------------------------------------------------
//* Process: Deleta registro a partir de um IdPessoa da tabela PessoaRecusaMeioContato
//*          utilizando a view PessoaRecusaMeioContato
//*
//-----------------------------------------------------------------------------------------
int CPessoaRecusaMeioContato::ExcluirPorPessoa(char* sDado)
{
struct sqlca sqlca;

EXEC SQL BEGIN DECLARE SECTION;
    VARCHAR sIdPessoa[LEN_NUMBER + LEN_EOS];
EXEC SQL END DECLARE SECTION;

    STRCPY_TO_ORA(sIdPessoa, sDado);

	EXEC SQL WHENEVER SQLERROR	goto sqlErrorLista;
  	EXEC SQL WHENEVER NOT FOUND CONTINUE;

    /* Deleta os pais */
    EXEC SQL DELETE FROM customer.pessoarecusameiocontato
                   WHERE idpessoa = :sIdPessoa;
  
    if (sqlca.sqlerrd[2] == 0 )
        return NOK;
    else
        return OK;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
		throw TuxBasicOraException(sqlca.sqlcode);
}
