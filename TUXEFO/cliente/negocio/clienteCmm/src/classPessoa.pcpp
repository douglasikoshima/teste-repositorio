//------------------------------------------------------------------------------------------------------
#undef SQLCA
#define SQLCA_NONE
#include <sqlca.h>
#include <sqlda.h>
//------------------------------------------------------------------------------------------------------
#undef MSG_NONE
#define MSG_NONE

#include <tuxfw.h>
#include "../include/Exception.h"
//------------------------------------------------------------------------------------------------------
EXEC SQL BEGIN DECLARE SECTION;
#include "../include/Global.h"
EXEC SQL END DECLARE SECTION;
#include "../include/TString.h"
EXEC SQL INCLUDE "../include/classPessoa.h";
#include "../include/Tools.h"


//------------------------------------------------------------------------------------------------------
// Constructror
//------------------------------------------------------------------------------------------------------


CPessoa::CPessoa()
{
    memset(&tPessoa, 0x00, sizeof(tPessoa));
    iTipoPessoa = -1;
	UsuarioLinha = 0; 
}

//------------------------------------------------------------------------------------------------------
// set
//------------------------------------------------------------------------------------------------------

void CPessoa::setidUsuario(int pDado)
{
	idUsuario =  pDado;
}

//------------------------------------------------------------------------------------------------------

void CPessoa::setTipoPessoa(int pDado)
{
	iTipoPessoa =  pDado;
}

//------------------------------------------------------------------------------------------------------

void CPessoa::setIdPessoa(char *pDado)
{
	STRCPY_TO_ORA(tPessoa.sIdPessoa, pDado);
}

//------------------------------------------------------------------------------------------------------

void CPessoa::setNmPessoa(char *pDado)
{
	STRCPY_TO_ORA(tPessoa.sNmPessoa, pDado);
}

//------------------------------------------------------------------------------------------------------

void CPessoa::setDtCadastroOut(char *pDado)
{
	STRCPY_TO_ORA(tPessoa.sDtCadastroOut, pDado);
}

//------------------------------------------------------------------------------------------------------

void CPessoa::setDsEstadoCivil(char *pDado)
{
	STRCPY_TO_ORA(tPessoa.sDsEstadoCivil, pDado);
}

//------------------------------------------------------------------------------------------------------

void CPessoa::setDtNascimentoOut(char *pDado)
{
	STRCPY_TO_ORA(tPessoa.tPF.sDtNascimentoOut, pDado);
}
//------------------------------------------------------------------------------------------------------

void CPessoa::setNmPessoaFilial(char *pDado)
{
	STRCPY_TO_ORA(tPessoa.tPJ.sNmPessoaFilial, pDado);
}

//------------------------------------------------------------------------------------------------------

void CPessoa::setNmFantasia(char *pDado)
{
	STRCPY_TO_ORA(tPessoa.tPJ.sNmFantasia, pDado);
}

//------------------------------------------------------------------------------------------------------
// Get
//------------------------------------------------------------------------------------------------------

char *CPessoa::getIdPessoa()
{
    return((char*)tPessoa.sIdPessoa.arr);
}
//------------------------------------------------------------------------------------------------------
char *CPessoa::getNmPessoa()
{
    return((char*)tPessoa.sNmPessoa.arr);
}
//------------------------------------------------------------------------------------------------------
char *CPessoa::getDtCadastroOut()
{
    return((char*)tPessoa.sDtCadastroOut.arr);
}
//------------------------------------------------------------------------------------------------------
char *CPessoa::getDsEstadoCivil()
{
    return((char*)tPessoa.sDsEstadoCivil.arr);
}
//------------------------------------------------------------------------------------------------------
char *CPessoa::getDtNascimentoOut()
{
    return((char*)tPessoa.tPF.sDtNascimentoOut.arr);
}
//------------------------------------------------------------------------------------------------------
char *CPessoa::getNmPessoaFilial()
{
    return((char*)tPessoa.tPJ.sNmPessoaFilial.arr);
}
//------------------------------------------------------------------------------------------------------
char *CPessoa::getIdPessoaDePara()  
{
	return((char*)tPessoa.sIdPessoaDePara.arr);
  
}
//------------------------------------------------------------------------------------------------------
char *CPessoa::getNmFantasia()
{
    return((char*)tPessoa.tPJ.sNmFantasia.arr);
}
//------------------------------------------------------------------------------------------------------
int CPessoa::getTipoPessoa()
{

if ( iTipoPessoa >= 0 ) 
     return iTipoPessoa; 

struct sqlca sqlca;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	EXEC SQL SELECT idtipopessoa
               INTO :iTipoPessoa:iTipoPessoa_ora
               FROM customer.pessoa
              WHERE idpessoa = :tPessoa.sIdPessoa;

	return iTipoPessoa;

sqlErrorLista:
		throw TuxBasicOraException(sqlca.sqlcode);

}

//------------------------------------------------------------------------------------------------------
// Metodos 
//------------------------------------------------------------------------------------------------------

int CPessoa::Recupera()
{
	return RecuperarPorTipoPessoa(getIdPessoa());
}

//------------------------------------------------------------------------------------------------------

int CPessoa::RecuperarPorTipoPessoa(char* pCla)
{
    ULOG_START("CPessoa::RecuperarPorTipoPessoa()");
    struct sqlca sqlca;


    STRCPY_TO_ORA(tPessoa.sIdPessoa, pCla);

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	switch( getTipoPessoa() )  { 
		case FISICA:

                ULOG("FISICA");

		        EXEC SQL SELECT a.idpessoa, 
				                a.nmpessoa, 
								TO_CHAR(a.dtcadastro, 'DD/MM/YYYY') as DtCadastroOut,
								b.dsestadocivil,
								TO_CHAR(c.dtnascimento, 'DD-MM-YYYY') as dtnascimentoout
						  INTO :tPessoa.sIdPessoa:tPessoa.iIdPessoa_ora,
							   :tPessoa.sNmPessoa:tPessoa.iNmPessoa_ora,
					           :tPessoa.sDtCadastroOut:tPessoa.iDtCadastroOut_ora,
					           :tPessoa.sDsEstadoCivil:tPessoa.iDsEstadoCivil_ora,
					           :tPessoa.tPF.sDtNascimentoOut:tPessoa.tPF.iDtNascimentoOut_ora
						   FROM customer.pessoa a,
							    apoio.estadocivil b,
							    customer.pessoafisica c
						  WHERE a.idpessoa = :tPessoa.sIdPessoa
						    AND c.IDPESSOA = a.IDPESSOA
						    AND c.IDESTADOCIVIL = b.IDESTADOCIVIL;

				EXEC SQL SELECT idpessoadepara 
					 INTO :tPessoa.sIdPessoaDePara
					 FROM customer.pessoadepara
					WHERE idpessoa = :tPessoa.sIdPessoa
					  AND idpessoa = idpessoaorigem;

		break;
		case JURIDICA: 

            ULOG("JURIDICA");

				EXEC SQL SELECT a.idpessoa,
								a.nmpessoa,
								TO_CHAR(a.dtcadastro, 'DD-MM-YYYY') as dtcadastroout
		  				   INTO :tPessoa.sIdPessoa:tPessoa.iIdPessoa_ora,
					            :tPessoa.sNmPessoa:tPessoa.iNmPessoa_ora,
					            :tPessoa.sDtCadastroOut:tPessoa.iDtCadastroOut_ora
						   FROM customer.pessoa a
						  WHERE idpessoa = :tPessoa.sIdPessoa;

					EXEC SQL SELECT idpessoadepara 
					 INTO :tPessoa.sIdPessoaDePara
					 FROM customer.pessoadepara
					WHERE idpessoa = :tPessoa.sIdPessoa
					  AND idpessoa = idpessoaorigem;

					break; 
		default:
		            ULOGE("ERRO");
		            ULOG_END("CPessoa::RecuperarPorTipoPessoa()");
					return NOK; 
	}
    ULOG_END("CPessoa::RecuperarPorTipoPessoa()");
	return OK;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
		ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CPessoa::RecuperarPorTipoPessoa()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

//------------------------------------------------------------------------------------------------------

void CPessoa::SetData(TPessoaJuridicaXML xmlJ)
{
    STRCPY_TO_ORA( tPessoa.sIdPessoa,					xmlJ.idPessoa );
	STRCPY_TO_ORA( tPessoa.sIdPessoaSistemaOrigem,		xmlJ.idPessoa );
    STRCPY_TO_ORA( tPessoa.sNmPessoa,					xmlJ.nmRazaoSocial  );

	if ( *xmlJ.usuarioLinha ) 
		UsuarioLinha = atoi(xmlJ.usuarioLinha); 

	sTipoRelacionamento = xmlJ.idTipoRelacionamento; 

	STRCPY_TO_ORA( tPessoa.sIdTipopessoa,				"2" ); 
    STRCPY_TO_ORA( tPessoa.sIdUF,						"0" ); 
    STRCPY_TO_ORA( tPessoa.sInFalecimentoInformado,		"0" ); 
    STRCPY_TO_ORA( tPessoa.sIdProbInadimplencia,		"0" ); 
    STRCPY_TO_ORA( tPessoa.sIdChurnProbabilidade,		"0" ); 
    STRCPY_TO_ORA( tPessoa.sIdTipoCarteira,				xmlJ.idTipoClassificacaoEmpresaSelecionado	 ); 
	STRCPY_TO_ORA( tPessoa.sIdSistemaOrigem,			"7");
    
}
//------------------------------------------------------------------------------------------------------

void CPessoa::GetData(TPessoaFisicaXML *xmlPF)
{
    STRCPY_FROM_ORA(xmlPF->idPessoa,     tPessoa.sIdPessoa);
    STRCPY_FROM_ORA(xmlPF->dsNome,       tPessoa.sNmPessoa);
//	STRCPY_FROM_ORA(xmlPF.idTipoPessoa, tPessoa.sIdTipopessoa);
}

//------------------------------------------------------------------------------------------------------

void CPessoa::SetData(TPessoaFisicaXML xmlJ)
{
	TDesmembraNome dn;


	strcpy( dn.szNomeCompleto, xmlJ.dsNome ); 

	DesmembraNome(&dn);

    STRCPY_TO_ORA( tPessoa.sIdPessoa,					xmlJ.idPessoa );
	STRCPY_TO_ORA( tPessoa.sIdPessoaSistemaOrigem,		xmlJ.idPessoa );
    STRCPY_TO_ORA( tPessoa.sNmPessoa,					dn.szNomeCompleto  );	
    STRCPY_TO_ORA( tPessoa.sNmNome,						dn.szNomePrimeiro  );
    STRCPY_TO_ORA( tPessoa.sNmNomemeio,					dn.szNomeMeio ); 
    STRCPY_TO_ORA( tPessoa.sNmSobrenome,				dn.szNomeFim ); 

	if ( *xmlJ.inUsuarioLinha ) 
		UsuarioLinha = atoi(xmlJ.inUsuarioLinha); 

	sTipoRelacionamento = xmlJ.idTipoRelacionamento; 

	STRCPY_TO_ORA( tPessoa.sIdTipopessoa,				"1" ); 
    STRCPY_TO_ORA( tPessoa.sIdUF,						"0" ); 
    STRCPY_TO_ORA( tPessoa.sInFalecimentoInformado,		"0" ); 
    STRCPY_TO_ORA( tPessoa.sIdProbInadimplencia,		"0" ); 
    STRCPY_TO_ORA( tPessoa.sIdChurnProbabilidade,		"0" ); 
    STRCPY_TO_ORA( tPessoa.sIdTipoCarteira,				"13" ); 
	STRCPY_TO_ORA( tPessoa.sIdSistemaOrigem,			"7");
	
}
//------------------------------------------------------------------------------------------------------

void CPessoa::inserePessoa()
{
    proCInserePessoa( tPessoa );  
}

//------------------------------------------------------------------------------------------------------

void CPessoa::atualizaPessoa()
{
    proCAtualizaPessoa( tPessoa );  
}

//------------------------------------------------------------------------------------------------------

void CPessoa::atualizaPessoaPorID()
{
    proCAtualizaPessoaPorID( tPessoa );  
}

//------------------------------------------------------------------------------------------------------
void CPessoa::proCInserePessoa( TPESSOA &tPessoa )
{
    ULOG_START("CPessoa::proCInserePessoa()");
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR    oszIdUsuarioAlteracao[LEN_IDUSUARIOALTERACAO];
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

	

    // copia os dados da estrutura para as variaveis ProC.
    STRCPY_TO_ORA( oszIdUsuarioAlteracao    , ID_USUARIO_ALTERACAO              );

    EXEC SQL WHENEVER SQLERROR goto erro;

    // Busca a sequence de Pessoa
    EXEC SQL SELECT Customer.PessoaSq.nextval 
               INTO :tPessoa.sIdPessoa 
               FROM DUAL;

	if( tPessoa.sIdPessoaSistemaOrigem.len == 0 )
	{
		char s[256]={NULL}; 
		STRCPY_FROM_ORA( s, tPessoa.sIdPessoa );   
		STRCPY_TO_ORA( tPessoa.sIdPessoaSistemaOrigem, s );   
	}

    // Insere na tabela Pessoa
    EXEC SQL INSERT INTO Customer.Pessoa
                       ( idpessoa
                       , idsistemaorigem
                       , idpessoasistemaorigem
                       , nmpessoa
                       , nmnome
                       , nmnomemeio
                       , nmsobrenome
                       , dtchurn
                       , infalecimentoinformado
                       , dtfalecimento
                       , idtipopessoa
                       , idtipocarteira
                       , iduf
                       , vlrchurnprobabilidade
                       , dttipocarteira
                       , idprobinadimplencia
                       , idchurnprobabilidade
                       , dtcadastro
                       , dscargocontato
                       , dsdeptocontato
                       , idusuarioalteracao
                       , dtultimaalteracao )
                VALUES ( :tPessoa.sIdPessoa
                       , :tPessoa.sIdSistemaOrigem
                       , :tPessoa.sIdPessoa
                       , :tPessoa.sNmPessoa
                       , :tPessoa.sNmNome
                       , :tPessoa.sNmNomemeio
                       , :tPessoa.sNmSobrenome
                       , TO_DATE( :tPessoa.sDtChurn, 'YYYYMMDDHH24MISS')
                       , :tPessoa.sInFalecimentoInformado
                       , TO_DATE( :tPessoa.sDtFalecimento, 'YYYYMMDDHH24MISS')
                       , :tPessoa.sIdTipopessoa
                       , :tPessoa.sIdTipoCarteira
                       , :tPessoa.sIdUF
                       , :tPessoa.sIdChurnProbabilidade
                       , TO_DATE( :tPessoa.sDtTipoCarteira, 'YYYYMMDDHH24MISS')
                       , :tPessoa.sIdProbInadimplencia
                       , :tPessoa.sIdChurnProbabilidade
                       , SYSDATE
                       , :tPessoa.sDsCargoContato
                       , :tPessoa.sDsDeptoContato
                       , :oszIdUsuarioAlteracao
                       , SYSDATE );

    // Busca a sequence de PessoaDePara
    EXEC SQL SELECT Customer.PessoaDeParasq.nextval 
               INTO :tPessoa.sIdPessoaDePara 
               FROM DUAL;

    EXEC SQL INSERT INTO Customer.PessoaDePara
                       ( idpessoadepara
                       , idpessoa
                       , idpessoaorigem
                       , idusuarioalteracao
                       , dtultimaalteracao )
                VALUES ( :tPessoa.sIdPessoaDePara
                       , :tPessoa.sIdPessoa
                       , :tPessoa.sIdPessoa
                       , :oszIdUsuarioAlteracao
                       , SYSDATE );

	ULOG_END("CPessoa::proCInserePessoa()");
    return;

    erro:
    	ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    	ULOG_END("CPessoa::proCInserePessoa()");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

/****************************************************************************************/

void CPessoa::proCAtualizaPessoa( TPESSOA &tPessoa )
{
    ULOG_START("CPessoa::proCAtualizaPessoa()");
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR    oszIdUsuarioAlteracao[LEN_IDUSUARIOALTERACAO];
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

	/* copia os dados da estrutura para as variaveis ProC */

    STRCPY_TO_ORA( oszIdUsuarioAlteracao    , ID_USUARIO_ALTERACAO              );

    EXEC SQL WHENEVER SQLERROR  goto erro;
    EXEC SQL WHENEVER NOT FOUND goto erro;

    // Atualiza a tabela Pessoa
    EXEC SQL UPDATE Customer.Pessoa
                SET idPessoa			    = :tPessoa.sIdPessoa
                  , idsistemaorigem         = :tPessoa.sIdSistemaOrigem
                  , idpessoasistemaorigem   = :tPessoa.sIdPessoaSistemaOrigem
                  , nmpessoa                = :tPessoa.sNmPessoa
                  , nmnome                  = :tPessoa.sNmNome
                  , nmnomemeio              = :tPessoa.sNmNomemeio
                  , nmsobrenome             = :tPessoa.sNmSobrenome
                  , dtchurn                 = TO_DATE(:tPessoa.sDtChurn, 'YYYYMMDDHH24MISS')
                  , infalecimentoinformado  = :tPessoa.sInFalecimentoInformado
                  , dtfalecimento           = TO_DATE(:tPessoa.sDtFalecimento, 'YYYYMMDDHH24MISS')
                  , idtipocarteira          = :tPessoa.sIdTipoCarteira
                  , idprobinadimplencia     = :tPessoa.sIdProbInadimplencia
                  , idchurnprobabilidade    = :tPessoa.sIdChurnProbabilidade
                  , dscargocontato          = :tPessoa.sDsCargoContato
                  , dsdeptocontato          = :tPessoa.sDsDeptoContato
                  , idusuarioalteracao      = :oszIdUsuarioAlteracao
                  , dtultimaalteracao       = SYSDATE
              WHERE idsistemaorigem         = TO_NUMBER( :tPessoa.sIdSistemaOrigem )
                AND idpessoasistemaorigem   = :tPessoa.sIdPessoaSistemaOrigem; 

	ULOG_END("CPessoa::proCAtualizaPessoa()");
    return;

    erro:
        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
        ULOG_END("CPessoa::proCAtualizaPessoa()");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

/****************************************************************************************/

void CPessoa::proCAtualizaPessoaPorID( TPESSOA &tPessoa )
{
    ULOG_START("CPessoa::proCAtualizaPessoaPorID()");
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR    oszIdUsuarioAlteracao[LEN_IDUSUARIOALTERACAO];
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

	/* copia os dados da estrutura para as variaveis ProC */

    STRCPY_TO_ORA( oszIdUsuarioAlteracao    , ID_USUARIO_ALTERACAO );

    EXEC SQL WHENEVER SQLERROR  goto erro;
    EXEC SQL WHENEVER NOT FOUND goto erro;

    // Atualiza a tabela Pessoa
    EXEC SQL UPDATE Customer.Pessoa
                SET idPessoa			    = :tPessoa.sIdPessoa
                  , idsistemaorigem         = :tPessoa.sIdSistemaOrigem
                  , idpessoasistemaorigem   = :tPessoa.sIdPessoaSistemaOrigem
                  , nmpessoa                = :tPessoa.sNmPessoa
                  , nmnome                  = :tPessoa.sNmNome
                  , nmnomemeio              = :tPessoa.sNmNomemeio
                  , nmsobrenome             = :tPessoa.sNmSobrenome
                  , dtchurn                 = TO_DATE(:tPessoa.sDtChurn, 'DD/MM/YYYY')
                  , infalecimentoinformado  = :tPessoa.sInFalecimentoInformado
                  , dtfalecimento           = TO_DATE(:tPessoa.sDtFalecimento, 'DD/MM/YYYY')
                  , idtipocarteira          = :tPessoa.sIdTipoCarteira
                  , idprobinadimplencia     = :tPessoa.sIdProbInadimplencia
                  , idchurnprobabilidade    = :tPessoa.sIdChurnProbabilidade
                  , dscargocontato          = :tPessoa.sDsCargoContato
                  , dsdeptocontato          = :tPessoa.sDsDeptoContato
                  , idusuarioalteracao      = :oszIdUsuarioAlteracao
                  , dtultimaalteracao       = SYSDATE
              WHERE idPessoa			    = :tPessoa.sIdPessoa;
                

	ULOG_END("CPessoa::proCAtualizaPessoaPorID()");
    return;

    erro:
    	ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    	ULOG_END("CPessoa::proCAtualizaPessoaPorID()");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}


void CPessoa::proCInsereSegmentacao()
{
   
    ULOG_START("CPessoa::proCInsereSegmentacao()");
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR    oszIdUsuarioAlteracao[LEN_IDUSUARIOALTERACAO];
		VARCHAR    oIdSegmentacao[64];
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

	

    // copia os dados da estrutura para as variaveis ProC.

    STRCPY_TO_ORA( oszIdUsuarioAlteracao    , ID_USUARIO_ALTERACAO );

    EXEC SQL WHENEVER SQLERROR goto erro;

    EXEC SQL SELECT Customer.PESSOASEGMENTACAOHISTORICOSQ.nextval 
               INTO :oIdSegmentacao
               FROM DUAL;

    EXEC SQL INSERT INTO Customer.PESSOASEGMENTACAOHISTORICO
                       ( 
						 IDPESSOASEGMENTACAO    
						,IDPESSOADEPARA         
						,IDSEGMENTACAO          
						,VLRENTABILIDADE        
						,DTSEGMENTACAO          
						,DTRENTABILIDADE        
						,IDUSUARIOALTERACAO     
						,DTULTIMAALTERACAO      
					  )
					  VALUES 
					  ( 
						 :oIdSegmentacao
                       , :tPessoa.sIdPessoaDePara
                       , 11
                       , 0
                       , SYSDATE
                       , SYSDATE
                       , :oszIdUsuarioAlteracao
                       , SYSDATE );


    EXEC SQL INSERT INTO Customer.PESSOASEGMENTACAO
                       ( 
						  IDPESSOADEPARA         
						 ,IDPESSOASEGMENTACAO    
						 ,IDUSUARIOALTERACAO     
						 ,DTULTIMAALTERACAO      
					) 
						VALUES
						(
						 :tPessoa.sIdPessoaDePara
						,:oIdSegmentacao
						,:oszIdUsuarioAlteracao
						,SYSDATE ); 


	ULOG_END("CPessoa::proCInsereSegmentacao()");
    return;

    erro:
    	ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    	ULOG_END("CPessoa::proCInsereSegmentacao()");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

/****************************************************************************************/
