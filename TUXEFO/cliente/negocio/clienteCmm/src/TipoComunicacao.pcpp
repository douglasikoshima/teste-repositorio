// TipoComunicacao.pcpp: implementation for the 
// CTipoComunicacao class.
//////////////////////////////////////////////////////////////////////

/*
 * Task force to seek potential memory leaks and exception errors - March,2005 - Cassio
 */

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw.h>
#include "../include/Global.h"
EXEC SQL INCLUDE "../include/TipoComunicacao.h";

//
// Construtor e Destrutor
CTipoComunicacao::CTipoComunicacao() {

	memset(sIdUsuarioAlteracao,0,256);
}

CTipoComunicacao::CTipoComunicacao(int iIdTipoCorr) {

    ULOG_START("CTipoComunicacao::CTipoComunicacao()"); 
	struct sqlca sqlca;

	iIdTipoComunicacao = iIdTipoCorr;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL SELECT
	 SgTipoComunicacao,
	 DsTipoComunicacao
	INTO
    :cSgTipoComunicacao,
    :cDsTipoComunicacao
	FROM
	 apoio.TipoComunicacao
	WHERE
	 IdTipoComunicacao = :iIdTipoComunicacao;

	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND)
		iIdTipoComunicacao = -1;

	ULOG_END("CTipoComunicacao::CTipoComunicacao()"); 
	return;

	sqlErrorConstrutor:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
	    ULOG_END("CTipoComunicacao::CTipoComunicacao()"); 
		throw TuxBasicOraException(sqlca.sqlcode);
}

CTipoComunicacao::~CTipoComunicacao() {
}

// Usuário de alteração
void CTipoComunicacao::setUsuarioAlteracao(char* value) {
	if (value != NULL) {
		strncpy(sIdUsuarioAlteracao,value, 255);
		sIdUsuarioAlteracao[255]='\0';
	}
}

//
// Metodos getter
int CTipoComunicacao::getIdTipoComunicacao(){
	return iIdTipoComunicacao;
}

char* CTipoComunicacao::getSgTipoComunicacao(){
	return cSgTipoComunicacao;
}

char* CTipoComunicacao::getDsTipoComunicacao(){
	return cDsTipoComunicacao;
}

//
// Metodos setter
void CTipoComunicacao::setIdTipoComunicacao(int value){
	iIdTipoComunicacao = value;
}

void CTipoComunicacao::setSgTipoComunicacao(char* value){
    strncpy(cSgTipoComunicacao, value?value:"", 255);
	cSgTipoComunicacao[255]='\0';
}

void CTipoComunicacao::setDsTipoComunicacao(char* value){
	strncpy(cDsTipoComunicacao, value?value:"", 255);
	cDsTipoComunicacao[255]='\0';
}

//
// Métodos de acesso a banco de dados
void CTipoComunicacao::inclui(){

    ULOG_START("CTipoComunicacao::inclui()"); 
    
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		int iNovoId;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorInc;

	// Busca o novo ID da sequence.
	EXEC SQL
		SELECT apoio.TipoComunicacaoSQ.NEXTVAL
		INTO :iNovoId
		FROM DUAL;
	if (sqlca.sqlcode)
	{
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
	    ULOG_END("CTipoComunicacao::inclui()"); 
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	// Insere no banco de dados
	EXEC SQL
	INSERT INTO apoio.TipoComunicacao
	(IdTipoComunicacao,
	 SgTipoComunicacao,
	 DsTipoComunicacao,
	 IdUsuarioAlteracao,
	 DtUltimaAlteracao)
	VALUES
	(:iNovoId,
	 :cSgTipoComunicacao,
	 :cDsTipoComunicacao,
	 :sIdUsuarioAlteracao,
	 SYSDATE);

	// Inserção OK, coloca o ID no objeto
	iIdTipoComunicacao = iNovoId;

	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorInc:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
	    ULOG_END("CTipoComunicacao::inclui()"); 
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CTipoComunicacao::exclui(){
    ULOG_START("CTipoComunicacao::exclui()"); 
	struct sqlca sqlca;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorExc;

	// Remove do banco de dados
	EXEC SQL
	DELETE apoio.TipoComunicacao
	WHERE IdTipoComunicacao = :iIdTipoComunicacao;

	// Remoção OK, seta ID do objeto para -1
	iIdTipoComunicacao = -1;

	ULOG_END("CTipoComunicacao::exclui()");
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorExc:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
	    ULOG_END("CTipoComunicacao::exclui()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CTipoComunicacao::altera(){

	ULOG_START("CTipoComunicacao::altera()");
	struct sqlca sqlca;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorAlt;

	// Altera no banco de dados para os dados atuais
	EXEC SQL
	UPDATE apoio.TipoComunicacao
	SET
	 SgTipoComunicacao = :cSgTipoComunicacao,
	 DsTipoComunicacao = :cDsTipoComunicacao,
	 IdUsuarioAlteracao = :sIdUsuarioAlteracao,
	 DtUltimaAlteracao = SYSDATE
	WHERE
	 IdTipoComunicacao = :iIdTipoComunicacao;

	ULOG_END("CTipoComunicacao::altera()");
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorAlt:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
	    ULOG_END("CTipoComunicacao::altera()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

CTipoComunicacao* CTipoComunicacao::lista(int* iNroObjetos){

	ULOG_START("CTipoComunicacao::lista()");
	struct sqlca sqlca;
	CTipoComunicacao* listaComunic = NULL;
	int iNroObjLocal = 1;

	EXEC SQL BEGIN DECLARE SECTION;
	    int iIdComunic;
	    char cSgComunic[256];
	    char cDsComunic[256];
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL DECLARE motivos CURSOR FOR
        SELECT
            IDTIPOCOMUNICACAO,
            SGTIPOCOMUNICACAO,
            DSTIPOCOMUNICACAO
        FROM
            APOIO.TIPOCOMUNICACAO
        ORDER BY UPPER(DSTIPOCOMUNICACAO);

	EXEC SQL OPEN motivos;

	// Corre os dados e monta a lista de objetos
	EXEC SQL WHENEVER NOT FOUND DO break;
	for (;; iNroObjLocal++) {

        memset(cSgComunic, 0x00, sizeof(cSgComunic));
        memset(cDsComunic, 0x00, sizeof(cDsComunic));

		EXEC SQL FETCH motivos INTO
		 :iIdComunic,
		 :cSgComunic,
		 :cDsComunic;

		// Aloca memória para o objeto atual.
		if ((listaComunic = (CTipoComunicacao*) 
                                realloc((void *)listaComunic, 
                                    (sizeof(CTipoComunicacao) * iNroObjLocal))) != NULL) {

			// Coloca os dados do objeto atual.
			listaComunic[iNroObjLocal-1].setIdTipoComunicacao(iIdComunic);
			listaComunic[iNroObjLocal-1].setSgTipoComunicacao(cSgComunic);
			listaComunic[iNroObjLocal-1].setDsTipoComunicacao(cDsComunic);

		} else
        {
			if (listaComunic) free(listaComunic);

            EXEC SQL CLOSE motivos;

			ULOG_END("CTipoComunicacao::lista()");	
			throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
		}
	}

    EXEC SQL CLOSE motivos;

	*iNroObjetos = iNroObjLocal - 1;
	ULOG_END("CTipoComunicacao::lista()");
	return listaComunic;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
	    ULOG_END("CTipoComunicacao::lista()");
		throw TuxBasicOraException(sqlca.sqlcode);
}