// PessoaSegmentacaoHistorico.pcpp: implementation for the 
// CPessoaSegmentacaoHistorico class.
//////////////////////////////////////////////////////////////////////

//*
//* Review:
//*
//* Task force to seek potential memory leaks and exception errors - March,2005 - Cassio

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw.h>
EXEC SQL INCLUDE "../include/PessoaSegmentacaoHistorico.h";

//
// Construtor e Destrutor
CPessoaSegmentacaoHistorico::CPessoaSegmentacaoHistorico() {
 	iiVlRentabilidade = -1;
 	icDtSegmentacao = -1;
 	icDtRentabilidade = -1;
	icDsSegmentacao = -1;
}

CPessoaSegmentacaoHistorico::~CPessoaSegmentacaoHistorico() {
}

//
// Metodos getter
long CPessoaSegmentacaoHistorico::getIdPessoaSegmentacao(){
	return iIdPessoaSegmentacao;
}

long CPessoaSegmentacaoHistorico::getIdPessoaDePara(){
	return iIdPessoaDePara;
}

int CPessoaSegmentacaoHistorico::getIdSegmentacao(){
	return iIdSegmentacao;
}

int* CPessoaSegmentacaoHistorico::getVlRentabilidade(){
	if (iiVlRentabilidade < 0)
		return NULL;
	else
		return &iVlRentabilidade;
}

char* CPessoaSegmentacaoHistorico::getDtSegmentacao(){
	if (icDtSegmentacao < 0)
		return NULL;
	else
		return cDtSegmentacao;
}

char* CPessoaSegmentacaoHistorico::getDtRentabilidade(){
	if (icDtRentabilidade < 0)
		return NULL;
	else
		return cDtRentabilidade;
}

char* CPessoaSegmentacaoHistorico::getDsSegmentacao(){
	if (icDsSegmentacao < 0)
		return NULL;
	else
		return cDsSegmentacao;
}

//
// Metodos setter
void CPessoaSegmentacaoHistorico::setIdPessoaSegmentacao(long value){
	iIdPessoaSegmentacao = value;
}

void CPessoaSegmentacaoHistorico::setIdPessoaDePara(long value){
	iIdPessoaDePara = value;
}

void CPessoaSegmentacaoHistorico::setIdSegmentacao(int value){
	iIdSegmentacao = value;
}

void CPessoaSegmentacaoHistorico::setVlRentabilidade(int* value){
	if (value == NULL)
		iiVlRentabilidade = -1;
	else {
		iVlRentabilidade = *value;
		iiVlRentabilidade = *value;
	}
}

void CPessoaSegmentacaoHistorico::setDtSegmentacao(char* value){
	if (value == NULL)
		icDtSegmentacao = -1;
	else {
		strncpy(cDtSegmentacao, value, 10);
		cDtSegmentacao[10]='\0';
		icDtSegmentacao = strlen(value);
	}
}

void CPessoaSegmentacaoHistorico::setDtRentabilidade(char* value){
	if (value == NULL)
		icDtRentabilidade = -1;
	else {
		strncpy(cDtRentabilidade, value, 10);
		cDtRentabilidade[10]='\0';
		icDtRentabilidade = strlen(value);
	}
}

void CPessoaSegmentacaoHistorico::setDsSegmentacao(char* value){
	if (value == NULL)
		icDsSegmentacao = -1;
	else {
		strncpy(cDsSegmentacao, value, 255);
		cDsSegmentacao[255]='\0';
		icDsSegmentacao = strlen(value);
	}
}

//
// Métodos de acesso a banco de dados
CPessoaSegmentacaoHistorico* CPessoaSegmentacaoHistorico::listaPorIdPessoa(long iIdPess, int* iNroObjetos) {

	ULOG_START("CPessoaSegmentacaoHistorico::listaPorIdPessoa()");
	struct sqlca sqlca;
	CPessoaSegmentacaoHistorico* listaPessoaSegHist = NULL;
	int iNroObjLocal = 1;
    char szDsSegmentacao[256 + 1];

	EXEC SQL BEGIN DECLARE SECTION;
	// Entrada
	long iIdPessoa;

	// Campos
 	long iIdPessoaSegmentacao;
	long iIdPessoaDePara;
 	int iIdSegmentacao;
 	int iVlRentabilidade;
 	char cDtSegmentacao[11];
 	char cDtRentabilidade[11];
	char cDsSegmentacao[256];
 
 	// Variáveis de indicação do oracle
 	short iiVlRentabilidade;
 	short icDtSegmentacao;
 	short icDtRentabilidade;
	short icDsSegmentacao;

    VARCHAR oszDsSegmentacao[256];
	EXEC SQL END DECLARE SECTION;

	iIdPessoa = iIdPess;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL DECLARE pessSegHist CURSOR FOR
	SELECT
	 	 PESSOASEGMENTACAOHISTORICO.IDPESSOASEGMENTACAO,
		 PESSOADEPARA.IDPESSOADEPARA,
	 	 PESSOASEGMENTACAOHISTORICO.IDSEGMENTACAO,
	 	 PESSOASEGMENTACAOHISTORICO.VLRENTABILIDADE,
	 	 TO_CHAR(PESSOASEGMENTACAOHISTORICO.DTSEGMENTACAO, 'DD/MM/YYYY'),
	 	 PESSOASEGMENTACAOHISTORICO.DTRENTABILIDADE,
		 SEGMENTACAO.DSSEGMENTACAO
	FROM
	    CUSTOMER.PESSOADEPARA PESSOADEPARA,
	    CUSTOMER.PESSOASEGMENTACAOHISTORICO PESSOASEGMENTACAOHISTORICO,
	    APOIO.SEGMENTACAO SEGMENTACAO
	WHERE PESSOADEPARA.IDPESSOADEPARA = PESSOASEGMENTACAOHISTORICO.IDPESSOADEPARA
	AND   PESSOASEGMENTACAOHISTORICO.IDSEGMENTACAO = SEGMENTACAO.IDSEGMENTACAO
	AND   PESSOADEPARA.IDPESSOA = :iIdPessoa
	ORDER BY PESSOASEGMENTACAOHISTORICO.DTSEGMENTACAO;

	EXEC SQL OPEN pessSegHist;

	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;; iNroObjLocal++) {
		
		EXEC SQL FETCH pessSegHist INTO
 		 iIdPessoaSegmentacao,
		 iIdPessoaDePara,
 		 iIdSegmentacao,
 		 iVlRentabilidade:iiVlRentabilidade,
 		 cDtSegmentacao:icDtSegmentacao,
 		 cDtRentabilidade:icDtRentabilidade,
		 cDsSegmentacao:icDsSegmentacao;

		// Aloca memória para o objeto atual.
		if ((listaPessoaSegHist = (CPessoaSegmentacaoHistorico*) 
                realloc((void *)listaPessoaSegHist, 
                        (sizeof(CPessoaSegmentacaoHistorico) * iNroObjLocal))) != NULL) {
			int index = iNroObjLocal-1;
			// Coloca os dados do objeto atual.
			listaPessoaSegHist[index].setIdPessoaSegmentacao(iIdPessoaSegmentacao);
			listaPessoaSegHist[index].setIdPessoaDePara(iIdPessoaDePara);
			listaPessoaSegHist[index].setIdSegmentacao(iIdSegmentacao);
			listaPessoaSegHist[index].setVlRentabilidade(iiVlRentabilidade < 0 ? NULL : &iVlRentabilidade);
			listaPessoaSegHist[index].setDtSegmentacao(icDtSegmentacao < 0 ? NULL : cDtSegmentacao);
			listaPessoaSegHist[index].setDtRentabilidade(icDtRentabilidade < 0 ? NULL : cDtRentabilidade);
			listaPessoaSegHist[index].setDsSegmentacao(icDsSegmentacao < 0 ? NULL : cDsSegmentacao);

		} else {
			if (listaPessoaSegHist)
				free(listaPessoaSegHist);
				
			ULOG_START("CPessoaSegmentacaoHistorico::listaPorIdPessoa()");
			throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
		}
	}

    ULOG("iNroObjLocal(%d)", iNroObjLocal);


    /* MANOBRA PARA CONTORNAR O PROBLEMA DE SEGMENTACAO */
    if(iNroObjLocal == 1) {

    	EXEC SQL WHENEVER NOT FOUND goto sqlErrorLista;

        EXEC SQL
            SELECT dssegmentacao
                INTO :oszDsSegmentacao
                FROM apoio.segmentacao
                WHERE sgsegmentacao = '-1';

        ULOG("oszDsSegmentacao.arr[%.*s](%d)", oszDsSegmentacao.len, oszDsSegmentacao.arr, oszDsSegmentacao.len);

        memset(szDsSegmentacao, 0x00, sizeof(szDsSegmentacao));
        memcpy(szDsSegmentacao, oszDsSegmentacao.arr, oszDsSegmentacao.len);

        ULOG("szDsSegmentacao[%s]", szDsSegmentacao);

                        
		if ((listaPessoaSegHist = (CPessoaSegmentacaoHistorico*) 
                realloc((void *)listaPessoaSegHist, 
                        (sizeof(CPessoaSegmentacaoHistorico) * iNroObjLocal))) != NULL) {
			int index = iNroObjLocal-1;

			// Coloca os dados do objeto atual.
			listaPessoaSegHist[index].setIdPessoaSegmentacao(0);
			listaPessoaSegHist[index].setIdPessoaDePara(0);
			listaPessoaSegHist[index].setIdSegmentacao(0);
			listaPessoaSegHist[index].setVlRentabilidade(0);
			listaPessoaSegHist[index].setDtSegmentacao("");
			listaPessoaSegHist[index].setDtRentabilidade("");
			listaPessoaSegHist[index].setDsSegmentacao(szDsSegmentacao);

		} else {
			if (listaPessoaSegHist)
				free(listaPessoaSegHist);
			throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
		}

        iNroObjLocal++;
    }

	*iNroObjetos = iNroObjLocal - 1;
	ULOG_END("CPessoaSegmentacaoHistorico::listaPorIdPessoa()");
	return listaPessoaSegHist;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CPessoaSegmentacaoHistorico::listaPorIdPessoa()");
		throw TuxBasicOraException(sqlca.sqlcode);
}