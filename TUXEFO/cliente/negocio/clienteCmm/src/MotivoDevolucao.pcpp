// MotivoDevolucao.pcpp: implementation for the 
// CMotivoDevolucao class.
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw.h>
#include "../include/Global.h"
EXEC SQL INCLUDE "../include/MotivoDevolucao.h";

//
// Construtor e Destrutor
CMotivoDevolucao::CMotivoDevolucao() {
	icSgMotivoDevolucao = -1;
	icDsMotivoDevolucao = -1;
	
	memset(sIdUsuarioAlteracao,0,256);
}

CMotivoDevolucao::CMotivoDevolucao(int iIdMotDev) {
    
    ULOG_START("CMotivoDevolucao::CMotivoDevolucao()");

	struct sqlca sqlca;

	iIdMotivoDevolucao = iIdMotDev;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL SELECT
	 SgMotivoDevolucao,
	 DsMotivoDevolucao,
	 InDisponibilidade
	INTO
	 cSgMotivoDevolucao:icSgMotivoDevolucao,
	 cDsMotivoDevolucao:icDsMotivoDevolucao,
	 iInDisponibilidade
	FROM
	 apoio.MotivoDevolucao
	WHERE
	 IdMotivoDevolucao = :iIdMotivoDevolucao;

	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND)
		iIdMotivoDevolucao = -1;

    ULOG_END("CMotivoDevolucao::CMotivoDevolucao()");
	return;

	sqlErrorConstrutor:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CMotivoDevolucao::CMotivoDevolucao()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

CMotivoDevolucao::~CMotivoDevolucao() {
}

// Usuário de alteração
void CMotivoDevolucao::setUsuarioAlteracao(char* value) {
	if (value != NULL) {
		strncpy(sIdUsuarioAlteracao,value, 255);
		sIdUsuarioAlteracao[255]='\0';
	}
}

//
// Metodos getter
int CMotivoDevolucao::getIdMotivoDevolucao(){
	return iIdMotivoDevolucao;
}

char* CMotivoDevolucao::getSgMotivoDevolucao(){
	if (icSgMotivoDevolucao < 0)
		return NULL;
	else
		return cSgMotivoDevolucao;
}

char* CMotivoDevolucao::getDsMotivoDevolucao(){
	if (icDsMotivoDevolucao < 0)
		return NULL;
	else
		return cDsMotivoDevolucao;
}

int CMotivoDevolucao::getInDisponibilidade(){
	return iInDisponibilidade;
}

//
// Metodos setter
void CMotivoDevolucao::setIdMotivoDevolucao(int value){
	iIdMotivoDevolucao = value;
}

void CMotivoDevolucao::setSgMotivoDevolucao(char* value){
	if (value == NULL)
		icSgMotivoDevolucao = -1;
	else {
		strncpy(cSgMotivoDevolucao, value, 255);
		cSgMotivoDevolucao[255]='\0';
		icSgMotivoDevolucao = strlen(value);
	}
}

void CMotivoDevolucao::setDsMotivoDevolucao(char* value){
	if (value == NULL)
		icDsMotivoDevolucao = -1;
	else {
		strncpy(cDsMotivoDevolucao, value, 255);
		cDsMotivoDevolucao[255]='\0';
		icDsMotivoDevolucao = strlen(value);
	}
}

void CMotivoDevolucao::setInDisponibilidade(int value){
	iInDisponibilidade = value;
}

//
// Métodos de acesso a banco de dados
int CMotivoDevolucao::inclui(){

	ULOG_START("CMotivoDevolucao::inclui()");
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		int iNovoId;
        int iTemRegistro;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorInc;

    //Verificando se o registro existe
	EXEC SQL SELECT count(1)
               INTO :iTemRegistro
               FROM apoio.MotivoDevolucao
              WHERE upper(dsmotivodevolucao) = upper(:cDsMotivoDevolucao)
                 OR upper(sgmotivodevolucao) = upper(:cSgMotivoDevolucao);

    if (iTemRegistro)
        return DUPLICATE_KEY;


	// Busca o novo ID da sequence.
	EXEC SQL
		SELECT apoio.MotivoDevolucaoSQ.NEXTVAL
		INTO :iNovoId
		FROM DUAL;
	if (sqlca.sqlcode)
	{
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CMotivoDevolucao::inclui()");
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	// Insere no banco de dados
	EXEC SQL
	INSERT INTO apoio.MotivoDevolucao
	(IdMotivoDevolucao,
	 SgMotivoDevolucao,
	 DsMotivoDevolucao,
	 InDisponibilidade,
	 IdUsuarioAlteracao,
	 DtUltimaAlteracao)
	VALUES
	(:iNovoId,
	 :cSgMotivoDevolucao:icSgMotivoDevolucao,
	 :cDsMotivoDevolucao:icDsMotivoDevolucao,
	 1,
	 :sIdUsuarioAlteracao,
	 SYSDATE);

	// Inserção OK, coloca o ID no objeto
	iIdMotivoDevolucao = iNovoId;

	ULOG_END("CMotivoDevolucao::inclui()");
	return OK;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorInc:
    {
        // Tratamento de qq tipo de chave duplicada (PK ou AK)
        if (sqlca.sqlcode == DUPLICATE_KEY )
        {
            ULOG_END("CMotivoDevolucao::inclui()");
            return DUPLICATE_KEY;
        }

        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
        ULOG_END("CMotivoDevolucao::inclui()");
		throw TuxBasicOraException(sqlca.sqlcode);
    }
}

void CMotivoDevolucao::exclui(){

	ULOG_START("CMotivoDevolucao::exclui()");
	struct sqlca sqlca;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorExc;

	// Remove do banco de dados
	EXEC SQL
	DELETE apoio.MotivoDevolucao
	WHERE IdMotivoDevolucao = :iIdMotivoDevolucao;

	// Remoção OK, seta ID do objeto para -1
	iIdMotivoDevolucao = -1;

	ULOG_END("CMotivoDevolucao::exclui()");
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorExc:
		ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CMotivoDevolucao::exclui()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CMotivoDevolucao::altera(){

	ULOG_START("CMotivoDevolucao::altera()");
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        int iTemRegistro;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorAlt;

    //Verificando se o registro existe
	EXEC SQL SELECT count(1)
               INTO :iTemRegistro
               FROM apoio.MotivoDevolucao
              WHERE (upper(dsmotivodevolucao) = upper(:cDsMotivoDevolucao)
                      OR upper(sgmotivodevolucao) = upper(:cSgMotivoDevolucao))
                AND idmotivodevolucao != :iIdMotivoDevolucao;

    if (iTemRegistro)
    {
        ULOG_END("CMotivoDevolucao::altera()");
        return DUPLICATE_KEY;
    }

	// Altera no banco de dados para os dados atuais
	EXEC SQL
	UPDATE apoio.MotivoDevolucao
	SET
	 SgMotivoDevolucao = :cSgMotivoDevolucao:icSgMotivoDevolucao,
	 DsMotivoDevolucao = :cDsMotivoDevolucao:icDsMotivoDevolucao,
	 InDisponibilidade = :iInDisponibilidade,
	 IdUsuarioAlteracao = :sIdUsuarioAlteracao,
	 DtUltimaAlteracao = SYSDATE
	WHERE
	 IdMotivoDevolucao = :iIdMotivoDevolucao;

	ULOG_END("CMotivoDevolucao::altera()");
	return OK;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorAlt:
    {
        // Tratamento de qq tipo de chave duplicada (PK ou AK)
        if (sqlca.sqlcode == DUPLICATE_KEY )
        {
           ULOG_END("CMotivoDevolucao::altera()");
           return DUPLICATE_KEY;
        }


		ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CMotivoDevolucao::altera()");
		throw TuxBasicOraException(sqlca.sqlcode);
    }
}

CMotivoDevolucao* CMotivoDevolucao::lista(int* iNroObjetos){

	ULOG_START("CMotivoDevolucao::lista()");
	struct sqlca sqlca;
	CMotivoDevolucao* listaMotDev = NULL;
	int iNroObjLocal = 1;

	EXEC SQL BEGIN DECLARE SECTION;
	int iIdMotDev;
	char cSgMotDev[256];
	char cDsMotDev[256];
	int iDisp;
	short icSgMotDev;
	short icDsMotDev;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL DECLARE motivos CURSOR FOR
	SELECT
	 IdMotivoDevolucao,
	 SgMotivoDevolucao,
	 DsMotivoDevolucao,
	 InDisponibilidade
	FROM
	 apoio.MotivoDevolucao
     ORDER BY upper(DsMotivoDevolucao);
	EXEC SQL OPEN motivos;

	// Corre os dados e monta a lista de objetos
	EXEC SQL WHENEVER NOT FOUND DO break;
	for (;; iNroObjLocal++) {
		
		EXEC SQL FETCH motivos INTO
		 :iIdMotDev,
		 :cSgMotDev:icSgMotDev,
		 :cDsMotDev:icDsMotDev,
		 :iDisp;

		// Aloca memória para o objeto atual.
		if ((listaMotDev = (CMotivoDevolucao*) realloc((void *)listaMotDev, (sizeof(CMotivoDevolucao) * iNroObjLocal))) != NULL) {
			
			// Coloca os dados do objeto atual.
			listaMotDev[iNroObjLocal-1].setIdMotivoDevolucao(iIdMotDev);
			listaMotDev[iNroObjLocal-1].setSgMotivoDevolucao(icSgMotDev < 0 ? NULL : cSgMotDev);
			listaMotDev[iNroObjLocal-1].setDsMotivoDevolucao(icDsMotDev < 0 ? NULL : cDsMotDev);
			listaMotDev[iNroObjLocal-1].setInDisponibilidade(iDisp);

		} else {
			if (listaMotDev)
				free(listaMotDev);
			throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
		}
	}

	*iNroObjetos = iNroObjLocal - 1;
	ULOG_END("CMotivoDevolucao::lista()");
	return listaMotDev;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CMotivoDevolucao::lista()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CMotivoDevolucao::checaExclusaoPossivel() {

	ULOG_START("CMotivoDevolucao::checaExclusaoPossivel()");
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		int iQtReg;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorChecaExc;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	// Conta os elementos
	EXEC SQL
		SELECT 
		 count(1)
		INTO
		 :iQtReg
		FROM
		 Correspondencia.CorrespondenciaDevolvida
		WHERE
		 idMotivoDevolucao = :iIdMotivoDevolucao;

	ULOG_END("CMotivoDevolucao::checaExclusaoPossivel()");
	return iQtReg;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorChecaExc:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CMotivoDevolucao::checaExclusaoPossivel()");
		throw TuxBasicOraException(sqlca.sqlcode);
}
