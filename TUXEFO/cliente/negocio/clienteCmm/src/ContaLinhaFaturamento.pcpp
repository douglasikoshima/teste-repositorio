// ContaLinhaFaturamento.pcpp: implementation for the 
// CContaLinhaFaturamento class.
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw.h>
#include "../include/Funcoes.h"
EXEC SQL INCLUDE "../include/ContaLinhaFaturamento.h";

//
// Construtor e Destrutor
CContaLinhaFaturamento::CContaLinhaFaturamento() {
	poLinhas = NULL;
	iNrLinhas = 0;
}

CContaLinhaFaturamento::~CContaLinhaFaturamento() {
	if (poLinhas)
		free(poLinhas);
}

//
// Metodos getter
long CContaLinhaFaturamento::getIdConta(){
	return iIdConta;
}

char* CContaLinhaFaturamento::getIdContaSistemaOrigem(){
	return cIdContaSistemaOrigem;
}

char* CContaLinhaFaturamento::getNrConta(){
	return cNrConta;
}

char* CContaLinhaFaturamento::getDsCicloFatura(){
	return cDsCicloFatura;
}

char* CContaLinhaFaturamento::getDtVencimento(){
	return cDtVencimento;
}

CLinhaFaturamento* CContaLinhaFaturamento::getLinhas(){
	return poLinhas;
}

long CContaLinhaFaturamento::getNrLinhas(){
	return iNrLinhas;
}

//
// Metodos setter
void CContaLinhaFaturamento::setIdConta(long value){
	iIdConta = value;
}

void CContaLinhaFaturamento::setIdContaSistemaOrigem(char* value){
	strncpy(cIdContaSistemaOrigem, value, 256);
	cIdContaSistemaOrigem[256]='\0';
}

void CContaLinhaFaturamento::setNrConta(char* value){
	strncpy(cNrConta, value, 256);
	cNrConta[256]='\0';
}

void CContaLinhaFaturamento::setDsCicloFatura(char* value){
	strncpy(cDsCicloFatura, value, 256);
	cDsCicloFatura[256]='\0';
}

void CContaLinhaFaturamento::setDtVencimento(char* value){
	strncpy(cDtVencimento, value, 11);
	cDtVencimento[10]='\0';
}

void CContaLinhaFaturamento::setLinhas(CLinhaFaturamento* value){
	poLinhas = value;
}

void CContaLinhaFaturamento::setNrLinhas(long value){
	iNrLinhas = value;
}

//
// Métodos de busca
CContaLinhaFaturamento* CContaLinhaFaturamento::lista(long* iIdPessoa, char* cNrCont, char* cNrLinha, long* iNroObjetos)
{
    ULOG_START("CContaLinhaFaturamento::lista()");
	struct sqlca sqlca;
	CContaLinhaFaturamento* listaContaLinha = NULL;
	long iNroObjLocal = 0;
	long iIdContaControle = -1;
	long iLinhasNaConta = 0;

	char cOraDDD[3];
	char cOraFone[10];

	EXEC SQL BEGIN DECLARE SECTION;
		// Entrada
		long iOraIdPessoa;
		char cOraNrConta[101];
		long iOraDDD;
		long iOraFone;
	
		// Resultado Query
		long iIdConta;
		VARCHAR cIdContaSistemaOrigem[256];
		VARCHAR cNrConta[256];
		VARCHAR cIdConta[21+1];
		VARCHAR cDsCicloFatura[256];
		VARCHAR cDtVencimento[11];
		long iIdLinhaFaturamento;
		long iNrCodArea;
		long lNrLinha;
		VARCHAR cDsEstadoLinha[256];
		short iIdContaInd;
		
		char cPesquisa[2048];
		char cPesquisaAux[255];
	EXEC SQL END DECLARE SECTION;
	
	memset( cOraDDD, 0, sizeof( cOraDDD ) );
	memset( cOraFone, 0, sizeof( cOraFone ) );
	memset( &cIdConta, 0, sizeof( cIdConta ) );
	memset( cPesquisa, 0, sizeof( cPesquisa ) );
	memset( cPesquisaAux, 0, sizeof( cPesquisaAux ) );

	if (iIdPessoa != NULL)
		iOraIdPessoa = *iIdPessoa;
	else
		iOraIdPessoa = -1;

	if (cNrCont == NULL)
		sprintf(cOraNrConta, "-1");
	else
		sprintf(cOraNrConta, "%s", cNrCont);

	if (cNrLinha == NULL) 
	{
		iOraDDD = -1;
		iOraFone = -1;
	}
	else 
	{
		strncpy(cOraDDD, cNrLinha, 2);
		iOraDDD = atol(cOraDDD);
		sprintf( cOraFone, "%s", (char*)&cNrLinha[2] );
		iOraFone = atol(cOraFone);
	}

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
	//Recupera o IDCONTA via DDD e telefone
	ULOGI("\nCContaLinhaFaturamento::lista::Antes de buscar a conta" );
	EXEC SQL
	SELECT 
		LINHACONTA.IDCONTA
	INTO
		:cIdConta:iIdContaInd
	FROM 
		CUSTOMER.LINHACONTA LINHACONTA,
        LINHA.LINHATELEFONICA LINHATELEFONICA,
        LINHA.LINHABASE LINHABASE,
        APOIO.AREAREGISTRO AREAREGISTRO
	WHERE
        LINHACONTA.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
    AND
        LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
    AND
        LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
    AND
    	AREAREGISTRO.CDAREAREGISTRO = :iOraDDD 
	AND 
		LINHABASE.NRLINHA = :iOraFone;
		
	ULOGI("\nCContaLinhaFaturamento::lista::Despois de buscar a conta" );
	if( cIdConta.len <= 0 )
	{
		ULOGI("\nCContaLinhaFaturamento::lista::NAO ACHOU CONTA" );
		strcpy( (char*)cIdConta.arr, "-1" );
		cIdConta.len = 2;
	}

	strcpy( cPesquisa, 
	"SELECT "
	    "PESSCON.IDCONTA AS IDCONTA, "
        "LPAD(CONTA.IDCONTASISTEMAORIGEM, 10, '0') AS IDCONTASISTEMAORIGEM, "
	    "CONTA.CDCONTA AS CDCONTA, "
        "NVL(CONTA.CDCICLOFATURAMENTO, '0') AS CDCICLOFATURAMENTO, "
        "NVL(CONTA.NRDIAVENCIMENTO, 0) AS NRDIAVENCIMENTO, "
	    "LINCON.IDLINHATELEFONICA AS IDLINHATELEFONICA, "
	    "AREA.CDAREAREGISTRO AS CDAREAREGISTRO, "
	    "LINBAS.NRLINHA AS NRLINHA, "
	    "ESTADOLIN.DSESTADOLINHA AS DSESTADOLINHA "
	"FROM "
		"CUSTOMER.PESSOACONTA        PESSCON, "
		"CUSTOMER.LINHACONTA         LINCON, "
		"CUSTOMER.TIPORELACIONAMENTO TIPOREL, "
		"CUSTOMER.CONTA              CONTA, "
		"CUSTOMER.PESSOADEPARA       PESSDP, "
		"LINHA.LINHATELEFONICA       LINTEL, "
		"LINHA.LINHABASE             LINBAS, "
		"APOIO.AREAREGISTRO          AREA, "
		"APOIO.ESTADOLINHA           ESTADOLIN "
	"WHERE "
		"TIPOREL.SGTIPORELACIONAMENTO = 'C' "
    "AND "
	    "ROWNUM < 101 "
	"AND "
		"PESSCON.IDTIPORELACIONAMENTO = TIPOREL.IDTIPORELACIONAMENTO "
	"AND "
		"LINCON.IDCONTA               = PESSCON.IDCONTA "
	"AND "
		"CONTA.IDCONTA                = PESSCON.IDCONTA "
	"AND "
		"PESSDP.IDPESSOADEPARA        = PESSCON.IDPESSOADEPARA "
	"AND "
		"LINTEL.IDLINHATELEFONICA     = LINCON.IDLINHATELEFONICA "
	"AND "
		"LINBAS.IDLINHABASE           = LINTEL.IDLINHABASE "
	"AND "
		"AREA.IDAREAREGISTRO          = LINBAS.IDAREAREGISTRO "
	"AND "
		"ESTADOLIN.IDESTADOLINHA      = LINBAS.IDESTADOLINHA " );

	if( iOraIdPessoa != -1 )
	{
		// erro de compilacao !! itoa( iOraIdPessoa, cPesquisaAux, 10 );
    
        sprintf(cPesquisaAux,"%ld",iOraIdPessoa);

		strcat( cPesquisa, 
		" AND "
			"PESSDP.IDPESSOA = " );
		strcat( cPesquisa, cPesquisaAux );
	}

	if( strcmp( cOraNrConta, "-1" ) != 0 )
	{
		strcat( cPesquisa, 
		" AND "
			"CONTA.CDCONTA = '" );
		strcat( cPesquisa, cOraNrConta );
		strcat( cPesquisa, "' " );
	}

	if( iOraDDD != -1 )
	{
		strcat( cPesquisa, 
		" AND "
		    "CONTA.IDCONTA = " );
		   strcat( cPesquisa, (char*)cIdConta.arr );
	}

	strcat( cPesquisa, 
		" ORDER BY "
				"CONTA.IDCONTA" );	

	// Declara e abre o cursor
	EXEC SQL PREPARE qPesquisa FROM :cPesquisa;
	EXEC SQL DECLARE contaLinha CURSOR FOR qPesquisa;

	ULOGI("\nCContaLinhaFaturamento::lista::Pesquisa dinamica[%s]", cPesquisa );

	ULOGI("\nCContaLinhaFaturamento::lista::Antes de abrir o cursor" );
	EXEC SQL OPEN contaLinha;
	ULOGI("\nCContaLinhaFaturamento::lista::Cursor aberto" );

	// Corre os dados e monta a lista de objetos
	EXEC SQL WHENEVER NOT FOUND DO break;
	for (;;) {
		memset( &cIdContaSistemaOrigem, 0, sizeof( cIdContaSistemaOrigem ) );		
		memset( &cNrConta, 0, sizeof( cNrConta ) );		
		memset( &cDsCicloFatura, 0, sizeof( cDsCicloFatura ) );		
		memset( &cDtVencimento, 0, sizeof( cDtVencimento ) );		
		memset( &cDsEstadoLinha, 0, sizeof( cDsEstadoLinha ) );		
		EXEC SQL 
		FETCH 
			contaLinha 
		INTO
			:iIdConta,
			:cIdContaSistemaOrigem,
			:cNrConta,
			:cDsCicloFatura,
			:cDtVencimento,
			:iIdLinhaFaturamento,
			:iNrCodArea,
			:lNrLinha,
			:cDsEstadoLinha;

		ULOGI("\nCContaLinhaFaturamento::lista::Dentro do FETCH" );
		ULOGI("\nCContaLinhaFaturamento::lista::iNrCodArea:[%d] lNrLinha:[%d] cNrConta:[%s]", iNrCodArea, lNrLinha, (char*)cNrConta.arr );
		// Checa se ainda é a mesma conta
		if (iIdConta == iIdContaControle) 
		{
			ULOGI("\nCContaLinhaFaturamento::lista::Entrou no if (iIdConta == iIdContaControle)" );
			CLinhaFaturamento* poLin = NULL;

			iLinhasNaConta++;

			poLin = listaContaLinha[iNroObjLocal-1].getLinhas();
			if ((poLin = (CLinhaFaturamento*) realloc((void *)poLin, (sizeof(CLinhaFaturamento) * iLinhasNaConta))) != NULL) {
				ULOGI("\nCContaLinhaFaturamento::lista::Entrou no if ((poLin = (CLinhaFaturamento*) realloc((void *)poLin, (sizeof(CLinhaFaturamento) * iLinhasNaConta))) != NULL)" );
				poLin[iLinhasNaConta-1].setIdLinhaFaturamento(iIdLinhaFaturamento);
				poLin[iLinhasNaConta-1].setNrCodArea(iNrCodArea);
				poLin[iLinhasNaConta-1].setNrLinha(lNrLinha);
				poLin[iLinhasNaConta-1].setDsEstadoLinha((char*)cDsEstadoLinha.arr);

				listaContaLinha[iNroObjLocal-1].setLinhas(poLin);
				listaContaLinha[iNroObjLocal-1].setNrLinhas(iLinhasNaConta);
			} 
			else
			{
				ULOGI("\nCContaLinhaFaturamento::lista::(Exception)Entrou no else if ((poLin = (CLinhaFaturamento*) realloc((void *)poLin, (sizeof(CLinhaFaturamento) * iLinhasNaConta))) != NULL)" );
				throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
			}

			ULOGI("\nCContaLinhaFaturamento::lista::Saiu no if ((poLin = (CLinhaFaturamento*) realloc((void *)poLin, (sizeof(CLinhaFaturamento) * iLinhasNaConta))) != NULL)" );
		} 
		else 
		{
			ULOGI("\nCContaLinhaFaturamento::lista::Entrou no else if (iIdConta == iIdContaControle)" );
			// Aloca memória para o objeto atual.
			iNroObjLocal++;
			if ((listaContaLinha = (CContaLinhaFaturamento*) realloc((void *)listaContaLinha, (sizeof(CContaLinhaFaturamento) * iNroObjLocal))) != NULL) 
			{
				ULOGI("\nCContaLinhaFaturamento::lista::Entrou no if((listaContaLinha = (CContaLinhaFaturamento*) realloc((void *)listaContaLinha, (sizeof(CContaLinhaFaturamento) * iNroObjLocal))) != NULL)" );
				iIdContaControle = iIdConta;

				// Coloca os dados do objeto atual.
				listaContaLinha[iNroObjLocal-1].setIdConta(iIdConta);
				listaContaLinha[iNroObjLocal-1].setIdContaSistemaOrigem((char*)cIdContaSistemaOrigem.arr);
				listaContaLinha[iNroObjLocal-1].setNrConta((char*)cNrConta.arr);
				listaContaLinha[iNroObjLocal-1].setDsCicloFatura((char*)cDsCicloFatura.arr);
				listaContaLinha[iNroObjLocal-1].setDtVencimento((char*)cDtVencimento.arr);

				// Monta novo objeto de lista de linhas.
				CLinhaFaturamento* poLin;
				poLin = (CLinhaFaturamento*) malloc(sizeof(CLinhaFaturamento));
				poLin->setIdLinhaFaturamento(iIdLinhaFaturamento);
				poLin->setNrCodArea(iNrCodArea);
				poLin->setNrLinha(lNrLinha);
				poLin->setDsEstadoLinha((char*)cDsEstadoLinha.arr);

				iLinhasNaConta = 1;
				listaContaLinha[iNroObjLocal-1].setLinhas(poLin);
				listaContaLinha[iNroObjLocal-1].setNrLinhas(iLinhasNaConta);
			} 
			else 
			{
				ULOGI("\nCContaLinhaFaturamento::lista::(Exception)Entrou no else if((listaContaLinha = (CContaLinhaFaturamento*) realloc((void *)listaContaLinha, (sizeof(CContaLinhaFaturamento) * iNroObjLocal))) != NULL)" );
				if (listaContaLinha)
					free(listaContaLinha);
				throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
			}
		}
		ULOGI("\nCContaLinhaFaturamento::lista::Saiu no if (iIdConta == iIdContaControle)" );
	}
	EXEC SQL CLOSE contaLinha;
	ULOGI("\nCContaLinhaFaturamento::lista::Cursor fechado" );

	*iNroObjetos = iNroObjLocal;
	ULOG_END("CContaLinhaFaturamento::lista()");
	return listaContaLinha;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CContaLinhaFaturamento::lista()");
		throw TuxBasicOraException(sqlca.sqlcode);
}