#undef SQLCA
#define SQLCA_NONE
#include <sqlca.h>
#include <sqlda.h>

#undef MSG_NONE
#define MSG_NONE
#include "../include/Messages.h"

#include <tuxfw.h>
#include "../include/Exception.h"
#include "../include/Funcoes.h"

EXEC SQL BEGIN DECLARE SECTION;
#include "../include/Global.h"
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE "../include/classCstSubAssunto.h";

// Usuário de alteração
void CCstSubAssunto::setUsuarioAlteracao(char* value) {
	if (value != NULL) {
		strncpy(sIdUsuarioAlteracao,value, 255);
		sIdUsuarioAlteracao[255]='\0';
	}
}

CCstSubAssunto::CCstSubAssunto()
{
    memset(&tSubAss, 0x00, sizeof(tSubAss));

	memset(sIdUsuarioAlteracao,0,256);
}


void CCstSubAssunto::setIdSubAssunto(char*pDado)
{
    STRCPY_TO_ORA(tSubAss.sIdSubAssunto, pDado);
}

void CCstSubAssunto::setIdAssunto(char*pDado)
{
    STRCPY_TO_ORA(tSubAss.sIdAssunto, pDado);
}

void CCstSubAssunto::setNmSubAssunto(char*pDado)
{
    STRCPY_TO_ORA(tSubAss.sNmSubAssunto, pDado);
}

void CCstSubAssunto::setSqApresentacao(char*pDado)
{
    STRCPY_TO_ORA(tSubAss.sSqApresentacao, pDado);
}

void CCstSubAssunto::setInDisponibilidade(char*pDado)
{
    STRCPY_TO_ORA(tSubAss.sInDisponibilidade, pDado);
}

//Get
char *CCstSubAssunto::getIdSubAssunto()
{
    ZERA_TO_ORA(tSubAss.sIdSubAssunto);
    return((char*)tSubAss.sIdSubAssunto.arr);
}

char *CCstSubAssunto::getIdAssunto()
{
    ZERA_TO_ORA(tSubAss.sIdAssunto);
    return((char*)tSubAss.sIdAssunto.arr);
}

char *CCstSubAssunto::getNmSubAssunto()
{
    ZERA_TO_ORA(tSubAss.sNmSubAssunto);
    return((char*)tSubAss.sNmSubAssunto.arr);
}

char *CCstSubAssunto::getSqApresentacao()
{
    ZERA_TO_ORA(tSubAss.sSqApresentacao);
    return((char*)tSubAss.sSqApresentacao.arr);
}

char *CCstSubAssunto::getInDisponibilidade()
{
    ZERA_TO_ORA(tSubAss.sInDisponibilidade);
    return((char*)tSubAss.sInDisponibilidade.arr);
}

/***************************************************************************************************/
int CCstSubAssunto::Incluir()
{
    ULOG_START("CCstSubAssunto::Incluir()");
    struct sqlca sqlca;


	EXEC SQL BEGIN DECLARE SECTION;
        int iTemRegistro;
	EXEC SQL END DECLARE SECTION;

    //Verificando se o registro existe
	EXEC SQL SELECT count(1)
               INTO :iTemRegistro
                FROM customer.subassunto
                WHERE (upper(nmsubassunto) = upper(:tSubAss.sNmSubAssunto)
                    AND idassunto     = :tSubAss.sIdAssunto)
                OR ( sqapresentacao = TO_NUMBER(:tSubAss.sSqApresentacao)
                    AND idassunto = :tSubAss.sIdAssunto);


    if (iTemRegistro)
        return DUPLICATE_KEY;

    /* Obtendo a sequence */
    EXEC SQL SELECT customer.subassuntosq.nextval 
               INTO :tSubAss.sIdSubAssunto:tSubAss.iIdSubAssuntoNull
               FROM dual;

	EXEC SQL WHENEVER SQLERROR	goto erro;

    EXEC SQL 
        INSERT INTO customer.subassunto
                    ( 
                        idsubassunto,
                        idassunto,
                        nmsubassunto,
                        sqapresentacao,
                        indisponibilidade,
						idusuarioalteracao,
						dtultimaalteracao
                    )
             VALUES ( 
                        :tSubAss.sIdSubAssunto:tSubAss.iIdSubAssuntoNull,
                        :tSubAss.sIdAssunto:tSubAss.iIdAssuntoNull,
                        :tSubAss.sNmSubAssunto:tSubAss.iNmSubAssuntoNull,
                        :tSubAss.sSqApresentacao:tSubAss.iSqApresentacaoNull,
                        :tSubAss.sInDisponibilidade:tSubAss.iInDisponibilidadeNull,
						:sIdUsuarioAlteracao,
						SYSDATE
                    );

    ULOG_END("CCstSubAssunto::Incluir()");
    if (sqlca.sqlerrd[2] == 0 )
        return NOK;
    else
        return OK;

	erro:
    {
        if (sqlca.sqlcode == DUPLICATE_KEY )
        {
            ULOG_END("CCstSubAssunto::Incluir()");
            return DUPLICATE_KEY;
        }

		ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CCstSubAssunto::Incluir()");
		throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,
					sqlca.sqlerrm.sqlerrml);
    }
}

/***************************************************************************************************/
int CCstSubAssunto::Alterar()
{
    ULOG_START("CCstSubAssunto::Alterar()");
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        int iTemRegistro;
	EXEC SQL END DECLARE SECTION;

    //Verificando se o registro existe
	EXEC SQL SELECT count(1)
               INTO :iTemRegistro
               FROM customer.subassunto
              WHERE (upper(nmsubassunto) = upper(:tSubAss.sNmSubAssunto)
                    AND idsubassunto != :tSubAss.sIdSubAssunto 
                    AND idassunto     = :tSubAss.sIdAssunto )
                OR (sqapresentacao = TO_NUMBER(:tSubAss.sSqApresentacao)
                    AND idassunto     = :tSubAss.sIdAssunto
                    AND idsubassunto != :tSubAss.sIdSubAssunto);


    if (iTemRegistro)
        return DUPLICATE_KEY;


	EXEC SQL WHENEVER SQLERROR goto erro;

    EXEC SQL UPDATE customer.subassunto
                SET nmsubassunto       = :tSubAss.sNmSubAssunto:tSubAss.iNmSubAssuntoNull,
                    sqapresentacao     = :tSubAss.sSqApresentacao:tSubAss.iSqApresentacaoNull,
                    indisponibilidade  = :tSubAss.sInDisponibilidade:tSubAss.iInDisponibilidadeNull,
                    idassunto          = :tSubAss.sIdAssunto:tSubAss.iIdAssuntoNull,
					IdUsuarioAlteracao = :sIdUsuarioAlteracao,
					DtUltimaAlteracao  = SYSDATE
              WHERE idsubassunto = :tSubAss.sIdSubAssunto;
  
    ULOG_END("CCstSubAssunto::Alterar()");
    if (sqlca.sqlerrd[2] == 0 )
        return NOK;
    else
        return OK;

	erro:
    {
        if (sqlca.sqlcode == DUPLICATE_KEY )
        {
            ULOG_END("CCstSubAssunto::Alterar()");
            return DUPLICATE_KEY;
        }

		ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CCstSubAssunto::Alterar()");
		throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,
					sqlca.sqlerrm.sqlerrml);
    }
}


int CCstSubAssunto::Excluir()
{
struct sqlca sqlca;

	EXEC SQL WHENEVER SQLERROR	goto erro;

    EXEC SQL DELETE FROM customer.subassunto
              WHERE idsubassunto = :tSubAss.sIdSubAssunto;
  
    if (sqlca.sqlerrd[2] == 0 )
        return NOK;
    else
        return OK;

	erro:
		    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,
					sqlca.sqlerrm.sqlerrml);

}


CCstSubAssunto* CCstSubAssunto::RecuperarTodos(int* iNroObjetos, char *pId)
{
    ULOG_START("CCstSubAssunto::RecuperarTodos()");
    
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

    VARCHAR sCla[LEN_NUMBER + LEN_EOS];

    EXEC SQL END DECLARE SECTION;

    CCstSubAssunto* oSub = NULL;
    int iNroObjLocal = 1;
    
    if (!*pId){/* Para obter todos os registros da tabela */
        STRCPY_TO_ORA(sCla, "0"); 
    }
    else
    {
        STRCPY_TO_ORA(sCla, pId); 
    }
       
	EXEC SQL BEGIN DECLARE SECTION;
        TSUBASSUNTO tSubAssunto;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

    memset(&tSubAssunto, 0x00, sizeof(tSubAssunto));

	// Declara e abre o cursor
	EXEC SQL DECLARE cSubAss CURSOR FOR
            SELECT idsubassunto,
                   idassunto,
                   nmsubassunto,
                   sqapresentacao,
                   indisponibilidade
             FROM customer.subassunto
            WHERE ( (idassunto = :sCla) OR (0 = :sCla) )
         ORDER BY upper(nmsubassunto);


	EXEC SQL OPEN cSubAss;
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;; iNroObjLocal++) 
    {
        memset(&tSubAssunto, 0x00, sizeof(tSubAssunto));

		EXEC SQL FETCH cSubAss 
                  INTO :tSubAssunto.sIdSubAssunto:tSubAssunto.iIdSubAssuntoNull,
                       :tSubAssunto.sIdAssunto:tSubAssunto.iIdAssuntoNull,
                       :tSubAssunto.sNmSubAssunto:tSubAssunto.iNmSubAssuntoNull,
                       :tSubAssunto.sSqApresentacao:tSubAssunto.iSqApresentacaoNull,
                       :tSubAssunto.sInDisponibilidade:tSubAssunto.iInDisponibilidadeNull;

		// Aloca memória para o objeto atual.
		if ((oSub = (CCstSubAssunto*) realloc((void *)oSub, (sizeof(CCstSubAssunto) * iNroObjLocal))) != NULL) 
        {
			oSub[iNroObjLocal-1].setIdSubAssunto((char*)tSubAssunto.sIdSubAssunto.arr);
			oSub[iNroObjLocal-1].setIdAssunto((char*)tSubAssunto.sIdAssunto.arr);
			oSub[iNroObjLocal-1].setNmSubAssunto((char*)tSubAssunto.sNmSubAssunto.arr);
			oSub[iNroObjLocal-1].setSqApresentacao((char*)tSubAssunto.sSqApresentacao.arr);
			oSub[iNroObjLocal-1].setInDisponibilidade((char*)tSubAssunto.sInDisponibilidade.arr);
		} 
        else 
        {
			if (oSub) 
                free(oSub);

            ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
            ULOG_END("CCstSubAssunto::RecuperarTodos()");
			throw  TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
            EXEC SQL CLOSE cSubAss;
		}
	}

    EXEC SQL CLOSE cSubAss;

	*iNroObjetos = iNroObjLocal - 1;

	ULOG_END("CCstSubAssunto::RecuperarTodos()");
	return oSub;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
		ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CCstSubAssunto::RecuperarTodos()");
		throw  TuxBasicOraException(sqlca.sqlcode);
}


CCstSubAssunto* CCstSubAssunto::RecuperarIdAssuntoETipoPergunta(int* iNroObjetos, char *pId, char *pTp)
{
    ULOG_START("CCstSubAssunto::RecuperarIdAssuntoETipoPergunta()");
    struct sqlca sqlca;
    
    EXEC SQL BEGIN DECLARE SECTION;
         TSUBASSUNTO tSubAssunto;
         VARCHAR sCla[LEN_NUMBER + LEN_EOS];
         int iP1;
         int iP2;
    EXEC SQL END DECLARE SECTION;
    
    CCstSubAssunto* oSub = NULL;
    int iNroObjLocal = 1;
    char *pTok;

    STRCPY_TO_ORA(sCla, pId); 
    
    if (pTp)
    {
        pTok = strtok(pTp, ",");
	    iP1 = atoi(pTok);
        pTok = strtok(NULL, pTp);
	    iP2 = atoi(pTok);
    }
    else
        iP1 = -1;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

    memset(&tSubAssunto, 0x00, sizeof(tSubAssunto));

	// Declara e abre o cursor
	EXEC SQL DECLARE cSubAss1 CURSOR FOR
        SELECT idsubassunto,
               idassunto,
               nmsubassunto,
               sqapresentacao,
               indisponibilidade
         FROM customer.subassunto
        WHERE idassunto = :sCla
          AND idsubassunto IN (SELECT idsubassunto 
                                 FROM customer.atributo 
                                WHERE ( idtipoapresentacaopergunta NOT IN (:iP1, :iP2) OR :iP1 = -1))
     ORDER BY idsubassunto;


	EXEC SQL OPEN cSubAss1;
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;; iNroObjLocal++) 
    {
        memset(&tSubAssunto, 0x00, sizeof(tSubAssunto));

		EXEC SQL FETCH cSubAss1
                  INTO :tSubAssunto.sIdSubAssunto:tSubAssunto.iIdSubAssuntoNull,
                       :tSubAssunto.sIdAssunto:tSubAssunto.iIdAssuntoNull,
                       :tSubAssunto.sNmSubAssunto:tSubAssunto.iNmSubAssuntoNull,
                       :tSubAssunto.sSqApresentacao:tSubAssunto.iSqApresentacaoNull,
                       :tSubAssunto.sInDisponibilidade:tSubAssunto.iInDisponibilidadeNull;

		// Aloca memória para o objeto atual.
		if ((oSub = (CCstSubAssunto*) realloc((void *)oSub, (sizeof(CCstSubAssunto) * iNroObjLocal))) != NULL) 
        {
			oSub[iNroObjLocal-1].setIdSubAssunto((char*)tSubAssunto.sIdSubAssunto.arr);
			oSub[iNroObjLocal-1].setIdAssunto((char*)tSubAssunto.sIdAssunto.arr);
			oSub[iNroObjLocal-1].setNmSubAssunto((char*)tSubAssunto.sNmSubAssunto.arr);
			oSub[iNroObjLocal-1].setSqApresentacao((char*)tSubAssunto.sSqApresentacao.arr);
			oSub[iNroObjLocal-1].setInDisponibilidade((char*)tSubAssunto.sInDisponibilidade.arr);
		} 
        else 
        {
			if (oSub) 
                free(oSub);

            ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
            ULOG_END("CCstSubAssunto::RecuperarIdAssuntoETipoPergunta()");
			throw  TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
            EXEC SQL CLOSE cSubAss1;
		}
	}

    EXEC SQL CLOSE cSubAss1;

	*iNroObjetos = iNroObjLocal - 1;

	ULOG_END("CCstSubAssunto::RecuperarIdAssuntoETipoPergunta()");
	return oSub;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
		ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CCstSubAssunto::RecuperarIdAssuntoETipoPergunta()");
		throw  TuxBasicOraException(sqlca.sqlcode);
}
