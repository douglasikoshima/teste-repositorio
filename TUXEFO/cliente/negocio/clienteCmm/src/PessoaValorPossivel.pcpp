// PessoaValorPossivel.pcpp: implementation for the 
// CPessoaValorPossivel class.
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw.h>
EXEC SQL INCLUDE "../include/PessoaValorPossivel.h";

//
// Construtor e Destrutor
CPessoaValorPossivel::CPessoaValorPossivel() {

	memset(sIdUsuarioAlteracao,0,256);
}

CPessoaValorPossivel::~CPessoaValorPossivel() {
}

//
// Metodos getter
int CPessoaValorPossivel::getIdPessoaValorPossivel(){
	return iIdPessoaValorPossivel;
}

int CPessoaValorPossivel::getIdPessoa(){
	return iIdPessoa;
}

int CPessoaValorPossivel::getIdValorPossivel(){
	return iIdValorPossivel;
}

//
// Metodos setter
void CPessoaValorPossivel::setIdPessoaValorPossivel(int value){
	iIdPessoaValorPossivel = value;
}

void CPessoaValorPossivel::setIdPessoa(int value){
	iIdPessoa = value;
}

void CPessoaValorPossivel::setIdValorPossivel(int value){
	iIdValorPossivel = value;
}

// Usuário de alteração
void CPessoaValorPossivel::setUsuarioAlteracao(char* value) {
	if (value != NULL) {
		strncpy(sIdUsuarioAlteracao,value, 255);
		sIdUsuarioAlteracao[255]='\0';
	}
}

//
// Métodos de acesso a banco de dados
void CPessoaValorPossivel::inclui(){

	ULOG_START("CPessoaValorPossivel::inclui()");
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		int iNovoId;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorInc;

	// Busca o novo ID da sequence.
	EXEC SQL
		SELECT customer.PessoaValorPossivelSQ.NEXTVAL
		INTO :iNovoId
		FROM DUAL;
	if (sqlca.sqlcode)
	{
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CPessoaValorPossivel::inclui()");
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	// Insere no banco de dados
	EXEC SQL
	INSERT INTO customer.PessoaValorPossivel
	(IdPessoaValorPossivel,
	 IdPessoa,
	 IdValorPossivel,
	 IdUsuarioAlteracao,
	 DtUltimaAlteracao)
	VALUES
	(:iNovoId,
	 :iIdPessoa,
	 :iIdValorPossivel,
	 :sIdUsuarioAlteracao,
	 SYSDATE);

	// Inserção OK, coloca o ID no objeto
	iIdPessoaValorPossivel = iNovoId;

    ULOG_END("CPessoaValorPossivel::inclui()");
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorInc:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CPessoaValorPossivel::inclui()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CPessoaValorPossivel::exclui(){

	ULOG_START("CPessoaValorPossivel::exclui()");
	struct sqlca sqlca;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorExc;

	// Remove do banco de dados
	EXEC SQL
	DELETE FROM customer.PessoaValorPossivel
	WHERE IdPessoaValorPossivel = :iIdPessoaValorPossivel;

	// Remoção OK, seta ID do objeto para -1
	iIdPessoaValorPossivel = -1;

	ULOG_END("CPessoaValorPossivel::exclui()");
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorExc:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CPessoaValorPossivel::exclui()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CPessoaValorPossivel::altera(){
    
    ULOG_START("CPessoaValorPossivel::altera()");
	struct sqlca sqlca;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorAlt;

	// Altera no banco de dados para os dados atuais
	EXEC SQL
	UPDATE customer.PessoaValorPossivel
	SET
	 IdPessoa = :iIdPessoa,
	 IdValorPossivel = :iIdValorPossivel,
	 IdUsuarioAlteracao = :sIdUsuarioAlteracao,
	 DtUltimaAlteracao = SYSDATE
	WHERE
	 IdPessoaValorPossivel = :iIdPessoaValorPossivel;

	ULOG_END("CPessoaValorPossivel::altera()");
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorAlt:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CPessoaValorPossivel::altera()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CPessoaValorPossivel::limpaPorAtributoEPessoa(int iIdAtributo, int iIdPessoa) {

	ULOG_START("CPessoaValorPossivel::limpaPorAtributoEPessoa()");
	
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		int iOraIdPessoa;
		int iOraIdAtributo;
	EXEC SQL END DECLARE SECTION;

	iOraIdPessoa = iIdPessoa;
	iOraIdAtributo = iIdAtributo;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorExc;

	// Remove do banco de dados
	EXEC SQL
	DELETE FROM customer.PessoaValorPossivel
	WHERE IdValorPossivel in (SELECT IdValorPossivel from customer.ValorPossivel where IdAtributo = :iOraIdAtributo) AND
		  IdPessoa = :iOraIdPessoa;

	ULOG_END("CPessoaValorPossivel::limpaPorAtributoEPessoa()");
	
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorExc:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CPessoaValorPossivel::limpaPorAtributoEPessoa()");
		throw TuxBasicOraException(sqlca.sqlcode);
}
