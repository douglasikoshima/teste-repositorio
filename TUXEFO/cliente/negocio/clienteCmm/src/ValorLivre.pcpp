// ValorLivre.pcpp: implementation for the 
// CValorLivre class.
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw.h>
EXEC SQL BEGIN DECLARE SECTION;
#include "../include/Global.h"
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE "../include/ValorLivre.h";

//
// Construtor e Destrutor
CValorLivre::CValorLivre() {
	memset(cDsValor,0,sizeof(cDsValor));
	memset(sIdUsuarioAlteracao,0,256);
}

CValorLivre::~CValorLivre() {
}

// Usuário de alteração
void CValorLivre::setUsuarioAlteracao(char* value) {
	if (value != NULL) {
		strncpy(sIdUsuarioAlteracao,value, 255);
		sIdUsuarioAlteracao[255]='\0';
	}
}

//
// Metodos getter
int CValorLivre::getIdValorLivre(){
	return iIdValorLivre;
}

int CValorLivre::getIdPessoa(){
	return iIdPessoa;
}

int CValorLivre::getIdAtributo(){
	return iIdAtributo;
}

char* CValorLivre::getDsValor(){
	return cDsValor;
}

//
// Metodos setter
void CValorLivre::setIdValorLivre(int value){
	iIdValorLivre = value;
}

void CValorLivre::setIdPessoa(int value){
	iIdPessoa = value;
}

void CValorLivre::setIdAtributo(int value){
	iIdAtributo = value;
}

void CValorLivre::setDsValor(char* value){
	strcpy(cDsValor, value);
	cDsValor[255]='\0';
}

//
// Métodos de acesso a banco de dados
void CValorLivre::inclui(){
    ULOG_START("CValorLivre::inclui()"); 
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		int iNovoId;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorInc;

	// Busca o novo ID da sequence.
	EXEC SQL
		SELECT customer.ValorLivreSQ.NEXTVAL
		INTO :iNovoId
		FROM DUAL;
	if (sqlca.sqlcode)
	{
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
	    ULOG_END("CValorLivre::inclui()"); 
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	// Insere no banco de dados
	EXEC SQL
	INSERT INTO customer.ValorLivre
	(IdValorLivre,
	 IdPessoa,
	 IdAtributo,
	 DsValor,
	 IdUsuarioAlteracao,
	 DtUltimaAlteracao)
	VALUES
	(:iNovoId,
	 :iIdPessoa,
	 :iIdAtributo,
	 :cDsValor,
	 :sIdUsuarioAlteracao,
	 SYSDATE);

	// Inserção OK, coloca o ID no objeto
	iIdValorLivre = iNovoId;
    ULOG_END("CValorLivre::inclui()"); 
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorInc:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CValorLivre::inclui()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CValorLivre::exclui(){

    ULOG_START("CValorLivre::exclui()"); 
	struct sqlca sqlca;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorExc;

	// Remove do banco de dados
	EXEC SQL
	DELETE FROM customer.ValorLivre
	WHERE IdValorLivre = :iIdValorLivre;

	// Remoção OK, seta ID do objeto para -1
	iIdValorLivre = -1;
    ULOG_END("CValorLivre::exclui()"); 
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorExc:
        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CValorLivre::exclui()"); 
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CValorLivre::excluiPorUsuario(){

    ULOG_START("CValorLivre::excluiPorUsuario()"); 
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char osconta[256] = {NULL}; 
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorExc;

	EXEC SQL
		SELECT COUNT(1) INTO :osconta from customer.ValorLivre WHERE 
		      idAtributo = :iIdAtributo 
		  AND IdPessoa = :iIdPessoa; 

	if ( atoi( osconta ) > 0 ) 
	{
	EXEC SQL
	DELETE FROM customer.ValorLivre
	WHERE idAtributo = :iIdAtributo
			  AND IdPessoa = :iIdPessoa; 
	}

	// Remoção OK, seta ID do objeto para -1
	iIdValorLivre = -1;
    ULOG_END("CValorLivre::excluiPorUsuario()"); 
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorExc:
		ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CValorLivre::excluiPorUsuario()"); 
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CValorLivre::alteraPorUsuario()
{
    ULOG_START("CValorLivre::alteraPorUsuario()"); 
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		char osconta[256] = {NULL}; 
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorAlt;

	// Altera no banco de dados para os dados atuais


	EXEC SQL
		SELECT COUNT(1) INTO :osconta from customer.ValorLivre WHERE 
		      idAtributo = :iIdAtributo 
		  AND IdPessoa = :iIdPessoa; 

	if ( atoi( osconta ) > 0 ) 
	{
		EXEC SQL
		UPDATE customer.ValorLivre
		SET
		 IdPessoa = :iIdPessoa,
		 IdAtributo = :iIdAtributo,
		 DsValor = :cDsValor,
		 IdUsuarioAlteracao = :sIdUsuarioAlteracao,
		 DtUltimaAlteracao = SYSDATE
		WHERE
		 idAtributo = :iIdAtributo
		  AND IdPessoa = :iIdPessoa; 
	}
	else
		inclui(); 
		
    ULOG_END("CValorLivre::alteraPorUsuario()"); 
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorAlt:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CValorLivre::alteraPorUsuario()"); 
		throw TuxBasicOraException(sqlca.sqlcode);
}


void CValorLivre::altera(){
    ULOG_START("CValorLivre::altera()"); 
	struct sqlca sqlca;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorAlt;

	// Altera no banco de dados para os dados atuais

		EXEC SQL
		UPDATE customer.ValorLivre
		SET
		 IdPessoa = :iIdPessoa,
		 IdAtributo = :iIdAtributo,
		 DsValor = :cDsValor,
		 IdUsuarioAlteracao = :sIdUsuarioAlteracao,
		 DtUltimaAlteracao = SYSDATE
		WHERE
		 IdValorLivre = :iIdValorLivre;
		 
    ULOG_END("CValorLivre::altera()"); 
    
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorAlt:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);		
	    ULOG_END("CValorLivre::altera()"); 
		throw TuxBasicOraException(sqlca.sqlcode);
}

