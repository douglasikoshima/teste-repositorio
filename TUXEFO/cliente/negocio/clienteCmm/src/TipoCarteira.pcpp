// TipoCarteira.pcpp: implementation for the 
// CTipoCarteira class.
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw.h>
#include "../include/Global.h"
EXEC SQL INCLUDE "../include/TipoCarteira.h";

//
// Construtor e Destrutor
CTipoCarteira::CTipoCarteira() {

	memset(sIdUsuarioAlteracao,0,256);
}

CTipoCarteira::CTipoCarteira(int iIdTipoCorr) {

    ULOG_START("CTipoCarteira::CTipoCarteira()");
    
	struct sqlca sqlca;

	iIdTipoCarteira = iIdTipoCorr;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL SELECT
	 SgTipoCarteira,
	 DsTipoCarteira,
	 VlPeso
	INTO
	 :cSgTipoCarteira,
	 :cDsTipoCarteira,
	 :iVlPeso
	FROM
	 apoio.TipoCarteira
	WHERE
	 IdTipoCarteira = :iIdTipoCarteira;

	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND)
		iIdTipoCarteira = -1;

	ULOG_END("CTipoCarteira::CTipoCarteira()");
	return;

	sqlErrorConstrutor:
	    
		ULOG_END("CTipoCarteira::CTipoCarteira()");
		ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		throw TuxBasicOraException(sqlca.sqlcode);
}

CTipoCarteira::~CTipoCarteira() {
}

// Usuário de alteração
void CTipoCarteira::setUsuarioAlteracao(char* value) {
	if (value != NULL) {
		strncpy(sIdUsuarioAlteracao,value, 255);
		sIdUsuarioAlteracao[255]='\0';
	}
}

//
// Metodos getter
int CTipoCarteira::getIdTipoCarteira(){
	return iIdTipoCarteira;
}

char* CTipoCarteira::getSgTipoCarteira(){
	return cSgTipoCarteira;
}

char* CTipoCarteira::getDsTipoCarteira(){
	return cDsTipoCarteira;
}

int CTipoCarteira::getVlPeso(){
	return iVlPeso;
}

//
// Metodos setter
void CTipoCarteira::setIdTipoCarteira(int value){
	iIdTipoCarteira = value;
}

void CTipoCarteira::setSgTipoCarteira(char* value){
	strncpy(cSgTipoCarteira, value?value:"", 255);
	cSgTipoCarteira[255]='\0';
}

void CTipoCarteira::setDsTipoCarteira(char* value){
	strncpy(cDsTipoCarteira, value?value:"", 255);
	cDsTipoCarteira[255]='\0';
}

void CTipoCarteira::setVlPeso(int value){
	iVlPeso = value;
}

//
// Métodos de acesso a banco de dados
void CTipoCarteira::inclui(){
    ULOG_START("CTipoCarteira::inclui()");
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		int iNovoId;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorInc;

	// Busca o novo ID da sequence.
	EXEC SQL
		SELECT apoio.TipoCarteiraSQ.NEXTVAL
		INTO :iNovoId
		FROM DUAL;
	if (sqlca.sqlcode)
	{
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	// Insere no banco de dados
	EXEC SQL
	INSERT INTO apoio.TipoCarteira
	(IdTipoCarteira,
	 SgTipoCarteira,
	 DsTipoCarteira,
	 VlPeso,
	 IdUsuarioAlteracao,
	 DtUltimaAlteracao)
	VALUES
	(:iNovoId,
	 :cSgTipoCarteira,
	 :cDsTipoCarteira,
	 :iVlPeso,
	 :sIdUsuarioAlteracao,
	 SYSDATE);

	// Inserção OK, coloca o ID no objeto
	iIdTipoCarteira = iNovoId;

	ULOG_END("CTipoCarteira::inclui()");
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorInc:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CTipoCarteira::inclui()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CTipoCarteira::exclui(){
    
    ULOG_START("CTipoCarteira::exclui()");
    
	struct sqlca sqlca;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorExc;

	// Remove do banco de dados
	EXEC SQL
	DELETE apoio.TipoCarteira
	WHERE IdTipoCarteira = :iIdTipoCarteira;

	// Remoção OK, seta ID do objeto para -1
	iIdTipoCarteira = -1;

	ULOG_END("CTipoCarteira::exclui()");
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorExc:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CTipoCarteira::exclui()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CTipoCarteira::altera(){

	ULOG_START("CTipoCarteira::altera()");
	struct sqlca sqlca;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorAlt;

	// Altera no banco de dados para os dados atuais
	EXEC SQL
	UPDATE apoio.TipoCarteira
	SET
	 SgTipoCarteira = :cSgTipoCarteira,
	 DsTipoCarteira = :cDsTipoCarteira,
	 VlPeso = :iVlPeso,
	 IdUsuarioAlteracao = :sIdUsuarioAlteracao,
	 DtUltimaAlteracao = SYSDATE
	WHERE
	 IdTipoCarteira = :iIdTipoCarteira;

	ULOG_END("CTipoCarteira::altera()");
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorAlt:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CTipoCarteira::altera()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

CTipoCarteira* CTipoCarteira::lista(int* iNroObjetos){

	ULOG_START("CTipoCarteira::lista()");
	struct sqlca sqlca;
	CTipoCarteira* listaTpoCart = NULL;
	int iNroObjLocal = 1;

	EXEC SQL BEGIN DECLARE SECTION;
	int iIdTpoCart;
	char cSgTpoCart[256];
	char cDsTpoCart[256];
	int iVlPes;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL DECLARE carteiras CURSOR FOR
	SELECT
	 IdTipoCarteira,
	 SgTipoCarteira,
	 DsTipoCarteira,
	 VlPeso
	FROM
	 apoio.TipoCarteira
	WHERE
	 IdTipoCarteira > 0
	ORDER BY 3;
	EXEC SQL OPEN carteiras;

	// Corre os dados e monta a lista de objetos
	EXEC SQL WHENEVER NOT FOUND DO break;
	for (;; iNroObjLocal++) {

        memset(cSgTpoCart, 0x00, sizeof(cSgTpoCart));
        memset(cDsTpoCart, 0x00, sizeof(cDsTpoCart));
		
		EXEC SQL FETCH carteiras INTO
		 :iIdTpoCart,
		 :cSgTpoCart,
		 :cDsTpoCart,
		 :iVlPes;

		// Aloca memória para o objeto atual.
		if ((listaTpoCart = (CTipoCarteira*) realloc((void *)listaTpoCart, (sizeof(CTipoCarteira) * iNroObjLocal))) != NULL) {
			
			// Coloca os dados do objeto atual.
			listaTpoCart[iNroObjLocal-1].setIdTipoCarteira(iIdTpoCart);
			listaTpoCart[iNroObjLocal-1].setSgTipoCarteira(cSgTpoCart);
			listaTpoCart[iNroObjLocal-1].setDsTipoCarteira(cDsTpoCart);
			listaTpoCart[iNroObjLocal-1].setVlPeso(iVlPes);

		} else {
			if (listaTpoCart)
				free(listaTpoCart);
			throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
		}
	}

	*iNroObjetos = iNroObjLocal - 1;
	
	ULOG_END("CTipoCarteira::lista()");
	return listaTpoCart;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CTipoCarteira::lista()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CTipoCarteira::getIdTipoNaoDefinido() {
	return 13;
}
