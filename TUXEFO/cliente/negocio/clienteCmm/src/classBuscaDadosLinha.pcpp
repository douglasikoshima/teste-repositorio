#undef SQLCA
#define SQLCA_NONE
#include <sqlca.h>
#include <sqlda.h>

#include <tuxfw.h>
#include "../include/Exception.h"

#undef MSG_NONE
#define MSG_NONE
#include "../include/Messages.h"


EXEC SQL BEGIN DECLARE SECTION;
#include "../include/Global.h"
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE "../include/classBuscaDadosLinha.h";

#include <string>
using namespace std;

CBuscaDadosLinha::CBuscaDadosLinha()
{
    memset(&tCampos, 0x00, sizeof(tCampos));
}

CBuscaDadosLinha::~CBuscaDadosLinha()
{
}

void CBuscaDadosLinha::setIdPessoa(char* pDado)
{
    if ( pDado == NULL )
    {
        tCampos.iIdPessoa_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tCampos.sIdPessoa, pDado);
        tCampos.iIdPessoa_ora = 0;
    }
}
void CBuscaDadosLinha::setIdLinhaTelefonica(char* pDado)
{
    if ( pDado == NULL )
    {
        tCampos.iIdLinhaTelefonica_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tCampos.sIdLinhaTelefonica, pDado);
        tCampos.iIdLinhaTelefonica_ora = 0;
    }
}
void CBuscaDadosLinha::setCdAreaRegistro(char* pDado)
{
    if ( pDado == NULL )
    {
        tCampos.iCdAreaRegistro_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tCampos.sCdAreaRegistro, pDado);
        tCampos.iCdAreaRegistro_ora = 0;
    }
}
void CBuscaDadosLinha::setNrLinha(char* pDado)
{
    if ( pDado == NULL )
    {
        tCampos.iNrLinha_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tCampos.sNrLinha, pDado);
        tCampos.iNrLinha_ora = 0;
    }
}
void CBuscaDadosLinha::setDsTipoLinha(char* pDado)
{
    if ( pDado == NULL )
    {
        tCampos.iDsTipoLinha_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tCampos.sDsTipoLinha, pDado);
        tCampos.iDsTipoLinha_ora = 0;
    }
}
void CBuscaDadosLinha::setDsEstadoLinha(char* pDado)
{
    if ( pDado == NULL )
    {
        tCampos.iDsEstadoLinha_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tCampos.sDsEstadoLinha, pDado);
        tCampos.iDsEstadoLinha_ora = 0;
    }
}
void CBuscaDadosLinha::setDtHabilitacaoOut(char* pDado)
{
    if ( pDado == NULL )
    {
        tCampos.iDtHabilitacaoOut_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tCampos.sDtHabilitacaoOut, pDado);
        tCampos.iDtHabilitacaoOut_ora = 0;
    }
}
void CBuscaDadosLinha::setInDivulgacaoNrLinha(char* pDado)
{
    if ( pDado == NULL )
    {
        tCampos.iInDivulgacaoNrLinha_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tCampos.sInDivulgacaoNrLinha, pDado);
        tCampos.iInDivulgacaoNrLinha_ora = 0;
    }
}
void CBuscaDadosLinha::setDtTerminoContrato(char* pDado)
{
    if ( pDado == NULL )
    {
        tCampos.iDtTerminoContrato_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tCampos.sDtTerminoContrato, pDado);
        tCampos.iDtTerminoContrato_ora = 0;
    }
}
void CBuscaDadosLinha::setNmServico(char* pDado)
{
    if ( pDado == NULL )
    {
        tCampos.iNmServico_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tCampos.sNmServico, pDado);
        tCampos.iNmServico_ora = 0;
    }
}
void CBuscaDadosLinha::setTpContrato(char* pDado)
{
    if ( pDado == NULL )
    {
        tCampos.iTpContrato_ora = -1;
    }
    else
    {
        STRCPY_TO_ORA(tCampos.sTpContrato, pDado);
        tCampos.iTpContrato_ora = 0;
    }
}
void CBuscaDadosLinha::setTotalReg(long lDado)
{
    tCampos.lTotalReg = lDado;
}

//Metodos getters
char* CBuscaDadosLinha::getIdPessoa(void)
{
        return ((char*)tCampos.sIdPessoa.arr);
}
char* CBuscaDadosLinha::getIdLinhaTelefonica(void)
{
        return ((char*)tCampos.sIdLinhaTelefonica.arr);
}
char* CBuscaDadosLinha::getCdAreaRegistro(void)
{
        return ((char*)tCampos.sCdAreaRegistro.arr);
}
char* CBuscaDadosLinha::getNrLinha(void)
{
        return ((char*)tCampos.sNrLinha.arr);
}
char* CBuscaDadosLinha::getDsTipoLinha(void)
{
        return ((char*)tCampos.sDsTipoLinha.arr);
}
char* CBuscaDadosLinha::getDsEstadoLinha(void)
{
        return ((char*)tCampos.sDsEstadoLinha.arr);
}
char* CBuscaDadosLinha::getDtHabilitacaoOut(void)
{
        return ((char*)tCampos.sDtHabilitacaoOut.arr);
}
char* CBuscaDadosLinha::getInDivulgacaoNrLinha(void)
{
        return ((char*)tCampos.sInDivulgacaoNrLinha.arr);
}
char* CBuscaDadosLinha::getDtTerminoContrato(void)
{
        return ((char*)tCampos.sDtTerminoContrato.arr);
}
char* CBuscaDadosLinha::getNmServico(void)
{
        return ((char*)tCampos.sNmServico.arr);
}
char* CBuscaDadosLinha::getTpContrato(void)
{
        return ((char*)tCampos.sTpContrato.arr);
}

// Metodos de acesso ao BD
CBuscaDadosLinha* CBuscaDadosLinha::RecuperarPorIdPessoa(int* iNroObjetos, char* pId)
{
    ULOG_START("CBuscaDadosLinha::RecuperarPorIdPessoa()");
    struct sqlca sqlca;
    CBuscaDadosLinha* oPL = NULL;
    int iNroObjLocal = 1;

	EXEC SQL BEGIN DECLARE SECTION;
        TBUSCADADOSLINHA tSt;
        //VARCHAR sId[LEN_NUMBER+LEN_EOS];
        VARCHAR sId[65];
	EXEC SQL END DECLARE SECTION;


    STRCPY_TO_ORA(sId, pId);

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL DECLARE cCursor CURSOR FOR
        SELECT pessoadepara.idpessoa,
               linhatelefonica.idlinhatelefonica,
               arearegistro.cdarearegistro,
               linhabase.nrlinha,
               tipolinha.dstipolinha,
               planoservico.nmservico as planoservico,
               b.nmservico               as tipocontrato,
               estadolinha.dsestadolinha,
               to_char(linhatelefonica.dthabilitacao, 'DD/MM/YYYY'),
               linhatelefonica.indivulgacaonrlinha,
               to_char(planoservicolinha.dtvigenciainicio, 'DD/MM/YYYY')
          FROM linha.linhatelefonica,
               linha.planoservicolinha,
               linha.planoservicolinha a,
               linha.planoservico,
               linha.planoservico b,
               linha.linhabase,
               apoio.arearegistro,
               apoio.estadolinha,
               apoio.tipolinha,
               customer.pessoalinha,
               customer.pessoadepara
         WHERE linhatelefonica.idlinhatelefonica   = planoservicolinha.idlinhatelefonica
           AND planoservicolinha.idlinhatelefonica = a.IDLINHATELEFONICA
           AND planoservico.idservico              = planoservicolinha.idservico
           AND a.idservico                            = b.idservico
           AND linhabase.idlinhabase               = linhatelefonica.idlinhabase
           AND arearegistro.idarearegistro         = linhabase.idarearegistro
           AND estadolinha.idestadolinha           = linhabase.idestadolinha
           AND tipolinha.idtipolinha               = linhatelefonica.idtipolinha
           AND linhatelefonica.idlinhatelefonica   = pessoalinha.idlinhatelefonica
           AND pessoadepara.idpessoadepara         = pessoalinha.idpessoadepara
           AND ( planoservicolinha.dtvigenciafinal >= SYSDATE OR
                 planoservicolinha.dtvigenciafinal IS NULL )
           AND planoservicolinha.dtexpiracao IS NULL
           AND ( a.dtvigenciafinal >= SYSDATE OR
                 a.dtvigenciafinal IS NULL )
           AND a.dtexpiracao IS NULL
           AND planoservicolinha.inplano = 1
           AND a.incontrato = 1
           AND pessoadepara.idpessoa = :sId;

	EXEC SQL OPEN cCursor;
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;; iNroObjLocal++) 
    {
        memset(&tSt, 0x00, sizeof(tSt));
		EXEC SQL FETCH cCursor 
                  INTO  :tSt.sIdPessoa:tSt.iIdPessoa_ora
                       ,:tSt.sIdLinhaTelefonica:tSt.iIdLinhaTelefonica_ora
                       ,:tSt.sCdAreaRegistro:tSt.iCdAreaRegistro_ora
                       ,:tSt.sNrLinha:tSt.iNrLinha_ora
                       ,:tSt.sDsTipoLinha:tSt.iDsTipoLinha_ora
                       ,:tSt.sNmServico:tSt.iNmServico_ora
                       ,:tSt.sTpContrato:tSt.iTpContrato_ora
                       ,:tSt.sDsEstadoLinha:tSt.iDsEstadoLinha_ora
                       ,:tSt.sDtHabilitacaoOut:tSt.iDtHabilitacaoOut_ora
                       ,:tSt.sInDivulgacaoNrLinha:tSt.iInDivulgacaoNrLinha_ora
                       ,:tSt.sDtTerminoContrato:tSt.iDtTerminoContrato_ora;

		// Aloca memória para o objeto atual.
		if ((oPL = (CBuscaDadosLinha*) realloc((void *)oPL
                                               ,(sizeof(CBuscaDadosLinha) * iNroObjLocal))) 
                                      != NULL)
        {
            int index = iNroObjLocal-1;

			oPL[index].setIdPessoa((char*)tSt.sIdPessoa.arr);
			oPL[index].setIdLinhaTelefonica((char*)tSt.sIdLinhaTelefonica.arr);
			oPL[index].setCdAreaRegistro((char*)tSt.sCdAreaRegistro.arr);
			oPL[index].setNrLinha((char*)tSt.sNrLinha.arr);
			oPL[index].setDsTipoLinha((char*)tSt.sDsTipoLinha.arr);
			oPL[index].setDsEstadoLinha((char*)tSt.sDsEstadoLinha.arr);
			oPL[index].setDtHabilitacaoOut((char*)tSt.sDtHabilitacaoOut.arr);
			oPL[index].setInDivulgacaoNrLinha((char*)tSt.sInDivulgacaoNrLinha.arr);
			oPL[index].setDtTerminoContrato((char*)tSt.sDtTerminoContrato.arr);
			oPL[index].setNmServico((char*)tSt.sNmServico.arr);
			oPL[index].setTpContrato((char*)tSt.sTpContrato.arr);
		} 
        else 
        {
			if (oPL) 
                free(oPL);

            ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
            EXEC SQL CLOSE cCursor;
            ULOG_END("CBuscaDadosLinha::RecuperarPorIdPessoa()");
			throw  TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
		}
	}

    EXEC SQL CLOSE cCursor;

	*iNroObjetos = iNroObjLocal - 1;

	ULOG_END("CBuscaDadosLinha::RecuperarPorIdPessoa()");
	return oPL;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
		ULOG_END("CBuscaDadosLinha::RecuperarPorIdPessoa()");
		throw  TuxBasicOraException(sqlca.sqlcode);
}


CBuscaDadosLinha* CBuscaDadosLinha::buscarPorDadosFiltro(int* iNroObjetos, 
                                                         char* pId,
                                                         char* pLinhaDe, 
                                                         char* pLinhaAte, 
                                                         char* pIdTipo, 
                                                         char* pIdEstado)
{
    ULOG_START("CBuscaDadosLinha::buscarPorDadosFiltro()");
    
    struct sqlca sqlca;
    CBuscaDadosLinha* oPL = NULL;
    int iNroObjLocal = 1;

	EXEC SQL BEGIN DECLARE SECTION;
        TBUSCADADOSLINHA tSt;
        //VARCHAR sId[LEN_NUMBER+LEN_EOS];
        VARCHAR sId[65];
        //VARCHAR sLinhaDe[LEN_NRLINHA + LEN_EOS];
        VARCHAR sLinhaDe[32];
        //char sDddDe[3];
        char sDddDe[8];
        //VARCHAR sLinhaAte[LEN_NRLINHA + LEN_EOS];
        VARCHAR sLinhaAte[32];
        //char sDddAte[3];
        char sDddAte[8];
        //VARCHAR sIdTipo[LEN_NUMBER + LEN_EOS];
        VARCHAR sIdTipo[65];
        //VARCHAR sIdEstado[LEN_NUMBER + LEN_EOS];
        VARCHAR sIdEstado[65];
	EXEC SQL END DECLARE SECTION;

    // Setando os valores para pesquisa
    STRCPY_TO_ORA(sId, pId);

    if (pLinhaDe != NULL){
        STRCPY_TO_ORA(sLinhaDe, &pLinhaDe[2]);
        strncpy(sDddDe, pLinhaDe, 2);
        sDddDe[2] = '\0';
    }
    else{
        STRCPY_TO_ORA(sLinhaDe, "-1");
        strcpy(sDddDe, "-1");
        sDddDe[2] = '\0';
    }

    if (pLinhaAte != NULL){
        STRCPY_TO_ORA(sLinhaAte, &pLinhaAte[2]);
        strncpy(sDddAte, pLinhaAte, 2);
        sDddAte[2] = '\0';
    }
    else{
        STRCPY_TO_ORA(sLinhaAte, "-1");
        strcpy(sDddAte, "-1");
        sDddAte[2] = '\0';
    }

    if (pIdTipo != NULL){
        STRCPY_TO_ORA(sIdTipo, pIdTipo);
    }
    else{
        STRCPY_TO_ORA(sIdTipo, "-1");
    }

    if (pIdEstado != NULL){
        STRCPY_TO_ORA(sIdEstado, pIdEstado);
    }
    else{
        STRCPY_TO_ORA(sIdEstado, "-1");
    }

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL DECLARE cCursor1 CURSOR FOR
        SELECT pessoadepara.idpessoa,
               linhatelefonica.idlinhatelefonica,
               arearegistro.cdarearegistro,
               linhabase.nrlinha,
               tipolinha.dstipolinha,
               estadolinha.dsestadolinha,
               to_char(trunc(linhatelefonica.dthabilitacao), 'DD/MM/YYYY'),
               linhatelefonica.indivulgacaonrlinha,
               linhatelefonica.dtexpiracao
          FROM linha.linhatelefonica,
               linha.linhabase,
               apoio.arearegistro,
               apoio.estadolinha,
               apoio.tipolinha,
               customer.pessoalinha,
               customer.pessoadepara,
               customer.tiporelacionamento
         WHERE linhabase.idlinhabase                = linhatelefonica.idlinhabase
           AND arearegistro.idarearegistro          = linhabase.idarearegistro
           AND estadolinha.idestadolinha            = linhabase.idestadolinha
           AND tipolinha.idtipolinha                = linhatelefonica.idtipolinha
           AND linhatelefonica.idlinhatelefonica    = pessoalinha.idlinhatelefonica
           AND pessoadepara.idpessoadepara          = pessoalinha.idpessoadepara
           AND pessoalinha.idtiporelacionamento     = tiporelacionamento.idtiporelacionamento
           AND tiporelacionamento.sgtiporelacionamento = 'C'
           AND ( ( (linhabase.nrlinha >= :sLinhaDe AND arearegistro.cdarearegistro >= :sDddDe) AND 
                   (linhabase.nrlinha <= :sLinhaAte AND arearegistro.cdarearegistro <= :sDddAte) )
                 OR (-1 >= :sLinhaDe AND -1 <= :sLinhaAte) )
           AND ( tipolinha.idtipolinha = :sIdTipo OR -1 = :sIdTipo )
           AND ( estadolinha.idestadolinha = :sIdEstado OR -1 = :sIdEstado )
           AND pessoadepara.idpessoaorigem   IN (
		 	   SELECT idpessoaorigem 
			  FROM customer.pessoadepara p 
			 WHERE p.idpessoa =:sId
			  );
    
    
    EXEC SQL OPEN cCursor1;

    EXEC SQL WHENEVER NOT FOUND DO break;

	for (;; iNroObjLocal++) 
    {
        memset(&tSt, 0x00, sizeof(tSt));
		EXEC SQL FETCH cCursor1
                  INTO  :tSt.sIdPessoa:tSt.iIdPessoa_ora
                       ,:tSt.sIdLinhaTelefonica:tSt.iIdLinhaTelefonica_ora
                       ,:tSt.sCdAreaRegistro:tSt.iCdAreaRegistro_ora
                       ,:tSt.sNrLinha:tSt.iNrLinha_ora
                       ,:tSt.sDsTipoLinha:tSt.iDsTipoLinha_ora
                       ,:tSt.sDsEstadoLinha:tSt.iDsEstadoLinha_ora
                       ,:tSt.sDtHabilitacaoOut:tSt.iDtHabilitacaoOut_ora
                       ,:tSt.sInDivulgacaoNrLinha:tSt.iInDivulgacaoNrLinha_ora
                       ,:tSt.sDtTerminoContrato:tSt.iDtTerminoContrato_ora;

		// Aloca memória para o objeto atual.
		if ((oPL = (CBuscaDadosLinha*) realloc((void *)oPL, (sizeof(CBuscaDadosLinha) * iNroObjLocal))) != NULL)
        {
            int index = iNroObjLocal-1;

			oPL[index].setIdPessoa((char*)tSt.sIdPessoa.arr);
			oPL[index].setIdLinhaTelefonica((char*)tSt.sIdLinhaTelefonica.arr);
			oPL[index].setCdAreaRegistro((char*)tSt.sCdAreaRegistro.arr);
			oPL[index].setNrLinha((char*)tSt.sNrLinha.arr);
			oPL[index].setDsTipoLinha((char*)tSt.sDsTipoLinha.arr);
			oPL[index].setDsEstadoLinha((char*)tSt.sDsEstadoLinha.arr);
			oPL[index].setDtHabilitacaoOut((char*)tSt.sDtHabilitacaoOut.arr);
			oPL[index].setInDivulgacaoNrLinha((char*)tSt.sInDivulgacaoNrLinha.arr);
			oPL[index].setDtTerminoContrato((char*)tSt.sDtTerminoContrato.arr);

            EXEC SQL WHENEVER NOT FOUND CONTINUE;

            //Recuperando plano e contrato
	        EXEC SQL 
                SELECT planoservico.nmservico
                  INTO :tSt.sNmServico:tSt.iNmServico_ora
                  FROM linha.planoservicolinha  planoservicolinha
                     , linha.planoservico       planoservico
                 WHERE planoservicolinha.idlinhatelefonica = :tSt.sIdLinhaTelefonica
                   AND ( planoservicolinha.dtvigenciafinal >= SYSDATE OR
                         planoservicolinha.dtvigenciafinal IS NULL )
                   AND planoservicolinha.dtexpiracao IS NULL
                   AND planoservicolinha.idservico = planoservico.idservico
                   AND planoservicolinha.inplano   = 1;



/*
 	        EXEC SQL 
                SELECT planoservico.nmservico,
                       b.nmservico
                  INTO :tSt.sNmServico:tSt.iNmServico_ora
                      ,:tSt.sTpContrato:tSt.iTpContrato_ora
                  FROM linha.planoservicolinha,
                       linha.planoservicolinha a,
                       linha.planoservico,
                       linha.planoservico b
                 WHERE a.IDLINHATELEFONICA = :tSt.sIdLinhaTelefonica
                   AND planoservicolinha.idlinhatelefonica = a.IDLINHATELEFONICA
                   AND ( planoservicolinha.dtvigenciafinal >= SYSDATE OR
                         planoservicolinha.dtvigenciafinal IS NULL )
                   AND planoservicolinha.dtexpiracao IS NULL
                   AND ( a.dtvigenciafinal >= SYSDATE OR
                         a.dtvigenciafinal IS NULL )
                   AND a.dtexpiracao IS NULL
                   AND planoservicolinha.idservico = planoservico.idservico
                   AND a.idservico                    = b.idservico
                   AND planoservicolinha.inplano   = 1;
                   AND a.incontrato                   = 1;
*/

			oPL[index].setNmServico((char*)tSt.sNmServico.arr);
			oPL[index].setTpContrato((char*)tSt.sTpContrato.arr);
		} 
        else 
        {
			if (oPL) 
                free(oPL);

            ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
            EXEC SQL CLOSE cCursor1;
            ULOG_END("CBuscaDadosLinha::buscarPorDadosFiltro()");
			throw  TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
		}
	}


    EXEC SQL CLOSE cCursor1;

	*iNroObjetos = iNroObjLocal - 1;

	ULOG_END("CBuscaDadosLinha::buscarPorDadosFiltro()");
	return oPL;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CBuscaDadosLinha::buscarPorDadosFiltro()");
		throw  TuxBasicOraException(sqlca.sqlcode);
}


/******************************************
 *
 * Nao refiz o metodo, eu apenas incrementei o que era necessario para
 * resolver a incidencia 2665, ou seja, se havia problemas na pesquisa original
 * estes estarão presentes aqui. Isto porque o tempo dado para resolver a incidencia
 * foi muito pequeno. (Eder Jani Martins)
 *
 *****************************/
CBuscaDadosLinha* CBuscaDadosLinha::buscarPorDadosFiltro(int* iNroObjetos, 
                                                         char* pId,
                                                         char* pLinhaDe, 
                                                         char* pLinhaAte, 
                                                         char* pIdTipo, 
                                                         char* pIdEstado,
                                                         char* pPagina,//Valor da pagina (in)
                                                         char* cContadorPagina,//Texto de retorno (out)
                                                         int*  iProximaPagina)//Indicador se ha ou nao proxima pagina (out)
{
	ULOG_START("CBuscaDadosLinha::buscarPorDadosFiltro()");
	struct sqlca sqlca;
	CBuscaDadosLinha* oPL = NULL;
	int iNroObjLocal = 1;
	EXEC SQL BEGIN DECLARE SECTION;
        TBUSCADADOSLINHA tSt;
        // VARCHAR sId[LEN_NUMBER+LEN_EOS];
        VARCHAR sId[256];
        //VARCHAR sLinhaDe[LEN_NRLINHA + LEN_EOS];
        VARCHAR sLinhaDe[32];
        //char sDddDe[3];
        char sDddDe[8];
        //VARCHAR sLinhaAte[LEN_NRLINHA + LEN_EOS];
        VARCHAR sLinhaAte[32];
        //char sDddAte[3];
        char sDddAte[8];
        //VARCHAR sIdTipo[LEN_NUMBER + LEN_EOS];
        VARCHAR sIdTipo[65];
        //VARCHAR sIdEstado[LEN_NUMBER + LEN_EOS];
        VARCHAR sIdEstado[65];
        char* pzcPaginaAtual = pPagina;
		long  ipaginaAtual = atol( pzcPaginaAtual );
		long  iregistrosPPagina = 0;
		short sregistrosPPagina;
		long  iIni = 0;
		long  iFim = 0;
		int   iCont;
	EXEC SQL END DECLARE SECTION;

    // Setando os valores para pesquisa
    STRCPY_TO_ORA(sId, pId);

    if (pLinhaDe != NULL){
        STRCPY_TO_ORA(sLinhaDe, &pLinhaDe[2]);
        strncpy(sDddDe, pLinhaDe, 2);
        sDddDe[2] = '\0';
    }
    else{
        STRCPY_TO_ORA(sLinhaDe, "-1");
        strcpy(sDddDe, "-1");
        sDddDe[2] = '\0';
    }

    if (pLinhaAte != NULL){
        STRCPY_TO_ORA(sLinhaAte, &pLinhaAte[2]);
        strncpy(sDddAte, pLinhaAte, 2);
        sDddAte[2] = '\0';
    }
    else{
        STRCPY_TO_ORA(sLinhaAte, "-1");
        strcpy(sDddAte, "-1");
        sDddAte[2] = '\0';
    }

    if (pIdTipo != NULL){
        STRCPY_TO_ORA(sIdTipo, pIdTipo);
    }
    else{
        STRCPY_TO_ORA(sIdTipo, "-1");
    }

    if (pIdEstado != NULL){
        STRCPY_TO_ORA(sIdEstado, pIdEstado);
    }
    else{
        STRCPY_TO_ORA(sIdEstado, "-1");
    }

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
	SELECT
		TO_NUMBER(DSVALORPARAMETRO)
	INTO
		:iregistrosPPagina:sregistrosPPagina
	FROM
		APOIO.PARAMETRO
	WHERE
		CDPARAMETRO = 'LUPALINHA_LINHAS_POR_PAGINA';
		
    ULOG("buscarPorDadosFiltro ->> LUPALINHA_LINHAS_POR_PAGINA[%d]", iregistrosPPagina); 

	if( iregistrosPPagina <= 0 )
	{
        ULOGE("ERRO NRO_NOK");
        ULOG_END("CBuscaDadosLinha::buscarPorDadosFiltro()");
		throw  TuxBasicSvcException( sNrMsg, "Parâmetro LUPALINHA_LINHAS_POR_PAGINA não encontrado em APOIO.PARAMETRO ou está com valor zero." );
	}

	iIni = ipaginaAtual*iregistrosPPagina;
	iFim = iIni+iregistrosPPagina;
    ULOG("buscarPorDadosFiltro ->> iIni[%d]", iIni); 
    ULOG("buscarPorDadosFiltro ->> iFim[%d]", iFim); 

    ULOG( "1.Passou...\n" );

	// Declara e abre o cursor
	/*
    EXEC SQL DECLARE CursorbuscarPorDadosFiltro CURSOR FOR
        SELECT pessoadepara.idpessoa,
               linhatelefonica.idlinhatelefonica,
               arearegistro.cdarearegistro,
               linhabase.nrlinha,
               tipolinha.dstipolinha,
               estadolinha.dsestadolinha,
               to_char(linhatelefonica.dthabilitacao, 'DD/MM/YYYY'),
               linhatelefonica.indivulgacaonrlinha,
               linhatelefonica.dtexpiracao
          FROM linha.linhatelefonica,
               linha.linhabase,
               apoio.arearegistro,
               apoio.estadolinha,
               apoio.tipolinha,
               customer.pessoalinha,
               customer.pessoadepara,
               customer.tiporelacionamento
         WHERE linhabase.idlinhabase                = linhatelefonica.idlinhabase
           AND arearegistro.idarearegistro          = linhabase.idarearegistro
           AND estadolinha.idestadolinha            = linhabase.idestadolinha
           AND tipolinha.idtipolinha                = linhatelefonica.idtipolinha
           AND linhatelefonica.idlinhatelefonica    = pessoalinha.idlinhatelefonica
           AND pessoadepara.idpessoadepara          = pessoalinha.idpessoadepara
           AND pessoalinha.idtiporelacionamento     = tiporelacionamento.idtiporelacionamento
           AND tiporelacionamento.sgtiporelacionamento = 'C'
           AND ( ( (linhabase.nrlinha >= :sLinhaDe AND arearegistro.cdarearegistro >= :sDddDe) AND 
                   (linhabase.nrlinha <= :sLinhaAte AND arearegistro.cdarearegistro <= :sDddAte) )
                 OR (-1 >= :sLinhaDe AND -1 <= :sLinhaAte) )
           AND ( tipolinha.idtipolinha = :sIdTipo OR -1 = :sIdTipo )
           AND ( estadolinha.idestadolinha = :sIdEstado OR -1 = :sIdEstado )
           AND pessoadepara.idpessoaorigem   IN (
		 	   SELECT idpessoaorigem 
			  FROM customer.pessoadepara p 
			 WHERE p.idpessoa =:sId
			  );
    */
    EXEC SQL DECLARE CursorbuscarPorDadosFiltro CURSOR FOR
        SELECT pessoadepara.idpessoa,
               linhatelefonica.idlinhatelefonica,
               arearegistro.cdarearegistro,
               linhabase.nrlinha,
               tipolinha.dstipolinha,
			   decode (reason.SBSCRP_ID,null,(SUBSTR((ESTADOLINHA.DSESTADOLINHA || ' ' || LINHABASE.DSMOTIVOESTADO), 1, 25)),'Bloqueio Pré-Ativação'),
               to_char(linhatelefonica.dthabilitacao, 'DD/MM/YYYY'),
               linhatelefonica.indivulgacaonrlinha,
               linhatelefonica.dtexpiracao
          FROM linha.linhatelefonica,
	           linha.ACCESS_NBR_HOTLN_REASON REASON,
               linha.linhabase,
               apoio.arearegistro,
               apoio.estadolinha,
               apoio.tipolinha,
               customer.pessoalinha,
               customer.pessoadepara,
               customer.tiporelacionamento
         WHERE linhabase.idlinhabase                = linhatelefonica.idlinhabase
           AND arearegistro.idarearegistro          = linhabase.idarearegistro
           AND estadolinha.idestadolinha            = linhabase.idestadolinha
           AND tipolinha.idtipolinha                = linhatelefonica.idtipolinha
           AND linhatelefonica.idlinhatelefonica    = pessoalinha.idlinhatelefonica
           AND pessoadepara.idpessoadepara          = pessoalinha.idpessoadepara
           AND pessoalinha.idtiporelacionamento     = tiporelacionamento.idtiporelacionamento
	       AND LINHATELEFONICA.IDLINHASISTEMAORIGEM=REASON.SBSCRP_ID(+)
		   and REASON.HOTLN_REASON_CD(+) = 'PRE ACTIVATION'
           AND tiporelacionamento.sgtiporelacionamento = 'C'
           AND ( ( (linhabase.nrlinha >= :sLinhaDe AND arearegistro.cdarearegistro >= :sDddDe) AND 
                   (linhabase.nrlinha <= :sLinhaAte AND arearegistro.cdarearegistro <= :sDddAte) )
                 OR (-1 >= :sLinhaDe AND -1 <= :sLinhaAte) )
           AND ( tipolinha.idtipolinha = :sIdTipo OR -1 = :sIdTipo )
           AND ( estadolinha.idestadolinha = :sIdEstado OR -1 = :sIdEstado )
           AND pessoadepara.idpessoaorigem   IN (
		 	   SELECT idpessoaorigem 
			  FROM customer.pessoadepara p 
			 WHERE p.idpessoa =:sId
			  );    
    
    ULOG( ">>> Montou Cursor..." );
    
	EXEC SQL OPEN CursorbuscarPorDadosFiltro;
    ULOG( ">>> Abrindo Cursor..." );
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (iCont = 1;;iCont++) 
    {
        memset(&tSt, 0x00, sizeof(tSt));

		EXEC SQL FETCH CursorbuscarPorDadosFiltro
                  INTO  :tSt.sIdPessoa:tSt.iIdPessoa_ora
                       ,:tSt.sIdLinhaTelefonica:tSt.iIdLinhaTelefonica_ora
                       ,:tSt.sCdAreaRegistro:tSt.iCdAreaRegistro_ora
                       ,:tSt.sNrLinha:tSt.iNrLinha_ora
                       ,:tSt.sDsTipoLinha:tSt.iDsTipoLinha_ora
                       ,:tSt.sDsEstadoLinha:tSt.iDsEstadoLinha_ora
                       ,:tSt.sDtHabilitacaoOut:tSt.iDtHabilitacaoOut_ora
                       ,:tSt.sInDivulgacaoNrLinha:tSt.iInDivulgacaoNrLinha_ora
                       ,:tSt.sDtTerminoContrato:tSt.iDtTerminoContrato_ora;

		if( iCont > iIni && iCont <  iFim )
		{
			// Aloca memória para o objeto atual.
			if ((oPL = (CBuscaDadosLinha*) realloc((void *)oPL, (sizeof(CBuscaDadosLinha) * iNroObjLocal))) != NULL)
	        {
	            int index = iNroObjLocal-1;
	
				oPL[index].setIdPessoa((char*)tSt.sIdPessoa.arr);
				oPL[index].setIdLinhaTelefonica((char*)tSt.sIdLinhaTelefonica.arr);
				oPL[index].setCdAreaRegistro((char*)tSt.sCdAreaRegistro.arr);
				oPL[index].setNrLinha((char*)tSt.sNrLinha.arr);
				oPL[index].setDsTipoLinha((char*)tSt.sDsTipoLinha.arr);
				oPL[index].setDsEstadoLinha((char*)tSt.sDsEstadoLinha.arr);
				oPL[index].setDtHabilitacaoOut((char*)tSt.sDtHabilitacaoOut.arr);
				oPL[index].setInDivulgacaoNrLinha((char*)tSt.sInDivulgacaoNrLinha.arr);
				oPL[index].setDtTerminoContrato((char*)tSt.sDtTerminoContrato.arr);
	
	            EXEC SQL WHENEVER NOT FOUND CONTINUE;

	            //Recuperando plano e contrato
		        EXEC SQL 
	                SELECT planoservico.nmservico
	                  INTO :tSt.sNmServico:tSt.iNmServico_ora
	                  FROM linha.planoservicolinha  planoservicolinha
	                     , linha.planoservico       planoservico
	                 WHERE planoservicolinha.idlinhatelefonica = :tSt.sIdLinhaTelefonica
	                   AND ( planoservicolinha.dtvigenciafinal >= SYSDATE OR
	                         planoservicolinha.dtvigenciafinal IS NULL )
	                   AND planoservicolinha.dtexpiracao IS NULL
	                   AND planoservicolinha.idservico = planoservico.idservico
	                   AND planoservicolinha.inplano   = 1
					   AND ROWNUM <= 1;

				oPL[index].setNmServico((char*)tSt.sNmServico.arr);
				oPL[index].setTpContrato((char*)tSt.sTpContrato.arr);
			}//if ((oPL = (CBuscaDadosLinha*) realloc((void *)oPL, (sizeof(CBuscaDadosLinha) * iNroObjLocal))) != NULL)
	        else 
	        {
	            EXEC SQL CLOSE CursorbuscarPorDadosFiltro;
				
				if (oPL) 
	                free(oPL);
	
	            ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
	            ULOG_END("CBuscaDadosLinha::buscarPorDadosFiltro()");
				throw  TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
			}//else if ((oPL = (CBuscaDadosLinha*) realloc((void *)oPL, (sizeof(CBuscaDadosLinha) * iNroObjLocal))) != NULL)
			iNroObjLocal++;
		}//if( iCont >= iIni || iCont <=  iFim )
	}//for (;; iNroObjLocal++) 

    EXEC SQL CLOSE CursorbuscarPorDadosFiltro;

    *iProximaPagina = 0;
	if( iCont > iFim )
		*iProximaPagina = 1;

	sprintf( cContadorPagina, "%d página(s)", (iCont/iregistrosPPagina)+1 );

    ULOG("buscarPorDadosFiltro ->> cContadorPagina[%s]", cContadorPagina); 
    ULOG("buscarPorDadosFiltro ->> iProximaPagina[%d]", *iProximaPagina); 

	*iNroObjetos = iNroObjLocal - 1;

	ULOG_END("CBuscaDadosLinha::buscarPorDadosFiltro()");
	return oPL;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CBuscaDadosLinha::buscarPorDadosFiltro()");
		throw  TuxBasicOraException(sqlca.sqlcode);
}


long CBuscaDadosLinha::getTotalReg(char* pId,char* pLinhaDe, char* pLinhaAte, char* pIdTipo, char* pIdEstado)
{
    ULOG_START("CBuscaDadosLinha::getTotalReg()");
    
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        //VARCHAR sId[LEN_NUMBER+LEN_EOS];
        VARCHAR sId[65];
        //VARCHAR sLinhaDe[LEN_NRLINHA + LEN_EOS];
        VARCHAR sLinhaDe[32];
        //VARCHAR sLinhaAte[LEN_NRLINHA + LEN_EOS];
        VARCHAR sLinhaAte[32];
        //VARCHAR sIdTipo[LEN_NUMBER + LEN_EOS];
        VARCHAR sIdTipo[65];
        //VARCHAR sIdEstado[LEN_NUMBER + LEN_EOS];
        VARCHAR sIdEstado[65];
        long iTotal;
	EXEC SQL END DECLARE SECTION;

    // Setando os valores para pesquisa
    STRCPY_TO_ORA(sId, pId);

    if (pLinhaDe != NULL){
        STRCPY_TO_ORA(sLinhaDe, pLinhaDe);
    }
    else{
        STRCPY_TO_ORA(sLinhaDe, "-1");
    }

    if (pLinhaAte != NULL){
        STRCPY_TO_ORA(sLinhaAte, pLinhaAte);
    }
    else{
        STRCPY_TO_ORA(sLinhaAte, "-1");
    }

    if (pIdTipo != NULL){
        STRCPY_TO_ORA(sIdTipo, pIdTipo);
    }
    else{
        STRCPY_TO_ORA(sIdTipo, "-1");
    }

    if (pIdEstado != NULL){
        STRCPY_TO_ORA(sIdEstado, pIdEstado);
    }
    else{
        STRCPY_TO_ORA(sIdEstado, "-1");
    }

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
        SELECT count(1)
          INTO :iTotal
          FROM linha.linhatelefonica,
               linha.planoservicolinha,
               linha.planoservicolinha a,
               linha.planoservico,
               linha.planoservico b,
               linha.linhabase,
               apoio.arearegistro,
               apoio.estadolinha,
               apoio.tipolinha,
               customer.pessoalinha,
               customer.pessoadepara
         WHERE linhatelefonica.idlinhatelefonica   = planoservicolinha.idlinhatelefonica
           AND planoservicolinha.idlinhatelefonica = a.IDLINHATELEFONICA
           AND planoservico.idservico              = planoservicolinha.idservico
           AND a.idservico                            = b.idservico
           AND linhabase.idlinhabase               = linhatelefonica.idlinhabase
           AND arearegistro.idarearegistro         = linhabase.idarearegistro
           AND estadolinha.idestadolinha           = linhabase.idestadolinha
           AND tipolinha.idtipolinha               = linhatelefonica.idtipolinha
           AND linhatelefonica.idlinhatelefonica   = pessoalinha.idlinhatelefonica
           AND pessoadepara.idpessoadepara         = pessoalinha.idpessoadepara
           AND ( planoservicolinha.dtvigenciafinal >= SYSDATE OR
                 planoservicolinha.dtvigenciafinal IS NULL )
           AND planoservicolinha.dtexpiracao IS NULL
           AND ( a.dtvigenciafinal >= SYSDATE OR
                 a.dtvigenciafinal IS NULL )
           AND a.dtexpiracao IS NULL
           AND planoservicolinha.inplano = 1
           AND a.incontrato = 1
           AND (    (linhabase.nrlinha >= :sLinhaDe AND linhabase.nrlinha <= :sLinhaAte) 
                 OR (-1 >= :sLinhaDe AND -1 <= :sLinhaAte) )
           AND ( tipolinha.idtipolinha = :sIdTipo OR -1 = :sIdTipo )
           AND ( estadolinha.idestadolinha = :sIdEstado OR -1 = :sIdEstado )
           AND pessoadepara.idpessoa = :sId;

    ULOG_END("CBuscaDadosLinha::getTotalReg()");    
    if ( iTotal < 0 )
        return (long)0;

    return (long)iTotal;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CBuscaDadosLinha::getTotalReg()");
		throw  TuxBasicOraException(sqlca.sqlcode);
}

void CBuscaDadosLinha::obterQtdEstadoLinhaCarregaTI(char* pId, int &qtLinhasAtivas, int &qtLinhasInativas)
{
    ULOG_START("CBuscaDadosLinha::obterQtdEstadoLinhaCarregaTI()");

    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        const char *pQuery;
        int varOraQtLinhasAtivas;
        int varOraQtLinhasInativas;
	EXEC SQL END DECLARE SECTION;

    string query =
        "\nWITH smsp AS"
        "\n("
            "\n\tSELECT /*+ INDEX(PESSOALINHA,PESSOALINHAIE2) */"
                "\n\t\tNVL(ESTADOLINHA.INLINHACANCELADA,0) AS INLINHACANCELADA"
            "\n\tFROM"
                "\n\t\tCUSTOMER.PESSOALINHA PESSOALINHA,"
                "\n\t\tLINHA.LINHATELEFONICA LINHATELEFONICA,"
                "\n\t\tLINHA.LINHABASE LINHABASE,"
                "\n\t\tAPOIO.ESTADOLINHA ESTADOLINHA"
            "\n\tWHERE"
                "\n\t\tPESSOALINHA.IDPESSOADEPARA = "+(string)pId+
            "\n\tAND PESSOALINHA.IDTIPORELACIONAMENTO = 2"
            "\n\tAND LINHATELEFONICA.IDLINHATELEFONICA = PESSOALINHA.IDLINHATELEFONICA"
            "\n\tAND LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE"
            "\n\tAND LINHABASE.IDESTADOLINHA = ESTADOLINHA.IDESTADOLINHA"
        "\n)"
        "\nSELECT"
            "\n*"
        "\nFROM"
        "\n("
            "\n\tSELECT"
            "\n\t("
                "\n\t\tSELECT"
                    "\n\t\t\tCOUNT(1)"
                "\n\t\tFROM"
                    "\n\t\t\tsmsp"
                "\n\t\tWHERE"
                    "\n\t\t\tsmsp.INLINHACANCELADA = 0"
            "\n\t) AS QTLINHASATIVAS"
            "\n,"
            "\n\t("
                "\n\t\tSELECT"
                    "\n\t\t\tCOUNT(1)"
                "\n\t\tFROM"
                    "\n\t\t\tsmsp"
                "\n\t\tWHERE"
                    "\n\t\t\tsmsp.INLINHACANCELADA = 1"
            "\n\t) AS QTLINHASINATIVAS"
            "\n\tFROM"
                "\n\t\tDUAL"
        "\n)\n";

    pQuery = query.c_str();
    ULOG("QUERY=%s",pQuery);

    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

    EXEC SQL PREPARE statementEstadoLinha FROM :pQuery;
	EXEC SQL DECLARE CursorEstadoLinha CURSOR FOR statementEstadoLinha;

	EXEC SQL OPEN CursorEstadoLinha;

	EXEC SQL FETCH CursorEstadoLinha INTO :varOraQtLinhasAtivas,:varOraQtLinhasInativas;

	EXEC SQL CLOSE CursorEstadoLinha;
    
    qtLinhasAtivas = varOraQtLinhasAtivas;
    qtLinhasInativas = varOraQtLinhasInativas;

    ULOG("  qtLinhasAtivas=%d", qtLinhasAtivas);
    ULOG("qtLinhasInativas=%d", qtLinhasInativas);

    ULOG_END("CBuscaDadosLinha::obterQtdEstadoLinhaCarregaTI()");

    return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CBuscaDadosLinha::obterQtdEstadoLinhaCarregaTI()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

