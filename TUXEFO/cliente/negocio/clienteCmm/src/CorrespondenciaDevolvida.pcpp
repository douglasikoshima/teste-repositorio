// CorrespondenciaDevolvida.pcpp: implementation for the
// CCorrespondenciaDevolvida class.
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <time.h>
#include <tuxfw.h>
#include "../include/Global.h"
#include "../include/Funcoes.h"

EXEC SQL INCLUDE "../include/CorrespondenciaDevolvida.h";
EXEC SQL INCLUDE "../include/StatusCorrespondencia.h";

//
// Construtor e Destrutor
CCorrespondenciaDevolvida::CCorrespondenciaDevolvida() {
	icDtDevolucao = -1;
	icDtEnvioSMS = -1;
	icDtEnvioTelemenssagem = -1;
	icNmLogradouro = -1;
	iiNrEndereco = -1;
	icDsComplemento = -1;
	icNmBairro = -1;
	icNmCidade = -1;
	icNrCEP = -1;

	memset(sIdUsuarioAlteracao,0,256);
}

CCorrespondenciaDevolvida::CCorrespondenciaDevolvida(int iIdCorrDev) 
{
    ULOG_START("CCorrespondenciaDevolvida::CCorrespondenciaDevolvida()");
	struct sqlca sqlca;

	iIdCorrespondenciaDevolvida = iIdCorrDev;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL SELECT
	 corrDev.IdPessoaUsuarioInclusao,
	 corrDev.IdMotivoDevolucao,
	 corrDev.IdPessoa,
	 corrDev.IdPais,
	 corrDev.IdUf,
	 corrDev.IdTipoCorrespondencia,
	 corrDev.IdPessoaUsuarioAlteracao,
	 TO_CHAR(corrDev.DtDevolucao,'DD/MM/YYYY'),
	 TO_CHAR(corrDev.DtEnvioSMS,'DD/MM/YYYY'),
	 TO_CHAR(corrDev.DtEnvioTelemenssagem,'DD/MM/YYYY'),
	 corrDev.NmLogradouro,
	 corrDev.NrEndereco,
	 corrDev.DsComplemento,
	 corrDev.NmBairro,
	 corrDev.NmCidade,
	 corrDev.NrCEP
	INTO
	 :iIdPessoaUsuarioInclusao,
	 :iIdMotivoDevolucao,
	 :iIdPessoa,
	 :iIdPais,
	 :iIdUf,
	 :iIdTipoCorrespondencia,
	 :iIdPessoaUsuarioAlteracao:iiIdPessoaUsuarioAlteracao,
	 :cDtDevolucao:icDtDevolucao,
	 :cDtEnvioSMS:icDtEnvioSMS,
	 :cDtEnvioTelemenssagem:icDtEnvioTelemenssagem,
	 :cNmLogradouro:icNmLogradouro,
	 :cNrEndereco:iiNrEndereco,
	 :cDsComplemento:icDsComplemento,
	 :cNmBairro:icNmBairro,
	 :cNmCidade:icNmCidade,
	 :cNrCEP:icNrCEP
	FROM
	 correspondencia.CorrespondenciaDevolvida corrDev
	WHERE 
	 idCorrespondenciaDevolvida = :iIdCorrespondenciaDevolvida;

	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND)
		iIdCorrespondenciaDevolvida = -1;
		
    ULOG_END("CCorrespondenciaDevolvida::CCorrespondenciaDevolvida()");
	return;

	sqlErrorConstrutor:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CCorrespondenciaDevolvida::CCorrespondenciaDevolvida()");
		throw TuxBasicOraException(sqlca.sqlcode);
}


CCorrespondenciaDevolvida::~CCorrespondenciaDevolvida() {
}

// Usuário de alteração
void CCorrespondenciaDevolvida::setUsuarioAlteracao(char* value) {
	if (value != NULL) {
		strncpy(sIdUsuarioAlteracao,value, 255);
		sIdUsuarioAlteracao[255]='\0';
	}
}

//
// Métodos getter para os atributos
int CCorrespondenciaDevolvida::getIdCorrespondenciaDevolvida(){
	return iIdCorrespondenciaDevolvida;
}

int CCorrespondenciaDevolvida::getIdPessoaUsuarioInclusao(){
	return iIdPessoaUsuarioInclusao;
}

int CCorrespondenciaDevolvida::getIdMotivoDevolucao(){
	return iIdMotivoDevolucao;
}

int CCorrespondenciaDevolvida::getIdPessoa(){
	return iIdPessoa;
}

int CCorrespondenciaDevolvida::getIdPais(){
	return iIdPais;
}

int CCorrespondenciaDevolvida::getIdUf(){
	return iIdUf;
}

int CCorrespondenciaDevolvida::getIdTipoCorrespondencia(){
	return iIdTipoCorrespondencia;
}

int CCorrespondenciaDevolvida::getIdPessoaUsuarioAlteracao(){
	return iIdPessoaUsuarioAlteracao;
}

char* CCorrespondenciaDevolvida::getDtDevolucao(){
	if (icDtDevolucao < 0)
		return NULL;
	else
		return cDtDevolucao;
}

char* CCorrespondenciaDevolvida::getDtEnvioSMS(){
	if (icDtEnvioSMS < 0)
		return NULL;
	else
		return cDtEnvioSMS;
}

char* CCorrespondenciaDevolvida::getDtEnvioTelemensagem(){
	if (icDtEnvioTelemenssagem < 0)
		return NULL;
	else
		return cDtEnvioTelemenssagem;
}

char* CCorrespondenciaDevolvida::getNmLogradouro(){
	if (icNmLogradouro < 0)
		return NULL;
	else
		return cNmLogradouro;
}

char* CCorrespondenciaDevolvida::getNrEndereco(){
	if (iiNrEndereco < 0)
		return NULL;
	else
		return cNrEndereco;
}

char* CCorrespondenciaDevolvida::getDsComplemento(){
	if (icDsComplemento < 0)
		return NULL;
	else
		return cDsComplemento;
}

char* CCorrespondenciaDevolvida::getNmBairro(){
	if (icNmBairro < 0)
		return NULL;
	else
		return cNmBairro;
}

char* CCorrespondenciaDevolvida::getNmCidade(){
	if (icNmCidade < 0)
		return NULL;
	else
		return cNmCidade;
}

char* CCorrespondenciaDevolvida::getNrCEP(){
	if (icNrCEP < 0)
		return NULL;
	else
		return cNrCEP;
}

// Setters
void CCorrespondenciaDevolvida::setIdCorrespondenciaDevolvida(int value){
	iIdCorrespondenciaDevolvida = value;
}

void CCorrespondenciaDevolvida::setIdPessoaUsuarioInclusao(int value){
	iIdPessoaUsuarioInclusao = value;
}

void CCorrespondenciaDevolvida::setIdMotivoDevolucao(int value){
	iIdMotivoDevolucao = value;
}

void CCorrespondenciaDevolvida::setIdPessoa(int value){
	iIdPessoa = value;
}

void CCorrespondenciaDevolvida::setIdPais(int value){
	iIdPais = value;
}

void CCorrespondenciaDevolvida::setIdUf(int value){
	iIdUf = value;
}

void CCorrespondenciaDevolvida::setIdTipoCorrespondencia(int value){
	iIdTipoCorrespondencia = value;
}

void CCorrespondenciaDevolvida::setIdPessoaUsuarioAlteracao(int value){
	iIdPessoaUsuarioAlteracao = value;
}

void CCorrespondenciaDevolvida::setDtDevolucao(char* value){
	if (value == NULL)
		icDtDevolucao = -1;
	else {
		strncpy(cDtDevolucao, value, 10);
		cDtDevolucao[10]='\0';
		icDtDevolucao = strlen(value);
	}
}

void CCorrespondenciaDevolvida::setDtEnvioSMS(char* value){
	if (value == NULL)
		icDtEnvioSMS = -1;
	else {
		strncpy(cDtEnvioSMS, value, 10);
		cDtEnvioSMS[10]='\0';
		icDtEnvioSMS = strlen(value);
	}
}

void CCorrespondenciaDevolvida::setDtEnvioTelemensagem(char* value){
	if (value == NULL)
		icDtEnvioTelemenssagem = -1;
	else {
		strncpy(cDtEnvioTelemenssagem, value, 10);
		cDtEnvioTelemenssagem[10]='\0';
		icDtEnvioTelemenssagem = strlen(value);
	}
}

void CCorrespondenciaDevolvida::setNmLogradouro(char* value){
	if (value == NULL)
		icNmLogradouro = -1;
	else {
		strncpy(cNmLogradouro, value, 255);
		cNmLogradouro[255]='\0';
		icNmLogradouro = strlen(value);
	}
}

void CCorrespondenciaDevolvida::setNrEndereco(char* value){
	if (value == NULL)
		iiNrEndereco = -1;
	else {
		strncpy(cNrEndereco, value, 255);
		cNrEndereco[255]='\0';
		iiNrEndereco= strlen(value);
	}
}

void CCorrespondenciaDevolvida::setDsComplemento(char* value){
	if (value == NULL)
		icDsComplemento = -1;
	else {
		strncpy(cDsComplemento, value, 255);
		cDsComplemento[255]='\0';
		icDsComplemento = strlen(value);
	}
}

void CCorrespondenciaDevolvida::setNmBairro(char *value){
	if (value == NULL)
		icNmBairro = -1;
	else {
		strncpy(cNmBairro, value, 255);
		cNmBairro[255]='\0';
		icNmBairro = strlen(value);
	}
}

void CCorrespondenciaDevolvida::setNmCidade(char* value){
	if (value == NULL)
		icNmCidade = -1;
	else {
		strncpy(cNmCidade, value, 255);
		cNmCidade[255]='\0';
		icNmCidade = strlen(value);
	}
}

void CCorrespondenciaDevolvida::setNrCEP(char* value){
	if (value == NULL)
		icNrCEP = -1;
	else {
		strncpy(cNrCEP, value, 255);
		cNrCEP[255]='\0';
		icNrCEP = strlen(value);
	}
}

//
// Métodos de acesso a banco de dados

char** CCorrespondenciaDevolvida::getNomeEDoctoCliente() 
{
    ULOG_START("CCorrespondenciaDevolvida::getNomeEDoctoCliente()");
	struct sqlca sqlca;

	char** ppcSaida;

	EXEC SQL BEGIN DECLARE SECTION;
		char cNrDocto[256];
		short icNrDocto;
		char cNmPessoa[256];
		short icNmPessoa;
		char cTipoDocumento[256];
		short icTipoDocumento;
	EXEC SQL END DECLARE SECTION;

    
	ULOG("iIdPessoa[%d]", iIdPessoa);

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorNmDoc;
	EXEC SQL WHENEVER NOT FOUND GOTO sqlNotFound;

	// Recupera o nro do documento e nome completo da pessoa
	EXEC SQL
	SELECT 
	     DOCUMENTO.NRDOCUMENTO
	    ,PESSOA.NMPESSOA
	    ,TIPODOCUMENTO.DSTIPODOCUMENTO
	INTO 
		 :cNrDocto:icNrDocto
      	,:cNmPessoa:icNmPessoa
      	,:cTipoDocumento:icTipoDocumento
	FROM 
	    CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
	    CUSTOMER.PESSOA PESSOA,
	    CUSTOMER.DOCUMENTO DOCUMENTO,
	    APOIO.TIPODOCUMENTO TIPODOCUMENTO
	WHERE 
	    PESSOA.IDPESSOA = PESSOADOCUMENTO.IDPESSOA
	AND
	    PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
	AND
	    DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
	AND
	    TIPODOCUMENTO.NRPRIORIDADE = 
	    ( 
	        SELECT 
	            MIN(TIPODOCUMENTO2.NRPRIORIDADE)
	        FROM 
	             CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO2
	            ,CUSTOMER.DOCUMENTO DOCUMENTO2
	            ,APOIO.TIPODOCUMENTO TIPODOCUMENTO2
	        WHERE
	            PESSOADOCUMENTO2.IDPESSOA = PESSOA.IDPESSOA
	        AND 
	            PESSOADOCUMENTO2.IDDOCUMENTO = DOCUMENTO2.IDDOCUMENTO
	        AND 
	            TIPODOCUMENTO2.IDTIPODOCUMENTO = DOCUMENTO2.IDTIPODOCUMENTO 
	    )
	AND 
	    ROWNUM < 2
	AND 
	    PESSOA.IDPESSOA = :iIdPessoa;	
	
	if (sqlca.sqlcode && sqlca.sqlcode != NO_DATA_FOUND)
		throw TuxBasicOraException(sqlca.sqlcode);

	// Monta o pedaço de xml
	ppcSaida = (char**) malloc(sizeof(char*) * 3);
	if (icNrDocto >= 0) 
	{
		ppcSaida[0] = (char*) malloc(strlen(rtrim(cNmPessoa)) + 1);
		sprintf(ppcSaida[0], "%s", rtrim(cNmPessoa));
	    ULOG("cNmPessoa(%s)", cNmPessoa);
	    
	} 
	else 
	{
		ppcSaida[0] = NULL;
	}
	if (icNrDocto >= 0) {
		ppcSaida[1] = (char*) malloc(strlen(rtrim(cNrDocto)) + 1);
		sprintf(ppcSaida[1], "%s", rtrim(cNrDocto));
	    ULOG("cNrDocto(%s)", cNrDocto);
	    
	} 
	else 
	{
		ppcSaida[1] = NULL;
	}
	if (icTipoDocumento >= 0) {
		ppcSaida[2] = (char*) malloc(strlen(rtrim(cTipoDocumento)) + 1);
		sprintf(ppcSaida[2], "%s", rtrim(cTipoDocumento));
	    ULOG("cTipoDocumento(%s)", cTipoDocumento);
	    
	} else {
		ppcSaida[2] = NULL;
	}

    ULOG_END("CCorrespondenciaDevolvida::getNomeEDoctoCliente()");
	return ppcSaida;

	// Não encontrou.
	sqlNotFound:
		ppcSaida = (char**) malloc(sizeof(char*) * 2);
		ppcSaida[0] = NULL;
		ppcSaida[1] = NULL;
		ULOG_END("CCorrespondenciaDevolvida::getNomeEDoctoCliente()");
		return ppcSaida;
	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorNmDoc:
        ULOGE("sqlca.sqlcode(%d) sqlca.sqlerrm.sqlerrmc[%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        ULOG_END("CCorrespondenciaDevolvida::getNomeEDoctoCliente()");
        throw TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

// Insere o registro atual no banco de dados
void CCorrespondenciaDevolvida::inclui()
{
    ULOG_START("CCorrespondenciaDevolvida::inclui()");
    
	time_t curr;
	tm local;
	char cData[11];
	struct sqlca sqlca;
	CHistoricoStatus oStatus;

	EXEC SQL BEGIN DECLARE SECTION;
		int iNovoId;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorInc;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	// Busca o novo ID da sequence.
	EXEC SQL
		SELECT correspondencia.CorrespondenciaDevolvidaSQ.NEXTVAL
		INTO :iNovoId
		FROM DUAL;
	if (sqlca.sqlcode)
	{
	    ULOG_END("CCorrespondenciaDevolvida::inclui()");
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	// Insere no banco de dados
	EXEC SQL
	INSERT INTO correspondencia.CorrespondenciaDevolvida
	(IdCorrespondenciaDevolvida,
	 IdPessoaUsuarioInclusao,
	 IdMotivoDevolucao,
	 IdPessoa,
	 IdPais,
	 IdUf,
	 IdTipoCorrespondencia,
	 IdPessoaUsuarioAlteracao,
	 DtDevolucao,
	 DtEnvioSMS,
	 DtEnvioTelemenssagem,
	 NmLogradouro,
	 NrEndereco,
	 DsComplemento,
	 NmBairro,
	 NmCidade,
	 NrCEP,
	 DtInclusao,
	 IdUsuarioAlteracao,
	 DtUltimaAlteracao)
	VALUES
	(:iNovoId,
	 :iIdPessoaUsuarioInclusao,
	 :iIdMotivoDevolucao,
	 :iIdPessoa,
	 :iIdPais,
	 :iIdUf,
	 :iIdTipoCorrespondencia,
	 :iIdPessoaUsuarioInclusao,
	 TO_DATE(:cDtDevolucao:icDtDevolucao,'DD/MM/YYYY'),
	 TO_DATE(:cDtEnvioSMS:icDtEnvioSMS,'DD/MM/YYYY'),
	 TO_DATE(:cDtEnvioTelemenssagem:icDtEnvioTelemenssagem,'DD/MM/YYYY'),
	 :cNmLogradouro:icNmLogradouro,
	 :cNrEndereco:iiNrEndereco,
	 :cDsComplemento:icDsComplemento,
	 :cNmBairro:icNmBairro,
	 :cNmCidade:icNmCidade,
	 :cNrCEP:icNrCEP,
	 SYSDATE,
	 :sIdUsuarioAlteracao,
	 SYSDATE);

	// Inserção OK, coloca o ID no objeto
	iIdCorrespondenciaDevolvida = iNovoId;

	// Insere status inicial]
	oStatus.setIdCorrespondenciaDevolvida(iIdCorrespondenciaDevolvida);
	oStatus.setIdPessoaUsuario(iIdPessoaUsuarioInclusao);
	oStatus.setIdStatusCorrespondencia(CStatusCorrespondencia::getIdStatusAberto());
	time(&curr); 
	local=*(localtime(&curr));
	sprintf(cData, "%2d/%2d/%d", local.tm_mday, local.tm_mon+1, local.tm_year+1900);
	oStatus.setDtStatus(cData);
	atualizaStatus(&oStatus, 1);
    ULOG_END("CCorrespondenciaDevolvida::inclui()");
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorInc:
        ULOGE("sqlca.sqlcode(%d) sqlca.sqlerrm.sqlerrmc[%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        ULOG_END("CCorrespondenciaDevolvida::inclui()");
        throw TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

void CCorrespondenciaDevolvida::exclui(CHistoricoStatus* poHist)
{

	ULOG_START("CCorrespondenciaDevolvida::exclui()");
	struct sqlca sqlca;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorExc;

	// Se tem elemento de histórico de status, exclui logicamente.
	if (poHist) {
		poHist->setIdStatusCorrespondencia(CStatusCorrespondencia::getIdStatusEncerrado());
		atualizaStatus(poHist, 0);
	} else {
		// Remove do banco de dados
		EXEC SQL
		DELETE correspondencia.CorrespondenciaDevolvida
		WHERE IdCorrespondenciaDevolvida = :iIdCorrespondenciaDevolvida;
	}

	// Remoção OK, seta ID do objeto para -1
	iIdCorrespondenciaDevolvida = -1;

	ULOG_END("CCorrespondenciaDevolvida::exclui()");
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorExc:
        ULOGE("sqlca.sqlcode(%d) sqlca.sqlerrm.sqlerrmc[%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        ULOG_END("CCorrespondenciaDevolvida::exclui()");
        throw TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

void CCorrespondenciaDevolvida::altera()
{

	ULOG_START("CCorrespondenciaDevolvida::altera()");
	struct sqlca sqlca;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorAlt;

	// Altera no banco de dados para os dados atuais
	EXEC SQL
	UPDATE correspondencia.CorrespondenciaDevolvida
	SET
	 IdMotivoDevolucao = :iIdMotivoDevolucao,
	 IdPessoa = :iIdPessoa,
	 IdPais = :iIdPais,
	 IdUf = :iIdUf,
	 IdTipoCorrespondencia = :iIdTipoCorrespondencia,
	 IdPessoaUsuarioAlteracao = :iIdPessoaUsuarioAlteracao,
	 DtDevolucao = TO_DATE(:cDtDevolucao:icDtDevolucao,'DD/MM/YYYY'),
	 NmLogradouro = :cNmLogradouro:icNmLogradouro,
	 NrEndereco = :cNrEndereco:iiNrEndereco,
	 DsComplemento = :cDsComplemento:icDsComplemento,
	 NmBairro = :cNmBairro:icNmBairro,
	 NmCidade = :cNmCidade:icNmCidade,
	 NrCEP = :cNrCEP:icNrCEP,
	 DtAlteracao = SYSDATE,
	 IdUsuarioAlteracao = :sIdUsuarioAlteracao,
	 DtUltimaAlteracao = SYSDATE
	WHERE
	 IdCorrespondenciaDevolvida = :iIdCorrespondenciaDevolvida;

	ULOG_END("CCorrespondenciaDevolvida::altera()");
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorAlt:
        ULOGE("sqlca.sqlcode(%d) sqlca.sqlerrm.sqlerrmc[%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        ULOG_END("CCorrespondenciaDevolvida::altera()");
        throw TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

void CCorrespondenciaDevolvida::atualizaStatus(CHistoricoStatus* oStatus, int bInicial)
{

	ULOG_START("CCorrespondenciaDevolvida::atualizaStatus()");
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		int iIdHistoricoStatus;
	EXEC SQL END DECLARE SECTION;
	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorAltStatus;

	// Insere o Status de correspondencia.
	oStatus->inclui();

	// Recupera o ID do status da correspondencia
	iIdHistoricoStatus = oStatus->getIdHistoricoStatus();

	// Se for status inicial, insere, senão atualiza
	if (bInicial) {

		EXEC SQL
		INSERT INTO correspondencia.HistoricoStatusAtual
		 (IdCorrespondenciaDevolvida, 
		  IdHistorioStatus,
		  IdUsuarioAlteracao,
		  DtUltimaAlteracao)
		VALUES
		 (:iIdCorrespondenciaDevolvida,
		  :iIdHistoricoStatus,
		  :sIdUsuarioAlteracao,
		  SYSDATE);
	} else {

		EXEC SQL
		UPDATE correspondencia.HistoricoStatusAtual
		SET
		 IdHistorioStatus = :iIdHistoricoStatus,
		 IdUsuarioAlteracao = :sIdUsuarioAlteracao,
		 DtUltimaAlteracao = SYSDATE
		WHERE
		 IdCorrespondenciaDevolvida = :iIdCorrespondenciaDevolvida;
	}

	ULOG_END("CCorrespondenciaDevolvida::atualizaStatus()");
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorAltStatus:
        ULOGE("sqlca.sqlcode(%d) sqlca.sqlerrm.sqlerrmc[%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        ULOG_END("CCorrespondenciaDevolvida::atualizaStatus()");
        throw TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}



char *CCorrespondenciaDevolvida::getCodigoConta(int iCorrDev)
{

	ULOG_START("CCorrespondenciaDevolvida::getCodigoConta()");
	struct sqlca sqlca;
    char *pCdConta;

	EXEC SQL BEGIN DECLARE SECTION;
		char sCdConta[256];
        int iIdCorrDev;
        short iCdConta;
	EXEC SQL END DECLARE SECTION;
   
    memset(sCdConta, 0x00, sizeof(sCdConta));

    iIdCorrDev = iCorrDev;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorNrConta;

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

	// Altera no banco de dados para os dados atuais
	EXEC SQL SELECT conta.cdconta
               INTO :sCdConta:iCdConta
              FROM correspondencia.correspondenciadevolvida,
                   correspondencia.correspdevolvidaconta,
                   customer.conta
             WHERE correspondenciadevolvida.idcorrespondenciadevolvida = correspdevolvidaconta.idcorrespondenciadevolvida
               AND conta.idconta = correspdevolvidaconta.idconta
               AND correspondenciadevolvida.idpessoa = :iIdPessoa
               AND correspondenciadevolvida.idcorrespondenciadevolvida = :iIdCorrDev;


    if ( sCdConta[0] ){
        pCdConta = (char*) malloc(strlen(rtrim(sCdConta)) + 1);
        strcpy(pCdConta, rtrim(sCdConta));
    }
    else
        pCdConta = "";

    ULOG_END("CCorrespondenciaDevolvida::getCodigoConta()");
    return pCdConta;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorNrConta:
        ULOGE("sqlca.sqlcode(%d) sqlca.sqlerrm.sqlerrmc[%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        ULOG_END("CCorrespondenciaDevolvida::getCodigoConta()");
        throw TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);

}

char *CCorrespondenciaDevolvida::getNumeroLinha(int iCorrDev)
{

	ULOG_START("CCorrespondenciaDevolvida::getNumeroLinha()");
	struct sqlca sqlca;
    char *pNrLinha;

	EXEC SQL BEGIN DECLARE SECTION;
		char sNrLinha[256];
        int iIdCorrDev;
        short iNrLinha;
	EXEC SQL END DECLARE SECTION;
   
    memset(sNrLinha, 0x00, sizeof(sNrLinha));

    iIdCorrDev = iCorrDev;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorNrConta;

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

	// Altera no banco de dados para os dados atuais
	EXEC SQL SELECT arearegistro.cdarearegistro || linhabase.nrlinha
               INTO :sNrLinha:iNrLinha
               FROM correspondencia.correspondenciadevolvida,
                    correspondencia.correspdevlinhatelefonic,
                    linha.linhatelefonica,
                    linha.linhabase,
                    apoio.arearegistro
              WHERE correspondenciadevolvida.idcorrespondenciadevolvida = correspdevlinhatelefonic.idcorrespondenciadevolvida
                AND linhatelefonica.idlinhatelefonica = correspdevlinhatelefonic.idlinhatelefonica
                AND linhabase.idlinhabase = linhatelefonica.idlinhabase
                AND arearegistro.idarearegistro = linhabase.idarearegistro
                AND correspondenciadevolvida.idpessoa = :iIdPessoa 
                AND correspondenciadevolvida.idcorrespondenciadevolvida = :iIdCorrDev;

    if ( sNrLinha[0] ){
        pNrLinha = (char*) malloc(strlen(rtrim(sNrLinha)) + 1);
        strcpy(pNrLinha, rtrim(sNrLinha));
    }
    else
        pNrLinha = "";

    ULOG_END("CCorrespondenciaDevolvida::getNumeroLinha()");
    return pNrLinha;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorNrConta:
        ULOGE("sqlca.sqlcode(%d) sqlca.sqlerrm.sqlerrmc[%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);
        ULOG_END("CCorrespondenciaDevolvida::getNumeroLinha()");
        throw TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}
