#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>

#include "tuxfw.h"
#include "../include/GestorMisc.h"

EXEC SQL BEGIN DECLARE SECTION;
#include "../include/Global.h"
EXEC SQL END DECLARE SECTION;

/*******************************************************************************************************/
CGestorMiscpc::CGestorMiscpc(void)
{
    ULOG_START("CGestorMiscpc::CGestorMiscpc");
    memset(&m_tGestorMisc, 0x00, sizeof(TGestorMisc));
    memset(&tGestorMiscInput, 0x00, sizeof(TGestorMiscInput));
    ULOG_END("CGestorMiscpc::CGestorMiscpc");
}

/*******************************************************************************************************/
CGestorMiscpc::~CGestorMiscpc(void)
{
    ULOG("CGestorMiscpc::~CGestorMiscpc");
}

/*******************************************************************************************************/
void CGestorMiscpc::clearStruct(void)
{
    memset(&m_tGestorMisc, 0x00, sizeof(TGestorMisc));
    memset(&tGestorMiscInput, 0x00, sizeof(TGestorMiscInput));
}

/*******************************************************************************************************/
void CGestorMiscpc::setIdConta(char *pszIdConta)
{
    strcpy(tGestorMiscInput.szIdConta, pszIdConta);
}

/*******************************************************************************************************/
void CGestorMiscpc::setIdNrCPF(char *pszIdNrCPF)
{
    strcpy(tGestorMiscInput.szIdNrCPF, pszIdNrCPF);
}

/*******************************************************************************************************/
void CGestorMiscpc::setCdConta(char *pszCdConta)
{
    strcpy(tGestorMiscInput.szCdConta, pszCdConta);
}

/*******************************************************************************************************/
void CGestorMiscpc::setNrDocumento(char *pszNrDocumento)
{
    strcpy(tGestorMiscInput.szNrDocumento, pszNrDocumento);
}

/*******************************************************************************************************/
void CGestorMiscpc::setNmNome(char *pszNmNome)
{
    strcpy(tGestorMiscInput.szNmNome, pszNmNome);
}

/*******************************************************************************************************/
void CGestorMiscpc::setNmNomeMeio(char *pszNmNomeMeio)
{
    strcpy(tGestorMiscInput.szNmNomeMeio, pszNmNomeMeio);
}

/*******************************************************************************************************/
void CGestorMiscpc::setNmSobreNome(char *pszNmSobreNome)
{
    strcpy(tGestorMiscInput.szNmSobreNome, pszNmSobreNome);
}

/*******************************************************************************************************/
void CGestorMiscpc::setCdContaCliente(char *pszCdContaCliente)
{
    strcpy(tGestorMiscInput.szCdContaCliente, pszCdContaCliente);
}

/*******************************************************************************************************/
void CGestorMiscpc::setNrDocumentoCliente(char *pszNrDocumentoCliente)
{
    strcpy(tGestorMiscInput.szNrDocumentoCliente, pszNrDocumentoCliente);
}

/*******************************************************************************************************/
void CGestorMiscpc::setDsTipoGestor(char *pszDsTipoGestor)
{
    strcpy(tGestorMiscInput.szDsTipoGestor, pszDsTipoGestor);
}

/*******************************************************************************************************/
char *CGestorMiscpc::getIdConta(void)
{
    static char szAux[LEN_IDCONTA + LEN_EOS];

    strcpy(szAux, tGestorMiscInput.szIdConta);
    return szAux;
}

/*******************************************************************************************************/
char *CGestorMiscpc::getCdConta(void)
{
    static char szAux[LEN_CDCONTA + LEN_EOS];

    strcpy(szAux, tGestorMiscInput.szCdConta);
    return szAux;
}

/*******************************************************************************************************/
char *CGestorMiscpc::getNrDocumento(void)
{
    static char szAux[LEN_NRDOCUMENTO + LEN_EOS];

    strcpy(szAux, tGestorMiscInput.szNrDocumento);
    return szAux;
}

/*******************************************************************************************************/
char *CGestorMiscpc::getIdPessoaConta(void)
{
    static char szAux[LEN_IDPESSOACONTA + LEN_EOS];

    strcpy(szAux, tGestorMiscInput.szIdPessoaConta);
    return szAux;
}

/*******************************************************************************************************/
void CGestorMiscpc::controleAlocacao(void)
{
    m_iQtdElementosAlocados=QTD_ELEMENTOS_GESTOR;
    m_iQtdElementosObtidos=0;

    ULOG("m_iQtdElementosAlocados(%d)", m_iQtdElementosAlocados);
    ULOG("sizeof(TGestorMisc)(%d)", sizeof(TGestorMisc));

    if((m_ptGestorMisc = (TGestorMisc *) malloc((sizeof(TGestorMisc) * (m_iQtdElementosAlocados)))) == NULL ) {
        throw new TuxBasicSvcException("13E0001", "Erro alocando memoria!");
    }
    ULOG("Memoria alocada m_ptGestorMisc (%p)", m_ptGestorMisc);
}

/*******************************************************************************************************/
TGestorMisc *CGestorMiscpc::buscaGestorMisc(int iBusca)
{
    static int iFlag=0;
    static TGestorMisc tGestorMiscAux;
    static TGestorMisc *ptGestorMiscAux;
    static int iCount=0;

    ULOG_START("CGestorMiscpc::buscaGestorMisc");

    if(iFlag == 0) {
        this->controleAlocacao();


        if(iBusca == ID_CONTAS_)
            this->proCBuscaGestorMiscContasDisp();
        else if(iBusca == ID_CNPJ_)
            this->proCBuscaGestorMiscCNPJDisp();
        else if(iBusca == ID_GESTOR_CONTA_)
            this->proCBuscaGestorContaDinamica();
        else if(iBusca == ID_LISTA_UF_)
            this->proCBuscaUF();
        else if(iBusca == ID_BUSCA_TELEFONE)
            this->proCBuscaGestorMiscComunicacao();
        else if(iBusca == ID_BUSCA_ENDERECO)
            this->proCBuscaGestorMiscEndereco();
        else if(iBusca == ID_BUSCA_CONTA)
            this->proCBuscaGestorMiscConta();
        else
            throw new TuxBasicSvcException("13E0000", "Erro buscaGestorMisc");

        ptGestorMiscAux=m_ptGestorMisc;
        iFlag=1;
    }

    // ULOG("m_ptGestorMisc(%p)ptGestorMiscAux(%p)", m_ptGestorMisc, ptGestorMiscAux);
    // ULOG("m_iQtdElementosAlocados(%d)m_iQtdElementosObtidos(%d)iCount(%d)", m_iQtdElementosAlocados, m_iQtdElementosObtidos, iCount);

    if(iCount < m_iQtdElementosObtidos)
    {
        memcpy(&tGestorMiscAux, ptGestorMiscAux, sizeof(TGestorMisc));
        iCount++;
        ptGestorMiscAux++;

        ULOG_END("CGestorMiscpc::buscaGestorMisc <NOT NULL>");
        return &tGestorMiscAux;
    }
    else
    {
        // ULOG("Desalocando memoria ->m_ptGestorMisc(%p)", m_ptGestorMisc);
        free(m_ptGestorMisc);
        m_ptGestorMisc=NULL;
        iFlag=0;
        iCount=0;
        m_iQtdElementosObtidos=0;

        ULOG_END("CGestorMiscpc::buscaGestorMisc <NULL>");
        return NULL;
    }
}

/****************************************************************************************/
bool CGestorMiscpc::buscaGestorMiscContasCount(void)
{
    ULOG_START("CGestorMiscpc::buscaGestorMiscContasCount");

    struct sqlca sqlca;
    bool bExiste;

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszCdConta[LEN_CDCONTA];
        int oiCount;
    EXEC SQL END DECLARE SECTION;


    STRCPY_TO_ORA(oszCdConta, tGestorMiscInput.szCdConta);

    EXEC SQL WHENEVER SQLERROR  goto erro;

    EXEC SQL
        SELECT
            COUNT(1)
        INTO
            :oiCount
        FROM
        (
            SELECT DISTINCT
                cgc.idnrcpf
            FROM
                customer.conta cc,
                customer.pessoaconta cpc,
                customer.gestorconta cgc,
                customer.gestorcontacontato cgcc,
                customer.gestorcontapessoaconta cgcpc
            WHERE
                cgc.idnrcpf = cgcc.idnrcpf
            AND
                cgcc.idnrcpf = cgcpc.idnrcpf
            AND
                cgcpc.idpessoaconta = cpc.idpessoaconta
            AND
                cpc.idconta = cc.idconta
            AND
                cc.cdconta = :oszCdConta
        );

    ULOG("oiCount(%d)", oiCount);
    if(oiCount > 0)
        bExiste = true;
    else
        bExiste = false;


    ULOGI("Finalizando buscaGestorMiscContasCount");
    ULOG_END("CGestorMiscpc::buscaGestorMiscContasCount");
    return bExiste;

    erro:
        ULOGE("Finalizando buscaGestorMiscContasCount <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/****************************************************************************************/
bool CGestorMiscpc::buscaGestorMiscCNPJCount(void)
{
    ULOG_START("CGestorMiscpc::buscaGestorMiscCNPJCount");

    struct sqlca sqlca;
    bool bExiste;

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszNrDocumento[LEN_NRDOCUMENTO];
        int oiCount;
    EXEC SQL END DECLARE SECTION;


    STRCPY_TO_ORA(oszNrDocumento, tGestorMiscInput.szNrDocumento);

    EXEC SQL WHENEVER SQLERROR  goto erro;

    EXEC SQL
        SELECT
            COUNT(1)
        INTO
            :oiCount
        FROM
        (
            SELECT DISTINCT
                cc.idconta,
                cc.cdconta
            FROM
                customer.documento cd,
                customer.pessoadocumento cpd,
                customer.pessoaconta cpc,
                customer.conta cc,
                customer.pessoadepara cpdp,
                apoio.tipodocumento atd,
                customer.gestorconta cgc,
                customer.gestorcontacontato cgcc,
                customer.gestorcontapessoaconta cgcpc
            WHERE
                cd.iddocumento = cpd.iddocumento
            AND
                cpd.idpessoa = cpdp.idpessoa
            AND
                cpdp.idpessoadepara = cpc.idpessoadepara
            AND
                cpc.idconta = cc.idconta
            AND
                cd.idtipodocumento = atd.idtipodocumento
            AND
                cgc.idnrcpf = cgcc.idnrcpf
            AND
                cgcc.idnrcpf = cgcpc.idnrcpf
            AND
                cgcpc.idpessoaconta = cpc.idpessoaconta
            AND
                atd.sgclassificacao = 'CNPJ'
            AND
                cd.nrdocumento = :oszNrDocumento
        );
    
    ULOG("oiCount(%d)", oiCount);
    if(oiCount > 0)
        bExiste = true;
    else
        bExiste = false;


    ULOGI("Finalizando buscaGestorMiscCNPJCount");
    ULOG_END("CGestorMiscpc::buscaGestorMiscCNPJCount");
    return bExiste;

    erro:
        ULOGE("Finalizando buscaGestorMiscCNPJCount <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/****************************************************************************************/
void CGestorMiscpc::proCBuscaGestorMiscConta(void)
{
    ULOG_START("CGestorMiscpc::proCBuscaGestorMiscConta");

    TGestorMisc *ptGestorMiscAux;
    struct sqlca sqlca;
    int iCount;

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdNrCPF[LEN_IDNRCPF];

        VARCHAR oszIdConta[LEN_IDCONTA];
        VARCHAR oszCdConta[LEN_CDCONTA];

        short oiIdConta = 0;
        short oiCdConta = 0;
    EXEC SQL END DECLARE SECTION;


    STRCPY_TO_ORA(oszIdNrCPF, tGestorMiscInput.szIdNrCPF);

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND DO break;

    EXEC SQL DECLARE cA5 CURSOR FOR
        SELECT 
            cc.idconta,
            cc.cdconta
        FROM
            customer.pessoaconta cpc,
            customer.conta cc,
            customer.pessoadepara cpdp,
            customer.gestorconta cgc,
            customer.gestorcontacontato cgcc,
            customer.gestorcontapessoaconta cgcpc,
            apoio.tipocomunicacao atc
        WHERE
            cpdp.idpessoadepara = cpc.idpessoadepara
        AND
            cpc.idconta = cc.idconta
        AND
            cgc.idnrcpf = cgcc.idnrcpf
        AND
            cgcc.idnrcpf = cgcpc.idnrcpf
        AND
            cgcpc.idpessoaconta = cpc.idpessoaconta
        AND
            atc.idtipocomunicacao = cgcc.idtipocomunicacao
        AND
            atc.dstipocomunicacao = 'CELULAR'
        AND
            cgc.idnrcpf = :oszIdNrCPF;


    EXEC SQL OPEN cA5;

    for(iCount=0, ptGestorMiscAux=m_ptGestorMisc;;iCount++, ptGestorMiscAux++, m_iQtdElementosObtidos++)
    {

        EXEC SQL FETCH cA5 INTO
             :oszIdConta:oiIdConta,
             :oszCdConta:oiCdConta;

        // ULOG("m_iQtdElementosAlocados(%d)iCount(%d)", m_iQtdElementosAlocados, iCount);


        /* Verifica se precisa realocar espaco */
        if(iCount >= m_iQtdElementosAlocados) {
            m_iQtdElementosAlocados++;

            ULOG("Realocando memoria [%p]", m_ptGestorMisc);
            m_ptGestorMisc = (TGestorMisc *) realloc(m_ptGestorMisc, sizeof(TGestorMisc) * (m_iQtdElementosAlocados));
            ULOG("Memoria realocada [%p] bloco(%d)", m_ptGestorMisc, sizeof(TGestorMisc) * (m_iQtdElementosAlocados));

            /* Atribui o novo endereco obtido e posiciona o ponteiro na posicao do ultimo registro obtido antes da realocacao */
            ptGestorMiscAux = m_ptGestorMisc+iCount;
        }

        /* copia as informacoes obtidas para o ponteiro */
        memset(ptGestorMiscAux, 0x00, sizeof(TGestorMisc));
        if(oiIdConta != -1) {
            STRCPY_FROM_ORA(ptGestorMiscAux->szIdConta, oszIdConta);
        }
        if(oiCdConta != -1) {
            STRCPY_FROM_ORA(ptGestorMiscAux->szCdConta, oszCdConta);
        }
    }

    EXEC SQL CLOSE cA5;
    ULOG("iCount(%d) m_iQtdElementosAlocados(%d) m_iQtdElementosObtidos(%d)", iCount, m_iQtdElementosAlocados, m_iQtdElementosObtidos);


    ULOGI("Finalizando proCBuscaGestorMiscConta");
    ULOG_END("CGestorMiscpc::proCBuscaGestorMiscConta");
    return;

    erro:
        ULOGE("Finalizando proCBuscaGestorMiscConta <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/****************************************************************************************/
void CGestorMiscpc::proCBuscaGestorMiscEndereco(void)
{
    ULOG_START("CGestorMiscpc::proCBuscaGestorMiscEndereco");

    TGestorMisc *ptGestorMiscAux;
    struct sqlca sqlca;
    int iCount;

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdNrCPF[LEN_IDNRCPF];

        VARCHAR oszNmLogradouro[LEN_NMLOGRADOUROGC];
        VARCHAR oszNrEndereco[LEN_NRENDERECOGC];
        VARCHAR oszNmEnderecoComplemento[LEN_NMENDERECOCOMPLEMENTO];
        VARCHAR oszNmBairro[LEN_NMBAIRROGC];
        VARCHAR oszNmCidade[LEN_NMCIDADE];
        VARCHAR oszIdUF[LEN_IDUF];
        VARCHAR oszNrCEP[LEN_NRCEPGC];

        short oiNmLogradouro = 0;
        short oiNrEndereco = 0;
        short oiNmEnderecoComplemento = 0;
        short oiNmBairro = 0;
        short oiNmCidade = 0;
        short oiIdUF = 0;
        short oiNrCEP = 0;
    EXEC SQL END DECLARE SECTION;


    STRCPY_TO_ORA(oszIdNrCPF, tGestorMiscInput.szIdNrCPF);

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND DO break;

    EXEC SQL DECLARE cA4 CURSOR FOR
        SELECT
            cgc.nmlogradouro,
            cgc.nrendereco,
            cgc.nmenderecocomplemento,
            cgc.nmbairro,
            cgc.nmcidade,
            cgc.iduf,
            cgc.nrcep
        FROM
            customer.gestorconta cgc
        WHERE
            cgc.idnrcpf = :oszIdNrCPF;


    EXEC SQL OPEN cA4;

    for(iCount=0, ptGestorMiscAux=m_ptGestorMisc;;iCount++, ptGestorMiscAux++, m_iQtdElementosObtidos++)
    {

        EXEC SQL FETCH cA4 INTO
             :oszNmLogradouro:oiNmLogradouro,
             :oszNrEndereco:oiNrEndereco,
             :oszNmEnderecoComplemento:oiNmEnderecoComplemento,
             :oszNmBairro:oiNmBairro,
             :oszNmCidade:oiNmCidade,
             :oszIdUF:oiIdUF,
             :oszNrCEP:oiNrCEP;

        // ULOG("m_iQtdElementosAlocados(%d)iCount(%d)", m_iQtdElementosAlocados, iCount);


        /* Verifica se precisa realocar espaco */
        if(iCount >= m_iQtdElementosAlocados) {
            m_iQtdElementosAlocados++;

            ULOG("Realocando memoria [%p]", m_ptGestorMisc);
            m_ptGestorMisc = (TGestorMisc *) realloc(m_ptGestorMisc, sizeof(TGestorMisc) * (m_iQtdElementosAlocados));
            ULOG("Memoria realocada [%p] bloco(%d)", m_ptGestorMisc, sizeof(TGestorMisc) * (m_iQtdElementosAlocados));

            /* Atribui o novo endereco obtido e posiciona o ponteiro na posicao do ultimo registro obtido antes da realocacao */
            ptGestorMiscAux = m_ptGestorMisc+iCount;
        }

        /* copia as informacoes obtidas para o ponteiro */
        memset(ptGestorMiscAux, 0x00, sizeof(TGestorMisc));
        if(oiNmLogradouro != -1) {
            STRCPY_FROM_ORA(ptGestorMiscAux->szNmLogradouro, oszNmLogradouro);
        }
        if(oiNrEndereco != -1) {
            STRCPY_FROM_ORA(ptGestorMiscAux->szNrEndereco, oszNrEndereco);
        }
        if(oiNmEnderecoComplemento != -1) {
            STRCPY_FROM_ORA(ptGestorMiscAux->szNmEnderecoComplemento, oszNmEnderecoComplemento);
        }
        if(oiNmBairro != -1) {
            STRCPY_FROM_ORA(ptGestorMiscAux->szNmBairro, oszNmBairro);
        }
        if(oiNmCidade != -1) {
            STRCPY_FROM_ORA(ptGestorMiscAux->szNmCidade, oszNmCidade);
        }
        if(oiIdUF != -1) {
            STRCPY_FROM_ORA(ptGestorMiscAux->szIdUF, oszIdUF);
        }
        if(oiNrCEP != -1) {
            STRCPY_FROM_ORA(ptGestorMiscAux->szNrCEP, oszNrCEP);
        }
    }

    EXEC SQL CLOSE cA4;
    ULOG("iCount(%d) m_iQtdElementosAlocados(%d) m_iQtdElementosObtidos(%d)", iCount, m_iQtdElementosAlocados, m_iQtdElementosObtidos);


    ULOGI("Finalizando proCBuscaGestorMiscEndereco");
    ULOG_END("CGestorMiscpc::proCBuscaGestorMiscEndereco");
    return;

    erro:
        ULOGE("Finalizando proCBuscaGestorMiscEndereco <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/****************************************************************************************/
void CGestorMiscpc::proCBuscaGestorMiscComunicacao(void)
{
    ULOG_START("CGestorMiscpc::proCBuscaGestorMiscComunicacao");

    TGestorMisc *ptGestorMiscAux;
    struct sqlca sqlca;
    int iCount;

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdNrCPF[LEN_IDNRCPF];

        VARCHAR oszCdAreaRegistro[LEN_CDAREAREGISTROGC];
        VARCHAR oszIdNrLinha[LEN_IDNRLINHA];
        VARCHAR oszDsTipoComunicacao[LEN_DSTIPOCOMUNICACAO];
        VARCHAR oszNrRamal[LEN_NRRAMAL];

        short oiCdAreaRegistro = 0;
        short oiIdNrLinha = 0;
        short oiDsTipoComunicacao = 0;
        short oiNrRamal = 0;
    EXEC SQL END DECLARE SECTION;


    STRCPY_TO_ORA(oszIdNrCPF, tGestorMiscInput.szIdNrCPF);

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND DO break;

    EXEC SQL DECLARE cA1 CURSOR FOR
        SELECT
            cgcc.cdarearegistro,
            cgcc.idnrlinha,
            atc.dstipocomunicacao,
            cgcc.nrramal
        FROM
            customer.gestorconta cgc,
            customer.gestorcontacontato cgcc,
            apoio.tipocomunicacao atc
        WHERE
            cgc.idnrcpf = cgcc.idnrcpf
        AND
            cgcc.idtipocomunicacao = atc.idtipocomunicacao
        AND
            cgc.idnrcpf = :oszIdNrCPF;


    EXEC SQL OPEN cA1;

    for(iCount=0, ptGestorMiscAux=m_ptGestorMisc;;iCount++, ptGestorMiscAux++, m_iQtdElementosObtidos++)
    {

        EXEC SQL FETCH cA1 INTO
             :oszCdAreaRegistro:oiCdAreaRegistro,
             :oszIdNrLinha:oiIdNrLinha,
             :oszDsTipoComunicacao:oiDsTipoComunicacao,
             :oszNrRamal:oiNrRamal;

        // ULOG("m_iQtdElementosAlocados(%d)iCount(%d)", m_iQtdElementosAlocados, iCount);


        /* Verifica se precisa realocar espaco */
        if(iCount >= m_iQtdElementosAlocados) {
            m_iQtdElementosAlocados++;

            ULOG("Realocando memoria [%p]", m_ptGestorMisc);
            m_ptGestorMisc = (TGestorMisc *) realloc(m_ptGestorMisc, sizeof(TGestorMisc) * (m_iQtdElementosAlocados));
            ULOG("Memoria realocada [%p] bloco(%d)", m_ptGestorMisc, sizeof(TGestorMisc) * (m_iQtdElementosAlocados));

            /* Atribui o novo endereco obtido e posiciona o ponteiro na posicao do ultimo registro obtido antes da realocacao */
            ptGestorMiscAux = m_ptGestorMisc+iCount;
        }

        /* copia as informacoes obtidas para o ponteiro */
        memset(ptGestorMiscAux, 0x00, sizeof(TGestorMisc));
        if(oiCdAreaRegistro != -1) {
            STRCPY_FROM_ORA(ptGestorMiscAux->szCdAreaRegistro, oszCdAreaRegistro);
        }
        if(oiIdNrLinha != -1) {
            STRCPY_FROM_ORA(ptGestorMiscAux->szIdNrLinha, oszIdNrLinha);
        }
        if(oiDsTipoComunicacao != -1) {
            STRCPY_FROM_ORA(ptGestorMiscAux->szDsTipoComunicacao, oszDsTipoComunicacao);
        }
        if(oiNrRamal != -1) {
            STRCPY_FROM_ORA(ptGestorMiscAux->szNrRamal, oszNrRamal);
        }
    }

    EXEC SQL CLOSE cA1;
    ULOG("iCount(%d) m_iQtdElementosAlocados(%d) m_iQtdElementosObtidos(%d)", iCount, m_iQtdElementosAlocados, m_iQtdElementosObtidos);


    ULOGI("Finalizando proCBuscaGestorMiscComunicacao");
    ULOG_END("CGestorMiscpc::proCBuscaGestorMiscComunicacao");
    return;

    erro:
        ULOGE("Finalizando proCBuscaGestorMiscComunicacao <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/***************************************************************************/
void CGestorMiscpc::proCBuscaGestorMiscContasDisp(void)
{
    ULOG_START("CGestorMiscpc::proCBuscaGestorMiscContasDisp");

    TGestorMisc *ptGestorMiscAux;
    struct sqlca sqlca;
    int iCount;

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszCdContaIn[LEN_CDCONTA];

        VARCHAR oszIdConta[LEN_IDCONTA];
        VARCHAR oszCdContaOut[LEN_CDCONTA];

        short oiIdConta = 0;
        short oiCdContaOut = 0;
    EXEC SQL END DECLARE SECTION;


    STRCPY_TO_ORA(oszCdContaIn, tGestorMiscInput.szCdConta);

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND DO break;

    EXEC SQL DECLARE cA2 CURSOR FOR
        SELECT
            cc.idconta,
            cc.cdconta
        FROM
            customer.conta cc,
            customer.pessoaconta cpc
        WHERE
            cpc.idconta = cc.idconta
        AND
            cc.cdconta = :oszCdContaIn;


    EXEC SQL OPEN cA2;

    for(iCount=0, ptGestorMiscAux=m_ptGestorMisc;;iCount++, ptGestorMiscAux++, m_iQtdElementosObtidos++)
    {

        EXEC SQL FETCH cA2 INTO
             :oszIdConta:oiIdConta,
             :oszCdContaOut:oiCdContaOut;

        // ULOG("m_iQtdElementosAlocados(%d)iCount(%d)", m_iQtdElementosAlocados, iCount);


        /* Verifica se precisa realocar espaco */
        if(iCount >= m_iQtdElementosAlocados) {
            m_iQtdElementosAlocados++;

            ULOG("Realocando memoria [%p]", m_ptGestorMisc);
            m_ptGestorMisc = (TGestorMisc *) realloc(m_ptGestorMisc, sizeof(TGestorMisc) * (m_iQtdElementosAlocados));
            ULOG("Memoria realocada [%p] bloco(%d)", m_ptGestorMisc, sizeof(TGestorMisc) * (m_iQtdElementosAlocados));

            /* Atribui o novo endereco obtido e posiciona o ponteiro na posicao do ultimo registro obtido antes da realocacao */
            ptGestorMiscAux = m_ptGestorMisc+iCount;
        }

        /* copia as informacoes obtidas para o ponteiro */
        memset(ptGestorMiscAux, 0x00, sizeof(TGestorMisc));
        if(oiIdConta != -1) {
            STRCPY_FROM_ORA(ptGestorMiscAux->szIdConta, oszIdConta);
        }
        if(oiCdContaOut != -1) {
            STRCPY_FROM_ORA(ptGestorMiscAux->szCdConta, oszCdContaOut);
        }

    }

    EXEC SQL CLOSE cA2;
    ULOG("iCount(%d) m_iQtdElementosAlocados(%d) m_iQtdElementosObtidos(%d)", iCount, m_iQtdElementosAlocados, m_iQtdElementosObtidos);


    ULOGI("Finalizando proCBuscaGestorMiscContasDisp");
    ULOG_END("CGestorMiscpc::proCBuscaGestorMiscContasDisp");
    return;

    erro:
        ULOGE("Finalizando proCBuscaGestorMiscContasDisp <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/****************************************************************************************/
void CGestorMiscpc::proCBuscaGestorMiscCNPJDisp(void)
{
    ULOG_START("CGestorMiscpc::proCBuscaGestorMiscCNPJDisp");

    TGestorMisc *ptGestorMiscAux;
    struct sqlca sqlca;
    int iCount;

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszNrDocumento[LEN_NRDOCUMENTO];
        VARCHAR oszIdConta[LEN_IDCONTA];
        VARCHAR oszCdConta[LEN_CDCONTA];

        short oiIdConta = 0;
        short oiCdConta = 0;
    EXEC SQL END DECLARE SECTION;


    STRCPY_TO_ORA(oszNrDocumento, tGestorMiscInput.szNrDocumento);

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND DO break;

    EXEC SQL DECLARE cA3 CURSOR FOR
        SELECT DISTINCT
            cc.idconta,
            cc.cdconta
        FROM
            customer.documento cd,
            customer.pessoadocumento cpd,
            customer.pessoaconta cpc,
            customer.conta cc,
            customer.pessoadepara cpdp,
            apoio.tipodocumento atd,
            customer.gestorconta cgc,
            customer.gestorcontacontato cgcc,
            customer.gestorcontapessoaconta cgcpc
        WHERE
            cd.iddocumento = cpd.iddocumento
        AND
            cpd.idpessoa = cpdp.idpessoa
        AND
            cpdp.idpessoadepara = cpc.idpessoadepara
        AND
            cpc.idconta = cc.idconta
        AND
            cd.idtipodocumento = atd.idtipodocumento
        AND
            cgc.idnrcpf = cgcc.idnrcpf
        AND
            cgcc.idnrcpf = cgcpc.idnrcpf
        AND
            cgcpc.idpessoaconta = cpc.idpessoaconta
        AND
            atd.sgclassificacao = 'CNPJ'
        AND
            cd.nrdocumento = :oszNrDocumento
        ORDER BY
            cc.cdconta;


    EXEC SQL OPEN cA3;

    for(iCount=0, ptGestorMiscAux=m_ptGestorMisc;;iCount++, ptGestorMiscAux++, m_iQtdElementosObtidos++)
    {

        EXEC SQL FETCH cA3 INTO
             :oszIdConta,
             :oszCdConta;

        // ULOG("m_iQtdElementosAlocados(%d)iCount(%d)", m_iQtdElementosAlocados, iCount);


        /* Verifica se precisa realocar espaco */
        if(iCount >= m_iQtdElementosAlocados) {
            m_iQtdElementosAlocados++;

            ULOG("Realocando memoria [%p]", m_ptGestorMisc);
            m_ptGestorMisc = (TGestorMisc *) realloc(m_ptGestorMisc, sizeof(TGestorMisc) * (m_iQtdElementosAlocados));
            ULOG("Memoria realocada [%p] bloco(%d)", m_ptGestorMisc, sizeof(TGestorMisc) * (m_iQtdElementosAlocados));

            /* Atribui o novo endereco obtido e posiciona o ponteiro na posicao do ultimo registro obtido antes da realocacao */
            ptGestorMiscAux = m_ptGestorMisc+iCount;
        }

        /* copia as informacoes obtidas para o ponteiro */
        memset(ptGestorMiscAux, 0x00, sizeof(TGestorMisc));
        STRCPY_FROM_ORA(ptGestorMiscAux->szIdConta, oszIdConta);
        STRCPY_FROM_ORA(ptGestorMiscAux->szCdConta, oszCdConta);

    }

    EXEC SQL CLOSE cA3;
    ULOG("iCount(%d) m_iQtdElementosAlocados(%d) m_iQtdElementosObtidos(%d)", iCount, m_iQtdElementosAlocados, m_iQtdElementosObtidos);


    ULOGI("Finalizando proCBuscaGestorMiscCNPJDisp");
    ULOG_END("CGestorMiscpc::proCBuscaGestorMiscCNPJDisp");
    return;

    erro:
        ULOGE("Finalizando proCBuscaGestorMiscCNPJDisp <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/****************************************************************************************/
void CGestorMiscpc::proCBuscaUF(void)
{
    ULOG_START("CGestorMiscpc::proCBuscaUF");

    TGestorMisc *ptGestorMiscAux;
    struct sqlca sqlca;
    int iCount;

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdUF[LEN_IDUF];
        VARCHAR oszSgUF[LEN_SGUF];

        short oiIdUF = 0;
        short oiSgUF = 0;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND DO break;

    EXEC SQL DECLARE cUF CURSOR FOR
        SELECT
            uf.iduf,
            uf.sguf
        FROM
            apoio.uf uf
        WHERE
            uf.iduf > 0
        AND
            uf.sguf != 'spsp'
        AND
            uf.sguf IN ('AC', 'AL', 'AP', 'AM', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MT', 'MS', 'MG', 'PA', 'PB', 'PR', 'PE', 'PI', 'RJ', 'RN', 'RS', 'RO', 'RR', 'SC', 'SP', 'SE', 'TO')
        ORDER BY
            uf.sguf;



    EXEC SQL OPEN cUF;

    for(iCount=0, ptGestorMiscAux=m_ptGestorMisc;;iCount++, ptGestorMiscAux++, m_iQtdElementosObtidos++)
    {

        EXEC SQL FETCH cUF INTO
            :oszIdUF:oiIdUF,
            :oszSgUF:oiSgUF;

        // ULOG("m_iQtdElementosAlocados(%d)iCount(%d)", m_iQtdElementosAlocados, iCount);


        /* Verifica se precisa realocar espaco */
        if(iCount >= m_iQtdElementosAlocados) {
            m_iQtdElementosAlocados++;

            ULOG("Realocando memoria [%p]", m_ptGestorMisc);
            m_ptGestorMisc = (TGestorMisc *) realloc(m_ptGestorMisc, sizeof(TGestorMisc) * (m_iQtdElementosAlocados));
            ULOG("Memoria realocada [%p] bloco(%d)", m_ptGestorMisc, sizeof(TGestorMisc) * (m_iQtdElementosAlocados));

            /* Atribui o novo endereco obtido e posiciona o ponteiro na posicao do ultimo registro obtido antes da realocacao */
            ptGestorMiscAux = m_ptGestorMisc+iCount;
        }

        /* copia as informacoes obtidas para o ponteiro */
        memset(ptGestorMiscAux, 0x00, sizeof(TGestorMisc));
        if(oiIdUF != -1) {
            STRCPY_FROM_ORA(ptGestorMiscAux->szIdUF, oszIdUF);
        }
        if(oiSgUF != -1) {
            STRCPY_FROM_ORA(ptGestorMiscAux->szSgUF, oszSgUF);
        }

    }

    EXEC SQL CLOSE cUF;
    ULOG("iCount(%d) m_iQtdElementosAlocados(%d) m_iQtdElementosObtidos(%d)", iCount, m_iQtdElementosAlocados, m_iQtdElementosObtidos);

    ULOGI("Finalizando proCBuscaUF");
    ULOG_END("CGestorMiscpc::proCBuscaUF");
    return;

    erro:
        ULOGE("Finalizando proCBuscaUF <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/****************************************************************************************/
void CGestorMiscpc::proCBuscaGestorContaDinamica(void)
{
    ULOG_START("CGestorContapc::proCBuscaGestorContaDinamica");

    struct sqlca sqlca;
    TGestorMisc *ptGestorMiscAux;
    int iCount;
    char szQueryAux[1000 + LEN_EOS];

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdNrCPF[LEN_IDNRCPF];
        VARCHAR oszNmNomeGestor[LEN_NMNOMEGC];
        VARCHAR oszNmNomeCliente[LEN_NMPESSOA];
        VARCHAR oszIdNrLinha[LEN_IDNRLINHA];
        VARCHAR oszCdConta[LEN_CDCONTA];
        VARCHAR oszDsTipoGestor[LEN_DSTIPOGESTOR];

        char oszPesquisaFinal[5000];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR goto erro;

    strcpy(oszPesquisaFinal,
        "SELECT "
            "cgc.idnrcpf as NrCPF, "
            "cgc.nmnome || ' ' || cgc.nmnomemeio || ' ' || cgc.nmsobrenome as NomeGestor, "
            "cp.nmnome || ' ' || cp.nmnomemeio || ' ' || cp.nmsobrenome as NomeCliente, "
            "cgcc.cdarearegistro || cgcc.idnrlinha as TelefoneContato, "
            "cc.cdconta as NumeroConta, "
            "cgc.dstipogestor as TipoGestor "
        "FROM "
            "customer.gestorconta cgc, "
            "customer.gestorcontacontato cgcc, "
            "customer.gestorcontapessoaconta cgcpc, "
            "customer.pessoaconta cpc, "
            "customer.pessoa cp, "
            "customer.pessoadepara cpdp, "
            "customer.conta cc, "
            "customer.pessoadocumento cpd, "
            "customer.documento cd, "
            "apoio.tipodocumento atd, "
            "apoio.tipocomunicacao atc "
        "WHERE "
            "cgc.idnrcpf = cgcc.idnrcpf "
        "AND "
            "cgcc.idnrcpf = cgcpc.idnrcpf "
        "AND "
            "cgcpc.idpessoaconta = cpc.idpessoaconta "
        "AND "
            "cpc.idpessoadepara = cpdp.idpessoadepara "
        "AND "
            "cpdp.idpessoa = cp.idpessoa "
        "AND "
            "cpc.idconta = cc.idconta "
        "AND "
            "cpd.idpessoa = cp.idpessoa "
        "AND "
            "cpd.iddocumento = cd.iddocumento "
        "AND "
            "atd.sgtipodocumento = 'CNPJ' "
        "AND "
            "cgcc.idtipocomunicacao = atc.idtipocomunicacao "
        "AND "
            "atc.dstipocomunicacao = 'CELULAR' "
        "AND "
           "cd.idtipodocumento = atd.idtipodocumento ");


    memset(szQueryAux, 0x00, sizeof(szQueryAux));

    /* Parte dinamica */
    /* Nome do Gestor */
    if(strlen(tGestorMiscInput.szNmNome) > 0)
    {
        sprintf(szQueryAux,
            "AND "
                "cgc.nmnome = '%s' "
            "AND "
                "cgc.nmnomemeio = '%s' "
            "AND "
                " cgc.nmsobrenome = '%s' ",   tGestorMiscInput.szNmNome,
                                              tGestorMiscInput.szNmNomeMeio,
                                              tGestorMiscInput.szNmSobreNome);

        ULOG("1.szQueryAux[%s]", szQueryAux);
        strcat(oszPesquisaFinal, szQueryAux);
        ULOG("1.oszPesquisaFinal[%s]", oszPesquisaFinal);
    }


    /* CPF Gestor */
    if(strlen(tGestorMiscInput.szNrDocumento) > 0)
    {
        sprintf(szQueryAux,
            "AND "
                "cgc.idnrcpf = %s ", tGestorMiscInput.szNrDocumento);

        ULOG("2.szQueryAux[%s]", szQueryAux);
        strcat(oszPesquisaFinal, szQueryAux);
        ULOG("2.oszPesquisaFinal[%s]", oszPesquisaFinal);
    }


    /* Conta Cliente */
    if(strlen(tGestorMiscInput.szCdContaCliente) > 0)
    {
        sprintf(szQueryAux,
            "AND "
                "cc.cdconta = '%s' ", tGestorMiscInput.szCdContaCliente);

        ULOG("3.szQueryAux[%s]", szQueryAux);
        strcat(oszPesquisaFinal, szQueryAux);
        ULOG("3.oszPesquisaFinal[%s]", oszPesquisaFinal);
    }


    /* CNPJ Cliente */
    if(strlen(tGestorMiscInput.szNrDocumentoCliente) > 0)
    {
        sprintf(szQueryAux,
            "AND "
                "cd.nrdocumento = '%s' ", tGestorMiscInput.szNrDocumentoCliente);

        ULOG("4.szQueryAux[%s]", szQueryAux);
        strcat(oszPesquisaFinal, szQueryAux);
        ULOG("4.oszPesquisaFinal[%s]", oszPesquisaFinal);
    }



    ULOGI("Pesquisa[%s]", oszPesquisaFinal);
    EXEC SQL PREPARE qPesquisa FROM :oszPesquisaFinal;
    EXEC SQL DECLARE cDinamic CURSOR FOR qPesquisa;

    EXEC SQL OPEN cDinamic;

    for(iCount=0, ptGestorMiscAux=m_ptGestorMisc;;iCount++, ptGestorMiscAux++, m_iQtdElementosObtidos++)
    {
        EXEC SQL FETCH cDinamic INTO
            :oszIdNrCPF,
            :oszNmNomeGestor,
            :oszNmNomeCliente,
            :oszIdNrLinha,
            :oszCdConta,
            :oszDsTipoGestor;

        // ULOG("m_iQtdElementosAlocados(%d)iCount(%d)", m_iQtdElementosAlocados, iCount);


        /* Verifica se precisa realocar espaco */
        if(iCount >= m_iQtdElementosAlocados) {
            m_iQtdElementosAlocados++;

            ULOG("Realocando memoria [%p]", m_ptGestorMisc);
            m_ptGestorMisc = (TGestorMisc *) realloc(m_ptGestorMisc, sizeof(TGestorMisc) * (m_iQtdElementosAlocados));
            ULOG("Memoria realocada [%p] bloco(%d)", m_ptGestorMisc, sizeof(TGestorMisc) * (m_iQtdElementosAlocados));

            /* Atribui o novo endereco obtido e posiciona o ponteiro na posicao do ultimo registro obtido antes da realocacao */
            ptGestorMiscAux = m_ptGestorMisc+iCount;
        }

        /* copia as informacoes obtidas para o ponteiro */
        memset(ptGestorMiscAux, 0x00, sizeof(TGestorMisc));
        STRCPY_FROM_ORA(ptGestorMiscAux->szIdNrCPF, oszIdNrCPF);
        STRCPY_FROM_ORA(ptGestorMiscAux->szNmNomeGestor, oszNmNomeGestor);
        STRCPY_FROM_ORA(ptGestorMiscAux->szNmNomeCliente, oszNmNomeCliente);
        STRCPY_FROM_ORA(ptGestorMiscAux->szIdNrLinha, oszIdNrLinha);
        STRCPY_FROM_ORA(ptGestorMiscAux->szCdConta, oszCdConta);
        STRCPY_FROM_ORA(ptGestorMiscAux->szDsTipoGestor, oszDsTipoGestor);
    }


    EXEC SQL CLOSE cDinamic;

    ULOGI("Finalizando CGestorMiscpc::proCBuscaGestorContaDinamica");
    ULOG_END("CGestorMiscpc::proCBuscaGestorContaDinamica");
    return;

    erro:
        ULOGE("Finalizando CGestorMiscpc::proCBuscaGestorContaDinamica <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/****************************************************************************************/
bool CGestorMiscpc::buscaIdPessoaConta(void)
{
    ULOG_START("CGestorMiscpc::buscaIdPessoaConta");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdConta[LEN_IDCONTA];
        VARCHAR oszIdPessoaConta[LEN_IDPESSOACONTA];

        short oiIdPessoaConta = 0;
    EXEC SQL END DECLARE SECTION;


    STRCPY_TO_ORA(oszIdConta, tGestorMiscInput.szIdConta);

    EXEC SQL WHENEVER SQLERROR  goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    EXEC SQL
        SELECT
            cpc.idpessoaconta
        INTO
            :oszIdPessoaConta:oiIdPessoaConta
        FROM
            customer.pessoaconta cpc,
            customer.conta cc
        WHERE
            cpc.idconta = cc.idconta
        AND
            cc.idconta = :oszIdConta;



    if(oiIdPessoaConta != -1) {
        STRCPY_FROM_ORA(tGestorMiscInput.szIdPessoaConta, oszIdPessoaConta);
    }


    ULOGI("Finalizando buscaIdPessoaConta <FOUND>");
    ULOG_END("CGestorMiscpc::buscaIdPessoaConta");
    return true;

    naoexiste:
        ULOGI("Finalizando buscaIdPessoaConta <NOT FOUND>");
        ULOG_END("CGestorMiscpc::proCBbuscaIdPessoaContauscaIdPessoaConta");
        return false;

    erro:
        ULOGE("Finalizando buscaIdPessoaConta <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}
