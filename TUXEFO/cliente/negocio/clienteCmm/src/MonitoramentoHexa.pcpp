// MonitoramentoHexa.pcpp: implementation for the 
// CMonitoramentoHexa class.
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw.h>
#include "../include/Funcoes.h"
EXEC SQL INCLUDE "../include/MonitoramentoHexa.h";

char szAux[512 + 1];

//
// Construtor e Destrutor
CMonitoramentoHexa::CMonitoramentoHexa() {
	icDtConsulta = -1;
	icCdHexa = -1;
	icCdDecimal = -1;
	icNrDocumento = -1;

	memset(sIdUsuarioAlteracao,0,256);
}

CMonitoramentoHexa::~CMonitoramentoHexa() {
}

// Usuário de alteração
void CMonitoramentoHexa::setUsuarioAlteracao(char* value) {
	if (value != NULL) {
		strncpy(sIdUsuarioAlteracao,value, 255);
		sIdUsuarioAlteracao[255]='\0';
	}
}

//
// Metodos getter
char* CMonitoramentoHexa::getDtConsulta(){
	if (icDtConsulta < 0)
		return NULL;
	else
		return cDtConsulta;
}

int CMonitoramentoHexa::getIdLinha() {
	return iIdLinha;
}

char* CMonitoramentoHexa::getNrLinha(){
	return cNrLinha;
}

int CMonitoramentoHexa::getIdUsuario(){
	return iIdUsuario;
}

char* CMonitoramentoHexa::getNmLogin(){
	return cNmLogin;
}

char* CMonitoramentoHexa::getCdHexa(){
	if (icCdHexa < 0)
		return NULL;
	else
		return cCdHexa;
}

char* CMonitoramentoHexa::getCdDecimal(){
	if (icCdDecimal < 0)
		return NULL;
	else
		return cCdDecimal;
}

char* CMonitoramentoHexa::getDsTipoLinha(){
	return cDsTipoLinha;
}

char* CMonitoramentoHexa::getNrDocumento(){
	return cNrDocumento;
}

char* CMonitoramentoHexa::getDsTipoDocumento(){
	return cDsTipoDocumento;
}

//
// Metodos setter
void CMonitoramentoHexa::setDtConsulta(char* value){
	if(value == NULL)
		icDtConsulta = -1;
	else {
		strncpy(cDtConsulta, value, 256);
		cDtConsulta[256]='\0';
		icDtConsulta= strlen(value);
	}
}

void CMonitoramentoHexa::setIdLinha(int value) {
	iIdLinha = value;
}

void CMonitoramentoHexa::setNrLinha(char* value) {
	strncpy(cNrLinha, value, 256);
	cNrLinha[256]='\0';
}

void CMonitoramentoHexa::setIdUsuario(int value) {
	iIdUsuario = value;
}

void CMonitoramentoHexa::setNmLogin(char* value){
	strncpy(cNmLogin, value, 256);
	cNmLogin[256]='\0';
}

void CMonitoramentoHexa::setCdHexa(char* value){
	if(value == NULL)
		icCdHexa = -1;
	else {
		strncpy(cCdHexa, value, 256);
		cCdHexa[256]='\0';
		icCdHexa= strlen(value);
	}
}

void CMonitoramentoHexa::setCdDecimal(char* value){
	if(value == NULL)
		icCdDecimal = -1;
	else {
		strncpy(cCdDecimal, value, 256);
		cCdDecimal[256]='\0';
		icCdDecimal= strlen(value);
	}
}

void CMonitoramentoHexa::setDsTipoLinha(char* value){
	strncpy(cDsTipoLinha, value, 256);
	cDsTipoLinha[256]='\0';
}

void CMonitoramentoHexa::setNrDocumento(char* value){
	strncpy(cNrDocumento, value, 256);
	cNrDocumento[256]='\0';
}

void CMonitoramentoHexa::setDsTipoDocumento(char* value){
	strncpy(cDsTipoDocumento, value, 256);
	cDsTipoDocumento[256]='\0';
}

//
// Métodos de banco de dados
CMonitoramentoHexa* CMonitoramentoHexa::busca(char* cDtIni,
											  char* cDtFim, 
											  char* cNrLin, 
											  char* cNmLog, 
											  char* cCdHex, 
											  int* iNroObjetos) {

	
	ULOG_START("CMonitoramentoHexa::busca()");

    ULOG("cDtIni[%s]", cDtIni);
    ULOG("cDtFim[%s]", cDtFim);
    ULOG("cNrLin[%s]", cNrLin);
    ULOG("cNmLog[%s]", cNmLog);
    ULOG("cCdHex[%s]", cCdHex);

	struct sqlca sqlca;
	CMonitoramentoHexa* listaBusca = NULL;
	int iNroObjLocal = 1;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	EXEC SQL BEGIN DECLARE SECTION;
	// Parâmetros de entrada
	char cOraDtIni[256];
	char cOraDtFim[256];
	char cOraNrLin[256];
	char cOraNmLog[256];
	char cOraCdHex[256];

	// Resultado da busca
	char cDtConsulta[256];
	char cNmLogin[256];
	char cNrLinha[256];
	char cDsTipoLinha[256];
	char cNrDocumento[256];
	char cDsTipoDocumento[256];

	// Variáveis indicativas do oracle
	short icDtConsulta;
	short icNmLogin;
	short icCdHexa;
	short icCdDeci;
	short icNrDocumento;
	short icDsTipoDocumento;
	EXEC SQL END DECLARE SECTION;

	// Seta os valores para a busca
	strncpy(cOraDtIni,cDtIni,256);
	strncpy(cOraDtFim,cDtFim,256);

	if (cNrLin != NULL && *cNrLin != NULL) {
		strncpy(cOraNrLin, cNrLin, 10);
		cOraNrLin[10]='\0';
	} else {
		strcpy(cOraNrLin, "-1");
	}

	if (cNmLog != NULL && *cNmLog != NULL) {
		strncpy(cOraNmLog, cNmLog, 255);
		cOraNmLog[255]='\0';
	} else {
		sprintf(cOraNmLog, "-1");
	}

	if (cCdHex != NULL && *cCdHex != NULL) {
		strncpy(cOraCdHex, cCdHex, 255);
		cOraCdHex[255]='\0';
	} else {
		sprintf(cOraCdHex, "-1");
	}


    ULOG("cOraDtIni[%s]", cOraDtIni);
    ULOG("cOraDtFim[%s]", cOraDtFim);
    ULOG("cOraNrLin[%s]", cOraNrLin);
    ULOG("cOraNmLog[%s]", cOraNmLog);
    ULOG("cOraCdHex[%s]", cOraCdHex);


	// Monta a query.
	EXEC SQL DECLARE consultas CURSOR FOR
    SELECT 
           TO_CHAR(dtConsulta, 'DD/MM/YYYY HH24:MI:SS'),
	       /* '('||substr(Linha,0,2)||')'||substr(linha,3,4)||'-'||substr(linha,7,4), */
           soa_ow.formata_nrlinha(substr(Linha,1,2)||substr(linha,3)) ,
	       NmLoginUsuario,
	       DsTipoLinha,
	       nrDocumento,
           dstipodocumento
	  FROM Linha.HexaConsLogV01
	 WHERE dtConsulta >= TO_DATE(:cOraDtIni || ' 00:00:00','DD/MM/YYYY HH24:MI:SS')
       AND dtConsulta <= TO_DATE(:cOraDtFim || ' 23:59:59','DD/MM/YYYY HH24:MI:SS')
       AND (Linha = :cOraNrLin OR :cOraNrLin = '-1') 
       AND (upper(NmLoginUsuario) = upper(:cOraNmLog) OR :cOraNmLog = '-1') 
       AND (sgserial = UPPER(:cOraCdHex) OR :cOraCdHex = '-1')
  ORDER BY
     DtConsulta;

	// Prepara e abre o cursor
	EXEC SQL OPEN consultas;

	// Corre os dados e monta a lista de objetos
	EXEC SQL WHENEVER NOT FOUND DO break;
	for (;; iNroObjLocal++) {

		EXEC SQL FETCH consultas INTO
		 cDtConsulta:icDtConsulta,
		 cNrLinha,
		 cNmLogin:icNmLogin,
		 cDsTipoLinha,
		 cNrDocumento:icNrDocumento,
         cDsTipoDocumento:icDsTipoDocumento;

		// Aloca memória para o objeto atual.
		if ((listaBusca = (CMonitoramentoHexa*) realloc((void *)listaBusca, (sizeof(CMonitoramentoHexa) * iNroObjLocal))) != NULL) {
			
			// Coloca os dados do objeto atual.
			listaBusca[iNroObjLocal-1].setDtConsulta(icDtConsulta < 0 ? NULL : rtrim(cDtConsulta));
			listaBusca[iNroObjLocal-1].setNmLogin(icNmLogin < 0 ? NULL : rtrim(cNmLogin));
			listaBusca[iNroObjLocal-1].setNrLinha(rtrim(cNrLinha));
            
			listaBusca[iNroObjLocal-1].setDsTipoLinha(rtrim(cDsTipoLinha));
			listaBusca[iNroObjLocal-1].setNrDocumento(icNrDocumento < 0 ? NULL : rtrim(cNrDocumento));
			listaBusca[iNroObjLocal-1].setDsTipoDocumento(icDsTipoDocumento < 0 ? NULL : rtrim(cDsTipoDocumento));

		} else {
			if (listaBusca)
				free(listaBusca);
			throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
		}
	}

	*iNroObjetos = iNroObjLocal - 1;
    ULOG("*iNroObjetos(%d)", *iNroObjetos);
	ULOG_END("CMonitoramentoHexa::busca()");
	return listaBusca;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CMonitoramentoHexa::busca()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

/*********************************************************************************/
void CMonitoramentoHexa::registraConsulta() {

	ULOG_START("CMonitoramentoHexa::registraConsulta()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		int iNovoId;
	EXEC SQL END DECLARE SECTION;
	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorIns;

	// Busca o novo ID da sequence.
	EXEC SQL
		SELECT Linha.LogConsultaHexaSQ.NEXTVAL
		INTO :iNovoId
		FROM DUAL;
	if (sqlca.sqlcode)
	{
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CMonitoramentoHexa::registraConsulta()");
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	// Insere
	EXEC SQL INSERT INTO Linha.LogConsultaHexa
	(IdLogConsultaHexa,
	 DtConsulta,
	 IdLinhaTelefonica,
	 IdPessoaUsuario,
	 SgSerial,
	 IdUsuarioAlteracao,
	 DtUltimaAlteracao)
	VALUES
	(:iNovoId,
	 SYSDATE,
	 :iIdLinha,
	 :iIdUsuario,
	 :cCdHexa:icCdHexa,
	 :sIdUsuarioAlteracao,
	 SYSDATE);

	ULOG_END("CMonitoramentoHexa::registraConsulta()");
	return;

	sqlErrorIns:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CMonitoramentoHexa::registraConsulta()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

/*********************************************************************************/
bool CMonitoramentoHexa::existeNrLinha(char *pszNrLinha)
{
	ULOG_START("CMonitoramentoHexa::existeNrLinha()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		int iQtd;
        char oszNrLinha[80];
	EXEC SQL END DECLARE SECTION;

    
    strncpy(oszNrLinha, pszNrLinha, 80);

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorIns;

	EXEC SQL
		SELECT COUNT(1)
		INTO :iQtd
		FROM  Linha.HexaConsLogV01
        WHERE linha = :oszNrLinha;

    ULOG( "iQtd(%d)", iQtd);
    

    ULOG_END("CMonitoramentoHexa::existeNrLinha()");
    
    if(iQtd > 0)
        return true;
    else
        return false;

	sqlErrorIns:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CMonitoramentoHexa::existeNrLinha()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

/*********************************************************************************/
bool CMonitoramentoHexa::existeNmLogin(char *pszNmLogin)
{
	ULOG_START("CMonitoramentoHexa::existeNmLogin()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		int iQtd;
        char oszNmLogin[255];
	EXEC SQL END DECLARE SECTION;

    
    strncpy(oszNmLogin, pszNmLogin, 255);

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorIns;

	EXEC SQL
		SELECT COUNT(1)
		INTO :iQtd
		FROM  Linha.HexaConsLogV01
        WHERE nmloginusuario = :oszNmLogin;

    ULOG("iQtd(%d)", iQtd);
    

    ULOG_END("CMonitoramentoHexa::existeNmLogin()");
    if(iQtd > 0)
        return true;
    else
        return false;

	sqlErrorIns:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CMonitoramentoHexa::existeNmLogin()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

/*********************************************************************************/
bool CMonitoramentoHexa::existeCdHexa(char *pszCdHexa)
{
	ULOG_START("CMonitoramentoHexa::existeCdHexa()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		int iQtd;
        char oszCdHexa[255];
	EXEC SQL END DECLARE SECTION;

    
    strncpy(oszCdHexa, pszCdHexa, 255);

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorIns;

	EXEC SQL
		SELECT COUNT(1)
		INTO :iQtd
		FROM  Linha.HexaConsLogV01
        WHERE sgserial = UPPER(:oszCdHexa);

    ULOG("iQtd(%d)", iQtd);
    
    ULOG_END("CMonitoramentoHexa::existeCdHexa()");
    if(iQtd > 0)
        return true;
    else
        return false;

	sqlErrorIns:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CMonitoramentoHexa::existeCdHexa()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

/*********************************************************************************/
bool CMonitoramentoHexa::existeCdDecimal(char *pszCdDecimal)
{
	ULOG_START("CMonitoramentoHexa::existeCdDecimal()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		int iQtd;
        char oszCdDecimal[255];
	EXEC SQL END DECLARE SECTION;

    
    strncpy(oszCdDecimal, pszCdDecimal, 255);

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorIns;

	EXEC SQL
		SELECT COUNT(1)
		INTO :iQtd
		FROM  Linha.HexaConsLogV01
        WHERE TO_NUMBER(LTRIM(RTRIM(sgserial)), 'xxxxxxxx') = TO_NUMBER(:oszCdDecimal);

    ULOG( "iQtd(%d)", iQtd);
    

    ULOG_END("CMonitoramentoHexa::existeCdDecimal()");
    if(iQtd > 0)
        return true;
    else
        return false;

	sqlErrorIns:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CMonitoramentoHexa::existeCdDecimal()");
		throw TuxBasicOraException(sqlca.sqlcode);
}


/*********************************************************************************/
char *CMonitoramentoHexa::convertDecimal2Hexa(char *pszCdDecimal)
{
	ULOG_START("CMonitoramentoHexa::convertDecimal2Hexa()");
	struct sqlca sqlca;
    static char szCdHexa[255 + 1];

	EXEC SQL BEGIN DECLARE SECTION;
        char oszCdDecimal[255];
        char oszCdHexa[255];
	EXEC SQL END DECLARE SECTION;
    
    ULOG("pszCdDecimal[%s]", pszCdDecimal);
    strncpy(oszCdDecimal, pszCdDecimal, 255);

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorIns;

	EXEC SQL
		SELECT LTRIM(RTRIM(UPPER(TO_CHAR(:oszCdDecimal, 'xxxxxxxxxx'))))
		INTO :oszCdHexa
		FROM DUAL;

    ULOG("oszCdHexa[%s]", oszCdHexa);
    strcpy(szCdHexa, rtrim(oszCdHexa));
    ULOG("szCdHexa[%s]", szCdHexa);
    
    ULOG_END("CMonitoramentoHexa::convertDecimal2Hexa()");
    return szCdHexa;

	sqlErrorIns:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CMonitoramentoHexa::convertDecimal2Hexa()");
		throw TuxBasicOraException(sqlca.sqlcode);
}
