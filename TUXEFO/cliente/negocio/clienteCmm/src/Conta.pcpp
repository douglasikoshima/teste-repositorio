//----------------------------------------------------------------------------------------------------
// Conta.pcpp: implementation for the 
// CConta class.
//----------------------------------------------------------------------------------------------------

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw.h>
EXEC SQL BEGIN DECLARE SECTION;
#include "../include/Global.h"
EXEC SQL END DECLARE SECTION;

#include "../include/Funcoes.h"
#undef MSG_NONE
#define MSG_NONE
#include "../include/Messages.h"

EXEC SQL INCLUDE "../include/Conta.h";

char pCtaSisOrig[LEN_NUMBER + LEN_EOS]; // estava como var local

//----------------------------------------------------------------------------------------------------
// Construtor e Destrutor
//----------------------------------------------------------------------------------------------------

CConta::CConta() 
{
	memset(&tConta,0,sizeof(TConta));
}

//----------------------------------------------------------------------------------------------------
// Métodos de acesso a banco de dados
//----------------------------------------------------------------------------------------------------

void CConta::insereConta(void)
{
	proCInsereConta(&tConta);
}

//----------------------------------------------------------------------------------------------------

void CConta::atualizaConta(void)
{
	proCAtualizaConta(tConta);
}

//----------------------------------------------------------------------------------------------------
void CConta::setIdSistemaOrigem(char *pszIdSistemaOrigem)
{
    strcpy(tConta.szIdSistemaOrigem, pszIdSistemaOrigem);
}
//----------------------------------------------------------------------------------------------------
char *CConta::getIdSistemaOrigem(void)
{
    static char szAux[LEN_IDSISTEMAORIGEM + LEN_EOS];

    strcpy(szAux, tConta.szIdSistemaOrigem);
    return szAux;
}

//----------------------------------------------------------------------------------------------------

void CConta::setIdConta(char *pszIdConta)
{
    strcpy(tConta.szIdConta, pszIdConta);
}
//----------------------------------------------------------------------------------------------------

char *CConta::getIdConta(void)
{
    static char szAux[LEN_IDCONTA + LEN_EOS];

    strcpy(szAux, tConta.szIdConta);
    return szAux;
}

//----------------------------------------------------------------------------------------------------

char *CConta::getIdPessoaSistemaOrigem(void)
{
    static char szAux[LEN_IDPESSOASISTEMAORIGEM + LEN_EOS];

    strcpy(szAux, tConta.szIdSistemaOrigem);
    return szAux;
}

//----------------------------------------------------------------------------------------------------

char *CConta::getIdEnderecoSistemaOrigem(void)
{
    static char szAux[LEN_IDENDERECOSISTEMAORIGEM + LEN_EOS];
    return szAux;
}

//----------------------------------------------------------------------------------------------------

void CConta::setNrConta(char *pszNrConta)
{
    strcpy(tConta.szCdConta, pszNrConta);
}

//----------------------------------------------------------------------------------------------------

void CConta::setIdContaSistemaOrigem(char *pszIdContaSistemaOrigem)
{
    strcpy(tConta.szIdContaSistemaOrigem, pszIdContaSistemaOrigem);
}

//----------------------------------------------------------------------------------------------------

void CConta::setCdConta(char *pszCdConta)
{
    strcpy(tConta.szCdConta, pszCdConta);
}

//----------------------------------------------------------------------------------------------------

void CConta::setIdStatusConta(char *pszStatusConta)
{
    strcpy(tConta.szIdStatusConta, pszStatusConta);
}

//----------------------------------------------------------------------------------------------------

void CConta::setIdTipoConta(char *pszIdTipoConta)
{
    strcpy(tConta.szIdTipoConta, pszIdTipoConta);
}

//----------------------------------------------------------------------------------------------------
void CConta::setData(char *IdLinhaTelefonica)
{

  setIdSistemaOrigem("2"); 
  setIdStatusConta	("0");    
  setIdContaSistemaOrigem( IdLinhaTelefonica ); 

  strcpy( tConta.szIdConta,				"0" ); 
  strcpy( tConta.szIdLayoutConta,		"0" ); 
  strcpy( tConta.szIdTipoConta,			"0" ); 
  strcpy( tConta.szCdConta,				"0" ); 
  strcpy( tConta.szCdDigitoConta,		"0" ); 
  strcpy( tConta.szCdCicloFaturamento,	"0" ); 
  strcpy( tConta.szNrDiaVencimento,		"0" ); 
  strcpy( tConta.szInContaPorEmail,		"0" ); 
  strcpy( tConta.szTsSincronismoPrincipal, "0" ); 
  strcpy( tConta.szSqSincronismoPrincipal, "0" ); 
  strcpy( tConta.szTsSincronismoCiclo, "0" ); 
  strcpy( tConta.szSqSincronismoCiclo, "0" ); 
  strcpy( tConta.szTsSincronismoStatus, "0" ); 
  strcpy( tConta.szSqSincronismoStatus, "0" ); 
  strcpy( tConta.szNrDiaPerioDoCicloDe, "0" ); 
		
}
//----------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------
char* CConta::getContaSisOrigem(char* pcNrConta, int iIdPessoa) 
{
    ULOG_START("CConta::getContaSisOrigem()");
	struct sqlca sqlca;

    memset(pCtaSisOrig,0,sizeof(pCtaSisOrig));

	EXEC SQL BEGIN DECLARE SECTION;
		char *pcOraNrConta;
		int iNrCont;
		char cIdContSisOr[LEN_NUMBER + LEN_EOS];
		int iOraIdPessoa;
	EXEC SQL END DECLARE SECTION;

    

    ULOG("pcNrConta[%s]", pcNrConta);
    ULOG("iIdPessoa(%d)", iIdPessoa);

    memset(cIdContSisOr, 0x00, sizeof(cIdContSisOr));

	iOraIdPessoa = iIdPessoa;
	pcOraNrConta = pcNrConta;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
	EXEC SQL WHENEVER NOT FOUND GOTO sqlNotFound;

    ULOG("local 1");

	// Checa se a conta existe.
	EXEC SQL SELECT count(1)
	           INTO :iNrCont
	           FROM customer.conta
	          WHERE cdconta = :pcOraNrConta;

    ULOG("iNrCont(%d)", iNrCont);

	// Conta não existe.
	if (iNrCont == 0){
        strcpy(pCtaSisOrig, "c"); /*conta nao existe*/
        return pCtaSisOrig;
    }

    ULOG("local 2");

	// Recupera o ID se a conta for da pessoa.
	EXEC SQL SELECT DISTINCT LPAD(CONT.IdContaSistemaOrigem, 10, '0')
	           INTO :cIdContSisOr
	           FROM CUSTOMER.CONTA CONT,
	                CUSTOMER.PESSOACONTA PESSCON,
	                CUSTOMER.PESSOADEPARA PESSDPCON
	          WHERE PESSDPCON.IDPESSOADEPARA = PESSCON.IDPESSOADEPARA 
                AND PESSCON.IDCONTA = CONT.IDCONTA 
                AND CONT.CDCONTA = :pcOraNrConta 
                AND PESSDPCON.IDPESSOAORIGEM = :iOraIdPessoa;
	 

    strcpy(pCtaSisOrig, cIdContSisOr);

    ULOG("pCtaSisOrig[%s]", pCtaSisOrig);
    
    ULOG_END("CConta::getContaSisOrigem()");
	return rtrim(pCtaSisOrig);

	sqlNotFound:
        strcpy(pCtaSisOrig, "n"); /*conta nao nao pertence a esse ID*/
        ULOG_END("CConta::getContaSisOrigem()");
        return pCtaSisOrig;

	sqlError:
        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
        ULOG_END("CConta::getContaSisOrigem()");
		throw TuxBasicOraException(sqlca.sqlcode);
}

//----------------------------------------------------------------------------------------------------
// Insere registro 
//----------------------------------------------------------------------------------------------------

void CConta::proCInsereConta(TConta *ptConta)
{
    ULOG_START("CConta::proCInsereConta()");
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdConta[LEN_IDCONTA];
        VARCHAR oszIdSistemaOrigem[LEN_IDSISTEMAORIGEM];
        VARCHAR oszIdLayoutConta[LEN_IDLAYOUTCONTA];
        VARCHAR oszIdTipoConta[LEN_IDTIPOCONTA];
        VARCHAR oszCdConta[LEN_CDCONTA];
        VARCHAR oszCdDigitoConta[LEN_CDDIGITOCONTA];
        VARCHAR oszCdCicloFaturamento[LEN_CDCICLOFATURAMENTO];
        VARCHAR oszNrDiaVencimento[LEN_NRDIAVENCIMENTO];
        VARCHAR oszInContaPorEmail[LEN_INCONTAPOREMAIL];
        VARCHAR oszTsSincronismoPrincipal[LEN_TSSINCRONISMOPRINCIPAL];
        VARCHAR oszSqSincronismoPrincipal[LEN_SQSINCRONISMOPRINCIPAL];
        VARCHAR oszTsSincronismoCiclo[LEN_TSSINCRONISMOCICLO];
        VARCHAR oszSqSincronismoCiclo[LEN_SQSINCRONISMOCICLO];
        VARCHAR oszTsSincronismoStatus[LEN_TSSINCRONISMOSTATUS];
        VARCHAR oszSqSincronismoStatus[LEN_SQSINCRONISMOSTATUS];
        VARCHAR oszIdStatusConta[LEN_IDSTATUSCONTA];
        VARCHAR oszIdContaSistemaOrigem[LEN_IDCONTASISTEMAORIGEM];
        VARCHAR oszNrDiaPerioDoCicloDe[LEN_NRDIAPERIODOCICLODE];
        VARCHAR oszIdUsuarioAlteracao[LEN_IDUSUARIOALTERACAO];
    EXEC SQL END DECLARE SECTION;

	struct sqlca sqlca;

	

	/* atribui valores para as variaveis ProC */
    STRCPY_TO_ORA(oszIdSistemaOrigem,		ptConta->szIdSistemaOrigem);
    STRCPY_TO_ORA(oszIdLayoutConta,			ptConta->szIdLayoutConta);
    STRCPY_TO_ORA(oszIdTipoConta,			ptConta->szIdTipoConta);
    STRCPY_TO_ORA(oszCdDigitoConta,			ptConta->szCdDigitoConta);
    STRCPY_TO_ORA(oszCdCicloFaturamento,	ptConta->szCdCicloFaturamento);
    STRCPY_TO_ORA(oszNrDiaVencimento,		ptConta->szNrDiaVencimento);
    STRCPY_TO_ORA(oszInContaPorEmail,		ptConta->szInContaPorEmail);
    STRCPY_TO_ORA(oszTsSincronismoPrincipal,ptConta->szTsSincronismoPrincipal);
    STRCPY_TO_ORA(oszSqSincronismoPrincipal,ptConta->szSqSincronismoPrincipal);
    STRCPY_TO_ORA(oszTsSincronismoCiclo,	ptConta->szTsSincronismoCiclo);
    STRCPY_TO_ORA(oszSqSincronismoCiclo,	ptConta->szSqSincronismoCiclo);
    STRCPY_TO_ORA(oszTsSincronismoStatus,	ptConta->szTsSincronismoStatus);
    STRCPY_TO_ORA(oszSqSincronismoStatus,	ptConta->szSqSincronismoStatus);
    STRCPY_TO_ORA(oszIdStatusConta,			ptConta->szIdStatusConta);
    STRCPY_TO_ORA(oszIdContaSistemaOrigem,	ptConta->szIdContaSistemaOrigem);
    STRCPY_TO_ORA(oszNrDiaPerioDoCicloDe,	ptConta->szNrDiaPerioDoCicloDe);
    STRCPY_TO_ORA(oszIdUsuarioAlteracao ,	ID_USUARIO_ALTERACAO);
    STRCPY_TO_ORA(oszCdConta,				ptConta->szCdConta);

	EXEC SQL WHENEVER SQLERROR goto erro;

	EXEC SQL SELECT to_char(Customer.Contasq.nextval) INTO :oszIdConta FROM dual;

    /* Copia o valor da sequence para o ponteiro passado como parametro */
    STRCPY_FROM_ORA(ptConta->szIdConta, oszIdConta);

	EXEC SQL INSERT INTO Customer.Conta
	(
        idconta,
        idsistemaorigem,
        idlayoutconta,
        idtipoconta,
        cdconta,
        cddigitoconta,
        cdciclofaturamento,
        nrdiavencimento,
        incontaporemail,
        tssincronismoprincipal,
        sqsincronismoprincipal,
        tssincronismociclo,
        sqsincronismociclo,
        tssincronismostatus,
        sqsincronismostatus,
        idstatusconta,
        idcontasistemaorigem,
        nrdiaperiodociclode,
        idusuarioalteracao,
        dtultimaalteracao
    )
	VALUES
    (
        :oszIdConta,
        :oszIdSistemaOrigem,
        :oszIdLayoutConta,
        :oszIdTipoConta,
        :oszCdConta,
        :oszCdDigitoConta,
        :oszCdCicloFaturamento,
        :oszNrDiaVencimento,
        :oszInContaPorEmail,
        :oszTsSincronismoPrincipal,
        :oszSqSincronismoPrincipal,
        :oszTsSincronismoCiclo,
        :oszSqSincronismoCiclo,
        :oszTsSincronismoStatus,
        :oszSqSincronismoStatus,
        :oszIdStatusConta,
        :oszIdContaSistemaOrigem,
        :oszNrDiaPerioDoCicloDe,
        :oszIdUsuarioAlteracao,
        SYSDATE
    );

	ULOG_END("CConta::proCInsereConta()");
	return;

sqlNotFound:
	erro:
    	ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    	ULOG_END("CConta::proCInsereConta()");
		throw TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

//----------------------------------------------------------------------------------------------------
// Atualiza registro 
//----------------------------------------------------------------------------------------------------

void CConta::proCAtualizaConta(TConta tConta)
{
    ULOG_START("CConta::proCAtualizaConta()");
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdConta				 [LEN_IDCONTA];
        VARCHAR oszIdSistemaOrigem		 [LEN_IDSISTEMAORIGEM];
        VARCHAR oszIdLayoutConta		 [LEN_IDLAYOUTCONTA];
        VARCHAR oszIdTipoConta			 [LEN_IDTIPOCONTA];
        VARCHAR oszCdConta				 [LEN_CDCONTA];
        VARCHAR oszCdDigitoConta		 [LEN_CDDIGITOCONTA];
        VARCHAR oszCdCicloFaturamento	 [LEN_CDCICLOFATURAMENTO];
        VARCHAR oszNrDiaVencimento		 [LEN_NRDIAVENCIMENTO];
        VARCHAR oszInContaPorEmail		 [LEN_INCONTAPOREMAIL];
        VARCHAR oszTsSincronismoPrincipal[LEN_TSSINCRONISMOPRINCIPAL];
        VARCHAR oszSqSincronismoPrincipal[LEN_SQSINCRONISMOPRINCIPAL];
        VARCHAR oszTsSincronismoCiclo	 [LEN_TSSINCRONISMOCICLO];
        VARCHAR oszSqSincronismoCiclo	 [LEN_SQSINCRONISMOCICLO];
        VARCHAR oszTsSincronismoStatus   [LEN_TSSINCRONISMOSTATUS];
        VARCHAR oszSqSincronismoStatus	 [LEN_SQSINCRONISMOSTATUS];
        VARCHAR oszIdStatusConta		 [LEN_IDSTATUSCONTA];
        VARCHAR oszIdContaSistemaOrigem	 [LEN_IDCONTASISTEMAORIGEM];
        VARCHAR oszNrDiaPerioDoCicloDe	 [LEN_NRDIAPERIODOCICLODE];
        VARCHAR oszDtExpiracao			 [LEN_DTEXPIRACAO];
        VARCHAR oszIdUsuarioAlteracao	 [LEN_IDUSUARIOALTERACAO];
    EXEC SQL END DECLARE SECTION;

	struct sqlca sqlca;

	

	/* atribui valores para as variaveis ProC */
    STRCPY_TO_ORA(oszIdConta,				tConta.szIdConta);
    STRCPY_TO_ORA(oszIdSistemaOrigem,		tConta.szIdSistemaOrigem);
    STRCPY_TO_ORA(oszIdLayoutConta,			tConta.szIdLayoutConta);
    STRCPY_TO_ORA(oszIdTipoConta,			tConta.szIdTipoConta);
    STRCPY_TO_ORA(oszCdConta,				tConta.szCdConta);
    STRCPY_TO_ORA(oszCdDigitoConta,			tConta.szCdDigitoConta);
    STRCPY_TO_ORA(oszCdCicloFaturamento,	tConta.szCdCicloFaturamento);
    STRCPY_TO_ORA(oszNrDiaVencimento,		tConta.szNrDiaVencimento);
    STRCPY_TO_ORA(oszInContaPorEmail,		tConta.szInContaPorEmail);
    STRCPY_TO_ORA(oszTsSincronismoPrincipal,tConta.szTsSincronismoPrincipal);
    STRCPY_TO_ORA(oszSqSincronismoPrincipal,tConta.szSqSincronismoPrincipal);
    STRCPY_TO_ORA(oszTsSincronismoCiclo,	tConta.szTsSincronismoCiclo);
    STRCPY_TO_ORA(oszSqSincronismoCiclo,	tConta.szSqSincronismoCiclo);
    STRCPY_TO_ORA(oszTsSincronismoStatus,	tConta.szTsSincronismoStatus);
    STRCPY_TO_ORA(oszSqSincronismoStatus,	tConta.szSqSincronismoStatus);
    STRCPY_TO_ORA(oszIdStatusConta,			tConta.szIdStatusConta);
    STRCPY_TO_ORA(oszIdContaSistemaOrigem,	tConta.szIdContaSistemaOrigem);
    STRCPY_TO_ORA(oszNrDiaPerioDoCicloDe,	tConta.szNrDiaPerioDoCicloDe);
    STRCPY_TO_ORA(oszDtExpiracao,			tConta.szDtExpiracao);
    STRCPY_TO_ORA(oszIdUsuarioAlteracao,	ID_USUARIO_ALTERACAO);

	EXEC SQL WHENEVER SQLERROR goto erro;

	EXEC SQL UPDATE Customer.Conta
    SET
        idconta =				TO_NUMBER(:oszIdConta),
        idsistemaorigem =		TO_NUMBER(:oszIdSistemaOrigem),
        idlayoutconta =			TO_NUMBER(:oszIdLayoutConta),
        idtipoconta =			TO_NUMBER(:oszIdTipoConta),
        cdconta =				:oszCdConta,
        cddigitoconta =			:oszCdDigitoConta,
        cdciclofaturamento =	:oszCdCicloFaturamento,
        nrdiavencimento =		TO_NUMBER(:oszNrDiaVencimento),
        incontaporemail =		TO_NUMBER(:oszInContaPorEmail),
        tssincronismoprincipal= TO_NUMBER(:oszTsSincronismoPrincipal),
        sqsincronismoprincipal= TO_NUMBER(:oszSqSincronismoPrincipal),
        tssincronismociclo =	TO_NUMBER(:oszTsSincronismoCiclo),
        sqsincronismociclo =	TO_NUMBER(:oszSqSincronismoCiclo),
        tssincronismostatus =	TO_NUMBER(:oszTsSincronismoStatus),
        sqsincronismostatus =	TO_NUMBER(:oszSqSincronismoStatus),
        idstatusconta =			TO_NUMBER(:oszIdStatusConta),
        idcontasistemaorigem =	:oszIdContaSistemaOrigem,
        nrdiaperiodociclode =	TO_NUMBER(:oszNrDiaPerioDoCicloDe),
        dtexpiracao =			to_date(:oszDtExpiracao, 'YYYYMMDDHH24MISS'),
        idusuarioalteracao =	to_number(:oszIdUsuarioAlteracao),
        dtultimaalteracao =		SYSDATE
    WHERE
        idconta = TO_NUMBER(:oszIdConta);

	ULOG_END("CConta::proCAtualizaConta()");
	return;

	sqlNotFound:

	erro:
    	ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    	ULOG_END("CConta::proCAtualizaConta()");
		throw TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

//----------------------------------------------------------------------------------------------------

char** CConta::listaLinhasIntraGrupo(int* iNroObjetos) 
{
    ULOG_START("CConta::listaLinhasIntraGrupo()");
	struct sqlca sqlca;
	char** listalinTel = NULL;
	int iNroObjLocal = 1;

	EXEC SQL BEGIN DECLARE SECTION;
		char pcFone[256];
		char pcConta[256];
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorListaIG;

	

	memset(pcConta, 0, 256);
	strncpy(pcConta, tConta.szCdConta, 255);

	// Declara e abre o cursor
	EXEC SQL DECLARE linhas CURSOR FOR
      SELECT DISTINCT areareg.cdarearegistro || lb1.nrlinha
                 FROM linha.linhatelefonica linha,
                      linha.linhabase linbase,
                      apoio.arearegistro areareg,
                      linha.planoservico pserv,
                      linha.planoservicolinha pslinha,
                      linha.planoservicolinha pslinha1,
                      customer.linhaconta lincon,
                      customer.conta conta,
                      linha.linhabase lb1,
                      linha.linhatelefonica lt1
                WHERE linha.idlinhabase = linbase.idlinhabase
                  AND lb1.idarearegistro = areareg.idarearegistro
                  AND pslinha.idlinhatelefonica(+) = linha.idlinhatelefonica
                  AND pserv.idservico(+) = pslinha.idservico
                  AND lincon.idlinhatelefonica = linha.idlinhatelefonica
                  AND conta.idconta = lincon.idconta
                  AND pslinha.sqservicointragrupo = pslinha1.sqservicointragrupo
                  AND pslinha1.idlinhatelefonica = lt1.idlinhatelefonica
                  AND lt1.idlinhabase = lb1.idlinhabase
                  AND pslinha1.sqservicointragrupo <> 0
                  AND conta.cdconta = :pcConta;


	EXEC SQL OPEN linhas;

	// Corre os dados e monta a lista de objetos
	EXEC SQL WHENEVER NOT FOUND DO break;
	for (;; iNroObjLocal++) {

		memset(pcFone, 0, 256);
		
		EXEC SQL FETCH linhas INTO
		   :pcFone;

		rtrim(pcFone);

		listalinTel = (char**) realloc((void *)listalinTel, (sizeof(char**) * iNroObjLocal));
		if (listalinTel == NULL) {
			EXEC SQL CLOSE linhas;
			throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
		}
		
		listalinTel[iNroObjLocal-1] = (char*) malloc(strlen(pcFone)+1);
		if (listalinTel[iNroObjLocal-1] == NULL) {
			EXEC SQL CLOSE linhas;
			free(listalinTel);
			throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
		}
			
		memset(listalinTel[iNroObjLocal-1], 0, strlen(pcFone)+1);
		memcpy(listalinTel[iNroObjLocal-1], pcFone, strlen(pcFone));
	}
	
	*iNroObjetos = iNroObjLocal - 1;

	ULOG_END("CConta::listaLinhasIntraGrupo()");

	return listalinTel;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorListaIG:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CConta::listaLinhasIntraGrupo()");
		throw TuxBasicOraException(sqlca.sqlcode);
}
//-----------
void CConta::recuperaIdConta(char *pszCdConta)
{
    ULOG_END("CConta::recuperaIdConta()");
	struct sqlca sqlca;
	char s[256]={NULL}; 
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR pcIdConta[256];
		VARCHAR pcConta[256];
	EXEC SQL END DECLARE SECTION;

// Marca ponto de controle de erro



	STRCPY_TO_ORA(pcConta,pszCdConta);

	EXEC SQL WHENEVER NOT FOUND GOTO sqlNotFound;
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorListaIG;
	EXEC SQL select 
				idConta 
			 into 
				:pcIdConta 
			 from 
				customer.conta 
			 where 
				cdconta = :pcConta;

	memcpy( s, &pcIdConta.arr, pcIdConta.len ); 

	setIdConta(s);
    ULOG_END("CConta::recuperaIdConta()");
	return;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlNotFound:
        ULOG_END("CConta::recuperaIdConta()");
		setIdConta("0");
		return;
	sqlErrorListaIG:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CConta::recuperaIdConta()");
		throw TuxBasicOraException(sqlca.sqlcode);
}
