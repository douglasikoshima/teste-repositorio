#include <string.h>

#undef SQLCA
#define SQLCA_NONE
#include <sqlca.h>
#include <sqlda.h>

#include <tuxfw.h>
#include "../include/Exception.h"
#include "../include/Funcoes.h"

#undef MSG_NONE
#define MSG_NONE
#include "../include/Messages.h"

EXEC SQL BEGIN DECLARE SECTION;
#include "../include/Global.h"
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE "../include/classCstAtributo.h";

// Usuário de alteração
void CCstAtributo::setUsuarioAlteracao(char* value) {
	if (value != NULL) {
		strncpy(sIdUsuarioAlteracao,value, 255);
		sIdUsuarioAlteracao[255]='\0';
	}
}

CCstAtributo::CCstAtributo()
{
    memset(&tAtributo, 0x00, sizeof(tAtributo));

	poValoresLivres = NULL;
	iNrValoresLivres = 0;

	poValoresSelecionados = NULL;
	iNrValoresSelecionados = 0;

	memset(sIdUsuarioAlteracao,0,256);
}

CCstAtributo::~CCstAtributo()
{
	if(poValoresLivres)
		free(poValoresLivres);
}

void CCstAtributo::setIdAtributo(char*pDado)
{
    STRCPY_TO_ORA(tAtributo.sIdAtributo, pDado);
}

void CCstAtributo::setIdSubAssunto(char*pDado)
{
    STRCPY_TO_ORA(tAtributo.sIdSubAssunto, pDado);
}

void CCstAtributo::setDsAtributo(char*pDado)
{
    STRCPY_TO_ORA(tAtributo.sDsAtributo, pDado);
}

void CCstAtributo::setSqApresentacao(char*pDado)
{
    STRCPY_TO_ORA(tAtributo.sSqApresentacao, pDado);
}

void CCstAtributo::setIdTAPergunta(char*pDado)
{
    STRCPY_TO_ORA(tAtributo.sIdTAPergunta, pDado);
}

void CCstAtributo::setInDisponibilidade(char*pDado)
{
    STRCPY_TO_ORA(tAtributo.sInDisponibilidade, pDado);
}

void CCstAtributo::setNrValoresLivres(int value) {
	iNrValoresLivres = value;
}

void CCstAtributo::setValoresLivres(CValorLivre* value) {
	poValoresLivres = value;
}

void CCstAtributo::setNrValoresPossiveis(int value) {
	iNrValoresPossiveis = value;
}

void CCstAtributo::setValoresPossiveis(CCstValorPossivel* value) {
	poValoresPossiveis = value;
}

//Get
char *CCstAtributo::getIdAtributo()
{
    return((char*)tAtributo.sIdAtributo.arr);
}

char *CCstAtributo::getIdSubAssunto()
{
    return((char*)tAtributo.sIdSubAssunto.arr);
}

char *CCstAtributo::getDsAtributo()
{
    return((char*)tAtributo.sDsAtributo.arr);
}

char *CCstAtributo::getSqApresentacao()
{
    return((char*)tAtributo.sSqApresentacao.arr);
}

char *CCstAtributo::getIdTAPergunta()
{
    return((char*)tAtributo.sIdTAPergunta.arr);
}

char *CCstAtributo::getInDisponibilidade()
{
    return((char*)tAtributo.sInDisponibilidade.arr);
}

int CCstAtributo::getNrValoresLivres() {
	return iNrValoresLivres;
}

CValorLivre* CCstAtributo::getValoresLivres() {
	return poValoresLivres;
}

int CCstAtributo::getNrValoresPossiveis() {
	return iNrValoresPossiveis;
}

CCstValorPossivel* CCstAtributo::getValoresPossiveis() {
	return poValoresPossiveis;
}

int CCstAtributo::Incluir()
{
    ULOG_START("CCstAtributo::Incluir()");
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        int iTemRegistro;
	EXEC SQL END DECLARE SECTION;

    ULOG("getValoresPossiveis");
    ULOG("tAtributo.sDsAtributo[%.*s]", LEN_DSATRIBUTO, tAtributo.sDsAtributo.arr);
    ULOG("tAtributo.sIdSubAssunto[%.*s]", LEN_NUMBER, tAtributo.sIdSubAssunto.arr);

    //Verificando se o registro existe
	EXEC SQL SELECT count(1)
               INTO :iTemRegistro
               FROM customer.atributo
              WHERE upper(dsatributo) = upper(:tAtributo.sDsAtributo)
                AND idsubassunto      = :tAtributo.sIdSubAssunto;

    ULOG("sqlca.sqlcode(%d)", sqlca.sqlcode);
    ULOG("iTemRegistro(%d)", iTemRegistro);

    if (iTemRegistro)
        return DUPLICATE_KEY;

    ULOG("Local 3");

    /* Obtendo a sequence */
    EXEC SQL SELECT customer.atributosq.nextval 
               INTO :tAtributo.sIdAtributo:tAtributo.iIdAtributoNull
               FROM dual;

	EXEC SQL WHENEVER SQLERROR	goto erro;

    EXEC SQL 
        INSERT INTO customer.atributo
                    ( 
                        idatributo,
                        idsubassunto,
                        dsatributo,
                        sqapresentacao,
                        idtipoapresentacaopergunta,
                        indisponibilidade,
						idusuarioalteracao,
						dtultimaalteracao
                    )
             VALUES ( 
                        :tAtributo.sIdAtributo:tAtributo.iIdAtributoNull,
                        :tAtributo.sIdSubAssunto:tAtributo.iIdSubAssuntoNull,
                        :tAtributo.sDsAtributo:tAtributo.iDsAtributoNull,
                        :tAtributo.sSqApresentacao:tAtributo.iSqApresentacaoNull,
                        :tAtributo.sIdTAPergunta:tAtributo.iidTAPerguntaNull,
                        :tAtributo.sInDisponibilidade:tAtributo.iInDisponibilidadeNull,
						:sIdUsuarioAlteracao,
						SYSDATE
                    );  

    ULOG("2. sqlca.sqlcode(%d)", sqlca.sqlcode);
    ULOG_END("CCstAtributo::Incluir()");
    if (!sqlca.sqlerrd[2])
        return NOK;
    else
        return OK;

	erro:
    {
        if (sqlca.sqlcode == DUPLICATE_KEY)
        {
           ULOG_END("CCstAtributo::Incluir()");
           return DUPLICATE_KEY;
        }

        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
        ULOG_END("CCstAtributo::Incluir()");
    	throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
    }
}


int CCstAtributo::Alterar()
{
    ULOG_START("CCstAtributo::Alterar()");
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
        int iTemRegistro;
	EXEC SQL END DECLARE SECTION;

    //Verificando se o registro existe
	EXEC SQL SELECT count(1)
               INTO :iTemRegistro
               FROM customer.atributo
              WHERE upper(dsatributo) = upper(:tAtributo.sDsAtributo)
                AND idatributo  != :tAtributo.sIdAtributo
                AND idsubassunto = :tAtributo.sIdSubAssunto;

    if (iTemRegistro)
        return DUPLICATE_KEY;


	EXEC SQL WHENEVER SQLERROR	goto erro;

    EXEC SQL UPDATE customer.atributo
                SET idsubassunto               = :tAtributo.sIdSubAssunto:tAtributo.iIdSubAssuntoNull,
                    dsatributo                 = :tAtributo.sDsAtributo:tAtributo.iDsAtributoNull,
                    sqapresentacao             = :tAtributo.sSqApresentacao:tAtributo.iSqApresentacaoNull,
                    idtipoapresentacaopergunta = :tAtributo.sIdTAPergunta:tAtributo.iidTAPerguntaNull,
                    indisponibilidade          = :tAtributo.sInDisponibilidade:tAtributo.iInDisponibilidadeNull,
					IdUsuarioAlteracao = :sIdUsuarioAlteracao,
					DtUltimaAlteracao = SYSDATE
              WHERE idatributo = :tAtributo.sIdAtributo;
  
    ULOG_END("CCstAtributo::Alterar()");
    if (!sqlca.sqlerrd[2])
        return NOK;
    else
        return OK;

	erro:
    {
        if (sqlca.sqlcode == DUPLICATE_KEY )
        {
            ULOG_END("CCstAtributo::Alterar()");
           return DUPLICATE_KEY;
        }

		ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CCstAtributo::Alterar()");
		throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,
					sqlca.sqlerrm.sqlerrml);
    }
}


int CCstAtributo::Excluir()
{
    ULOG_START("CCstAtributo::Excluir()");
    struct sqlca sqlca;

	EXEC SQL WHENEVER SQLERROR	goto erro;

    EXEC SQL DELETE FROM customer.atributo
              WHERE idatributo = :tAtributo.sIdAtributo;
  
    ULOG_END("CCstAtributo::Excluir()");
    if (!sqlca.sqlerrd[2])
        return NOK;
    else
        return OK;

	erro:
		ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CCstAtributo::Excluir()");
		throw TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc,
					sqlca.sqlerrm.sqlerrml);

}


CCstAtributo* CCstAtributo::RecuperarTodos(int* iNroObjetos)
{
    ULOG_END("CCstAtributo::RecuperarTodos()");
    struct sqlca sqlca;

    CCstAtributo* oObj = NULL;
    int iNroObjLocal = 1;

	EXEC SQL BEGIN DECLARE SECTION;
        TATRIBUTO tST;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	// Declara e abre o cursor
	EXEC SQL DECLARE cCursor CURSOR FOR
            SELECT idatributo,
                   idsubassunto,
                   dsatributo,
                   sqapresentacao,
                   idtipoapresentacaopergunta,
                   indisponibilidade
             FROM customer.atributo;

	EXEC SQL OPEN cCursor;
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;; iNroObjLocal++) 
    {
        memset(&tST, 0x00, sizeof(tST));

		EXEC SQL FETCH cCursor
                  INTO :tST.sIdAtributo:tST.iIdAtributoNull,
                       :tST.sIdSubAssunto:tST.iIdSubAssuntoNull,
                       :tST.sDsAtributo:tST.iDsAtributoNull,
                       :tST.sSqApresentacao:tST.iSqApresentacaoNull,
                       :tST.sIdTAPergunta:tST.iidTAPerguntaNull,
                       :tST.sInDisponibilidade:tST.iInDisponibilidadeNull;

		// Aloca memória para o objeto atual.
		if ((oObj = (CCstAtributo*) realloc((void *)oObj, (sizeof(CCstAtributo) * iNroObjLocal))) != NULL) {

			oObj[iNroObjLocal-1].setIdAtributo((char*)tST.sIdAtributo.arr);
			oObj[iNroObjLocal-1].setIdSubAssunto((char*)tST.sIdSubAssunto.arr);
			oObj[iNroObjLocal-1].setDsAtributo((char*)tST.sDsAtributo.arr);
			oObj[iNroObjLocal-1].setSqApresentacao((char*)tST.sSqApresentacao.arr);
			oObj[iNroObjLocal-1].setIdTAPergunta((char*)tST.sIdTAPergunta.arr);
			oObj[iNroObjLocal-1].setInDisponibilidade((char*)tST.sInDisponibilidade.arr);
		} 
        else 
        {
			if (oObj) 
                free(oObj);

            
            ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
			throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
            EXEC SQL CLOSE cCursor;
		}
	}

    EXEC SQL CLOSE cCursor;

	*iNroObjetos = iNroObjLocal - 1;
	ULOG_END("CCstAtributo::RecuperarTodos()");
	return oObj;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
		ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CCstAtributo::RecuperarTodos()");
		throw new TuxBasicOraException(sqlca.sqlcode);
}


CCstAtributo* CCstAtributo::RecuperarPorIdSubAss(int* iNroObjetos, char* pId)
{
    ULOG_END("CCstAtributo::RecuperarPorIdSubAss()");
    struct sqlca sqlca;

    CCstAtributo* oObj = NULL;
    int iNroObjLocal = 1;

	EXEC SQL BEGIN DECLARE SECTION;
        TATRIBUTO tST;
        VARCHAR sId[LEN_NUMBER + LEN_EOS];
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

    STRCPY_TO_ORA(sId, pId);

	// Declara e abre o cursor
	EXEC SQL DECLARE cCursor2 CURSOR FOR
            SELECT idatributo,
                   dsatributo
             FROM customer.atributo
            WHERE idsubassunto = :sId ;

	EXEC SQL OPEN cCursor2;
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;; iNroObjLocal++) 
    {
        memset(&tST, 0x00, sizeof(tST));

		EXEC SQL FETCH cCursor2
                  INTO :tST.sIdAtributo:tST.iIdAtributoNull,
                       :tST.sDsAtributo:tST.iDsAtributoNull;

		// Aloca memória para o objeto atual.
		if ((oObj = (CCstAtributo*) realloc((void *)oObj, (sizeof(CCstAtributo) * iNroObjLocal))) != NULL) {

			oObj[iNroObjLocal-1].setIdAtributo((char*)tST.sIdAtributo.arr);
			oObj[iNroObjLocal-1].setDsAtributo((char*)tST.sDsAtributo.arr);
		} 
        else 
        {
			if (oObj) 
                free(oObj);

            ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
            ULOG_END("CCstAtributo::RecuperarPorIdSubAss()");
			throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
            EXEC SQL CLOSE cCursor2;
		}
	}

    EXEC SQL CLOSE cCursor2;

	*iNroObjetos = iNroObjLocal - 1;
	ULOG_END("CCstAtributo::RecuperarPorIdSubAss()");
	return oObj;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
		ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CCstAtributo::RecuperarPorIdSubAss()");
		throw new TuxBasicOraException(sqlca.sqlcode);
}

CCstAtributo* CCstAtributo::RecuperarPorIdSubAssETipoApresentacao(int* iNroObjetos, char* pId, char *pTp)
{
    ULOG_START("CCstAtributo::RecuperarPorIdSubAssETipoApresentacao()");
    struct sqlca sqlca;
    
    CCstAtributo* oObj = NULL;
    int iNroObjLocal = 1;
    char *pTok;

	EXEC SQL BEGIN DECLARE SECTION;
        TATRIBUTO tST;
        VARCHAR sId[LEN_NUMBER + LEN_EOS];
		int iP1;
		int iP2;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

    STRCPY_TO_ORA(sId,   pId);

    if (pTp){
        pTok = strtok(pTp, ",");
	    iP1 = atoi(pTok);
        pTok = strtok(NULL, pTp);
	    iP2 = atoi(pTok);
    }
    else
        iP1 = -1;

	// Declara e abre o cursor
	EXEC SQL DECLARE cCursorTP CURSOR FOR
            SELECT idatributo,
                   dsatributo
             FROM customer.atributo
            WHERE idsubassunto = :sId
              AND idtipoapresentacaopergunta NOT IN (:iP1, :iP2) OR :iP1 = -1
            ORDER BY upper(dsatributo);

	EXEC SQL OPEN cCursorTP;
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;; iNroObjLocal++) 
    {
        memset(&tST, 0x00, sizeof(tST));

		EXEC SQL FETCH cCursorTP
                  INTO :tST.sIdAtributo:tST.iIdAtributoNull,
                       :tST.sDsAtributo:tST.iDsAtributoNull;

		// Aloca memória para o objeto atual.
		if ((oObj = (CCstAtributo*) realloc((void *)oObj, (sizeof(CCstAtributo) * iNroObjLocal))) != NULL) {

			oObj[iNroObjLocal-1].setIdAtributo((char*)tST.sIdAtributo.arr);
			oObj[iNroObjLocal-1].setDsAtributo((char*)tST.sDsAtributo.arr);
		} 
        else 
        {
			if (oObj) 
                free(oObj);

            ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
			throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
			ULOG_END("CCstAtributo::RecuperarPorIdSubAssETipoApresentacao()");
            EXEC SQL CLOSE cCursorTP;
		}
	}

    EXEC SQL CLOSE cCursorTP;

	*iNroObjetos = iNroObjLocal - 1;
	ULOG_END("CCstAtributo::RecuperarPorIdSubAssETipoApresentacao()");
	return oObj;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
		ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CCstAtributo::RecuperarPorIdSubAssETipoApresentacao()");
		throw new TuxBasicOraException(sqlca.sqlcode);
}



CCstAtributo* CCstAtributo::RecuperarPorIdSubAssEPessoa(int* iNroObjetos, int iIdSub, int iIdPessoa)
{
    ULOG_START("CCstAtributo::RecuperarPorIdSubAssEPessoa()");
	struct sqlca sqlca;

	CCstAtributo* poListaAtributos = NULL;
	int iNroObjLocal = 0;
	int iIdAtributoControle = -1;
	int iValoresNoAtributo = 0;
	int iValoresPNoAtributo = 0;

	EXEC SQL BEGIN DECLARE SECTION;
        TATRIBUTO tST;
        int iOraIdSub;
		int iOraIdPessoa;
		int iIdValorLivre;
		char cDsValorLivre[256];
		char cIdValorPossivel[256];
		char cDsValorPossivel[256];
		int iIdPessoaValorPossivel;

		// Variáveis indicativas do oracle
		short iiIdValorLivre;
		short icDsValorLivre;
		short icIdValorPossivel;
		short icDsValorPossivel;
		short iiIdPessoaValorPossivel;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	iOraIdSub = iIdSub;
	iOraIdPessoa = iIdPessoa;

	// Primeira parte, com valores livres: Declara e abre o cursor
	EXEC SQL DECLARE cCursor3 CURSOR FOR
		SELECT 
		 idAtributo,
		 dsAtributo,
		 idTipoApresentacaoPergunta,
		 sqApresentacao,
		 idValorLivre,
		 dsValor
		FROM 
		 customer.AttVlLivreOuterV01 
		WHERE
		 (idPessoa is null OR idPessoa = :iOraIdPessoa) AND
		 idSubAssunto = :iOraIdSub
		ORDER BY SqApresentacao;

	EXEC SQL OPEN cCursor3;
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;;) 
    {
        memset(&tST, 0x00, sizeof(tST));

		EXEC SQL FETCH cCursor3
                  INTO :tST.sIdAtributo:tST.iIdAtributoNull,
                       :tST.sDsAtributo:tST.iDsAtributoNull,
					   :tST.sIdTAPergunta:tST.iidTAPerguntaNull,
					   :tST.sSqApresentacao:tST.iSqApresentacaoNull,
					   :iIdValorLivre:iiIdValorLivre,
					   :cDsValorLivre:icDsValorLivre;


		// Checa se ainda é o mesma assunto
		ZERA_TO_ORA(tST.sIdAtributo);
		if (atoi((char*)tST.sIdAtributo.arr) == iIdAtributoControle) {
			CValorLivre* poVLivre = NULL;

			iValoresNoAtributo++;

			poVLivre = poListaAtributos[iNroObjLocal-1].getValoresLivres();
			if ((poVLivre = (CValorLivre*) realloc((void *)poVLivre, (sizeof(CValorLivre) * iValoresNoAtributo))) != NULL) {
				rtrim(cDsValorLivre);
				poVLivre[iValoresNoAtributo-1].setIdValorLivre(iIdValorLivre);
				poVLivre[iValoresNoAtributo-1].setDsValor(cDsValorLivre);

				poListaAtributos[iNroObjLocal-1].setValoresLivres(poVLivre);
				poListaAtributos[iNroObjLocal-1].setNrValoresLivres(iValoresNoAtributo);
			} 
			else 
			{
				ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
				ULOG_END("CCstAtributo::RecuperarPorIdSubAssEPessoa()");
				throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
			}
		} else {
			// Aloca memória para o objeto atual.
			iNroObjLocal++;
			if ((poListaAtributos = (CCstAtributo*) realloc((void *)poListaAtributos, (sizeof(CCstAtributo) * iNroObjLocal))) != NULL) {
				
				ZERA_TO_ORA(tST.sIdAtributo);
				ZERA_TO_ORA(tST.sDsAtributo);
				ZERA_TO_ORA(tST.sIdTAPergunta);

				iIdAtributoControle = atoi((char*)tST.sIdAtributo.arr);

				poListaAtributos[iNroObjLocal-1].setIdAtributo((char*)tST.sIdAtributo.arr);
				poListaAtributos[iNroObjLocal-1].setDsAtributo((char*)tST.sDsAtributo.arr);
				poListaAtributos[iNroObjLocal-1].setIdTAPergunta((char*)tST.sIdTAPergunta.arr);
				poListaAtributos[iNroObjLocal-1].setSqApresentacao((char*)tST.sSqApresentacao.arr);

				if(iiIdValorLivre >= 0) {
					// Monta novo objeto de lista de subassuntos.
					CValorLivre* poVLivre;
					poVLivre = (CValorLivre*) malloc(sizeof(CValorLivre));
					poVLivre->setIdValorLivre(iIdValorLivre);
					poVLivre->setDsValor(rtrim(cDsValorLivre));
					iValoresNoAtributo = 1;
					poListaAtributos[iNroObjLocal-1].setValoresLivres(poVLivre);
					poListaAtributos[iNroObjLocal-1].setNrValoresLivres(iValoresNoAtributo);
				} else
					poListaAtributos[iNroObjLocal-1].setNrValoresLivres(0);
				poListaAtributos[iNroObjLocal-1].setNrValoresPossiveis(0);
			}
			else 
			{
				if (poListaAtributos)
					free(poListaAtributos);
				ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
				ULOG_END("CCstAtributo::RecuperarPorIdSubAssEPessoa()");
				throw new TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
			}
		}
	}

	// Segunda parte, com valores possíveis. Declara e abre o cursor
	EXEC SQL DECLARE cCursor4 CURSOR FOR
		SELECT 
		 idAtributo,
		 dsAtributo,
		 idTipoApresentacaoPergunta,
		 sqApresentacao,
		 idValorPossivel,
		 dsValorPossivel,
		 idPessoaValorPossivel
		FROM 
		 customer.AttVlPossivelOuterV01 
		WHERE
		 (idPessoa is null OR idPessoa = :iOraIdPessoa) 
        AND
		 idSubAssunto = :iOraIdSub;

	EXEC SQL OPEN cCursor4;
	EXEC SQL WHENEVER NOT FOUND DO break;

	iIdAtributoControle = -1;

	for (;;) 
    {
        memset(&tST, 0x00, sizeof(tST));

		EXEC SQL FETCH cCursor4
                  INTO :tST.sIdAtributo:tST.iIdAtributoNull,
                       :tST.sDsAtributo:tST.iDsAtributoNull,
					   :tST.sIdTAPergunta:tST.iidTAPerguntaNull,
					   :tST.sSqApresentacao:tST.iSqApresentacaoNull,
					   :cIdValorPossivel:icIdValorPossivel,
					   :cDsValorPossivel:icDsValorPossivel,
					   :iIdPessoaValorPossivel:iiIdPessoaValorPossivel;

		// Checa se ainda é o mesma assunto
		ZERA_TO_ORA(tST.sIdAtributo);
		if (atoi((char*)tST.sIdAtributo.arr) == iIdAtributoControle) {
			CCstValorPossivel* poVPoss = NULL;

			iValoresPNoAtributo++;

			poVPoss = poListaAtributos[iNroObjLocal-1].getValoresPossiveis();
			if ((poVPoss = (CCstValorPossivel*) realloc((void *)poVPoss, (sizeof(CCstValorPossivel) * iValoresPNoAtributo))) != NULL) {
				rtrim(cIdValorPossivel);
				rtrim(cDsValorPossivel);
				poVPoss[iValoresPNoAtributo-1].setIdValorPossivel(cIdValorPossivel);
				poVPoss[iValoresPNoAtributo-1].setDsValorPossivel(cDsValorPossivel);

				poListaAtributos[iNroObjLocal-1].setValoresPossiveis(poVPoss);
				poListaAtributos[iNroObjLocal-1].setNrValoresPossiveis(iValoresPNoAtributo);

				// Checa se é selecionado ou não.
				if (iiIdPessoaValorPossivel >= 0)
					poVPoss[iValoresPNoAtributo-1].setInSelecionado(1);
				else
					poVPoss[iValoresPNoAtributo-1].setInSelecionado(0);

			} else {
				ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
				ULOG_END("CCstAtributo::RecuperarPorIdSubAssEPessoa()");
				throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
			}
		} else {
			// Aloca memória para o objeto atual.
			iNroObjLocal++;
			if ((poListaAtributos = (CCstAtributo*) realloc((void *)poListaAtributos, (sizeof(CCstAtributo) * iNroObjLocal))) != NULL) {
				
				ZERA_TO_ORA(tST.sIdAtributo);
				ZERA_TO_ORA(tST.sDsAtributo);
				ZERA_TO_ORA(tST.sIdTAPergunta);

				iIdAtributoControle = atoi((char*)tST.sIdAtributo.arr);

				poListaAtributos[iNroObjLocal-1].setIdAtributo((char*)tST.sIdAtributo.arr);
				poListaAtributos[iNroObjLocal-1].setDsAtributo((char*)tST.sDsAtributo.arr);
				poListaAtributos[iNroObjLocal-1].setIdTAPergunta((char*)tST.sIdTAPergunta.arr);
				poListaAtributos[iNroObjLocal-1].setSqApresentacao((char*)tST.sSqApresentacao.arr);

				if(icIdValorPossivel >= 0) {
					// Monta novo objeto de lista de subassuntos.
					CCstValorPossivel* poVPoss;
					poVPoss = (CCstValorPossivel*) malloc(sizeof(CCstValorPossivel));
					poVPoss->setIdValorPossivel(rtrim(cIdValorPossivel));
					poVPoss->setDsValorPossivel(rtrim(cDsValorPossivel));
					iValoresPNoAtributo = 1;
					poListaAtributos[iNroObjLocal-1].setValoresPossiveis(poVPoss);
					poListaAtributos[iNroObjLocal-1].setNrValoresPossiveis(iValoresPNoAtributo);

					// Checa se é selecionado
					if (iiIdPessoaValorPossivel >= 0)
						poVPoss->setInSelecionado(1);
					else
						poVPoss->setInSelecionado(0);

				} else {
					poListaAtributos[iNroObjLocal-1].setNrValoresPossiveis(0);
				}
				poListaAtributos[iNroObjLocal-1].setNrValoresLivres(0);
			} else {
				if (poListaAtributos)
					free(poListaAtributos);
				ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
				ULOG_END("CCstAtributo::RecuperarPorIdSubAssEPessoa()");
				throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
			}
		}
	}

	*iNroObjetos = iNroObjLocal;
	ULOG_END("CCstAtributo::RecuperarPorIdSubAssEPessoa()");
	return poListaAtributos;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CCstAtributo::RecuperarPorIdSubAssEPessoa()");
		throw TuxBasicOraException(sqlca.sqlcode);
}


CCstAtributo* CCstAtributo::RecuperarPorIdSubAssIdPessoaIdGrupo(int* iNroObjetos, int iIdSub, int iIdPessoa, int iIdGrupo)
{
	ULOG_START("CCstAtributo::RecuperarPorIdSubAssIdPessoaIdGrupo()");
	struct sqlca sqlca;

	CCstAtributo* poListaAtributos = NULL;
	int iNroObjLocal = 0;
	int iIdAtributoControle = -1;
	int iValoresNoAtributo = 0;
	int iValoresPNoAtributo = 0;

	EXEC SQL BEGIN DECLARE SECTION;
        TATRIBUTO tST;
        int iOraIdSub;
		int iOraIdPessoa;
		int iIdValorLivre;
		char cDsValorLivre[256];
		char cIdValorPossivel[256];
		char cDsValorPossivel[256];
		int iIdPessoaValorPossivel;

        int iOraIdGrupo = iIdGrupo;

		// Variáveis indicativas do oracle
		short iiIdValorLivre;
		short icDsValorLivre;
		short icIdValorPossivel;
		short icDsValorPossivel;
		short iiIdPessoaValorPossivel;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	iOraIdSub = iIdSub;
	iOraIdPessoa = iIdPessoa;

	// Primeira parte, com valores livres: Declara e abre o cursor
	EXEC SQL DECLARE cCursorVlLivrePorGrupo CURSOR FOR
		SELECT DISTINCT
		 idAtributo,
		 dsAtributo,
		 idTipoApresentacaoPergunta,
		 sqApresentacao,
		 idValorLivre,
		 dsValor
		FROM 
		 customer.AttVlLivreOuterPorGrupoV01 
		WHERE
		 (idPessoa is null OR idPessoa = :iOraIdPessoa) 
        AND
		 idSubAssunto = :iOraIdSub
        AND
         (idgrupo = :iOraIdGrupo OR '-1' = :iOraIdGrupo)
		ORDER BY SqApresentacao;

	EXEC SQL OPEN cCursorVlLivrePorGrupo;
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;;) 
    {
        memset(&tST, 0x00, sizeof(tST));

		EXEC SQL FETCH cCursorVlLivrePorGrupo
                  INTO :tST.sIdAtributo:tST.iIdAtributoNull,
                       :tST.sDsAtributo:tST.iDsAtributoNull,
					   :tST.sIdTAPergunta:tST.iidTAPerguntaNull,
					   :tST.sSqApresentacao:tST.iSqApresentacaoNull,
					   :iIdValorLivre:iiIdValorLivre,
					   :cDsValorLivre:icDsValorLivre;


		// Checa se ainda é o mesma assunto
		ZERA_TO_ORA(tST.sIdAtributo);
		if (atoi((char*)tST.sIdAtributo.arr) == iIdAtributoControle) {
			CValorLivre* poVLivre = NULL;

			iValoresNoAtributo++;

			poVLivre = poListaAtributos[iNroObjLocal-1].getValoresLivres();
			if ((poVLivre = (CValorLivre*) realloc((void *)poVLivre, (sizeof(CValorLivre) * iValoresNoAtributo))) != NULL) {
				rtrim(cDsValorLivre);
				poVLivre[iValoresNoAtributo-1].setIdValorLivre(iIdValorLivre);
				poVLivre[iValoresNoAtributo-1].setDsValor(cDsValorLivre);

				poListaAtributos[iNroObjLocal-1].setValoresLivres(poVLivre);
				poListaAtributos[iNroObjLocal-1].setNrValoresLivres(iValoresNoAtributo);
			} else {
                if (poVLivre)
                    free(poVLivre);

                EXEC SQL CLOSE cCursorVlLivrePorGrupo;
				ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
				ULOG_END("CCstAtributo::RecuperarPorIdSubAssIdPessoaIdGrupo()");
				throw new TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
			}
		} 
		else
		{
			// Aloca memória para o objeto atual.
			iNroObjLocal++;
			if ((poListaAtributos = (CCstAtributo*) realloc((void *)poListaAtributos, (sizeof(CCstAtributo) * iNroObjLocal))) != NULL) {
				
				ZERA_TO_ORA(tST.sIdAtributo);
				ZERA_TO_ORA(tST.sDsAtributo);
				ZERA_TO_ORA(tST.sIdTAPergunta);

				iIdAtributoControle = atoi((char*)tST.sIdAtributo.arr);

				poListaAtributos[iNroObjLocal-1].setIdAtributo((char*)tST.sIdAtributo.arr);
				poListaAtributos[iNroObjLocal-1].setDsAtributo((char*)tST.sDsAtributo.arr);
				poListaAtributos[iNroObjLocal-1].setIdTAPergunta((char*)tST.sIdTAPergunta.arr);
				poListaAtributos[iNroObjLocal-1].setSqApresentacao((char*)tST.sSqApresentacao.arr);

				if(iiIdValorLivre >= 0) {
					// Monta novo objeto de lista de subassuntos.
					CValorLivre* poVLivre;
					poVLivre = (CValorLivre*) malloc(sizeof(CValorLivre));
					poVLivre->setIdValorLivre(iIdValorLivre);
					poVLivre->setDsValor(rtrim(cDsValorLivre));
					iValoresNoAtributo = 1;
					poListaAtributos[iNroObjLocal-1].setValoresLivres(poVLivre);
					poListaAtributos[iNroObjLocal-1].setNrValoresLivres(iValoresNoAtributo);
				} else
					poListaAtributos[iNroObjLocal-1].setNrValoresLivres(0);
				poListaAtributos[iNroObjLocal-1].setNrValoresPossiveis(0);
			} 
			else 
			{
				if (poListaAtributos)
					free(poListaAtributos);

                EXEC SQL CLOSE cCursorVlLivrePorGrupo;
				ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
				ULOG_END("CCstAtributo::RecuperarPorIdSubAssIdPessoaIdGrupo()");
				throw new TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
			}
		}
	}


	// Segunda parte, com valores possíveis. Declara e abre o cursor
	EXEC SQL DECLARE cCursorVlPossivelPorGrupo CURSOR FOR
            SELECT valorespossiveis.idAtributo
                 , valorespossiveis.dsAtributo
                 , valorespossiveis.idTipoApresentacaoPergunta
                 , valorespossiveis.sqApresentacao
                 , valorespossiveis.idValorPossivel
                 , valorespossiveis.dsValorPossivel
                 , valorselecionado.idpessoavalorpossivel
              FROM (  SELECT DISTINCT atributo.idAtributo
                           , atributo.dsAtributo
                           , atributo.idTipoApresentacaoPergunta
                           , atributo.sqApresentacao AS attSqApresentacao
                           , valorpossivel.sqApresentacao
                           , valorpossivel.idValorPossivel
                           , valorpossivel.dsValorPossivel
                        FROM customer.subassunto subassunto
                           , customer.atributo atributo
                           , customer.valorpossivel valorpossivel
                           , customer.atributocanal atributocanal
                       WHERE subassunto.idsubassunto = atributo.idsubassunto
                         AND atributo.idatributo = valorpossivel.idatributo
                         AND atributo.idatributo = atributocanal.idatributo
                         AND atributo.Indisponibilidade = 1
                         AND valorpossivel.Indisponibilidade = 1
                         AND subassunto.idsubassunto = :iOraIdSub
                         AND atributocanal.idcanal IN ( SELECT idcanal 
                                                          FROM acesso.grupocanal 
                                                         WHERE idgrupo = :iOraIdGrupo OR '-1' = :iOraIdGrupo )) valorespossiveis
                  , ( SELECT idvalorpossivel
                           , idpessoa idpessoavalorpossivel
                        FROM customer.pessoavalorpossivel pessoavalorpossivel
                       WHERE pessoavalorpossivel.idpessoa = :iOraIdPessoa ) valorselecionado
             WHERE valorespossiveis.idvalorpossivel = valorselecionado.idvalorpossivel (+)
             ORDER BY valorespossiveis.attSqApresentacao
                    , valorespossiveis.dsAtributo
                    , valorespossiveis.sqapresentacao;

	EXEC SQL OPEN cCursorVlPossivelPorGrupo;
	
	EXEC SQL WHENEVER NOT FOUND DO break;

	iIdAtributoControle = -1;

	for (;;) 
    {
        memset(&tST, 0x00, sizeof(tST));

		EXEC SQL FETCH cCursorVlPossivelPorGrupo
                  INTO :tST.sIdAtributo:tST.iIdAtributoNull,
                       :tST.sDsAtributo:tST.iDsAtributoNull,
					   :tST.sIdTAPergunta:tST.iidTAPerguntaNull,
					   :tST.sSqApresentacao:tST.iSqApresentacaoNull,
					   :cIdValorPossivel:icIdValorPossivel,
					   :cDsValorPossivel:icDsValorPossivel,
					   :iIdPessoaValorPossivel:iiIdPessoaValorPossivel;

		// Checa se ainda é o mesma assunto
		ZERA_TO_ORA(tST.sIdAtributo);
		if (atoi((char*)tST.sIdAtributo.arr) == iIdAtributoControle) {
			CCstValorPossivel* poVPoss = NULL;

			iValoresPNoAtributo++;

			poVPoss = poListaAtributos[iNroObjLocal-1].getValoresPossiveis();
			if ((poVPoss = (CCstValorPossivel*) realloc((void *)poVPoss, (sizeof(CCstValorPossivel) * iValoresPNoAtributo))) != NULL) {
				rtrim(cIdValorPossivel);
				rtrim(cDsValorPossivel);
				poVPoss[iValoresPNoAtributo-1].setIdValorPossivel(cIdValorPossivel);
				poVPoss[iValoresPNoAtributo-1].setDsValorPossivel(cDsValorPossivel);

				poListaAtributos[iNroObjLocal-1].setValoresPossiveis(poVPoss);
				poListaAtributos[iNroObjLocal-1].setNrValoresPossiveis(iValoresPNoAtributo);

				// Checa se é selecionado ou não.
				if (iiIdPessoaValorPossivel >= 0)
					poVPoss[iValoresPNoAtributo-1].setInSelecionado(1);
				else
					poVPoss[iValoresPNoAtributo-1].setInSelecionado(0);

			} else {
				ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
                if (poVPoss)
                    free(poVPoss);

                EXEC SQL CLOSE cCursorVlPossivelPorGrupo;
                ULOG_END("CCstAtributo::RecuperarPorIdSubAssIdPessoaIdGrupo()");
				throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
			}
		} else {
			// Aloca memória para o objeto atual.
			iNroObjLocal++;
			if ((poListaAtributos = (CCstAtributo*) realloc((void *)poListaAtributos, (sizeof(CCstAtributo) * iNroObjLocal))) != NULL) {
				
				ZERA_TO_ORA(tST.sIdAtributo);
				ZERA_TO_ORA(tST.sDsAtributo);
				ZERA_TO_ORA(tST.sIdTAPergunta);

				iIdAtributoControle = atoi((char*)tST.sIdAtributo.arr);

				poListaAtributos[iNroObjLocal-1].setIdAtributo((char*)tST.sIdAtributo.arr);
				poListaAtributos[iNroObjLocal-1].setDsAtributo((char*)tST.sDsAtributo.arr);
				poListaAtributos[iNroObjLocal-1].setIdTAPergunta((char*)tST.sIdTAPergunta.arr);
				poListaAtributos[iNroObjLocal-1].setSqApresentacao((char*)tST.sSqApresentacao.arr);

				if(icIdValorPossivel >= 0) {
					// Monta novo objeto de lista de subassuntos.
					CCstValorPossivel* poVPoss;
					poVPoss = (CCstValorPossivel*) malloc(sizeof(CCstValorPossivel));
					poVPoss->setIdValorPossivel(rtrim(cIdValorPossivel));
					poVPoss->setDsValorPossivel(rtrim(cDsValorPossivel));
					iValoresPNoAtributo = 1;
					poListaAtributos[iNroObjLocal-1].setValoresPossiveis(poVPoss);
					poListaAtributos[iNroObjLocal-1].setNrValoresPossiveis(iValoresPNoAtributo);

					// Checa se é selecionado
					if (iiIdPessoaValorPossivel >= 0)
						poVPoss->setInSelecionado(1);
					else
						poVPoss->setInSelecionado(0);

				} else {
					poListaAtributos[iNroObjLocal-1].setNrValoresPossiveis(0);
				}
				poListaAtributos[iNroObjLocal-1].setNrValoresLivres(0);
			} else {
				if (poListaAtributos)
					free(poListaAtributos);

                EXEC SQL CLOSE cCursorVlPossivelPorGrupo;
				ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
				ULOG_END("CCstAtributo::RecuperarPorIdSubAssIdPessoaIdGrupo()");
				throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
			}
		}
	}

    EXEC SQL CLOSE cCursorVlLivrePorGrupo;
    EXEC SQL CLOSE cCursorVlPossivelPorGrupo;

	*iNroObjetos = iNroObjLocal;
	ULOG_END("CCstAtributo::RecuperarPorIdSubAssIdPessoaIdGrupo()");
	return poListaAtributos;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
		ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CCstAtributo::RecuperarPorIdSubAssIdPessoaIdGrupo()");
		throw TuxBasicOraException(sqlca.sqlcode);
}


CCstAtributo* CCstAtributo::RecuperarPorIdSubAssIdPessoaIdCanal(int* iNroObjetos, int iIdSub, int iIdPessoa, int iIdCanal)
{
    ULOG_START("CCstAtributo::RecuperarPorIdSubAssIdPessoaIdCanal()");
    
	struct sqlca sqlca;

	CCstAtributo* poListaAtributos = NULL;
	int iNroObjLocal = 0;
	int iIdAtributoControle = -1;
	int iValoresNoAtributo = 0;
	int iValoresPNoAtributo = 0;

	EXEC SQL BEGIN DECLARE SECTION;
        TATRIBUTO tST;
        int iOraIdSub;
		int iOraIdPessoa;
		int iIdValorLivre;
		char cDsValorLivre[256];
		char cIdValorPossivel[256];
		char cDsValorPossivel[256];
		int iIdPessoaValorPossivel;

        int iOraIdCanal = iIdCanal;

		// Variáveis indicativas do oracle
		short iiIdValorLivre;
		short icDsValorLivre;
		short icIdValorPossivel;
		short icDsValorPossivel;
		short iiIdPessoaValorPossivel;
	EXEC SQL END DECLARE SECTION;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	iOraIdSub = iIdSub;
	iOraIdPessoa = iIdPessoa;

	// Primeira parte, com valores livres: Declara e abre o cursor
	EXEC SQL DECLARE cCursorVlLivrePorCanal CURSOR FOR
		SELECT DISTINCT
		 idAtributo,
		 dsAtributo,
		 idTipoApresentacaoPergunta,
		 sqApresentacao,
		 idValorLivre,
		 dsValor
		FROM 
		 customer.AttVlLivreOuterPorCanalV01 
		WHERE
		 (idPessoa is null OR idPessoa = :iOraIdPessoa) 
        AND
		 idSubAssunto = :iOraIdSub
        AND
         (idcanal = :iOraIdCanal OR '-1' = :iOraIdCanal)
		ORDER BY SqApresentacao;

	EXEC SQL OPEN cCursorVlLivrePorCanal;
	EXEC SQL WHENEVER NOT FOUND DO break;

	for (;;) 
    {
        memset(&tST, 0x00, sizeof(tST));

		EXEC SQL FETCH cCursorVlLivrePorCanal
                  INTO :tST.sIdAtributo:tST.iIdAtributoNull,
                       :tST.sDsAtributo:tST.iDsAtributoNull,
					   :tST.sIdTAPergunta:tST.iidTAPerguntaNull,
					   :tST.sSqApresentacao:tST.iSqApresentacaoNull,
					   :iIdValorLivre:iiIdValorLivre,
					   :cDsValorLivre:icDsValorLivre;


		// Checa se ainda é o mesma assunto
		ZERA_TO_ORA(tST.sIdAtributo);
		if (atoi((char*)tST.sIdAtributo.arr) == iIdAtributoControle) 
		{
			CValorLivre* poVLivre = NULL;

			iValoresNoAtributo++;

			poVLivre = poListaAtributos[iNroObjLocal-1].getValoresLivres();
			if ((poVLivre = (CValorLivre*) realloc((void *)poVLivre, (sizeof(CValorLivre) * iValoresNoAtributo))) != NULL) {
				rtrim(cDsValorLivre);
				poVLivre[iValoresNoAtributo-1].setIdValorLivre(iIdValorLivre);
				poVLivre[iValoresNoAtributo-1].setDsValor(cDsValorLivre);

				poListaAtributos[iNroObjLocal-1].setValoresLivres(poVLivre);
				poListaAtributos[iNroObjLocal-1].setNrValoresLivres(iValoresNoAtributo);
			} else {
                if (poVLivre)
                    free(poVLivre);

                EXEC SQL CLOSE cCursorVlLivrePorCanal;
				ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
				ULOG_END("CCstAtributo::RecuperarPorIdSubAssIdPessoaIdCanal()");
				throw new TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
			}
		}
		else 
		{
			// Aloca memória para o objeto atual.
			iNroObjLocal++;
			if ((poListaAtributos = (CCstAtributo*) realloc((void *)poListaAtributos, (sizeof(CCstAtributo) * iNroObjLocal))) != NULL) {
				
				ZERA_TO_ORA(tST.sIdAtributo);
				ZERA_TO_ORA(tST.sDsAtributo);
				ZERA_TO_ORA(tST.sIdTAPergunta);

				iIdAtributoControle = atoi((char*)tST.sIdAtributo.arr);

				poListaAtributos[iNroObjLocal-1].setIdAtributo((char*)tST.sIdAtributo.arr);
				poListaAtributos[iNroObjLocal-1].setDsAtributo((char*)tST.sDsAtributo.arr);
				poListaAtributos[iNroObjLocal-1].setIdTAPergunta((char*)tST.sIdTAPergunta.arr);
				poListaAtributos[iNroObjLocal-1].setSqApresentacao((char*)tST.sSqApresentacao.arr);

				if(iiIdValorLivre >= 0) {
					// Monta novo objeto de lista de subassuntos.
					CValorLivre* poVLivre;
					poVLivre = (CValorLivre*) malloc(sizeof(CValorLivre));
					poVLivre->setIdValorLivre(iIdValorLivre);
					poVLivre->setDsValor(rtrim(cDsValorLivre));
					iValoresNoAtributo = 1;
					poListaAtributos[iNroObjLocal-1].setValoresLivres(poVLivre);
					poListaAtributos[iNroObjLocal-1].setNrValoresLivres(iValoresNoAtributo);
				} else
					poListaAtributos[iNroObjLocal-1].setNrValoresLivres(0);
				poListaAtributos[iNroObjLocal-1].setNrValoresPossiveis(0);
			} else {
				if (poListaAtributos)
					free(poListaAtributos);

                EXEC SQL CLOSE cCursorVlLivrePorCanal;
				ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
				ULOG_END("CCstAtributo::RecuperarPorIdSubAssIdPessoaIdCanal()");
				throw new TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
			}
		}
	}


	// Segunda parte, com valores possíveis. Declara e abre o cursor
	EXEC SQL DECLARE cCursorVlPossivelPorCanal CURSOR FOR
            SELECT valorespossiveis.idAtributo
                 , valorespossiveis.dsAtributo
                 , valorespossiveis.idTipoApresentacaoPergunta
                 , valorespossiveis.sqApresentacao
                 , valorespossiveis.idValorPossivel
                 , valorespossiveis.dsValorPossivel
                 , valorselecionado.idpessoavalorpossivel
              FROM (  SELECT atributo.idAtributo
                           , atributo.dsAtributo
                           , atributo.idTipoApresentacaoPergunta
                           , atributo.sqApresentacao AS attSqApresentacao
                           , valorpossivel.sqApresentacao
                           , valorpossivel.idValorPossivel
                           , valorpossivel.dsValorPossivel
                        FROM customer.subassunto subassunto
                           , customer.atributo atributo
                           , customer.valorpossivel valorpossivel
                           , customer.atributocanal atributocanal
                       WHERE subassunto.idsubassunto = atributo.idsubassunto
                         AND atributo.idatributo = valorpossivel.idatributo
                         AND atributo.idatributo = atributocanal.idatributo
                         AND atributo.Indisponibilidade = 1
                         AND valorpossivel.Indisponibilidade = 1
                         AND subassunto.idsubassunto = :iOraIdSub
                         AND atributocanal.idcanal = :iOraIdCanal OR '-1' = :iOraIdCanal ) valorespossiveis
                  , ( SELECT idvalorpossivel
                           , idpessoa idpessoavalorpossivel
                        FROM customer.pessoavalorpossivel pessoavalorpossivel
                       WHERE pessoavalorpossivel.idpessoa = :iOraIdPessoa ) valorselecionado
             WHERE valorespossiveis.idvalorpossivel = valorselecionado.idvalorpossivel (+)
             ORDER BY valorespossiveis.attSqApresentacao
                    , valorespossiveis.dsAtributo
                    , valorespossiveis.sqapresentacao;

	EXEC SQL OPEN cCursorVlPossivelPorCanal;
	EXEC SQL WHENEVER NOT FOUND DO break;

	iIdAtributoControle = -1;

	for (;;) 
    {
        memset(&tST, 0x00, sizeof(tST));

		EXEC SQL FETCH cCursorVlPossivelPorCanal
                  INTO :tST.sIdAtributo:tST.iIdAtributoNull,
                       :tST.sDsAtributo:tST.iDsAtributoNull,
					   :tST.sIdTAPergunta:tST.iidTAPerguntaNull,
					   :tST.sSqApresentacao:tST.iSqApresentacaoNull,
					   :cIdValorPossivel:icIdValorPossivel,
					   :cDsValorPossivel:icDsValorPossivel,
					   :iIdPessoaValorPossivel:iiIdPessoaValorPossivel;

		// Checa se ainda é o mesma assunto
		ZERA_TO_ORA(tST.sIdAtributo);
		if (atoi((char*)tST.sIdAtributo.arr) == iIdAtributoControle) {
			CCstValorPossivel* poVPoss = NULL;

			iValoresPNoAtributo++;

			poVPoss = poListaAtributos[iNroObjLocal-1].getValoresPossiveis();
			if ((poVPoss = (CCstValorPossivel*) realloc((void *)poVPoss, (sizeof(CCstValorPossivel) * iValoresPNoAtributo))) != NULL) {
				rtrim(cIdValorPossivel);
				rtrim(cDsValorPossivel);
				poVPoss[iValoresPNoAtributo-1].setIdValorPossivel(cIdValorPossivel);
				poVPoss[iValoresPNoAtributo-1].setDsValorPossivel(cDsValorPossivel);

				poListaAtributos[iNroObjLocal-1].setValoresPossiveis(poVPoss);
				poListaAtributos[iNroObjLocal-1].setNrValoresPossiveis(iValoresPNoAtributo);

				// Checa se é selecionado ou não.
				if (iiIdPessoaValorPossivel >= 0)
					poVPoss[iValoresPNoAtributo-1].setInSelecionado(1);
				else
					poVPoss[iValoresPNoAtributo-1].setInSelecionado(0);

			} else {
				ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
                if (poVPoss)
                    free(poVPoss);

                EXEC SQL CLOSE cCursorVlPossivelPorCanal;
                ULOG_END("CCstAtributo::RecuperarPorIdSubAssIdPessoaIdCanal()");
				throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
			}
		} else {
			// Aloca memória para o objeto atual.
			iNroObjLocal++;
			if ((poListaAtributos = (CCstAtributo*) realloc((void *)poListaAtributos, (sizeof(CCstAtributo) * iNroObjLocal))) != NULL) {
				
				ZERA_TO_ORA(tST.sIdAtributo);
				ZERA_TO_ORA(tST.sDsAtributo);
				ZERA_TO_ORA(tST.sIdTAPergunta);

				iIdAtributoControle = atoi((char*)tST.sIdAtributo.arr);

				poListaAtributos[iNroObjLocal-1].setIdAtributo((char*)tST.sIdAtributo.arr);
				poListaAtributos[iNroObjLocal-1].setDsAtributo((char*)tST.sDsAtributo.arr);
				poListaAtributos[iNroObjLocal-1].setIdTAPergunta((char*)tST.sIdTAPergunta.arr);
				poListaAtributos[iNroObjLocal-1].setSqApresentacao((char*)tST.sSqApresentacao.arr);

				if(icIdValorPossivel >= 0) {
					// Monta novo objeto de lista de subassuntos.
					CCstValorPossivel* poVPoss;
					poVPoss = (CCstValorPossivel*) malloc(sizeof(CCstValorPossivel));
					poVPoss->setIdValorPossivel(rtrim(cIdValorPossivel));
					poVPoss->setDsValorPossivel(rtrim(cDsValorPossivel));
					iValoresPNoAtributo = 1;
					poListaAtributos[iNroObjLocal-1].setValoresPossiveis(poVPoss);
					poListaAtributos[iNroObjLocal-1].setNrValoresPossiveis(iValoresPNoAtributo);

					// Checa se é selecionado
					if (iiIdPessoaValorPossivel >= 0)
						poVPoss->setInSelecionado(1);
					else
						poVPoss->setInSelecionado(0);

				} else {
					poListaAtributos[iNroObjLocal-1].setNrValoresPossiveis(0);
				}
				poListaAtributos[iNroObjLocal-1].setNrValoresLivres(0);
			} else {
				if (poListaAtributos)
					free(poListaAtributos);

                EXEC SQL CLOSE cCursorVlPossivelPorCanal;
				ULOGE("ERRO DE MEMORIA -> NRO_MEMORIA");
				ULOG_END("CCstAtributo::RecuperarPorIdSubAssIdPessoaIdCanal()");
				throw TuxBasicSvcException(sNrMsg,MSG_MEMORIA);
			}
		}
	}

    EXEC SQL CLOSE cCursorVlLivrePorCanal;
    EXEC SQL CLOSE cCursorVlPossivelPorCanal;

	*iNroObjetos = iNroObjLocal;
	ULOG_END("CCstAtributo::RecuperarPorIdSubAssIdPessoaIdCanal()");
	return poListaAtributos;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
		ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		ULOG_END("CCstAtributo::RecuperarPorIdSubAssIdPessoaIdCanal()");
		throw TuxBasicOraException(sqlca.sqlcode);
}



void CCstAtributo::limpaCanais()
{
        ULOG_END("CCstAtributo::limpaCanais()");
        struct sqlca sqlca;

        EXEC SQL WHENEVER NOT FOUND CONTINUE;
        EXEC SQL WHENEVER SQLERROR GOTO sqlErrorDeletaCanais;

        EXEC SQL
        DELETE FROM
          customer.atributocanal
        WHERE
          idAtributo = :tAtributo.sIdAtributo;

        ULOG_END("CCstAtributo::limpaCanais()");
        return;

sqlErrorDeletaCanais:
        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
        ULOG_END("CCstAtributo::limpaCanais()");
        throw TuxBasicOraException(sqlca.sqlcode);
}

void CCstAtributo::associaCanal(int iIdCanal) 
{

        ULOG_START("CCstAtributo::associaCanal()");
        struct sqlca sqlca;

        EXEC SQL WHENEVER NOT FOUND CONTINUE;
        EXEC SQL WHENEVER SQLERROR GOTO sqlErrorInsereCanal;

        EXEC SQL BEGIN DECLARE SECTION;
                int iOraIdCanal;
        EXEC SQL END DECLARE SECTION;

        iOraIdCanal = iIdCanal;

        ULOG("iOraIdCanal(%d)", iOraIdCanal);

        EXEC SQL
        INSERT INTO
          customer.atributocanal
        (idatributocanal,
         idcanal,
         idatributo,
         idusuarioalteracao,
         dtultimaalteracao)
        VALUES
        (customer.atributocanalsq.nextval,
         :iOraIdCanal,
         :tAtributo.sIdAtributo,
         :sIdUsuarioAlteracao,
         SYSDATE);

        ULOG("sqlca.sqlcode(%d)", sqlca.sqlcode);
        
        ULOG_END("CCstAtributo::associaCanal()");

        return;

sqlErrorInsereCanal:
        ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
        ULOG_END("CCstAtributo::associaCanal()");
        throw TuxBasicOraException(sqlca.sqlcode);
}
