// BuscaCorrespondenciaTI.pcpp: implementation for the 
// CBuscaCorrespondenciaTI class.
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw.h>

EXEC SQL INCLUDE "../include/BuscaCorrespondenciaTI.h";

//
// Construtor e Destrutor
CBuscaCorrespondenciaTI::CBuscaCorrespondenciaTI() {
	icNrLinha = -1;
	icNrConta = -1;
	icDsTipoCorrespondencia = -1;
	icDsMotivoDevolucao = -1;
	icDtDevolucao = -1;
	icDtRegistro = -1;
}

CBuscaCorrespondenciaTI::~CBuscaCorrespondenciaTI() {
}

//
// Metodos getter
int CBuscaCorrespondenciaTI::getIdCorrespondencia(){
	return iIdCorrespondencia;
}

char* CBuscaCorrespondenciaTI::getNrLinha(){
	if (icNrLinha < 0)
		return NULL;
	else
		return cNrLinha;
}

char* CBuscaCorrespondenciaTI::getNrConta(){
	if (icNrConta < 0)
		return NULL;
	else
		return cNrConta;
}

char* CBuscaCorrespondenciaTI::getDsTipoCorrespondencia(){
	if (icDsTipoCorrespondencia < 0)
		return NULL;
	else
		return cDsTipoCorrespondencia;
}

char* CBuscaCorrespondenciaTI::getDsMotivoDevolucao(){
	if (icDsMotivoDevolucao < 0)
		return NULL;
	else
		return cDsMotivoDevolucao;
}

char* CBuscaCorrespondenciaTI::getDtDevolucao(){
	if (icDtDevolucao < 0)
		return NULL;
	else
		return cDtDevolucao;
}

char* CBuscaCorrespondenciaTI::getDtRegistro(){
	if (icDtRegistro < 0)
		return NULL;
	else
		return cDtRegistro;
}

char* CBuscaCorrespondenciaTI::getNmPessoa(){
	return cNmPessoa;
}

int CBuscaCorrespondenciaTI::getIdTipoRelacionamento(){
	return iIdTipoRelacionamento;
}

char* CBuscaCorrespondenciaTI::getDsTipoRelacionamento(){
	return cDsTipoRelacionamento;
}

//
// Metodos setter
void CBuscaCorrespondenciaTI::setIdCorrespondencia(int value){
	iIdCorrespondencia = value;
}

void CBuscaCorrespondenciaTI::setNrLinha(char* value){
	if(value == NULL)
		icNrLinha = -1;
	else {
		strncpy(cNrLinha, value, 255);
		cNrLinha[255]='\0';
		icNrLinha= strlen(value);
	}
}

void CBuscaCorrespondenciaTI::setNrConta(char* value){
	if(value == NULL)
		icNrConta = -1;
	else {
		strncpy(cNrConta, value, 255);
		cNrConta[255]='\0';
		icNrConta= strlen(value);
	}
}

void CBuscaCorrespondenciaTI::setDsTipoCorrespondencia(char* value){
	if(value == NULL)
		icDsTipoCorrespondencia = -1;
	else {
		strncpy(cDsTipoCorrespondencia, value, 255);
		cDsTipoCorrespondencia[255]='\0';
		icDsTipoCorrespondencia= strlen(value);
	}
}

void CBuscaCorrespondenciaTI::setDsMotivoDevolucao(char* value){
	if(value == NULL)
		icDsMotivoDevolucao = -1;
	else {
		strncpy(cDsMotivoDevolucao, value, 255);
		cDsMotivoDevolucao[255]='\0';
		icDsMotivoDevolucao = strlen(value);
	}
}

void CBuscaCorrespondenciaTI::setDtDevolucao(char* value){
	if(value == NULL)
		icDtDevolucao = -1;
	else {
		strncpy(cDtDevolucao, value, 255);
		cDtDevolucao[255]='\0';
		icDtDevolucao= strlen(value);
	}
}

void CBuscaCorrespondenciaTI::setDtRegistro(char* value){
	if(value == NULL)
		icDtRegistro = -1;
	else {
		strncpy(cDtRegistro, value, 255);
		cDtRegistro[255]='\0';
		icDtRegistro= strlen(value);
	}
}

void CBuscaCorrespondenciaTI::setNmPessoa(char* value){
	strncpy(cNmPessoa, value, 255);
	cNmPessoa[255]='\0';
}

void CBuscaCorrespondenciaTI::setIdTipoRelacionamento(int value){
	iIdTipoRelacionamento = value;
}

void CBuscaCorrespondenciaTI::setDsTipoRelacionamento(char* value){
	strncpy(cDsTipoRelacionamento, value, 255);
	cDsTipoRelacionamento[255]='\0';
}

//
// Métodos de banco de dados
CBuscaCorrespondenciaTI* CBuscaCorrespondenciaTI::buscaCliUsu(char* cDtRegIni,
													char* cDtRegFim, 
													int iIdPessoa,
													int iIdStat, 
													int* iNroObjetos)
{
    ULOG_START("CBuscaCorrespondenciaTI::buscaCliUsu()");

	struct sqlca sqlca;
	CBuscaCorrespondenciaTI* listaBusca = NULL;
	int iNroObjLocal = 1;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	EXEC SQL BEGIN DECLARE SECTION;
	// Parâmetros de entrada
	char cOraDtRegIni[256];
	char cOraDtRegFim[256];
	int iOraIdStat;
	int iOraIdPessoa;

	// Resultado da busca
	int iIdCorrespondencia;
	char cNrLinha[256];
	char cNrConta[256];
	char cDsTipoCorrespondencia[256];
	char cDsMotivoDevolucao[256];
	char cDtDevolucao[256];
	char cDtRegistro[256];
	char cNmPessoa[256];
	int iIdTipoRelacionamento;
	char cDsTipoRelacionamento[256];

	// Variáveis indicativas do oracle
	short icNrLinha;
	short icNrConta;
	short icDsTipoCorrespondencia;
	short icDsMotivoDevolucao;
	short icDtDevolucao;
	short icDtRegistro;
	EXEC SQL END DECLARE SECTION;

	// Seta os valores para a busca
	if (cDtRegIni != NULL) {
		strncpy(cOraDtRegIni,cDtRegIni,255);
		strncpy(cOraDtRegFim,cDtRegFim,255);
	} else {
		strcpy(cOraDtRegIni,"01/01/2036");
		strcpy(cOraDtRegFim,"01/01/1970");
	}

	iOraIdStat = iIdStat;
	iOraIdPessoa = iIdPessoa;

	// Monta a query.
	EXEC SQL DECLARE listaCorr CURSOR FOR
	SELECT 
	 idCorrespondenciaDevolvida, 
	 linha,
	 cdConta, 
	 dsMotivoDevolucao,
	 dsTipoCorrespondencia, 
	 TO_CHAR(dtInclusao,'DD/MM/YYYY'),
	 TO_CHAR(dtDevolucao,'DD/MM/YYYY'),
	 NmPessoa,
	 IdTipoRelacionamento, 
	 NmTipoRelacionamento
	from
	 correspondencia.corrDevTelaIniV01
	where
	 idPessoa in ( select
						 idPessoaUsu
						from 
						 customer.UsuFromCliV01
						where
						 idPessoaCli = :iOraIdPessoa AND 
						 idPessoaUsu <> :iOraIdPessoa) AND
	 idTipoRelacionamento = 1 AND
     ( (TO_CHAR(DtInclusao, 'YYYYMMDD') >= TO_CHAR(TO_DATE(:cOraDtRegIni, 'DD/MM/YYYY'), 'YYYYMMDD') AND  
        TO_CHAR(DtInclusao, 'YYYYMMDD') <= TO_CHAR(TO_DATE(:cOraDtRegFim, 'DD/MM/YYYY'), 'YYYYMMDD')) OR '01/01/2036' = :cOraDtRegIni) AND
	 idStatusCorrespondencia = :iOraIdStat
	UNION
	select 
	 idCorrespondenciaDevolvida,
	 linha,
	 cdConta, 
	 dsMotivoDevolucao,
	 dsTipoCorrespondencia, 
	 TO_CHAR(dtInclusao,'DD/MM/YYYY'),
	 TO_CHAR(dtDevolucao,'DD/MM/YYYY'),
	 NmPessoa,
	 IdTipoRelacionamento, 
	 NmTipoRelacionamento
	from
	 correspondencia.corrDevTelaIniV01
	where

	 idTipoRelacionamento = 2 AND
     ( (TO_CHAR(DtInclusao, 'YYYYMMDD') >= TO_CHAR(TO_DATE(:cOraDtRegIni, 'DD/MM/YYYY'), 'YYYYMMDD') AND  
        TO_CHAR(DtInclusao, 'YYYYMMDD') <= TO_CHAR(TO_DATE(:cOraDtRegFim, 'DD/MM/YYYY'), 'YYYYMMDD')) OR '01/01/2036' = :cOraDtRegIni) AND
	 idPessoa = :iOraIdPessoa AND
	 idStatusCorrespondencia = :iOraIdStat;

	// Prepara e abre o cursor
	EXEC SQL OPEN listaCorr;

	// Corre os dados e monta a lista de objetos
	EXEC SQL WHENEVER NOT FOUND DO break;
	for (;; iNroObjLocal++) {
		
		EXEC SQL FETCH listaCorr INTO
			iIdCorrespondencia,
			cNrLinha:icNrLinha,
			cNrConta:icNrConta,
			cDsMotivoDevolucao:icDsMotivoDevolucao,
			cDsTipoCorrespondencia:icDsTipoCorrespondencia,
			cDtDevolucao:icDtDevolucao,
			cDtRegistro:icDtRegistro,
			cNmPessoa,
			iIdTipoRelacionamento,
			cDsTipoRelacionamento;

		// Aloca memória para o objeto atual.
		if ((listaBusca = (CBuscaCorrespondenciaTI*) realloc((void *)listaBusca, (sizeof(CBuscaCorrespondenciaTI) * iNroObjLocal))) != NULL) {
			
			// Coloca os dados do objeto atual.
			listaBusca[iNroObjLocal-1].setIdCorrespondencia(iIdCorrespondencia);
			listaBusca[iNroObjLocal-1].setNrLinha(icNrLinha < 0 ? NULL : cNrLinha);
			listaBusca[iNroObjLocal-1].setNrConta(icNrConta < 0 ? NULL : cNrConta);
			listaBusca[iNroObjLocal-1].setDsTipoCorrespondencia(icDsTipoCorrespondencia < 0 ? NULL : cDsTipoCorrespondencia);
			listaBusca[iNroObjLocal-1].setDsMotivoDevolucao(icDsMotivoDevolucao < 0 ? NULL : cDsMotivoDevolucao);
			listaBusca[iNroObjLocal-1].setDtDevolucao(icDtDevolucao < 0 ? NULL : cDtDevolucao);
			listaBusca[iNroObjLocal-1].setDtRegistro(icDtRegistro < 0 ? NULL : cDtRegistro);
			listaBusca[iNroObjLocal-1].setNmPessoa(cNmPessoa);
			listaBusca[iNroObjLocal-1].setIdTipoRelacionamento(iIdTipoRelacionamento);
			listaBusca[iNroObjLocal-1].setDsTipoRelacionamento(cDsTipoRelacionamento);

		} else {
			if (listaBusca)
				free(listaBusca);
			ULOG_END("CBuscaCorrespondenciaTI::buscaCliUsu()");
			throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
		}
	}

	*iNroObjetos = iNroObjLocal - 1;
	ULOG_END("CBuscaCorrespondenciaTI::buscaCliUsu()");
	return listaBusca;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CBuscaCorrespondenciaTI::buscaCliUsu()");
		throw TuxBasicOraException(sqlca.sqlcode);
}


CBuscaCorrespondenciaTI* CBuscaCorrespondenciaTI::buscaCli(char* cDtRegIni,
													       char* cDtRegFim, 
													       int iIdPessoa,
													       int iIdStat, 
													       int* iNroObjetos) 
{

	ULOG_START("CBuscaCorrespondenciaTI::buscaCli()");
	struct sqlca sqlca;
	CBuscaCorrespondenciaTI* listaBusca = NULL;
	int iNroObjLocal = 1;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	EXEC SQL BEGIN DECLARE SECTION;
	// Parâmetros de entrada
	char cOraDtRegIni[256];
	char cOraDtRegFim[256];
	int iOraIdStat;
	int iOraIdPessoa;

	// Resultado da busca
	int iIdCorrespondencia;
	char cNrLinha[256];
	char cNrConta[256];
	char cDsTipoCorrespondencia[256];
	char cDsMotivoDevolucao[256];
	char cDtDevolucao[256];
	char cDtRegistro[256];
	char cNmPessoa[256];
	int iIdTipoRelacionamento;
	char cDsTipoRelacionamento[256];

	// Variáveis indicativas do oracle
	short icNrLinha;
	short icNrConta;
	short icDsTipoCorrespondencia;
	short icDsMotivoDevolucao;
	short icDtDevolucao;
	short icDtRegistro;
	EXEC SQL END DECLARE SECTION;

    ULOG("cDtRegIni[%s]", cDtRegIni ? cDtRegIni : "...NULL...");
    ULOG("cDtRegFim[%s]", cDtRegFim ? cDtRegFim : "...NULL...");

	// Seta os valores para a busca
	if (cDtRegIni != NULL) {
		strncpy(cOraDtRegIni,cDtRegIni,255);
		strncpy(cOraDtRegFim,cDtRegFim,255);
	} else {
		strcpy(cOraDtRegIni,"01/01/2036");
		strcpy(cOraDtRegFim,"01/01/1970");
	}

	iOraIdStat = iIdStat;
	iOraIdPessoa = iIdPessoa;

	// Monta a query.
	EXEC SQL DECLARE listaCorrCli CURSOR FOR
	SELECT 
	 IDCORRESPONDENCIADEVOLVIDA,
	 LINHA,
	 CDCONTA, 
	 DSMOTIVODEVOLUCAO,
	 DSTIPOCORRESPONDENCIA, 
	 TO_CHAR(DTINCLUSAO,'DD/MM/YYYY'),
	 TO_CHAR(DTDEVOLUCAO,'DD/MM/YYYY'),
	 NMPESSOA,
	 IDTIPORELACIONAMENTO, 
	 NMTIPORELACIONAMENTO
	FROM
	 CORRESPONDENCIA.CORRDEVTELAINIV01
	WHERE
	 IDTIPORELACIONAMENTO = 2 AND
     ( (TO_CHAR(DtInclusao, 'YYYYMMDD') >= TO_CHAR(TO_DATE(:cOraDtRegIni, 'DD/MM/YYYY'), 'YYYYMMDD') AND  
        TO_CHAR(DtInclusao, 'YYYYMMDD') <= TO_CHAR(TO_DATE(:cOraDtRegFim, 'DD/MM/YYYY'), 'YYYYMMDD')) OR '01/01/2036' = :cOraDtRegIni) AND
	 idPessoa = :iOraIdPessoa AND
	 ( idStatusCorrespondencia = :iOraIdStat or :iOraIdStat = 0 );

	// Prepara e abre o cursor
	EXEC SQL OPEN listaCorrCli;

	// Corre os dados e monta a lista de objetos
	EXEC SQL WHENEVER NOT FOUND DO break;
	for (;; iNroObjLocal++) {
		
		EXEC SQL FETCH listaCorrCli INTO
			iIdCorrespondencia,
			cNrLinha:icNrLinha,
			cNrConta:icNrConta,
			cDsMotivoDevolucao:icDsMotivoDevolucao,
			cDsTipoCorrespondencia:icDsTipoCorrespondencia,
			cDtDevolucao:icDtDevolucao,
			cDtRegistro:icDtRegistro,
			cNmPessoa,
			iIdTipoRelacionamento,
			cDsTipoRelacionamento;

		// Aloca memória para o objeto atual.
		if ((listaBusca = (CBuscaCorrespondenciaTI*) realloc((void *)listaBusca, (sizeof(CBuscaCorrespondenciaTI) * iNroObjLocal))) != NULL) {
			
			// Coloca os dados do objeto atual.
			listaBusca[iNroObjLocal-1].setIdCorrespondencia(iIdCorrespondencia);
			listaBusca[iNroObjLocal-1].setNrLinha(icNrLinha < 0 ? NULL : cNrLinha);
			listaBusca[iNroObjLocal-1].setNrConta(icNrConta < 0 ? NULL : cNrConta);
			listaBusca[iNroObjLocal-1].setDsTipoCorrespondencia(icDsTipoCorrespondencia < 0 ? NULL : cDsTipoCorrespondencia);
			listaBusca[iNroObjLocal-1].setDsMotivoDevolucao(icDsMotivoDevolucao < 0 ? NULL : cDsMotivoDevolucao);
			listaBusca[iNroObjLocal-1].setDtDevolucao(icDtDevolucao < 0 ? NULL : cDtDevolucao);
			listaBusca[iNroObjLocal-1].setDtRegistro(icDtRegistro < 0 ? NULL : cDtRegistro);
			listaBusca[iNroObjLocal-1].setNmPessoa(cNmPessoa);
			listaBusca[iNroObjLocal-1].setIdTipoRelacionamento(iIdTipoRelacionamento);
			listaBusca[iNroObjLocal-1].setDsTipoRelacionamento(cDsTipoRelacionamento);

		} else {
			if (listaBusca)
				free(listaBusca);

            EXEC SQL CLOSE listaCorrCli;
            
            ULOG_END("CBuscaCorrespondenciaTI::buscaCli()");

			throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
		}
	}

    ULOG("iNroObjLocal(%d)",iNroObjLocal);

    EXEC SQL CLOSE listaCorrCli;

	*iNroObjetos = iNroObjLocal - 1;
	
	ULOG_END("CBuscaCorrespondenciaTI::buscaCli()");
	
	return listaBusca;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CBuscaCorrespondenciaTI::buscaCli()");
		throw TuxBasicOraException(sqlca.sqlcode);
}


CBuscaCorrespondenciaTI* CBuscaCorrespondenciaTI::buscaCli(char* cDtRegIni,
													       char* cDtRegFim, 
													       int iIdPessoa,
													       int* iNroObjetos)
{

	ULOG_START("CBuscaCorrespondenciaTI::buscaCli()");
	struct sqlca sqlca;
	CBuscaCorrespondenciaTI* listaBusca = NULL;
	int iNroObjLocal = 1;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	EXEC SQL BEGIN DECLARE SECTION;
	// Parâmetros de entrada
	char cOraDtRegIni[256];
	char cOraDtRegFim[256];
	int iOraIdPessoa;

	// Resultado da busca
	int iIdCorrespondencia;
	char cNrLinha[256];
	char cNrConta[256];
	char cDsTipoCorrespondencia[256];
	char cDsMotivoDevolucao[256];
	char cDtDevolucao[256];
	char cDtRegistro[256];
	char cNmPessoa[256];
	int iIdTipoRelacionamento;
	char cDsTipoRelacionamento[256];

	// Variáveis indicativas do oracle
	short icNrLinha;
	short icNrConta;
	short icDsTipoCorrespondencia;
	short icDsMotivoDevolucao;
	short icDtDevolucao;
	short icDtRegistro;
	EXEC SQL END DECLARE SECTION;

    ULOG("cDtRegIni[%s]", cDtRegIni ? cDtRegIni : "...NULL...");
    ULOG("cDtRegFim[%s]", cDtRegFim ? cDtRegFim : "...NULL...");

	// Seta os valores para a busca
	if (cDtRegIni != NULL) {
		strncpy(cOraDtRegIni,cDtRegIni,255);
		strncpy(cOraDtRegFim,cDtRegFim,255);
	} else {
		strcpy(cOraDtRegIni,"01/01/2036");
		strcpy(cOraDtRegFim,"01/01/1970");
	}

	iOraIdPessoa = iIdPessoa;

	// Monta a query.
	EXEC SQL DECLARE listaCorrCliSemStatus CURSOR FOR
	SELECT DISTINCT
		CORR.IDCORRESPONDENCIADEVOLVIDA,
		AREAREGISTRO.CDAREAREGISTRO || LINHABASE.NRLINHA,
		CONTA.CDCONTA,
		MOTDEV.DSMOTIVODEVOLUCAO,
		TPCORR.DSTIPOCORRESPONDENCIA,
		CORR.DTINCLUSAO,
		CORR.DTDEVOLUCAO,
		PESS.NMPESSOA,
		TPREL.IDTIPORELACIONAMENTO,
		TPREL.NMTIPORELACIONAMENTO
	FROM
		CORRESPONDENCIA.CORRESPONDENCIADEVOLVIDA CORR,
		CORRESPONDENCIA.CORRESPDEVLINHATELEFONIC CORRLIN,
	    LINHA.LINHATELEFONICA LINHATELEFONICA,
	    LINHA.LINHABASE LINHABASE,
		CORRESPONDENCIA.CORRESPDEVOLVIDACONTA CORRCONT,
		CUSTOMER.CONTA CONTA,
		CORRESPONDENCIA.HISTORICOSTATUSATUAL HISTSTATATU,
		CORRESPONDENCIA.HISTORICOSTATUS HISTSTAT,
		APOIO.TIPOCORRESPONDENCIA TPCORR, 
		APOIO.MOTIVODEVOLUCAO MOTDEV,
		CUSTOMER.PESSOA PESS, 
		CUSTOMER.TIPORELACIONAMENTO TPREL,
		APOIO.STATUSCORRESPONDENCIA STATUSCORRESPONDENCIA,
		CORRESPONDENCIA.STATUSUNIDADE STATUSUNIDADE,
	    APOIO.AREAREGISTRO AREAREGISTRO
	WHERE
	    AREAREGISTRO.IDAREAREGISTRO = LINHABASE.IDAREAREGISTRO
	AND
	    CORRLIN.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
	AND
	    LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
	AND
		CORR.IDPESSOA = PESS.IDPESSOA
	AND
		CORRLIN.IDCORRESPONDENCIADEVOLVIDA(+) = CORR.IDCORRESPONDENCIADEVOLVIDA
	AND
		CORRCONT.IDCORRESPONDENCIADEVOLVIDA(+) = CORR.IDCORRESPONDENCIADEVOLVIDA
	AND
		CORRCONT.IDCONTA = CONTA.IDCONTA (+)
	AND
		CORR.IDTIPOCORRESPONDENCIA = TPCORR.IDTIPOCORRESPONDENCIA
	AND
		CORR.IDMOTIVODEVOLUCAO = MOTDEV.IDMOTIVODEVOLUCAO
	AND
		CORR.IDCORRESPONDENCIADEVOLVIDA = HISTSTAT.IDCORRESPONDENCIADEVOLVIDA
	AND
		HISTSTATATU.IDHISTORIOSTATUS = HISTSTAT.IDHISTORIOSTATUS
	AND
		HISTSTAT.IDSTATUSCORRESPONDENCIA = STATUSCORRESPONDENCIA.IDSTATUSCORRESPONDENCIA
	AND
		STATUSCORRESPONDENCIA.IDSTATUSCORRESPONDENCIA = STATUSUNIDADE.IDSTATUSCORRESPONDENCIA
	AND
		STATUSUNIDADE.IDUNIDADE IN ( SELECT IDUNIDADE FROM ACESSO.UNIDADE WHERE CDUNIDADE = 'CORRTRATAR' )	
	AND	
	 	TPREL.IDTIPORELACIONAMENTO = 2
	AND
     	( ( TO_CHAR(CORR.DTINCLUSAO, 'YYYYMMDD') >= TO_CHAR(TO_DATE(:cOraDtRegIni, 'DD/MM/YYYY'), 'YYYYMMDD') 
     	  AND TO_CHAR(CORR.DTINCLUSAO, 'YYYYMMDD') <= TO_CHAR(TO_DATE(:cOraDtRegFim, 'DD/MM/YYYY'), 'YYYYMMDD')) 
    	  OR '01/01/2036' = :cOraDtRegIni
    	) 
   	AND
		PESS.IDPESSOA = :iOraIdPessoa;
	
	// Prepara e abre o cursor
	EXEC SQL OPEN listaCorrCliSemStatus;

	// Corre os dados e monta a lista de objetos
	EXEC SQL WHENEVER NOT FOUND DO break;
	for (;; iNroObjLocal++) {
		
		EXEC SQL FETCH listaCorrCliSemStatus INTO
			iIdCorrespondencia,
			cNrLinha:icNrLinha,
			cNrConta:icNrConta,
			cDsMotivoDevolucao:icDsMotivoDevolucao,
			cDsTipoCorrespondencia:icDsTipoCorrespondencia,
			cDtDevolucao:icDtDevolucao,
			cDtRegistro:icDtRegistro,
			cNmPessoa,
			iIdTipoRelacionamento,
			cDsTipoRelacionamento;

		// Aloca memória para o objeto atual.
		if ((listaBusca = (CBuscaCorrespondenciaTI*) realloc((void *)listaBusca, (sizeof(CBuscaCorrespondenciaTI) * iNroObjLocal))) != NULL) {
			
			// Coloca os dados do objeto atual.
			listaBusca[iNroObjLocal-1].setIdCorrespondencia(iIdCorrespondencia);
			listaBusca[iNroObjLocal-1].setNrLinha(icNrLinha < 0 ? NULL : cNrLinha);
			listaBusca[iNroObjLocal-1].setNrConta(icNrConta < 0 ? NULL : cNrConta);
			listaBusca[iNroObjLocal-1].setDsTipoCorrespondencia(icDsTipoCorrespondencia < 0 ? NULL : cDsTipoCorrespondencia);
			listaBusca[iNroObjLocal-1].setDsMotivoDevolucao(icDsMotivoDevolucao < 0 ? NULL : cDsMotivoDevolucao);
			listaBusca[iNroObjLocal-1].setDtDevolucao(icDtDevolucao < 0 ? NULL : cDtDevolucao);
			listaBusca[iNroObjLocal-1].setDtRegistro(icDtRegistro < 0 ? NULL : cDtRegistro);
			listaBusca[iNroObjLocal-1].setNmPessoa(cNmPessoa);
			listaBusca[iNroObjLocal-1].setIdTipoRelacionamento(iIdTipoRelacionamento);
			listaBusca[iNroObjLocal-1].setDsTipoRelacionamento(cDsTipoRelacionamento);

		} else {
			if (listaBusca)
				free(listaBusca);

            EXEC SQL CLOSE listaCorrCliSemStatus;
            
            ULOG_END("CBuscaCorrespondenciaTI::buscaCli()");
            
			throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
		}
	}

    ULOG("iNroObjLocal(%d)",iNroObjLocal);

    EXEC SQL CLOSE listaCorrCliSemStatus;

	*iNroObjetos = iNroObjLocal - 1;
	ULOG_END("CBuscaCorrespondenciaTI::buscaCli()");
	return listaBusca;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CBuscaCorrespondenciaTI::buscaCli()");
		throw TuxBasicOraException(sqlca.sqlcode);
}



CBuscaCorrespondenciaTI* CBuscaCorrespondenciaTI::buscaUsu(char* cDtRegIni,
													char* cDtRegFim, 
													int iIdPessoa,
													int iIdStat, 
													int* iNroObjetos) 
{

	ULOG_START("CBuscaCorrespondenciaTI::buscaUsu()");
	struct sqlca sqlca;
	CBuscaCorrespondenciaTI* listaBusca = NULL;
	int iNroObjLocal = 1;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorLista;

	EXEC SQL BEGIN DECLARE SECTION;
	// Parâmetros de entrada
	char cOraDtRegIni[256];
	char cOraDtRegFim[256];
	int iOraIdStat;
	int iOraIdPessoa;

	// Resultado da busca
	int iIdCorrespondencia;
	char cNrLinha[256];
	char cNrConta[256];
	char cDsTipoCorrespondencia[256];
	char cDsMotivoDevolucao[256];
	char cDtDevolucao[256];
	char cDtRegistro[256];
	char cNmPessoa[256];
	int iIdTipoRelacionamento;
	char cDsTipoRelacionamento[256];

	// Variáveis indicativas do oracle
	short icNrLinha;
	short icNrConta;
	short icDsTipoCorrespondencia;
	short icDsMotivoDevolucao;
	short icDtDevolucao;
	short icDtRegistro;
	EXEC SQL END DECLARE SECTION;

    ULOG("cDtRegIni[%s]", cDtRegIni ? cDtRegIni : "...NULL...");
    ULOG("cDtRegFim[%s]", cDtRegFim ? cDtRegFim : "...NULL...");

	// Seta os valores para a busca
	if (cDtRegIni != NULL) {
		strncpy(cOraDtRegIni,cDtRegIni,255);
		strncpy(cOraDtRegFim,cDtRegFim,255);
	} else {
		strcpy(cOraDtRegIni,"01/01/2036");
		strcpy(cOraDtRegFim,"01/01/1970");
	}

	iOraIdStat = iIdStat;
	iOraIdPessoa = iIdPessoa;

	// Monta a query.
	EXEC SQL DECLARE listaCorrUsu CURSOR FOR
	SELECT
	 idCorrespondenciaDevolvida,
	 linha,
	 cdConta, 
	 dsMotivoDevolucao,
	 dsTipoCorrespondencia, 
	 TO_CHAR(dtInclusao,'DD/MM/YYYY'),
	 TO_CHAR(dtDevolucao,'DD/MM/YYYY'),
	 NmPessoa,
	 IdTipoRelacionamento, 
	 NmTipoRelacionamento
	from
	 correspondencia.corrDevTelaIniV01
	where
	 idTipoRelacionamento = 1 AND
     ( (TO_CHAR(DtInclusao, 'YYYYMMDD') >= TO_CHAR(TO_DATE(:cOraDtRegIni, 'DD/MM/YYYY'), 'YYYYMMDD') AND  
        TO_CHAR(DtInclusao, 'YYYYMMDD') <= TO_CHAR(TO_DATE(:cOraDtRegFim, 'DD/MM/YYYY'), 'YYYYMMDD')) OR '01/01/2036' = :cOraDtRegIni) AND
	 idPessoa = :iOraIdPessoa AND
	 ( idStatusCorrespondencia = :iOraIdStat or :iOraIdStat = 0 );

	// Prepara e abre o cursor
	EXEC SQL OPEN listaCorrUsu;

	// Corre os dados e monta a lista de objetos
	EXEC SQL WHENEVER NOT FOUND DO break;
	for (;; iNroObjLocal++) {
		
		EXEC SQL FETCH listaCorrUsu INTO
			iIdCorrespondencia,
			cNrLinha:icNrLinha,
			cNrConta:icNrConta,
			cDsMotivoDevolucao:icDsMotivoDevolucao,
			cDsTipoCorrespondencia:icDsTipoCorrespondencia,
			cDtDevolucao:icDtDevolucao,
			cDtRegistro:icDtRegistro,
			cNmPessoa,
			iIdTipoRelacionamento,
			cDsTipoRelacionamento;

		// Aloca memória para o objeto atual.
		if ((listaBusca = (CBuscaCorrespondenciaTI*) realloc((void *)listaBusca, (sizeof(CBuscaCorrespondenciaTI) * iNroObjLocal))) != NULL) {
			
			// Coloca os dados do objeto atual.
			listaBusca[iNroObjLocal-1].setIdCorrespondencia(iIdCorrespondencia);
			listaBusca[iNroObjLocal-1].setNrLinha(icNrLinha < 0 ? NULL : cNrLinha);
			listaBusca[iNroObjLocal-1].setNrConta(icNrConta < 0 ? NULL : cNrConta);
			listaBusca[iNroObjLocal-1].setDsTipoCorrespondencia(icDsTipoCorrespondencia < 0 ? NULL : cDsTipoCorrespondencia);
			listaBusca[iNroObjLocal-1].setDsMotivoDevolucao(icDsMotivoDevolucao < 0 ? NULL : cDsMotivoDevolucao);
			listaBusca[iNroObjLocal-1].setDtDevolucao(icDtDevolucao < 0 ? NULL : cDtDevolucao);
			listaBusca[iNroObjLocal-1].setDtRegistro(icDtRegistro < 0 ? NULL : cDtRegistro);
			listaBusca[iNroObjLocal-1].setNmPessoa(cNmPessoa);
			listaBusca[iNroObjLocal-1].setIdTipoRelacionamento(iIdTipoRelacionamento);
			listaBusca[iNroObjLocal-1].setDsTipoRelacionamento(cDsTipoRelacionamento);

		} else {
			if (listaBusca)
				free(listaBusca);
			ULOG_END("CBuscaCorrespondenciaTI::buscaUsu()");
			throw new TuxBasicSvcException(NRO_ERR_MEMORIA,MSG_ERR_MEMORIA);
		}
	}

	*iNroObjetos = iNroObjLocal - 1;
	ULOG_END("CBuscaCorrespondenciaTI::buscaUsu()");
	return listaBusca;

	// Tratamento de erro - Lança excessão com o código oracle do erro.
	sqlErrorLista:
	    ULOGE("ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	    ULOG_END("CBuscaCorrespondenciaTI::buscaUsu()");
		throw TuxBasicOraException(sqlca.sqlcode);
}
