//------------------------------------------------------------------------------------
  //                           (c) Consorcio Indra/PT-SI.
  //                              xxxxxxxxxxxxxxxxxxxxxxx
  //                                  xxxxxxxxxxxxxx 
  //----------------------------------------------------------------------------------
  // Los contenidos de este fichero son propiedad de Telefonica Consorsio Indra/Pt-SI.
  // titular del copyright. Este fichero solo podra ser copiado, distribuido y utilizado,
  // em su totalidad o en parte, con el permiso escrito de Consorcio Indra/Pt-SI o de
  // acuerdo com los terminos y condiciones establecidas em el acuerdo/contrato bajo el
  // que se suministra.
//----------------------------------------------------------------------------------
//* Fonte   : main.cpp
//* Servico : PesquisaLinha
//* Servidor: PesquisaTI
//*
//* Ficheiro: TUXEFO/cliente/PesquisaTI/PesquisaLinha/src
//*
//* Tipo: Pro*C
//*
//* Autor: Jefferson Martins
//*
//* Fecha primeira version:13/06/2004
//*
//* Version actual: 01.00
//*
//* Purpose:
//*//-------------------------------------------------------------------------------
//* Purpose:
//*
//* Monta XML de retorno com todas a linhas a partir da escolha de uma Pessoa
//*
//* Review:
//*
//* Task force to seek potential memory leaks and exception errors - March,2005 - Cassio
//* 
//*//-------------------------------------------------------------------------------
//---------------------------------------------------------------------

//EXEC SQL INCLUDE SQLCA;

#include "../../negocio/clienteCmm/include/Messages.h"
#include "../../negocio/clienteCmm/include/Funcoes.h"
#include <tuxfw.h>

#include "../include/PesquisaLinha.h"

#define STRLENNULL( y ) ( y == NULL ? 0 : strlen( y )  )

EXEC SQL BEGIN DECLARE SECTION;
#include "Global.h"
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE "../../negocio/clienteCmm/include/classPessoaLinha.h";
EXEC SQL INCLUDE "../../negocio/clienteCmm/include/AreaRegistroBloqueado.h";

DECLARE_TUXEDO_SERVICE(PesquisaLinha);

void implPesquisaLinha::Execute(DOMNode *pDnode, XMLGen *pXmlG)
{
    ULOG_START( "implPesquisaLinha::Execute()" );
    char *idPessoa=0;
    char *nrConta=0;
    int iNroReg = 0;
    int iAux;
    CPessoaLinha* poObj = 0;
    DOMNode *dnPaginacao = walkDOM( pDnode, "Paginacao", 0 );
    char* pzcAux;
    char cpageNumber[5+1];
    
    try{

        idPessoa=walkTree(pDnode, XML_IN_IDPESSOA, 0);
        nrConta=walkTree(pDnode, XML_IN_NRCONTA, 0);
        
        if( STRLENNULL( idPessoa ) > 0 )
        {
            if ( !*nrConta)
                XMLString::release(&nrConta);

            if ( !IsNumeric(idPessoa) ){
                ERROR(NRO_ID_PESSOA_VI);
                TAG_VALOR_INVALIDO(XML_IN_IDPESSOA);
                XMLString::release(&idPessoa);
                throw new TuxBasicSvcException(sNrMsg, sMsg);
            }
            //OBS: Pesquisa por pessoa não é paginada
            poObj = CPessoaLinha::buscarPorIdPessoa(&iNroReg, idPessoa);

        }
        else
        {
            if ( !*idPessoa)
                XMLString::release(&idPessoa);

            if(!nrConta){
                ERROR(NRO_PESQUISA_NE);
                TAG_INEXISTENTE(XML_IN_NRCONTA);
                throw new TuxBasicSvcException(sNrMsg, sMsg);
            }
            if ( !*nrConta){
                ERROR(NRO_PESQUISA_VV);
                TAG_VALOR_VAZIO(XML_IN_NRCONTA);
                XMLString::release(&nrConta);
                throw new TuxBasicSvcException(sNrMsg, sMsg);
            }

	    	memset(&cpageNumber, 0, sizeof(cpageNumber));
			//Rotinas para paginação
			strcpy( cpageNumber, "1" );//Assume como primeira pagina
			if( dnPaginacao != NULL )
			{
				pzcAux = walkTree( dnPaginacao, "pageNumber", 0 );	
				if( pzcAux != NULL )
					strcpy( cpageNumber, pzcAux );//Caso venha alguma número, assumimos o que vier, senão fica como 1 mesmo
					
				XMLString::release(&pzcAux);
			}
	   		ULOG("pageNumber[%s]", cpageNumber );

            poObj = CPessoaLinha::buscarPorNrConta(&iNroReg, nrConta, cpageNumber);

        }

        pXmlG->createTag(XML_VO_ROOT);
        pXmlG->addProp("xmlns",XML_PROP);
        for (iAux=0; iAux < iNroReg; iAux++) 
        {
            pXmlG->createTag(XML_VO_NO_LINHAS);
//              pXmlG->addItem(XML_VO_IDPESSOALINHA, poObj[iAux].getIdPessoa());
                pXmlG->addItem(XML_VO_NRLINHA, poObj[iAux].getNrLinha());

                CAreaRegistroBloqueado *pclAreaRegistroBloqueado = new CAreaRegistroBloqueado;
                pclAreaRegistroBloqueado->setNrLinha(poObj[iAux].getNrLinha());
                if(pclAreaRegistroBloqueado->DDDBloqueado() == true)
                {
                    pXmlG->addItem("inBloqueado", "1");
                }
                else
                {
                    pXmlG->addItem("inBloqueado", "0");
                }
                delete pclAreaRegistroBloqueado;

            pXmlG->closeTag();
        }
		if( dnPaginacao != NULL )
		{
			//TAGs de paginacao
	    	pXmlG->createTag("Paginacao");
		        pXmlG->addItem("pageNumber", cpageNumber);
		    	if( iNroReg > 0 )
		    	{
	            	//estamos pegando poObj[0] porque a forma de buscar os dados e tosca e mudar para a paginacao
	            	//seria muito trabalhoso e perigoso. O valor de ultima pagina sempre vem no primeiro registro.
    				ULOG( "poObj[0].getUltimaPagina()[%d]", poObj[0].getUltimaPagina() );
	            	if( poObj[0].getUltimaPagina() == 1 ) 
	            		pXmlG->addItem("hasNext", 0);
	            	else
	            		pXmlG->addItem("hasNext", 1);
				}
				else
					pXmlG->addItem("hasNext", 0);
			pXmlG->closeTag();//Paginacao
		}//if( dnPaginacao != NULL )
        pXmlG->closeTag();

        XMLString::release(&idPessoa);
        XMLString::release(&nrConta);
        idPessoa = 0;
        nrConta  = 0;

        //Liberando memoria alocada
        if ( poObj ) free(poObj);
    }
    catch(...){
        if ( idPessoa ) XMLString::release(&idPessoa);
        if ( nrConta ) XMLString::release(&nrConta);
        if ( poObj ) free(poObj);
        throw;  //repassando o erro para nucleo
    }

    ULOG_END( "implPesquisaLinha::Execute()" );

    // Execução OK.
    INFORMATION(NRO_OK);
    setStatusCode(sNrMsg, MSG_OK);
}



