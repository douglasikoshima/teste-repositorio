#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>

#include "tuxfw.h"
#include "PessoaDocumentopcTMA.h"

EXEC SQL BEGIN DECLARE SECTION;
#include "PPGlobalTMA.h"
EXEC SQL END DECLARE SECTION;

/**************************************************************************************/
void CPessoaDocumentopc::proCApagaPessoaDocumento(TPessoaDocumento *ptPessoaDocumento)
{
    ULOG_START("CPessoaDocumentopc::proCApagaPessoaDocumento");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoa[LEN_IDPESSOADOCUMENTO];
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro;

    STRCPY_TO_ORA(oszIdPessoa, ptPessoaDocumento->szIdPessoa);

    EXEC SQL DELETE
        FROM Customer.PessoaDocumento
        WHERE idpessoa = TO_NUMBER(:oszIdPessoa);

    ULOGI("Finalizando proCApagaPessoaDocumento <OK>");
    ULOG_END("CPessoaDocumentopc::proCApagaPessoaDocumento");
    return;

    erro:
        ULOGE("Finalizando proCApagaPessoaDocumento <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/**************************************************************************************/
void CPessoaDocumentopc::proCInserePessoaDocumento(TPessoaDocumento *ptPessoaDocumento)
{
   ULOG_START("CPessoaDocumentopc::proCInserePessoaDocumento");

   EXEC SQL BEGIN DECLARE SECTION;
      VARCHAR oszIdPessoaDocumento[LEN_IDPESSOADOCUMENTO];
      VARCHAR oszIdPessoa[LEN_IDPESSOA];
      VARCHAR oszIdDocumento[LEN_IDDOCUMENTO];
      VARCHAR oszTsSincronismo[LEN_TSSINCRONISMO];
      VARCHAR oszSqSincronismo[LEN_SQSINCRONISMO];
      VARCHAR oszIdSistemaOrigem[LEN_IDSISTEMAORIGEM];
      VARCHAR oszIdDocumentoSistemaOrigem[LEN_IDDOCUMENTOSISTEMAORIGEM];
      VARCHAR oszDtExpiracao[LEN_DTEXPIRACAO];
      VARCHAR oszIdUsuarioAlteracao[LEN_IDUSUARIOALTERACAO];
   EXEC SQL END DECLARE SECTION;

   struct sqlca sqlca;

   /* copia os valores da estrutura para as variaveis ProC */
   STRCPY_TO_ORA(oszIdPessoa, ptPessoaDocumento->szIdPessoa);
   STRCPY_TO_ORA(oszIdDocumento, ptPessoaDocumento->szIdDocumento);
   STRCPY_TO_ORA(oszTsSincronismo, ptPessoaDocumento->szTsSincronismo);
   STRCPY_TO_ORA(oszSqSincronismo, ptPessoaDocumento->szSqSincronismo);
   STRCPY_TO_ORA(oszIdSistemaOrigem, ptPessoaDocumento->szIdSistemaOrigem);
   STRCPY_TO_ORA(oszDtExpiracao, ptPessoaDocumento->szDtExpiracao);
   STRCPY_TO_ORA(oszIdUsuarioAlteracao, ptPessoaDocumento->szIdUsuarioAlteracao);

   EXEC SQL WHENEVER SQLERROR goto erro;

   EXEC SQL SELECT customer.pessoadocumentosq.nextval INTO :oszIdPessoaDocumento FROM DUAL;

   STRCPY_FROM_ORA(ptPessoaDocumento->szIdPessoaDocumento, oszIdPessoaDocumento);
   STRCPY_TO_ORA(oszIdDocumentoSistemaOrigem, ptPessoaDocumento->szIdPessoaDocumento);

    /* Chamado 20069232 -----------------------------------------------
    EXEC SQL INSERT INTO Customer.PessoaDocumento
                       ( idpessoadocumento
                       , idpessoa
                       , iddocumento
                       , tssincronismo
                       , sqsincronismo
                       , idsistemaorigem
                       , iddocumentosistemaorigem
                       , idusuarioalteracao
                       , dtultimaalteracao )
                VALUES ( :oszIdPessoaDocumento
                       , :oszIdPessoa
                       , :oszIdDocumento
                       , :oszTsSincronismo
                       , :oszSqSincronismo
                       , :oszIdSistemaOrigem
                       , :oszIdDocumentoSistemaOrigem
                       , :oszIdUsuarioAlteracao
                       , SYSDATE);
    */
    
   ULOG( "*** Vai atualizar Customer.PessoaDocumento" );
   
   ULOG( "*** oszIdPessoa    [%s]", (char*)oszIdPessoa.arr );
   ULOG( "*** oszIdDocumento [%s]", (char*)oszIdDocumento.arr );
   
   EXEC SQL
   UPDATE Customer.PessoaDocumento
   SET 
     tssincronismo = :oszTsSincronismo
   , idpessoadocumento = :oszIdPessoaDocumento
   , sqsincronismo = :oszSqSincronismo
   , idsistemaorigem = :oszIdSistemaOrigem
   , iddocumentosistemaorigem = :oszIdDocumentoSistemaOrigem
   , idusuarioalteracao = :oszIdUsuarioAlteracao
   , dtultimaalteracao = sysdate
   WHERE
   idpessoa = :oszIdPessoa
   AND iddocumento = :oszIdDocumento ;

   ULOG( "@@@ Linhas afetadas [%d]", sqlca.sqlerrd[2] );
   if( sqlca.sqlerrd[2] == 0 )
   {
   
      EXEC SQL
      UPDATE Customer.PessoaDocumento
      SET 
        tssincronismo      = :oszTsSincronismo
      , idpessoadocumento = :oszIdPessoaDocumento
      , sqsincronismo      = :oszSqSincronismo
      , idsistemaorigem    = :oszIdSistemaOrigem
      , iddocumento        = :oszIdDocumento
      , idusuarioalteracao = :oszIdUsuarioAlteracao
      , dtultimaalteracao  = sysdate
      WHERE
        idpessoa = :oszIdPessoa
      AND iddocumentosistemaorigem = :oszIdDocumentoSistemaOrigem ;
      
      ULOG( "&&& Linhas afetadas [%d]", sqlca.sqlerrd[2] );
      if( sqlca.sqlerrd[2] == 0 )
      {
         ULOG( "*** Inserindo em Customer.PessoaDocumento" );
         
         //EXEC SQL SELECT customer.pessoadocumentosq.nextval INTO :oszIdPessoaDocumento FROM DUAL;
         
         EXEC SQL 
         INSERT INTO Customer.PessoaDocumento
         ( 
              idpessoadocumento
            , idpessoa
            , iddocumento
            , tssincronismo
            , sqsincronismo
            , idsistemaorigem
            , iddocumentosistemaorigem
            , idusuarioalteracao
            , dtultimaalteracao 
         )
         VALUES 
         ( 
              :oszIdPessoaDocumento
            , :oszIdPessoa
            , :oszIdDocumento
            , :oszTsSincronismo
            , :oszSqSincronismo
            , :oszIdSistemaOrigem
            , :oszIdDocumentoSistemaOrigem
            , :oszIdUsuarioAlteracao
            , SYSDATE
         );
      }
   }

   ULOGI("Finalizando proCInserePessoaDocumento <OK>");
   ULOG_END("CPessoaDocumentopc::proCInserePessoaDocumento");
   return;

   erro:
     ULOGE("Finalizando proCInserePessoaDocumento <ERROR>");
     throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

/**************************************************************************************/
void CPessoaDocumentopc::proCAtualizaPessoaDocumento(TPessoaDocumento tPessoaDocumento)
{
    ULOG_START("CPessoaDocumentopc::proCAtualizaPessoaDocumento");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoaDocumento[LEN_IDPESSOADOCUMENTO];
        VARCHAR oszIdDocumento[LEN_IDDOCUMENTO];
        VARCHAR oszIdUsuarioAlteracao[LEN_IDUSUARIOALTERACAO];
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;


    STRCPY_TO_ORA(oszIdPessoaDocumento, tPessoaDocumento.szIdPessoaDocumento);
    STRCPY_TO_ORA(oszIdDocumento, tPessoaDocumento.szIdDocumento);
    STRCPY_TO_ORA(oszIdUsuarioAlteracao, tPessoaDocumento.szIdUsuarioAlteracao);

    EXEC SQL WHENEVER SQLERROR goto erro;


    EXEC SQL UPDATE Customer.PessoaDocumento
                SET
                    iddocumento              = TO_NUMBER(:oszIdDocumento)
                  , idusuarioalteracao       = TO_NUMBER(:oszIdUsuarioAlteracao)
                  , dtultimaalteracao        = SYSDATE
              WHERE idpessoadocumento        = TO_NUMBER(:oszIdPessoaDocumento);

    ULOGI("Finalizando proCAtualizaPessoaDocumento <OK>");
    ULOG_END("CPessoaDocumentopc::proCAtualizaPessoaDocumento");
    return;

    erro:
        ULOGE("Finalizando proCAtualizaPessoaDocumento <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/**************************************************************************************/
bool CPessoaDocumentopc::proCBuscaPessoaDocumento(TPessoaDocumento *ptPessoaDocumento)
{
    ULOG_START("CPessoaDocumentopc::proCBuscaPessoaDocumento");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoaDocumento[LEN_IDPESSOADOCUMENTO];
        VARCHAR oszIdPessoa[LEN_IDPESSOA];
        VARCHAR oszIdDocumento[LEN_IDDOCUMENTO];
        VARCHAR oszTsSincronismo[LEN_TSSINCRONISMO];
        VARCHAR oszSqSincronismo[LEN_SQSINCRONISMO];
        VARCHAR oszIdSistemaOrigem[LEN_IDSISTEMAORIGEM];
        VARCHAR oszIdDocumentoSistemaOrigem[LEN_IDDOCUMENTOSISTEMAORIGEM];
        VARCHAR oszDtExpiracao[LEN_DTEXPIRACAO];

        short iIdPessoaDocumento = 0;
        short iIdPessoa = 0;
        short iIdDocumento = 0;
        short iTsSincronismo = 0;
        short iSqSincronismo = 0;
        short iIdSistemaOrigem = 0;
        short iIdDocumentoSistemaOrigem = 0;
        short iDtExpiracao = 0;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    STRCPY_TO_ORA(oszIdPessoa, ptPessoaDocumento->szIdPessoa);
    STRCPY_TO_ORA(oszIdPessoaDocumento, ptPessoaDocumento->szIdPessoaDocumento);

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    EXEC SQL SELECT TO_CHAR(idpessoadocumento)
                  , TO_CHAR(idpessoa)
                  , TO_CHAR(iddocumento)
                  , TO_CHAR(tssincronismo)
                  , TO_CHAR(sqsincronismo)
                  , TO_CHAR(idsistemaorigem)
                  , iddocumentosistemaorigem
                  , TO_CHAR(dtexpiracao, 'DD/MM/YYYY')
               INTO :oszIdPessoaDocumento:iIdPessoaDocumento
                  , :oszIdPessoa:iIdPessoa
                  , :oszIdDocumento:iIdDocumento
                  , :oszTsSincronismo:iTsSincronismo
                  , :oszSqSincronismo:iSqSincronismo
                  , :oszIdSistemaOrigem:iIdSistemaOrigem
                  , :oszIdDocumentoSistemaOrigem:iIdDocumentoSistemaOrigem
                  , :oszDtExpiracao:iDtExpiracao
               FROM Customer.PessoaDocumento
              WHERE customer.pessoadocumento.rowid = ( SELECT min(customer.pessoadocumento.rowid)
                                                         FROM customer.pessoadocumento
                                                            , customer.documento
                                                        WHERE customer.pessoadocumento.iddocumento = customer.documento.iddocumento
                                                          AND idtipodocumento = TO_NUMBER(:oszIdPessoaDocumento)
                                                          AND idpessoa = TO_NUMBER(:oszIdPessoa) )
                AND NVL(dtexpiracao,SYSDATE) >= SYSDATE;


    if(iIdPessoaDocumento != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumento->szIdPessoaDocumento, oszIdPessoaDocumento);
    }

    if(iIdPessoa != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumento->szIdPessoa, oszIdPessoa);
    }

    if(iIdDocumento != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumento->szIdDocumento, oszIdDocumento);
    }

    if(iTsSincronismo != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumento->szTsSincronismo, oszTsSincronismo);
    }

    if(iSqSincronismo != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumento->szSqSincronismo, oszSqSincronismo);
    }

    if(iIdSistemaOrigem != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumento->szIdSistemaOrigem, oszIdSistemaOrigem);
    }

    if(iIdDocumentoSistemaOrigem != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumento->szIdDocumentoSistemaOrigem, oszIdDocumentoSistemaOrigem);
    }

    if(iDtExpiracao != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumento->szDtExpiracao, oszDtExpiracao);
    }


    ULOGI("Finalizando proCBuscaPessoaDocumento <OK>");
    ULOG_END("CPessoaDocumentopc::proCBuscaPessoaDocumento");
    return true;

    naoexiste:
        ULOGI("Finalizando proCBuscaPessoaDocumento <NOT FOUND>");
        ULOG_END("CPessoaDocumentopc::proCBuscaPessoaDocumento");
        return false;

    erro:
        ULOGI("Finalizando proCBuscaPessoaDocumento <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/**************************************************************************************/
bool CPessoaDocumentopc::proCBuscaPessoaPessoaDocumento(const char *nrDocumento
                                                       ,const char *idTipoDocumento
                                                       ,const char *nmNome
                                                       ,const char *nmNomeMeio
                                                       ,const char *nmSobreNome
                                                       ,char *idPessoa)
{
    ULOG_START("CPessoaDocumentopc::proCBuscaPessoaPessoaDocumento");

    EXEC SQL BEGIN DECLARE SECTION;
        const char *varOraNrDocumento = nrDocumento;
        const char *varOraIdTipoDocumento = idTipoDocumento;
        const char *varOraNmNome = nmNome;
        const char *varOraNmNomeMeio = nmNomeMeio;
        const char *varOraNmSobreNome = nmSobreNome;

        short statOraNmNome = *varOraNmNome==0?-1:1;
        short statOraNmNomeMeio = *varOraNmNomeMeio==0?-1:1;
        short statOraNmSobreNome = *varOraNmSobreNome==0?-1:1;

        VARCHAR oszIdPessoa[39];
        short iIdPessoa=-1;

    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    ULOG("    nrDocumento=%s",varOraNrDocumento);
    ULOG("idTipoDocumento=%s",varOraIdTipoDocumento);
    ULOG("         nmNome=%d:%s",statOraNmNome,varOraNmNome);
    ULOG("     nmNomeMeio=%d:%s",statOraNmNomeMeio,varOraNmNomeMeio);
    ULOG("    nmSobreNome=%d:%s",statOraNmSobreNome,varOraNmSobreNome);

    EXEC SQL SELECT idPessoa
             INTO :oszIdPessoa:iIdPessoa
             FROM
             (
                 SELECT Pessoa.idPessoa
                   FROM Customer.PessoaDocumento PessoaDocumento,
                        Customer.Documento Documento,
                        Customer.Pessoa Pessoa
                  WHERE PessoaDocumento.idDocumento = Documento.IdDocumento
                  AND Documento.idTipoDocumento = :varOraIdTipoDocumento
                  AND Documento.nrDocumento = :varOraNrDocumento
                  AND PessoaDocumento.idPessoa = Pessoa.idPessoa
                  AND PessoaDocumento.dtExpiracao IS NULL
                  AND NVL(Pessoa.nmNome,'') = DECODE(:statOraNmNome,1,:varOraNmNome,NVL(Pessoa.nmNome,''))
                  AND NVL(Pessoa.nmNomeMeio,'') = DECODE(:statOraNmNomeMeio,1,:varOraNmNomeMeio,NVL(Pessoa.nmNomeMeio,''))
                  AND NVL(Pessoa.nmSobreNome,'') = DECODE(:statOraNmSobreNome,1,:varOraNmSobreNome,NVL(Pessoa.nmSobreNome,''))
                  ORDER BY
                    Pessoa.dtCadastro DESC
             )
             WHERE
                ROWNUM < 2;

    if(iIdPessoa != -1) {
        STRCPY_FROM_ORA(idPessoa,oszIdPessoa);
    }

    ULOGI("Finalizando proCBuscaPessoaPessoaDocumento <OK>");
    ULOG_END("CPessoaDocumentopc::proCBuscaPessoaPessoaDocumento");
    return true;

    naoexiste:
        ULOGI("Finalizando proCBuscaPessoaPessoaDocumento <NOT FOUND>");
        ULOG_END("CPessoaDocumentopc::proCBuscaPessoaPessoaDocumento");
        return false;

    erro:
        ULOGI("Finalizando proCBuscaPessoaPessoaDocumento <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/**************************************************************************************/
void CPessoaDocumentopc::proCApagaPessoaDocumentoEspecifico(const char *idDocumento,const char *idPessoa)
{
    ULOG_START("CPessoaDocumentopc::proCApagaPessoaDocumentoEspecifico");

    EXEC SQL BEGIN DECLARE SECTION;
        const char *varOraIdDocumento = idDocumento;
        const char *varOraIdPessoa = idPessoa;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    ULOG("nrDocumento=%s",varOraIdDocumento);
    ULOG("   idPessoa=%s",varOraIdPessoa);

    EXEC SQL
        DELETE FROM CUSTOMER.PESSOADOCUMENTO
        WHERE
            IDDOCUMENTO = :varOraIdDocumento
        AND IDPESSOA = :varOraIdPessoa;

    ULOGI("Finalizando proCApagaPessoaDocumentoEspecifico <OK>");
    ULOG_END("CPessoaDocumentopc::proCApagaPessoaDocumentoEspecifico");
    return;

    erro:
        ULOGE("Finalizando proCApagaPessoaDocumentoEspecifico <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/**************************************************************************************/
bool CPessoaDocumentopc::proCExistePessoaDocumento(const char *idDocumento,const char *idPessoa)
{
    ULOG_START("CPessoaDocumentopc::proCExistePessoaDocumento");

    EXEC SQL BEGIN DECLARE SECTION;
        const char *varOraIdDocumento = idDocumento;
        const char *varOraIdPessoa = idPessoa;
        
        int varOraCount;

    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    ULOG("nrDocumento=%s",varOraIdDocumento);
    ULOG("   idPessoa=%s",varOraIdPessoa);

    EXEC SQL
        SELECT
            COUNT(1)
        INTO
            :varOraCount
        FROM
            CUSTOMER.PESSOADOCUMENTO
        WHERE
            IDDOCUMENTO = :varOraIdDocumento
        AND IDPESSOA = :varOraIdPessoa;

    ULOG("count=%d",varOraCount);

    ULOGI("Finalizando proCExistePessoaDocumento <OK>");
    ULOG_END("CPessoaDocumentopc::proCExistePessoaDocumento");

    return varOraCount>0?true:false;

    erro:
        ULOGI("Finalizando proCExistePessoaDocumento <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}
