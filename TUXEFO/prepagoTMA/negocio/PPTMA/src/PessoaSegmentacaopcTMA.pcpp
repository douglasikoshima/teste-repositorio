///////////////////////////////////////////////////////////////////////////////
/**
 *
 * 33374 – Modelo Atendimento Futuro PF e PJ Fixa e Móvel - Marcação Cliente Segmentada
 *    Criação do metodo CPessoaSegmentacaopc::proCClassificaInfancia
 *    Agosto/2015
 *
 **/
 
 
///////////////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>

#include "tuxfw.h"
#include "PessoaSegmentacaopcTMA.h"
#include <string>

using namespace std;

#define CONVIND(O,I) \
{ \
	if (I == -1) { \
		##O.arr[0]=0; \
	} else { \
		##O.arr[##O.len]=0; \
	} \
}


#define endOraStr(varstr)      varstr.arr[varstr.len] = 0x0;

EXEC SQL BEGIN DECLARE SECTION;
#include "PPGlobalTMA.h"
EXEC SQL END DECLARE SECTION;

/********************************************************************************/
void CPessoaSegmentacaopc::proCAtualizaPessoaSegmentacao(TPessoaSegmentacao *ptPessoaSegmentacao)
{
    ULOG_START("CPessoaSegmentacaopc::proCAtualizaPessoaSegmentacao");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoaDePara[LEN_IDPESSOADEPARA];
        VARCHAR oszIdPessoaSegmentacao[LEN_IDPESSOASEGMENTACAO];
        VARCHAR oszIdUsuarioAlteracao[LEN_IDUSUARIOALTERACAO];
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro;

    STRCPY_TO_ORA(oszIdPessoaDePara, ptPessoaSegmentacao->szIdPessoaDePara);
    STRCPY_TO_ORA(oszIdPessoaSegmentacao, ptPessoaSegmentacao->szIdPessoaSegmentacao);
    STRCPY_TO_ORA(oszIdUsuarioAlteracao, ptPessoaSegmentacao->szIdUsuarioAlteracao);


    EXEC SQL UPDATE Customer.PessoaSegmentacao
        SET      idpessoadepara       = :oszIdPessoaDePara
               , idpessoasegmentacao  = :oszIdPessoaSegmentacao
               , idusuarioalteracao   = :oszIdUsuarioAlteracao
               , dtultimaalteracao    = SYSDATE
        WHERE    idpessoadepara       = TO_NUMBER(:oszIdPessoaDePara);

    ULOGI("Finalizando proCAtualizaPessoaSegmentacao <OK>");
    ULOG_END("CPessoaSegmentacaopc::proCAtualizaPessoaSegmentacao");
    return;

    erro:
        ULOGE("Finalizando proCAtualizaPessoaSegmentacao <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}
 
/********************************************************************************/
void CPessoaSegmentacaopc::proCInserePessoaSegmentacao(TPessoaSegmentacao *ptPessoaSegmentacao)
{
    ULOG_START("CPessoaSegmentacaopc::proCInserePessoaSegmentacao");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoaDePara[LEN_IDPESSOADEPARA];
        VARCHAR oszIdPessoaSegmentacao[LEN_IDPESSOASEGMENTACAO];
        VARCHAR oszIdUsuarioAlteracao[LEN_IDUSUARIOALTERACAO];
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro;

    STRCPY_TO_ORA(oszIdPessoaDePara, ptPessoaSegmentacao->szIdPessoaDePara);
    STRCPY_TO_ORA(oszIdPessoaSegmentacao, ptPessoaSegmentacao->szIdPessoaSegmentacao);
    STRCPY_TO_ORA(oszIdUsuarioAlteracao, ptPessoaSegmentacao->szIdUsuarioAlteracao);


    EXEC SQL INSERT INTO customer.pessoasegmentacao
                       ( idpessoadepara
                       , idpessoasegmentacao
                       , idusuarioalteracao
                       , dtultimaalteracao)
                VALUES ( :oszIdPessoaDePara
                       , :oszIdPessoaSegmentacao
                       , :oszIdUsuarioAlteracao
                       , SYSDATE );

    ULOGI("Finalizando proCInserePessoaSegmentacao <OK>");
    ULOG_END("CPessoaSegmentacaopc::proCInserePessoaSegmentacao");
    return;

    erro:
        ULOGE("Finalizando proCInserePessoaSegmentacao <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}
 
/********************************************************************************/
bool CPessoaSegmentacaopc::proCBuscaPessoaSegmentacao(TPessoaSegmentacao *ptPessoaSegmentacao)
{
    ULOG_START("CPessoaSegmentacaopc::proCBuscaPessoaSegmentacao");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoaDePara[LEN_IDPESSOADEPARA];
        VARCHAR oszIdPessoaSegmentacao[LEN_IDPESSOASEGMENTACAO];
        VARCHAR oszIdUsuarioAlteracao[LEN_IDUSUARIOALTERACAO];
        VARCHAR oszDtUltimaAlteracao[LEN_DTULTIMAALTERACAO];

        short iIdPessoaDePara = 0;
        short iIdPessoaSegmentacao = 0;
        short iIdUsuarioAlteracao = 0;
        short iDtUltimaAlteracao = 0;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    STRCPY_TO_ORA(oszIdPessoaDePara, ptPessoaSegmentacao->szIdPessoaDePara);

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    EXEC SQL SELECT TO_CHAR( idpessoadepara       )
                  , TO_CHAR( idpessoasegmentacao  )
                  , TO_CHAR( idusuarioalteracao   )
                  , TO_CHAR( dtultimaalteracao    , 'DD/MM/YYYY')
               INTO :oszIdPessoaDePara:iIdPessoaDePara
                  , :oszIdPessoaSegmentacao:iIdPessoaSegmentacao
                  , :oszIdUsuarioAlteracao:iIdUsuarioAlteracao
                  , :oszDtUltimaAlteracao:iDtUltimaAlteracao
               FROM Customer.PessoaSegmentacao
              WHERE idpessoadepara = TO_NUMBER( :oszIdPessoaDePara );


    if( iIdPessoaDePara != -1 ) {
        STRCPY_FROM_ORA(ptPessoaSegmentacao->szIdPessoaDePara, oszIdPessoaDePara);
    }
    if( iIdPessoaSegmentacao != -1 ) {
        STRCPY_FROM_ORA(ptPessoaSegmentacao->szIdPessoaSegmentacao, oszIdPessoaSegmentacao);
    }
    if( iIdUsuarioAlteracao != -1 ) {
        STRCPY_FROM_ORA(ptPessoaSegmentacao->szIdUsuarioAlteracao, oszIdUsuarioAlteracao);
    }
    if( iDtUltimaAlteracao != -1 ) {
        STRCPY_FROM_ORA(ptPessoaSegmentacao->szDtUltimaAlteracao, oszDtUltimaAlteracao);
    }

    ULOGI("Finalizando proCBuscaPessoaSegmentacao <FOUND>");
    ULOG_END("CPessoaSegmentacaopc::proCBuscaPessoaSegmentacao");
    return true;

    naoexiste:
        ULOGI("Finalizando proCBuscaPessoaSegmentacao <NOT FOUND>");
        ULOG_END("CPessoaSegmentacaopc::proCBuscaPessoaSegmentacao");
        return false;

    erro:
        ULOGE("Finalizando proCBuscaPessoaSegmentacao <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}



bool CPessoaSegmentacaopc::proCClassificaInfancia( char * vi_idLinhaTelefonica, char * vi_idPessoa , char * vi_idTipoPessoa )
{
    ULOG_START( "CPessoaSegmentacaopc::proCClassificaInfancia" );

    string stmt;
    char buffer[256];
    
    EXEC SQL BEGIN DECLARE SECTION;
        char * query;
        char idLinhaTelefonica[256];
        char idPessoa[256];
        char idTipoPessoa[3];
        char sProcedure[256];
        
        VARCHAR idServico[256];
        short i_idServico = -1;
        VARCHAR dtAlteracaoPlano[32];
        short i_dtAlteracaoPlano = -1;
        VARCHAR flgServico[256];
        short i_flgServico = -1;

        VARCHAR  O_CDERRO[256];
        VARCHAR  O_DSERRO[1024];
    
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    sprintf( idLinhaTelefonica, "%s", vi_idLinhaTelefonica );
    sprintf( idPessoa         , "%s", vi_idPessoa );
    sprintf( idTipoPessoa     , "%s", vi_idTipoPessoa );
    
    memset( &idServico       , 0x0, sizeof(idServico) );
    memset( &dtAlteracaoPlano, 0x0, sizeof(dtAlteracaoPlano) );
    memset( &flgServico      , 0x0, sizeof(flgServico) );
    
    memset( &O_CDERRO, 0x0, sizeof(O_CDERRO));
    memset( &O_DSERRO, 0x0, sizeof(O_DSERRO));
    
    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

/*     EXEC SQL 
    SELECT 
       IDSERVICO ,
       TO_CHAR( DTULTIMAALTERACAO , 'DD/MM/YYYY HH24:MI:SS' )
    INTO
       :idServico:i_idServico ,
       :dtAlteracaoPlano:i_dtAlteracaoPlano
    FROM 
    (
        SELECT PLANOSERVICO.IDSERVICO, PLANOSERVICOLINHA.DTULTIMAALTERACAO,
        DENSE_RANK () over (partition by PLANOSERVICOLINHA.IDSERVICO order by PLANOSERVICOLINHA.DTVIGENCIAINICIO desc, IDSERVICOLINHA desc) As last_date
        FROM LINHA.PLANOSERVICO PLANOSERVICO, LINHA.PLANOSERVICOLINHA PLANOSERVICOLINHA
        WHERE 
            PLANOSERVICOLINHA.IDLINHATELEFONICA = :idLinhaTelefonica
        AND PLANOSERVICOLINHA.IDSERVICO = PLANOSERVICO.IDSERVICO
        AND (PLANOSERVICOLINHA.DTVIGENCIAINICIO IS NOT NULL OR TRUNC(PLANOSERVICOLINHA.DTVIGENCIAINICIO) <= TRUNC(SYSDATE))
        AND (PLANOSERVICOLINHA.DTVIGENCIAFINAL IS NULL OR TRUNC(PLANOSERVICOLINHA.DTVIGENCIAFINAL) >= TRUNC(SYSDATE))
        AND (PLANOSERVICOLINHA.DTEXPIRACAO IS NULL OR (PLANOSERVICOLINHA.DTEXPIRACAO IS NOT NULL AND TRUNC(PLANOSERVICOLINHA.DTEXPIRACAO) >= TRUNC(SYSDATE)))
    ) WHERE Last_date = 1 AND ROWNUM < 2;
 */    
 
     stmt =
    " SELECT "
      " IDSERVICO , "
      " TO_CHAR( DTULTIMAALTERACAO , 'DD/MM/YYYY HH24:MI:SS' ) "
    " FROM "
    " ( "
       " SELECT PLANOSERVICO.IDSERVICO, PLANOSERVICOLINHA.DTULTIMAALTERACAO, "
       " DENSE_RANK () over (partition by PLANOSERVICOLINHA.IDSERVICO order by PLANOSERVICOLINHA.DTVIGENCIAINICIO desc, IDSERVICOLINHA desc) As last_date "
       " FROM LINHA.PLANOSERVICO PLANOSERVICO, LINHA.PLANOSERVICOLINHA PLANOSERVICOLINHA "
       " WHERE " ;
    
    sprintf( buffer, "     PLANOSERVICOLINHA.IDLINHATELEFONICA = %s ", idLinhaTelefonica );
    
    stmt += buffer ;
    
    stmt +=
       " AND PLANOSERVICOLINHA.IDSERVICO = PLANOSERVICO.IDSERVICO "
       " AND (PLANOSERVICOLINHA.DTVIGENCIAINICIO IS NOT NULL OR TRUNC(PLANOSERVICOLINHA.DTVIGENCIAINICIO) <= TRUNC(SYSDATE)) "
       " AND (PLANOSERVICOLINHA.DTVIGENCIAFINAL IS NULL OR TRUNC(PLANOSERVICOLINHA.DTVIGENCIAFINAL) >= TRUNC(SYSDATE)) "
       " AND (PLANOSERVICOLINHA.DTEXPIRACAO IS NULL OR (PLANOSERVICOLINHA.DTEXPIRACAO IS NOT NULL AND TRUNC(PLANOSERVICOLINHA.DTEXPIRACAO) >= TRUNC(SYSDATE))) "
    " ) WHERE Last_date = 1 AND ROWNUM < 2 ";

    query = (char *)stmt.c_str();

    ULOG( "Executando [%s]", query );

    EXEC SQL PREPARE CnsServico FROM :query;
    EXEC SQL DECLARE crsServico CURSOR FOR CnsServico;

    EXEC SQL OPEN crsServico;
    for ( ;; )
    {
        EXEC SQL FETCH crsServico into 
           :idServico:i_idServico ,
           :dtAlteracaoPlano:i_dtAlteracaoPlano ;

        CONVIND( idServico, i_idServico );
        CONVIND( dtAlteracaoPlano, i_dtAlteracaoPlano );
        
    }
    EXEC SQL CLOSE crsServico;
     
 
    //sprintf( sProcedure, "BEGIN ATENDIMENTO.BUSCAIDSERVICO( %s, :idServico, :dtAlteracaoPlano, :O_CDERRO, :O_DSERRO ); END; ", idLinhaTelefonica );
    
    //ULOG( "Executando PLSQL [%s] " , sProcedure );
    
    //EXEC SQL PREPARE CALLPROC FROM :sProcedure;
    //EXEC SQL EXECUTE CALLPROC USING :idServico , :dtAlteracaoPlano , :O_CDERRO, :O_DSERRO;
    
    //endOraStr( idServico );
    //endOraStr( dtAlteracaoPlano );
    //endOraStr( O_CDERRO );
    //endOraStr( O_DSERRO );

    ULOG( "*** idServico        [%s]" , (char*)idServico.arr );
    ULOG( "*** dtAlteracaoPlano [%s]" , (char*)dtAlteracaoPlano.arr );
    //ULOG( "*** O_CDERRO         [%s]" , (char*)O_CDERRO.arr );
    //ULOG( "*** O_DSERRO         [%s]" , (char*)O_DSERRO.arr );
    
    if( idServico.arr[0] == 0x0 ) 
    {
        ULOGI("IDLINHATELEFONICA [%s] - Nao foi encontrado relacionamento entre LINHA.PLANOSERVICO e LINHA.PLANOSERVICOLINHA", idLinhaTelefonica );
        ULOG_END("CPessoaSegmentacaopc::proCClassificaInfancia");
        return false;
    }
    
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    
    EXEC SQL
    SELECT 1 INTO :flgServico:i_flgServico FROM LINHA.PLANOSERVICOSUBSEGMENTO WHERE IDSERVICO = :idServico ;
    CONVIND( flgServico,i_flgServico );
    ULOG( "*** flgServico        [%s]" , (char*)flgServico.arr );
    ULOG( "*** flgServico        [%d]" , i_flgServico );
    if( i_flgServico < 0 ) 
    {
        ULOGI("IDSERVICO [%s] nao encontrado em LINHA.PLANOSERVICOSUBSEGMENTO", (char *)idServico.arr );
        ULOG_END("CPessoaSegmentacaopc::proCClassificaInfancia");
        return false;
    }

    ULOG( "@@@ Atualizando LINHA.PLANOSERVLINHAPESSOASUBSEG" );
    EXEC SQL
    UPDATE LINHA.PLANOSERVLINHAPESSOASUBSEG
    SET IDPESSOA = :idPessoa ,
        IDTIPOPESSOA = :idTipoPessoa ,
        DTULTIMAALTERACAOPLANO = TO_DATE( :dtAlteracaoPlano , 'DD/MM/YYYY HH24:MI:SS' )
    WHERE
        IDLINHATELEFONICA = :idLinhaTelefonica
    AND IDSERVICO = :idServico ;
    
    if( sqlca.sqlerrd[2] == 0 )
    {
        ULOG( "*** Vai inserir em LINHA.PLANOSERVLINHAPESSOASUBSEG" );
        EXEC SQL
        INSERT INTO LINHA.PLANOSERVLINHAPESSOASUBSEG
        (
            IDPLANOSERVLINHAPESSOASUBSEG ,
            IDLINHATELEFONICA ,
            IDPESSOA ,
            IDTIPOPESSOA ,
            IDSERVICO ,
            DTULTIMAALTERACAOPLANO ,
            IDUSUARIOALTERACAO ,
            DTULTIMAALTERACAO 
        )
        VALUES
        (
            LINHA.PLANOSERVLINHAPESSOASUBSEGSQ.NEXTVAL ,
            :idLinhaTelefonica ,
            :idPessoa ,
            :idTipoPessoa ,
            :idServico ,
            TO_DATE( :dtAlteracaoPlano , 'DD/MM/YYYY HH24:MI:SS' ) ,
            1 ,
            SYSDATE
        );
    }

    ULOGI("Finalizando proCClassificaInfancia <FOUND>");
    ULOG_END("CPessoaSegmentacaopc::proCClassificaInfancia");
    return true;

    erro:
        ULOGE("Finalizando proCClassificaInfancia <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}
