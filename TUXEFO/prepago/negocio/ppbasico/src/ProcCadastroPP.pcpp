
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <iostream.h>
#include <unistd.h>
#include <ctype.h>
#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

#include <tuxfw.h>


#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

EXEC SQL BEGIN DECLARE SECTION;
#include "Global.h"
EXEC SQL END DECLARE SECTION;

#define SAFE_STRNCPY(dst,src) strncpy(dst,src?src:"",sizeof(dst)-1);dst[sizeof(dst)-1]=0;

#define CONVIND(O,I) \
{\
    if (I == -1) { \
        ##O.arr[0]=0; \
    } else { \
        ##O.arr[##O.len]=0; \
    } \
}

//==============================================================================
// Protótipos
int sendXML(char *pXmlSaida, char *pRetMsg, long * iErrorNumber );
bool DeletaRegistro(char * pszIdFila );
bool AtualizaRegistro( char * pszIdFila, char * pszStatusCode, char * pszStatusText );
char *ObtemValorTag(char *pXml, char *pTag);
char *TrataErroNGIN(char *pStatusText);
char *replace( char *st, char *orig, char *repl );
void retira_apostrofe( char * bf );
bool RemoverRegistro( char * szIDLINHATELEFONICA );
bool IncrementaQTDTentativa( char * szIDLINHATELEFONICA, int iqtdTentativa );

int ProcCadastroPP( char * sIDOPERADORA, char * sNRLINHA, char * sNRDOCUMENTO, char * sNMPESSOA, char * sSGPLANO, char * sPROCEDURE, char * szIDLINHATELEFONICA, char * szINQTDTENTATIVA  )
{
    ULOG_START( "ProcCadastroPP()" );
   
    char szRetMsg[4000 + 1];
	char szO_CDERRO[1000 + 1];
	char szO_DSERRO[1000 + 1];
	
    char szStatusCode[255 + 1];
    char szStatusText[255 + 1];
    char szXml[8000 + 1];
    char szXmlTmp[8000 + 1];
    long iErrorNumber=0;
	char szAux[8000 + 1];

    ULOG(">>>EnviaLegado\n");

    struct sqlca sqlca;

    char *pc_statusCode = 0x0;
    char *pc_statusText = 0x0;
	char *pc_Msg = 0x0;
    TuxRemoteService* remoteService;
    TuxMessage* inputMessage;
    XMLGen oEntrada;
	
	int iSucesso = 1;

    /* reformata o XML para envio */
    /*
    memset(szXml, 0x00, sizeof(szXml));
    strcpy(szXml, "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>");
    strcat(szXml, "<msg><msgHdr><user>1</user><service>CADPP</service></msgHdr><msgBody>");
    strcat(szXml, szXmlTmp+5);
    szXml[strlen(szXml)-6]=0x00;
    strcat(szXml, "</msgBody></msg>");
    ULOG( "szXml [%s]", szXml );
    */
	
	sprintf(szXml, "<msg><PROCEDURE>%s</PROCEDURE>",sPROCEDURE);
	sprintf( szXmlTmp, "<IDOPERADORA>%s</IDOPERADORA>", sIDOPERADORA );strcat( szXml, szXmlTmp );
	sprintf( szXmlTmp, "<NRLINHA>%s</NRLINHA>", sNRLINHA );strcat( szXml, szXmlTmp );
	sprintf( szXmlTmp, "<NRDOCUMENTO>%s</NRDOCUMENTO>", sNRDOCUMENTO );strcat( szXml, szXmlTmp );
	sprintf( szXmlTmp, "<NMPESSOA>%s</NMPESSOA>", sNMPESSOA );strcat( szXml, szXmlTmp );
	sprintf( szXmlTmp, "<SGPLANO>%s</SGPLANO></msg>", sSGPLANO );strcat( szXml, szXmlTmp );	
	
	
	ULOG( "ENVIANDO Registro de Cadastro para o Programa de Pontos:" );
	
	ULOG("IDOPERADORA:[%s] ", sIDOPERADORA );
	ULOG("sNRLINHA:[%s] ", sNRLINHA );
	ULOG("sNRDOCUMENTO:[%s] ", sNRDOCUMENTO );
	ULOG("sNMPESSOA:[%s] ", sNMPESSOA );
	ULOG("sSGPLANO:[%s] ", sSGPLANO );
	ULOG("PROCEDURE:[%s] ", sPROCEDURE );
	
    ULOG( "szXml [%s]", szXml );
	
    oEntrada.aggregateXML(szXml);

    // Faz a solicitação ao serviço
    remoteService = new TuxRemoteService();
    inputMessage = new TuxMessage();
    inputMessage->setUser("FO");
    inputMessage->setService("CADPP");
    inputMessage->setMessageBody(&oEntrada);
    // Repassa configuracoes ao manipulador do serviço remoto e invoca o servico.
    remoteService->setServiceName("CADPP");
    remoteService->setInputMessage(inputMessage);

    if(remoteService->remoteCall() != TUXFWRET_OK)
    {
		ULOG( "ERRO. remoteService->remoteCall() != TUXFWRET_OK \n");
        delete remoteService;
        delete inputMessage;
		return -2;
    }

    memset( szStatusCode, 0x0, sizeof(szStatusCode) );
    memset( szStatusText, 0x0, sizeof(szStatusText) );

    pc_statusCode = remoteService->getOutputMessage()->getStatusCode();
    pc_statusText = remoteService->getOutputMessage()->getStatusText();
	pc_Msg = remoteService->getOutputMessage()->getMessageBody();

    if(pc_statusCode)
	{
        strcpy(szStatusCode, pc_statusCode);
		ULOG( "#szStatusCode[%s] \n", szStatusCode);

	}

    if(pc_statusText)
    {
        if(strlen(pc_statusText) >= sizeof(szStatusText))
            strncpy(szStatusText, pc_statusText, sizeof(szStatusText) - 1);
        else
            strcpy(szStatusText, pc_statusText);
		
		ULOG( "#szStatusText[%s] \n", szStatusText);
    }
	
	if ( szStatusCode[2] == 'I' )
	{
		if(pc_Msg)
		{
			if(strlen(pc_statusText) >= sizeof(szStatusText))
				strncpy(szStatusText, pc_statusText, sizeof(szStatusText) - 1);
			else
				strcpy(szStatusText, pc_statusText);
				
			memset( szO_CDERRO, 0x0, sizeof(szO_CDERRO) );			
			memset( szO_DSERRO, 0x0, sizeof(szO_DSERRO) );			
			
			try
			{
				SAFE_STRNCPY(szO_CDERRO,ObtemValorTag(pc_Msg, "O_CDERRO"));  	
				SAFE_STRNCPY(szO_DSERRO,ObtemValorTag(pc_Msg, "O_DSERRO")); 
				ULOG( "#szO_CDERRO[%s] \n", szO_CDERRO);
				ULOG( "#szO_DSERRO[%s] \n", szO_DSERRO);
			}
			catch(...)
			{
				ULOG( "#Erro tentanto ober O_CDERRO e O_DSERRO \n");
			}
			//strcpy(szMsg, pc_Msg);		
		}
		else
		{	
			ULOG( "ERRO. Serviço CADPP nao retornou xml com a TAG de MessageBody:IDOPERADORA:[%s], sNRLINHA:[%s], sNRDOCUMENTO:[%s], sNMPESSOA:[%s], sSGPLANO:[%s]\n", sIDOPERADORA, sNRLINHA, sNRDOCUMENTO, sNMPESSOA, sSGPLANO );
		}	
	}
	
    free(pc_statusCode);
    free(pc_statusText);
	free(pc_Msg);

    /*
    memset(szRetMsg, 0x00, sizeof(szRetMsg));
    sendXML( szXml, szRetMsg, &iErrorNumber );
    */
    

    /* Obtem os valores das tags de retorno do XML */    
    /*    SAFE_STRNCPY(szStatusCode,ObtemValorTag(szRetMsg, "statusCode"));    */
    ULOG( "statusCode=[%s]\n",szStatusCode );

    /*   SAFE_STRNCPY(szStatusText,ObtemValorTag(szRetMsg, "statusText"));   */
    ULOG( "statusText=[%s]\n",szStatusText );

    if ( szStatusCode[2] != 'I' )
    {
        iErrorNumber = TPESYSTEM;
    }
    
    if ( iErrorNumber )
    {
        //if ( 0 == szStatusCode[0] ) 
        //{
            switch (iErrorNumber) 
            {
                case TPEABORT     : strcpy(szStatusCode,"TPEABORT");strcpy(szStatusText,"TPEABORT"); break;
                case TPEBADDESC   : strcpy(szStatusCode,"TPEBADDESC");strcpy(szStatusText,"TPEBADDESC"); break;
                case TPEBLOCK     : strcpy(szStatusCode,"TPEBLOCK");strcpy(szStatusText,"TPEBLOCK"); break;
                case TPEINVAL     : strcpy(szStatusCode,"TPEINVAL");strcpy(szStatusText,"TPEINVAL"); break;
                case TPELIMIT     : strcpy(szStatusCode,"TPELIMIT");strcpy(szStatusText,"TPELIMIT"); break;
                case TPENOENT     : strcpy(szStatusCode,"TPENOENT");strcpy(szStatusText,"TPENOENT"); break;
                case TPEOS        : strcpy(szStatusCode,"TPEOS");strcpy(szStatusText,"TPEOS"); break;
                case TPEPERM      : strcpy(szStatusCode,"TPEPERM");strcpy(szStatusText,"TPEPERM"); break;
                case TPEPROTO     : strcpy(szStatusCode,"TPEPROTO");strcpy(szStatusText,"TPEPROTO"); break;
                case TPESVCERR    : strcpy(szStatusCode,"TPESVCERR");strcpy(szStatusText,"TPESVCERR"); break;
                case TPESVCFAIL   : strcpy(szStatusCode,"TPESVCFAIL");strcpy(szStatusText,"TPESVCFAIL"); break;
                case TPESYSTEM    : strcpy(szStatusCode,"TPESYSTEM");strcpy(szStatusText,"TPESYSTEM"); break;
                case TPETIME      : strcpy(szStatusCode,"TPETIME");strcpy(szStatusText,"TPETIME"); break;
                case TPETRAN      : strcpy(szStatusCode,"TPETRAN");strcpy(szStatusText,"TPETRAN"); break;
                case TPGOTSIG     : strcpy(szStatusCode,"TPGOTSIG");strcpy(szStatusText,"TPGOTSIG"); break;
                case TPERMERR     : strcpy(szStatusCode,"TPERMERR");strcpy(szStatusText,"TPERMERR"); break;
                case TPEITYPE     : strcpy(szStatusCode,"TPEITYPE");strcpy(szStatusText,"TPEITYPE"); break;
                case TPEOTYPE     : strcpy(szStatusCode,"TPEOTYPE");strcpy(szStatusText,"TPEOTYPE"); break;
                case TPERELEASE   : strcpy(szStatusCode,"TPERELEASE");strcpy(szStatusText,"TPERELEASE"); break;
                case TPEHAZARD    : strcpy(szStatusCode,"TPEHAZARD");strcpy(szStatusText,"TPEHAZARD"); break;
                case TPEHEURISTIC : strcpy(szStatusCode,"TPEHEURISTIC");strcpy(szStatusText,"TPEHEURISTIC"); break;
                case TPEEVENT     : strcpy(szStatusCode,"TPEEVENT");strcpy(szStatusText,"TPEEVENT"); break;
                case TPEMATCH     : strcpy(szStatusCode,"TPEMATCH");strcpy(szStatusText,"TPEMATCH"); break;
                case TPEDIAGNOSTIC: strcpy(szStatusCode,"TPEDIAGNOSTIC");strcpy(szStatusText,"TPEDIAGNOSTIC"); break;
                case TPEMIB       : strcpy(szStatusCode,"TPEMIB");strcpy(szStatusText,"TPEMIB"); break;
                default           : strcpy(szStatusCode,"ERRDESCONHECIDO");strcpy(szStatusText,"ERRDESCONHECIDO"); break;
            } // switch (iErrorNumber)
        //} // if ( 0 == szStatusCode[0] )
    }

    /* Se sucesso grava o XML em disco e apaga o registro */
    if(szStatusCode[2] == 'I' && 0 == iErrorNumber) 
	{
        ULOG( "szXml [%s] processado por CADPP!", szXml );
		int iO_CDERRO;
		try
		{
			iO_CDERRO = atoi(szO_CDERRO);
		}
		catch(...)
		{
		}
		
		if (iO_CDERRO != 0 )
		{
			ULOG( "O_CDERRO[%s]\n",szO_CDERRO );
			ULOG( "O_DSERRO[%s]\n",szO_DSERRO );
			ULOG( "ERRO no retorno de serviço CADPP: IDOPERADORA:[%s], sNRLINHA:[%s], sNRDOCUMENTO:[%s], sNMPESSOA:[%s], sSGPLANO:[%s]\n", sIDOPERADORA, sNRLINHA, sNRDOCUMENTO, sNMPESSOA, sSGPLANO );
			
				int iqtdTentativa;
				try
				{
					iqtdTentativa = atoi(szINQTDTENTATIVA);
					iqtdTentativa++;
					//Incrementar Registro
					ULOG( "Incrementando a Quantidade de Tentativa do registro para [%d]\n", iqtdTentativa );
					bool bIncrementar = IncrementaQTDTentativa( szIDLINHATELEFONICA, iqtdTentativa );
					if( bIncrementar == true)
					{
						ULOG( "SUCESSO no incremento da Quantidade de tentativas para[%d]\n", iqtdTentativa );
					}
					else
					{
						ULOG( "ERRO no incremento da Quantidade de tentativas para[%d]\n", iqtdTentativa );
						ULOG( "Finalizando processo...\n" );
						ULOG_END( "ProcCadastroPP()" );
						delete remoteService;
						delete inputMessage;
						return -2;
					}
				}
				catch(...)
				{
					ULOG( "ERRO tentando obter a quantidade de Tentativas[%s]\n",szINQTDTENTATIVA );
					ULOG( "Finalizando processo...\n" );
					ULOG_END( "ProcCadastroPP()" );
					delete remoteService;
					delete inputMessage;
					return -2;
				}
			
			ULOG( "Finalizando processo...\n" );
			ULOG_END( "ProcCadastroPP()" );
			delete remoteService;
			delete inputMessage;
			return 0;
		}
		else
		{
			
			ULOG( "SUCESSO no retorno de serviço CADPP: IDOPERADORA:[%s], sNRLINHA:[%s], sNRDOCUMENTO:[%s], sNMPESSOA:[%s], sSGPLANO:[%s]\n", sIDOPERADORA, sNRLINHA, sNRDOCUMENTO, sNMPESSOA, sSGPLANO );
		}		

        //
        // Vai remover da fila, pois nao houve erro de infra
        // o Servico foi chamado e executou com sucesso
        // Sera ignorado falha na regra de negocio, pois ja existe uma tabela de LOG no PP
        bool bRemovido = RemoverRegistro( szIDLINHATELEFONICA );
        if( bRemovido == true)
        {
            ULOG( "SUCESSO na remoção do registro em CUSTOMER.TEMPPESSOALINHA szIDLINHATELEFONICA:[%s]\n", szIDLINHATELEFONICA );
        }
        else
        {
            ULOG( "ERRO na remoção do registro em CUSTOMER.TEMPPESSOALINHA szIDLINHATELEFONICA:[%s]\n", szIDLINHATELEFONICA );
            ULOG( "Finalizando processo...\n" );
            ULOG_END( "ProcCadastroPP()" );
            delete remoteService;
            delete inputMessage;
            return -2;
        }
	}
    else /* Grava Codigo de erro e mensagem */
    {
		ULOG( "StatusCode serviço CADPP retornou Erro." );
		
			int iqtdTentativa;
			try
			{
				iqtdTentativa = atoi(szINQTDTENTATIVA);
				iqtdTentativa++;
				//Incrementar Registro
				ULOG( "Incrementando a Quantidade de Tentativa do registro para [%d]\n", iqtdTentativa );
				bool bIncrementar = IncrementaQTDTentativa( szIDLINHATELEFONICA, iqtdTentativa );
				if( bIncrementar == true)
				{
					ULOG( "SUCESSO no incremento da Quantidade de tentativas para[%d]\n", iqtdTentativa );
				}
				else
				{
					ULOG( "ERRO no incremento da Quantidade de tentativas para[%d]\n", iqtdTentativa );
					ULOG( "Finalizando processo...\n" );
					ULOG_END( "ProcCadastroPP()" );
					delete remoteService;
					delete inputMessage;
					return -2;
				}
			}
			catch(...)
			{
				ULOG( "ERRO tentando obter a quantidade de Tentativas[%s]\n",szINQTDTENTATIVA );
				ULOG( "Finalizando processo...\n" );
				ULOG_END( "ProcCadastroPP()" );
				delete remoteService;
				delete inputMessage;
				return -2;
			}
		
		ULOG( "Finalizando processo...\n" );
		ULOG_END( "ProcCadastroPP()" );
		delete remoteService;
		delete inputMessage;
		return 0;
    }
	
    delete remoteService;
    delete inputMessage;
    ULOG("Processamento encerrado com sucesso...\n");
    ULOG_END( "ProcCadastroPP()" );
 
    return 0;
}



/************************************************************************************************************/
char *TrataErroNGIN(char *pStatusText)
{
    char szStatusTextAux[255 + 1];
    static char szCdErro[255 + 1];
    register int iCont;
    int iLen;

    /* copia string a ser analisada para buffer local (strtok altera o ponteiro de entrada) */
    strcpy(szStatusTextAux, pStatusText);

    memset(szCdErro, 0x00, sizeof(szCdErro));
    iLen=strlen(szStatusTextAux);
    for(iCont=0; iCont < iLen && szStatusTextAux[iCont] != '.'; iCont++) {
        szCdErro[iCont] = szStatusTextAux[iCont];
    }

    strcpy(pStatusText, szStatusTextAux+iCont+1);

    return szCdErro;
}



/************************************************************************************************************/
char *ObtemValorTag(char *pXml, char *pTag)
{
    static char szValue[4096 + 1];

    szValue[0] = 0;
    if ( pXml )
    {
        if ( *pXml )
        {
            char *p0 = strstr(pXml,pTag) + strlen(pTag) + 1;
            if ( p0 )
            {
                char *p1 = strstr(p0,pTag) - 2;
                if ( p1 )
                {
                    if ( p1 > p0 )
                    {
                        int tam = p1-p0;
                        if (tam > 4096) tam = 4096;
                        strncpy(szValue,p0,tam);
                        szValue[tam]=0;
                    }
                }
            }
        }
    }

    return szValue;
}



/************************************************************************************************************/
int sendXML( char *pXmlSaida, char *pRetMsg, long * iErrorNumber ) 
{
    ULOG_START( "sendXML()" );
    
    char *sendbuf, *rcvbuf;
    long sendlen, rcvlen;

    sendlen = strlen( pXmlSaida );

    if((sendbuf = (char *) tpalloc("STRING", NULL, sendlen+1)) == NULL) {
        ULOGE("Error allocating send buffer\n");
        return -1;
    }

    if((rcvbuf = (char *) tpalloc("STRING", NULL, sendlen+1)) == NULL) {
        ULOGE("Error allocating receive buffer\n");
        tpfree( sendbuf );
        return -1;
    }

    strcpy( sendbuf, pXmlSaida );

    if( tpcall("TUXPREPAGOBE", (char *)sendbuf, sendlen, (char **)&rcvbuf, &rcvlen, (long)0 ) == -1 ) 
    {
        ULOG( ">>> ERRO: TUXPREPAGOBE --> TPERRNO [%d]",tperrno  );
        
        ULOGE( "rcvbuf [%s]\n", rcvbuf);

        *iErrorNumber = tperrno;
        strcpy( pRetMsg, rcvbuf );

        tpfree( sendbuf );
        tpfree( rcvbuf );

        ULOG_END( "sendXML()" );
        return 1;
    }

    *iErrorNumber=0;
    strcpy( pRetMsg, rcvbuf );

    tpfree( sendbuf );
    tpfree( rcvbuf );

    ULOG_END( "sendXML()" );
    return 0;
}

/************************************************************************************************************/
bool RemoverRegistro( char * szIDLINHATELEFONICA )
{
    ULOG_START( "RemoverRegistro()" );
    
    EXEC SQL BEGIN DECLARE SECTION;
        char *oszIDLINHATELEFONICA = szIDLINHATELEFONICA;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro;
//    EXEC SQL WHENEVER NOT FOUND goto naoexiste;
    
    ULOG( "Removendo IDLINHATELEFONICA [%s]", oszIDLINHATELEFONICA );

    /* atualiza base com código de erro da transacao de envio para legado */
    EXEC SQL
        DELETE
            CUSTOMER.TEMPPESSOALINHA TPL
        WHERE
            TPL.IDLINHATELEFONICA = TO_NUMBER(:oszIDLINHATELEFONICA);

    ULOG_END( "RemoverRegistro()" );
    return true;

    erro:
//        ULOG( "*** ERRO: Finalizando com erro sqlca.sqlcode [%d]\n", sqlca.sqlcode );
		ULOG( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
        ULOG_END( "RemoverRegistro()" );
        return false;

    naoexiste:
        ULOG( "*** ERRO: oszIDLINHATELEFONICA [%s] nao encontrado\n", oszIDLINHATELEFONICA );
        ULOG_END( "RemoverRegistro()" );
        return false;
}

/************************************************************************************************************/
bool IncrementaQTDTentativa( char * szIDLINHATELEFONICA, int iqtdTentativa )
{
    ULOG_START( "IncrementaQTDTentativa()" );
    
    EXEC SQL BEGIN DECLARE SECTION;
        char *oszIDLINHATELEFONICA = szIDLINHATELEFONICA;
		int oiQtdTentativa = iqtdTentativa;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro;
//    EXEC SQL WHENEVER NOT FOUND goto naoexiste;
    
    ULOG( "Removendo IDLINHATELEFONICA [%s]", oszIDLINHATELEFONICA );

    /* atualiza base com código de erro da transacao de envio para legado */
    EXEC SQL
        UPDATE
            CUSTOMER.TEMPPESSOALINHA TPL SET TPL.INQTDTENTATIVA = :oiQtdTentativa
        WHERE
            TPL.IDLINHATELEFONICA = TO_NUMBER(:oszIDLINHATELEFONICA);

    ULOG_END( "IncrementaQTDTentativa()" );
    return true;

    erro:
//        ULOG( "*** ERRO: Finalizando com erro sqlca.sqlcode [%d]\n", sqlca.sqlcode );
		ULOG( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
        ULOG_END( "IncrementaQTDTentativa()" );
        return false;

    naoexiste:
        ULOG( "*** ERRO: oszIDLINHATELEFONICA [%s] nao encontrado\n", oszIDLINHATELEFONICA );
        ULOG_END( "IncrementaQTDTentativa()" );
        return false;
}



/************************************************************************************************************/
bool AtualizaRegistro( char * pszIdFila, char * pszStatusCode, char * pszStatusText )
{
    ULOG_START( "AtualizaRegistro()" );
    
    EXEC SQL BEGIN DECLARE SECTION;

        char *oszIdFila = pszIdFila;
        char *oszCdErro = pszStatusCode;
        char *oszDsErro = pszStatusText;

    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;
    
    ULOG( "Atualizando idfilasetclientinfo [%s]", oszIdFila );
    ULOG( "oszCdErro [%s]", oszCdErro );
    ULOG( "oszDsErro [%s]", oszDsErro );

    /* atualiza base com código de erro da transacao de envio para legado */
    EXEC SQL
        UPDATE
            infra.filasetclientinfo
        SET
            cderro = :oszCdErro,
            dserro = SUBSTR(TRIM(:oszDsErro),1,150),
            dterro = SYSDATE,
            inerro = 1,
            qtretry = qtretry + 1
        WHERE
            idfilasetclientinfo = :oszIdFila;

    ULOG_END( "AtualizaRegistro()" );
    return true;

    erro:
        ULOG( "*** ERRO: Finalizando com erro sqlca.sqlcode [%d]\n", sqlca.sqlcode );
        ULOG_END( "AtualizaRegistro()" );
        return false;

    naoexiste:
        ULOG( "*** ERRO: idfilasetclientinfo [%s] nao encontrado\n", oszIdFila );
        ULOG_END( "AtualizaRegistro()" );
        return false;
}



/************************************************************************************************************/
bool DeletaRegistro(char * pszIdFila )
{
    ULOG_START( "DeletaRegistro()" );
    EXEC SQL BEGIN DECLARE SECTION;
        char * oszIdFila = pszIdFila;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;


    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    ULOG( ">>> Removendo oszIdFila [%s] de infra.filasetclientinfo", oszIdFila );
    EXEC SQL
    DELETE
        FROM infra.filasetclientinfo
    WHERE
        idfilasetclientinfo = :oszIdFila;
    
    ULOG_END( "DeletaRegistro()" );
    return true;

    erro:
        ULOG( "*** ERRO: Finalizando com erro sqlca.sqlcode [%d]\n", sqlca.sqlcode );
        ULOG_END( "DeletaRegistro()" );
        return false;

    naoexiste:
        ULOG( "*** ERRO: idfilasetclientinfo [%s] nao encontrado\n", oszIdFila );
        ULOG_END( "DeletaRegistro()" );
        return false;
}



char *replace( char *st, char *orig, char *repl ) 
{
   static char buffer[4096];
   char *ch;
   buffer[0] = 0x0;
   
   if (!(ch = strstr(st, orig)))
      return st;
   
   strncpy(buffer, st, ch-st);  
   buffer[ch-st] = 0;
   sprintf(buffer+(ch-st), "%s%s", repl, ch+strlen(orig));
   
   return buffer;
}


void retira_apostrofe( char * bf )
{
    char buffer[4096];
    char *p;
    char *s;
    
    strcpy( buffer, bf );
        
    p = strstr( buffer, "&apos;" );
    
    while ( p != NULL )
    {
        s = replace( buffer, "&apos;", "" );
        strcpy( buffer, s );
        p = strstr( buffer, "&apos;" );
    }
    
    strcpy( bf, buffer );
    
}

