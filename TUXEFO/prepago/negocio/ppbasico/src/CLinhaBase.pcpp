#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <CLinhaBase.h>

CLinhaBase::CLinhaBase()
{
}

CLinhaBase::~CLinhaBase()
{
}

int CLinhaBase::Insert( 
						char* cidAreaRegistro,
						char* cnrLinha,
						char* cnrMim,
						char* cnrDigitoLinha,
						char* cidEstadoLinha,
						char* csqSincronismoEstado,
						char* ctsSincronismoEstado,
						char* cdtEstadoLinha,
						char* cdsMotivoEstado,
						char* cidUsuarioAlteracao
					  )
{
    ULOG_START("CLinhaBase::Insert");

	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidAreaRegistro = cidAreaRegistro;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
		char* cAuxnrLinha = cnrLinha;
		char* cAuxnrMim = cnrMim;
		char* cAuxnrDigitoLinha = cnrDigitoLinha;
		char* cAuxidEstadoLinha = cidEstadoLinha;
		char* cAuxsqSincronismoEstado = csqSincronismoEstado;
		char* cAuxtsSincronismoEstado = ctsSincronismoEstado;
		char* cAuxdtEstadoLinha = cdtEstadoLinha;
		char* cAuxdsMotivoEstado = cdsMotivoEstado;
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraLinhaBase();
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
		
		//Realiza o insert
		EXEC SQL 
			INSERT INTO LINHA.LINHABASE 
			(	IDLINHABASE,
				IDAREAREGISTRO,
				NRLINHA,
				NRMIN,
				NRDIGITOLINHA,
				IDESTADOLINHA,
				SQSINCRONISMOESTADO,
				TSSINCRONISMOESTADO,
				DTESTADOLINHA,
				DSMOTIVOESTADO,
				IDUSUARIOALTERACAO,
				DTULTIMAALTERACAO
			)
			VALUES 
			(	LINHA.LINHABASESQ.NEXTVAL,
				:cAuxidAreaRegistro,
				:cAuxnrLinha,
				:cAuxnrMim,
				:cAuxnrDigitoLinha,
				:cAuxidEstadoLinha,
				:cAuxsqSincronismoEstado,
				:cAuxtsSincronismoEstado,
				:cAuxdtEstadoLinha,
				:cAuxdsMotivoEstado,
				:cAuxidUsuarioAlteracao,
				SYSDATE
			);

        ULOG_END("CLinhaBase::Insert");
		return 0;//Sucesso
	}
	catch(...)
	{
		throw;
	}
	
GotoInsert:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CLinhaBase::Update( 
						char* cidLinhaBase,
						char* cidAreaRegistro,
						char* cnrLinha,
						char* cnrMim,
						char* cnrDigitoLinha,
						char* cidEstadoLinha,
						char* csqSincronismoEstado,
						char* ctsSincronismoEstado,
						char* cdtEstadoLinha,
						char* cdsMotivoEstado,
						char* cidUsuarioAlteracao 
					 )
{
    ULOG_START("CLinhaBase::Update");

	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidLinhaBase = cidLinhaBase;
		char* cAuxidAreaRegistro = cidAreaRegistro;
		char* cAuxnrLinha = cnrLinha;
		char* cAuxnrMim = cnrMim;
		char* cAuxnrDigitoLinha = cnrDigitoLinha;
		char* cAuxidEstadoLinha = cidEstadoLinha;
		char* cAuxsqSincronismoEstado = csqSincronismoEstado;
		char* cAuxtsSincronismoEstado = ctsSincronismoEstado;
		char* cAuxdtEstadoLinha = cdtEstadoLinha;
		char* cAuxdsMotivoEstado = cdsMotivoEstado;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraLinhaBase();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
		
		//Executa a instrucao de update
		EXEC SQL 
			UPDATE LINHA.LINHABASE 
			SET
				IDAREAREGISTRO = :cAuxidAreaRegistro,
				NRLINHA = :cAuxnrLinha,
				NRMIN = :cAuxnrMim,
				NRDIGITOLINHA = :cAuxnrDigitoLinha,
				IDESTADOLINHA = cidEstadoLinha,
				SQSINCRONISMOESTADO = csqSincronismoEstado,
				TSSINCRONISMOESTADO = ctsSincronismoEstado,
				DTESTADOLINHA = cdtEstadoLinha,
				DSMOTIVOESTADO = cdsMotivoEstado,
				IDUSUARIOALTERACAO = :cAuxidUsuarioAlteracao,
				DTULTIMAALTERACAO = SYSDATE
			WHERE
				IDLINHABASE = :cAuxidLinhaBase;
		
        ULOG_END("CLinhaBase::Update");
		return 0;
	}
	catch(...)
	{
		throw;
	}

GotoUpdate:
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CLinhaBase::Delete( char* cidLinhaBase )
{
    ULOG_START("CLinhaBase::Delete");

	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;	
		char* cAuxidLinhaBase = cidLinhaBase; 
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraLinhaBase();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
		sqlca.sqlcode=0;
		
		//Executa a instrucao de delecao
		EXEC SQL 
			DELETE FROM 
				LINHA.LINHABASE 		
			WHERE 
				IDLINHABASE = :cAuxidLinhaBase;
		
        ULOG_END("CLinhaBase::Delete");
		return 0;//Sucesso
	}
	catch(...)
	{
		throw;
	}

GotoDelete:
	if( sqlca.sqlcode == -2292 )
		return 1;
	else
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CLinhaBase::ListId( char* cidLinhaBase ) 
{
    ULOG_START("CLinhaBase::ListId");

	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidLinhaBase = cidLinhaBase; 
		struct
		{
			VARCHAR stidLinhaBase[21+1];
			VARCHAR stidAreaRegistro[21+1];
			VARCHAR stnrLinha[21+1];
			VARCHAR stnrMim[255+1];
			VARCHAR stnrDigitoLinha[21+1];
			VARCHAR stidEstadoLinha[21+1];
			VARCHAR stsqSincronismoEstado[21+1];
			VARCHAR sttsSincronismoEstado[21+1];
			VARCHAR stdtEstadoLinha[21+1];
			VARCHAR stdsMotivoEstado[255+1];
			} stLinhaBaseRegistro;
		struct
		{
			short iidLinhaBase;
			short iidAreaRegistro;
			short inrLinha;
			short inrMim;
			short inrDigitoLinha;
			short iidEstadoLinha;
			short isqSincronismoEstado;
			short itsSincronismoEstado;
			short idtEstadoLinha;
			short idsMotivoEstado;
		} stLinhaBaseIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraLinhaBase();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorLinhaBaseId CURSOR FOR 
   			SELECT 	
   				IDLINHABASE,
				IDAREAREGISTRO,
				NRLINHA,
				NRMIN,
				NRDIGITOLINHA,
				IDESTADOLINHA,
				SQSINCRONISMOESTADO,
				TSSINCRONISMOESTADO,
				DTESTADOLINHA,
				DSMOTIVOESTADO
			FROM 
				LINHA.LINHABASE
			WHERE 
				IDLINHABASE = :cAuxidLinhaBase;

		//Abre o cursor
		EXEC SQL OPEN CursorLinhaBaseId;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stLinhaBaseRegistro, 0, sizeof(stLinhaBaseRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorLinhaBaseId INTO :stLinhaBaseRegistro:stLinhaBaseIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stLinhaBaseRegistro.stidLinhaBase.arr,
				(char*)stLinhaBaseRegistro.stidAreaRegistro.arr, 
				(char*)stLinhaBaseRegistro.stnrLinha.arr, 
				(char*)stLinhaBaseRegistro.stnrMim.arr, 
				(char*)stLinhaBaseRegistro.stnrDigitoLinha.arr,
				(char*)stLinhaBaseRegistro.stidEstadoLinha.arr,
				(char*)stLinhaBaseRegistro.stsqSincronismoEstado.arr,
				(char*)stLinhaBaseRegistro.sttsSincronismoEstado.arr,
				(char*)stLinhaBaseRegistro.stdtEstadoLinha.arr,
				(char*)stLinhaBaseRegistro.stdsMotivoEstado.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorLinhaBaseId;

	}
	catch(...)
	{
		throw;
	}

    ULOG_END("CLinhaBase::ListId");

	//Retorna a quantidade de registros
	return iCont;
GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CLinhaBase::ListAll( void )
{
    ULOG_START("CLinhaBase::ListAll");

	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidLinhaBase[21+1];
			VARCHAR stidAreaRegistro[21+1];
			VARCHAR stnrLinha[21+1];
			VARCHAR stnrMim[255+1];
			VARCHAR stnrDigitoLinha[21+1];
			VARCHAR stidEstadoLinha[21+1];
			VARCHAR stsqSincronismoEstado[21+1];
			VARCHAR sttsSincronismoEstado[21+1];
			VARCHAR stdtEstadoLinha[21+1];
			VARCHAR stdsMotivoEstado[255+1];
			} stLinhaBaseRegistro;
		struct
		{
			short iidLinhaBase;
			short iidAreaRegistro;
			short inrLinha;
			short inrMim;
			short inrDigitoLinha;
			short iidEstadoLinha;
			short isqSincronismoEstado;
			short itsSincronismoEstado;
			short idtEstadoLinha;
			short idsMotivoEstado;
		} stLinhaBaseIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraLinhaBase();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL DECLARE CursorLinhaBaseAll CURSOR FOR
   			SELECT 	
   				IDLINHABASE,
				IDAREAREGISTRO,
				NRLINHA,
				NRMIN,
				NRDIGITOLINHA,
				IDESTADOLINHA,
				SQSINCRONISMOESTADO,
				TSSINCRONISMOESTADO,
				DTESTADOLINHA,
				DSMOTIVOESTADO
			FROM 
				LINHA.LINHABASE
			WHERE
				IDLINHABASE > 0; 

		//Abre o cursor
		EXEC SQL OPEN CursorLinhaBaseAll;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stLinhaBaseRegistro, 0, sizeof(stLinhaBaseRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorLinhaBaseAll INTO :stLinhaBaseRegistro:stLinhaBaseIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stLinhaBaseRegistro.stidLinhaBase.arr,
				(char*)stLinhaBaseRegistro.stidAreaRegistro.arr, 
				(char*)stLinhaBaseRegistro.stnrLinha.arr, 
				(char*)stLinhaBaseRegistro.stnrMim.arr, 
				(char*)stLinhaBaseRegistro.stnrDigitoLinha.arr,
				(char*)stLinhaBaseRegistro.stidEstadoLinha.arr,
				(char*)stLinhaBaseRegistro.stsqSincronismoEstado.arr,
				(char*)stLinhaBaseRegistro.sttsSincronismoEstado.arr,
				(char*)stLinhaBaseRegistro.stdtEstadoLinha.arr,
				(char*)stLinhaBaseRegistro.stdsMotivoEstado.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o cursor
		EXEC SQL CLOSE CursorLinhaBaseAll;
	}
	catch(...)
	{
		throw;
	}

    ULOG_END("CLinhaBase::ListAll");

	//Retorna a quantidade de registros
	return iCont;

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CLinhaBase::GetXml( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
				xml->createTag(cNomeTag);
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idLinhaBase", Registro(x)->cidLinhaBase );
				xml->addItem("idAreaRegistro", Registro(x)->cidAreaRegistro ); 
				xml->addItem("nrLinha", Registro(x)->cnrLinha ); 
				xml->addItem("nrMim", Registro(x)->cnrMim ); 
				xml->addItem("nrDigitoLinha", Registro(x)->cnrDigitoLinha ); 
				xml->addItem("idEstadoLinha", Registro(x)->cidEstadoLinha ); 
				xml->addItem("sqSincronismoEstado", Registro(x)->csqSincronismoEstado ); 
				xml->addItem("tsSincronismoEstado", Registro(x)->ctsSincronismoEstado ); 
				xml->addItem("dtEstadoLinha", Registro(x)->cdtEstadoLinha ); 
				xml->addItem("dsMotivoEstado", Registro(x)->cdsMotivoEstado ); 
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}

int CLinhaBase::ValidaLinhaPrePago( char* ccdAreaRegistro,
		                            char* cnrLinha )
{
    ULOG_START("CLinhaBase::ValidaLinhaPrePago");

	//Variavel de controle para a quantidade de registros retornada
	int    iRet;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxcdAreaRegistro = ccdAreaRegistro; 
		char* cAuxnrLinha = cnrLinha; 
		struct
		{
			VARCHAR stnrDigitoLinha[21+1];
			VARCHAR stidLinhaTelefonica[21+1];
			VARCHAR stidPessoa[21+1];
			VARCHAR stidTipoPessoa[21+1];
		} stLinhaBaseRegistro;
		struct
		{
			short inrDigitoLinha;
			short iidLinhaTelefonica;
			short iidPessoa;
			short iidTipoPessoa;
		} stLinhaBaseIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraLinhaBase();
		memset( &stLinhaBaseRegistro, 0, sizeof(stLinhaBaseRegistro) );

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoValidaLinhaPrePago;
		sqlca.sqlcode=0;

        EXEC SQL
			SELECT 
				LINHABASE.NRDIGITOLINHA
			   ,LINHATELEFONICA.IDLINHATELEFONICA
			   ,PESSOA.IDPESSOA
               ,PESSOA.IDTIPOPESSOA
			INTO
				:stLinhaBaseRegistro:stLinhaBaseIndicator
			FROM CUSTOMER.PESSOALINHA  	      PESSOALINHA
				, LINHA.LINHATELEFONICA 	      LINHATELEFONICA
				, LINHA.LINHABASE       	      LINHABASE
				, CUSTOMER.LINHACONTA   	      LINHACONTA
				, APOIO.AREAREGISTRO    	      AREAREGISTRO
				, APOIO.TIPOLINHA    	      TIPOLINHA
				, CUSTOMER.TIPORELACIONAMENTO  TIPORELACIONAMENTO
				, CUSTOMER.TIPORELACIONAMENTO  TIPORELACIONAMENTOPESSOA
                , CUSTOMER.PESSOADEPARA        PESSOADEPARA
                , CUSTOMER.PESSOA              PESSOA
			WHERE 
                LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
            AND
                LINHABASE.IDLINHABASE = LINHATELEFONICA.IDLINHABASE
            AND
                LINHATELEFONICA.IDLINHATELEFONICA = LINHACONTA.IDLINHATELEFONICA
            AND
                LINHACONTA.IDTIPORELACIONAMENTO = TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
            AND
                LINHATELEFONICA.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
            AND
                LINHATELEFONICA.IDLINHATELEFONICA = PESSOALINHA.IDLINHATELEFONICA (+) //Alter join, linhas pre ativas nao tem pessoa
            AND
                PESSOALINHA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA (+) //Alter join, linhas pre ativas nao tem pessoa
            AND
                PESSOALINHA.IDTIPORELACIONAMENTO = TIPORELACIONAMENTOPESSOA.IDTIPORELACIONAMENTO (+)//Alter join, linhas pre ativas nao tem pessoa
            AND
                PESSOADEPARA.IDPESSOA = PESSOA.IDPESSOA (+)//Alter join, linhas pre ativas nao tem pessoa
			AND 
                (TIPOLINHA.SGTIPOLINHA = 'PRÉ' OR TIPOLINHA.SGTIPOLINHA = 'PRÉCHIP')
			AND 
                TIPORELACIONAMENTO.SGTIPORELACIONAMENTO = 'C' //Verifica se a relacao com conta eh do tipo cliente
			AND 
				NVL(TIPORELACIONAMENTOPESSOA.SGTIPORELACIONAMENTO,'C') = 'C'
            //    ( 
            //    	TIPORELACIONAMENTOPESSOA.SGTIPORELACIONAMENTO = 'C' //Aqui filtra a pessoa, pois pode ter usuario e cliente na mesma linha, soh retorna cliente
            //    OR 
            //      	TIPORELACIONAMENTOPESSOA.SGTIPORELACIONAMENTO IS NULL //Como esta relacao eh um alter join, tem que verificar se eh nulo, indicando linha pre ativa ou nao achou nada
            //    )
			AND 
                LINHABASE.NRLINHA = :cAuxnrLinha
			AND 
                AREAREGISTRO.CDAREAREGISTRO = :cAuxcdAreaRegistro
			AND 
            	LINHACONTA.DTEXPIRACAO IS NULL
			AND
				ROWNUM <= 1;

		//Linha sempre vem, senao nao achou nada
		if( stLinhaBaseRegistro.stidLinhaTelefonica.len > 0 )
		{
			//Se achou linha, entao verifica se achou pessoa
			if( stLinhaBaseRegistro.stidPessoa.len > 0 )
			{
				Add( (char*)stLinhaBaseRegistro.stidPessoa.arr,
				     (char*)stLinhaBaseRegistro.stidTipoPessoa.arr,
				     (char*)stLinhaBaseRegistro.stnrDigitoLinha.arr,
				     (char*)stLinhaBaseRegistro.stidLinhaTelefonica.arr );
				iRet = 1;//Achou tudo
			}
			else
			{
				Add( "",
				     "",
				     (char*)stLinhaBaseRegistro.stnrDigitoLinha.arr,
				     (char*)stLinhaBaseRegistro.stidLinhaTelefonica.arr );

				iRet = 0;//Achou so dados de linha
			}
		}//if( stLinhaBaseRegistro.stnrDigitoLinha.len > 0 )
		else
			iRet = -1;//Nao achou nada
	}
	catch(...)
	{
		throw;
	}

    ULOG_END("CLinhaBase::ValidaLinhaPrePago");
	//Retorna: 0, 1 ou -1
	return iRet;

GotoValidaLinhaPrePago:
	throw TuxBasicOraException(sqlca.sqlcode);
}
