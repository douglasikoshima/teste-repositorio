///////////////////////////////////////////////////////////////////////////////
/**
 * @modulo  Sincronismo
 * @usecase PessoaDocumento
 * @author  Renato Striitzel Russo
 * @author  Carlos Eduardo Barbosa Braga
 * @version $Revision: 1.1 $
 * @CVS     $Author: a5110702 $ - $Date: 2009/07/31 15:33:23 $
 **/
///////////////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <memory.h>
#include "tuxfw.h"
#include "PessoaDocumentopc.h"
#include "PrePagoException.h"


EXEC SQL BEGIN DECLARE SECTION;
#include "Global.h"
EXEC SQL END DECLARE SECTION;

/**************************************************************************************/
void CPessoaDocumentopc::proCApagaPessoaDocumento(TPessoaDocumento *ptPessoaDocumento)
{
    ULOG_START("CPessoaDocumentopc::proCApagaPessoaDocumento");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoa[LEN_IDPESSOADOCUMENTO];
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro;

    STRCPY_TO_ORA(oszIdPessoa, ptPessoaDocumento->szIdPessoa);

    EXEC SQL DELETE
        FROM Customer.PessoaDocumento
        WHERE idpessoa = TO_NUMBER(:oszIdPessoa);

    ULOGI("Finalizando proCApagaPessoaDocumento <OK>");
    ULOG_END("CPessoaDocumentopc::proCApagaPessoaDocumento");
    return;

    erro:
        ULOGE("Finalizando proCApagaPessoaDocumento <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/**************************************************************************************/
void CPessoaDocumentopc::proCInserePessoaDocumento(TPessoaDocumento *ptPessoaDocumento)
{
    ULOG_START("CPessoaDocumentopc::proCInserePessoaDocumento");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoaDocumento[LEN_IDPESSOADOCUMENTO];
        VARCHAR oszIdPessoa[LEN_IDPESSOA];
        VARCHAR oszIdDocumento[LEN_IDDOCUMENTO];
        VARCHAR oszTsSincronismo[LEN_TSSINCRONISMO];
        VARCHAR oszSqSincronismo[LEN_SQSINCRONISMO];
        VARCHAR oszIdSistemaOrigem[LEN_IDSISTEMAORIGEM];
        VARCHAR oszIdDocumentoSistemaOrigem[LEN_IDDOCUMENTOSISTEMAORIGEM];
        VARCHAR oszDtExpiracao[LEN_DTEXPIRACAO];
        VARCHAR oszIdUsuarioAlteracao[LEN_IDUSUARIOALTERACAO];
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    /* copia os valores da estrutura para as variaveis ProC */
    STRCPY_TO_ORA(oszIdPessoa, ptPessoaDocumento->szIdPessoa);
    STRCPY_TO_ORA(oszIdDocumento, ptPessoaDocumento->szIdDocumento);
    STRCPY_TO_ORA(oszTsSincronismo, ptPessoaDocumento->szTsSincronismo);
    STRCPY_TO_ORA(oszSqSincronismo, ptPessoaDocumento->szSqSincronismo);
    STRCPY_TO_ORA(oszIdSistemaOrigem, ptPessoaDocumento->szIdSistemaOrigem);
    STRCPY_TO_ORA(oszIdDocumentoSistemaOrigem, ptPessoaDocumento->szIdDocumentoSistemaOrigem);
    STRCPY_TO_ORA(oszDtExpiracao, ptPessoaDocumento->szDtExpiracao);
    STRCPY_TO_ORA(oszIdUsuarioAlteracao, ptPessoaDocumento->szIdUsuarioAlteracao);

    EXEC SQL WHENEVER SQLERROR goto erro;

    EXEC SQL
        SELECT Customer.PessoaDocumentoSq.nextval
            INTO :oszIdPessoaDocumento
            FROM DUAL;

    STRCPY_FROM_ORA(ptPessoaDocumento->szIdPessoaDocumento, oszIdPessoaDocumento);

    EXEC SQL INSERT INTO Customer.PessoaDocumento
                       ( idpessoadocumento
                       , idpessoa
                       , iddocumento
                       , tssincronismo
                       , sqsincronismo
                       , idsistemaorigem
                       , iddocumentosistemaorigem
                       , idusuarioalteracao
                       , dtultimaalteracao )
                VALUES ( TO_NUMBER(:oszIdPessoaDocumento)
                       , TO_NUMBER(:oszIdPessoa)
                       , TO_NUMBER(:oszIdDocumento)
                       , TO_NUMBER(:oszTsSincronismo)
                       , TO_NUMBER(:oszSqSincronismo)
                       , TO_NUMBER(:oszIdSistemaOrigem)
                       , :oszIdDocumentoSistemaOrigem
                       , TO_NUMBER(:oszIdUsuarioAlteracao)
                       , SYSDATE);


    ULOGI("Finalizando proCInserePessoaDocumento <OK>");
    ULOG_END("CPessoaDocumentopc::proCInserePessoaDocumento");
    return;

    erro:
        ULOGE("Finalizando proCInserePessoaDocumento <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
}

/**************************************************************************************/
void CPessoaDocumentopc::proCAtualizaPessoaDocumento(TPessoaDocumento tPessoaDocumento)
{
    ULOG_START("CPessoaDocumentopc::proCAtualizaPessoaDocumento");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoaDocumento[LEN_IDPESSOADOCUMENTO];
        VARCHAR oszIdDocumento[LEN_IDDOCUMENTO];
        VARCHAR oszIdUsuarioAlteracao[LEN_IDUSUARIOALTERACAO];
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;


    STRCPY_TO_ORA(oszIdPessoaDocumento, tPessoaDocumento.szIdPessoaDocumento);
    STRCPY_TO_ORA(oszIdDocumento, tPessoaDocumento.szIdDocumento);
    STRCPY_TO_ORA(oszIdUsuarioAlteracao, tPessoaDocumento.szIdUsuarioAlteracao);

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;


    EXEC SQL UPDATE Customer.PessoaDocumento
                SET
                    iddocumento              = TO_NUMBER(:oszIdDocumento)
                  , idusuarioalteracao       = TO_NUMBER(:oszIdUsuarioAlteracao)
                  , dtultimaalteracao        = SYSDATE
              WHERE idpessoadocumento        = TO_NUMBER(:oszIdPessoaDocumento);

    ULOGI("Finalizando proCAtualizaPessoaDocumento <OK>");
    ULOG_END("CPessoaDocumentopc::proCAtualizaPessoaDocumento");
    return;

    naoexiste:
        ULOGI("Finalizando proCAtualizaPessoaDocumento <NOT FOUND>");
        ULOG_END("CPessoaDocumentopc::proCAtualizaPessoaDocumento");
        throw PrePagoException(1, sqlca.sqlerrm.sqlerrmc);

    erro:
        ULOGE("Finalizando proCAtualizaPessoaDocumento <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/**************************************************************************************/
bool CPessoaDocumentopc::proCBuscaPessoaDocumento(TPessoaDocumento *ptPessoaDocumento)
{
    ULOG_START("CPessoaDocumentopc::proCBuscaPessoaDocumento");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoaDocumento[LEN_IDPESSOADOCUMENTO];
        VARCHAR oszIdPessoa[LEN_IDPESSOA];
        VARCHAR oszIdDocumento[LEN_IDDOCUMENTO];
        VARCHAR oszTsSincronismo[LEN_TSSINCRONISMO];
        VARCHAR oszSqSincronismo[LEN_SQSINCRONISMO];
        VARCHAR oszIdSistemaOrigem[LEN_IDSISTEMAORIGEM];
        VARCHAR oszIdDocumentoSistemaOrigem[LEN_IDDOCUMENTOSISTEMAORIGEM];
        VARCHAR oszDtExpiracao[LEN_DTEXPIRACAO];

        short iIdPessoaDocumento = 0;
        short iIdPessoa = 0;
        short iIdDocumento = 0;
        short iTsSincronismo = 0;
        short iSqSincronismo = 0;
        short iIdSistemaOrigem = 0;
        short iIdDocumentoSistemaOrigem = 0;
        short iDtExpiracao = 0;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    STRCPY_TO_ORA(oszIdPessoa, ptPessoaDocumento->szIdPessoa);
    STRCPY_TO_ORA(oszIdPessoaDocumento, ptPessoaDocumento->szIdPessoaDocumento);

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    EXEC SQL SELECT TO_CHAR(idpessoadocumento)
                  , TO_CHAR(idpessoa)
                  , TO_CHAR(iddocumento)
                  , TO_CHAR(tssincronismo)
                  , TO_CHAR(sqsincronismo)
                  , TO_CHAR(idsistemaorigem)
                  , iddocumentosistemaorigem
                  , TO_CHAR(dtexpiracao, 'DD/MM/YYYY')
               INTO :oszIdPessoaDocumento:iIdPessoaDocumento
                  , :oszIdPessoa:iIdPessoa
                  , :oszIdDocumento:iIdDocumento
                  , :oszTsSincronismo:iTsSincronismo
                  , :oszSqSincronismo:iSqSincronismo
                  , :oszIdSistemaOrigem:iIdSistemaOrigem
                  , :oszIdDocumentoSistemaOrigem:iIdDocumentoSistemaOrigem
                  , :oszDtExpiracao:iDtExpiracao
               FROM Customer.PessoaDocumento
              WHERE customer.pessoadocumento.rowid = ( SELECT min(customer.pessoadocumento.rowid)
                                                         FROM customer.pessoadocumento
                                                            , customer.documento
                                                        WHERE customer.pessoadocumento.iddocumento = customer.documento.iddocumento
                                                          AND idtipodocumento = TO_NUMBER(:oszIdPessoaDocumento)
                                                          AND idpessoa = TO_NUMBER(:oszIdPessoa) )
                AND NVL(dtexpiracao,SYSDATE) >= SYSDATE;
                //AND ((dtexpiracao is null) OR (dtexpiracao >= SYSDATE));


    if(iIdPessoaDocumento != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumento->szIdPessoaDocumento, oszIdPessoaDocumento);
    }

    if(iIdPessoa != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumento->szIdPessoa, oszIdPessoa);
    }

    if(iIdDocumento != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumento->szIdDocumento, oszIdDocumento);
    }

    if(iTsSincronismo != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumento->szTsSincronismo, oszTsSincronismo);
    }

    if(iSqSincronismo != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumento->szSqSincronismo, oszSqSincronismo);
    }

    if(iIdSistemaOrigem != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumento->szIdSistemaOrigem, oszIdSistemaOrigem);
    }

    if(iIdDocumentoSistemaOrigem != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumento->szIdDocumentoSistemaOrigem, oszIdDocumentoSistemaOrigem);
    }

    if(iDtExpiracao != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumento->szDtExpiracao, oszDtExpiracao);
    }


    ULOGI("Finalizando proCBuscaPessoaDocumento <OK>");
    ULOG_END("CPessoaDocumentopc::proCBuscaPessoaDocumento");
    return true;

    naoexiste:
        ULOGI("Finalizando proCBuscaPessoaDocumento <NOT FOUND>");
        ULOG_END("CPessoaDocumentopc::proCBuscaPessoaDocumento");
        return false;

    erro:
        ULOGI("Finalizando proCBuscaPessoaDocumento <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/**************************************************************************************/
bool CPessoaDocumentopc::proCBuscaPessoaDocumentoB01(TPessoaDocumentoB01 *ptPessoaDocumentoB01)
{
    ULOG_START("CPessoaDocumentopc::proCBuscaPessoaDocumentoB01");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoa[LEN_IDPESSOA];
        VARCHAR oszIdTipoDocumento[LEN_IDTIPODOCUMENTO];

        VARCHAR oszIdPessoaDocumento[LEN_IDPESSOADOCUMENTO];
        VARCHAR oszIdDocumento[LEN_IDDOCUMENTO];
        VARCHAR oszTsSincronismo[LEN_TSSINCRONISMO];
        VARCHAR oszSqSincronismo[LEN_SQSINCRONISMO];
        VARCHAR oszNrDocumento[LEN_NRDOCUMENTO];

        short iIdPessoa = 0;
        short iIdTipoDocumento = 0;
        short iIdPessoaDocumento = 0;
        short iIdDocumento = 0;
        short iTsSincronismo = 0;
        short iSqSincronismo = 0;
        short iNrDocumento = 0;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    STRCPY_TO_ORA(oszIdPessoa, ptPessoaDocumentoB01->szIdPessoa);
    STRCPY_TO_ORA(oszIdTipoDocumento, ptPessoaDocumentoB01->szIdTipoDocumento);

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;


    EXEC SQL SELECT TO_CHAR(pessoa.idpessoa)
                  , TO_CHAR(documento.idtipodocumento)
                  , TO_CHAR(pessoadocumento.idpessoadocumento)
                  , TO_CHAR(documento.iddocumento)
                  , TO_CHAR(pessoadocumento.tssincronismo)
                  , TO_CHAR(pessoadocumento.sqsincronismo)
                  , TO_CHAR(documento.nrdocumento)
               INTO :oszIdPessoa:iIdPessoa
                  , :oszIdTipoDocumento:iIdTipoDocumento
                  , :oszIdPessoaDocumento:iIdPessoaDocumento
                  , :oszIdDocumento:iIdDocumento
                  , :oszTsSincronismo:iTsSincronismo
                  , :oszSqSincronismo:iSqSincronismo
                  , :oszNrDocumento:iNrDocumento
               FROM customer.pessoa pessoa                             
                  , customer.documento documento                       
                  , customer.pessoadocumento pessoadocumento           
              WHERE pessoadocumento.iddocumento = documento.iddocumento
                AND pessoadocumento.idpessoa    = pessoa.idpessoa         
                AND pessoa.idpessoa = TO_NUMBER( :oszIdPessoa )
                AND documento.idtipodocumento = TO_NUMBER( :oszIdTipoDocumento )
                AND rownum = 1
                AND NVL(pessoadocumento.dtexpiracao,SYSDATE) >= SYSDATE;
                //AND ((pessoadocumento.dtexpiracao is null) OR (pessoadocumento.dtexpiracao >= SYSDATE));

    if(iIdPessoa != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumentoB01->szIdPessoa, oszIdPessoa);
    }

    if(iIdTipoDocumento != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumentoB01->szIdTipoDocumento, oszIdTipoDocumento);
    }

    if(iIdPessoaDocumento != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumentoB01->szIdPessoaDocumento, oszIdPessoaDocumento);
    }

    if(iIdDocumento != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumentoB01->szIdDocumento, oszIdDocumento);
    }

    if(iTsSincronismo != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumentoB01->szTsSincronismo, oszTsSincronismo);
    }

    if(iSqSincronismo != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumentoB01->szSqSincronismo, oszSqSincronismo);
    }

    if(iNrDocumento != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumentoB01->szNrDocumento, oszNrDocumento);
    }

    ULOGI("Finalizando proCBuscaPessoaDocumentoB01 <OK>");
    ULOG_END("CPessoaDocumentopc::proCBuscaPessoaDocumentoB01");
    return true;

    naoexiste:
        ULOGI("Finalizando proCBuscaPessoaDocumentoB01 <NOT FOUND>");
        ULOG_END("CPessoaDocumentopc::proCBuscaPessoaDocumentoB01");
        return false;

    erro:
        ULOGE("Finalizando proCBuscaPessoaDocumentoB01 <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/**************************************************************************************/
bool CPessoaDocumentopc::proCBuscaPessoaDocumentoApagaB01(TPessoaDocumentoB01 *ptPessoaDocumentoB01)
{
    ULOG_START("CPessoaDocumentopc::proCBuscaPessoaDocumentoApagaB01");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoaSistemaOrigem[LEN_IDPESSOASISTEMAORIGEM];
        VARCHAR oszIdSistemaOrigem[LEN_IDSISTEMAORIGEM];
        VARCHAR oszIdTipoDocumento[LEN_IDTIPODOCUMENTO];
        VARCHAR oszNrDocumento[LEN_NRDOCUMENTO];

        VARCHAR oszSqSincronismo[LEN_SQSINCRONISMO];
        VARCHAR oszIdPessoaDocumento[LEN_IDPESSOADOCUMENTO];

        short iSqSincronismo = 0;
        short iIdPessoaDocumento = 0;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    STRCPY_TO_ORA(oszIdPessoaSistemaOrigem, ptPessoaDocumentoB01->szIdPessoaSistemaOrigem);
    STRCPY_TO_ORA(oszIdSistemaOrigem, ptPessoaDocumentoB01->szIdSistemaOrigem);
    STRCPY_TO_ORA(oszIdTipoDocumento, ptPessoaDocumentoB01->szIdTipoDocumento);
    STRCPY_TO_ORA(oszNrDocumento, ptPessoaDocumentoB01->szNrDocumento);

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

   EXEC SQL SELECT TO_CHAR(PESSOADOCUMENTO.sqsincronismo)
                 , TO_CHAR(PESSOADOCUMENTO.idpessoadocumento)
              INTO :oszSqSincronismo:iSqSincronismo
                 , :oszIdPessoaDocumento:iIdPessoaDocumento
              FROM CUSTOMER.PESSOA PESSOA
                 , CUSTOMER.DOCUMENTO DOCUMENTO
                 , CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO
             WHERE PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO
               AND PESSOADOCUMENTO.IDPESSOA = PESSOA.IDPESSOA
               AND PESSOA.idpessoasistemaorigem = :oszIdPessoaSistemaOrigem
               AND PESSOA.idsistemaorigem       = TO_NUMBER( :oszIdSistemaOrigem )
               AND DOCUMENTO.idtipodocumento    = TO_NUMBER( :oszIdTipoDocumento )
               AND DOCUMENTO.nrdocumento        = :oszNrDocumento;

    if(iSqSincronismo != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumentoB01->szSqSincronismo, oszSqSincronismo);
    }

    if(iIdPessoaDocumento != -1) {
        STRCPY_FROM_ORA(ptPessoaDocumentoB01->szIdPessoaDocumento, oszIdPessoaDocumento);
    }

    ULOGI("Finalizando proCBuscaPessoaDocumentoApagaB01 <OK>");
    ULOG_END("CPessoaDocumentopc::proCBuscaPessoaDocumentoApagaB01");
    return true;

    naoexiste:
        ULOGI("Finalizando proCBuscaPessoaDocumentoApagaB01 <NOT FOUND>");
        ULOG_END("CPessoaDocumentopc::proCBuscaPessoaDocumentoApagaB01");
        return false;

    erro:
        ULOGE("Finalizando proCBuscaPessoaDocumentoApagaB01 <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}
