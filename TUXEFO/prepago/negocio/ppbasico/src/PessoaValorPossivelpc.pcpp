///////////////////////////////////////////////////////////////////////////////
/**
 * @modulo  PrePago
 * @usecase PessoaValorPossivel
 * @author  Renato Striitzel Russo
 * @author  Carlos Eduardo Barbosa Braga
 * @author  Eder Martins
 * @version $Revision: 1.1 $
 * @CVS     $Author: a5110702 $ - $Date: 2009/07/31 15:33:22 $
 **/
///////////////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "tuxfw.h"
#include "PessoaValorPossivelpc.h"
#include "PrePagoException.h"

EXEC SQL BEGIN DECLARE SECTION;
#include "Global.h"
EXEC SQL END DECLARE SECTION;

/********************************************************************************/
void CPessoaValorPossivelpc::proCInserePessoaValorPossivel(TPessoaValorPossivel *ptPessoaValorPossivel)
{
    ULOG_START("CPessoaValorPossivelpc::proCInserePessoaValorPossivel");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoaValorPossivel[LEN_IDPESSOAVALORPOSSIVEL];
        VARCHAR oszIdValorPossivel[LEN_IDVALORPOSSIVEL];
        VARCHAR oszIdPessoa[LEN_IDPESSOA];
        VARCHAR oszIdUsuarioAlteracao[LEN_IDUSUARIOALTERACAO];
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    STRCPY_TO_ORA(oszIdValorPossivel, ptPessoaValorPossivel->szIdValorPossivel);
    STRCPY_TO_ORA(oszIdPessoa, ptPessoaValorPossivel->szIdPessoa);
    STRCPY_TO_ORA(oszIdUsuarioAlteracao, ptPessoaValorPossivel->szIdUsuarioAlteracao);

    EXEC SQL WHENEVER SQLERROR goto erro;

    EXEC SQL INSERT INTO Customer.PessoaValorPossivel
            (    idpessoavalorpossivel
               , idvalorpossivel
               , idpessoa
               , idusuarioalteracao
               , dtultimaalteracao)
        VALUES (  Customer.PessoaValorPossivelSq.nextval
               , :oszIdValorPossivel
               , :oszIdPessoa
               , :oszIdUsuarioAlteracao
               , SYSDATE)
               RETURNING idpessoavalorpossivel
                    INTO :oszIdPessoaValorPossivel;

    STRCPY_FROM_ORA(ptPessoaValorPossivel->szIdPessoaValorPossivel, oszIdPessoaValorPossivel);

    ULOGI("Finalizando proCInserePessoaValorPossivel <OK>");
    ULOG_END("CPessoaValorPossivelpc::proCInserePessoaValorPossivel");
    return;

    erro:
        ULOGE("Finalizando proCInserePessoaValorPossivel <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/********************************************************************************/
void CPessoaValorPossivelpc::proCApagaEscolaridade(TPessoaValorPossivel *ptPessoaValorPossivel)
{
    ULOG_START("CPessoaValorPossivelpc::proCApagaEscolaridade");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoa[LEN_IDPESSOA];
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    STRCPY_TO_ORA(oszIdPessoa, ptPessoaValorPossivel->szIdPessoa);

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND  goto naoexiste;


    EXEC SQL DELETE FROM customer.pessoavalorpossivel
        WHERE idpessoavalorpossivel IN ( SELECT pessoavalorpossivel.idpessoavalorpossivel
                                            FROM customer.atributo              atributo
                                               , customer.valorpossivel         valorpossivel
                                               , customer.pessoavalorpossivel   pessoavalorpossivel
                                            WHERE atributo.idatributo                 = valorpossivel.idatributo
                                             AND atributo.idatributo                  = 90
                                             AND pessoavalorpossivel.idvalorpossivel  = valorpossivel.idvalorpossivel
                                             AND pessoavalorpossivel.idpessoa         = :oszIdPessoa);
   
    ULOGI("Finalizando proCApagaEscolaridade <OK>");
    ULOG_END("CPessoaValorPossivelpc::proCApagaEscolaridade");
    return;

    naoexiste:
        ULOGI("Finalizando proCApagaEscolaridade <NOT FOUND>");
        ULOG_END("CPessoaValorPossivelpc::proCApagaEscolaridade");
        return;

    erro:
        ULOGE("Finalizando proCApagaEscolaridade <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/********************************************************************************/
void CPessoaValorPossivelpc::proCApagaOcupacao(TPessoaValorPossivel *ptPessoaValorPossivel)
{
    ULOG_START("CPessoaValorPossivelpc::proCApagaOcupacao");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoa[LEN_IDPESSOA];
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    STRCPY_TO_ORA(oszIdPessoa, ptPessoaValorPossivel->szIdPessoa);

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND  goto naoexiste;

    EXEC SQL DELETE customer.pessoavalorpossivel
        WHERE idpessoavalorpossivel IN ( SELECT pessoavalorpossivel.idpessoavalorpossivel
                                            FROM customer.atributo                  atributo
                                               , customer.valorpossivel             valorpossivel
                                               , customer.pessoavalorpossivel       pessoavalorpossivel
                                            WHERE atributo.idatributo               = valorpossivel.idatributo
                                            AND atributo.idatributo                 = 107
                                            AND pessoavalorpossivel.idvalorpossivel = valorpossivel.idvalorpossivel
                                            AND pessoavalorpossivel.idpessoa        = :oszIdPessoa);

    ULOGI("Finalizando proCApagaOcupacao <OK>");
    ULOG_END("CPessoaValorPossivelpc::proCApagaOcupacao");
    return;

    naoexiste:
        ULOGI("Finalizando proCApagaOcupacao <NOT FOUND>");
        ULOG_END("CPessoaValorPossivelpc::proCApagaOcupacao");
        return;

    erro:
        ULOGE("Finalizando proCApagaOcupacao <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}
