#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <CTipoDocumento.h>
#include <Global.h>

CTipoDocumento::CTipoDocumento()
{
}

CTipoDocumento::~CTipoDocumento()
{
}

int CTipoDocumento::ListId( char* cidTipoDocumento )
{
    ULOG_START("CTipoDocumento::ListId");

	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidTipoDocumento = cidTipoDocumento;
		struct
		{
			VARCHAR stidTipoDocumento[21+1];
			VARCHAR stsgTipoDocumento[255+1];
			VARCHAR stdsTipoDocumento[255+1];
			VARCHAR stidTipoPessoa[21+1];
			VARCHAR stnrPrioridade[21+1];
            VARCHAR stsgClassificacao[255+1];
		} stTipoDocumentoRegistro;
		struct
		{
			short stidTipoDocumento;
			short stsgTipoDocumento;
			short stdsTipoDocumento;
			short stidTipoPessoa;
			short stnrPrioridade;
            short stsgClassificacao;
		} stTipoDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;

	try
	{
		ZeraTipoDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE 
	   			CursorTipoDocumentoId CURSOR FOR
                    SELECT 
                        IDTIPODOCUMENTO, 
                        SGCLASSIFICACAO, 
                        DSTIPODOCUMENTO, 
                        IDTIPOPESSOA,
                        NRPRIORIDADE,
                        SGCLASSIFICACAO
                    FROM 
                        APOIO.TIPODOCUMENTO
                    WHERE 
                        IDTIPODOCUMENTO = :cAuxidTipoDocumento;
	
		EXEC SQL OPEN CursorTipoDocumentoId;
	
		if(sqlca.sqlcode)
        {
            ULOGE("CTipoDocumento::ListId <ERROR>");
            ULOG_END("CTipoDocumento::ListId");
			return 0;
        }
		else
		{
			for(;;)
			{
				memset( &stTipoDocumentoRegistro, 0, sizeof(stTipoDocumentoRegistro) );
				memset( &stTipoDocumentoIndicator,-1, sizeof(stTipoDocumentoIndicator) );
				EXEC SQL FETCH CursorTipoDocumentoId INTO :stTipoDocumentoRegistro:stTipoDocumentoIndicator;

                CONVIND(stTipoDocumentoRegistro.stidTipoDocumento,stTipoDocumentoIndicator.stidTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stsgTipoDocumento,stTipoDocumentoIndicator.stsgTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stdsTipoDocumento,stTipoDocumentoIndicator.stdsTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stidTipoPessoa   ,stTipoDocumentoIndicator.stidTipoPessoa   );
                CONVIND(stTipoDocumentoRegistro.stnrPrioridade   ,stTipoDocumentoIndicator.stnrPrioridade   );
                CONVIND(stTipoDocumentoRegistro.stsgClassificacao,stTipoDocumentoIndicator.stsgClassificacao);

				Add( (char*)stTipoDocumentoRegistro.stidTipoDocumento.arr, 
				     (char*)stTipoDocumentoRegistro.stsgTipoDocumento.arr, 
				     (char*)stTipoDocumentoRegistro.stdsTipoDocumento.arr,
				     (char*)stTipoDocumentoRegistro.stidTipoPessoa.arr,
				     (char*)stTipoDocumentoRegistro.stnrPrioridade.arr,
                     (char*)stTipoDocumentoRegistro.stsgClassificacao.arr);
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorTipoDocumentoId;
		}
	}
	catch(...)
	{
		throw;
	}

    ULOGI("CTipoDocumento::ListId <OK>");
    ULOG_END("CTipoDocumento::ListId");

	return iCont;

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CTipoDocumento::ListAll( void )
{
    ULOG_START("CTipoDocumento::ListAll");

	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidTipoDocumento[21+1];
			VARCHAR stsgTipoDocumento[255+1];
			VARCHAR stdsTipoDocumento[255+1];
			VARCHAR stidTipoPessoa[21+1];
			VARCHAR stnrPrioridade[21+1];
            VARCHAR stsgClassificacao[255+1];
		} stTipoDocumentoRegistro;
		struct
		{
			short stidTipoDocumento;
			short stsgTipoDocumento;
			short stdsTipoDocumento;
			short stidTipoPessoa;
			short stnrPrioridade;
            short stsgClassificacao;
		} stTipoDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;

	try
	{
		ZeraTipoDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
	   		DECLARE 
	   			CursorTipoDocumentoAll CURSOR FOR
                    SELECT 
                        IDTIPODOCUMENTO, 
                        SGCLASSIFICACAO, 
                        DSTIPODOCUMENTO, 
                        IDTIPOPESSOA,
                        NRPRIORIDADE,
                        SGCLASSIFICACAO
                    FROM 
                        APOIO.TIPODOCUMENTO
                    WHERE
                        IDTIPODOCUMENTO > 0 AND
                        INVISUALIZA = 1;
	
		EXEC SQL OPEN CursorTipoDocumentoAll;
	
		if(sqlca.sqlcode)
        {
            ULOGE("CTipoDocumento::ListAll <ERROR>");
            ULOG_END("CTipoDocumento::ListAll");
			return 0;
        }
		else
		{
			for(;;)
			{
				memset( &stTipoDocumentoRegistro, 0, sizeof(stTipoDocumentoRegistro) );
				memset( &stTipoDocumentoIndicator,-1, sizeof(stTipoDocumentoIndicator) );
				EXEC SQL FETCH CursorTipoDocumentoAll INTO :stTipoDocumentoRegistro:stTipoDocumentoIndicator;

                CONVIND(stTipoDocumentoRegistro.stidTipoDocumento,stTipoDocumentoIndicator.stidTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stsgTipoDocumento,stTipoDocumentoIndicator.stsgTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stdsTipoDocumento,stTipoDocumentoIndicator.stdsTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stidTipoPessoa   ,stTipoDocumentoIndicator.stidTipoPessoa   );
                CONVIND(stTipoDocumentoRegistro.stnrPrioridade   ,stTipoDocumentoIndicator.stnrPrioridade   );
                CONVIND(stTipoDocumentoRegistro.stsgClassificacao,stTipoDocumentoIndicator.stsgClassificacao);

				Add( (char*)stTipoDocumentoRegistro.stidTipoDocumento.arr, 
				     (char*)stTipoDocumentoRegistro.stsgTipoDocumento.arr, 
				     (char*)stTipoDocumentoRegistro.stdsTipoDocumento.arr,
				     (char*)stTipoDocumentoRegistro.stidTipoPessoa.arr,
				     (char*)stTipoDocumentoRegistro.stnrPrioridade.arr,
                     (char*)stTipoDocumentoRegistro.stsgClassificacao.arr);
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorTipoDocumentoAll;
		}
	}
	catch(...)
	{
		throw;
	}

    ULOGI("CTipoDocumento::ListAll <OK>");
    ULOG_END("CTipoDocumento::ListAll");

	return iCont;

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);

}


int CTipoDocumento::ListPF( void )
{
    ULOG_START("CTipoDocumento::ListPF");

	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidTipoDocumento[21+1];
			VARCHAR stsgTipoDocumento[255+1];
			VARCHAR stdsTipoDocumento[255+1];
			VARCHAR stidTipoPessoa[21+1];
			VARCHAR stnrPrioridade[21+1];
		} stTipoDocumentoRegistro;
		struct
		{
			short stidTipoDocumento;
			short stsgTipoDocumento;
			short stdsTipoDocumento;
			short stidTipoPessoa;
			short stnrPrioridade;
		} stTipoDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;

	try
	{
		ZeraTipoDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListPF;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
			DECLARE 
				CursorListPF CURSOR FOR
			SELECT 
		    TD.IDTIPODOCUMENTO, 
		    TD.SGCLASSIFICACAO, 
		    TD.DSTIPODOCUMENTO, 
		    TD.IDTIPOPESSOA,
		    TD.NRPRIORIDADE 
		FROM 
		    APOIO.TIPODOCUMENTO TD,
		    (
		        SELECT
		           A.SGCLASSIFICACAO,
		           A.NRPRIORIDADE,
		           MIN(IDTIPODOCUMENTO) IDTIPODOCUMENTO
		        FROM
		            (
		                SELECT 
		                    SGCLASSIFICACAO,
		                    MIN(NVL(NRPRIORIDADE,100)) NRPRIORIDADE
		                FROM 
		                    APOIO.TIPODOCUMENTO
		                WHERE
		                    IDTIPOPESSOA = ( SELECT IDTIPOPESSOA FROM APOIO.TIPOPESSOA WHERE SGTIPOPESSOA = 'PF' )
		                GROUP BY
		                    SGCLASSIFICACAO
		             ) A,
		             APOIO.TIPODOCUMENTO B
		        WHERE
		             B.SGCLASSIFICACAO = A.SGCLASSIFICACAO AND
		             NVL(B.NRPRIORIDADE,100) = A.NRPRIORIDADE
		        GROUP BY
		            A.SGCLASSIFICACAO,
		            A.NRPRIORIDADE
		    ) X
		WHERE
		    TD.IDTIPODOCUMENTO = X.IDTIPODOCUMENTO
		ORDER BY
		    TD.DSTIPODOCUMENTO;
	
		EXEC SQL OPEN CursorListPF;
	
		if(sqlca.sqlcode)
        {
            ULOGE("CTipoDocumento::ListPF <ERROR>");
            ULOG_END("CTipoDocumento::ListPF");
			return 0;
        }
		else
		{
			for(;;)
			{
				memset( &stTipoDocumentoRegistro, 0, sizeof(stTipoDocumentoRegistro) );
				memset( &stTipoDocumentoIndicator,-1, sizeof(stTipoDocumentoIndicator) );
				EXEC SQL FETCH CursorListPF INTO :stTipoDocumentoRegistro:stTipoDocumentoIndicator;

                CONVIND(stTipoDocumentoRegistro.stidTipoDocumento,stTipoDocumentoIndicator.stidTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stsgTipoDocumento,stTipoDocumentoIndicator.stsgTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stdsTipoDocumento,stTipoDocumentoIndicator.stdsTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stidTipoPessoa   ,stTipoDocumentoIndicator.stidTipoPessoa   );
                CONVIND(stTipoDocumentoRegistro.stnrPrioridade   ,stTipoDocumentoIndicator.stnrPrioridade   );

				Add( (char*)stTipoDocumentoRegistro.stidTipoDocumento.arr, 
				     (char*)stTipoDocumentoRegistro.stsgTipoDocumento.arr, 
				     (char*)stTipoDocumentoRegistro.stdsTipoDocumento.arr,
				     (char*)stTipoDocumentoRegistro.stidTipoPessoa.arr,
				     (char*)stTipoDocumentoRegistro.stnrPrioridade.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorListPF;
		}
	}
	catch(...)
	{
		throw;
	}

    ULOGI("CTipoDocumento::ListPF <OK>");
    ULOG_END("CTipoDocumento::ListPF");

	return iCont;

GotoListPF:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CTipoDocumento::ListPFFiltrado( void )
{
    ULOG_START("CTipoDocumento::ListPFFiltrado");

	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidTipoDocumento[21+1];
			VARCHAR stsgTipoDocumento[255+1];
			VARCHAR stdsTipoDocumento[255+1];
			VARCHAR stidTipoPessoa[21+1];
			VARCHAR stnrPrioridade[21+1];
            VARCHAR stsgClassificacao[255+1];
		} stTipoDocumentoRegistro;
		struct
		{
			short stidTipoDocumento;
			short stsgTipoDocumento;
			short stdsTipoDocumento;
			short stidTipoPessoa;
			short stnrPrioridade;
            short stsgClassificacao;
		} stTipoDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;

	try
	{
		ZeraTipoDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListPFFiltrado;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
			DECLARE 
				CursorListPFFiltrado CURSOR FOR
                  SELECT 
                    TD.IDTIPODOCUMENTO, 
                    TD.SGCLASSIFICACAO, 
                    TD.DSTIPODOCUMENTO, 
                    TD.IDTIPOPESSOA,
                    TD.NRPRIORIDADE,
                    TD.SGCLASSIFICACAO
                  FROM 
                    APOIO.TIPODOCUMENTO TD,
                    APOIO.TIPOPESSOA    TP
                  WHERE
                    TD.IDTIPOPESSOA = TP.IDTIPOPESSOA AND
                    TP.SGTIPOPESSOA = 'PF' AND
                    TD.SGCLASSIFICACAO NOT IN ('CPR') AND
                    TD.INVISUALIZA = 1
                  ORDER BY
                    TD.DSTIPODOCUMENTO;
	
		EXEC SQL OPEN CursorListPFFiltrado;
	
		if(sqlca.sqlcode)
        {
            ULOGE("CTipoDocumento::ListPFFiltrado <ERROR>");
            ULOG_END("CTipoDocumento::ListPFFiltrado");
			return 0;
        }
		else
		{
			for(;;)
			{
				memset( &stTipoDocumentoRegistro, 0, sizeof(stTipoDocumentoRegistro) );
				memset( &stTipoDocumentoIndicator,-1, sizeof(stTipoDocumentoIndicator) );
				EXEC SQL FETCH CursorListPFFiltrado INTO :stTipoDocumentoRegistro:stTipoDocumentoIndicator;

                CONVIND(stTipoDocumentoRegistro.stidTipoDocumento,stTipoDocumentoIndicator.stidTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stsgTipoDocumento,stTipoDocumentoIndicator.stsgTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stdsTipoDocumento,stTipoDocumentoIndicator.stdsTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stidTipoPessoa   ,stTipoDocumentoIndicator.stidTipoPessoa   );
                CONVIND(stTipoDocumentoRegistro.stnrPrioridade   ,stTipoDocumentoIndicator.stnrPrioridade   );
                CONVIND(stTipoDocumentoRegistro.stsgClassificacao,stTipoDocumentoIndicator.stsgClassificacao);

				Add( (char*)stTipoDocumentoRegistro.stidTipoDocumento.arr, 
				     (char*)stTipoDocumentoRegistro.stsgTipoDocumento.arr, 
				     (char*)stTipoDocumentoRegistro.stdsTipoDocumento.arr,
				     (char*)stTipoDocumentoRegistro.stidTipoPessoa.arr,
				     (char*)stTipoDocumentoRegistro.stnrPrioridade.arr,
                     (char*)stTipoDocumentoRegistro.stsgClassificacao.arr );

				iCont++;
			}
			EXEC SQL CLOSE CursorListPFFiltrado;
		}
	}
	catch(...)
	{
		throw;
	}

    ULOGI("CTipoDocumento::ListPFFiltrado <OK>");
    ULOG_END("CTipoDocumento::ListPFFiltrado");

	return iCont;

GotoListPFFiltrado:
	throw TuxBasicOraException(sqlca.sqlcode);

}


int CTipoDocumento::ListPJ( void )
{
    ULOG_START("CTipoDocumento::ListPJ");

	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidTipoDocumento[21+1];
			VARCHAR stsgTipoDocumento[255+1];
			VARCHAR stdsTipoDocumento[255+1];
			VARCHAR stidTipoPessoa[21+1];
			VARCHAR stnrPrioridade[21+1];
		} stTipoDocumentoRegistro;
		struct
		{
			short stidTipoDocumento;
			short stsgTipoDocumento;
			short stdsTipoDocumento;
			short stidTipoPessoa;
			short stnrPrioridade;
		} stTipoDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;

	try
	{
		ZeraTipoDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListPJ;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
			DECLARE 
				CursorListPJ CURSOR FOR
			SELECT 
		    TD.IDTIPODOCUMENTO, 
		    TD.SGCLASSIFICACAO, 
		    TD.DSTIPODOCUMENTO, 
		    TD.IDTIPOPESSOA,
		    TD.NRPRIORIDADE 
		FROM 
		    APOIO.TIPODOCUMENTO TD,
		    (
		        SELECT
		           A.SGCLASSIFICACAO,
		           A.NRPRIORIDADE,
		           MIN(IDTIPODOCUMENTO) IDTIPODOCUMENTO
		        FROM
		            (
		                SELECT 
		                    SGCLASSIFICACAO,
		                    MIN(NVL(NRPRIORIDADE,100)) NRPRIORIDADE
		                FROM 
		                    APOIO.TIPODOCUMENTO
						WHERE
							IDTIPOPESSOA = ( SELECT IDTIPOPESSOA FROM APOIO.TIPOPESSOA WHERE SGTIPOPESSOA = 'PJ' )
		                GROUP BY
		                    SGCLASSIFICACAO
		             ) A,
		             APOIO.TIPODOCUMENTO B
		        WHERE
		             B.SGCLASSIFICACAO = A.SGCLASSIFICACAO AND
		             NVL(B.NRPRIORIDADE,100) = A.NRPRIORIDADE
		        GROUP BY
		            A.SGCLASSIFICACAO,
		            A.NRPRIORIDADE
		    ) X
		WHERE
		    TD.IDTIPODOCUMENTO = X.IDTIPODOCUMENTO
		ORDER BY
		    TD.DSTIPODOCUMENTO;
	
		EXEC SQL OPEN CursorListPJ;
	
		if(sqlca.sqlcode)
        {
            ULOGE("CTipoDocumento::ListPJ <ERROR>");
            ULOG_END("CTipoDocumento::ListPJ");
			return 0;
        }
		else
		{
			for(;;)
			{
				memset( &stTipoDocumentoRegistro, 0, sizeof(stTipoDocumentoRegistro) );
				memset( &stTipoDocumentoIndicator,-1, sizeof(stTipoDocumentoIndicator) );
				EXEC SQL FETCH CursorListPJ INTO :stTipoDocumentoRegistro:stTipoDocumentoIndicator;

                CONVIND(stTipoDocumentoRegistro.stidTipoDocumento,stTipoDocumentoIndicator.stidTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stsgTipoDocumento,stTipoDocumentoIndicator.stsgTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stdsTipoDocumento,stTipoDocumentoIndicator.stdsTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stidTipoPessoa   ,stTipoDocumentoIndicator.stidTipoPessoa   );
                CONVIND(stTipoDocumentoRegistro.stnrPrioridade   ,stTipoDocumentoIndicator.stnrPrioridade   );

				Add( (char*)stTipoDocumentoRegistro.stidTipoDocumento.arr, 
				     (char*)stTipoDocumentoRegistro.stsgTipoDocumento.arr, 
				     (char*)stTipoDocumentoRegistro.stdsTipoDocumento.arr,
				     (char*)stTipoDocumentoRegistro.stidTipoPessoa.arr,
				     (char*)stTipoDocumentoRegistro.stnrPrioridade.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorListPJ;
		}
	}
	catch(...)
	{
		throw;
	}

    ULOGI("CTipoDocumento::ListPJ <OK>");
    ULOG_END("CTipoDocumento::ListPJ");

	return iCont;

GotoListPJ:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CTipoDocumento::ListPJFiltrado( void )
{
    ULOG_START("CTipoDocumento::ListPJFiltrado");

	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidTipoDocumento[21+1];
			VARCHAR stsgTipoDocumento[255+1];
			VARCHAR stdsTipoDocumento[255+1];
			VARCHAR stidTipoPessoa[21+1];
			VARCHAR stnrPrioridade[21+1];
            VARCHAR stsgClassificacao[255+1];
		} stTipoDocumentoRegistro;
		struct
		{
			short stidTipoDocumento;
			short stsgTipoDocumento;
			short stdsTipoDocumento;
			short stidTipoPessoa;
			short stnrPrioridade;
            short stsgClassificacao;
		} stTipoDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;

	try
	{
		ZeraTipoDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListPJFiltrado;
		sqlca.sqlcode=0;
	
	   	EXEC SQL 
			DECLARE 
				CursorListPJFiltrado CURSOR FOR
                  SELECT 
                    TD.IDTIPODOCUMENTO, 
                    TD.SGCLASSIFICACAO, 
                    TD.DSTIPODOCUMENTO, 
                    TD.IDTIPOPESSOA,
                    TD.NRPRIORIDADE,
                    TD.SGCLASSIFICACAO
                  FROM 
                    APOIO.TIPODOCUMENTO TD,
                    APOIO.TIPOPESSOA    TP
                  WHERE
                    TD.IDTIPOPESSOA = TP.IDTIPOPESSOA AND
                    TP.SGTIPOPESSOA = 'PJ' AND
                    TD.SGCLASSIFICACAO NOT IN ('CCM', 'CNPJ') AND
                    TD.INVISUALIZA = 1
                  ORDER BY
                    TD.DSTIPODOCUMENTO;
	
		EXEC SQL OPEN CursorListPJFiltrado;
	
		if(sqlca.sqlcode)
        {
            ULOGE("CTipoDocumento::ListPJFiltrado <ERROR>");
            ULOG_END("CTipoDocumento::ListPJFiltrado");
			return 0;
        }
		else
		{
			for(;;)
			{
				memset( &stTipoDocumentoRegistro, 0, sizeof(stTipoDocumentoRegistro) );
				memset( &stTipoDocumentoIndicator,-1, sizeof(stTipoDocumentoIndicator) );
				EXEC SQL FETCH CursorListPJFiltrado INTO :stTipoDocumentoRegistro:stTipoDocumentoIndicator;

                CONVIND(stTipoDocumentoRegistro.stidTipoDocumento,stTipoDocumentoIndicator.stidTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stsgTipoDocumento,stTipoDocumentoIndicator.stsgTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stdsTipoDocumento,stTipoDocumentoIndicator.stdsTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stidTipoPessoa   ,stTipoDocumentoIndicator.stidTipoPessoa   );
                CONVIND(stTipoDocumentoRegistro.stnrPrioridade   ,stTipoDocumentoIndicator.stnrPrioridade   );
                CONVIND(stTipoDocumentoRegistro.stsgClassificacao,stTipoDocumentoIndicator.stsgClassificacao);

				Add( (char*)stTipoDocumentoRegistro.stidTipoDocumento.arr, 
				     (char*)stTipoDocumentoRegistro.stsgTipoDocumento.arr, 
				     (char*)stTipoDocumentoRegistro.stdsTipoDocumento.arr,
				     (char*)stTipoDocumentoRegistro.stidTipoPessoa.arr,
				     (char*)stTipoDocumentoRegistro.stnrPrioridade.arr,
                     (char*)stTipoDocumentoRegistro.stsgClassificacao.arr);
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorListPJFiltrado;
		}
	}
	catch(...)
	{
		throw;
	}

    ULOGI("CTipoDocumento::ListPJFiltrado <OK>");
    ULOG_END("CTipoDocumento::ListPJFiltrado");

	return iCont;

GotoListPJFiltrado:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CTipoDocumento::ListPJInscricoes( void )
{
    ULOG_START("CTipoDocumento::ListPJInscricoes");

	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidTipoDocumento[21+1];
			VARCHAR stsgTipoDocumento[255+1];
			VARCHAR stdsTipoDocumento[255+1];
			VARCHAR stidTipoPessoa[21+1];
			VARCHAR stnrPrioridade[21+1];
            VARCHAR stsgClassificacao[255+1];
		} stTipoDocumentoRegistro;
		struct
		{
			short stidTipoDocumento;
			short stsgTipoDocumento;
			short stdsTipoDocumento;
			short stidTipoPessoa;
			short stnrPrioridade;
            short stsgClassificacao;
		} stTipoDocumentoIndicator;
	EXEC SQL END DECLARE SECTION;

	try
	{
		ZeraTipoDocumento();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListPJInscricoes;
		sqlca.sqlcode=0;
		
		
		//Recupera as inscricoes:
		//	INSCRIÇÃO ESTADUAL
		//	INSCRIÇÃO FEDERAL
		//	INSCRIÇÃO MUNICIPAL
	   	EXEC SQL 
			DECLARE 
				CursorListPJInscricoes CURSOR FOR
                    SELECT 
                        TD.IDTIPODOCUMENTO, 
                        TD.SGCLASSIFICACAO, 
                        TD.DSTIPODOCUMENTO, 
                        TD.IDTIPOPESSOA,
                        TD.NRPRIORIDADE,
                        TD.SGCLASSIFICACAO
                    FROM 
                        APOIO.TIPODOCUMENTO TD,
                        APOIO.TIPOPESSOA TP
                    WHERE
                        TD.SGCLASSIFICACAO IN('IE', 'IF', 'IM', 'II') AND
                        TD.INVISUALIZA = 1 AND
                        TD.IDTIPOPESSOA = TP.IDTIPOPESSOA AND
                        TP.SGTIPOPESSOA = 'PJ'
                    ORDER BY
                        TD.DSTIPODOCUMENTO;
	
		EXEC SQL OPEN CursorListPJInscricoes;
	
		if(sqlca.sqlcode)
        {
            ULOGE("CTipoDocumento::ListPJInscricoes <ERROR>");
            ULOG_END("CTipoDocumento::ListPJInscricoes");
			return 0;
        }
		else
		{
			for(;;)
			{
				memset( &stTipoDocumentoRegistro, 0, sizeof(stTipoDocumentoRegistro) );
				memset( &stTipoDocumentoIndicator,-1, sizeof(stTipoDocumentoIndicator) );
				EXEC SQL FETCH CursorListPJInscricoes INTO :stTipoDocumentoRegistro:stTipoDocumentoIndicator;

                CONVIND(stTipoDocumentoRegistro.stidTipoDocumento,stTipoDocumentoIndicator.stidTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stsgTipoDocumento,stTipoDocumentoIndicator.stsgTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stdsTipoDocumento,stTipoDocumentoIndicator.stdsTipoDocumento);
                CONVIND(stTipoDocumentoRegistro.stidTipoPessoa   ,stTipoDocumentoIndicator.stidTipoPessoa   );
                CONVIND(stTipoDocumentoRegistro.stnrPrioridade   ,stTipoDocumentoIndicator.stnrPrioridade   );
                CONVIND(stTipoDocumentoRegistro.stsgClassificacao,stTipoDocumentoIndicator.stsgClassificacao);

				Add( (char*)stTipoDocumentoRegistro.stidTipoDocumento.arr, 
				     (char*)stTipoDocumentoRegistro.stsgTipoDocumento.arr, 
				     (char*)stTipoDocumentoRegistro.stdsTipoDocumento.arr,
				     (char*)stTipoDocumentoRegistro.stidTipoPessoa.arr,
				     (char*)stTipoDocumentoRegistro.stnrPrioridade.arr,
                     (char*)stTipoDocumentoRegistro.stsgClassificacao.arr);
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorListPJInscricoes;
		}
	}
	catch(...)
	{
		throw;
	}

    ULOGI("CTipoDocumento::ListPJInscricoes <OK>");
    ULOG_END("CTipoDocumento::ListPJInscricoes");

	return iCont;

GotoListPJInscricoes:
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CTipoDocumento::getXmlBasico( char* cNomeTag, XMLGen*xml )
{
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			if( Registro( x ) != NULL )
			{
				xml->addItem("idTipoDocumento"  , Registro(x)->cidTipoDocumento );
				xml->addItem("sgTipoDocumento"  , Registro(x)->csgTipoDocumento );
				xml->addItem("dsTipoDocumento"  , Registro(x)->cdsTipoDocumento );
				xml->addItem("idTipoPessoa", Registro(x)->cidTipoPessoa );
				xml->addItem("nrPrioridade", Registro(x)->cnrPrioridade );
			}
			xml->closeTag();
		}
	}
}

void CTipoDocumento::getXmlCombo( char* cNomeTag,
                                  char* cidTag,
                                  char* cdsTag,
                                  XMLGen* xml )
{
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			if( Registro( x ) != NULL )
			{
				xml->addItem( cidTag , Registro(x)->cidTipoDocumento );
				xml->addItem( cdsTag , Registro(x)->cdsTipoDocumento );
			}
			xml->closeTag();
		}
	}
}

void CTipoDocumento::getXmlCombo( char* cNomeTag,
                                  char* cidTag,
                                  char* csgTag,
                                  char* cdsTag,
                                  XMLGen* xml )
{
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			if( Registro( x ) != NULL )
			{
				xml->addItem( cidTag , Registro(x)->cidTipoDocumento );
				xml->addItem( csgTag , Registro(x)->csgTipoDocumento );
				xml->addItem( cdsTag , Registro(x)->cdsTipoDocumento );
			}
			xml->closeTag();
		}
	}
}

void CTipoDocumento::getXmlCombo2( char* cNomeTag,
                                  char* cidTag,
                                  char* csgTag,
                                  char* cdsTag,
                                  XMLGen* xml )
{
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			if( Registro( x ) != NULL )
			{
				xml->addItem( cidTag , Registro(x)->csgClassificacao );
				xml->addItem( csgTag , Registro(x)->csgTipoDocumento );
				xml->addItem( cdsTag , Registro(x)->cdsTipoDocumento );
			}
			xml->closeTag();
		}
	}
}

void CTipoDocumento::getXmlComboSemRepetencia( char* cNomeTag,
                                               char* cidTag,
                                               char* csgTag,
                                               char* cdsTag,
                                               XMLGen* xml )
{
	int  iPrioridade = 0;
	struct
	{
		char cidTipoDocumento[21+1];
		char csgTipoDocumento[255+1];
		char cdsTipoDocumento[255+1];
		char cnrPrioridade[21+1];
	}stTipoDocumento;
	memset( &stTipoDocumento, 0, sizeof( stTipoDocumento ) );
	if( Quantidade() > 0 )
	{
		strcpy( stTipoDocumento.cidTipoDocumento, Registro(0)->cidTipoDocumento );
		strcpy( stTipoDocumento.csgTipoDocumento, Registro(0)->csgTipoDocumento );
		strcpy( stTipoDocumento.cdsTipoDocumento, Registro(0)->cdsTipoDocumento );
		strcpy( stTipoDocumento.cnrPrioridade   , Registro(0)->cnrPrioridade    );
		for( int x = 0; x < Quantidade(); x++ )
		{
			if( strcmp( Registro(x)->cdsTipoDocumento, stTipoDocumento.cdsTipoDocumento ) != 0 )
			{
				xml->createTag(cNomeTag);
				if( Registro( x ) != NULL )
				{
					xml->addItem( cidTag , stTipoDocumento.cidTipoDocumento );
					xml->addItem( csgTag , stTipoDocumento.csgTipoDocumento );
					xml->addItem( cdsTag , stTipoDocumento.cdsTipoDocumento );
				}
				xml->closeTag();

				memset( &stTipoDocumento, 0, sizeof( stTipoDocumento ) );
				strcpy( stTipoDocumento.cidTipoDocumento, Registro(x)->cidTipoDocumento );
				strcpy( stTipoDocumento.csgTipoDocumento, Registro(x)->csgTipoDocumento );
				strcpy( stTipoDocumento.cdsTipoDocumento, Registro(x)->cdsTipoDocumento );
				strcpy( stTipoDocumento.cnrPrioridade   , Registro(x)->cnrPrioridade    );

			}// if( strcmp( Registro(x)->cdsTipoDocumento, stTipoDocumento.cdsTipoDocumento ) != 0 )
			else
			{
				if( atoi( stTipoDocumento.cnrPrioridade ) > atoi( Registro(x)->cnrPrioridade ) )
				{
					memset( &stTipoDocumento, 0, sizeof( stTipoDocumento ) );
					strcpy( stTipoDocumento.cidTipoDocumento, Registro(x)->cidTipoDocumento );
					strcpy( stTipoDocumento.csgTipoDocumento, Registro(x)->csgTipoDocumento );
					strcpy( stTipoDocumento.cdsTipoDocumento, Registro(x)->cdsTipoDocumento );
					strcpy( stTipoDocumento.cnrPrioridade   , Registro(x)->cnrPrioridade    );
				}
			}//else if( strcmp( Registro(x)->cdsTipoDocumento, stTipoDocumento.cdsTipoDocumento ) != 0 )

			if( x == ( Quantidade()-1 ) )
			{
				xml->createTag(cNomeTag);
				if( Registro( x ) != NULL )
				{
					xml->addItem( cidTag , stTipoDocumento.cidTipoDocumento );
					xml->addItem( csgTag , stTipoDocumento.csgTipoDocumento );
					xml->addItem( cdsTag , stTipoDocumento.cdsTipoDocumento );
				}
				xml->closeTag();
			}//if( x == Quantidade() )
		}//for( int x = 0; x < Quantidade(); x++ )
	}//if( Quantidade() > 0 )
}
