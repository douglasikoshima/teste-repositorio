#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include <CPais.h>

CPais::CPais()
{
}

CPais::~CPais()
{
}

int CPais::ListId( char* cid )
{
    ULOG_START("CPais::ListId");

	int    iCont = 0;
	struct sqlca sqlca;

    if ( cid && *cid )
    {
	    EXEC SQL BEGIN DECLARE SECTION;
		    char* cidOra = cid;
		    struct
		    {
			    VARCHAR stId[21+1];
			    VARCHAR stSigla[255+1];
			    VARCHAR stDescricao[255+1];
			    VARCHAR stdsNacionalidade[255+1];
		    } stPaisRegistro;
		    struct
		    {
			    short iId;
			    short iSigla;
			    short iDescricao;
			    short idsNacionalidade;
		    } stPaisIndicator;
	    EXEC SQL END DECLARE SECTION;
	    try
	    {

		    ZeraPais();
	    
		    EXEC SQL WHENEVER NOT FOUND DO break;
		    EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		    sqlca.sqlcode=0;
	    
	   	    EXEC SQL DECLARE CursorPaisId CURSOR FOR
			    SELECT IDPAIS, 
			           SGPAIS, 
			           NMPAIS, 
			           DSNACIONALIDADE 
			      FROM APOIO.PAIS
			     WHERE IDPAIS = :cidOra;
	    
		    EXEC SQL OPEN CursorPaisId;
	    
		    if(sqlca.sqlcode)
            {
                ULOGE("CPais::ListId <ERROR>");
                ULOG_END("CPais::ListId");
			    return 0;
            }
		    else
		    {
			    for(;;)
			    {
				    memset( &stPaisRegistro, 0, sizeof(stPaisRegistro) );
				    EXEC SQL FETCH CursorPaisId INTO :stPaisRegistro:stPaisIndicator;
	    
				    Add( (char*)stPaisRegistro.stId.arr, (char*)stPaisRegistro.stSigla.arr, (char*)stPaisRegistro.stDescricao.arr, (char*)stPaisRegistro.stdsNacionalidade.arr );
	    
				    iCont++;
	    
			    }
			    EXEC SQL CLOSE CursorPaisId;
		    }
	    }
	    catch(...)
	    {
		    throw;
	    }
    } // if ( cid && *cid )

    ULOGI("CPais::ListId <OK>");
    ULOG_END("CPais::ListId");

	return iCont;

GotoListId:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CPais::ListAll( void )
{
    ULOG_START("CPais::ListAll");

	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stId[21+1];
			VARCHAR stSigla[255+1];
			VARCHAR stDescricao[255+1];
			VARCHAR stdsNacionalidade[255+1];
		} stPaisRegistro;
		struct
		{
			short iId;
			short iSigla;
			short iDescricao;
			short idsNacionalidade;
		} stPaisIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{
		ZeraPais();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;
	
	   	EXEC SQL DECLARE CursorPaisAll CURSOR FOR
			SELECT IDPAIS, 
			       SGPAIS, 
			       NMPAIS, 
			       DSNACIONALIDADE 
			  FROM APOIO.PAIS
			 WHERE  INPREENCHELISTA=1
			 ORDER BY NMPAIS;
	
		EXEC SQL OPEN CursorPaisAll;
	
		if(sqlca.sqlcode)
        {
            ULOGE("CPais::ListAll <ERROR>");
            ULOG_END("CPais::ListAll");
			return 0;
        }
		else
		{
			for(;;)
			{
				memset( &stPaisRegistro, 0, sizeof(stPaisRegistro) );
				EXEC SQL FETCH CursorPaisAll INTO :stPaisRegistro:stPaisIndicator;
	
				Add( (char*)stPaisRegistro.stId.arr, (char*)stPaisRegistro.stSigla.arr, (char*)stPaisRegistro.stDescricao.arr, (char*)stPaisRegistro.stdsNacionalidade.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorPaisAll;
		}
	}
	catch(...)
	{
		throw;
	}

    ULOGI("CPais::ListAll <OK>");
    ULOG_END("CPais::ListAll");
	
	return iCont;

GotoListAll:
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CPais::ListSigla( char* csgPais )
{
    ULOG_START("CPais::ListSigla");

	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxsgPais = csgPais;
		struct
		{
			VARCHAR stId[21+1];
			VARCHAR stSigla[255+1];
			VARCHAR stDescricao[255+1];
			VARCHAR stdsNacionalidade[255+1];
		} stPaisRegistro;
		struct
		{
			short iId;
			short iSigla;
			short iDescricao;
			short idsNacionalidade;
		} stPaisIndicator;
	EXEC SQL END DECLARE SECTION;
	try
	{
		ZeraPais();
	
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListSigla;
		sqlca.sqlcode=0;
	
	   	EXEC SQL DECLARE CursorListSigla CURSOR FOR
			SELECT PAIS.IDPAIS
			      ,PAIS.SGPAIS 
			      ,PAIS.NMPAIS 
			      ,PAIS.DSNACIONALIDADE 
			  FROM APOIO.PAIS PAIS
			 WHERE PAIS.SGPAIS = :cAuxsgPais
			   AND IDPAIS > 0;
	
		EXEC SQL OPEN CursorListSigla;
	
		if(sqlca.sqlcode)
        {
            ULOGE("CPais::ListSigla <ERROR>");
            ULOG_END("CPais::ListSigla");
			return 0;
        }
		else
		{
			for(;;)
			{
				memset( &stPaisRegistro, 0, sizeof(stPaisRegistro) );
				EXEC SQL FETCH CursorListSigla INTO :stPaisRegistro:stPaisIndicator;
	
				Add( (char*)stPaisRegistro.stId.arr
				    ,(char*)stPaisRegistro.stSigla.arr
				    ,(char*)stPaisRegistro.stDescricao.arr
				    ,(char*)stPaisRegistro.stdsNacionalidade.arr );
	
				iCont++;
	
			}
			EXEC SQL CLOSE CursorListSigla;
		}
	}
	catch(...)
	{
		throw;
	}
	
    ULOGI("CPais::ListSigla <OK>");
    ULOG_END("CPais::ListSigla");

	return iCont;

GotoListSigla:
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CPais::GetXml( char* cNomeTag, XMLGen*xml )
{
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			xml->addProp(	"xmlns", "usuario.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{
				xml->addItem("idPais"  , Registro(x)->cidPais   );
				xml->addItem("sgPais"  , Registro(x)->csgPais   );
				xml->addItem("dsPais"  , Registro(x)->cdsPais   );
				xml->addItem("indisponibilidade", Registro(x)->cdsNacionalidade );
			}
			xml->closeTag();
		}
	}
}
