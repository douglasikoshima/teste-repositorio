#include "Util.h"

#include <string>
#include <cstring>
#include <cctype>
#include <cmath>
#include <cstdlib>

using namespace std;


char* Util::rtrim(char *pStr)
{
	int rInd;

	if (pStr == NULL)
			return NULL;

   rInd = strlen(pStr) - 1;
   while ( isspace(pStr[rInd]) && rInd >= 0){
      rInd--;
   }

   pStr[rInd + 1] = '\0';
   
   return pStr;
}

char* Util::ltrim(char *pStr)
{
	int lInd = 0;

	if (pStr == NULL)
			return NULL;

    //rInd = strlen(pStr) - 1;

    while (isspace(pStr[lInd])){
        lInd++;
	}

	pStr = pStr + lInd;
     
   return pStr;
}

char* Util::trim(char *pStr){
	return ltrim(rtrim(pStr));		
}

char* Util::upper(char *pTok)
{ 
	char* p = pTok;

    while(*p != '\0'){
       *p = toupper(*p);
	   p++;
	}
	return pTok;
}

void Util::trim(string& strValue)
{
  string::size_type posBegin = strValue.find_first_not_of(' ');
  string::size_type posEnd = strValue.find_last_not_of(' ');
  
  string::size_type pInit;
  string::size_type pEnd;

  if( posBegin == string::npos )
	pInit = 0;
  else
	pInit = posBegin;


  if( posEnd == string::npos )
	pEnd = strValue.length() - 1;
  else
	pEnd = posEnd - posBegin + 1;
	  
  strValue = strValue.substr(pInit,pEnd);

}

string Util::intToStr(int iNumber) 
{
	stringstream ssTemp;
	ssTemp << iNumber;
	return ssTemp.str();
}


long Util::pot(int base, int potencia) {

	long returnValue = 1;

	if (base == 0)
		return 1;

	if (potencia > 0)
		for (int i=0;i < potencia; i++)
			returnValue *= base;
	else
		for (int i=0; i < (potencia*(-1)); i++)
			returnValue /= base;

	return returnValue;
}

unsigned long Util::HexaToLong(char *hex) {

	char cCaracter;
	int iValorDec;
	unsigned long dValorFinal = 0;
	int iSz = strlen(hex);

	for (unsigned int i=iSz; i > 0; i--) {
		cCaracter = hex[i-1];

		switch ((int)cCaracter){
			case 97: case 65: iValorDec = 10; break;
			case 98: case 66: iValorDec = 11; break;
			case 99: case 67: iValorDec = 12; break;
			case 100: case 68: iValorDec = 13; break;
			case 101: case 69: iValorDec = 14; break;
			case 102: case 70: iValorDec = 15; break;
			default: iValorDec = (int)cCaracter - 48;
		}

		dValorFinal += iValorDec*((long)pot(16,(iSz-i)));
	}

	return dValorFinal;
}

/************************************************************************
 * Funcao: Verifica se em um buffer contem somente caracter numerico.   *
 * Parametro: d = dado para realizar a verificacao.                     *
 * Retorno: 0 = contem caracter diferente de numerico                   *
 *          1 = contem somente caracter numerico                        *
 ************************************************************************/
int Util::IsNumeric(char* d){
    for(; *d; d++ )
       if ( !isdigit(*d) )
            return 0;
    return 1;
}

bool Util::cmp(char *s1, char *s2)
{
	if ((s1 == NULL) || (s2 == NULL)) return false;

	int l1 = strlen(s1), l2 = strlen(s2);

	if (l1 != l2) return false;

	if (memcmp(s1, s2, l1) == 0)
		return true;
	else
		return false;
}

bool Util::isNum(char *s)
{
	if (s == NULL) return false;

	unsigned int l = strlen(s);

	if (!l) return false;

	for (unsigned int i = 0; i < l; i++)
		if (isdigit(*(s + i)) == 0) return false;

	return true;
}

/************************************************************************
 * Funcao: Faz conversão de datas                                       *
 *                                                                      * 
 * Parametros:                                                          *
 * 		dt  = String com a data (Ex: "1984-03-06 18:45:01")             *
 * 		df  = Formato da data (Ex: "YYYY-MM-DD hh:mm:ss")               *
 * 		rdf = Formato de saida da data (Ex: "DD/MM/YYYY hh:mm")         *
 *                                                                      *
 * YYYY = 2004                                                          *
 * YY   = 04                                                            *
 * MM   = 12                                                            *
 * MAB  = JAN                                                           *
 * DD   = 31                                                            *
 *                                                                      *
 * Retorno: String com a data no formato rdf                            *
 ************************************************************************/
/*
char* Util::convertDate(char *dateString, char *dateFormat, char *returnDateFormat)
{
	if ((dateString == NULL) || (! *dateString))
		return NULL;

	char YYYY[] = "YYYY";
	char YY[]   = "YY";
	char MM[]   = "MM";
	char MAB[]  = "MAB";
	char DD[]   = "DD";
	char hh[]   = "hh";
	char mm[]   = "mm";
	char ss[]   = "ss";

	char MA[][4] = {"JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"};

	string  dtStr = dateString;
	string  dtFmt = dateFormat;
	string* rdtFmt = new string(returnDateFormat);
	
	try {
		int m = atoi(dtStr.substr(dtFmt.find(MM), strlen(MM)).c_str());

		if((m > 0) && (m < 13))
			rdtFmt->replace(rdtFmt->find(MAB), strlen(MAB), MA[(m-1)]);
	} catch (...){};

	try {
		string mab = dtStr.substr(dtFmt.find(MAB), strlen(MAB));

		for (int i = 0; i < 12; i++)
		{
			if (strcmp(mab.c_str(), MA[i]) == 0)
			{
				char M[3];
				sprintf(M, "%.2d", ++i);
				
				rdtFmt->replace(rdtFmt->find(MM), strlen(MM), M);
				break;	
			}
		}
	} catch(...){};

	try {
		rdtFmt->replace(rdtFmt->find(DD), strlen(DD), dtStr.substr(dtFmt.find(DD), strlen(DD)));
	} catch(...){}

	try {
		rdtFmt->replace(rdtFmt->find(MM), strlen(MM), dtStr.substr(dtFmt.find(MM), strlen(MM)));
	} catch(...){}

	try {
		rdtFmt->replace(rdtFmt->find(YYYY), strlen(YYYY), dtStr.substr(dtFmt.find(YYYY), strlen(YYYY)));
	} catch(...){}

	try {
		string sb = dtStr.substr(dtFmt.find(YY), strlen(YY));

		string tmp;

		if (atoi(sb.c_str()) > 50)
			tmp = "19" + sb;
		else
			tmp = "20" + sb;

		rdtFmt->replace(rdtFmt->find(YYYY), strlen(YYYY), tmp);
	} catch(...){}

	try {
		int fi = dtFmt.find(YYYY);
		
		if (fi != -1)
			rdtFmt->replace(rdtFmt->find(YY), strlen(YY), dtStr.substr((fi+strlen(YY)), strlen(YYYY)));
	} catch(...){}

	try {
		rdtFmt->replace(rdtFmt->find(YY), strlen(YY), dtStr.substr(dtFmt.find(YY), strlen(YY)));
	} catch(...){}

	try {
		rdtFmt->replace(rdtFmt->find(hh), strlen(hh), dtStr.substr(dtFmt.find(hh), strlen(hh)));
	} catch(...){}

	try {
		rdtFmt->replace(rdtFmt->find(mm), strlen(mm), dtStr.substr(dtFmt.find(mm), strlen(mm)));
	} catch(...){}

	try {
		rdtFmt->replace(rdtFmt->find(ss), strlen(ss), dtStr.substr(dtFmt.find(ss), strlen(ss)));
	} catch(...){}

	char* pc_formatedDate = (char*) rdtFmt->c_str();

	char *formatedDate = new char[strlen(pc_formatedDate) + 1];

	strcpy(formatedDate, pc_formatedDate);

	delete rdtFmt;

	return formatedDate;
}
*/
/************************************************************************
 * Funcao: Faz conversão de datas                                       *
 *                                                                      * 
 * Parametros:                                                          *
 *      newDate = String com retorno da nova data
 * 		dt  = String com a data (Ex: "1984-03-06 18:45:01")             *
 * 		df  = Formato da data (Ex: "YYYY-MM-DD hh:mm:ss")               *
 * 		rdf = Formato de saida da data (Ex: "DD/MM/YYYY hh:mm")         *
 *                                                                      *
 * YYYY = 2004                                                          *
 * YY   = 04                                                            *
 * MM   = 12                                                            *
 * MAB  = JAN                                                           *
 * DD   = 31                                                            *
 *                                                                      *
 * Retorno: String com a data no formato rdf                            *
 ************************************************************************/
char* Util::formateDate(char *newDate, char *dateString, char *dateFormat, char *returnDateFormat)
{
	if ((dateString == NULL) || (! *dateString))
	{
		strcpy(newDate, "");
		return newDate;
	}

	char YYYY[] = "YYYY";
	char YY[]   = "YY";
	char MM[]   = "MM";
	char MAB[]  = "MAB";
	char DD[]   = "DD";
	char hh[]   = "hh";
	char mm[]   = "mm";
	char ss[]   = "ss";

	char MA[][4] = {"JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"};

	string  dtStr = dateString;
	string  dtFmt = dateFormat;
	string* rdtFmt = new string(returnDateFormat);
	
	try {
		int m = atoi(dtStr.substr(dtFmt.find(MM), strlen(MM)).c_str());

		if((m > 0) && (m < 13))
			rdtFmt->replace(rdtFmt->find(MAB), strlen(MAB), MA[(m-1)]);
	} catch (...){};

	try {
		string mab = dtStr.substr(dtFmt.find(MAB), strlen(MAB));

		for (int i = 0; i < 12; i++)
		{
			if (strcmp(mab.c_str(), MA[i]) == 0)
			{
				char M[3];
				sprintf(M, "%.2d", ++i);
				
				rdtFmt->replace(rdtFmt->find(MM), strlen(MM), M);
				break;	
			}
		}
	} catch(...){};

	try {
		rdtFmt->replace(rdtFmt->find(DD), strlen(DD), dtStr.substr(dtFmt.find(DD), strlen(DD)));
	} catch(...){}

	try {
		rdtFmt->replace(rdtFmt->find(MM), strlen(MM), dtStr.substr(dtFmt.find(MM), strlen(MM)));
	} catch(...){}

	try {
		rdtFmt->replace(rdtFmt->find(YYYY), strlen(YYYY), dtStr.substr(dtFmt.find(YYYY), strlen(YYYY)));
	} catch(...){}

	try {
		string sb = dtStr.substr(dtFmt.find(YY), strlen(YY));

		string tmp;

		if (atoi(sb.c_str()) > 50)
			tmp = "19" + sb;
		else
			tmp = "20" + sb;

		rdtFmt->replace(rdtFmt->find(YYYY), strlen(YYYY), tmp);
	} catch(...){}

	try {
		int fi = dtFmt.find(YYYY);
		
		if (fi != -1)
			rdtFmt->replace(rdtFmt->find(YY), strlen(YY), dtStr.substr((fi+strlen(YY)), strlen(YYYY)));
	} catch(...){}

	try {
		rdtFmt->replace(rdtFmt->find(YY), strlen(YY), dtStr.substr(dtFmt.find(YY), strlen(YY)));
	} catch(...){}

	try {
		rdtFmt->replace(rdtFmt->find(hh), strlen(hh), dtStr.substr(dtFmt.find(hh), strlen(hh)));
	} catch(...){}

	try {
		rdtFmt->replace(rdtFmt->find(mm), strlen(mm), dtStr.substr(dtFmt.find(mm), strlen(mm)));
	} catch(...){}

	try {
		rdtFmt->replace(rdtFmt->find(ss), strlen(ss), dtStr.substr(dtFmt.find(ss), strlen(ss)));
	} catch(...){}

	strcpy(newDate, (char*) rdtFmt->c_str());

	delete rdtFmt;

	return newDate;
}


#include <tuxfw.h>
#include <sqlca.h>

// Busca IdContaSistemaOrigem
char* Util::getIdContaSistemaOrigem(char* pc_IdContaSistemaOrigem, char* pc_Line)
{
	if ((pc_Line == NULL) || (! isNum(pc_Line)))
		return NULL;

	if (strlen(pc_Line) < 10 || strlen(pc_Line) > 11 )
		return NULL;

	char vc_DDD[3];
	char vc_Fone[10];

	memset(vc_DDD, '\0', sizeof(vc_DDD));
	memset(vc_Fone, '\0', sizeof(vc_Fone));

	strncpy(vc_DDD, pc_Line, 2);
	sprintf(vc_Fone, "%s", (char*)&pc_Line[2] );


	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		unsigned int i_idAreaRegistro;
		unsigned int i_nrLinha;
		char         c_idContaSistemaOrigem[256];
		int iInPagadora;
		int iIdConta;
		int iIdContaAnterior;
	EXEC SQL END DECLARE SECTION;

	i_idAreaRegistro = atoi(vc_DDD);
	i_nrLinha = atoi(vc_Fone);
	iInPagadora = 0;
	iIdConta = 0;

	memset(c_idContaSistemaOrigem, 0, sizeof(c_idContaSistemaOrigem));

	//EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	// Faz a consulta no banco de dados
	EXEC SQL
		SELECT 
			e.idconta,idContaSistemaOrigem,NVL(e.INPAGADORA,0) AS INPAGADORA
		INTO
			:iIdConta,:c_idContaSistemaOrigem,:iInPagadora
		FROM
			apoio.AreaRegistro 	 a,
			linha.LinhaBase 		 b,
			linha.LinhaTelefonica  c,
			customer.LinhaConta 	 d,
			customer.Conta 		 e
		WHERE
			a.idAreaRegistro 		= b.idAreaRegistro
		AND	   
			b.idLinhaBase			= c.idLinhaBase
		AND
			c.idLinhaTelefonica		= d.idLinhaTelefonica
		AND
			d.idConta				= e.idConta
		AND
			a.cdAreaRegistro		= :i_idAreaRegistro
		AND
			b.nrLinha				= :i_nrLinha
		AND	   
			d.idTipoRelacionamento	= 2
		AND
			rownum 					= 1;

	if(sqlca.sqlcode == 1403)
	{
		return NULL;
	}
	else
	{
		while(iInPagadora == 0)
		{
			memset(&c_idContaSistemaOrigem,0,sizeof(c_idContaSistemaOrigem));
			iInPagadora = 0;
			iIdContaAnterior = iIdConta;
			iIdConta = 0;
			EXEC SQL
			SELECT 
				NVL(CONTA.IDCONTASISTEMAORIGEM,' '),
				NVL(CONTA.INPAGADORA,0) AS INPAGADORA
			INTO	:c_idContaSistemaOrigem,:iInPagadora
			FROM
				CUSTOMER.CONTA  CONTA,
				CUSTOMER.CONTAHIERARQUIA  CONTAHIERARQUIA
			WHERE
				CONTA.IDCONTA = CONTAHIERARQUIA.IDCONTAPAI
				AND CONTAHIERARQUIA.IDCONTA = :iIdContaAnterior;
			
			if(sqlca.sqlcode == 1403)
			{
				return NULL;
			}
		}
	}
	
	strcpy(pc_IdContaSistemaOrigem, Util::trim(c_idContaSistemaOrigem));

	tuxfw_getlogger()->debug("IdContaSistemaOrigem: %s", pc_IdContaSistemaOrigem);

	return pc_IdContaSistemaOrigem;

	//OraNoDataFound:
	//	return NULL;

	OraException:
		return NULL;

}

int Util::getDadosPessoa(char*nomePessoa,char*cpf,char*linha,char*ddd)
{
	tuxfw_getlogger()->debug("Util::getDadosPessoa");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cNomePessoa[256];
		VARCHAR cCpf[256];
		char*cLinha = linha;
		char*cDdd = ddd;
	EXEC SQL END DECLARE SECTION;
	memset(&cNomePessoa,0,256);
	memset(&cCpf,0,256);
	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;
	EXEC SQL WHENEVER SQLERROR GOTO OraException;
	EXEC SQL
		SELECT 
			NVL(PESSOA.NMPESSOA,' '),
			NVL(DOCUMENTO.NRDOCUMENTO,' ')
		INTO
			:cNomePessoa,:cCpf
		FROM
			CUSTOMER.PESSOALINHA  PESSOALINHA,
			LINHA.LINHABASE  LINHABASE,
			LINHA.LINHATELEFONICA  LINHATELEFONICA,
			APOIO.AREAREGISTRO  AREAREGISTRO,
			CUSTOMER.PESSOADEPARA  PESSOADEPARA,
			CUSTOMER.PESSOA  PESSOA,
			CUSTOMER.PESSOADOCUMENTO  PESSOADOCUMENTO,
			CUSTOMER.DOCUMENTO  DOCUMENTO,
			APOIO.TIPODOCUMENTO  TIPODOCUMENTO
		WHERE
			AREAREGISTRO.CDAREAREGISTRO = :cDdd AND
			LINHABASE.NRLINHA = :cLinha AND
			LINHABASE.IDLINHABASE = LINHATELEFONICA.IDLINHABASE AND
			AREAREGISTRO.IDAREAREGISTRO = LINHABASE.IDAREAREGISTRO AND
			PESSOALINHA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA AND
			PESSOALINHA.IDTIPORELACIONAMENTO = 2 AND
			PESSOALINHA.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA AND
			PESSOADEPARA.IDPESSOA = PESSOA.IDPESSOA AND
			PESSOADOCUMENTO.IDPESSOA = PESSOA.IDPESSOA AND
			PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO AND
			DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO AND
			TIPODOCUMENTO.SGCLASSIFICACAO = 'CPF';

	strcpy(nomePessoa,(char*)cNomePessoa.arr);
	strcpy(cpf,(char*)cCpf.arr);

	return 1;

	OraNoDataFound:
		tuxfw_getlogger()->debug("getDadosPessoa: Linha não encontrada no banco");
		return 0;
	OraException:
		throw TuxBasicOraException(sqlca.sqlcode);
}

// Verifica se uma linha é válida
int Util::isValidLine(char* pc_Line)
{
	if ((pc_Line == NULL) || (! isNum(pc_Line)))
		return false;

	if (strlen(pc_Line) < 10 || strlen(pc_Line) > 11 )
		return false;

	char vc_DDD[3];
	char vc_Fone[10];

	memset(vc_DDD, '\0', sizeof(vc_DDD));
	memset(vc_Fone, '\0', sizeof(vc_Fone));

	strncpy(vc_DDD, pc_Line, 2);
	// strncpy(vc_Fone, (pc_Line + 2), 8);
	sprintf(vc_Fone, "%s", (char*)&pc_Line[2] );


	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		unsigned int i_idLinhaBase;
		unsigned int i_idEstadoLinha;
		unsigned int i_idAreaRegistro;
		unsigned int i_nrLinha;
		VARCHAR i_sgClassificacao[256];
	EXEC SQL END DECLARE SECTION;

	i_idLinhaBase = 0;
	i_idEstadoLinha = 0;
	i_idAreaRegistro = atoi(vc_DDD);
	i_nrLinha = atoi(vc_Fone);
	memset(&i_sgClassificacao,0,sizeof(i_sgClassificacao));

	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	// Faz a consulta no banco de dados
	EXEC SQL 
		SELECT
			idlinhabase,
			estadolinha.SGCLASSIFICACAO
		INTO
			:i_idLinhaBase,
			:i_sgClassificacao
		FROM
			linha.linhabase  lin, apoio.arearegistro  area,
			apoio.estadolinha  estadolinha 
		WHERE
			lin.idarearegistro = area.idarearegistro and
			lin.IDESTADOLINHA = estadolinha.IDESTADOLINHA
		AND
			area.cdarearegistro = :i_idAreaRegistro
		AND
			lin.nrlinha = :i_nrLinha;		

	if (i_idLinhaBase > 0)
	{
		tuxfw_getlogger()->debug("isValidLine: Linha encontrada no banco");

		if(!strcmp((char*)i_sgClassificacao.arr,"A"))
		{
			tuxfw_getlogger()->debug("isValidLine: Linha ativa");
		 	return 1;
		}
		else
		{
			tuxfw_getlogger()->debug("isValidLine: Linha não está ativa");
		 	return -1;
		}
	}
	else
	{
		tuxfw_getlogger()->debug("isValidLine: Linha não encontrada no banco");
		return 0;
	}

	OraNoDataFound:
		tuxfw_getlogger()->debug("isValidLine: Linha não encontrada no banco");
		return 0;

	OraException:
		throw TuxBasicOraException(sqlca.sqlcode);
}

// Informa a quantidade de favoritos da UF
int Util::getQtFavoritos(char* pc_Line)
{
	if ((pc_Line == NULL) || (! isNum(pc_Line)))
		return -1;

	if (strlen(pc_Line) < 10 || strlen(pc_Line) > 11 )
		return -1;

	char vc_DDD[3];
	char vc_Fone[10];

	memset(vc_DDD, '\0', sizeof(vc_DDD));
	memset(vc_Fone, '\0', sizeof(vc_Fone));

	strncpy(vc_DDD, pc_Line, 2);
	// strncpy(vc_Fone, (pc_Line + 2), 8);
	sprintf(vc_Fone, "%s", (char*)&pc_Line[2] );

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		unsigned int i_idAreaRegistro;
		unsigned int i_nrLinha;
		unsigned int i_idTipoRelacionamento;
		unsigned int i_qtFavoritos;
	EXEC SQL END DECLARE SECTION;

	i_idAreaRegistro = atoi(vc_DDD);
	i_nrLinha = atoi(vc_Fone);
	i_idTipoRelacionamento = PESSOA_CLIENTE;

	i_qtFavoritos = 0;

	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	// Faz a consulta no banco de dados
	EXEC SQL
		SELECT
			FavoritoUF.QTFAVORITOS
		INTO
			:i_qtFavoritos
		FROM
			apoio.arearegistro AreaRegistro,
			linha.linhaBase LinhaBase,
			linha.linhaTelefonica LinhaTelefonica,		
			customer.pessoalinha PessoaLinha,
			customer.pessoadepara PessoaDePara,
			customer.pessoa Pessoa,
			vol.favoritoUF   FavoritoUF		
		WHERE
			LinhaBase.NRLINHA = :i_nrLinha  AND
			LinhaBase.IDAREAREGISTRO = AreaRegistro.IDAREAREGISTRO AND
			AreaRegistro.CDAREAREGISTRO =  :i_idAreaRegistro  AND
			LinhaBase.idlinhabase = LinhaTelefonica.IDLINHABASE AND
			LinhaTelefonica.IDLINHATELEFONICA = PessoaLinha.IDLINHATELEFONICA AND
			PessoaLinha.IDPESSOADEPARA = PessoaDePara.IDPESSOADEPARA AND
			PessoaLinha.idtiporelacionamento =  :i_idTipoRelacionamento  AND
			PessoaDePara.IDPESSOA = Pessoa.IDPESSOA AND
			Pessoa.IDUF = FavoritoUF.IDUF;



	tuxfw_getlogger()->debug("getQtFavoritos:i_qtFavoritos: %d", i_qtFavoritos);

	return i_qtFavoritos;

	OraNoDataFound:
		tuxfw_getlogger()->debug("getQtFavoritos: Quantidade de favoritos não encontrada para a UF");
		return 0;

	OraException:
		throw TuxBasicOraException(sqlca.sqlcode);

}

int Util::getDigitoLinha(char* pc_Line)
{
	if ((pc_Line == NULL) || (! isNum(pc_Line)))
		return -1;

	if (strlen(pc_Line) < 10 || strlen(pc_Line) > 11 )
		return -1;

	char vc_DDD[3];
	char vc_Fone[10];

	memset(vc_DDD, '\0', sizeof(vc_DDD));
	memset(vc_Fone, '\0', sizeof(vc_Fone));

	strncpy(vc_DDD, pc_Line, 2);
	// strncpy(vc_Fone, (pc_Line + 2), 8);
	sprintf(vc_Fone, "%s", (char*)&pc_Line[2] );

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		unsigned int i_cdAreaRegistro;
		unsigned int i_nrLinha;
		         int i_nrDigitoLinha;
	EXEC SQL END DECLARE SECTION;

	i_cdAreaRegistro = atoi(vc_DDD);
	i_nrLinha = atoi(vc_Fone);

	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	// Faz a consulta no banco de dados
	EXEC SQL

		SELECT
			NVL(nrDigitoLinha, -1)
		INTO
			:i_nrDigitoLinha
		FROM
			apoio.areaRegistro  a,
			linha.linhaBase     b
		WHERE
			a.cdAreaRegistro = :i_cdAreaRegistro
		AND
			b.idAreaRegistro = a.idAreaRegistro
		AND
			b.nrLinha = :i_nrLinha;


	tuxfw_getlogger()->debug("getDigitoLinha:i_nrDigitoLinha: %d", i_nrDigitoLinha);

	return i_nrDigitoLinha;

	OraNoDataFound:
		tuxfw_getlogger()->debug("getDigitoLinha: Digito Linha não encontrado");
		return -1;

	OraException:
		throw TuxBasicOraException(sqlca.sqlcode);

}

char* Util::rand(char* pc_rand)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	char cSeq[256];
	EXEC SQL END DECLARE SECTION;

	pc_rand[0] = '\0';

	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	// Faz a consulta no banco de dados
	EXEC SQL

		SELECT
			TO_CHAR(linha.transacaoNGINSQ.nextval)
		INTO
			:cSeq
		FROM
			dual;

	strcpy(pc_rand, Util::trim(cSeq));

	tuxfw_getlogger()->debug("rand: %s", pc_rand);

	return pc_rand;

	OraNoDataFound:
		tuxfw_getlogger()->debug("Util::rand: SQ não encontrada");
		throw TuxBasicOraException(sqlca.sqlcode);

	OraException:
		throw TuxBasicOraException(sqlca.sqlcode);

}

void Util::DtAtual(char *chrDtAtual, char *chrFormato)
{

struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		char chrDtAtualSQL[11];
		char chrFormatoSQL[11];
	EXEC SQL END DECLARE SECTION;

	strcpy(chrFormatoSQL, chrFormato);

	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	// Faz a consulta no banco de dados
	EXEC SQL
		SELECT
			TO_CHAR(sysdate,:chrFormatoSQL)
		INTO
			:chrDtAtualSQL
		FROM
			DUAL;

	strcpy(chrDtAtual, chrDtAtualSQL);

	return;

	OraNoDataFound:
	OraException:		
		tuxfw_getlogger()->debug("Util:: DtAtual: Erro");
		chrDtAtual = NULL;

}

void Util::SubDiasData(char* chrDtInicial, char* chrDtFinal, int intSubtraiDias, char* chrFormato)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		char chrDtFinalSQL[11];
		char chrDtInicialSQL[11];
		char chrFormatoSQL[11];
		char chrFormatoFinal[12];
		int intSubtraiDiasSQL;
	EXEC SQL END DECLARE SECTION;

	strcpy(chrDtInicialSQL, chrDtInicial);
	
	strcpy(chrFormatoSQL, "dd/mm/yyyy");

	intSubtraiDiasSQL = intSubtraiDias;

	if ((strncmp(chrDtInicialSQL,"200", 3) == 0)|| (strncmp(chrDtInicialSQL, "199", 3) == 0)) //checando se o formato é yyyy/dd/mm
		strcpy(chrFormatoSQL, "yyyy/mm/dd");

	strcpy (chrFormatoFinal, chrFormato);

	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	// Faz a consulta no banco de dados
	EXEC SQL
		SELECT
			TO_CHAR(TO_DATE(:chrDtInicialSQL, :chrFormatoSQL) -:intSubtraiDiasSQL,:chrFormatoFinal)
		INTO
			:chrDtFinalSQL
		FROM
			DUAL;

	strcpy(chrDtFinal, chrDtFinalSQL);

	return;
	OraNoDataFound:
	OraException:		
		tuxfw_getlogger()->debug("Util::Data inválida - retornando null");
		chrDtFinal = NULL;
	
}

char *Util::DataDiaAnterior(char* chrData)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		char chrDataDiaAnteriorSQL[11];
		char chrDataAtualSQL[11];
		char chrFormatoSQL[11];
	EXEC SQL END DECLARE SECTION;

	strcpy(chrDataAtualSQL, chrData);
	
	strcpy(chrFormatoSQL, "dd/mm/yyyy");

	if ((strncmp(chrDataAtualSQL,"200", 3) == 0)|| (strncmp(chrDataAtualSQL, "199", 3) == 0)) //checando se o formato é yyyy/dd/mm
		strcpy(chrFormatoSQL, "yyyy/mm/dd");

	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	// Faz a consulta no banco de dados
	EXEC SQL
		SELECT
			TO_CHAR(TO_DATE(:chrDataAtualSQL, :chrFormatoSQL) -1,'dd-mm-yyyy')
		INTO
			:chrDataDiaAnteriorSQL
		FROM
			DUAL;

	return chrDataDiaAnteriorSQL;

	OraNoDataFound:
	OraException:		
		tuxfw_getlogger()->debug("Util::Data inválida - retornando null");
		return NULL;
	
}


bool Util::IsValidDate(char*dtDiaVencimento)
{
	tuxfw_getlogger()->debug("Util::IsValidDate");
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		int verificar = 0;
		char dtdia[9];
	EXEC SQL END DECLARE SECTION;

	if(strlen(dtDiaVencimento) < 10)
		return false;

	// formato da data yyyy-mm-dd
	dtdia[0] = dtDiaVencimento[8];
	dtdia[1] = dtDiaVencimento[9];
	dtdia[2] = dtDiaVencimento[5];
	dtdia[3] = dtDiaVencimento[6];
	dtdia[4] = dtDiaVencimento[0];
	dtdia[5] = dtDiaVencimento[1];
	dtdia[6] = dtDiaVencimento[2];
	dtdia[7] = dtDiaVencimento[3];
	dtdia[8] = 0;
	
	tuxfw_getlogger()->debug("dtdia=%s, dtDiaVencimento=%s ",dtdia,dtDiaVencimento);

	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;
	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	// Faz a consulta no banco de dados
	EXEC SQL
		SELECT 1
		INTO :verificar
		FROM DUAL
		WHERE 
		(
		TO_DATE(:dtdia,'DDMMYYYY') < SYSDATE 
		AND TO_CHAR(TO_DATE(:dtdia,'DDMMYYYY'),'D') > 1
		AND TO_CHAR(TO_DATE(:dtdia,'DDMMYYYY'),'D') < 7
		AND TO_DATE(:dtdia,'DDMMYYYY') NOT IN (SELECT DTDIA FROM CALENDARIO.FERIADO)
		) 
		OR
		(
		TO_DATE(:dtdia,'DDMMYYYY') < SYSDATE 
		AND TO_CHAR(TO_DATE(:dtdia,'DDMMYYYY'),'D') = 1 
		AND TO_DATE(TO_CHAR(SYSDATE,'DDMMYYYY'),'DDMMYYYY') - TO_DATE(:dtdia,'DDMMYYYY') >= 2
		)
		OR
		(
		TO_DATE(:dtdia,'DDMMYYYY') < SYSDATE 
		AND TO_CHAR(TO_DATE(:dtdia,'DDMMYYYY'),'D') = 7 
		AND TO_DATE(TO_CHAR(SYSDATE,'DDMMYYYY'),'DDMMYYYY') - TO_DATE(:dtdia,'DDMMYYYY') >= 3
		)
		OR
		(
		TO_DATE(:dtdia,'DDMMYYYY') < SYSDATE 
		AND TO_CHAR(TO_DATE(:dtdia,'DDMMYYYY'),'D') > 1
		AND TO_CHAR(TO_DATE(:dtdia,'DDMMYYYY'),'D') < 6
		AND TO_DATE(:dtdia,'DDMMYYYY') IN (SELECT DTDIA FROM CALENDARIO.FERIADO)
		AND TO_DATE(TO_CHAR(SYSDATE,'DDMMYYYY'),'DDMMYYYY') - TO_DATE(:dtdia,'DDMMYYYY') >= 2
		)
		OR
		(
		TO_DATE(:dtdia,'DDMMYYYY') < SYSDATE 
		AND TO_CHAR(TO_DATE(:dtdia,'DDMMYYYY'),'D') = 6
		AND TO_DATE(:dtdia,'DDMMYYYY') IN (SELECT DTDIA FROM CALENDARIO.FERIADO)
		AND TO_DATE(TO_CHAR(SYSDATE,'DDMMYYYY'),'DDMMYYYY') - TO_DATE(:dtdia,'DDMMYYYY') >= 4
		);

	return true;

	OraNoDataFound:
	OraException:		
		tuxfw_getlogger()->debug("Util::IsValidDate - OraException");
		return false;
}

// Insere um registro de log para uma chamada ao legado NGIN
int Util::logarChamadaNGIN(string &snrLinha, string &sdsMetodo_NGIN, string &sdsObservacao, string &sdsXML_IN, string &sdsXML_OUT )
{
	struct sqlca sqlca;
	string sMsgTempLog;

	sMsgTempLog = "logando chamanda NGIN com nrLinha[" + snrLinha + "], dsMetodo[" + sdsMetodo_NGIN + "], dsObservacao[" + sdsObservacao + "], dsXML_IN[" + sdsXML_IN + "] e dsXML_OUT[" + sdsXML_OUT + "].";
	tuxfw_getlogger()->debug((char *)(sMsgTempLog.data()));

	EXEC SQL BEGIN DECLARE SECTION;
		const char* ccOraNRLinha;
		const char* ccOraDSMetodo_NGIN; 
		const char* ccOraDSObservacao;
		const char* ccOraDSXML_IN;
		const char* ccOraDSXML_OUT;
	EXEC SQL END DECLARE SECTION;

	ccOraNRLinha = snrLinha.data();
	ccOraDSMetodo_NGIN = sdsMetodo_NGIN.data(); 
	ccOraDSObservacao = sdsObservacao.data();
	ccOraDSXML_IN = sdsXML_IN.data();
	ccOraDSXML_OUT = sdsXML_OUT.data();

	
	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;
	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	EXEC SQL INSERT INTO CUSTOMER.LOGNGIN
			(
			    NRLINHA,
			    DSMETODO_NGIN,
			    DSOBSERVACAO,
			    DSXML_IN,
			    DSXML_OUT,
			    DTULTIMAALTERACAO
			  )
			  VALUES
			  (
				:ccOraNRLinha,
				:ccOraDSMetodo_NGIN,
				:ccOraDSObservacao,
				:ccOraDSXML_IN,
				:ccOraDSXML_OUT,
				SYSDATE
			  );		
	//EXEC SQL COMMIT;

	return 1;
	
	OraNoDataFound:
		sMsgTempLog = "Erro [OraNoDataFound] ao tentar logar o XML IN[" + sdsXML_IN + "] OUT [" + sdsXML_OUT + "] de/para um serviço NGIN referente a linha [" + snrLinha + "]. ";
		tuxfw_getlogger()->debug((char *)(sMsgTempLog.data()));
		return 0;
	OraException:
		sMsgTempLog = "Erro OraException [";
		sMsgTempLog += *new string(sqlca.sqlerrm.sqlerrmc);
		sMsgTempLog += "] ao tentar logar o XML IN[" + sdsXML_IN + "] OUT [" + sdsXML_OUT + "] de/para um serviço NGIN referente a linha [" + snrLinha + "]. ";
		tuxfw_getlogger()->debug((char *)(sMsgTempLog.data()));
		return 0;
}

// Verifica se uma linha é válida
int Util::VerificarlinhaFavoritaValida(string &spc_ddd, TIPOVALIDACAO eTipoValidacao )
{
	string sMsgTempLog;
	sMsgTempLog = "Valor spc_ddd [" + spc_ddd + "] e eTipoValidacaoe [" + Util::intToStr((int)eTipoValidacao) + "]  de entrada da funcao VerificarlinhaFavoritaValida() ";
	tuxfw_getlogger()->debug((char *)(sMsgTempLog.data()));

	if ((spc_ddd.length() <= 0) || (!isNum((char *)(spc_ddd.data()))))
		return -1;

	char vc_DDD[3];
	memset(vc_DDD, '\0', sizeof(vc_DDD));
	strncpy(vc_DDD, (char *)(spc_ddd.data()), 2);
	
	struct sqlca sqlca;


	EXEC SQL BEGIN DECLARE SECTION;
		unsigned int i_inDisponibilidade;
		unsigned int i_cdAreaRegistro;
		unsigned int i_idAreaRegistro;
	EXEC SQL END DECLARE SECTION;
		i_inDisponibilidade = 0;
		i_cdAreaRegistro = atoi(vc_DDD);
		i_idAreaRegistro = 0;
		
		
	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	// validar DDD
	if ( eTipoValidacao == VALIDA_TABELA_DDD )
	{
		EXEC SQL 
			SELECT
				IDUSUARIOALTERACAO
			INTO
				:i_inDisponibilidade
			FROM
				CUSTOMER.DDDNGINFAVORITOS
			WHERE
				CDAREAREGISTRO = :i_cdAreaRegistro
				AND ROWNUM < 2;

	    if( i_inDisponibilidade > 0 )
		   return 1;
		else
		   return 0;
	}
	// validar Regional
	if ( eTipoValidacao == VALIDA_TABELA_REGIONAL) 
	{	
		EXEC SQL 
			SELECT
				TO_CHAR(FU.INDISPONIBILIDADE)
			INTO
				:i_inDisponibilidade
			FROM
				VOL.FAVORITOUF FU,
				CUSTOMER.UFOPERADORA UO,
				APOIO.AREAREGISTRO AR
			WHERE
			   FU.IDUF = UO.IDUF AND
			   UO.IDUFOPERADORA = AR.IDUFOPERADORA AND
			   AR.CDAREAREGISTRO = :i_cdAreaRegistro AND
			   FU.QTFAVORITOS = 5 AND
			   ROWNUM < 2;
			   
	    if( i_inDisponibilidade >= 1 )
		   return 1;
		else
		   return 0;
	}
	
	OraNoDataFound:
		return 0;
	OraException:
		sMsgTempLog = "Erro OraException ["+ *new string(sqlca.sqlerrm.sqlerrmc) + "] ao tentar validar DDD/Regional[" + spc_ddd + "]. ";
		tuxfw_getlogger()->debug((char *)(sMsgTempLog.data()));
		return 0;
}

// Verifica se uma linha é válida
int Util::lerApoioParametro(string &sCdParametro, string &sDsValorParametro)
{
	struct sqlca sqlca;
	string sMsgTempLog;

	EXEC SQL BEGIN DECLARE SECTION;
		const char* ccOraCdParametro = sCdParametro.data();
		char chDsValorParametro[512];
	EXEC SQL END DECLARE SECTION;
		memset(chDsValorParametro,0,sizeof(chDsValorParametro));
		
	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;
	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	EXEC SQL 
		SELECT
			DSVALORPARAMETRO
		INTO
			:chDsValorParametro
		FROM
			APOIO.PARAMETRO
		WHERE
			CDPARAMETRO = :ccOraCdParametro
			AND ROWNUM < 2;

		sDsValorParametro = chDsValorParametro;
		return 1;

	OraNoDataFound:
		sMsgTempLog = "Erro OraNoDataFound ao tentar ler o Parametro ["+sCdParametro+"] da tabela APOIO.PARAMETRO.";
		tuxfw_getlogger()->debug((char *)(sMsgTempLog.data()));
		return 0;
	OraException:
		sMsgTempLog = "Erro OraException [";
		sMsgTempLog += *new string(sqlca.sqlerrm.sqlerrmc);
		sMsgTempLog += "] ao tentar ler o Parametro ["+sCdParametro+"] da tabela APOIO.PARAMETRO.";
		tuxfw_getlogger()->debug((char *)(sMsgTempLog.data()));		
		return 0;
		
}
