//---------------------------------------------------------------------------
//                         (c) Consórcio Indra/PT-SI.
//                            xxxxxxxxxxxxxxxxxxxxxxx
//                                xxxxxxxxxxxxxx
//-----------------------------------------------------------------------------
// Los contenidos de este fichero son propiedad de Telefónica Consórcio Indra/PT-SI. 
// titular del copyright. Este fichero solo podra ser copiado, distribuido y utilizado, 
// en su totalidad o en parte, con el permiso escrito de Consórcio Indra/PT-SI 
// o de acuerdo con los terminos y condiciones establecidas en el acuerdo/contrato bajo 
// el que se suministra.
//---------------------------------------------------------------------------
//*  Modulo                   : 
//*  Fichero                  : Parametro
//*  Tipo                     : .cpp
//*  Autor                    : Jones Randis Dalberto
//*  Fecha primera version    : 
//*  Version actual           : 
//*//---------------------------------------------------------------------------
//*  Proposito:
//*
//*  Controle de parametros no VOL
//*//---------------------------------------------------------------------------
//*  Dependencias:
//*
//*  
//*//---------------------------------------------------------------------------
//*  Consideraciones de portabilidad:
//*
//*  
////---------------------------------------------------------------------------

#include "Parametro.h"
#include "Util.h"

#include <tuxfw.h>

#include <cstring>

using namespace std;

CParametro::CParametro(void)
{
	strcpy(this->mvc_chave, "");
	strcpy(this->mvc_valor, "");
	strcpy(this->mvc_consulta, "");
	mvi_inAtivo = 1;
	mvi_inAdicionarServico = 0;

}

CParametro::~CParametro(void)
{

}

void CParametro::setChave(char* chave)
{
	strcpy(this->mvc_chave, chave);
}

void CParametro::setValor(char* valor)
{
	strcpy(this->mvc_valor, valor);
}

void CParametro::setConsulta(char* valor)
{
	strcpy(this->mvc_consulta, valor);
}

void CParametro::setCdAreaRegistro(int valor)
{
	mvi_cdAreaRegistro = valor;
}
void CParametro::setInAtivo(int valor)
{
	mvi_inAtivo = valor;
}
void CParametro::setInAdicionarServico(int valor)
{
	mvi_inAdicionarServico = valor;
}


char* CParametro::getChave(void)
{
	return this->mvc_chave;
}

char* CParametro::getValor(void)
{
	return this->mvc_valor;
}

char* CParametro::getConsulta(void)
{
	return this->mvc_consulta;
}

int	  CParametro::getCdAreaRegistro(void)
{
	return this->mvi_cdAreaRegistro;
}

int	  CParametro::getInAtivo(void)
{
	return this->mvi_inAtivo;
}

int   CParametro::getInAdicionarServico(void)
{
	return this->mvi_inAdicionarServico;
}


#include <sqlca.h>

void CParametro::getSistemaOrigem(char *idUser, char *sgSistemaOrigem)
{
	struct sqlca sqlca;
	
	tuxfw_getlogger()->debug("CParametro::getSistemaOrigem");
	
	EXEC SQL BEGIN DECLARE SECTION;		
		struct dados { 
			VARCHAR sgSistemaOrigemStr[256];
		} m_stDados;
		struct idados {
			short i_sgSistemaOrigemStr;
		} m_istDados;
		char *pidUser = idUser;
	EXEC SQL END DECLARE SECTION;	
	
	memset(&m_stDados,0,sizeof(m_stDados));	
	memset(&m_istDados,0,sizeof(m_istDados));	

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	EXEC SQL 
		SELECT NVL(sgsistemaorigem, ' ')
		  INTO m_stDados:m_istDados
		  FROM apoio.sistemaorigem
		 WHERE idsistemaorigem = :pidUser;		  

	strcpy(sgSistemaOrigem,(char*)m_stDados.sgSistemaOrigemStr.arr);
	tuxfw_getlogger()->debug("sgSistemaOrigem: %s, idsistemaorigem: %s",sgSistemaOrigem, idUser);

	return;

	OraException:
		if(sqlca.sqlcode == NO_DATA_FOUND)
		{
			tuxfw_getlogger()->debug("não achou o sistema origem para o idsistemaorigem = %s", idUser);
			return;
		}
		else
			throw TuxBasicOraException(sqlca.sqlcode);
}

void CParametro::consultar(void)
{
	struct sqlca sqlca;
	
	EXEC SQL BEGIN DECLARE SECTION;
	char* pc_chave;
	char  pc_valor[256];
	EXEC SQL END DECLARE SECTION;

	pc_chave = this->getChave();

	memset(pc_valor, '\0', sizeof(pc_valor));

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	EXEC SQL WHENEVER NOT FOUND GOTO OraException;

	EXEC SQL SELECT NVL(dsValorParametro, ' ') INTO :pc_valor FROM apoio.ParametroB00 WHERE cdParametro = :pc_chave;

	this->setConsulta(Util::trim(pc_valor));

	return;

	OraException:
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CParametro::consultarContatoFuncionalidade(void)
{
	struct sqlca sqlca;
	
	EXEC SQL BEGIN DECLARE SECTION;
	char* pc_chave;
	char  pc_valor[256];
	EXEC SQL END DECLARE SECTION;

	pc_chave = this->getChave();

	memset(pc_valor, '\0', sizeof(pc_valor));

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	EXEC SQL WHENEVER NOT FOUND GOTO OraException;

	EXEC SQL SELECT CONTATOFUNCIONALIDADE.IDCONTATO INTO :pc_valor 
	FROM CONTATOADM.CONTATOFUNCIONALIDADE CONTATOFUNCIONALIDADE WHERE CONTATOFUNCIONALIDADE.CDFUNCIONALIDADE = :pc_chave;

	this->setConsulta(Util::trim(pc_valor));

	return;

	OraException:
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CParametro::incluir(void)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	char* pc_chave;
	char* pc_valor;
	EXEC SQL END DECLARE SECTION;

	pc_chave = this->getChave();
	pc_valor = this->getValor();

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	EXEC SQL INSERT INTO apoio.Parametro  (cdParametro, dsParametro, dsValorParametro, dtUltimaAlteracao) VALUES (:pc_chave, :pc_chave, :pc_valor, sysdate);

	return;

	OraException:
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CParametro::alterar(void)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	char* pc_chave;
	char* pc_valor;
	EXEC SQL END DECLARE SECTION;

	pc_chave = this->getChave();
	pc_valor = this->getValor();

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	EXEC SQL WHENEVER NOT FOUND GOTO OraException;
	
	EXEC SQL UPDATE apoio.Parametro  SET dsValorParametro = :pc_valor WHERE cdParametro = :pc_chave;

	return;

	OraException:
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CParametro::excluir(void)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	char* pc_chave;
	EXEC SQL END DECLARE SECTION;

	pc_chave = this->getChave();

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	EXEC SQL WHENEVER NOT FOUND GOTO OraException;
	
	EXEC SQL DELETE FROM apoio.Parametro  WHERE cdParametro = :pc_chave;

	return;

	OraException:
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CParametro::consultarNomeServico(void)
{
	struct sqlca sqlca;
	
	EXEC SQL BEGIN DECLARE SECTION;
	char* pc_chave;
	char  pc_valor[256]="";
	int   iCdAreaRegistro;
	int   iInAtivo=0;
	EXEC SQL END DECLARE SECTION;

	pc_chave = this->getChave();

	memset(pc_valor, '\0', sizeof(pc_valor));

	iCdAreaRegistro = this->getCdAreaRegistro();

	EXEC SQL WHENEVER SQLERROR GOTO OraException;


	EXEC SQL 
		SELECT 
				NVL(dsServicoAtlys, ' '),
				NVL(inAtivo, 0)
		INTO
				:pc_valor,
				:iInAtivo
		FROM   
				apoio.ServicoAtlys	a,
				apoio.areaRegistro	b
		WHERE  
				a.idAreaRegistro = b.idAreaRegistro
		AND		cdAreaRegistro	 = :iCdAreaRegistro
		AND		dsServicoFO      = :pc_chave;


	this->setConsulta(Util::trim(pc_valor));
	this->setInAtivo(iInAtivo);

	return;

	OraException:
		if(sqlca.sqlcode == NO_DATA_FOUND)
		{
			this->setConsulta(Util::trim(pc_valor));
			this->setInAtivo(iInAtivo);
			return;
		}
		else
			throw TuxBasicOraException(sqlca.sqlcode);
}

int CParametro::consultarNomeServicoTorpedoEmpresas(char *chrptrServicoAtlys, char *chrptrChave)
{
	struct sqlca sqlca;
	
	EXEC SQL BEGIN DECLARE SECTION;
	char  chrChaveSQL[256];
	char  chrServicoAtlysSQL[256]="";
	char  pc_valor[256]="";
	int   iCdAreaRegistro;
	int   iInAtivo=0;
	EXEC SQL END DECLARE SECTION;

	strcpy(chrChaveSQL, chrptrChave);

	strcat (chrChaveSQL, "%");

	memset(pc_valor, '\0', sizeof(pc_valor));

	strcpy (chrServicoAtlysSQL, chrptrServicoAtlys);

	iCdAreaRegistro = this->getCdAreaRegistro();

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	EXEC SQL 
		SELECT 
				NVL(dsServicoAtlys, ' '),
				NVL(inAtivo, 0)
		INTO
				:pc_valor,
				:iInAtivo
		FROM   
				apoio.ServicoAtlys	a,
				apoio.areaRegistro	b
		WHERE  
				a.idAreaRegistro = b.idAreaRegistro
		AND		cdAreaRegistro	 = :iCdAreaRegistro
		AND		dsServicoAtlys	 = :chrServicoAtlysSQL
		AND		dsServicoFO		 like :chrChaveSQL;


	return 1;

	OraException:
		if(sqlca.sqlcode == NO_DATA_FOUND)
		{
			return 0;
		}
		throw TuxBasicOraException(sqlca.sqlcode);

}

void CParametro::consultarInAtivoSvcName(void)
{
	struct sqlca sqlca;
	
	EXEC SQL BEGIN DECLARE SECTION;
	char* pc_chave;
	int   iCdAreaRegistro;
	int   iInAtivo;
	EXEC SQL END DECLARE SECTION;

	pc_chave = this->getChave();

	iCdAreaRegistro = this->getCdAreaRegistro();

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

//	EXEC SQL WHENEVER NOT FOUND GOTO OraException;

	EXEC SQL 
		SELECT 
				NVL(inAtivo, 0)
		INTO
				:iInAtivo
		FROM   
				apoio.ServicoAtlys 	a,
				apoio.areaRegistro 	b
		WHERE  
				a.idAreaRegistro = b.idAreaRegistro
		AND		cdAreaRegistro	 = :iCdAreaRegistro
		AND		dsServicoAtlys	 = :pc_chave;

	this->setInAtivo(iInAtivo);

	return;

	OraException:
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CParametro::consultarServicosInvertidos(list< CParametro > & lstParametro)
{
    ULOG_START( "CParametro::consultarServicosInvertidos()" );
    
	struct sqlca sqlca;
	
	EXEC SQL BEGIN DECLARE SECTION;
	char* pc_chave;
	char  pc_valor[256];
	int   iCdAreaRegistro;
	int   iInAtivo;
	int   iInAdicionarServico;
	EXEC SQL END DECLARE SECTION;

	pc_chave = this->getChave();

	memset(pc_valor, '\0', sizeof(pc_valor));

	iCdAreaRegistro = this->getCdAreaRegistro();

	CParametro oParametro;

	// garante que a lista esta vazia
	lstParametro.clear();


	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	ULOG( "*** Pesquisando servicos para DDD [%d]", iCdAreaRegistro );
    
    EXEC SQL DECLARE LSTSERVICOSINVERTIDOS CURSOR FOR
		SELECT 
				NVL(dsServicoAtlys, ' '),
				NVL(inAtivo, 0),
				1
		FROM   
				apoio.ServicoAtlys 	a,
				apoio.areaRegistro 	b
		WHERE  
				a.idAreaRegistro = b.idAreaRegistro
		AND		cdAreaRegistro	 = :iCdAreaRegistro
		AND		inAtivo			 = 0;

	EXEC SQL WHENEVER NOT FOUND DO break;

	EXEC SQL OPEN LSTSERVICOSINVERTIDOS;

	for( ;; ) {
		// varre todos os registros para criar a lista com os Relacionamentos
		EXEC SQL FETCH LSTSERVICOSINVERTIDOS INTO
			:pc_valor,
			:iInAtivo,
			:iInAdicionarServico;

		oParametro.setConsulta(Util::trim(pc_valor));
        ULOG( "*** oParametro.setConsulta [%s]", Util::trim(pc_valor) );
        
		oParametro.setInAtivo(iInAtivo);
        ULOG( "*** oParametro.setInAtivo [%d]", iInAtivo );

		oParametro.setInAdicionarServico(iInAdicionarServico);
        ULOG( "*** oParametro.setInAdicionarServico [%d]", iInAdicionarServico );

		lstParametro.push_back( oParametro );
	}

	EXEC SQL CLOSE LSTSERVICOSINVERTIDOS;

    ULOG_END( "CParametro::consultarServicosInvertidos()" );

	return;

	OraException:
		throw TuxBasicOraException(sqlca.sqlcode);
}


void CParametro::consultarNomeServicoLegado(char *cServicoLegado, int iCdAreaRegistro, char *cServicoFO, char *cOperacao, char *cSgSistemaOrigem,char*linha)
{
	tuxfw_getlogger()->debug("CParametro::consultarNomeServicoLegado");
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;

	int   iCdAreaRegistroSQL;
	char  cServicoFOSQL[256] ="";
	char  cOperacaoSQL[256]="";
	char  cSgSistemaOrigemSQL[256]="";
	char  cServicoLegadoSQL[256]="";
	char *clinha = linha;

	EXEC SQL END DECLARE SECTION;

	iCdAreaRegistroSQL = iCdAreaRegistro;
	
	strcpy (cServicoFOSQL, cServicoFO);

	strcpy (cOperacaoSQL, cOperacao);

	strcpy(cSgSistemaOrigemSQL, cSgSistemaOrigem);

	EXEC SQL WHENEVER SQLERROR GOTO OraException;
	
	EXEC SQL WHENEVER NOT FOUND GOTO OraException;

	EXEC SQL
	SELECT 
		SERVICOLEGADO.DSSERVICOLEGADO
	INTO
		:cServicoLegadoSQL
	FROM 
		VOL.SERVICOLEGADO SERVICOLEGADO,
		LINHA.LINHABASE LINHABASE,
		LINHA.LINHATELEFONICA LINHATELEFONICA
	WHERE 
		SERVICOLEGADO.DSSERVICOFO = :cServicoFOSQL AND 
		SERVICOLEGADO.IDAREAREGISTRO = (SELECT IDAREAREGISTRO FROM APOIO.AREAREGISTRO WHERE CDAREAREGISTRO = :iCdAreaRegistroSQL ) AND
		SERVICOLEGADO.DSOPERACAO = :cOperacaoSQL AND
		SERVICOLEGADO.IDSISTEMAORIGEM = (SELECT IDSISTEMAORIGEM FROM APOIO.SISTEMAORIGEM WHERE SGSISTEMAORIGEM = :cSgSistemaOrigemSQL) AND
		LINHABASE.IDLINHABASE = LINHATELEFONICA.IDLINHABASE AND
		LINHABASE.NRLINHA = :clinha AND
		LINHABASE.IDAREAREGISTRO = SERVICOLEGADO.IDAREAREGISTRO AND
		SERVICOLEGADO.IDTIPOLINHA = LINHATELEFONICA.IDTIPOLINHA;



	strcpy (cServicoLegado, Util::trim(cServicoLegadoSQL));

	return;

	OraException:
		tuxfw_getlogger()->debug("Erro oracle sqlca.sqlcode = %d",sqlca.sqlcode);
		throw TuxBasicOraException(sqlca.sqlcode);

}

void CParametro::consultarNomeServicoFO(char *cServicoFO, int iCdAreaRegistro, char *cServicoLegado, char *cOperacao, char *cSgSistemaOrigem)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;

	int   iCdAreaRegistroSQL;
	char  cServicoFOSQL[256] ="";
	char  cOperacaoSQL[256]="";
	char  cSgSistemaOrigemSQL[256]="";
	char  cServicoLegadoSQL[256]="";

	EXEC SQL END DECLARE SECTION;

	iCdAreaRegistroSQL = iCdAreaRegistro;
	
	strcpy(cServicoLegadoSQL, cServicoLegado);

	strcpy (cOperacaoSQL, cOperacao);

	strcpy(cSgSistemaOrigemSQL, cSgSistemaOrigem);
	
	
	EXEC SQL WHENEVER SQLERROR GOTO OraException;
	
	EXEC SQL WHENEVER NOT FOUND GOTO OraException;

	EXEC SQL 

	SELECT 
		DSSERVICOFO
	INTO
		:cServicoFOSQL
	FROM
		VOL.SERVICOLEGADO
	WHERE 
		IDAREAREGISTRO = (SELECT IDAREAREGISTRO FROM APOIO.AREAREGISTRO WHERE CDAREAREGISTRO = :iCdAreaRegistroSQL ) AND
		DSOPERACAO = :cOperacaoSQL AND 
		IDSISTEMAORIGEM = (SELECT IDSISTEMAORIGEM FROM APOIO.SISTEMAORIGEM WHERE SGSISTEMAORIGEM = :cSgSistemaOrigemSQL) AND 
		DSSERVICOLEGADO = :cServicoLegadoSQL;
 
	
	strcpy(cServicoFO, Util::trim(cServicoFOSQL));

	return;

	OraException:
		if(sqlca.sqlcode == NO_DATA_FOUND)
			return;
			
		throw TuxBasicOraException(sqlca.sqlcode);

}



int CParametro::getNrInSid(char* pcLinha, char* pc_idCanal, char* pc_usuario, char* pc_nmApi)
{

	tuxfw_getlogger()->debug("CreatorPlugInBE::consultarInSid");
	
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		int  iOraIdSisOrg;
		char vcOraDDD[3];
		char vcOraNrFone[9];
		char vcOraIdLinhaSisOrig[256];
		int  iNrInSid = 0;
		char cNmApi[60];
		char cIdCanal[10];
	EXEC SQL END DECLARE SECTION;

	memset(vcOraDDD, '\0', sizeof(vcOraDDD));
	memset(vcOraNrFone, '\0', sizeof(vcOraNrFone));
	memset(vcOraIdLinhaSisOrig, '\0', sizeof(vcOraIdLinhaSisOrig));
	memset(cNmApi, '\0', sizeof(cNmApi));
	memset(cIdCanal, '\0', sizeof(cIdCanal));

	strncpy(vcOraDDD, pcLinha, 2);	
	strcpy (cNmApi, pc_nmApi);

	char cUsuario[10];

	memset(cUsuario, '\0', sizeof(cUsuario));


	strcpy  (cUsuario, pc_usuario);


	if(pc_idCanal == NULL || pc_idCanal == '\0')
	{
		if (!strcmp(cUsuario, "FO"))
			pc_idCanal = "1";

		else if (!strcmp(cUsuario, "URA"))		
			pc_idCanal = "9";

		else if (!strcmp(cUsuario, "VOL"))
			pc_idCanal = "15";

		else if  (!strcmp(cUsuario, "TAV"))
			pc_idCanal = "13";
	}


	

	strcpy(cIdCanal, pc_idCanal);

	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL WHENEVER SQLERROR GOTO OraException;


	// Faz a consulta no banco de dados
	EXEC SQL
		SELECT
			NRINSID
		INTO
			:iNrInSid
		FROM 		
			apoio.arearegistro arearegistro,
			customer.ufoperadora ufoperadora,
			customer.operadora operadora,
			infra.insidapioperadoracanal insidapioperadoracanal,
			infra.apingin apingin
		WHERE		 			 
			 arearegistro.cdarearegistro = :vcOraDDD AND
			 arearegistro.IDUFOPERADORA = ufoperadora.IDUFOPERADORA AND
			 ufoperadora.IDPESSOADEPARAOPERADORA = operadora.IDPESSOADEPARAOPERADORA AND			
			 operadora.IDGRUPOOPERADORA = insidapioperadoracanal.IDGRUPOOPERADORA  AND
			 insidapioperadoracanal.IDCANAL = :cIdCanal AND
			 insidapioperadoracanal.IDAPINGIN = apingin.IDAPINGIN AND
			 apingin.NMAPI = :cNmApi;



	if (sqlca.sqlcode == 1403)
	{
		EXEC SQL
		SELECT 
			NRINSIDDEFAULT
		INTO
			:iNrInSid
		FROM 
			infra.apingin 
		WHERE 
			NMAPI = :cNmApi;
			 
	}

	return iNrInSid;
		
	OraException:	
		throw TuxBasicOraException(sqlca.sqlcode);

}