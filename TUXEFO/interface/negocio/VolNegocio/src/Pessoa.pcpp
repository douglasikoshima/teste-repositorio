// Pessoa.cpp: implementation of the CPessoa class.
//
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw.h>
#include "Defines.h"
#include "Util.hpp"
#include "Pessoa.hpp"


EXEC SQL INCLUDE SQLCA;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPessoa::CPessoa() : m_oEndereco(NULL)
{  	   
    m_iIdPessoa = -1; 
	m_iIdUsuarioAlteracao = -1;
	strcpy( this->m_cNmPessoa, "" );
	strcpy( this->m_cDsContato, "" );
	strcpy( this->m_cDtUltimaAlteracao, "" );
}


CPessoa::~CPessoa() {
	if(NULL != this->m_oEndereco){
       delete this->m_oEndereco;
    }
}

CPessoa* CPessoa::createInstance(){
       return new CPessoa();
}


/*

  GETs

*/

int CPessoa::getIdPessoa() {
	return this->m_iIdPessoa;
}
int CPessoa::getIdConta(){
	return this->m_iIdConta;
}

char * CPessoa::getIdSistOrig(){
	return this->m_cIdSistOrig;
}

char * CPessoa::getNmPessoa() {
	return this->m_cNmPessoa;
}

char * CPessoa::getNomeUsuario() {
	return this->m_cNomeUsuario;
}

char * CPessoa::getNomeCliente() {
	return this->m_cNomeCliente;
}
char * CPessoa::getDsContato() {
	return this->m_cDsContato;
}

int CPessoa::getIdUsuarioAlteracao() {
	return this->m_iIdUsuarioAlteracao;
}

char * CPessoa::getDtUltimaAlteracao() {
	return this->m_cDtUltimaAlteracao;
}

CEndereco * CPessoa::getEndereco() {
	if(this->m_oEndereco == NULL)
		this->m_oEndereco = new CEndereco();
	return this->m_oEndereco;
}

int CPessoa::getIdTipoRelacionamento(){
	return m_iIdTipoRelacionamento;
}


char* CPessoa::getSgTipoRelacionamento(){
	return m_cSgTipoRelacionamento;
}


/*
 
   SETs

*/

void CPessoa::setIdPessoa(int value) {
	this->m_iIdPessoa = value;
}

void CPessoa::setNmPessoa(char *value) {
	strcpy( this->m_cNmPessoa, value );
}

void CPessoa::setNomeUsuario(char *value) {
	strcpy( this->m_cNomeUsuario, value );
//	memcpy(this->m_cNomeUsuario, value, strlen(value));
}

void CPessoa::setIdConta(int value){
	this->m_iIdConta = value;
}

void CPessoa::setIdSistOrig(char *value){
	strcpy(this->m_cIdSistOrig, value);
}


void CPessoa::setNomeCliente(char *value) {
	strcpy( this->m_cNomeCliente, value );
//	memcpy(this->m_cNomeCliente, value, strlen(value));
}
void CPessoa::setDsContato(char *value) {
	strcpy( this->m_cDsContato, value );
}


void CPessoa::setIdUsuarioAlteracao(int value) {
	this->m_iIdUsuarioAlteracao = value;
}

void CPessoa::setDtUltimaAlteracao(char *value) {
	strcpy( this->m_cDtUltimaAlteracao, value );
}

void CPessoa::setEndereco( const CEndereco & value ) {
	if( NULL != this->m_oEndereco )
		delete this->m_oEndereco;

	this->m_oEndereco = new CEndereco( value );
}

void CPessoa::setIdTipoRelacionamento(int value){
	this->m_iIdTipoRelacionamento = value ;

	 }
void CPessoa::setSgTipoRelacionamento(char *value){
		strcpy( this->m_cSgTipoRelacionamento, value );
}


//Metodos de Negocio da Interface da Classe CPessoa:

void CPessoa::consultarNome() {
	 this->consultarNmPessoaDB();
}

void CPessoa::consultarNomeUsuario(int iArea, int iNro){
	this->consultarNomeUsuarioDB(iArea, iNro);
}

void CPessoa::consultarNomeCliente(int iArea, int iNro){
	this->consultarNomeClienteDB(iArea, iNro);
}

void CPessoa::consultarEMail(void) {
	 this->consultarDsContatoDB();
}

void CPessoa::alterarEMail(void) {
 	this->alterarDsContatoDB();
}

char* CPessoa::obterLembreteSenha(int codArea, int nroLinha){

        //Obter IdPessoa;   
		this->consultarIdPessoaDB(codArea, nroLinha);

		// Delega para CSenha a Execução da Consulta.
		return this->m_oSenha.obterLembreteSenha(this->getIdPessoa());
}

void CPessoa::obterDadosSessao(int area, int nro, char* senha){

	this->consultarDadosSessaoDB(area, nro, senha);
;}

void CPessoa::obterIdPessoa(int codArea, int nroLinha){
	this->consultarIdPessoaDB(codArea, nroLinha);
}

//Metodos que acionanam CRelacionamento

void CPessoa::consultarHistQtdRelac(  list< CRelacionamento > & listaRelac,
												char * cQtRelac,
												char * cIdCanal){

	this->m_oRelac.setCanalPesquisa(cIdCanal);
	this->m_oRelac.setQtdRelac(atoi(cQtRelac));
	this->m_oRelac.consultarUltimosRelacionamentos( (this->getIdPessoa()) , listaRelac );
}

void CPessoa::consultarHistQtdRelacCanal(  list< CRelacionamento > & listaRelac,
 												int  iQtRelac,
 												int  iIdCanal){
 
 	this->m_oRelac.setIdCanal(iIdCanal);
 	this->m_oRelac.setQtdRelac(iQtRelac);
 	this->m_oRelac.consultarUltimosRelacionamentosCanal( (this->getIdPessoa()) , listaRelac );
}

void CPessoa::consultarHistRangeDate(	list< CRelacionamento > & listaRelac,  
												char * cDtInicio,
												char * cDtFinal,
												char * cIdCanal){

	this->m_oRelac.setDtRelacionamentoInicio(cDtInicio);
	this->m_oRelac.setDtRelacionamentoFinal(cDtFinal);
	this->m_oRelac.setCanalPesquisa(cIdCanal);
	this->m_oRelac.consultarRelacionamentosPeriodo( (this->getIdPessoa()) , listaRelac );
}
	
// Metodos que acionam a interface de m_oProcesso (CProcesso)

void CPessoa::consultarRangeDateProcessos(  list< CProcesso > & lstOProc,
 												char *  cDataInicio,
 												char * cDataFinal){
 
 	this->m_oProc.setDtProcessoFinal(cDataFinal);
 	this->m_oProc.setDtProcessoInicio(cDataInicio);
 	this->m_oProc.consultarRangeDateProcessos( this->getIdPessoa() , lstOProc );
}

void CPessoa::consultarUltimosProcessos( list< CProcesso > & listaOProc,  char * cQtProc ){

	this->m_oProc.setQtdProcessos( atoi(cQtProc) );
	this->m_oProc.consultarUltimosProcessos( (this->getIdPessoa()) , listaOProc );
}

// Metodos que acionam a interface de m_oSenha (CSenha)

char* CPessoa::consultarLembreteFraseSecreta(void){

    // Delega para CSenha a Execução da Consulta.
    return this->m_oSenha.consultarLembreteFraseSecreta(this->m_iIdPessoa);
};

char* CPessoa::consultarFraseSecreta(void){
    
    // Delega para CSenha a Execução da Consulta.
   return this->m_oSenha.consultarFraseSecreta(this->m_iIdPessoa);
};


void CPessoa::alterarFraseSecreta(char* dsFraseSecreta, char* dsLembreteFraseSecreta){
    
	// Delega para CSenha a Execução da Alteração.
    this->m_oSenha.alterarFraseSecreta(this->getIdPessoa(), dsFraseSecreta, dsLembreteFraseSecreta);
};          

// Metodos que acionam a interface de m_oEndereco (CEndereco)

void CPessoa::alterarEndereco() {
	if( NULL == this->m_oEndereco )
		return; // deveria lancar uma excecao (na verdade, uma assertiva) ???

	this->m_oEndereco->alterarEndereco( this->m_iIdPessoa );
}

void CPessoa::inserirEndereco() {
	if( NULL == this->m_oEndereco )
		return; // deveria lancar uma excecao (na verdade, uma assertiva) ???

	this->m_oEndereco->inserirEndereco( this->m_iIdPessoa );
}

void CPessoa::consultarEndereco() {
	if( NULL == this->m_oEndereco )
		return; 

	this->m_oEndereco->consultarEndereco( this->m_iIdPessoa );
}


// METODOS PRIVATE

// Métodos de acesso a banco de dados

void CPessoa::consultarNmPessoaDB(void) {

    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	int  iIdPessoa;
	char cNmPessoa[256];
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iIdPessoa = this->getIdPessoa();

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL SELECT
		nmPessoa
	INTO
		:cNmPessoa
	FROM
		customer.Pessoa
	WHERE
		idPessoa = :iIdPessoa; 
 
	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw new TuxBasicOraException(sqlca.sqlcode);
	}
 
    this->setNmPessoa(CUtil::trim(cNmPessoa));
    
	return;
 
	sqlErrorConstrutor:
		throw new TuxBasicOraException(sqlca.sqlcode);
}


void CPessoa::consultarNomeUsuarioDB(int area, int nro) {
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	char cNmPessoa[256];
	int iArea;
	int iNro;
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iArea = area;
	iNro = nro;

	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     /*select * from customer.pessoaLINHAB01 
	where   idtiporelacionamento = 2 and sgtiporelacionamento = 'U'
	and nrlinha = 12345678 and cdarearegistro = 11*/
	EXEC SQL 
	SELECT
		Pessoa.nmPessoa	
	INTO
		:cNmPessoa
	FROM
		apoio.arearegistro AreaRegistro,
		linha.linhaBase LinhaBase,
		linha.linhaTelefonica LinhaTelefonica,		
		customer.pessoalinha PessoaLinha,
		customer.pessoadepara PessoaDePara,
		customer.Pessoa Pessoa
	WHERE
		 LinhaBase.NRLINHA = :iNro AND
		 LinhaBase.IDAREAREGISTRO = AreaRegistro.IDAREAREGISTRO AND
		 AreaRegistro.CDAREAREGISTRO =  :iArea AND
		 LinhaBase.idlinhabase = LinhaTelefonica.IDLINHABASE AND
		 LinhaTelefonica.IDLINHATELEFONICA = PessoaLinha.IDLINHATELEFONICA AND
		 PessoaLinha.IDPESSOADEPARA = PessoaDePara.IDPESSOADEPARA AND
		 PessoaLinha.idtiporelacionamento = 1 AND
		 PessoaDePara.IDPESSOA =  Pessoa.IDPESSOA;
	
 
	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw new TuxBasicOraException(sqlca.sqlcode);
	}
 
    this->setNomeUsuario(CUtil::trim(cNmPessoa));
    
	return;
 
	sqlErrorConstrutor:
		throw new TuxBasicOraException(sqlca.sqlcode);
}


void CPessoa::consultarNomeClienteDB(int area, int nro) {

    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	char cNmPessoa[256];
	int iArea;
	int iNro;
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iArea = area;
	iNro = nro;

	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     /*select * from customer.pessoaLINHAB01 
	where   idtiporelacionamento = 2 and sgtiporelacionamento = 'U'
	and nrlinha = 12345678 and cdarearegistro = 11*/
	EXEC SQL 
	SELECT
		Pessoa.nmPessoa
	FROM
		apoio.arearegistro AreaRegistro,
		linha.linhaBase LinhaBase,
		linha.linhaTelefonica LinhaTelefonica,		
		customer.pessoalinha PessoaLinha,
		customer.pessoadepara PessoaDePara,
		customer.Pessoa Pessoa
	WHERE
		 LinhaBase.NRLINHA = :iNro AND
		 LinhaBase.IDAREAREGISTRO = AreaRegistro.IDAREAREGISTRO AND
		 AreaRegistro.CDAREAREGISTRO =  :iArea AND
		 LinhaBase.idlinhabase = LinhaTelefonica.IDLINHABASE AND
		 LinhaTelefonica.IDLINHATELEFONICA = PessoaLinha.IDLINHATELEFONICA AND
		 PessoaLinha.IDPESSOADEPARA = PessoaDePara.IDPESSOADEPARA AND
		 PessoaLinha.idtiporelacionamento = 2 AND
		 PessoaDePara.IDPESSOA =  Pessoa.IDPESSOA;
	
 
	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw new TuxBasicOraException(sqlca.sqlcode);
	}
 
    this->setNomeCliente(CUtil::trim(cNmPessoa));
    
	return;
 
	sqlErrorConstrutor:
		throw new TuxBasicOraException(sqlca.sqlcode);
}


void CPessoa::consultarDsContatoDB(void) {

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	int  iIdPessoa;
	char cDsContato[100];
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iIdPessoa = this->getIdPessoa();
/*o rownum foi colocado devido haver mais de um registro na base
depois de garantida a integridade dos dados deve-se retirar
	*/
	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL SELECT
		dsContato
	INTO
		:cDsContato
	FROM
		customer.PessoaComunicacao
	WHERE
		idPessoa = :iIdPessoa
		AND idTipoComunicacao = 5
		and ROWNUM = 1;

	// ID não existe. Seta o Contato para ""
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw new TuxBasicOraException(sqlca.sqlcode);
	}
    
    this->setDsContato(CUtil::trim(cDsContato));

	return;
 
	sqlErrorConstrutor:
		throw new TuxBasicOraException(sqlca.sqlcode);
}


void CPessoa::consultarIdPessoaDB(int codArea, int nroLinha){

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	int  iIdPessoa;
	int iCodArea;
	int iNroLinha;


 	EXEC SQL END DECLARE SECTION;

	iCodArea = codArea;
	iNroLinha = nroLinha;

    // Seta a Chave da Consulta:
	//iCodArea = codArea;
	//iNroLinha = nroLinha;
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL
	SELECT
		PessoaDePara.IDPESSOA
	INTO
		:iIdPessoa
	FROM
		apoio.arearegistro AreaRegistro,
		linha.linhaBase LinhaBase,
		linha.linhaTelefonica LinhaTelefonica,		
		customer.pessoalinha PessoaLinha,
		customer.pessoadepara PessoaDePara
	WHERE
		 LinhaBase.NRLINHA = :iNroLinha  AND
		 LinhaBase.IDAREAREGISTRO = AreaRegistro.IDAREAREGISTRO AND
		 AreaRegistro.CDAREAREGISTRO = :iCodArea  AND
		 LinhaBase.idlinhabase = LinhaTelefonica.IDLINHABASE AND
		 LinhaTelefonica.IDLINHATELEFONICA = PessoaLinha.IDLINHATELEFONICA AND
		 PessoaLinha.IDPESSOADEPARA = PessoaDePara.IDPESSOADEPARA AND
		 PessoaLinha.idtiporelacionamento = 1;


	
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		EXEC SQL 
		SELECT
			PessoaDePara.IDPESSOA
		INTO
			:iIdPessoa
		FROM
			apoio.arearegistro AreaRegistro,
			linha.linhaBase LinhaBase,
			linha.linhaTelefonica LinhaTelefonica,		
			customer.pessoalinha PessoaLinha,
			customer.pessoadepara PessoaDePara
		WHERE
			 LinhaBase.NRLINHA = :iNroLinha  AND
			 LinhaBase.IDAREAREGISTRO = AreaRegistro.IDAREAREGISTRO AND
			 AreaRegistro.CDAREAREGISTRO = :iCodArea  AND
			 LinhaBase.idlinhabase = LinhaTelefonica.IDLINHABASE AND
			 LinhaTelefonica.IDLINHATELEFONICA = PessoaLinha.IDLINHATELEFONICA AND
			 PessoaLinha.IDPESSOADEPARA = PessoaDePara.IDPESSOADEPARA AND
			 PessoaLinha.idtiporelacionamento = 2;
	 }

	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw new TuxBasicOraException(sqlca.sqlcode);
	}

	this->setIdPessoa(iIdPessoa);

	return;
 
	sqlErrorConstrutor:
		throw new TuxBasicOraException(sqlca.sqlcode);
}

void CPessoa::consultarDadosSessaoDB(int iArea, int iMobNro, char* senha){

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int iIdPessoa;
 	int  iIdTipoRelacionamento;
	int iCodArea;
	int iNroLinha;
/*	int iIdConta;*/
	char cIdSistOrig [255+1];
	char cSgTipoRelacionamento[2];
	char cCdSenha[256];
 	EXEC SQL END DECLARE SECTION;


	memset(cIdSistOrig,' ' , sizeof(cIdSistOrig));

	iCodArea = iArea;
	iNroLinha = iMobNro;

	strcpy( cCdSenha, senha);

    // Seta a Chave da Consulta:
	//iCodArea = codArea;
	//iNroLinha = nroLinha;
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL SELECT
	        D.IDPESSOA, E.SGTIPORELACIONAMENTO, E.IDTIPORELACIONAMENTO,  A.IDLINHASISTEMAORIGEM /*G.IDCONTA,*/
		INTO:
			iIdPessoa, cSgTipoRelacionamento, iIdTipoRelacionamento, cIdSistOrig
     FROM
	 	 LINHA.LINHATELEFONICA  A,
 		 LINHA.LINHABASE  B,
		 APOIO.AREAREGISTRO  B1,
		 CUSTOMER.PESSOALINHA  C, 
		 CUSTOMER.PESSOADEPARA  D,
		 CUSTOMER.PESSOA  D1,
         CUSTOMER.TIPORELACIONAMENTO  E,
  		 CUSTOMER.SENHA  F
    WHERE
		A.IDLINHABASE			= B.IDLINHABASE AND
		B.IDAREAREGISTRO		= B1.IDAREAREGISTRO AND
		C.IDLINHATELEFONICA		= A.IDLINHATELEFONICA AND
		D1.IDPESSOA				= D.IDPESSOA AND
		C.IDPESSOADEPARA		= D.IDPESSOADEPARA AND
		C.IDTIPORELACIONAMENTO	= E.IDTIPORELACIONAMENTO AND   	
		f.idpessoa				= d.idpessoa and
		B1.CdAreaRegistro		= :iCodArea AND
		b.NRLINHA				= :iNroLinha AND
		f.CdSenha				= :cCdSenha;



 
	//Por Enquanto Depos terá de ver com o cliente

	// ID não existe. Seta o Contato para ""
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw new TuxBasicOraException(sqlca.sqlcode);
	}

    this->setIdPessoa(iIdPessoa);
	this->setIdTipoRelacionamento(iIdTipoRelacionamento);
	this->setSgTipoRelacionamento(cSgTipoRelacionamento);
/*	this->setIdConta(iIdConta);*/
    
	  this->setIdSistOrig(cIdSistOrig);

	return;
 
	sqlErrorConstrutor:
		throw new TuxBasicOraException(sqlca.sqlcode);
}
void CPessoa::alterarDsContatoDB(void) {

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int  iIdPessoa;
	char cDsContato[ 256 ];
 	int  iIdUsuarioAlteracao;
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iIdPessoa = this->getIdPessoa();
	strcpy(cDsContato , this->getDsContato());
	iIdUsuarioAlteracao = this->getIdUsuarioAlteracao();

	// verifica se ja tem e-mail cadastrado
	this->consultarDsContatoDB();
	if( 0 == strcmp(this->getDsContato(),"") ) {
		return; // >>>> deve fazer uma inclusao !
	}

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL UPDATE
		customer.PessoaComunicacao 
	SET
		dsContato = :cDsContato
		, idUsuarioAlteracao = :iIdUsuarioAlteracao
		, dtUltimaAlteracao = SYSDATE
	WHERE
		idPessoa = :iIdPessoa
		AND idTipoComunicacao = 5;

	return;
 
	sqlErrorConstrutor:
		throw new TuxBasicOraException(sqlca.sqlcode);
}

