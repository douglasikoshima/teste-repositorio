// Senha.cpp: implementation of the CSenha class.
//
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw.h>
#include "Defines.h"
#include "Util.hpp"
#include "Senha.hpp"


EXEC SQL INCLUDE SQLCA;


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSenha::CSenha(){

    // Inicializacao da Instancia
    m_iIdPessoa = -1;
	strcpy( this->m_cDsFraseSecreta, "" );
	strcpy( this->m_cDsLembreteFraseSecreta, "" );
}

CSenha::~CSenha(){
}


//Interface da Classe CSenha:

// Operações da classe

char* CSenha::consultarLembreteFraseSecreta(int idPessoa){	 
	
	 // Verifica de o idPessoa é Valido
	 if(idPessoa != -1){

	    // Se os Dados da Senha da Pessoa  ainda não foi recuperada do DB, faz a consulta.
	    if( (this->getIdPessoa()) != idPessoa ){	

	       // Armazena a Chave da Consulta:
	       this->setIdPessoa(idPessoa);

	       // Executa a Query no DB
           this->carregarDadosSenhaDB();
	    }
	 }
	 else{
	      throw new TuxBasicSvcException("20E0000","CSenha Valor de idPessoa INVALIDO");
	 }

     // Recupera o Lembrete da Frase Secreta do Cache
     return this->getDsLembreteFraseSecreta();
}

char* CSenha::consultarFraseSecreta(int idPessoa){

	 // Verifica de o idPessoa é Valido
	 if(idPessoa != -1){

	    // Se os Dados da Senha da Pessoa  ainda não foi recuperada do DB, faz a consulta.
	    if( (this->getIdPessoa()) != idPessoa ){	

	       // Armazena a Chave da Consulta:
	       this->setIdPessoa(idPessoa);

	       // Executa a Query no DB
           this->carregarDadosSenhaDB();
	    }
	 }
	 else{
	      throw new TuxBasicSvcException("20E0000","CSenha Valor de idPessoa INVALIDO");
	 }
	
	// Recupera a Frase Secreta do Cache
	return this->getDsFraseSecreta();
}


char* CSenha::obterLembreteSenha(int idPessoa){

	 // Verifica de o idPessoa é Valido
	 if(idPessoa != -1){

	    // Se os Dados da Senha da Pessoa  ainda não foi recuperada do DB, faz a consulta.
	    if( (this->getIdPessoa()) != idPessoa ){	

	       // Armazena a Chave da Consulta:
	       this->setIdPessoa(idPessoa);

	       // Executa a Query no DB
           this->carregarDadosSenhaDB();
	    }
	 }
	 else{
	      throw new TuxBasicSvcException("20E0000","CSenha Valor de idPessoa INVALIDO");
	 }

     // Recupera o Lembrete da Frase Secreta do Cache
     return this->getDsLembreteSenha();
}

void CSenha::alterarFraseSecreta(int idPessoa, char* dsFraseSecreta, char* dsLembreteFraseSecreta){

	 // Verifica de o idPessoa é Valido
	 if(idPessoa != -1){

	    // Armazena a Chave da Alteracao:
	    this->setIdPessoa(idPessoa);

	    // Armazena os demais dados		
		this->setDsFraseSecreta(dsFraseSecreta);
        this->setDsLembreteFraseSecreta(dsLembreteFraseSecreta);

        // Executa a Query no DB
        this->alterarDadosSenhaDB();

	 }
	 else{
	      throw new TuxBasicSvcException("20E0000","CSenha Valor de idPessoa INVALIDO");
	 }
}


/*
  GETs
*/

int CSenha::getIdPessoa(){
	return m_iIdPessoa;
}

char* CSenha::getSenha(){
	return m_cSenha;
}

char * CSenha::getDsFraseSecreta(){
	return m_cDsFraseSecreta;
}

char * CSenha::getDsLembreteFraseSecreta(){
	return m_cDsLembreteFraseSecreta;
}

char * CSenha::getDsLembreteSenha(){
	return m_cDsLembreteSenha;
}

/*
   SETs
 */

void CSenha::setIdPessoa(int value){
	m_iIdPessoa = value;
}

void CSenha::setDsFraseSecreta(char *value){
	strcpy(m_cDsFraseSecreta,value); 
}

void CSenha::setDsLembreteFraseSecreta(char *value){
    strcpy(m_cDsLembreteFraseSecreta,value); 
}

void CSenha::setDsLembreteSenha(char *value){
    strcpy(m_cDsLembreteSenha,value); 
}
void CSenha::setSenha(char *value){
    strcpy(m_cSenha,value); 
}
// PRIVATE


// Métodos de acesso a banco de dados

// Carrega nos atributos da instancia da classe senha
// o registro com dados da Senha da Pessoa em questão (Id)
void CSenha::carregarDadosSenhaDB(void){

	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	
	int  iIdPessoa;
	char cDsLembreteFraseSecreta[256];
	char cDsFraseSecreta[256];
	char cDsLembreteSenha[256];
	EXEC SQL END DECLARE SECTION;


    // Seta a Chave da Consulta:
    iIdPessoa = this->getIdPessoa();

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL SELECT
		NVL(dsLembreteFraseSecreta, ' ') as dsLembreteFraseSecreta,
		NVL(dsFraseSecreta, ' ') as dsFraseSecreta,
		NVL(dsLembreteSenha, ' ') as dsLembreteSenha
	INTO
		:cDsLembreteFraseSecreta, 
		:cDsFraseSecreta, 
		:cDsLembreteSenha
	FROM
	 customer.Senha
	WHERE
	 idPessoa = :iIdPessoa; 

	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw new TuxBasicOraException(sqlca.sqlcode);
	}
    	
	// Retirar espaços em Branco
	CUtil::trim(cDsFraseSecreta);
	CUtil::trim(cDsLembreteFraseSecreta);
	CUtil::trim(cDsLembreteSenha);

	this->setDsFraseSecreta(cDsFraseSecreta);
 	this->setDsLembreteFraseSecreta(cDsLembreteFraseSecreta);	
	this->setDsLembreteSenha(cDsLembreteSenha);			

    //tuxfw_getlogger()->information("QUERY com CHAVE:%d\n", iIdPessoa); 

	return;
 
	sqlErrorConstrutor:
		throw new TuxBasicOraException(sqlca.sqlcode);
}

void CSenha::alterarDadosSenhaDB(void){


	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	
	int  iIdPessoa;
	char cDsFraseSecreta[256];
	char cDsLembreteFraseSecreta[256];
	EXEC SQL END DECLARE SECTION;

    // Seta os dados a Alteraao
	iIdPessoa = this->getIdPessoa();
	strcpy(cDsFraseSecreta, this->getDsFraseSecreta());
	strcpy(cDsLembreteFraseSecreta, this->getDsLembreteFraseSecreta() );

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL UPDATE
		customer.Senha 
	SET
		dsFraseSecreta = :cDsFraseSecreta ,
		dsLembreteFraseSecreta = :cDsLembreteFraseSecreta ,
		dtUltimaAlteracao = SYSDATE

	WHERE
		idPessoa = :iIdPessoa; 

	return;
 
	sqlErrorConstrutor:
		throw new TuxBasicOraException(sqlca.sqlcode);

}