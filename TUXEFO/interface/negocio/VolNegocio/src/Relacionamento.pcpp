// Senha.cpp: implementation of the CSenha class.
//
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE


#include <sqlca.h>
#include <tuxfw.h>
#include "Defines.h"
#include "Relacionamento.hpp"

EXEC SQL INCLUDE SQLCA;


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRelacionamento::CRelacionamento(){

    // Inicializacao da Instancia

	strcpy( this->m_cDsOperacao, "" );
	strcpy( this->m_cDtRelacionamento, "" );
	strcpy( this->m_cHrRelacionamento, "" );
	strcpy( this->m_cDsCanal, "" );
	m_iIdCanal = -1;
}

CRelacionamento::~CRelacionamento(){
}


/*
  GETs
*/

//Setters Para Pesquisa
void CRelacionamento::setDtRelacionamentoInicio(char * value){
	strcpy( this->m_cDtRelacionamentoInicio, value );
}
void CRelacionamento::setDtRelacionamentoFinal(char * value){
	strcpy( this->m_cDtRelacionamentoFinal, value );
}
void CRelacionamento::setCanalPesquisa(char * value){
	strcpy( this->m_cCanalPesquisa, value );
}
void CRelacionamento::setQtdRelac(int i){
	m_QtdRelac = i;
}

//Setters
void CRelacionamento::setDsOperacao(char * value){
	strcpy( this->m_cDsOperacao, value );
}
void CRelacionamento::setDtRelacionamento(char * value){
	strcpy( this->m_cDtRelacionamento, value );
}
void CRelacionamento::setHrRelacionamento(char * value){
	strcpy( this->m_cHrRelacionamento, value );
}
void CRelacionamento::setIdCanal(int i ){
	this->m_iIdCanal = i;
}
void CRelacionamento::setDsCanal(char * value){
	strcpy( this->m_cDsCanal, value );
}

//Getters Para Pesquisa
int CRelacionamento::getQtdRelac(void){
	return m_QtdRelac;
}
char * CRelacionamento::getDtRelacionamentoInicio(void){
	return m_cDtRelacionamentoInicio;
}
char * CRelacionamento::getDtRelacionamentoFinal(void){
	return m_cDtRelacionamentoFinal;
}
char * CRelacionamento::getCanalPesquisa(void){
	return m_cCanalPesquisa;
}

//Getters

char * CRelacionamento::getDsOperacao(void){
	return m_cDsOperacao;
}
char * CRelacionamento::getDtRelacionamento(void){
	return m_cDtRelacionamento;
}
char * CRelacionamento::getHrRelacionamento(void){
	return m_cHrRelacionamento;
}
int CRelacionamento::getIdCanal(void){
	return m_iIdCanal;
}
char * CRelacionamento::getDsCanal(void){
	return m_cDsCanal;
}
	
 


void CRelacionamento::consultarUltimosRelacionamentos(int IdPessoa,
														list< CRelacionamento > & lstRelac){
	CRelacionamento::consultarUltimosRelacionamentosDB(IdPessoa, lstRelac);
}

void CRelacionamento::consultarUltimosRelacionamentosCanal(int IdPessoa,
														list< CRelacionamento > & lstRelac){
	CRelacionamento::consultarUltimosRelacionamentosCanalDB(IdPessoa, lstRelac);
}

void CRelacionamento::consultarRelacionamentosPeriodo(int IdPessoa, list < CRelacionamento > & lstRelac){
	CRelacionamento::consultarRelacionamentosPeriodoDataDB(IdPessoa, lstRelac);
}
	



// PRIVATE
// Métodos de acesso a banco de dados
void CRelacionamento::consultarUltimosRelacionamentosDB(int idCliente, list < CRelacionamento > & lstRelac){

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	int  iIdCliente;
	int iIdCanal;
	char cDataRegistro[ 9+1 ];
	char cHoraRegistro[ 7+1 ];
	char cDtRegistro[ 19+1 ];
	char cDsTipoHistoricoSenha[ 255 ];
	char cNmCanal[ 255 ];
	int  iQtdRelac;
	
 	
	EXEC SQL END DECLARE SECTION;
	
	// valores das chaves da consulta SQL

	memset(&cDtRegistro,			' ', sizeof(cDtRegistro));
	memset(&cDsTipoHistoricoSenha,	' ', sizeof(cDsTipoHistoricoSenha));
	memset(&cNmCanal,				' ', sizeof(cNmCanal));


    iIdCliente = idCliente;
    iQtdRelac = this->getQtdRelac();

	// garante que a lista esta vazia
	lstRelac.clear();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
	EXEC SQL DECLARE LSTRELAC CURSOR FOR

		SELECT *
		FROM
			(SELECT
				HISTORICO, 
				to_char(DATAREGISTRO, 'dd/mm/yyyy hh24:mi:ss'), 
				DSPROCEDENCIA, 
				IDPROCEDENCIA
			FROM
				contatoADM.ContatoFolhaV01
			WHERE
	            IdPessoa = :iIdCliente
				ORDER BY DATAREGISTRO
			DESC )
		WHERE
			RowNum <= :iQtdRelac;
	
	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL OPEN LSTRELAC;

	for( ;; ) {
		// varre todos os registros para criar a lista com os Relacionamentos

		EXEC SQL FETCH LSTRELAC INTO
			:cDsTipoHistoricoSenha
			, :cDtRegistro
			, :cNmCanal
			, :iIdCanal;

			memset(cDataRegistro,			' ', sizeof(cDataRegistro));
			memset(cHoraRegistro,			' ', sizeof(cHoraRegistro));

			sprintf(cDataRegistro, "%10.10s", &cDtRegistro[0]);
			this->setDtRelacionamento(cDataRegistro);

			sprintf(cHoraRegistro, "%8.8s", &cDtRegistro[11]);
			this->setHrRelacionamento(cHoraRegistro);

			this->setDsOperacao(CUtil::trim(cDsTipoHistoricoSenha));

			this->setDsCanal(CUtil::trim(cNmCanal));

			this->setIdCanal(iIdCanal);

				lstRelac.push_back( *this );
		}

	EXEC SQL CLOSE LSTRELAC;
;

	return;


	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 
}

void CRelacionamento::consultarUltimosRelacionamentosCanalDB(int idCliente, list < CRelacionamento > & lstRelac){

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	int  iIdCliente;
	int iIdCanal;
	char cDataRegistro[ 9+1 ];
	char cHoraRegistro[ 7+1 ];
	char cDtRegistro[ 19+1 ];
	char cDsTipoHistoricoSenha[ 255 ];
	char cNmCanal[ 255 ];
	int  iQtdRelac;
	
 	
	EXEC SQL END DECLARE SECTION;
	
	// valores das chaves da consulta SQL

	memset(&cDtRegistro,			' ', sizeof(cDtRegistro));
	memset(&cDsTipoHistoricoSenha,	' ', sizeof(cDsTipoHistoricoSenha));
	memset(&cNmCanal,				' ', sizeof(cNmCanal));

    iIdCliente = idCliente;
    iQtdRelac = this->getQtdRelac();
	iIdCanal = this->getIdCanal();

	// garante que a lista esta vazia
	lstRelac.clear();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    

	EXEC SQL DECLARE LSTRELACCANAL CURSOR FOR

		SELECT *
		FROM
			(SELECT
				HISTORICO, 
				to_char(DATAREGISTRO, 'dd/mm/yyyy hh24:mi:ss'), 
				DSPROCEDENCIA, 
				IDPROCEDENCIA
			FROM
				contatoADM.ContatoFolhaV01
			WHERE
				IdPessoa = :iIdCliente
			AND IDPROCEDENCIA = :iIdCanal
			ORDER BY 
				DATAREGISTRO
			DESC)
		WHERE
			RowNum <= :iQtdRelac;

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL OPEN LSTRELACCANAL;

	for( ;; ) {
		// varre todos os registros para criar a lista com os Relacionamentos

		EXEC SQL FETCH LSTRELACCANAL INTO
			:cDsTipoHistoricoSenha
			, :cDtRegistro
			, :cNmCanal
			, :iIdCanal;

			memset(cDataRegistro,			' ', sizeof(cDataRegistro));
			memset(cHoraRegistro,			' ', sizeof(cHoraRegistro));

			sprintf(cDataRegistro, "%10.10s", &cDtRegistro[0]);
			this->setDtRelacionamento(cDataRegistro);

			sprintf(cHoraRegistro, "%8.8s", &cDtRegistro[11]);
			this->setHrRelacionamento(cHoraRegistro);

			this->setDsOperacao(CUtil::trim(cDsTipoHistoricoSenha));

			this->setDsCanal(CUtil::trim(cNmCanal));

			this->setIdCanal(iIdCanal);

				lstRelac.push_back( *this );
		}

	EXEC SQL CLOSE LSTRELACCANAL;

	return;


	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 
}


void CRelacionamento::consultarRelacionamentosPeriodoDataDB(int idCliente, list < CRelacionamento > & lstRelac){
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;

	int  iIdCliente;
	int iIdCanal;
	char cDataRegistro[ 8+1 ];
	char cHoraRegistro[ 8+1 ];
	char cDtRegistro[ 19+1 ];
	char cDsTipoHistoricoSenha[ 255 ];
	char cNmCanal[ 255 ];
	char cDataInicioPesq[19+1];
	char cDataFimPesq[19+1];
 	
	EXEC SQL END DECLARE SECTION;
	
	// valores das chaves da consulta SQL

	memset(&cDtRegistro,				' ', sizeof(cDtRegistro));
	memset(&cDsTipoHistoricoSenha,	' ', sizeof(cDsTipoHistoricoSenha));
	memset(&cNmCanal,				' ', sizeof(cNmCanal));

    iIdCliente = idCliente;
    sprintf(cDataInicioPesq, "%10.10s 00:00:00", this->getDtRelacionamentoInicio());
	sprintf(cDataFimPesq, "%8.8s 23:59:59", this->getDtRelacionamentoFinal());

	// garante que a lista esta vazia
	lstRelac.clear();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
	EXEC SQL DECLARE LSTRELACDATE CURSOR FOR

		SELECT
			HISTORICO, 
			to_char(DATAREGISTRO, 'dd/mm/yyyy hh24:mi:ss'), 
			DSPROCEDENCIA, 
			IDPROCEDENCIA
		FROM
			contatoADM.ContatoFolhaV01
		WHERE
            IdPessoa = :iIdCliente
            AND DATAREGISTRO  >= TO_DATE( :cDataInicioPesq , 'dd/mm/yyyy  hh24:mi:ss')
			AND DATAREGISTRO  <= TO_DATE( :cDataFimPesq ,    'dd/mm/yyyy  hh24:mi:ss')
			ORDER BY DATAREGISTRO
		DESC;

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL OPEN LSTRELACDATE;

	for( ;; ) {
		// varre todos os registros para criar a lista com os Relacionamentos

		EXEC SQL FETCH LSTRELACDATE INTO
			:cDsTipoHistoricoSenha
			, :cDtRegistro
			, :cNmCanal
			, :iIdCanal;

			memset(cDataRegistro,			' ', sizeof(cDataRegistro));
			memset(cHoraRegistro,			' ', sizeof(cHoraRegistro));

/*			memcpy(cDataRegistro, &cDtRegistro[0], sizeof(cDataRegistro)	);*/
			sprintf(cDataRegistro, "%10.10s", &cDtRegistro[0]);
/*			memcpy(cHoraRegistro, &cDtRegistro[11], sizeof(cHoraRegistro)	);

*/
/*			strncpy(cDataRegistro, &cDtRegistro[0], sizeof(cDataRegistro));*/
			this->setDtRelacionamento(cDataRegistro);
			strncpy(cHoraRegistro, &cDtRegistro[11], sizeof(cHoraRegistro));
			this->setHrRelacionamento(cHoraRegistro);
			this->setDsOperacao(CUtil::trim(cDsTipoHistoricoSenha));
			this->setIdCanal(iIdCanal);
			this->setDsCanal(CUtil::trim(cNmCanal));

	
			lstRelac.push_back( *this );
		}

	EXEC SQL CLOSE LSTRELACDATE;

	return;

	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 
}