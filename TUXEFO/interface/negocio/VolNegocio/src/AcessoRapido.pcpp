#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw.h>
#include "Util.hpp"
#include "AcessoRapido.hpp"

EXEC SQL INCLUDE SQLCA;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAcessoRapido::CAcessoRapido(){

}


CAcessoRapido::~CAcessoRapido() {
}


/*Get*/
int CAcessoRapido::getIdAcessRapid(void){
	return this->m_iIdAcessRapid;
}
char * CAcessoRapido::getNmItem(void){
	return this->m_cNmItem;
}
char * CAcessoRapido::getDsHint(void){
	return this->m_cDsHint;
}

/*Set*/
void CAcessoRapido::setIdAcessRapid(int value){
	this->m_iIdAcessRapid = value;
}
void CAcessoRapido::setNmItem(char * value){
	strcpy(this->m_cNmItem, value);
}
void CAcessoRapido::setDsHint(char * value){
	strcpy(this->m_cDsHint, value);
}


void CAcessoRapido::consultarAcessoRapido(int idPessoa , list <CAcessoRapido> & lstAcess){
	this->consultarAcessoRapidoDB( idPessoa , lstAcess );


}

int CAcessoRapido::insertAcessoRapido(int idPessoa, int idItem){
	return (this->insertAcessoRapidoDB(idPessoa, idItem));
	
}


int CAcessoRapido::excluirAcessoRapido(int idPessoa, int idItem){

	return (this->excluirAcessoRapidoDB(idPessoa, idItem));

}

int CAcessoRapido::excluirAcessoRapidoDB(int idPessoa, int idItem){
	
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		int  iIdPessoa;
		int  iIdPessoaDePara;
		int  iIdItem;
	
 	EXEC SQL END DECLARE SECTION;

	iIdPessoa = idPessoa;
	iIdItem = idItem;
	
	//O select abaixo foi feito deste jeito devido ter usuarios duplicados
	//na base de dados exemplo o usuario 10

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	
	EXEC SQL 
		SELECT idPessoaDePara 
		INTO :iIdPessoaDePara 
		FROM customer.pessoadepara
		where idPessoa = :iIdPessoa
		AND IDPESSOAORIGEM = :iIdPessoa;
		
	EXEC SQL DELETE FROM
		Vol.AcessoRapido 
	WHERE
		idpessoadepara = :iIdPessoaDePara AND
		iditemmenu = :iIdItem;

	EXEC SQL COMMIT;

	
	return 1;

	sqlErrorConstrutor:

	if (sqlca.sqlcode == 1403)
		return -1;
	else
		return 0;

}

int CAcessoRapido::insertAcessoRapidoDB( int idPessoa, int idItem){
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		int  iIdPessoa;
		int  iIdPessoaDePara;
		int  iIdItem;
		int  iIdAcessoRapido;
	
 	EXEC SQL END DECLARE SECTION;

	iIdPessoa = idPessoa;
	iIdItem = idItem;
	
	/*IDPESSOAENDERECO, IDPESSOA, IDPAIS, IDTIPOENDERECO, IDUF, IDSISTEMAORIGEM*/

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL SELECT Vol.AcessoRapidoSQ.NEXTVAL INTO :iIdAcessoRapido FROM DUAL;
	
	EXEC SQL 
		SELECT idPessoaDePara 
		INTO :iIdPessoaDePara 
		FROM customer.pessoadepara
		where idPessoa = :iIdPessoa
		AND IDPESSOAORIGEM = :iIdPessoa;
		
		

	EXEC SQL INSERT INTO 
	Vol.AcessoRapido  (
			IDACESSORAPIDO, IDPESSOADEPARA,	IDITEMMENU	)
	VALUES	(
			  :iIdAcessoRapido
			, :iIdPessoaDePara
			, :iIdItem	);

	EXEC SQL COMMIT;

	
	return 1;

	sqlErrorConstrutor:
		if(sqlca.sqlcode == 0) {
		//throw TuxBasicOraException( sqlca.sqlcode );
			//Erro ao inserir os dados
			return 0;
		}else if (sqlca.sqlcode < 0){
			//Dados Duplicados
			return -1;
		}
}

void CAcessoRapido::consultarAcessoRapidoDB( int idPessoa , list <CAcessoRapido> & lstOMenu){
/*

  Tem de fazer este join., 
select * from 
Vol.ACESSORAPIDO  A1, customer.pessoadepara P1
where a1.IDPESSOADEPARA = p1.IDPESSOADEPARA and idpessoa = 10
	*/
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;

	int  iIdPessoa;
	int iIdAcRapid;
	char cNmItem[256];
	char cDsHint[256];
	EXEC SQL END DECLARE SECTION;


	// valores das chaves da consulta SQL

	memset(cNmItem,					' ', sizeof(cNmItem));

    iIdPessoa = idPessoa;
    
	// garante que a lista esta vazia
	lstOMenu.clear();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
	EXEC SQL DECLARE LSTMENU CURSOR FOR
	SELECT
		c.IDITEMMENU , 
		c.NMITEM,
		c.dsHint
	FROM
		Vol.AcessoRapido  a, 
		customer.pessoadepara b, 
		acesso.itemmenu c
	WHERE 
		a.IDPESSOADEPARA = b.IDPESSOADEPARA and
		a.IDITEMMENU = c.IDITEMMENU and 
		b.IDPESSOA = :iIdPessoa;

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL OPEN LSTMENU;

	for( ;; ) {
		// varre todos os registros para criar a lista com os Relacionamentos


		EXEC SQL FETCH LSTMENU INTO
			  :iIdAcRapid
			, :cNmItem
			, :cDsHint;

						
			this->setIdAcessRapid(iIdAcRapid);
			this->setNmItem(CUtil::trim(cNmItem));
			this->setDsHint(CUtil::trim(cDsHint));

			lstOMenu.push_back( *this );
		}

	EXEC SQL CLOSE LSTMENU;

	return;

	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 
}
