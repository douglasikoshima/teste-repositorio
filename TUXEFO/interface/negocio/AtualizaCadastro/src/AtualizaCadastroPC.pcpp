/* $Id: AtualizaCadastroPC.pcpp,v 1.1 2009/07/31 15:33:41 a5110702 Exp $ */

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
#include <ctype.h>

#include <tuxfw.h>
#include "../../RegistraContato/include/stRegistraContato.h"
#include "../include/stAlteraSenha.h"

extern bool proCRegistraContato(stRegistraContato*);
extern bool proCRegistraContatoAlteracao(int, stRegistraContato*);

int validaClientes(int, int, char*);
int validaUsuarios(int, int, char*);
int testaUsuarios(int, char*);
int obterPessoaUsuario(int, int) ;
int obterPessoaCliente(int, int) ;
int obterSenhaCliente(int) ;

int alteraFraseUsuario(stAlteraSenha*);
int alteraFraseCliente(stAlteraSenha*);

bool alteraSenhaUsuario(stAlteraSenha*);
bool alteraSenhaCliente(stAlteraSenha*);
bool alteraSenhaTelefoneCliente(stAlteraSenha *);
char* trim(char *pStr);

void sql_error_atualizacadastro(sqlca*);

	EXEC SQL BEGIN DECLARE SECTION;
		#include "../include/stAlteraSenha.h"
	EXEC SQL END DECLARE SECTION;

/**
* Valida a senha informada comparando com todas as senhas dos
* clientes de nível superior.
*/
int validaClientes(int idConta, int idPessoa, char* senha)
{
	ULOG_START("validaClientes()"); 
	struct sqlca sqlca;

	int  senhavalida   = 1;

	EXEC SQL BEGIN DECLARE SECTION;
		int   idcontafilho		= idConta;
		int   idpessoa			= idPessoa;
		char  senhateste[256];
		int   idconta			= 0;
		short indidconta		= 0;
		char  senhacliente[256];
		short indsenhacliente	= 0;
	EXEC SQL END DECLARE SECTION;

	strcpy(senhateste, senha);

	EXEC SQL WHENEVER SQLERROR	DO sql_error_atualizacadastro(&sqlca);

	// Verifica a existencia de uma conta pai.
	EXEC SQL 
		SELECT 
			idContaPai
		INTO 
			:idconta:indidconta
		FROM
			customer.ContaHierarquia
		WHERE
			idConta = :idcontafilho;

	if (indidconta != -1 && idconta > 0)
	{
		senhavalida = validaClientes(idconta, idpessoa, senhateste);
	}
	else if (sqlca.sqlcode <= 0)
	{
		senhavalida = 0;
	}

	if (senhavalida == 1) {
		// Testa o cliente da conta atual para validar a senha.
		EXEC SQL 
			SELECT 
				senha
			INTO 
				:senhacliente:indsenhacliente
			FROM
				customer.contasenhaclienteV06
			WHERE
					idConta = :idcontafilho
				AND idPessoa = :idpessoa;

		if ( indsenhacliente != -1 && strcmp ( senhacliente , senhateste ) == 0 )
		{	
			senhavalida = -2;
		}
	}	

	ULOG_END("validaClientes()"); 
	return senhavalida;
	
		
}


bool alteraSenhaTelefoneCliente(stAlteraSenha *m_stDados) 
{
   
	ULOG_START("alteraSenhaTelefoneCliente()"); 
	
	struct sqlca sqlca;

	int prefixo = 0;
	int numero	= 0;
	char cConv[3];

	if ( m_stDados->telefone[0]=='0' ) 
	{
		strncpy(cConv,m_stDados->telefone+1,2);cConv[2]=0;
		prefixo = atoi(cConv);
		numero	= atoi(m_stDados->telefone+3);
	}
	else
	{
		strncpy(cConv,m_stDados->telefone,2);cConv[2]=0;
		prefixo = atoi(cConv);
		numero	= atoi(m_stDados->telefone+2);
	}
	
	EXEC SQL BEGIN DECLARE SECTION;

		int   oprefixo		   = prefixo;
		int   otelefone 	   = numero;

		int    idpessoa 	   = 0;
		short  indidpessoa	   = 0;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR DO sql_error_atualizacadastro(&sqlca);

	EXEC SQL 
		SELECT
			idPessoa
		INTO
			:idpessoa:indidpessoa
		FROM
			customer.TelefoneUsuarioV09
		WHERE
				cdAreaRegistro = :oprefixo
				AND nrLinha    = :otelefone
		AND idTipoRelacionamento = 1;
		
	 ULOG_END("alteraSenhaTelefoneCliente()"); 
	  
	if (indidpessoa != -1 && m_stDados->idPessoa == idpessoa)
	{
		return true;	
	}
	else
	{
		return false;
	}


}


int obterPessoaUsuario(int prefixo, int numero) 
{
	ULOG_START("obterPessoaUsuario()"); 
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;

		int   oprefixo		   = prefixo;
		int   otelefone 	   = numero;
		int    idpessoa 	   = 0;
		short  indidpessoa	   = 0;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR DO sql_error_atualizacadastro(&sqlca);

	EXEC SQL 
		SELECT
			idPessoa
		INTO
			:idpessoa:indidpessoa
		FROM
			customer.TelefoneUsuarioV09
		WHERE
				cdAreaRegistro = :oprefixo
				AND nrLinha    = :otelefone
		AND idTipoRelacionamento = 1;
		

	ULOG_END("obterPessoaUsuario()");		
	
	if (indidpessoa != -1)
	{
		return idpessoa;	
	}
	else
	{
		return 0;
	}
}


int obterPessoaCliente(int prefixo, int numero) 
{
	ULOG_START("obterPessoaCliente()"); 
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;

		int   oprefixo		   = prefixo;
		int   otelefone 	   = numero;
		int    idpessoa 	   = 0;
		short  indidpessoa	   = 0;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR DO sql_error_atualizacadastro(&sqlca);

	EXEC SQL 
		SELECT
			idPessoa
		INTO
			:idpessoa:indidpessoa
		FROM
			customer.TelefoneUsuarioV09
		WHERE
			cdAreaRegistro		= :oprefixo
		AND nrLinha 			= :otelefone
		AND idTipoRelacionamento= 2;
		
	 ULOG_END("obterPessoaCliente()"); 
	 
	if (indidpessoa != -1)
		return idpessoa;	
	else
		return 0;
}

bool proCVerificaSenhasIguaisCliUsu(char* telefone, char* senha, int idTipoRelacionamento)
{
   ULOG_START("proCVerificaSenhasIguaisCliUsu()"); 
   struct sqlca sqlca;

	int  prefixo;
	int  numero;
	char cConv[3];

	strncpy(cConv,telefone,2);
	prefixo = atoi(cConv);
	numero	= atoi(telefone+2);

	EXEC SQL BEGIN DECLARE SECTION;

		int   oprefixo		   = prefixo;
		int   otelefone 	   = numero;
		int   oidTipoRelacionamento = idTipoRelacionamento;
		int    idpessoa 	   = 0;
		short  indidpessoa	   = 0;

		char  cSenhaCorrente[256];
		char  cSenhaBanco[256];

	EXEC SQL END DECLARE SECTION;

	strcpy(cSenhaCorrente, senha);

	//inverte para buscar a senha do outro tipo de relacionamento.
	if (oidTipoRelacionamento == 2)
		oidTipoRelacionamento = 1;
	else
		oidTipoRelacionamento = 2;

	EXEC SQL WHENEVER SQLERROR DO sql_error_atualizacadastro(&sqlca);

	if (oidTipoRelacionamento == 2){
		EXEC SQL
			SELECT
				NVL(s.cdSenha, ' ')
			INTO
				:cSenhaBanco
			FROM
				apoio.AreaRegistro 		 ar,
				linha.LinhaBase 			 lb,
				linha.LinhaTelefonica 	 lt,
				customer.PessoaLinha  	 pl,
				customer.PessoaDePara 	 pdp,
				customer.Senha				 s
			WHERE
				ar.idAreaRegistro			 = lb.idAreaRegistro
			AND lb.idLinhaBase				 = lt.idLinhaBase
			AND lt.idLinhaTelefonica		 = pl.idLinhaTelefonica
			AND pl.idPessoaDePara			 = pdp.idPessoaDePara
			AND pdp.idPessoa				 = s.idPessoa
			AND ar.cdAreaRegistro			 = :oprefixo
			AND lb.nrLinha					 = :otelefone
			AND pl.idTipoRelacionamento 	 = 2;
	}
	else
	{
		EXEC SQL
			SELECT
				NVL(s.cdSenha, ' ')
			INTO
				:cSenhaBanco
			FROM
				apoio.AreaRegistro 		 ar,
				linha.LinhaBase 			 lb,
				linha.LinhaTelefonica 	 lt,
				customer.PessoaLinha  	 pl,
				customer.Senha				 s
			WHERE
				ar.idAreaRegistro			 = lb.idAreaRegistro
			AND lb.idLinhaBase				 = lt.idLinhaBase
			AND lt.idLinhaTelefonica		 = pl.idLinhaTelefonica
			AND pl.idPessoaLinha			 = s.idPessoaLinha
			AND ar.cdAreaRegistro			 = :oprefixo
			AND lb.nrLinha					 = :otelefone
			AND pl.idTipoRelacionamento 	 = 1;
	}

   ULOG_END("proCVerificaSenhasIguaisCliUsu()"); 
	//Verifica se as pessoas (cliente e usuário) são distintas e senhas iguais.
	if ( obterPessoaCliente(prefixo, numero) != obterPessoaUsuario(prefixo, numero) && strcmp(trim(cSenhaCorrente), trim(cSenhaBanco)) == 0 )
		return true;
	else
		return false;
	
}


int obterSenhaCliente(int idPessoaCliente) 
{
	ULOG_START("obterSenhaCliente()"); 
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;

		int   idpessoa		   = idPessoaCliente;
		int    idsenha		  = 0;
		short  indidsenha	  = 0;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR DO sql_error_atualizacadastro(&sqlca);

	EXEC SQL 
		SELECT
			idSenha
		INTO
			:idsenha:indidsenha
		FROM
			customer.Senha
		WHERE
			idPessoa = :idpessoa;
			
	ULOG_END("obterSenhaCliente()"); 
	
	if (indidsenha != -1)
	{
		return idsenha;    
	}
	else
	{
		return 0;
	}


}


/**
* Cria os registros de senhas para a pessoa nos pontos das
* estruturas onde eu não contiver senha ja criada.
*/
bool proCCriaSenhaPessoa(int idPessoa, int idPessoaLinha, char* senha, int tipoPessoa, int idTipoHistoricoSenha, int idCanal, int idTipoSistema, int idPessoaUsuario) 
{
	ULOG_START("proCCriaSenhaPessoa()"); 

	struct sqlca sqlca;

	bool  senhasCriadas = true;

	struct stRegistraContato m_stDados;

	memset(&m_stDados,0,sizeof(m_stDados));

	m_stDados.idTipoHistoricoSenha = idTipoHistoricoSenha;
	m_stDados.idCanal			   = idCanal;
	m_stDados.idTipoSistema 	   = idTipoSistema;
	m_stDados.idPessoaUsuario	   = idPessoaUsuario;
	m_stDados.idTipoSenha		   = 1;
	m_stDados.idTipoStatusSenha    = 1;

	
	EXEC SQL BEGIN DECLARE SECTION;

		int   idpessoa		   = idPessoa;
		int   idpessoalinha    = idPessoaLinha;
		short indidpessoalinha = 0;
		int   idsenhapessoa    = 0;
		short indidsenhapessoa = 0;
		short indidsenhaat = 0;
		int   idpessoadepara   = 0;
		short indidpessoadepara= 0;
		char  senhapessoa[256];
		int   idsenha		   = 0;
	EXEC SQL END DECLARE SECTION;

	strcpy(senhapessoa, senha);

	EXEC SQL WHENEVER SQLERROR DO sql_error_atualizacadastro(&sqlca);

	if (tipoPessoa == 1 || tipoPessoa == 3) {

		EXEC SQL 
			SELECT
				idSenha
			INTO
				:idsenha:indidsenhaat
			FROM
				customer.Senha
			WHERE	
				idPessoaLinha = :idpessoalinha;

		if (sqlca.sqlcode > 0)
		{
			EXEC SQL SELECT customer.SenhasQ.NEXTVAL INTO :idsenha FROM dual;

			EXEC SQL 
				INSERT INTO customer.Senha 
				(
					idSenha,
					cdSenha,
					idTipoStatusSenha, 
					idTipoSenha,
					inTrocaSenha,
					dtUltimaAtualizacao,
					idPessoaLinha
				)
				VALUES
				(
					:idsenha,
					:senhapessoa,
					1,
					1,
					1,
					sysdate,
					:idpessoalinha
				);
		}
		else
		{
				EXEC SQL 
					UPDATE
						customer.Senha 
					SET
						cdSenha = :senhapessoa,
						dtUltimaAtualizacao = sysdate,
						inTrocaSenha = 1,
						idTipoStatusSenha = 1, 
						idTipoSenha = 1
					WHERE
						idSenha = :idsenha;
			
		}		
			strcpy(m_stDados.cdSenha,senha);
		
			m_stDados.idSenha = idsenha;
		
			if (!proCRegistraContato(&m_stDados)) 
			{
				sql_error_atualizacadastro(&sqlca); 			
			}

	}
	
	if (tipoPessoa == 2 || tipoPessoa == 3) 
	{

		EXEC SQL 
			SELECT
				idSenha
			INTO
				:idsenha:indidsenhaat
			FROM
				customer.Senha
			WHERE	
				idPessoa = :idpessoa;

		if (sqlca.sqlcode > 0)
		{
			EXEC SQL SELECT customer.SenhasQ.NEXTVAL INTO :idsenha FROM dual;

		   EXEC SQL 
			   INSERT INTO customer.Senha 
				(
					idSenha,
					cdSenha,
					idTipoStatusSenha, 
					idTipoSenha,
					dtUltimaAtualizacao,
					idPessoa,
					inTrocaSenha
				)
				VALUES
				(
					:idsenha,
					:senhapessoa,
					1,
					1,
					sysdate,
					:idpessoa,
					1
				);
		}
		else
		{
				EXEC SQL 
					UPDATE
						customer.Senha 
					SET
						cdSenha = :senhapessoa,
						dtUltimaAtualizacao = sysdate,
						inTrocaSenha = 1,
						idTipoStatusSenha = 1, 
						idTipoSenha = 1
					WHERE
						idSenha = :idsenha;
			
		}		
	
		strcpy(m_stDados.cdSenha,senha);
		
		m_stDados.idSenha = idsenha;
	
		if (!proCRegistraContato(&m_stDados)) 
		{
			sql_error_atualizacadastro(&sqlca); 			
		}
	}
	
	ULOG_END("proCCriaSenhaPessoa()"); 

	return true;
}

bool alteraSenhaUsuario(stAlteraSenha *m_stDados) 
{
	ULOG_START("alteraSenhaUsuario()"); 
	struct sqlca sqlca;
	struct stRegistraContato m_stRegistraContato;

	memset(&m_stRegistraContato,0,sizeof(m_stRegistraContato));

	bool  senhaAlterada = true;

	int prefixo = 0;
	int numero	= 0;
	char cConv[3];

	ULOG("Atualizando senha: %d\n", atoi(m_stDados->telefone+0));
	ULOG("Atualizando senha: %d, %d\n", prefixo, numero);
	if ( m_stDados->telefone[0]=='0' ) 
	{
		strncpy(cConv,m_stDados->telefone+1,2);cConv[2]=0;
		prefixo = atoi(cConv);
		numero	= atoi(m_stDados->telefone+3);
	}
	else
	{
		strncpy(cConv,m_stDados->telefone,2);cConv[2]=0;
		prefixo = atoi(cConv);
		numero	= atoi(m_stDados->telefone+2);
	}
	ULOG("Atualizando senha: %d, %d\n", prefixo, numero);
	
	EXEC SQL BEGIN DECLARE SECTION;

		int   oprefixo		   = prefixo;
		int   otelefone 	   = numero;

		struct stAlteraSenha dadosoracle;

		int    idsenha		 = 0;
		short  indidsenha	 = 0;

		int    idPessoaLinha	   = 0;
		short  indIdPessoaLinha    = 0;

		int    idsenhareg	 = 0;
		int    newidsenha	 = 0;

	EXEC SQL END DECLARE SECTION;

	memcpy(&dadosoracle, m_stDados, sizeof(dadosoracle));
	ULOG("Tratando senha\n");
	ULOG("Atualizando senha: %d\n", atoi(dadosoracle.telefone));

	EXEC SQL WHENEVER SQLERROR DO sql_error_atualizacadastro(&sqlca);

	EXEC SQL 
		SELECT
			idPessoaLinha
		INTO
			:idPessoaLinha:indIdPessoaLinha
		FROM
			customer.TelefoneUsuarioV09
		WHERE
				cdAreaRegistro = :oprefixo
				AND nrLinha    = :otelefone
		AND idTipoRelacionamento = 1;
	ULOG("Atualizando senha: %d, %d\n", oprefixo, otelefone);
	if (sqlca.sqlcode <= 0)
	{

		ULOG("Obtemos Id senha\n");
		EXEC SQL 
			SELECT
				idSenha
			INTO
				:idsenha:indidsenha
			FROM
				customer.Senha 
			WHERE	
				idPessoaLinha = :idPessoaLinha;
				
		ULOG("Inserimos senha: %s", dadosoracle.cdSenha);
		if (sqlca.sqlcode > 0)
		{
			EXEC SQL SELECT customer.SenhasQ.NEXTVAL INTO :newidsenha FROM dual;
	
			EXEC SQL
			INSERT INTO customer.Senha 
			(
				idSenha,
				cdSenha,
				idTipoStatusSenha, 
				idTipoSenha,
				inTrocaSenha,
				dtUltimaAtualizacao,
				idPessoaLinha
			)
			VALUES
			(
				:newidsenha,
				:dadosoracle.cdSenha,
				1,
				1,
				0,
				sysdate,
				:idPessoaLinha
			);


			EXEC SQL
			UPDATE
				LINHA.LINHATELEFONICA
			SET
				CDSENHAPREATIVA = NULL
			WHERE
				IDLINHABASE  =  (SELECT 
							IDLINHABASE 
						FROM 
							LINHA.LINHABASE LINHABASE, 
							APOIO.AREAREGISTRO AREAREGISTRO
						WHERE 
							LINHABASE.NRLINHA = :otelefone AND
							LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO AND
							AREAREGISTRO.CDAREAREGISTRO = :oprefixo);


			
			idsenhareg = newidsenha;
		}
		else
		{
			idsenhareg = idsenha;
		}

		if ( m_stDados->registraHistorico == 1 ) {
		
			m_stRegistraContato.idTipoHistoricoSenha = m_stDados->idTipoHistoricoSenha;
			m_stRegistraContato.idTipoSistema		 = m_stDados->idTipoSistema;
			m_stRegistraContato.idPessoaUsuario 	 = m_stDados->idPessoaUsuario;
			m_stRegistraContato.idCanal 			 = m_stDados->idCanal;
			strcpy(m_stRegistraContato.obsRegistro, m_stDados->obsRegistro);
			m_stRegistraContato.idPessoaLinha		 = m_stDados->idPessoaLinha;
			m_stRegistraContato.iIdTerminal			 = m_stDados->iIdTerminal;

			proCRegistraContatoAlteracao(idsenhareg, &m_stRegistraContato);

	
		}
	
		if (indidsenha != -1) 
		{
		ULOG("Atualizamos senha\n");
			// Verifica a existencia de uma conta pai.
			EXEC SQL 
				UPDATE
					customer.Senha 
				SET
					cdSenha = :dadosoracle.cdSenha,
					dtUltimaAtualizacao = sysdate,
					inTrocaSenha = :dadosoracle.inTrocaSenha,
					dsLembreteSenha = DECODE(:dadosoracle.dsLembreteSenha,'',NULL,:dadosoracle.dsLembreteSenha),
					idTipoSenha =1,
					qtTentativaErro = NULL
				WHERE
					idSenha = :idsenha;
		}

   }

	ULOG_START("alteraSenhaUsuario()"); 
	return senhaAlterada;
}

int alteraFraseUsuario(stAlteraSenha *m_stDados)
{
	ULOG_START("alteraFraseUsuario()"); 
	
	struct sqlca sqlca;
	struct stRegistraContato m_stRegistraContato;

	memset(&m_stRegistraContato,0,sizeof(m_stRegistraContato));

	bool  senhaAlterada = true;

	int prefixo = 0;
	int numero	= 0;
	char cConv[3];

	ULOG("Atualizando senha: %d\n", atoi(m_stDados->telefone+0));
	ULOG("Atualizando senha: %d, %d\n", prefixo, numero);
	if ( m_stDados->telefone[0]=='0' ) 
	{
		strncpy(cConv,m_stDados->telefone+1,2);cConv[2]=0;
		prefixo = atoi(cConv);
		numero	= atoi(m_stDados->telefone+3);
	}
	else
	{
		strncpy(cConv,m_stDados->telefone,2);cConv[2]=0;
		prefixo = atoi(cConv);
		numero	= atoi(m_stDados->telefone+2);
	}
	ULOG("Atualizando senha: %d, %d\n", prefixo, numero);
	
	EXEC SQL BEGIN DECLARE SECTION;

		int   oprefixo		   = prefixo;
		int   otelefone 	   = numero;

		struct stAlteraSenha dadosoracle;

		int    idsenha		 = 0;
		short  indidsenha	 = 0;

		int    idPessoaLinha	   = 0;
		short  indIdPessoaLinha    = 0;

		int    idsenhareg	 = 0;
		int    newidsenha	 = 0;

	EXEC SQL END DECLARE SECTION;

	memcpy(&dadosoracle, m_stDados, sizeof(dadosoracle));
	ULOG("Tratando senha\n");
	ULOG("Atualizando senha: %d\n", atoi(dadosoracle.telefone));

	EXEC SQL WHENEVER SQLERROR DO sql_error_atualizacadastro(&sqlca);

	EXEC SQL 
		SELECT
			idPessoaLinha
		INTO
			:idPessoaLinha:indIdPessoaLinha
		FROM
			customer.TelefoneUsuarioV09
		WHERE
				cdAreaRegistro = :oprefixo
				AND nrLinha    = :otelefone
		AND idTipoRelacionamento = 1;
	ULOG("Atualizando senha: %d, %d\n", oprefixo, otelefone);
	if (sqlca.sqlcode <= 0)
	{

		ULOG("Obtemos Id senha\n");
		EXEC SQL 
			SELECT
				idSenha
			INTO
				:idsenha:indidsenha
			FROM
				customer.Senha 
			WHERE	
				idPessoaLinha = :idPessoaLinha;
				
		if (sqlca.sqlcode > 0)
		{
		ULOG("Senha nao encontrada\n");
		return -1;
		}
		else
		{
			idsenhareg = idsenha;
		}

		if ( m_stDados->registraHistorico == 1 ) {
		
			m_stRegistraContato.idTipoHistoricoSenha = m_stDados->idTipoHistoricoSenha;
			m_stRegistraContato.idTipoSistema		 = m_stDados->idTipoSistema;
			m_stRegistraContato.idPessoaUsuario 	 = m_stDados->idPessoaUsuario;
			m_stRegistraContato.idCanal 			 = m_stDados->idCanal;
			strcpy(m_stRegistraContato.obsRegistro, m_stDados->obsRegistro);
			m_stRegistraContato.idPessoaLinha		 = m_stDados->idPessoaLinha;
			m_stRegistraContato.iIdTerminal			 = m_stDados->iIdTerminal;

			proCRegistraContatoAlteracao(idsenhareg, &m_stRegistraContato);
	
		}
	
		if (indidsenha != -1) 
		{
		ULOG("Atualizamos senha\n");
			// Verifica a existencia de uma conta pai.
			EXEC SQL 
				UPDATE
					customer.Senha 
				SET
					dsFraseSecreta = NULL,
					dsLembreteSenha = NULL,
					qtTentativaFraseSecreta = 0,
					idStatusSenhaFraseSecreta = 1,
					dtBloqueioFraseSecreta = NULL,
					dtUltimaAtualizacao = sysdate,
					idTipoSenha = 1
				WHERE
					idSenha = :idsenha;
		}
   }
   
   ULOG_END("alteraFraseUsuario()"); 

   return 0;
}

bool alteraSenhaCliente(stAlteraSenha *m_stDados) 
{
	ULOG_START("alteraSenhaCliente()"); 

	struct sqlca sqlca;
	struct stRegistraContato m_stRegistraContato;

	memset(&m_stRegistraContato,0,sizeof(m_stRegistraContato));

	bool  senhaAlterada = true;

	int prefixo = 0;
	int numero	= 0;
	char cConv[3];

	ULOG("Atualizando senha: %d\n", atoi(m_stDados->telefone+0));
	ULOG("Atualizando senha: %d, %d\n", prefixo, numero);

	if ( m_stDados->telefone[0]=='0' ) 
	{
		strncpy(cConv,m_stDados->telefone+1,2);cConv[2]=0;
		prefixo = atoi(cConv);
		numero	= atoi(m_stDados->telefone+3);
	}
	else
	{
		strncpy(cConv,m_stDados->telefone,2);cConv[2]=0;
		prefixo = atoi(cConv);
		numero	= atoi(m_stDados->telefone+2);
	}
	

	EXEC SQL BEGIN DECLARE SECTION;

		struct stAlteraSenha dadosoracle;

		int    idsenha		 = 0;
		short  indidsenha	 = 0;

		int    idsenhareg	 = 0;
		int    newidsenha	 = 0;
		int    oprefixo		   = prefixo;
		int    otelefone 	   = numero;

	EXEC SQL END DECLARE SECTION;

	memcpy(&dadosoracle, m_stDados, sizeof(dadosoracle));

	
	EXEC SQL WHENEVER SQLERROR DO sql_error_atualizacadastro(&sqlca);

	EXEC SQL 
		SELECT
			idSenha
		INTO
			:idsenha:indidsenha
		FROM
			customer.Senha 
		WHERE	
			idPessoa = :dadosoracle.idPessoa;

	ULOG("No existe Senha para el cliente: %d\n", dadosoracle.idPessoa);
	ULOG("Inserimos senha: %s", dadosoracle.cdSenha);

	if (sqlca.sqlcode > 0)
	{
		ULOG("No existe Senha para el cliente: %d\n", dadosoracle.idPessoa);
	
		EXEC SQL SELECT customer.SenhasQ.NEXTVAL INTO :newidsenha FROM dual;

		EXEC SQL
		INSERT INTO customer.Senha 
		(
			idSenha,
			cdSenha,
			idTipoStatusSenha, 
			idTipoSenha,
			inTrocaSenha,
			dtUltimaAtualizacao,
			idPessoa
		)
		VALUES
		(
			:newidsenha,
			:dadosoracle.cdSenha,
			1,
			1,
			0,
			sysdate,
			:dadosoracle.idPessoa
		);
		
		idsenhareg = newidsenha;


		EXEC SQL
		UPDATE
			LINHA.LINHATELEFONICA
		SET
			CDSENHAPREATIVA = NULL
		WHERE
			IDLINHABASE  =  (SELECT 
						IDLINHABASE 
					FROM 
						LINHA.LINHABASE LINHABASE, 
						APOIO.AREAREGISTRO AREAREGISTRO
					WHERE 
						LINHABASE.NRLINHA = :otelefone AND
						LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO AND
						AREAREGISTRO.CDAREAREGISTRO = :oprefixo);

	

	}
	else
	{
		idsenhareg = idsenha;
	}

	if ( m_stDados->registraHistorico == 1 ) {
	
		m_stRegistraContato.idTipoHistoricoSenha = m_stDados->idTipoHistoricoSenha;
		m_stRegistraContato.idTipoSistema		 = m_stDados->idTipoSistema;
		m_stRegistraContato.idPessoaUsuario 	 = m_stDados->idPessoaUsuario;
		m_stRegistraContato.idCanal 			 = m_stDados->idCanal;
		strcpy(m_stRegistraContato.obsRegistro, m_stDados->obsRegistro);
		m_stRegistraContato.idPessoaLinha		 = m_stDados->idPessoaLinha;
		m_stRegistraContato.iIdTerminal			 = m_stDados->iIdTerminal;
		

		proCRegistraContatoAlteracao(idsenhareg, &m_stRegistraContato);

	}

	if (indidsenha != -1) 
	{
	
		// Verifica a existencia de uma conta pai.
		EXEC SQL 
			UPDATE
				customer.Senha 
			SET
				cdSenha = :dadosoracle.cdSenha,
				dtUltimaAtualizacao = sysdate,
				inTrocaSenha = :dadosoracle.inTrocaSenha,
				idTipoSenha = 1,
				dsLembreteSenha = DECODE(:dadosoracle.dsLembreteSenha,'',NULL,:dadosoracle.dsLembreteSenha)
			WHERE
				idSenha = :idsenha;
	}

	/*Como seja atualizada a senha do cliente, será necessário atualizar também a senha do usuario 
	  em outras linhas em que a mesma pessoa seja cliente e usuário.	
	*/
	EXEC SQL
		UPDATE
			customer.Senha 
		SET
			cdSenha 			= :dadosoracle.cdSenha,
			dtUltimaAtualizacao = sysdate,
			idTipoSenha = 1,
			inTrocaSenha		= :dadosoracle.inTrocaSenha,
			dsLembreteSenha 	= DECODE(:dadosoracle.dsLembreteSenha,'',NULL,:dadosoracle.dsLembreteSenha)
		WHERE
			idPessoaLinha IN
				(SELECT
						idPessoaLinha
				FROM	
						customer.SenhaClienteUsuarioIguaisV01
				WHERE
						idPessoaLinha	 IN
											(SELECT idPessoaLinha
											FROM	customer.PessoaLinha	pl,
													customer.PessoaDePara	pdp
											WHERE	pl.idPessoaDePara		= pdp.idPessoaDePara
											AND 	pdp.idPessoa			= :dadosoracle.idPessoa)
				AND 	(TO_CHAR(cdAreaRegistro) || TO_CHAR(nrLinha)) != :dadosoracle.telefone
				AND 	idTipoRelacionamento = 1);
				
	 ULOG_END("alteraSenhaCliente()"); 

	return senhaAlterada;
}

int alteraFraseCliente(stAlteraSenha *m_stDados) 
{
	ULOG_START("alteraFraseCliente()"); 

	struct sqlca sqlca;
	struct stRegistraContato m_stRegistraContato;

	memset(&m_stRegistraContato,0,sizeof(m_stRegistraContato));

	EXEC SQL BEGIN DECLARE SECTION;

		struct stAlteraSenha dadosoracle;

		int    idsenha		 = 0;
		short  indidsenha	 = 0;

		int    idsenhareg	 = 0;
		int    newidsenha	 = 0;

	EXEC SQL END DECLARE SECTION;

	memcpy(&dadosoracle, m_stDados, sizeof(dadosoracle));

	EXEC SQL WHENEVER SQLERROR DO sql_error_atualizacadastro(&sqlca);

	EXEC SQL 
		SELECT
			idSenha
		INTO
			:idsenha:indidsenha
		FROM
			customer.Senha 
		WHERE	
			idPessoa = :dadosoracle.idPessoa;

	if (sqlca.sqlcode > 0)
	{
	
	ULOG("Nao existe Senha para el cliente: %d\n", dadosoracle.idPessoa);
	return -1;
	}
	else
	{
		idsenhareg = idsenha;
	}

	if ( m_stDados->registraHistorico == 1 ) {
	
		m_stRegistraContato.idTipoHistoricoSenha = m_stDados->idTipoHistoricoSenha;
		m_stRegistraContato.idTipoSistema		 = m_stDados->idTipoSistema;
		m_stRegistraContato.idPessoaUsuario 	 = m_stDados->idPessoaUsuario;
		m_stRegistraContato.idCanal 			 = m_stDados->idCanal;
		strcpy(m_stRegistraContato.obsRegistro, m_stDados->obsRegistro);
		m_stRegistraContato.idPessoaLinha		 = m_stDados->idPessoaLinha;
		m_stRegistraContato.iIdTerminal			 = m_stDados->iIdTerminal;
		m_stRegistraContato.iIdTerminal			 = m_stDados->iIdTerminal;

		proCRegistraContatoAlteracao(idsenhareg, &m_stRegistraContato);

	}

	if (indidsenha != -1) 
	{
		// Actualiza la senha.
		EXEC SQL 
			UPDATE
				customer.Senha 
			SET
				dsFraseSecreta = NULL,
				dsLembreteSenha = NULL,
				qtTentativaFraseSecreta = 0,
				idStatusSenhaFraseSecreta = 1,
				idTipoSenha = 1,
				dtBloqueioFraseSecreta = NULL,
				dtUltimaAtualizacao = sysdate
			WHERE
				idSenha = :idsenha;
	}
	
	ULOG_END("alteraFraseCliente()"); 

	return 0;
}

bool proCAlteraSenha(stAlteraSenha *m_stDados) 
{
	ULOG_START("alteraFraseCliente()"); 
	struct sqlca sqlca;

	bool senhaAlterada = true;

	char cConv[3];

	EXEC SQL BEGIN DECLARE SECTION;
		int 		idPessoaLinha = 0;
		int		prefixo = 0;
		int		numero	= 0;
		int		idTipoRelacionamento =0;
	EXEC SQL END DECLARE SECTION;

	if ( m_stDados->telefone[0]=='0' ) 
	{
		strncpy(cConv,m_stDados->telefone+1,2);cConv[2]=0;
		prefixo = atoi(cConv);
		numero	= atoi(m_stDados->telefone+3);
	}
	else
	{
		strncpy(cConv,m_stDados->telefone,2);cConv[2]=0;
		prefixo = atoi(cConv);
		numero	= atoi(m_stDados->telefone+2);
	}

	idTipoRelacionamento = m_stDados->titularidadeSenha;

	EXEC SQL WHENEVER SQLERROR DO sql_error_atualizacadastro(&sqlca);

	EXEC SQL 
		SELECT
			idPessoaLinha
		INTO
			:idPessoaLinha
		FROM
			apoio.AreaRegistro 	 a,
			linha.LinhaBase 		 b,
			linha.LinhaTelefonica  c,
			customer.PessoaLinha	 d
		WHERE	
			a.idAreaRegistro		 = b.idAreaRegistro
		AND b.idLinhaBase			 = c.idLinhaBase
		AND c.idLinhaTelefonica 	 = d.idLinhaTelefonica
		AND a.cdAreaRegistro		 = :prefixo
		AND b.nrLinha				 = :numero
		AND d.idTipoRelacionamento	 = :idTipoRelacionamento;

	
	//adiciona o idPessoaLinha a estrutura
	m_stDados->idPessoaLinha = idPessoaLinha;


	//Caso esteja reiniciando ou alterando a senha do usuário E cliente e usuario forem a mesma pessoa, efetua a alteracao para ambos.
	if ( obterPessoaCliente(prefixo, numero) == obterPessoaUsuario(prefixo, numero) && m_stDados->titularidadeSenha == 1 )
		m_stDados->titularidadeSenha = 2;


	if (m_stDados->titularidadeSenha == 2)
	{
	ULOG("Altera Senha Cliente\n");
		senhaAlterada = alteraSenhaCliente(m_stDados);

	}

	if ( m_stDados->titularidadeSenha == 1 || alteraSenhaTelefoneCliente(m_stDados) )
	{
	ULOG("Altera Senha Usuario: %s\n", (char *)m_stDados->telefone);
	ULOG("Altera Senha Usuario: %s\n", (char *)m_stDados->cdSenha);
		senhaAlterada = alteraSenhaUsuario(m_stDados);
	}
	ULOG_END("alteraFraseCliente()"); 
	return senhaAlterada;
}

int proCAlteraFrase(stAlteraSenha *m_stDados) 
{
	ULOG_START("proCAlteraFrase()"); 
	struct sqlca sqlca;

	int fraseAlterada = 0;

	char cConv[3];

	EXEC SQL BEGIN DECLARE SECTION;
	
	   int	 idPessoaLinha = 0;
	   int	 prefixo = 0;
	   int	 numero  = 0;
	   int	 idTipoRelacionamento =0;
	   
	EXEC SQL END DECLARE SECTION;

	if ( m_stDados->telefone[0]=='0' ) 
	{
		strncpy(cConv,m_stDados->telefone+1,2);cConv[2]=0;
		prefixo = atoi(cConv);
		numero	= atoi(m_stDados->telefone+3);
	}
	else
	{
		strncpy(cConv,m_stDados->telefone,2);cConv[2]=0;
		prefixo = atoi(cConv);
		numero	= atoi(m_stDados->telefone+2);
	}

	idTipoRelacionamento = m_stDados->titularidadeSenha;

	EXEC SQL WHENEVER SQLERROR DO sql_error_atualizacadastro(&sqlca);

	EXEC SQL 
		SELECT
			idPessoaLinha
		INTO
			:idPessoaLinha
		FROM
			apoio.AreaRegistro 	 a,
			linha.LinhaBase 		 b,
			linha.LinhaTelefonica  c,
			customer.PessoaLinha	 d
		WHERE	
			a.idAreaRegistro		 = b.idAreaRegistro
		AND b.idLinhaBase			 = c.idLinhaBase
		AND c.idLinhaTelefonica 	 = d.idLinhaTelefonica
		AND a.cdAreaRegistro		 = :prefixo
		AND b.nrLinha				 = :numero
		AND d.idTipoRelacionamento	 = :idTipoRelacionamento;

	
	//adiciona o idPessoaLinha a estrutura
	m_stDados->idPessoaLinha = idPessoaLinha;


	//Caso esteja reiniciando ou alterando a senha do usuário E cliente e usuario forem a mesma pessoa, efetua a alteracao para ambos.
	if ( obterPessoaCliente(prefixo, numero) == obterPessoaUsuario(prefixo, numero) && m_stDados->titularidadeSenha == 1 )
		m_stDados->titularidadeSenha = 2;


	if (m_stDados->titularidadeSenha == 2)
	{
	ULOG("Altera Frase Cliente\n");
		fraseAlterada = alteraFraseCliente(m_stDados);

	}

	if ( m_stDados->titularidadeSenha == 1 || alteraSenhaTelefoneCliente(m_stDados) )
	{
	ULOG("Altera Frase Usuario para el telefone: %s\n", (char *)m_stDados->telefone);
	ULOG("Altera Frase Usuario para la senha: %s\n", (char *)m_stDados->cdSenha);
		fraseAlterada = alteraFraseUsuario(m_stDados);
	}
	
	ULOG_END("proCAlteraFrase()"); 
	
	return fraseAlterada;
}

/**
* Valida a senha informada comparando com todas as senhas dos
* usuários dos níveis inferiores ao cliente.
*/
int validaUsuarios(int idConta, int idPessoa, char* senha)
{
	ULOG_START("validaUsuarios()"); 
	int  senhavalida   = 1;
	/*struct sqlca sqlca;


	

	EXEC SQL BEGIN DECLARE SECTION;
		int   idcontapai		= idConta;
		int   idpessoa			= idPessoa;
		char  senhateste[256];
		int   idconta			= 0;
		short indidconta		= 0;
		char  senhacliente[256];
		short indsenhacliente	= 0;
	EXEC SQL END DECLARE SECTION;

	strcpy(senhateste, senha);

	EXEC SQL WHENEVER SQLERROR	DO sql_error_atualizacadastro(&sqlca);

	// Verifica a existencia de uma conta filho
	EXEC SQL 
		SELECT 
			idConta
		INTO 
			:idconta:indidconta
		FROM
			customer.ContaHierarquia
		WHERE
			idContaPai = :idcontapai;

	if (indidconta != -1 && idconta > 0)
	{
		senhavalida = validaUsuarios(idconta, idpessoa, senhateste);
	

	}
	else
	{
	ULOG("Obtenemos Senha cliente: %d , %d\n", idcontapai, idpessoa);
		EXEC SQL 
			SELECT 
				senha
			INTO 
				:senhacliente:indsenhacliente
			FROM
				customer.ContaSenhaClienteV06
			WHERE
					idConta = :idcontapai
				AND idPessoa != :idpessoa;

		if ( indsenhacliente != -1 && strcmp ( senhacliente , senhateste ) == 0 ) 
		{	
		ULOG("Senha no Valida: %d\n", strcmp ( senhacliente , senhateste ));
		ULOG("Senha no Valida: %s, %s\n", senhacliente , senhateste);
			senhavalida = -2;
		}
	}

	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	if (senhavalida == 1) {
		// Testa os usuários da conta atual verificando as senhas.
	ULOG("Obtenemos Senha Usuario: %d , %d\n", idcontapai, idpessoa);
		EXEC SQL DECLARE usuarioSenha CURSOR FOR
			SELECT 
				senha
			FROM
				customer.ContaSenhaUsuarioV01
			WHERE
					idConta = :idcontapai
				AND idPessoa != :idpessoa;

		// Executa o cursor.
		EXEC SQL OPEN usuarioSenha;

		while(true)
		{

			EXEC SQL FETCH usuarioSenha INTO :senhacliente:indsenhacliente;

			if ( indsenhacliente != -1 && strcmp ( senhacliente , senhateste ) == 0 ) 
			{	
				senhavalida = -2;
			}

		}

		EXEC SQL CLOSE usuarioSenha;

   }   
   */
   ULOG_END("validaUsuarios()"); 

	return senhavalida;
}

int senhaFraca(char* senha)
{
   ULOG_START("senhaFraca()"); 
	int contador = 0;
	int lenSenha = strlen(senha);
	
	int indSeq = 0;
	
	int numAtual = 0;
	int numAnterior = 0;
	int numContador = 0;
	
	char carAtual[1];
	char carAnterior[1];
	
		ULOG("Senha A Comprobar: %s\n", senha); 
	for (int i=0; i<lenSenha; i++)
	{
		strncpy(carAtual, senha + i, 1);
			ULOG("Car Atual: %s\n", carAtual);	
		numAtual = atoi(carAtual);
			ULOG("Num Atual: %d\n", numAtual);	
		
		for (int j=0; j<lenSenha; j++)
		{
			strncpy(carAnterior , senha + j, 1);
			numContador = atoi(carAnterior);
				ULOG("Car Anterior: %s\n", carAnterior);	
				ULOG("Num Contador: %d\n", numContador);	
			if ((i != j) && (numAtual == numContador))
			{
				contador++;
					ULOG("Contador: %d\n", contador);
			}
		}		
		if (contador > 2)
			break;
		else
			contador = 0;
		ULOG("Num Anterior: %d\n", numAnterior);	
		if (i>1)
		{
			if (numAtual == (numAnterior + 1))
				numAnterior = numAtual;
			else
			{
				if (numAtual == (numAnterior - 1))
					numAnterior = numAtual;
				else
					indSeq = 1;
			}
		}
		else
			numAnterior = numAtual;
	}
	ULOG_END("senhaFraca()"); 
	if (contador > 2)
		return -3;
	if (indSeq == 0)
		return -4;
	return 0;
	
}
/**
* Busca os clientes ligados ao usuário e compara o CPF
* do usuário com dos clientes, caso algum cliente possua 
* o mesmo grupo de 4 primeiros dígitos que algum usuário
* retorna como true, caso contrario false.
*/
int proCSenhaValida(int idPessoa, char* telefone, char* senha, int tipoPessoa)
{
	ULOG_START("proCSenhaValida()"); 

	struct sqlca sqlca;

	int senhavalida = 1;
	int prefixo = 0;
	int numero	= 0;
	char cConv[3];

	int indSenhaFraca = 0;
	
	//indSenhaFraca = senhaFraca(senha);
	//if (indSenhaFraca < 0)
		//return indSenhaFraca;
		

	if ( telefone[0]=='0' ) 
	{
		strncpy(cConv,telefone+1,2);cConv[2]=0;
		prefixo = atoi(cConv);
		numero	= atoi(telefone+3);
	}
	else
	{
		strncpy(cConv,telefone,2);
		cConv[2]=0;
		prefixo = atoi(cConv);
		numero	= atoi(telefone+2);
	}
	
	EXEC SQL BEGIN DECLARE SECTION;

		int   idpessoa		= idPessoa;
		int   idpessoalinha 	 = 0;
		int   idsenha	   = 0;
		char  senhateste[256];
		int   idconta		= 0;
		short indidconta	= 0;
		short indidpessoalinha	  = 0;
		short indidsenha	= 0;
	EXEC SQL END DECLARE SECTION;

	strcpy(senhateste, senha);

	EXEC SQL WHENEVER SQLERROR	DO sql_error_atualizacadastro(&sqlca);

	idpessoalinha = obterPessoaUsuario(prefixo, numero);

	idsenha = obterSenhaCliente(idpessoa);


	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	 // Declara o cursor a ser executado.
	  EXEC SQL DECLARE clienteConta CURSOR FOR
		  SELECT 
			  idConta
		  FROM
			  customer.ClienteContaV01
		  WHERE
			  idPessoaOrigem = :idpessoa;

	  // Executa o cursor.
	  EXEC SQL OPEN clienteConta;

	  // Buscará os níveis superiores até encontar uma senha incompatível ou acabar o loop.
	  while (senhavalida == 1) 
	  {

		  EXEC SQL FETCH clienteConta INTO :idconta:indidconta;


		  if (indidconta != -1 && idconta > 0)
		  {
		  if (tipoPessoa != 2)
		  {

			  senhavalida = validaUsuarios(idconta, idpessoalinha, senhateste);

		  }
		  else
		  {
				  senhavalida = validaUsuarios(idconta, idpessoa, senhateste);
			  
			  }
		  }
		  else
		  {
			  senhavalida = 0;
		  }
	  }

	  EXEC SQL CLOSE clienteConta;
	

	 ULOG_END("proCSenhaValida()"); 
	return senhavalida;
}


/**
* Busca no banco de dados se o cliente faz parte tanto da 
* estrutura de cliente como de usuário.
* Retorna:
*	1 - Para usuário.
*	2 - Para cliente.
*	3 - Para usuário/cliente.
*/
int proCTipoPessoa(int idPessoa)
{
	ULOG_START("proCTipoPessoa()"); 
	
	struct sqlca sqlca;

	int tipoPessoa = 0;
	int cliente    = 0;
	int usuario    = 0;

	EXEC SQL BEGIN DECLARE SECTION;
		int idPessoaOrigem	= 0;
		int possuiLinha 	= 0;
		int possuiConta 	= 0;
		short indPossuiLinha, indPossuiConta = 0;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR DO sql_error_atualizacadastro(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	// Atribui o valor do parametro no escopo da query.
	idPessoaOrigem = idPessoa;

	// Declara o cursor a ser executado.
	EXEC SQL DECLARE buscaTipoPessoa CURSOR FOR
		SELECT 
			idPessoaLinha,
			idPessoaConta
		FROM
			customer.UsuarioClienteV10
		WHERE
			idPessoaOrigem = :idPessoaOrigem;

	// Executa o cursor.
	EXEC SQL OPEN buscaTipoPessoa;

	while (true)
	{
	  EXEC SQL FETCH buscaTipoPessoa INTO :possuiLinha:indPossuiLinha, :possuiConta:indPossuiConta;

	  if (indPossuiLinha != -1 && possuiLinha > 0)
		usuario = 1;

	  if (indPossuiConta != -1 && possuiConta > 0)
		cliente = 1;

	}

	EXEC SQL CLOSE buscaTipoPessoa;

	if (usuario > 0 && cliente == 0)
		tipoPessoa = 1;
	else if (usuario == 0 && cliente > 0)
		tipoPessoa = 2;
	else if (usuario > 0 && cliente > 0)
		tipoPessoa = 3;
	else
		tipoPessoa = -1;
	ULOG_END("proCTipoPessoa()"); 
  return tipoPessoa;

}


/**
* Função de chamada do teste recursivo de senhas inferiores ao usuário.
*/
int testaUsuarios(int idPessoa, char* senha)
{
	ULOG_START("testaUsuarios()"); 
	
	struct sqlca sqlca;

	int  senhavalida = 1;

	EXEC SQL BEGIN DECLARE SECTION;
		int   idpessoa			= idPessoa;
		char   senhateste[256];
		int   idconta			= 0;
		short indidconta		= 0;
	EXEC SQL END DECLARE SECTION;

	strcpy(senhateste, senha);

	EXEC SQL WHENEVER SQLERROR DO sql_error_atualizacadastro(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	// Verifica a existencia de uma conta pai.
		EXEC SQL DECLARE testeUsuario CURSOR FOR
			SELECT 
				idConta
			FROM
				customer.ClienteContaV01
			WHERE
				idPessoaOrigem = :idpessoa;

		// Executa o cursor.
		EXEC SQL OPEN testeUsuario;

		// Buscará os níveis superiores até encontar uma senha incompatível ou acabar o loop.
		while (senhavalida == 1) 
		{

			EXEC SQL FETCH testeUsuario INTO :idconta:indidconta;

			if (indidconta != -1 && idconta > 0)
			{
				senhavalida = validaUsuarios(idconta, idpessoa, senhateste);
			}
			else
			{
				senhavalida = 0;
			}
		}

		EXEC SQL CLOSE testeUsuario;

	ULOG_END("testaUsuarios()"); 
	return senhavalida;
}





char* rtrim(char *pStr)
{
   
   
	int rInd;

	if (pStr == NULL)
			return NULL;

   rInd = strlen(pStr) - 1;
   while ( isspace(pStr[rInd]) && rInd >= 0){
	  rInd--;
   }

   pStr[rInd + 1] = '\0';
   
   return pStr;
}

char* ltrim(char *pStr)
{
	int lInd = 0;

	if (pStr == NULL)
			return NULL;

	//rInd = strlen(pStr) - 1;

	while (isspace(pStr[lInd])){
		lInd++;
	}

	pStr = pStr + lInd;
	 
   return pStr;
}

char* trim(char *pStr){
	return ltrim(rtrim(pStr));		
}


void sql_error_atualizacadastro(sqlca*sqlca)
{
throw new TuxBasicOraException(sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc,sqlca->sqlerrm.sqlerrml);
//	throw TuxBasicOraException(sqlca->sqlcode);
}
