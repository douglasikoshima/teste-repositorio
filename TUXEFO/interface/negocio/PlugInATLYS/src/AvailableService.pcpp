#include "AvailableService.h"

#include <tuxfw.h>
#include "../../PlugInBE/include/Util.h"


#include <cstring>

using namespace std;


// Defines para o Oracle 
#define NO_MORE_ROWS	1403
#define NO_DATA_FOUND	1403
#define END_OF_CURSOR	1403
#define TOO_MANY_ROWS	1422
#define NULL_FETCHED	1405
#define COL_TRUNCATED	1406


EXEC SQL INCLUDE SQLCA;


CAvailableService::CAvailableService()
{
	strcpy (m_cName,"");
	strcpy (m_cType,"");
}

CAvailableService::~CAvailableService(){}


// Setters
void CAvailableService::setName(char* pcName)
{
	if(pcName == NULL)
		return;

	strcpy (this->m_cName,pcName);
}

void CAvailableService::setType(char* pcType)
{

	if(pcType == NULL)
		return;

	strcpy (this->m_cType,pcType);
}


// Getters	
char* CAvailableService::getName()
{
	return this->m_cName; 
}

char* CAvailableService::getType()
{
	return this->m_cType;
}


// Sobrecarga do operador de atribuição.
CAvailableService& CAvailableService::operator=(const CAvailableService& oASrc)
{
	
	// Faz a Atruibução.
	strcpy( this->m_cName, oASrc.m_cName );
	strcpy( this->m_cType, oASrc.m_cType );

	return *this;
};


// Select of type of Servico in DB
char* CAvailableService::getTypeServiceDB(char *pcNameService, char *pcTypeService)
{

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;	
		char cNameService[30];
		char cTypeService[30];
 	EXEC SQL END DECLARE SECTION;


    // Seta a Chave da Consulta:
    strcpy(cNameService , Util::trim(pcNameService));

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	tuxfw_getlogger()->debug("CAvailableService::getTypeServiceDB():SELECT");

	//-- Query que receba um SVC_NAME e devolva um SVC_TYPE_CODE.
	EXEC SQL SELECT
		 cdTipoServicoSistemaOrig	
	INTO
		 :cTypeService
	FROM
	     linha.planoservico
	WHERE
	      ((dtexpiracao is null) OR (dtexpiracao >= SYSDATE)) AND idservicosistemaorigem = :cNameService AND NOT cdTipoServicoSistemaOrig IS NULL;

	// ID não existe. Seta o ID para -1.
/*
	if (sqlca.sqlcode == NO_DATA_FOUND)
	{ 
		tuxfw_getlogger()->debug("CAvailableService::getTypeServiceDB():NO_DATA_FOUND");
		
		throw new TuxBasicOraException(sqlca.sqlcode);
	}
*/
    	
	// Retirar espaços em Branco
	
	strcpy(pcTypeService, Util::trim(cTypeService));

    tuxfw_getlogger()->information("Name: %s Type returned:%s\n", cNameService, pcTypeService); 

	return pcTypeService;
  

	sqlErrorConstrutor:
	    tuxfw_getlogger()->debug("CAvailableService::getTypeServiceDB(): ERRO_DB %s",sqlca.sqlcode);
		throw new TuxBasicOraException(sqlca.sqlcode);
}

char* CAvailableService::getSysDateBD(char *cDate, char *cFormato)
{

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;	
	char cSysDate[30];
	char cFormatDate[30];
 	EXEC SQL END DECLARE SECTION;

	strcpy(cFormatDate, cFormato);

	tuxfw_getlogger()->debug("FORMATO SYSDATE :%s", cFormatDate); 

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	//-- Query para pegar o SYSDATE do DB.
	EXEC SQL SELECT
		TO_CHAR( SYSDATE , :cFormatDate)	 
	INTO 
	    :cSysDate
	FROM DUAL;
	
	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND)
		throw new TuxBasicOraException(sqlca.sqlcode);
    	
	// Retirar espaços em Branco
	
	strcpy(cDate, Util::trim(cSysDate));

    tuxfw_getlogger()->debug("SYSDATE :%s", cDate); 

	return cDate;
  
	sqlErrorConstrutor:
		throw new TuxBasicOraException(sqlca.sqlcode);
}


// Return a list of All Members of Service
void  CAvailableService::getMembersServiceDB(char *pcNameService, list<CAvailableService>& lstMembers)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		char cNameService[30];
		char cTypeService[30];
	EXEC SQL END DECLARE SECTION;


	// Seta a Chave da Consulta:
    strcpy(cNameService , Util::trim(pcNameService));

	CAvailableService oService;

	// garante que a lista esta vazia
	lstMembers.clear();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	//-- Query que receba um SVC_NAME e devolva o SVC_TYPE_CODE e o SVC_NAME dos membros.

	EXEC SQL DECLARE MEMBERSERVICE CURSOR FOR

	SELECT planoservico.idservicosistemaorigem,
		   planoservico.cdtiposervicosistemaorig
    FROM linha.planoservico planoservico
    WHERE planoservico.idservico IN (
			SELECT pacote.idservico
			FROM linha.planoservico planoservico, 
				 linha.pacote       pacote
			WHERE planoservico.idservico = pacote.idservicopai AND
				  ((planoservico.dtexpiracao is null) OR (planoservico.dtexpiracao >= SYSDATE)) AND 
				  planoservico.idservicosistemaorigem = :cNameService);

	EXEC SQL WHENEVER NOT FOUND DO break;

	EXEC SQL OPEN MEMBERSERVICE;

	while(1)
	{

		// varre todos os registros para criar a lista com os servicos

		EXEC SQL FETCH MEMBERSERVICE INTO

			:cNameService ,
			:cTypeService;

		oService.setName( Util::trim( cNameService ) ); 
		oService.setType( Util::trim( cTypeService ) ); 

		lstMembers.push_back( oService );
	}

	EXEC SQL CLOSE MEMBERSERVICE;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 
};
