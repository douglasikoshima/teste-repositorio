// PessoaEndereco.cpp: implementation of the PessoaEndereco class.
//
//////////////////////////////////////////////////////////////////////

#include "../include/PessoaEndereco.h"
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

PessoaEndereco::PessoaEndereco()
{

}

PessoaEndereco::~PessoaEndereco()
{

}

int PessoaEndereco::listEnderecos(char *idPessoa,ListEnderecoPrePago&listEnderecoPrePago)
{
	tuxfw_getlogger()->debug("PessoaEndereco::listEnderecos");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct param{
			VARCHAR idEndereco[21];
			VARCHAR inAtualEndereco[21];
			VARCHAR idTipoEnderecoSelecionado[21];
			VARCHAR dsTituloLogradouro[256];
			VARCHAR dsTipoLogradouro[256];
			VARCHAR dsLogradouro[256];
			VARCHAR nrEndereco[256];
			VARCHAR dsComplementoEndereco[256];
			VARCHAR dsBairro[256];
			VARCHAR dsMunicipio[256];
			VARCHAR nrCEP[256];
			VARCHAR idUFEndereco[21];
			VARCHAR dsUFEndereco[256];
			VARCHAR idPaisEndereco[21];
			VARCHAR dsPaisEndereco[256];
		}m_param;
		struct iparam{
			short idEndereco;
			short inAtualEndereco;
			short idTipoEnderecoSelecionado;
			short dsTituloLogradouro;
			short dsTipoLogradouro;
			short dsLogradouro;
			short nrEndereco;
			short dsComplementoEndereco;
			short dsBairro;
			short dsMunicipio;
			short nrCEP;
			short idUFEndereco;
			short dsUFEndereco;
			short idPaisEndereco;
			short dsPaisEndereco;
		}m_iparam;
		char *cidPessoa = idPessoa;
	EXEC SQL END DECLARE SECTION;	
	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	EXEC SQL DECLARE CURSORENDERECO CURSOR FOR
		SELECT
			  PESSOAENDERECO.IDPESSOAENDERECO,
			  PESSOAENDERECO.INENDERECOPREFERENCIAL,
			  PESSOAENDERECO.IDTIPOENDERECO,
			  TRIM(PESSOAENDERECO.NMTITULOLOGRADOURO),
			  TRIM(PESSOAENDERECO.NMTIPOLOGRADOURO),
			  TRIM(PESSOAENDERECO.NMLOGRADOURO),
			  TRIM(PESSOAENDERECO.NRENDERECO),
			  TRIM(PESSOAENDERECO.DSENDERECOCOMPLEMENTO),
			  TRIM(PESSOAENDERECO.NMBAIRRO),
			  TRIM(PESSOAENDERECO.NMMUNICIPIO),
			  TRIM(PESSOAENDERECO.NRCEP),
			  PESSOAENDERECO.IDUF,
			  UF.NMUF,
			  PESSOAENDERECO.IDPAIS,
			  PAIS.SGPAIS
		FROM
			CUSTOMER.PESSOAENDERECO  PESSOAENDERECO,
			APOIO.UF  UF,
			APOIO.PAIS  PAIS,
			CUSTOMER.CONTAENDERECO  CONTAENDERECO
		WHERE
			 PESSOAENDERECO.IDUF = UF.IDUF AND
			 PAIS.IDPAIS = PESSOAENDERECO.IDPAIS AND
			 PESSOAENDERECO.IDPESSOAENDERECO = CONTAENDERECO.IDPESSOAENDERECO AND
			 IDPESSOA = :cidPessoa;
	EXEC SQL OPEN CURSORENDERECO;
	for(;;)
	{
		memset(&m_param,0,sizeof(param));
		memset(&m_iparam,0,sizeof(m_iparam));
		EXEC SQL FETCH CURSORENDERECO INTO :m_param:m_iparam;	
		EnderecoPrePago *enderecoPrePago = new EnderecoPrePago();
		enderecoPrePago->setIdEndereco((char*)m_param.idEndereco.arr);
		enderecoPrePago->setInAtualEndereco((char*)m_param.inAtualEndereco.arr);
		enderecoPrePago->setIdTipoEnderecoSelecionado((char*)m_param.idTipoEnderecoSelecionado.arr);
		enderecoPrePago->setDsTituloLogradouro((char*)m_param.dsTituloLogradouro.arr);
		enderecoPrePago->setDsTipoLogradouro((char*)m_param.dsTipoLogradouro.arr);
		enderecoPrePago->setDsLogradouro((char*)m_param.dsLogradouro.arr);
		enderecoPrePago->setNrEndereco((char*)m_param.nrEndereco.arr);
		enderecoPrePago->setDsComplementoEndereco((char*)m_param.dsComplementoEndereco.arr);
		enderecoPrePago->setDsBairro((char*)m_param.dsBairro.arr);
		enderecoPrePago->setDsMunicipio((char*)m_param.dsMunicipio.arr);
		enderecoPrePago->setNrCEP((char*)m_param.nrCEP.arr);
		enderecoPrePago->setIdUFEndereco((char*)m_param.idUFEndereco.arr);
		enderecoPrePago->setDsUFEndereco((char*)m_param.dsUFEndereco.arr);
		enderecoPrePago->setIdPaisEndereco((char*)m_param.idPaisEndereco.arr);
		enderecoPrePago->setDsPaisEndereco((char*)m_param.dsPaisEndereco.arr);
		listEnderecoPrePago.add(enderecoPrePago);
	}	
	EXEC SQL CLOSE CURSORENDERECO;
	return 1;
Error:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int PessoaEndereco::verificaEndereco(char*nrCep,char*logradouro,ListEnderecoPrePago&listEnderecoPrePago)
{
	tuxfw_getlogger()->debug("PessoaEndereco::verificaEndereco");	
	struct sqlca sqlca;
	int count = 0;
	EXEC SQL BEGIN DECLARE SECTION;
		struct param{
			VARCHAR codLogradouro[21];
			VARCHAR codCep[21];
			VARCHAR cidade[256];
			VARCHAR tipoLogradouro[256];
			VARCHAR tituloLogradouro[256];
			VARCHAR bairro[256];
			VARCHAR logradouro[256];
			VARCHAR slgUF[256];
		}m_param;
		struct iparam{
			short codLogradouro;
			short codCep;
			short cidade;
			short tipoLogradouro;
			short tituloLogradouro;
			short bairro;
			short logradouro;
			short slgUF;
		}m_iparam;
		char *cnrCep = nrCep;
		char clogradouro[256];
	EXEC SQL END DECLARE SECTION;	

	Util::alltrim(logradouro);
	sprintf(clogradouro,"%s%%",logradouro);
	tuxfw_getlogger()->debug("logradouro = %s ",clogradouro);	

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	EXEC SQL DECLARE CURSOR_ENDERECO_CEP CURSOR FOR
		SELECT
			DISTINCT
			LOGRADOURO.COD_LOGRADOURO,
			CEP.COD_CEP,
			LOCALIDADE.DSC_LOCALIDADE,
			TIPOLOGRADOURO.DSC_TIPO_LOGRAD,
			TITULOLOGRADOURO.DSC_TITULO_LOGRAD,
			BAIRRO.NOM_BAIRRO,
			LOGRADOURO.NOM_LOGRADOURO,
			UF.SGL_UF
		FROM
			ENDERECO.LOGRADOURO LOGRADOURO,
			ENDERECO.CEP CEP,
			ENDERECO.REL_CEP_LOGRAD_BAIRRO REL,
			ENDERECO.LOCALIDADE LOCALIDADE,
			ENDERECO.TIPO_LOGRADOURO TIPOLOGRADOURO,
			ENDERECO.TITULO_LOGRADOURO TITULOLOGRADOURO,
			ENDERECO.BAIRRO BAIRRO,
			ENDERECO.UNIDADE_FEDERACAO UF
		WHERE
			LOGRADOURO.COD_LOGRADOURO = REL.COD_LOGRADOURO AND
			LOGRADOURO.COD_LOCALIDADE = LOCALIDADE.COD_LOCALIDADE AND
			LOGRADOURO.COD_TIPO_LOGRAD = TIPOLOGRADOURO.COD_TIPO_LOGRAD AND
			REL.COD_BAIRRO = BAIRRO.COD_BAIRRO AND
			LOCALIDADE.COD_UF = UF.COD_UF AND
			LOGRADOURO.COD_TITULO_LOGRAD = TITULOLOGRADOURO.COD_TITULO_LOGRAD(+) AND
			CEP.COD_CEP = REL.COD_CEP AND
			UPPER(LOGRADOURO.NOM_LOGRADOURO) LIKE UPPER(:clogradouro) AND
			CEP.NUM_CEP = :cnrCep;	
	EXEC SQL OPEN CURSOR_ENDERECO_CEP;
	for(;;)
	{
		memset(&m_param,0,sizeof(param));
		memset(&m_iparam,0,sizeof(m_iparam));
		EXEC SQL FETCH CURSOR_ENDERECO_CEP INTO :m_param:m_iparam;	
		EnderecoPrePago *enderecoPrePago = new EnderecoPrePago();
		enderecoPrePago->setDsTituloLogradouro((char*)m_param.tituloLogradouro.arr);
		enderecoPrePago->setDsTipoLogradouro((char*)m_param.tipoLogradouro.arr);
		enderecoPrePago->setDsLogradouro((char*)m_param.logradouro.arr);
		enderecoPrePago->setDsBairro((char*)m_param.bairro.arr);
		enderecoPrePago->setDsMunicipio((char*)m_param.cidade.arr);
		enderecoPrePago->setDsUFEndereco((char*)m_param.slgUF.arr);
		listEnderecoPrePago.add(enderecoPrePago);
		count++;
	}	
	EXEC SQL CLOSE CURSOR_ENDERECO_CEP;
	if(count == 0)
		return 0;

	return 1;
Error:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int PessoaEndereco::getPais(char*sgPais,char*idPais)
{
	tuxfw_getlogger()->debug("PessoaEndereco::getPais");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct param{
			VARCHAR idPais[21];
		}m_param;
		struct iparam{
			short idPais;
		}m_iparam;
		char *csgPais = sgPais;
	EXEC SQL END DECLARE SECTION;	

	memset(&m_param,0,sizeof(param));
	memset(&m_iparam,0,sizeof(m_iparam));	

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND GOTO Error;
	EXEC SQL
		SELECT
			IDPAIS
		INTO
			:m_param:m_iparam
		FROM
			APOIO.PAIS 
		WHERE
			SGPAIS = :csgPais AND ROWNUM = 1;

	strcpy(idPais,(char*)m_param.idPais.arr);

	return 1;
Error:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int PessoaEndereco::getUF(char*sgUF,char*idUF)
{
	tuxfw_getlogger()->debug("PessoaEndereco::getUF");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct param{
			VARCHAR idUF[21];
		}m_param;
		struct iparam{
			short idUF;
		}m_iparam;
		char *csgUF = sgUF;
	EXEC SQL END DECLARE SECTION;	

	memset(&m_param,0,sizeof(param));
	memset(&m_iparam,0,sizeof(m_iparam));	

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND GOTO Error;
	EXEC SQL
		SELECT
			  IDUF
		INTO
			:m_param:m_iparam
		FROM
			APOIO.UF 
		WHERE
		UPPER(SGUF) = UPPER(:csgUF) AND ROWNUM = 1;

	strcpy(idUF,(char*)m_param.idUF.arr);

	return 1;
Error:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int PessoaEndereco::getTipoEndereco(char*idTipoEndereco)
{
	tuxfw_getlogger()->debug("PessoaEndereco::getTipoEndereco");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct param{
			VARCHAR idTipoEndereco[21];
		}m_param;
		struct iparam{
			short idTipoEndereco;
		}m_iparam;
	EXEC SQL END DECLARE SECTION;	

	memset(&m_param,0,sizeof(param));
	memset(&m_iparam,0,sizeof(m_iparam));	

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND GOTO Error;
	EXEC SQL
		SELECT 
			 IDTIPOENDERECO
		INTO
			:m_param:m_iparam
		FROM 
			 APOIO.TIPOENDERECO  
		WHERE SGTIPOENDERECO = 'COB' AND ROWNUM = 1;

	strcpy(idTipoEndereco,(char*)m_param.idTipoEndereco.arr);

	return 1;
Error:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);
}

void PessoaEndereco::consultarEnderecosDB(char*idPessoa,ListEnderecoPrePago&listEnderecoPrePago)
{
	struct sqlca sqlca;
	tuxfw_getlogger()->debug("PessoaEndereco::consultarEnderecosDB");
	EXEC SQL BEGIN DECLARE SECTION;
	char*  iIdPessoa = idPessoa;
	struct param{		
		VARCHAR	iIdPessoaEndereco[256];
		VARCHAR idTipoEndereco[256];
		VARCHAR idTipoEnderecoCobranca[256];
		long	iIdConta;
	}m_param;
	struct iparam{
		short  iIdPessoaEndereco;
		short  idTipoEndereco;
		short  idTipoEnderecoCobranca;
		short  iIdConta;
	}m_iparam;
	EXEC SQL END DECLARE SECTION;
		
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL DECLARE CONSULTARENDCONTALINHAV01 CURSOR FOR
	
	SELECT 
		*
	FROM 
	(
		SELECT
			idPessoaEndereco,
			idTipoEndereco,
			idTipoEnderecoCobranca,
			idConta
		FROM 
			customer.consultarEndContaLinhaV01
		WHERE
			idPessoa = :iIdPessoa			
		UNION
		SELECT
			idPessoaEndereco,
			idTipoEndereco,
			idTipoEnderecoCobranca,
			idConta
		FROM 
			customer.consultarEndContaLinhaV02
		WHERE
			idPessoa = :iIdPessoa			
	)
	ORDER BY
		idTipoEndereco, idTipoEnderecoCobranca, idPessoaEndereco;


	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	EXEC SQL OPEN CONSULTARENDCONTALINHAV01;

	for(;;) 
	{
		memset(&m_param,0,sizeof(m_param));
		memset(&m_iparam,0,sizeof(m_iparam));

		// varre todos os registros para criar a lista com os servicos
		EXEC SQL FETCH CONSULTARENDCONTALINHAV01 INTO :m_param:m_iparam;		
		if(m_param.iIdConta != 0){		
			tuxfw_getlogger()->debug("possui conta associada IDCONTA=%l",m_param.iIdConta);
			EnderecoPrePago *enderecoPrePago = new EnderecoPrePago();
			enderecoPrePago->setIdEndereco((char*)m_param.iIdPessoaEndereco.arr);
			enderecoPrePago->setIdTipoEnderecoSelecionado((char*)m_param.idTipoEndereco.arr);
			listEnderecoPrePago.add(enderecoPrePago);
			break;
		}		
	}

	EXEC SQL CLOSE CONSULTARENDCONTALINHAV01;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}