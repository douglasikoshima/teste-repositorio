// ImagemConta.pcpp: implementation of the ImagemConta class.
//
//////////////////////////////////////////////////////////////////////
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
#include "ImagemConta.h"
#include "RemoteLog.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

ImagemConta::ImagemConta()
{

}

ImagemConta::~ImagemConta()
{

}

int ImagemConta::getDataFase()
{
	tuxfw_getlogger()->debug("ImagemConta::getDataFase");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR m_data[25];
		short m_idata;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	memset(&m_data,0,sizeof(m_data));
	m_idata = 0;

	EXEC SQL
		SELECT TO_CHAR(TO_DATE(DSVALORPARAMETRO,'YYYYMMDD'),'YYYYMMDD') 
		INTO :m_data:m_idata
		FROM APOIO.PARAMETRO 
		WHERE CDPARAMETRO='PARAM_DT_CICLO_XENOS';
	
	return (int)atoi((char*)m_data.arr);

Error:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int ImagemConta::getURLImagem(char*url)
{
	tuxfw_getlogger()->debug("ImagemConta::getURLImagem");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR m_data[512];
		short m_idata;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR GOTO Error;

	memset(&m_data,0,sizeof(m_data));
	m_idata = 0;

	EXEC SQL
		SELECT DSVALORPARAMETRO
		INTO :m_data:m_idata
		FROM APOIO.PARAMETRO 
		WHERE CDPARAMETRO='URL_HOST_IMG_XENOS';
	
	strcpy(url,(char*)m_data.arr);
	
	return 1;

Error:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);
}

bool ImagemConta::selectImagemConta(struct stImagemConta &stDados)
{
	tuxfw_getlogger()->debug("ImagemConta::selectImagemConta");
	struct sqlca sqlca;
	m_stDados = &stDados;
	int minutosParametro = this->getMinutoParametro();

	// verifica se existe as infomações passadas na base
	if(selectIdContaSistemaOrigem() != 1)
	{
		return false;
	}

	if(strlen(stDados.idConta)==0 || strcmp(stDados.dtFimCiclo,"")==0)
	{
		return false;
	}

	Util::formataData(stDados.dtFimCiclo);

	EXEC SQL BEGIN DECLARE SECTION;
		char*dtFimCiclo = stDados.dtFimCiclo;
		char*idConta = stDados.idConta;
		char*sgTipoImagem = stDados.sgTipoImagem;
		int inXml = stDados.inXml;
		struct imagem{
			VARCHAR nmImagem[255+1];
			VARCHAR nmPathDetalhada[255+1];
			VARCHAR nmPathResumida[255+1];
			VARCHAR nmPathBoleto[255+1];
			VARCHAR sgTipoImagem[2+1];
			int inProcessado;
			int dia;
			int minutos;
		}stImagem;
		struct imagem_ind{
			short nmImagem;
			short nmPathDetalhada;
			short nmPathResumida;
			short nmPathBoleto;
			short sgTipoImagem;
			short inProcessado;
			short dia;
			short minutos;
		}stImagemInd;
	EXEC SQL END DECLARE SECTION;

	memset(&stImagem,0,sizeof(stImagem));
	memset(&stImagemInd,0,sizeof(stImagemInd));

	// sqlca.sqlcode=0;

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
	SELECT
		TRIM(IMG.NMIMAGEM),
		IMG.NMPATHDETALHADA,
		IMG.NMPATHRESUMIDA,
		IMG.NMPATHBOLETO,
		TPIMG.SGTIPOIMAGEM,
		IMG.INPROCESSADO,
		TO_NUMBER((TO_DATE(SYSDATE,'DD/MM/RRRR') - TO_DATE(IMG.DTULTIMAALTERACAO,'DD/MM/RRRR'))) AS DIA,
		TO_NUMBER(((TO_NUMBER(TO_CHAR(SYSDATE,'HH24'))*60) + TO_NUMBER(TO_CHAR(SYSDATE,'MI'))) - ((TO_NUMBER(TO_CHAR(IMG.DTULTIMAALTERACAO,'HH24'))*60) + TO_NUMBER(TO_CHAR(IMG.DTULTIMAALTERACAO,'MI')))) AS MINUTOS
	INTO
		:stImagem:stImagemInd
	FROM
		VOL.IMAGEMCONTA IMG,
		APOIO.TIPOIMAGEM TPIMG
	WHERE
		TPIMG.IDTIPOIMAGEM = IMG.IDTIPOIMAGEM AND
		TPIMG.SGTIPOIMAGEM = :sgTipoImagem AND
		IMG.IDCONTA = :idConta AND
		IMG.DTFIMCICLO = TO_DATE(:dtFimCiclo,'DD/MM/RRRR') AND
		IMG.INXML = :inXml AND
		IMG.DTULTIMAALTERACAO > TO_DATE(SYSDATE-30,'DD/MM/RRRR');

	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);

	if(sqlca.sqlcode == 1403)
	{
		tuxfw_getlogger()->debug("Não Encontrou Registro");
		return false;
	} // Se o xenos ainda não processou a imagem dentro do tempo parametrizado, devemos retornar erro para reprocessar
	else if((stImagem.inProcessado == 0 && stImagem.dia == 0 && stImagem.minutos >= minutosParametro) || (stImagem.inProcessado == 0 && stImagem.dia > 0))
	{
		tuxfw_getlogger()->debug("Parametrização de tempo de execução do xenos");
		tuxfw_getlogger()->debug("TEMPO DE PARAMETRIZAÇÃO EM MINUTOS = %d",minutosParametro);
		tuxfw_getlogger()->debug("QUANTIDADE DE MINUTOS ENTRE A ÚLTIMA ATUALIZAÇÃO E SYSDATE = %d",stImagem.minutos);
		tuxfw_getlogger()->debug("DIFERENÇA DE DIAS = %d",stImagem.dia);
		return false;
	}
	else
	{
		tuxfw_getlogger()->debug("OK");
		strcpy(m_stDados->nmImagem,(char*)stImagem.nmImagem.arr);
		strcpy(m_stDados->nmPathDetalhada,(char*)stImagem.nmPathDetalhada.arr);
		strcpy(m_stDados->nmPathResumida,(char*)stImagem.nmPathResumida.arr);
		strcpy(m_stDados->nmPathBoleto,(char*)stImagem.nmPathBoleto.arr);
		strcpy(m_stDados->sgTipoImagem,(char*)stImagem.sgTipoImagem.arr);
		m_stDados->inProcessado = stImagem.inProcessado;
		return true;
	}
Error:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);
}

bool ImagemConta::salvarDados()
{
	tuxfw_getlogger()->debug("ImagemConta::salvarDados");
	// chamar serviço SETIMAGEM de forma assincrona para gravação de dados.
	CRemoteLogBase remote;
	TuxMessage o_inputMessage;
	XMLGen xmlEnvio;
	char*sMsgIn = NULL;
	xmlEnvio.createTag("dados");
	xmlEnvio.addItem("dtFimCiclo",m_stDados->dtFimCiclo);
	xmlEnvio.addItem("idConta",m_stDados->idConta);
	xmlEnvio.addItem("sgTipoImagem",m_stDados->sgTipoImagem);
	xmlEnvio.addItem("nmImagem",m_stDados->nmImagem);
	xmlEnvio.addItem("idTipoImagem",m_stDados->idTipoImagem);
	xmlEnvio.addItem("inXml",m_stDados->inXml);
	xmlEnvio.closeTag();

	o_inputMessage.setMessageBody(&xmlEnvio);
	o_inputMessage.setService("SETIMAGEM");
	o_inputMessage.setUser("1");

	// Repassa configuracoes ao manipulador do serviço remoto e invoca o servico.
	try
	{
		sMsgIn = o_inputMessage.getMessageXML();
		remote.remoteCall("SETIMAGEM", sMsgIn, 0);
		tuxfw_getlogger()->debug("chamada realizada com sucesso");
		tuxfw_getlogger()->debug("desalocar sMsgIn");
		if(sMsgIn!=NULL)free(sMsgIn);
		return 1;
	}
	catch(...)
	{
		tuxfw_getlogger()->debug("CRemoteLogBase::log erro ao invocar serviço");
		tuxfw_getlogger()->debug("desalocar sMsgIn");
		if(sMsgIn!=NULL)free(sMsgIn);
		return 0;
	}
}
	
bool ImagemConta::callProcessamento(int processado)
{
	tuxfw_getlogger()->debug("ImagemConta::callFinalizarProcessamento");
	// chamar serviço SETIMAGEM de forma assincrona para gravação de dados.
	CRemoteLogBase remote;
	TuxMessage o_inputMessage;
	XMLGen xmlEnvio;
	char*sMsgIn = NULL;
	xmlEnvio.createTag("dados");
	xmlEnvio.addItem("dtFimCiclo",m_stDados->dtFimCiclo);
	xmlEnvio.addItem("idConta",m_stDados->idConta);
	xmlEnvio.addItem("sgTipoImagem",m_stDados->sgTipoImagem);
	xmlEnvio.addItem("nmImagem",m_stDados->nmImagem);
	xmlEnvio.addItem("idTipoImagem",m_stDados->idTipoImagem);
	xmlEnvio.addItem("inXml",m_stDados->inXml);
	xmlEnvio.addItem("nmPathDetalhada",m_stDados->nmPathDetalhada);
	xmlEnvio.addItem("nmPathResumida",m_stDados->nmPathResumida);
	xmlEnvio.addItem("nmPathBoleto",m_stDados->nmPathBoleto);
	xmlEnvio.addItem("processado",processado);
	xmlEnvio.closeTag();

	o_inputMessage.setMessageBody(&xmlEnvio);
	o_inputMessage.setService("SETIMAGEM");
	o_inputMessage.setUser("1");

	// Repassa configuracoes ao manipulador do serviço remoto e invoca o servico.
	try
	{
		sMsgIn = o_inputMessage.getMessageXML();
		remote.remoteCall("SETIMAGEM", sMsgIn, 0);
		tuxfw_getlogger()->debug("chamada realizada com sucesso");
		tuxfw_getlogger()->debug("desalocar sMsgIn");
		if(sMsgIn!=NULL)free(sMsgIn);
		return 1;
	}
	catch(...)
	{
		tuxfw_getlogger()->debug("CRemoteLogBase::log erro ao invocar serviço");
		tuxfw_getlogger()->debug("desalocar sMsgIn");
		if(sMsgIn!=NULL)free(sMsgIn);
		return 0;
	}
}

bool ImagemConta::callRemoverImagem()
{
	tuxfw_getlogger()->debug("ImagemConta::callRemoverImagem");
	// chamar serviço SETIMAGEM de forma assincrona para gravação de dados.
	CRemoteLogBase remote;
	TuxMessage o_inputMessage;
	XMLGen xmlEnvio;
	char*sMsgIn = NULL;
	xmlEnvio.createTag("dados");
	xmlEnvio.addItem("dtFimCiclo",m_stDados->dtFimCiclo);
	xmlEnvio.addItem("idConta",m_stDados->idConta);
	xmlEnvio.addItem("sgTipoImagem",m_stDados->sgTipoImagem);
	xmlEnvio.addItem("nmImagem",m_stDados->nmImagem);
	xmlEnvio.addItem("idTipoImagem",m_stDados->idTipoImagem);
	xmlEnvio.addItem("inXml",m_stDados->inXml);
	xmlEnvio.addItem("nmPathDetalhada",m_stDados->nmPathDetalhada);
	xmlEnvio.addItem("nmPathResumida",m_stDados->nmPathResumida);
	xmlEnvio.addItem("nmPathBoleto",m_stDados->nmPathBoleto);
	xmlEnvio.addItem("processado","0");
	xmlEnvio.addItem("remover","1");
	xmlEnvio.closeTag();

	o_inputMessage.setMessageBody(&xmlEnvio);
	o_inputMessage.setService("SETIMAGEM");
	o_inputMessage.setUser("1");

	// Repassa configuracoes ao manipulador do serviço remoto e invoca o servico.
	try
	{
		sMsgIn = o_inputMessage.getMessageXML();
		remote.remoteCall("SETIMAGEM", sMsgIn, 0);
		tuxfw_getlogger()->debug("chamada realizada com sucesso");
		tuxfw_getlogger()->debug("desalocar sMsgIn");
		if(sMsgIn!=NULL)free(sMsgIn);
		return 1;
	}
	catch(...)
	{
		tuxfw_getlogger()->debug("CRemoteLogBase::log erro ao invocar serviço");
		tuxfw_getlogger()->debug("desalocar sMsgIn");
		if(sMsgIn!=NULL)free(sMsgIn);
		return 0;
	}
}


bool ImagemConta::gravarRegistro(struct stImagemConta &stDados, int processado)
{
	tuxfw_getlogger()->debug("ImagemConta::gravarRegistro");
	struct sqlca sqlca;
	
	m_stDados = &stDados;
	// detelar imagem antiga caso exista
	deleteImagemConta();

	EXEC SQL BEGIN DECLARE SECTION;
		char*dtFimCiclo = m_stDados->dtFimCiclo;
		char*idConta = m_stDados->idConta;
		char*sgTipoImagem = m_stDados->sgTipoImagem;
		char*nmImagem = m_stDados->nmImagem;
		char*cidTipoImagem = m_stDados->idTipoImagem;
		char*nmPathDetalhada = m_stDados->nmPathDetalhada;
		char*nmPathResumida = m_stDados->nmPathResumida;
		char*nmPathBoleto = m_stDados->nmPathBoleto;
		int inXml = m_stDados->inXml;
		int iprocessado = processado;
	EXEC SQL END DECLARE SECTION;

	sqlca.sqlcode=0;

	if(m_stDados->nmImagem == NULL || (m_stDados->nmImagem != NULL && strlen(m_stDados->nmImagem) == 0))
		nmImagem = "0";

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
	INSERT INTO 
		VOL.IMAGEMCONTA 
		(IDIMAGEMCONTA,IDCONTA,IDTIPOIMAGEM,DTFIMCICLO,NMIMAGEM,INXML,IDUSUARIOALTERACAO,DTULTIMAALTERACAO,NMPATHDETALHADA,NMPATHRESUMIDA,NMPATHBOLETO,INPROCESSADO)
	VALUES (
	VOL.IMAGEMCONTASQ.NEXTVAL,
	:idConta,
	:cidTipoImagem,
	TO_DATE(:dtFimCiclo,'DD/MM/RRRR'),
	:nmImagem,
	:inXml,
	1,
	SYSDATE,
	:nmPathDetalhada,
	:nmPathResumida,
	:nmPathBoleto,
	:iprocessado
	);

	tuxfw_getlogger()->debug("OK");
	return 1;

Error:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);
}
	
bool ImagemConta::salvarDados(struct stImagemConta &stDados)
{
	tuxfw_getlogger()->debug("salvando dados de imagem para cache");
	m_stDados = &stDados;
	// detelar imagem antiga caso exista
	deleteImagemConta();
	// inserir imagem
	if(insertImagemConta() == 1)
		return true;
	else
	return false;
}

bool ImagemConta::removerRegistro(struct stImagemConta &stDados)
{
	tuxfw_getlogger()->debug("ImagemConta::removerRegistro");
	m_stDados = &stDados;
	// detelar imagem antiga caso exista
	return this->deleteImagemConta();
}

int ImagemConta::selectIdContaSistemaOrigem()
{
	tuxfw_getlogger()->debug("ImagemConta::selectIdContaSistemaOrigem");
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		char*idContaSistemaOrigem = m_stDados->idContaSistemaOrigem;
		VARCHAR idConta[21+1];
	EXEC SQL END DECLARE SECTION;

	memset(&idConta,0,sizeof(idConta));

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
	SELECT 
		IDCONTA 
	INTO 
		:idConta
	FROM 
		CUSTOMER.CONTA 
	WHERE 
		IDCONTASISTEMAORIGEM = :idContaSistemaOrigem;

	if(sqlca.sqlcode == 1403)
	{
		tuxfw_getlogger()->debug("Registro não encontrado");
		return -1;
	}
	else
	{
		tuxfw_getlogger()->debug("OK");
		strcpy(this->m_stDados->idConta,(char*)idConta.arr);
	}

	return 1;

Error:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int ImagemConta::deleteImagemConta()
{
	tuxfw_getlogger()->debug("ImagemConta::deleteImagemConta");
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		char*dtFimCiclo = m_stDados->dtFimCiclo;
		char*idConta = m_stDados->idConta;
		char*sgTipoImagem = m_stDados->sgTipoImagem;
		int inXml = m_stDados->inXml;
		VARCHAR idTipoImagem[21+1];
	EXEC SQL END DECLARE SECTION;


	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	memset(&idTipoImagem,0,sizeof(idTipoImagem));


	EXEC SQL
	SELECT NVL(IDTIPOIMAGEM,'0')
	INTO :idTipoImagem
	FROM APOIO.TIPOIMAGEM WHERE SGTIPOIMAGEM = :sgTipoImagem;

	if(sqlca.sqlcode != 1403)
	{
		strcpy(m_stDados->idTipoImagem,(char*)idTipoImagem.arr);
	}
	tuxfw_getlogger()->debug("dtFimCiclo = %s",dtFimCiclo);
	tuxfw_getlogger()->debug("idConta = %s",idConta);
	tuxfw_getlogger()->debug("sgTipoImagem = %s",sgTipoImagem);
	tuxfw_getlogger()->debug("idTipoImagem = %s",m_stDados->idTipoImagem);
	tuxfw_getlogger()->debug("inXml = %d",m_stDados->inXml);

	EXEC SQL
	DELETE
		VOL.IMAGEMCONTA
	WHERE
	IDTIPOIMAGEM = :idTipoImagem AND
		IDCONTA = :idConta AND
		INXML = : inXml AND
		DTFIMCICLO = TO_DATE(:dtFimCiclo,'DD/MM/RRRR');

	return true;
Error:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int ImagemConta::insertImagemConta()
{
	tuxfw_getlogger()->debug("ImagemConta::insertImagemConta");
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		char*dtFimCiclo = m_stDados->dtFimCiclo;
		char*idConta = m_stDados->idConta;
		char*sgTipoImagem = m_stDados->sgTipoImagem;
		char*nmImagem = m_stDados->nmImagem;
		char*cidTipoImagem = m_stDados->idTipoImagem;
		int inXml = m_stDados->inXml;
	EXEC SQL END DECLARE SECTION;

	sqlca.sqlcode=0;

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;


	EXEC SQL
	INSERT INTO 
		VOL.IMAGEMCONTA 
		(IDIMAGEMCONTA,IDCONTA,IDTIPOIMAGEM,DTFIMCICLO,NMIMAGEM,INXML,IDUSUARIOALTERACAO,DTULTIMAALTERACAO)
	VALUES (
	VOL.IMAGEMCONTASQ.NEXTVAL,
	:idConta,
	:cidTipoImagem,
	TO_DATE(:dtFimCiclo,'DD/MM/RRRR'),
	:nmImagem,
	:inXml,
	1,
	SYSDATE
	);

	tuxfw_getlogger()->debug("OK");
	return 1;

Error:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);
}

bool ImagemConta::getParametroCache()
{
	tuxfw_getlogger()->debug("ImagemConta::getParametroCache");
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		struct stParametro{
			VARCHAR dsValorParametro[255+1];
		}m_stParametro;
		struct stParametroInd{
			short dsValorParametro;
		}m_stParametroInd;
	EXEC SQL END DECLARE SECTION;

	memset(&m_stParametro,0,sizeof(m_stParametro));
	memset(&m_stParametroInd,0,sizeof(m_stParametroInd));
	
	sqlca.sqlcode=0;

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
		SELECT DSVALORPARAMETRO 
		INTO :m_stParametro:m_stParametroInd
		FROM APOIO.PARAMETRO 
		WHERE
		CDPARAMETRO = 'IMG_CONTA_CACHE';

	if(sqlca.sqlcode == 1403)
	{
		tuxfw_getlogger()->debug("Registro não encontrado");
		return false;
	}
	else
	{
		tuxfw_getlogger()->debug("OK PARAMETRO %s",(char*)m_stParametro.dsValorParametro.arr);
		if(strcmp((char*)m_stParametro.dsValorParametro.arr,"ATIVO") == 0)
			return true;
	}
	return false;
Error:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int ImagemConta::getAreaRegistro(char*cdAreaRegistro,char*sgUf)
{
	tuxfw_getlogger()->debug("ImagemConta::getAreaRegistro");
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		struct stParametro{
			VARCHAR sgUf[255+1];
		}m_stParametro;
		struct stParametroInd{
			short sgUf;
		}m_stParametroInd;
		char*areaRegistro = cdAreaRegistro;
	EXEC SQL END DECLARE SECTION;

	memset(&m_stParametro,0,sizeof(m_stParametro));
	memset(&m_stParametroInd,0,sizeof(m_stParametroInd));
	
	sqlca.sqlcode=0;

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
	  SELECT UF.SGUF 
	  INTO m_stParametro:m_stParametroInd
	  FROM CUSTOMER.UFOPERADORA UFO,APOIO.UF UF, APOIO.AREAREGISTRO AR 
	  WHERE 
	  UFO.IDUFOPERADORA = AR.IDUFOPERADORA AND 
	  UFO.IDUF  = UF.IDUF AND
	  AR.CDAREAREGISTRO = :areaRegistro;

	if(sqlca.sqlcode == 1403)
	{
		tuxfw_getlogger()->debug("Area Registro não encontrado");
		return 0;
	}
	else
	{
		strcpy(sgUf,(char*)m_stParametro.sgUf.arr);
		return 1;
	}
	return 0;
Error:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int ImagemConta::consultarTipoPessoa(int nrLinha, int cdAreaRegistro, int intTipoRelacionamento)
{
	tuxfw_getlogger()->debug("ImagemConta::consultarTipoPessoa");
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int iTipoRelacionamento;
	int iCdAreaRegistro;
	int iNrLinha;
	int idTipoPessoa;
	EXEC SQL END DECLARE SECTION;

	idTipoPessoa = -1;
	iCdAreaRegistro = cdAreaRegistro;
	iNrLinha = nrLinha;
	iTipoRelacionamento = intTipoRelacionamento;


	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	EXEC SQL 
	SELECT
		Pessoa.IDTIPOPESSOA
	INTO 
		:idTipoPessoa
	FROM
		linha.LinhaTelefonica	 	LinhaTelefonica,
		linha.LinhaBase			LinhaBase,
		apoio.EstadoLinha       	EstadoLinha,
		customer.pessoalinha		PessoaLinha,
		customer.pessoadepara		PessoaDePara,
		customer.pessoa			Pessoa,
		apoio.tipopessoa		TipoPessoa,
		apoio.AreaRegistro		AreaRegistro
	WHERE
		LinhaBase.nrLinha = :iNrLinha 
		AND LinhaBase.idAreaRegistro = AreaRegistro.idAreaRegistro
		AND AreaRegistro.cdAreaRegistro = :iCdAreaRegistro
		AND  LinhaBase.idEstadoLinha = EstadoLinha.idEstadoLinha
		AND LinhaBase.IDLINHABASE = LinhaTelefonica.IDLINHABASE
		AND LinhaTelefonica.IDLINHATELEFONICA = PessoaLinha.IDLINHATELEFONICA
		AND PessoaDePara.IDPESSOADEPARA =PessoaLinha.IDPESSOADEPARA
		AND PessoaDePara.IDPESSOA = Pessoa.IDPESSOA
		AND Pessoa.IDTIPOPESSOA = TipoPessoa.idtipopessoa
		AND PessoaLinha.IDTIPORELACIONAMENTO = :iTipoRelacionamento;

	return idTipoPessoa;

OraException:	
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);	
	return 0;
} 

int ImagemConta::getMinutoParametro()
{
	tuxfw_getlogger()->debug("ImagemConta::getMinutoParametro");
	struct sqlca sqlca;
	int minutos = 0;

	EXEC SQL BEGIN DECLARE SECTION;
		struct stParametro{
			VARCHAR dsValorParametro[255+1];
		}m_stParametro;
		struct stParametroInd{
			short dsValorParametro;
		}m_stParametroInd;
	EXEC SQL END DECLARE SECTION;

	memset(&m_stParametro,0,sizeof(m_stParametro));
	memset(&m_stParametroInd,0,sizeof(m_stParametroInd));
	
	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
		SELECT DSVALORPARAMETRO 
		INTO :m_stParametro:m_stParametroInd
		FROM APOIO.PARAMETRO 
		WHERE
		CDPARAMETRO = 'TEMPO_XENOS_REPROCESSAMENTO';

	if(sqlca.sqlcode == 1403)
	{
		tuxfw_getlogger()->debug("Registro não encontrado");
		return 0;
	}
	else
	{
		tuxfw_getlogger()->debug("OK PARAMETRO %s",(char*)m_stParametro.dsValorParametro.arr);
		try{
			minutos = atoi((char*)m_stParametro.dsValorParametro.arr);
			return minutos;
		}catch(...){
			tuxfw_getlogger()->debug("Erro na conversão de minutos");
		}
	}
	return 0;
Error:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);
}