/**
 * @modulo  Cliente
 * @usecase Ura
 * @author  Luiz Carlos Fonseca
 * @author  Bruno Pereira Soares
 * @version $Revision: 1.1 $
 * @CVS     $Author: a5110702 $ - $Date: 2009/07/31 15:34:09 $
 **/

/**
 * Serviço de troca de senha, ativado via URA
 **/

#undef SQLCA
#define SQLCA_NONE

#include<stdio.h>
#include<sqlca.h>
#include<sqlda.h>
#include<iostream.h>

#include "TrocaSenha.hpp"
#include "../../../negocio/commons/include/Commom.hpp"
#include "../../../negocio/commons/include/stLinha.hpp"

EXEC SQL BEGIN DECLARE SECTION;
#include "../../../negocio/commons/include/stLinha.hpp"
EXEC SQL END DECLARE SECTION;


/**
 * Verifica se a senha anterior passa é igual a senha atual da base
 * Retorna:
 *	 1 - Senhas iguais
 *	-2 - Registro não encontrado
 *	-3 - Erro ao executar a query
 *	 0 - Senhas diferentes
 */
int validarSenha(double idPessoa,double idPessoaLinha,char *senhaAtual,char cTitularidade)
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cdsenha[256];
		int p_idPessoa = idPessoa;
		double p_idPessoaLinha = idPessoaLinha;
	EXEC SQL END DECLARE SECTION;
	EXEC SQL WHENEVER SQLERROR GOTO gotoErro;
	if(cTitularidade == 'C')
	{
		EXEC SQL 
		SELECT CDSENHA 
		INTO :cdsenha
		FROM CUSTOMER.SENHA
		WHERE idpessoa = :p_idPessoa;
	}
	else
	if(cTitularidade == 'U')
	{
		EXEC SQL 
		SELECT CDSENHA 
		INTO :cdsenha
		FROM CUSTOMER.SENHA
		WHERE idpessoalinha = :p_idPessoaLinha;		
	}
	if(sqlca.sqlcode == 0)
	{
		char *senha = (char*)cdsenha.arr;
		if(strcmp(senha,senhaAtual) == 0)
		{
			return 1;
		}		
	}
	else
	if(sqlca.sqlcode == 1403)
	{
		return -2;
	}
	gotoErro:
	{
		return -3;
	}
	return 0;
}


void buscaIdPessoa(stStatuslinha *stLinha, char cTitularidade)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		struct stStatuslinha o_stLinha;
		char cOraTitularidade;
	EXEC SQL END DECLARE SECTION;

	cOraTitularidade = cTitularidade;

	EXEC SQL WHENEVER SQLERROR DO sql_error(&o_stLinha, ERR_DATABASE);
	EXEC SQL WHENEVER NOT FOUND DO sql_error(&o_stLinha, ERR_NOT_FOUND_OR_DISABLED);

	memset( &o_stLinha, 0, sizeof( o_stLinha ) );
	memcpy(&o_stLinha,&(*stLinha),sizeof(o_stLinha));

	/* Utilizamos o campo dblIdcliente independente de ser cliente ou usuário. 
	 * As rotinas de senha já fazem essas validações.
         */
	EXEC SQL 
	SELECT
		PessoaDePara.idPessoa, PessoaLinha.IDPESSOALINHA	
	 INTO 
		:o_stLinha.dblIdcliente,:o_stLinha.dblIdpessoalinha
	FROM
		apoio.arearegistro AreaRegistro,
		linha.linhaBase LinhaBase,
		linha.linhaTelefonica LinhaTelefonica,		
		customer.pessoalinha PessoaLinha,
		customer.pessoadepara PessoaDePara,
		customer.TipoRelacionamento TipoRelacionamento
	WHERE
		 LinhaBase.NRLINHA =  TO_NUMBER(:o_stLinha.ntLinha) AND
		 LinhaBase.IDAREAREGISTRO = AreaRegistro.IDAREAREGISTRO AND
		 AreaRegistro.CDAREAREGISTRO =   TO_NUMBER(:o_stLinha.ntArea) AND
		 LinhaBase.idlinhabase = LinhaTelefonica.IDLINHABASE AND
		 LinhaTelefonica.IDLINHATELEFONICA = PessoaLinha.IDLINHATELEFONICA AND
		 PessoaLinha.IDPESSOADEPARA = PessoaDePara.IDPESSOADEPARA AND
		 PessoaLinha.idtiporelacionamento = TipoRelacionamento.idTipoRelacionamento AND
		 UPPER(TipoRelacionamento.sgTipoRelacionamento) =   UPPER(:cOraTitularidade);

	memcpy(&(*stLinha),&o_stLinha,sizeof(*stLinha));
}

void sql_error(struct stStatuslinha *stLinha, int Status)
{
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        stLinha->ntStatus = Status;
}
