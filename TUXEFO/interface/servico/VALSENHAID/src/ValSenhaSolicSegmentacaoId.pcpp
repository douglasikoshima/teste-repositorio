/**
 * @modulo  Cliente
 * @usecase Ura
 * @author  Luiz Carlos Fonseca
 * @author  Bruno Pereira Soares
 * @version $Revision: 1.1.2.25.8.7.8.4.2.1.20.1 $
 * @CVS     $Author: a5110705 $ - $Date: 2016/04/08 20:26:40 $
 **/

/**
 * Serviço de validação de senha e solicitação de segmetação de cliente, ativado via URA
 **/

#include<stdio.h>
#include<sqlca.h>
#include<sqlda.h>
#include<string.h>
#include<iostream.h>
#include "ValSenhaSolicSegmentacaoId.hpp"
#include "../../../negocio/commons/include/Commom.hpp"
#include "../../../negocio/commons/include/stLinha.hpp"

#define CONVIND(O,I) \
{ \
	if (I == -1) { \
		##O.arr[0]=0; \
	} else { \
		##O.arr[##O.len]=0; \
	} \
}

extern struct sqlca sqlca;

bool validaSenha(char* telefone, char* senha, int* resultado, char* titularidade, int idCanal, int idPessoaUsuario);
bool IsControlN( char * idLinhaTelefonicaPrm );
bool IsVivoNext( char * idLinhaTelefonicaPrm );
bool IsVoip( char * idLinhaTelefonicaPrm );
bool IsCombo4P( char * idLinhaTelefonicaPrm );
void CodigoTecnologia( char * idLinhaTelefonicaPrm, char * idTipoTecnologiaPrm );
void CodigoSistOrigem( char * idLinhaTelefonicaPrm, char * idSistOrigemPrm );



EXEC SQL BEGIN DECLARE SECTION;
#include "../../../negocio/commons/include/stLinha.hpp"
EXEC SQL END DECLARE SECTION;

void RecuperarDados( struct stStatuslinha *stLinha, struct stVlStatuslinha *stVlLinha )
{
	EXEC SQL BEGIN DECLARE SECTION;
		struct stStatuslinha o_stLinha;
		struct stVlStatuslinha o_vlLinha;
		int iInCorp = 0;
		int iAtendimentoFO = 0;
		struct stNome{
			VARCHAR chrNomeUsuario[255+1];
			VARCHAR chrNomeCliente[255+1];
		}m_stNome;
		struct istNome{
			short chrNomeUsuario;
			short chrNomeCliente;
		}i_stNome;
	EXEC SQL END DECLARE SECTION;

	tuxfw_getlogger()->information("linha %s",stLinha->chrTelefone);

	EXEC SQL WHENEVER SQLERROR DO sql_error(&o_stLinha, ERR_DATABASE);

	memset( &o_stLinha, 0, sizeof( o_stLinha ) );
	memcpy(&o_stLinha,&(*stLinha),sizeof(o_stLinha));

	memset( &o_vlLinha, 0, sizeof( o_vlLinha ) );
	memcpy(&o_vlLinha,&(*stVlLinha),sizeof(o_vlLinha));

	memset(&m_stNome,0,sizeof(m_stNome));
	memset(&i_stNome,0,sizeof(i_stNome));

	EXEC SQL SELECT 
		LT.IDLINHATELEFONICA,
		EL.SGCLASSIFICACAO,
		decode(TL.SGTIPOLINHA, 'PRÉ', '00', 'POS', '01','CONT','03','CONTCHIP','07','PRÉCHIP','04','POSCHIP','05',TL.SGTIPOLINHA),
		UPPER(TRIM(LB.DSMOTIVOESTADO)),
		NVL(IDCLUSTERLINHA,0) as IDCLUSTERLINHA,
		LT.IDTIPOLINHA
	INTO	
		:o_stLinha.dblIdlinhatelefonica:o_vlLinha.i_dblIdlinhatelefonica,
		:o_stLinha.chrEstadolinha:o_vlLinha.i_chrEstadolinha,
		:o_stLinha.chrTipolinha:o_vlLinha.i_chrTipolinha,
		:o_stLinha.dsMotivoEstado:o_vlLinha.i_dsMotivoEstado,
		:o_stLinha.idClusterLinha:o_vlLinha.i_idClusterLinha,
		:o_stLinha.idTipoLinha:o_vlLinha.i_idTipoLinha
	FROM
		LINHA.LINHABASE LB,
		LINHA.LINHATELEFONICA LT,
		APOIO.AREAREGISTRO AR,
		APOIO.ESTADOLINHA EL,
		APOIO.TIPOLINHA TL
	WHERE
		LB.IDAREAREGISTRO = AR.IDAREAREGISTRO AND
		LB.IDLINHABASE = LT.IDLINHABASE AND
		LB.IDESTADOLINHA = EL.IDESTADOLINHA AND
		TL.IDTIPOLINHA = LT.IDTIPOLINHA AND
		LB.NRLINHA = TO_NUMBER(:o_stLinha.ntLinha) AND
		AR.CDAREAREGISTRO = TO_NUMBER(:o_stLinha.ntArea);

	if (o_vlLinha.i_dblIdlinhatelefonica == -1) {
		tuxfw_getlogger()->information("Linha não encontrada.");
		o_stLinha.ntStatus = ERR_NOT_FOUND_OR_DISABLED;
		memcpy(&(*stLinha),&o_stLinha,sizeof(*stLinha));
		memcpy(&(*stVlLinha),&o_vlLinha,sizeof(*stVlLinha));
		return;
	}
	/*Faz o decode do estado da linha*/
	DecodeEstadoLinha(&o_stLinha);

	// procurar o plano da linha
	GetPlano(&o_stLinha);

			
	// recupera idpessoa do cliente
	// tipo de carteira do cliente
	EXEC SQL SELECT 
		TRIM(PESSOA.NMPESSOA),
		PESSOALINHA.IDPESSOALINHA,
		PESSOA.IDPESSOA,
		TIPOPESSOA.SGTIPOPESSOA,
		decode(TIPOCARTEIRA.idtipocarteira, 0, -1, 13, -1, TIPOCARTEIRA.idtipocarteira) AS IDTIPOCARTEIRA,
		NVL(TIPOCARTEIRA.INCORPORATIVO,0) AS INCORPORATIVO,
		PESSOADEPARA.IDPESSOADEPARA
		INTO	:m_stNome.chrNomeCliente:i_stNome.chrNomeCliente,
			:o_stLinha.dblIdpessoalinha:o_vlLinha.i_dblIdpessoalinha,
			:o_stLinha.dblIdcliente:o_vlLinha.i_dblIdcliente,
			:o_stLinha.chrTipopessoa:o_vlLinha.i_chrTipopessoa,
			:o_stLinha.ntCarteira:o_vlLinha.i_ntCarteira,
			:iInCorp,
			:o_stLinha.idpessoadepara:o_vlLinha.i_idpessoadepara
	FROM
		LINHA.LINHATELEFONICA LINHATELEFONICA,
		LINHA.LINHABASE LINHABASE,
		APOIO.AREAREGISTRO AREAREGISTRO,
		CUSTOMER.PESSOALINHA PESSOALINHA,
		CUSTOMER.PESSOADEPARA PESSOADEPARA,
		CUSTOMER.PESSOA PESSOA,
		CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTO,
		APOIO.TIPOPESSOA TIPOPESSOA,
		APOIO.TIPOCARTEIRA TIPOCARTEIRA
	WHERE
		 LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
		 AND LINHABASE.IDLINHABASE = LINHATELEFONICA.IDLINHABASE
		 AND LINHATELEFONICA.IDLINHATELEFONICA = PESSOALINHA.IDLINHATELEFONICA
		 AND PESSOADEPARA.IDPESSOADEPARA = PESSOALINHA.IDPESSOADEPARA
		 AND PESSOALINHA.IDTIPORELACIONAMENTO = TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
		 AND PESSOA.IDPESSOA = PESSOADEPARA.IDPESSOA
		 AND PESSOA.IDTIPOPESSOA = TIPOPESSOA.IDTIPOPESSOA
		 AND PESSOA.IDTIPOCARTEIRA = TIPOCARTEIRA.IDTIPOCARTEIRA
		 AND TIPORELACIONAMENTO.SGTIPORELACIONAMENTO = 'C'
		 AND LINHABASE.NRLINHA = TO_NUMBER(:o_stLinha.ntLinha)
		 AND AREAREGISTRO.CDAREAREGISTRO = TO_NUMBER(:o_stLinha.ntArea);
		 
	// copiar o iInCorp para a estrutura
	o_stLinha.iInCorp = iInCorp;

	if (o_vlLinha.i_dblIdpessoalinha == -1 || o_stLinha.dblIdpessoalinha == 0 || o_stLinha.dblIdcliente == 0) {
		tuxfw_getlogger()->information("Linha sem cliente cadastrado, tipo linha = %s", o_stLinha.chrTipolinha);
		if (strcmp("00",o_stLinha.chrTipolinha) == 0 || strcmp("04",o_stLinha.chrTipolinha) == 0)
			o_stLinha.ntStatus = RET_OK;
		else {
			tuxfw_getlogger()->information("Linha pós paga sem cliente!");
			o_stLinha.ntStatus = ERR_NOT_FOUND_OR_DISABLED;
		}
                memcpy(&(*stLinha),&o_stLinha,sizeof(*stLinha));
                memcpy(&(*stVlLinha),&o_vlLinha,sizeof(*stVlLinha));
		return;
	}


	// verifica se será atendido pelo FO	
	EXEC SQL 
	SELECT COUNT(1) 
	INTO :iAtendimentoFO 
	FROM customer.pessoaatendimentofo 
	WHERE idpessoa = :o_stLinha.dblIdcliente;

	if(iAtendimentoFO == 1)
	{
		o_stLinha.ntStatus = ERR_NAO_ATENDIDO_FO;
	}
	else
	{
		// Altera o tipo da linha se o indicativo de corporativo for 1.
		if (iInCorp == 1 || strcmp(o_stLinha.chrTipopessoa, "PJ") == 0)
		{
			if(!strcmp("01",o_stLinha.chrTipolinha) || !strcmp("03",o_stLinha.chrTipolinha))
				sprintf(o_stLinha.chrTipolinha, "02");
			else
			if(!strcmp("05",o_stLinha.chrTipolinha) || !strcmp("07",o_stLinha.chrTipolinha))
				sprintf(o_stLinha.chrTipolinha, "06");
		}
		
		tuxfw_getlogger()->information("Dados Cliente");
		tuxfw_getlogger()->information("Tipo Pessoa: %s", o_stLinha.chrTipopessoa);
		// recupera idpessoa do usuario
		EXEC SQL SELECT 
			TRIM(PESSOA.NMPESSOA),
			PESSOA.IDPESSOA,
			PESSOALINHA.IDPESSOALINHA	
		INTO	:m_stNome.chrNomeUsuario:i_stNome.chrNomeUsuario,
			:o_stLinha.dblIdusuario:o_vlLinha.i_dblIdusuario,
			:o_stLinha.dblIdpessoalinhausr:o_vlLinha.i_dblIdpessoalinhausr
		FROM
			LINHA.LINHATELEFONICA LINHATELEFONICA,
			LINHA.LINHABASE LINHABASE,
			APOIO.AREAREGISTRO AREAREGISTRO,
			CUSTOMER.PESSOALINHA PESSOALINHA,
			CUSTOMER.PESSOADEPARA PESSOADEPARA,
			CUSTOMER.PESSOA PESSOA,
			CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTO,
			APOIO.TIPOPESSOA TIPOPESSOA
		WHERE
			 LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
			 AND LINHABASE.IDLINHABASE = LINHATELEFONICA.IDLINHABASE
			 AND LINHATELEFONICA.IDLINHATELEFONICA = PESSOALINHA.IDLINHATELEFONICA
			 AND PESSOADEPARA.IDPESSOADEPARA = PESSOALINHA.IDPESSOADEPARA
			 AND PESSOALINHA.IDTIPORELACIONAMENTO = TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
			 AND PESSOA.IDPESSOA = PESSOADEPARA.IDPESSOA
			 AND PESSOA.IDTIPOPESSOA = TIPOPESSOA.IDTIPOPESSOA
			 AND TIPORELACIONAMENTO.SGTIPORELACIONAMENTO = 'U'
			 AND LINHABASE.NRLINHA = TO_NUMBER(:o_stLinha.ntLinha)
			 AND AREAREGISTRO.CDAREAREGISTRO = TO_NUMBER(:o_stLinha.ntArea);

		tuxfw_getlogger()->information("Dados Usuario");

		VerificaLinha( &o_stLinha, &o_vlLinha );
	}
	
	// copiar o nome
	strcpy(o_stLinha.chrNomeCliente,(char*)m_stNome.chrNomeCliente.arr);
	strcpy(o_stLinha.chrNomeUsuario,(char*)m_stNome.chrNomeUsuario.arr);

	memcpy(&(*stLinha),&o_stLinha,sizeof(*stLinha));
	memcpy(&(*stVlLinha),&o_vlLinha,sizeof(*stVlLinha));
}

void VerificaLinha(  struct stStatuslinha *stLinha , struct stVlStatuslinha *stVlLinha )
{

	EXEC SQL BEGIN DECLARE SECTION;
		struct stStatuslinha o_stLinha;
		struct stVlStatuslinha o_vlLinha;
	EXEC SQL END DECLARE SECTION;	

	memset( &o_stLinha, 0, sizeof( o_stLinha ) );
	memcpy(&o_stLinha,&(*stLinha),sizeof(o_stLinha));

	memset( &o_vlLinha, 0, sizeof( o_vlLinha ) );
	memcpy(&o_vlLinha,&(*stVlLinha),sizeof(o_vlLinha));

	EXEC SQL WHENEVER SQLERROR DO sql_error(&o_stLinha, ERR_DATABASE);

	// segmento do cliente
	EXEC SQL SELECT 
		   SEGMENTACAO.SGSEGMENTACAO
		   INTO :o_stLinha.ntSegmento:o_vlLinha.i_ntSegmento
	FROM
		CUSTOMER.PESSOADEPARA PESSOADEPARA,
		CUSTOMER.PESSOASEGMENTACAO PESSOASEGMENTACAO,
		CUSTOMER.PESSOASEGMENTACAOHISTORICO PESSOASEGMENTACAOHISTORICO,
		APOIO.SEGMENTACAO SEGMENTACAO
	WHERE
		PESSOADEPARA.IDPESSOADEPARA = PESSOASEGMENTACAO.IDPESSOADEPARA
		AND PESSOASEGMENTACAO.IDPESSOASEGMENTACAO = PESSOASEGMENTACAOHISTORICO.IDPESSOASEGMENTACAO
		AND PESSOASEGMENTACAOHISTORICO.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA
		AND SEGMENTACAO.IDSEGMENTACAO = PESSOASEGMENTACAOHISTORICO.IDSEGMENTACAO
		AND PESSOADEPARA.IDPESSOA = TO_NUMBER(:o_stLinha.dblIdcliente);

        if (sqlca.sqlcode == 1403 || o_vlLinha.i_ntSegmento == -1) {
                o_stLinha.ntSegmento = -1;
                tuxfw_getlogger()->debug("Segmento não existe, setado para -1 (não classificado)");
        }
        tuxfw_getlogger()->debug("Segmento: %i", o_stLinha.ntSegmento);

	// indicador de senha reinicializada cliente
	// chamar servico tuxedo do renato teixeira
	// se statuscode 07W0003 = "S" caso contrario = "N"

	// senha cripto cliente
	EXEC SQL SELECT a.cdsenha, a.inTrocaSenha, NVL(a.IDTIPOSTATUSSENHA,'')
				INTO :o_stLinha.chrSenhacliente:o_vlLinha.i_chrSenhacliente,
				     :o_stLinha.chrReinicsenhacliente:o_vlLinha.i_chrReinicsenhacliente,
				     :o_stLinha.idStatusSenhaCliente:o_vlLinha.i_idStatusSenhaCliente
				FROM customer.senha a
					WHERE a.idpessoa = TO_NUMBER(:o_stLinha.dblIdcliente);
	if (o_vlLinha.i_idStatusSenhaCliente > -1 && o_stLinha.idStatusSenhaCliente == 2)
		sprintf(o_stLinha.chrReinicsenhacliente,"B");
	else
	if ((o_vlLinha.i_chrReinicsenhacliente > -1 && o_stLinha.chrReinicsenhacliente[0]=='1') || sqlca.sqlcode == 1403)
		sprintf(o_stLinha.chrReinicsenhacliente,"S");
	else
		sprintf(o_stLinha.chrReinicsenhacliente,"N");

	tuxfw_getlogger()->information("Senha Cliente: %d", o_stLinha.chrSenhacliente);

	// senha cripto usuario
	EXEC SQL SELECT a.cdsenha, a.inTrocaSenha, NVL(a.IDTIPOSTATUSSENHA,'')
				INTO :o_stLinha.chrSenhausuario:o_vlLinha.i_chrSenhausuario,
				     :o_stLinha.chrReinicsenhausuario:o_vlLinha.i_chrReinicsenhausuario,
				     :o_stLinha.idStatusSenhaUsuario:o_vlLinha.i_idStatusSenhaUsuario
				FROM customer.senha a
					WHERE a.idpessoalinha = TO_NUMBER(:o_stLinha.dblIdpessoalinhausr);
	if (o_vlLinha.i_idStatusSenhaUsuario > -1 && o_stLinha.idStatusSenhaUsuario == 2)
		sprintf(o_stLinha.chrReinicsenhausuario,"B");
	else
	if ((o_vlLinha.i_chrReinicsenhausuario > -1 && o_stLinha.chrReinicsenhausuario[0]=='1') || sqlca.sqlcode == 1403)
		sprintf(o_stLinha.chrReinicsenhausuario,"S");
	else
		sprintf(o_stLinha.chrReinicsenhausuario,"N");

	tuxfw_getlogger()->information("Senha Usuario: %s", o_stLinha.chrSenhausuario);

	// rg cliente
	EXEC SQL SELECT 
		   DOCUMENTO.NRDOCUMENTO
	INTO	:o_stLinha.chrRGcliente:o_vlLinha.i_chrRGcliente
	FROM 
		 APOIO.TIPOPESSOA TIPOPESSOA,
		 APOIO.TIPODOCUMENTO TIPODOCUMENTO,
		 CUSTOMER.PESSOADOCUMENTO,
		 CUSTOMER.DOCUMENTO
	WHERE
		TIPODOCUMENTO.SGCLASSIFICACAO = 'RG'
		AND TIPODOCUMENTO.IDTIPOPESSOA = TIPOPESSOA.IDTIPOPESSOA
		AND TIPODOCUMENTO.IDTIPODOCUMENTO = DOCUMENTO.IDTIPODOCUMENTO
		AND PESSOADOCUMENTO.IDPESSOA = TO_NUMBER(:o_stLinha.dblIdcliente)
		AND PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO 
		AND ROWNUM = 1;

	tuxfw_getlogger()->information("Doc Cliente");

	// rg usuario
	EXEC SQL SELECT 
		   DOCUMENTO.NRDOCUMENTO
	INTO	 :o_stLinha.chrRGusuario:o_vlLinha.i_chrRGusuario
	FROM 
		 APOIO.TIPOPESSOA TIPOPESSOA,
		 APOIO.TIPODOCUMENTO TIPODOCUMENTO,
		 CUSTOMER.PESSOADOCUMENTO,
		 CUSTOMER.DOCUMENTO
	WHERE
		TIPODOCUMENTO.SGCLASSIFICACAO = 'RG'
		AND TIPODOCUMENTO.IDTIPOPESSOA = TIPOPESSOA.IDTIPOPESSOA
		AND TIPODOCUMENTO.IDTIPODOCUMENTO = DOCUMENTO.IDTIPODOCUMENTO
		AND PESSOADOCUMENTO.IDPESSOA = TO_NUMBER(:o_stLinha.dblIdusuario)
		AND PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO 
		AND ROWNUM = 1;


	tuxfw_getlogger()->information("Doc Usuario");

	// cep cliente
	EXEC SQL SELECT PESSOAENDERECO.NRCEP 
	INTO :o_stLinha.chrCEPcliente:o_vlLinha.i_chrCEPcliente
	FROM CUSTOMER.PESSOAENDERECO PESSOAENDERECO
	WHERE PESSOAENDERECO.IDPESSOA = TO_NUMBER(:o_stLinha.dblIdcliente)
	AND ROWNUM = 1;
	 

	tuxfw_getlogger()->information("Cep Cliente");

	// cep usuario
	EXEC SQL SELECT PESSOAENDERECO.NRCEP 
	INTO :o_stLinha.chrCEPusuario:o_vlLinha.i_chrCEPusuario
	FROM CUSTOMER.PESSOAENDERECO PESSOAENDERECO
	WHERE PESSOAENDERECO.IDPESSOA = TO_NUMBER(:o_stLinha.dblIdusuario)
	AND ROWNUM = 1;

	tuxfw_getlogger()->information("Cep Usuario");

	// nascimento cliente
	EXEC SQL SELECT TO_CHAR(PESSOAFISICA.DTNASCIMENTO,'DDMMYY') 
	INTO :o_stLinha.chrNascimentocliente:o_vlLinha.i_chrNascimentocliente
	FROM CUSTOMER.PESSOAFISICA PESSOAFISICA
	WHERE PESSOAFISICA.IDPESSOA = TO_NUMBER(:o_stLinha.dblIdcliente);

	tuxfw_getlogger()->information("Nac Cliente");

	// nascimento usuario
	EXEC SQL SELECT TO_CHAR(PESSOAFISICA.DTNASCIMENTO,'DDMMYY') 
	INTO :o_stLinha.chrNascimentousuario:o_vlLinha.i_chrNascimentousuario
	FROM CUSTOMER.PESSOAFISICA PESSOAFISICA
	WHERE PESSOAFISICA.IDPESSOA = TO_NUMBER(:o_stLinha.dblIdusuario);

	tuxfw_getlogger()->information("Nac Usuario");

	// cpf cliente
	EXEC SQL SELECT 
		   DOCUMENTO.NRDOCUMENTO
	INTO	:o_stLinha.chrCPFcliente:o_vlLinha.i_chrCPFcliente
	FROM 
		 APOIO.TIPOPESSOA TIPOPESSOA,
		 APOIO.TIPODOCUMENTO TIPODOCUMENTO,
		 CUSTOMER.PESSOADOCUMENTO,
		 CUSTOMER.DOCUMENTO
	WHERE
		TIPODOCUMENTO.SGCLASSIFICACAO = 'CPF'
		AND TIPODOCUMENTO.IDTIPOPESSOA = TIPOPESSOA.IDTIPOPESSOA
		AND TIPODOCUMENTO.IDTIPODOCUMENTO = DOCUMENTO.IDTIPODOCUMENTO
		AND PESSOADOCUMENTO.IDPESSOA = TO_NUMBER(:o_stLinha.dblIdcliente)
		AND PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO 
		AND ROWNUM = 1;

	tuxfw_getlogger()->information("Doc CPF Cliente");

	// cpf usuario
	EXEC SQL SELECT 
		   DOCUMENTO.NRDOCUMENTO
	INTO	:o_stLinha.chrCPFusuario:o_vlLinha.i_chrCPFusuario
	FROM 
		 APOIO.TIPOPESSOA TIPOPESSOA,
		 APOIO.TIPODOCUMENTO TIPODOCUMENTO,
		 CUSTOMER.PESSOADOCUMENTO,
		 CUSTOMER.DOCUMENTO
	WHERE
		TIPODOCUMENTO.SGCLASSIFICACAO = 'CPF'
		AND TIPODOCUMENTO.IDTIPOPESSOA = TIPOPESSOA.IDTIPOPESSOA
		AND TIPODOCUMENTO.IDTIPODOCUMENTO = DOCUMENTO.IDTIPODOCUMENTO
		AND PESSOADOCUMENTO.IDPESSOA = TO_NUMBER(:o_stLinha.dblIdusuario)
		AND PESSOADOCUMENTO.IDDOCUMENTO = DOCUMENTO.IDDOCUMENTO 
		AND ROWNUM = 1;

	tuxfw_getlogger()->information("Doc CPF Usuario");

	// senha lojista
	// na tabela apoio.tiposenha haverá um ID representando senha lojista
	// ligado em customer.senha
	strcpy( o_stLinha.chrSenhalojista, "" );
	
	tuxfw_getlogger()->information("Senha Lojista");

	// prioridade do lojista
	// default = 04 (nenhuma)
	strcpy( o_stLinha.chrPrioridadelojista, "04" );

	tuxfw_getlogger()->information("Prioridade Lojista");

	// marcação de atendimento pessoal
	strcpy( o_stLinha.chrAtendimentoPessoal, "N" );

	tuxfw_getlogger()->information("Atendimento Pessoal");

	memcpy(&(*stLinha),&o_stLinha,sizeof(*stLinha));
	memcpy(&(*stVlLinha),&o_vlLinha,sizeof(*stVlLinha));

	
	/*
	tuxfw_getlogger()->information("Verifica se a Senha está bloqueada");
	if(GetSenhaBloqueada(&o_stLinha))
	{
		tuxfw_getlogger()->information("SENHA BLOQUEADA");
		stLinha->ntStatus = ERR_SENHA_BLOQUEADA;	
	}*/

	tuxfw_getlogger()->information("Fin Proceso");
}

void sql_error(struct stStatuslinha *stLinha, int Status)
{
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        stLinha->ntStatus = Status;
	tuxfw_getlogger()->information("Error: %d", Status);

	tuxfw_getlogger()->information("OraError: sqlca.sqlcode=[%d], sqlca.sqlerrm.sqlerrmc=[%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc);

}
void sql_error(struct stStatuslinha *stLinha, int Status, int sqlCode)
{
        EXEC SQL WHENEVER SQLERROR CONTINUE;
        stLinha->ntStatus = Status;
	tuxfw_getlogger()->information("Error: status=[%d], sqlcode=[%d]", Status,sqlCode);
}
/**
 * Decodifica o Estado da linha conforme tabela passada pela VIVO
	- Atlys

	H = Hotline (bloqueios)
	D = Disable (suspenso ou desabilitado)
	E = Ativo
	S = NPD (bloqueio total)

	- NGIN

	PACT 		PRE_ATIVADO
	ACT 		ATIVADO
	BAR		BARRADO 
	DES 		DESACTIVADO
	EXP 		EXPIRADO
 */
void DecodeEstadoLinha(struct stStatuslinha *stLinha)
{	
	tuxfw_getlogger()->information("DecodeEstadoLinha - vamos fazer o decode do estado  de linha");
	char estadoLinha[255+1];
	char *pEstadoLinha = NULL;
	memset(&estadoLinha,0,sizeof(estadoLinha));
	strcpy(estadoLinha,stLinha->chrEstadolinha);
	pEstadoLinha = strtok(estadoLinha," ");
	memset(stLinha->chrEstadolinha,0,sizeof(stLinha->chrEstadolinha));
	tuxfw_getlogger()->information("Estado da linha: %s", pEstadoLinha);

	// existe uma nova regra, na qual qualquer pos pago que conter bloqueio de pre ativacao,
	// o estado da linha será 06
	if (strcmp(stLinha->chrTipolinha,"01") == 0 || strcmp(stLinha->chrTipolinha,"05") == 0)
	{
		tuxfw_getlogger()->information("linha é pós paga");
		if(GetBloqueioPreAtivacao(stLinha ))
		{
			tuxfw_getlogger()->information("Linha está com bloqueio de pre ativacao, vamos retornar o estado 06");
			strncpy(stLinha->chrEstadolinha,"06",2);
			stLinha->chrEstadolinha[2]=0;
			return;
		}
	}

	if(strcmp(pEstadoLinha,"H") == 0 )
	{		
		if(strstr(stLinha->dsMotivoEstado,"CPEND") != NULL)
			strncpy(stLinha->chrEstadolinha,"02",2);
		else
			strncpy(stLinha->chrEstadolinha,"02",2);// alterado para 02 a pedido do Edoil
	}
	else
	if(strcmp(pEstadoLinha,"D") == 0)
	{		
		strncpy(stLinha->chrEstadolinha,"01",2);
	}
	else
	if(strcmp(pEstadoLinha,"A") == 0)
	{
		strncpy(stLinha->chrEstadolinha,"00",2);
	}
	else
	if(strcmp(pEstadoLinha,"S") == 0)
	{
		strncpy(stLinha->chrEstadolinha,"03",2);
	}
	else
	if(strcmp(pEstadoLinha,"P") == 0)
	{
		strncpy(stLinha->chrEstadolinha,"04",2);
	}
	else
	if(strcmp(pEstadoLinha,"B") == 0)
	{
		strncpy(stLinha->chrEstadolinha,"05",2);
	}
	else
	if(strcmp(pEstadoLinha,"O") == 0)
	{
		strncpy(stLinha->chrEstadolinha,"17",2);
	}
	else
	if(strcmp(pEstadoLinha,"R") == 0)
	{
		strncpy(stLinha->chrEstadolinha,"16",2);
	}
	else
	if(strcmp(pEstadoLinha,"I") == 0)
	{
		strncpy(stLinha->chrEstadolinha,"15",2);
	}

	stLinha->chrEstadolinha[2]=0;
}

/**
 * Verifica se a senha do Usuário ou Cliente está Bloqueada.
 */
bool GetSenhaBloqueada(struct stStatuslinha *stLinha)
{
	// Verificar o status da senha do usuário/cliente
	sqlca.sqlcode = 0;
	EXEC SQL BEGIN DECLARE SECTION;
		double idPessoaLinha = stLinha->dblIdpessoalinha;
		double idPessoa = stLinha->dblIdcliente;
		struct stSenha{
			int idTipoStatusSenha;
		}msenha;
		struct stSenhaInd{
			short idTipoStatusSenha;
		}msenhaind;
	EXEC SQL END DECLARE SECTION;
	EXEC SQL WHENEVER SQLERROR DO sql_error(stLinha, ERR_DATABASE);
	EXEC SQL WHENEVER NOT FOUND do break;	
	EXEC SQL DECLARE CursorSenha CURSOR FOR
		SELECT IDTIPOSTATUSSENHA
		FROM CUSTOMER.SENHA SENHA
		WHERE SENHA.IDPESSOALINHA = :idPessoaLinha	
		OR SENHA.IDPESSOA = :idPessoa;
	EXEC SQL OPEN CursorSenha;
	for(;;)
	{
		memset(&msenha,0,sizeof(msenha));
		EXEC SQL FETCH CursorSenha INTO :msenha:msenhaind;		
		if(msenha.idTipoStatusSenha == 2){
			return true;
		}
	}
	EXEC SQL CLOSE CursorSenha;
	return false;
}

void GetPlano(struct stStatuslinha *stLinha)
{
	tuxfw_getlogger()->information("GetPlano");
	sqlca.sqlcode = 0;
	EXEC SQL BEGIN DECLARE SECTION;
		struct param{
			VARCHAR sgPlano[256];
			VARCHAR dsPlano[256];
			VARCHAR dsPlanoControle[256];
		}m_param;
		struct iparam{
			short sgPlano;
			short dsPlano;
			short dsPlanoControle;
		}m_iparam;
		double dblIdlinhatelefonica = stLinha->dblIdlinhatelefonica;
	EXEC SQL END DECLARE SECTION;
	EXEC SQL WHENEVER SQLERROR DO sql_error(stLinha, ERR_DATABASE);
	EXEC SQL WHENEVER NOT FOUND CONTINUE;	

	memset( &m_param, 0, sizeof( m_param ) );
	memset( &m_iparam, 0, sizeof( m_iparam ) );

	EXEC SQL
	SELECT 
	 NVL(TRIM(LINHA.PLANOSERVICO.SGSERVICO),' ') ,
	 LINHA.PLANOSERVICO.NMSERVICO ,
	 NVL(TRIM(PLANOCONTROLE.DSPLANOLEGADO),' ')
	 INTO
		:m_param.sgPlano:m_iparam.sgPlano,
		:m_param.dsPlano:m_iparam.dsPlano,
		:m_param.dsPlanoControle:m_iparam.dsPlanoControle
	FROM 
	LINHA.PLANOSERVICOLINHA PLANOSERVICOLINHA,
	LINHA.PLANOSERVICO PLANOSERVICO,
	LINHA.PLANOCONTROLE PLANOCONTROLE
	WHERE
	PLANOSERVICOLINHA.IDLINHATELEFONICA =  :dblIdlinhatelefonica AND	
	PLANOSERVICO.IDSERVICO = PLANOSERVICOLINHA.IDSERVICO AND
	PLANOSERVICO.IDSERVICO = PLANOCONTROLE.IDSERVICO(+) AND
	PLANOSERVICOLINHA.INPLANO=1 AND
	PLANOSERVICOLINHA.DTEXPIRACAO IS NULL AND 
	( PLANOSERVICOLINHA.DTVIGENCIAFINAL >= SYSDATE OR PLANOSERVICOLINHA.DTVIGENCIAFINAL IS NULL )
	AND ROWNUM < 2;

	tuxfw_getlogger()->information("sqlca.sqlcode = %d",sqlca.sqlcode);
	tuxfw_getlogger()->information("m_param.dsPlanoControle = %s",(char*)m_param.dsPlanoControle.arr);
	tuxfw_getlogger()->information("m_param.dsPlano = %s",(char*)m_param.dsPlano.arr);

	if(sqlca.sqlcode != 1403)
	{
		strcpy(stLinha->dsPlano,(char*)m_param.dsPlano.arr);
		strcpy(stLinha->sgPlano,(char*)m_param.sgPlano.arr);

		if( strcmp((char*)m_param.dsPlanoControle.arr,stLinha->sgPlano) == 0 &&  strlen((char*)m_param.dsPlanoControle.arr) > 0)
			strcpy(stLinha->dsPlanoControle,"S");
	}


}



void GetLinhaRestrita( struct stStatuslinha *stLinha )
{
	EXEC SQL BEGIN DECLARE SECTION;
		struct stStatuslinha o_stLinha;
		int iNrRestrito = 0;
		
	EXEC SQL END DECLARE SECTION;

	tuxfw_getlogger()->information("linha %s",stLinha->chrTelefone);

	EXEC SQL WHENEVER SQLERROR DO sql_error(&o_stLinha, ERR_DATABASE);

	memset( &o_stLinha, 0, sizeof( o_stLinha ) );
	memcpy(&o_stLinha,&(*stLinha),sizeof(o_stLinha));

	

	EXEC SQL SELECT 
		COUNT(0)
	INTO	
		:iNrRestrito
	FROM
		LINHA.LINHABASE LB,		
		APOIO.AREAREGISTRO AR,
		VOL.LISTARESTRITA LR
	WHERE
		LB.IDAREAREGISTRO = AR.IDAREAREGISTRO AND		
		LB.NRLINHA = TO_NUMBER(:o_stLinha.ntLinha) AND
		AR.CDAREAREGISTRO = TO_NUMBER(:o_stLinha.ntArea) AND
		LB.IDLINHABASE = LR.IDLINHABASE;


	if (iNrRestrito)
		stLinha->iLinhaRestrita =  1;
	else
		stLinha->iLinhaRestrita =  0;


}

int getPlanoZap(struct stStatuslinha *stLinha)
{
	tuxfw_getlogger()->information("getPlanoZap");
	EXEC SQL BEGIN DECLARE SECTION;	 
		int countZap = 0;	
		double dblIdlinhatelefonica = stLinha->dblIdlinhatelefonica;
	EXEC SQL END DECLARE SECTION;
	
	EXEC SQL WHENEVER SQLERROR DO sql_error(stLinha, ERR_DATABASE);
	
	EXEC SQL SELECT
	  COUNT(1)
	INTO	:countZap
	FROM
		LINHA.LINHATELEFONICA LINHATELEFONICA,
		LINHA.PLANOSERVICOLINHA PLANOSERVICOLINHA,
		LINHA.PLANOSERVICO PLANOSERVICO
	WHERE
		LINHATELEFONICA.IDLINHATELEFONICA = :dblIdlinhatelefonica and
		LINHATELEFONICA.IDLINHATELEFONICA = PLANOSERVICOLINHA.IDLINHATELEFONICA AND 
		PLANOSERVICOLINHA.IDSERVICO = PLANOSERVICO.IDSERVICO AND
		(PLANOSERVICO.NMSERVICO LIKE '%BASICO CARTAO%'  OR
		 PLANOSERVICO.NMSERVICO LIKE '%CONEXAO ILIMITADO%'  OR
		 PLANOSERVICO.NMSERVICO LIKE '%PLANO CARTAO PF%'  OR
		 PLANOSERVICO.NMSERVICO LIKE '%PLANO CARTAO PJ%'  OR
		 PLANOSERVICO.NMSERVICO LIKE '%PLANO BASE INTERNET%' OR
		 PLANOSERVICO.NMSERVICO LIKE '%PLANO BASE INTERNET PF%')AND 
		( PLANOSERVICOlinha.dtvigenciafinal is null or PLANOSERVICOlinha.dtvigenciafinal >= sysdate +1 ) AND 
		( PLANOSERVICOlinha.dtexpiracao is null or PLANOSERVICOlinha.dtexpiracao >= sysdate +1 );	
		
	return countZap;
}

void setPlanoDadosFixo(struct stStatuslinha *stLinha)
{
	tuxfw_getlogger()->information("setPlanoDadosFixo");
	EXEC SQL BEGIN DECLARE SECTION;	 
		int count = 0;	
		double dblIdlinhatelefonica = stLinha->dblIdlinhatelefonica;
	EXEC SQL END DECLARE SECTION;
	
	EXEC SQL WHENEVER SQLERROR DO sql_error(stLinha, ERR_DATABASE);
	
	EXEC SQL SELECT
	  COUNT(1)
	INTO	:count
	FROM
		LINHA.LINHATELEFONICA LINHATELEFONICA,
		LINHA.PLANOSERVICOLINHA PLANOSERVICOLINHA,
		LINHA.PLANOSERVICO PLANOSERVICO
	WHERE
		LINHATELEFONICA.IDLINHATELEFONICA = :dblIdlinhatelefonica and
		LINHATELEFONICA.IDLINHATELEFONICA = PLANOSERVICOLINHA.IDLINHATELEFONICA AND 
		PLANOSERVICOLINHA.IDSERVICO = PLANOSERVICO.IDSERVICO AND
		(PLANOSERVICO.SGSERVICO LIKE '%PL FIXO INTERNET PF%'  OR
		 PLANOSERVICO.SGSERVICO LIKE '%PL FIXO INTERNET PJ%' )AND 
		( PLANOSERVICOlinha.dtvigenciafinal is null or PLANOSERVICOlinha.dtvigenciafinal >= sysdate +1 ) AND 
		( PLANOSERVICOlinha.dtexpiracao is null or PLANOSERVICOlinha.dtexpiracao >= sysdate +1 );	

	if(count > 0)
	{
		tuxfw_getlogger()->information("achou o serviço PL FIXO INTERNET count = %d", count);
		strcpy(stLinha->chrTipolinha,"13");
	}			
}

void getDadosPortabilidade(struct stStatuslinha *stLinha,XMLGen* xml_g)
{
	tuxfw_getlogger()->information("getDadosPortabilidade");

	EXEC SQL BEGIN DECLARE SECTION;
		struct stdados{
			VARCHAR statcom[1+1];
			VARCHAR cdcodigoretorno[2+1];
			VARCHAR sgindicadorsituacaocadastro[1+1];
			VARCHAR sgindicadorestadolinha[2+1];
			VARCHAR cdcodigoretornotipoconta[2+1];
			VARCHAR cdcodigosegmentocliente[2+1];
			VARCHAR cdcodigocarteira[2+1];
			VARCHAR sgindsenhareiniciocliente[1+1];
			VARCHAR sgindsenhareiniciousuario[1+1];
			VARCHAR dssenhacriptografadacliente[255+1];
			VARCHAR dssenhacriptografadausuario[255+1];
			VARCHAR dsnumerorgcliente[255+1];
			VARCHAR dsnumerorgusuario[255+1];
			VARCHAR dsnumerocepcliente[255+1];
			VARCHAR dsnumerocepusuario[255+1];
			VARCHAR dtdatanascimentocliente[22];
			VARCHAR dtdatanascimentousuario[22];
			VARCHAR dsnumerocpfcliente[255+1];
			VARCHAR dsnumerocpfusuario[255+1];
			VARCHAR dssenhalojista[255+1];
			VARCHAR cdprioridadelojista[1+1];
			VARCHAR sgindicadoratendimentopessoal[1+1];
			VARCHAR dsnomecliente[255+1];
			VARCHAR dsnomeusuario[255+1]; 
			VARCHAR planolinha[13+1];
			VARCHAR codrestricao[1+1]; 
			VARCHAR titularidade[1+1]; 
		}m_stDados;
		struct istdados{
			short statcom;
			short cdcodigoretorno;
			short sgindicadorsituacaocadastro;
			short sgindicadorestadolinha;
			short cdcodigoretornotipoconta;
			short cdcodigosegmentocliente;
			short cdcodigocarteira;
			short sgindsenhareiniciocliente;
			short sgindsenhareiniciousuario;
			short dssenhacriptografadacliente;
			short dssenhacriptografadausuario;
			short dsnumerorgcliente;
			short dsnumerorgusuario;
			short dsnumerocepcliente;
			short dsnumerocepusuario;
			short dtdatanascimentocliente;
			short dtdatanascimentousuario;
			short dsnumerocpfcliente;
			short dsnumerocpfusuario;
			short dssenhalojista;
			short cdprioridadelojista;
			short sgindicadoratendimentopessoal;
			short dsnomecliente;
			short dsnomeusuario; 
			short planolinha;
			short codrestricao; 
			short titularidade; 
		}m_istDados;		
		int cdAreaRegistro = stLinha->ntArea;
		int cdNumTelefone = stLinha->ntLinha;
		int status = -1;
	EXEC SQL END DECLARE SECTION;

	memset(&m_stDados,0,sizeof(m_stDados));
	memset(&m_istDados,0,sizeof(m_istDados));
	sqlca.sqlcode = 0;
	
	EXEC SQL WHENEVER SQLERROR DO sql_error(stLinha, ERR_NOT_FOUND_OR_DISABLED);
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL
	SELECT	TO_NUMBER(NVL(DSVALORPARAMETRO,-1))
	INTO	:status
	FROM	APOIO.PARAMETRO
	WHERE
		CDPARAMETRO = 'URIN_PORTABILIDADE';

	/**
	  * Verificar o Parametro URIN_PORTABILIDADE na APOIO.PARAMETRO
	  * O valor precisa ser 1 para retornar dados
	  */	
	if (sqlca.sqlcode == 1403 || status != 1) {
		tuxfw_getlogger()->information("Parâmetro URIN_PORTABILIDADE não encontrado na APOIO.PARAMETRO");
                stLinha->ntStatus = -1;		
		return;
	}

	EXEC SQL
	SELECT	 
	STATCOM, CDCODIGORETORNO, SGINDICADORSITUACAOCADASTRO, SGINDICADORESTADOLINHA, CDCODIGORETORNOTIPOCONTA, 
	 CDCODIGOSEGMENTOCLIENTE, CDCODIGOCARTEIRA, SGINDSENHAREINICIOCLIENTE, SGINDSENHAREINICIOUSUARIO, DSSENHACRIPTOGRAFADACLIENTE, 
	 DSSENHACRIPTOGRAFADAUSUARIO, DSNUMERORGCLIENTE, DSNUMERORGUSUARIO, DSNUMEROCEPCLIENTE, DSNUMEROCEPUSUARIO, 
	 DTDATANASCIMENTOCLIENTE, DTDATANASCIMENTOUSUARIO, DSNUMEROCPFCLIENTE, DSNUMEROCPFUSUARIO, DSSENHALOJISTA, 
	 CDPRIORIDADELOJISTA, SGINDICADORATENDIMENTOPESSOAL, DSNOMECLIENTE, DSNOMEUSUARIO, PLANOLINHA, 
	 CODRESTRICAO, TITULARIDADE
	 INTO :m_stDados:m_istDados
	 FROM
	 CUSTOMER.URINPORTABILIDADEV01
	 WHERE
	 NRLINHA = TO_NUMBER(:cdNumTelefone) AND
	 CDAREAREGISTRO = TO_NUMBER(:cdAreaRegistro);

	if(sqlca.sqlcode == 1403){
		tuxfw_getlogger()->information("Linha não encontrada na view de portabilidade");
		stLinha->ntStatus = -1;
		return;
	}

	xml_g->addItem(TAG_STATCOM,(char*)m_stDados.statcom.arr);
	xml_g->addItem(TAG_CODIGORETORNO,(char*)m_stDados.cdcodigoretorno.arr);
	xml_g->addItem(TAG_SITUACAO_CADASTRO,(char*)m_stDados.sgindicadorsituacaocadastro.arr);
	xml_g->addItem(TAG_ESTADOLINHA,(char*)m_stDados.sgindicadorestadolinha.arr);
	xml_g->addItem(TAG_TIPOLINHA,(char*)m_stDados.cdcodigoretornotipoconta.arr);
	xml_g->addItem(TAG_SEGMENTO,(char*)m_stDados.cdcodigosegmentocliente.arr);
	xml_g->addItem(TAG_CARTEIRA,(char*)m_stDados.cdcodigocarteira.arr);
	xml_g->addItem(TAG_REINIC_SENHA_CLIENTE,(char*)m_stDados.sgindsenhareiniciocliente.arr);
	xml_g->addItem(TAG_REINIC_SENHA_USUARIO,(char*)m_stDados.sgindsenhareiniciousuario.arr);
	xml_g->addItem(TAG_SENHA_CLIENTE,(char*)m_stDados.dssenhacriptografadacliente.arr);
	xml_g->addItem(TAG_SENHA_USUARIO,(char*)m_stDados.dssenhacriptografadausuario.arr);
	xml_g->addItem(TAG_RG_CLIENTE,(char*)m_stDados.dsnumerorgcliente.arr);
	xml_g->addItem(TAG_RG_USUARIO,(char*)m_stDados.dsnumerorgusuario.arr);
	xml_g->addItem(TAG_CEP_CLIENTE,(char*)m_stDados.dsnumerocepcliente.arr);
	xml_g->addItem(TAG_CEP_USUARIO,(char*)m_stDados.dsnumerocepusuario.arr);
	xml_g->addItem(TAG_NASCIMENTO_CLIENTE,(char*)m_stDados.dtdatanascimentocliente.arr);
	xml_g->addItem(TAG_NASCIMENTO_USUARIO,(char*)m_stDados.dtdatanascimentousuario.arr);
	xml_g->addItem(TAG_CPF_CLIENTE,(char*)m_stDados.dsnumerocpfcliente.arr);
	xml_g->addItem(TAG_CPF_USUARIO,(char*)m_stDados.dsnumerocpfusuario.arr);
	xml_g->addItem(TAG_SENHA_LOJISTA,(char*)m_stDados.dssenhalojista.arr);
	xml_g->addItem(TAG_PRIORIDADE_LOJISTA,(char*)m_stDados.cdprioridadelojista.arr);
	xml_g->addItem(TAG_ATENDIMENTO_PESSOAL,(char*)m_stDados.sgindicadoratendimentopessoal.arr);
	xml_g->addItem(TAG_NOME_CLIENTE,(char*)m_stDados.dsnomecliente.arr);
	xml_g->addItem(TAG_NOME_USUARIO,(char*)m_stDados.dsnomeusuario.arr); 
	xml_g->addItem(TAG_PLANO_LINHA,(char*)m_stDados.planolinha.arr);
	xml_g->addItem(TAG_CODRESTRICAO,(char*)m_stDados.codrestricao.arr); 
	xml_g->addItem(TAG_TITULARIDADE,(char*)m_stDados.titularidade.arr); 
	xml_g->addItem(TAG_CLUSTERLINHA,""); 	
	
	// adicionar tag de iphone
	setCadastroIPhone(stLinha,xml_g);
}

void setDadosPortabilidade(struct stStatuslinha *stLinha,XMLGen* xml_g)
{
	tuxfw_getlogger()->information("setDadosPortabilidade");
	EXEC SQL BEGIN DECLARE SECTION;	 		
		struct stdados{
			int status;
			int idAcaoPortabilidade;
			VARCHAR sgPortabilidade[256];
			VARCHAR dataSolicitacao[21];
			VARCHAR dataAtual[21];
			VARCHAR dsAcaoPortabilidade[256];
			VARCHAR tpFraude[3];
		}m_stDados;
		struct istdados{
			short status;
			short idAcaoPortabilidade;
			short sgPortabilidade;
			short dataSolicitacao;
			short dataAtual;
			short dsAcaoPortabilidade;
			short tpFraude;
		}m_istDados;
		double dblIdlinhatelefonica = stLinha->dblIdlinhatelefonica;
		int cdAreaRegistro = stLinha->ntArea;
		int cdNumTelefone = stLinha->ntLinha;
	EXEC SQL END DECLARE SECTION;
	char chStatusPortabilidade[21];	
	char chSiglaPortabilidade[256];
	memset(&chSiglaPortabilidade,0,sizeof(chSiglaPortabilidade));
	memset(&chStatusPortabilidade,0,sizeof(chStatusPortabilidade));
	memset(&m_stDados,0,sizeof(m_stDados));
	memset(&m_istDados,0,sizeof(m_istDados));
	sqlca.sqlcode = 0;
	// setando o status, e acao portabilidade para -1
	m_stDados.status = -1;
	m_stDados.idAcaoPortabilidade = -1;
	
	EXEC SQL WHENEVER SQLERROR DO sql_error(stLinha, ERR_DATABASE);
	EXEC SQL WHENEVER NOTFOUND CONTINUE;

	EXEC SQL
	SELECT	TO_NUMBER(NVL(DSVALORPARAMETRO,-1))
	INTO	:m_stDados.status:m_istDados.status
	FROM	APOIO.PARAMETRO
	WHERE
		CDPARAMETRO = 'URIN_PORTABILIDADE';

	/**
	  * Verificar o Parametro URIN_PORTABILIDADE na APOIO.PARAMETRO
	  * O valor precisa ser 1 para retornar dados
	  */	
	if (sqlca.sqlcode == 1403 || m_stDados.status != 1) {
                stLinha->ntStatus = -1;
		return;
	}
	 /**
	  * Data de mudança do status da portabilidade formato : DDMMAA
	  **/
	 EXEC SQL
	 SELECT DTULTIMAALTERACAO
	 INTO	:m_stDados.dataAtual:m_istDados.dataAtual
	 FROM 
	 (SELECT 		
		TO_CHAR(PESSOAPORTABILIDADEHIST.DTULTIMAALTERACAO,'DDMMYY') AS DTULTIMAALTERACAO			 
	 FROM 
		CUSTOMER.PESSOAPORTABILIDADEHIST PESSOAPORTABILIDADEHIST
	 WHERE
		PESSOAPORTABILIDADEHIST.NRLINHA = TO_NUMBER(:cdNumTelefone)
		AND PESSOAPORTABILIDADEHIST.CDAREAREGISTRO = TO_NUMBER(:cdAreaRegistro)
	 ORDER BY 
			DTULTIMAALTERACAO ASC
		)	 	
	 WHERE ROWNUM = 1;
	

	 sqlca.sqlcode = 0;

	/* Query unificada */
	EXEC SQL
	SELECT 
	    SGTIPOPORTABILIDADE,
	    TO_CHAR(DTULTIMAALTERACAO,'DDMMYY') AS DTULTIMAALTERACAO,
	    DSACAOPORTABILIDADE,
	    IDACAOPORTABILIDADE
        INTO :m_stDados.sgPortabilidade:m_istDados.sgPortabilidade,
	     :m_stDados.dataSolicitacao:m_istDados.dataSolicitacao,
	     :m_stDados.dsAcaoPortabilidade:m_istDados.dsAcaoPortabilidade,
	     :m_stDados.idAcaoPortabilidade:m_istDados.idAcaoPortabilidade
	FROM
	(
	    SELECT 
		TEMP.SGTIPOPORTABILIDADE,
		TEMP.DTULTIMAALTERACAO,
		TEMP.DSACAOPORTABILIDADE,
			TEMP.IDACAOPORTABILIDADE
	    FROM
	    (
		SELECT
		    1 AS DEF,
		    PESSOAPORTABILIDADEHIST.DTULTIMAALTERACAO,
		    PESSOAPORTABILIDADEHIST.SGTIPOPORTABILIDADE AS SGTIPOPORTABILIDADE,
		    ACAOPORTABILIDADE.DSACAOPORTABILIDADE,
				ACAOPORTABILIDADE.IDACAOPORTABILIDADE
		FROM 
		    CUSTOMER.PESSOAPORTABILIDADEHIST PESSOAPORTABILIDADEHIST,
		    APOIO.ACAOPORTABILIDADE ACAOPORTABILIDADE
		WHERE
		    PESSOAPORTABILIDADEHIST.NRLINHA = TO_NUMBER(:cdNumTelefone)
		AND PESSOAPORTABILIDADEHIST.CDAREAREGISTRO = TO_NUMBER(:cdAreaRegistro)
		AND PESSOAPORTABILIDADEHIST.DSACAOPORTABILIDADE=ACAOPORTABILIDADE.DSACAOPORTABILIDADE
		AND ACAOPORTABILIDADE.IDACAOPORTABILIDADE IN (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,101)
	    UNION ALL
		SELECT
		    2 AS DEF,
		    PESSOAPORTABILIDADEHIST.DTULTIMAALTERACAO,
		    PESSOAPORTABILIDADEHIST.SGTIPOPORTABILIDADE AS SGTIPOPORTABILIDADE,
		    ' ' AS DSACAOPORTABILIDADE,
				NULL AS IDACAOPORTABILIDADE
		FROM 
		    CUSTOMER.PESSOAPORTABILIDADEHIST PESSOAPORTABILIDADEHIST,
		    APOIO.ACAOPORTABILIDADE ACAOPORTABILIDADE
		WHERE
		    PESSOAPORTABILIDADEHIST.NRLINHA = TO_NUMBER(:cdNumTelefone)
		AND PESSOAPORTABILIDADEHIST.CDAREAREGISTRO = TO_NUMBER(:cdAreaRegistro)
		AND PESSOAPORTABILIDADEHIST.DSACAOPORTABILIDADE=ACAOPORTABILIDADE.DSACAOPORTABILIDADE
		AND ACAOPORTABILIDADE.IDACAOPORTABILIDADE NOT IN (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,101)
	    ) TEMP
	    ORDER BY
		TEMP.DEF,TEMP.DTULTIMAALTERACAO DESC
	)
	WHERE ROWNUM<=1;

		
	if(m_stDados.idAcaoPortabilidade < 10 && m_stDados.idAcaoPortabilidade > -1)
		sprintf(chStatusPortabilidade,"0%d",m_stDados.idAcaoPortabilidade);
	else
	if(m_stDados.idAcaoPortabilidade > 9)
		sprintf(chStatusPortabilidade,"%d",m_stDados.idAcaoPortabilidade);

	char *sigla = (char*)m_stDados.sgPortabilidade.arr;	
	if(sigla != NULL)
	{
		if(strcmp(sigla,"PORTIN") == 0)
			sprintf(chSiglaPortabilidade,"%s","01");
		else
		if(strcmp(sigla,"PORTOUT") == 0)
			sprintf(chSiglaPortabilidade,"%s","02");
		else
		if(strcmp(sigla,"FRAUDE") == 0)
		{
			//sprintf(chSiglaPortabilidade,"%s","03");
		    EXEC SQL
			SELECT (CASE WHEN COUNT(1)>0 THEN '05' ELSE '03'END)
			into :m_stDados.tpFraude:m_istDados.tpFraude	
			FROM customer.pessoaportabilidade
			WHERE cdarearegistro=TO_NUMBER(:cdAreaRegistro)
			AND	  nrlinha=:cdNumTelefone;
			
			sprintf(chSiglaPortabilidade,"%s",(char*)m_stDados.tpFraude.arr);
		}
		else
		if(strcmp(sigla,"WINBACK") == 0)
			sprintf(chSiglaPortabilidade,"%s","04");
	}

	if(sqlca.sqlcode == 1403){
		xml_g->addItem("statusPortabilidade","");
		xml_g->addItem("tipoOperacaoPortabilidade","00");
		xml_g->addItem("dtSolicitacaoPortabilidade","");
		xml_g->addItem("dtMudancaStatusPortabilidade","");
	}else{
		xml_g->addItem("statusPortabilidade",chStatusPortabilidade);
		xml_g->addItem("tipoOperacaoPortabilidade",chSiglaPortabilidade);
		xml_g->addItem("dtSolicitacaoPortabilidade",(char*)m_stDados.dataAtual.arr);
		xml_g->addItem("dtMudancaStatusPortabilidade",(char*)m_stDados.dataSolicitacao.arr);		
	}			
}

int isMailing(struct stStatuslinha *stLinha)
{
	tuxfw_getlogger()->information("isMailing");
	EXEC SQL BEGIN DECLARE SECTION;	 
		int count = 0;	
		int cdAreaRegistro = stLinha->ntArea;
		int cdNumTelefone = stLinha->ntLinha;
	EXEC SQL END DECLARE SECTION;
	
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;
	
	EXEC SQL 
	SELECT COUNT(1) INTO :count
	FROM VOL.LINHAPREMIUM WHERE NRLINHA = TO_NUMBER(:cdNumTelefone) AND CDAREAREGISTRO = TO_NUMBER(:cdAreaRegistro);

	tuxfw_getlogger()->information("Count = %d",count);

	return count;
}

void setCadastroIPhone(struct stStatuslinha *stLinha,XMLGen* xml_g)
{
	tuxfw_getlogger()->information("setCadastroIPhone");
	EXEC SQL BEGIN DECLARE SECTION;	 
		int countCampanha = 0;
		int countCadastro = 0;
		int cdAreaRegistro = stLinha->ntArea;
		int cdNumTelefone = stLinha->ntLinha;
	EXEC SQL END DECLARE SECTION;
	
	EXEC SQL WHENEVER SQLERROR CONTINUE;
	EXEC SQL WHENEVER NOTFOUND CONTINUE;
	
	EXEC SQL 
	SELECT COUNT(1) INTO :countCampanha
	FROM VOL.MAILINGIPHONE WHERE NRLINHA = TO_NUMBER(:cdNumTelefone) AND CDAREAREGISTRO = TO_NUMBER(:cdAreaRegistro);
	

	EXEC SQL 
	SELECT COUNT(1) INTO :countCadastro
	FROM VOL.CAMPANHAVIP CAMPANHAVIP, 
		LINHA.LINHABASE LINHABASE,
		APOIO.AREAREGISTRO AREAREGISTRO
	WHERE 
	      AREAREGISTRO.IDAREAREGISTRO = LINHABASE.IDAREAREGISTRO AND
	      LINHABASE.IDLINHABASE = CAMPANHAVIP.IDLINHABASE AND
	      LINHABASE.NRLINHA = TO_NUMBER(:cdNumTelefone) AND 
	      AREAREGISTRO.CDAREAREGISTRO = TO_NUMBER(:cdAreaRegistro);
	
	tuxfw_getlogger()->information("countCampanha = %d",countCampanha);
	tuxfw_getlogger()->information("countCadastro = %d",countCadastro);


	if(countCadastro > 0){
		xml_g->addItem("smartphone","02");
	}else if(countCampanha > 0){
		xml_g->addItem("smartphone","01");
	}else{
		xml_g->addItem("smartphone","00");
	}
	
}

bool GetBloqueioPreAtivacao( struct stStatuslinha *stLinha )
{
	tuxfw_getlogger()->information("GetBloqueioPreAtivacao para pós pago");	
	sqlca.sqlcode = 0;
	EXEC SQL BEGIN DECLARE SECTION;
		struct stStatuslinha o_stLinha;
		int iNrRestrito = 0;		
	EXEC SQL END DECLARE SECTION;

	tuxfw_getlogger()->information("linha %s",stLinha->chrTelefone);

	EXEC SQL WHENEVER SQLERROR DO sql_error(&o_stLinha, ERR_DATABASE,sqlca.sqlcode);

	memset( &o_stLinha, 0, sizeof( o_stLinha ) );
	memcpy(&o_stLinha,&(*stLinha),sizeof(o_stLinha));

	EXEC SQL SELECT count(0)
	INTO :iNrRestrito
	  from LINHA.ACCESS_NBR_HOTLN_REASON
	 where LINHA.ACCESS_NBR_HOTLN_REASON.SBSCRP_ID = (SELECT IDLINHASISTEMAORIGEM 
							     FROM LINHA.LINHABASE LB,
								  LINHA.LINHATELEFONICA LT,
								  APOIO.AREAREGISTRO AR
							    WHERE LB.NRLINHA = TO_NUMBER(:o_stLinha.ntLinha)
							      AND LB.IDAREAREGISTRO = AR.IDAREAREGISTRO 
							      AND LB.IDLINHABASE = LT.IDLINHABASE 
							      AND AR.CDAREAREGISTRO = TO_NUMBER(:o_stLinha.ntArea)) 
	   AND LINHA.ACCESS_NBR_HOTLN_REASON.HOTLN_REASON_CD = 'PRE ACTIVATION' 
	   AND LINHA.ACCESS_NBR_HOTLN_REASON.INEXCLUSAOLOGICA = 0;


	if (iNrRestrito)
		return 1;
	else
		return 0;


}

void IsLinhaOferta( struct stStatuslinha *stLinha )
{
	tuxfw_getlogger()->information("SetLinhaOferta - verfica se a linha possui oferta");	

	EXEC SQL BEGIN DECLARE SECTION;
		struct stStatuslinha o_stLinha;
		int iNrOferta = 0;		
	EXEC SQL END DECLARE SECTION;

	tuxfw_getlogger()->information("linha %s",stLinha->chrTelefone);
	// vamos setar o valor N caso a tabela não exista ou ocorra algum erro de oracle
	sprintf(stLinha->chrLinhaOferta,"N");

	EXEC SQL WHENEVER SQLERROR DO sql_error(&o_stLinha, ERR_DATABASE);

	memset( &o_stLinha, 0, sizeof( o_stLinha ) );
	memcpy(&o_stLinha,&(*stLinha),sizeof(o_stLinha));

	EXEC SQL 
	SELECT COUNT(1) 
	INTO :iNrOferta
	FROM LINHA.LINHAOFERTA LINHAOFERTA
	WHERE
	LINHAOFERTA.NRLINHA = TO_NUMBER(:o_stLinha.ntLinha) AND
	LINHAOFERTA.CDAREAREGISTRO = TO_NUMBER(:o_stLinha.ntArea);


	if (iNrOferta)
	{
		tuxfw_getlogger()->information("existe oferta para linha");
		sprintf(stLinha->chrLinhaOferta,"S");
	}
	else
	{
		tuxfw_getlogger()->information("não existe oferta para linha");
	}


}
/**
 * Verifica se a linha possui conta gestor associada.
 */
int linhaPossuiGestor( struct stStatuslinha *stLinha )
{
	tuxfw_getlogger()->information("verificaGestor");	

	tuxfw_getlogger()->information( ">>> EXTREME NOISE TERROR!!!" );

	EXEC SQL BEGIN DECLARE SECTION;
		char* orachrTelefone = stLinha->chrTelefone;
		int icountGestor = 0;		
		int icountGestorMaster = 0;
		short iicountGestor=-1;
		short iicountGestorMaster=-1;
	EXEC SQL END DECLARE SECTION;
	tuxfw_getlogger()->information("[linha com ddd]= %s",stLinha->chrTelefone);
	EXEC SQL WHENEVER SQLERROR DO sql_error(stLinha, ERR_DATABASE);

	/*
	EXEC SQL 
	SELECT COUNT(1) 
	INTO :icountGestor
	FROM CUSTOMER.PESSOAGESTOR
	WHERE
	(NRTELEFONECELULARVIVO = TO_NUMBER(:orachrTelefone) OR
	NRTELEFONEFIXO = TO_NUMBER(:orachrTelefone)) AND
	IDTIPORELACIONAMENTO = 5;
        */
        

    EXEC SQL
	SELECT 
	   COUNT(1) 
	INTO 
	   :icountGestorMaster:iicountGestorMaster
	FROM 
	   CUSTOMER.PESSOAGESTOR PESSOAGESTOR,
	   CUSTOMER.PESSOAGESTORMASTER PESSOAGESTORMASTER
	WHERE
	   PESSOAGESTORMASTER.NRDOCUMENTOGESTOR = PESSOAGESTOR.NRDOCUMENTO
	AND
	   ( PESSOAGESTOR.NRTELEFONECELULARVIVO = TO_NUMBER(:orachrTelefone) 
	OR
	   PESSOAGESTOR.NRTELEFONEFIXO = TO_NUMBER(:orachrTelefone)
	OR
	   PESSOAGESTOR.NRTELEFONECELULAROUTRO = TO_NUMBER(:orachrTelefone)
       ); 

	if ( icountGestorMaster > 0 )
	{
		tuxfw_getlogger()->information( ">>> GESTOR MASTER: foi encontrada uma conta para a linha" );
		tuxfw_getlogger()->information( ">>> icountGestorMaster!!!" );
		return 1;
    }
    else
    {
        icountGestor=0;
        EXEC SQL
	SELECT 
	   COUNT(1) 
	INTO 
           :icountGestor:iicountGestor
	FROM 
	   CUSTOMER.PESSOAGESTOR PESSOAGESTOR,
	   CUSTOMER.PESSOAGESTORCONTA PESSOAGESTORCONTA
	WHERE
	   PESSOAGESTORCONTA.NRDOCUMENTO = PESSOAGESTOR.NRDOCUMENTO
	AND
	   ( PESSOAGESTOR.NRTELEFONECELULARVIVO = TO_NUMBER(:orachrTelefone) 
	OR
		   PESSOAGESTOR.NRTELEFONEFIXO = TO_NUMBER(:orachrTelefone)
		OR
		   PESSOAGESTOR.NRTELEFONECELULAROUTRO = TO_NUMBER(:orachrTelefone)
		   )
	AND
	   PESSOAGESTORCONTA.IDTIPORELACIONAMENTO = 5;
	           
        if ( icountGestor > 0 )
	{
            tuxfw_getlogger()->information( ">>> GESTOR CONTA: foi encontrada uma conta para a linha" );
			tuxfw_getlogger()->information( ">>> iicountGestor!!!" );
            return 2;
	}
	else
	{
		tuxfw_getlogger()->information("não foi encontrada uma conta para a linha");
				tuxfw_getlogger()->information( ">>> NORMAL!!!" );
		return 0;
	}
    }

}

/**
 * Verifica CNL
 */
int getCnl(char *pCEP, char* pCNL )
{
	tuxfw_getlogger()->information(">>getCnl");	

	tuxfw_getlogger()->information( ">>> inicio" );

	tuxfw_getlogger()->information("[pCEP]= %s",pCEP);

	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR szCep[10];
		VARCHAR szCNL[20];
		short iszCNL=-1;
	EXEC SQL END DECLARE SECTION;

	memset( &szCep, 0x0, sizeof(szCep) );
	memset( &szCNL, 0x0, sizeof(szCNL) );

	EXEC SQL WHENEVER SQLERROR  goto ERROR;

	sprintf((char*)szCep.arr,"%s",pCEP);
	szCep.len=strlen(pCEP);

	tuxfw_getlogger()->information("[szCep.ARR]= %s",(char*)szCep.arr);

EXEC SQL
	SELECT 
        INCNL
		into szCNL:iszCNL
        FROM ENDERECO.DE_ENDERECO_PARA_APOIOV01
        WHERE CODCEP =substr(:szCep,1,8)
        AND   ROWNUM < 2;

	if ( iszCNL != -1 )
	   sprintf(pCNL,"%s",(char*)szCNL.arr);

	tuxfw_getlogger()->information("[pCNL]= %s",pCNL);

	tuxfw_getlogger()->information("<<getCnl");	

	
return 1;

ERROR:
tuxfw_getlogger()->information("<<getCnl");	
return 2;

}

void getComboFixo( struct stStatuslinha *stLinha )
{
	tuxfw_getlogger()->information("inicio getComboFixo retorna o cdfixomovel da linhatelefonica");	

	EXEC SQL BEGIN DECLARE SECTION;		
	
		double dblIdlinhatelefonica = stLinha->dblIdlinhatelefonica;		
        VARCHAR chrCdFixoMovel[1+1];
		short i_chrCdFixoMovel = 0;
	EXEC SQL END DECLARE SECTION;
	
	memset(&chrCdFixoMovel,0,sizeof(chrCdFixoMovel));	

	EXEC SQL WHENEVER SQLERROR DO sql_error(stLinha, ERR_DATABASE);


    EXEC SQL 	   
	SELECT cdfixomovel
	  INTO :chrCdFixoMovel:i_chrCdFixoMovel
	  FROM linha.linhatelefonica lt
	 WHERE lt.idlinhatelefonica = :dblIdlinhatelefonica;
	 
	 sprintf(stLinha->chrCdFixoMovel,(char*)chrCdFixoMovel.arr);

	tuxfw_getlogger()->information("cdfixomovel = %s", stLinha->chrCdFixoMovel);	
}


int consultarRegraComboFixo( struct stStatuslinha *stLinha )
{
	tuxfw_getlogger()->information("consultarRegraComboFixo");	

	EXEC SQL BEGIN DECLARE SECTION;		
		int iQtdLinhaFixa = 0;		
		int iQtdLinhaMovel = 0;	
		double idpessoadepara = stLinha->idpessoadepara;		
        
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR DO sql_error(stLinha, ERR_DATABASE);

    
    EXEC SQL 	   
	SELECT count(1)
	  INTO :iQtdLinhaFixa
	  FROM customer.pessoalinha pl, linha.linhatelefonica lt
	 WHERE pl.idpessoadepara = :idpessoadepara
	   AND pl.idtiporelacionamento = 2
	   AND pl.idlinhatelefonica = lt.idlinhatelefonica
	   AND lt.cdfixomovel = 'F';
	   
    EXEC SQL 	   
	SELECT count(1)
	  INTO :iQtdLinhaMovel
	  FROM customer.pessoalinha pl, linha.linhatelefonica lt
	 WHERE pl.idpessoadepara = :idpessoadepara
	   AND pl.idtiporelacionamento = 2
	   AND pl.idlinhatelefonica = lt.idlinhatelefonica
	   AND lt.cdfixomovel = 'M';

    if (iQtdLinhaFixa && iQtdLinhaMovel) {
		tuxfw_getlogger()->information("linha possui fixo movel");
		return 1;
	} else {
		tuxfw_getlogger()->information("linha não possui fixo movel");
		return 0;
	}
}

bool IsPlanoModem( struct stStatuslinha *stLinha )
{
	tuxfw_getlogger()->information("IsPlanoModem para pessoa física");	
	sqlca.sqlcode = 0;
	EXEC SQL BEGIN DECLARE SECTION;
		struct stStatuslinha o_stLinha;
		int iPlanoModem = 0;		
	EXEC SQL END DECLARE SECTION;

	tuxfw_getlogger()->information("linha %f",stLinha->dblIdcliente);

	EXEC SQL WHENEVER SQLERROR DO sql_error(&o_stLinha, ERR_DATABASE,sqlca.sqlcode);

	memset( &o_stLinha, 0, sizeof( o_stLinha ) );
	memcpy(&o_stLinha,&(*stLinha),sizeof(o_stLinha));

	EXEC SQL
	SELECT COUNT(1)  AS PLANOMODEM
	  INTO :iPlanoModem
	  FROM CUSTOMER.PESSOALINHA PL,
		   CUSTOMER.PESSOADEPARA PDP,
		   LINHA.PLANOSERVICO PS,
		   LINHA.PLANOSERVICOLINHA PSL,
		   LINHA.LINHATELEFONICA LT,
		   APOIO.PLANODADOS PD
	 WHERE  PSL.IDLINHATELEFONICA = LT.IDLINHATELEFONICA
		   AND PSL.IDSERVICO = PS.IDSERVICO
		   AND PS.IDSERVICO = PD.IDSERVICO
		   AND PL.IDPESSOADEPARA = PDP.IDPESSOADEPARA
		   AND PL.IDLINHATELEFONICA = LT.IDLINHATELEFONICA
		   AND PDP.IDPESSOA = :o_stLinha.dblIdcliente;

	tuxfw_getlogger()->information("linha %d",iPlanoModem);

	if (iPlanoModem)
		return 1;
	else
		return 0;


}



bool IsControlN( char * idLinhaTelefonicaPrm )
{
   tuxfw_getlogger()->information( ">>> IsControlN()" );
   
   bool retorno = false;

   EXEC SQL BEGIN DECLARE SECTION;
      char * idLinhaTelefonica = idLinhaTelefonicaPrm;
      int count = 0;
   EXEC SQL END DECLARE SECTION;

   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL WHENEVER NOTFOUND CONTINUE;
   
   tuxfw_getlogger()->information("*** idLinhaTelefonica [%s]", idLinhaTelefonica );

   EXEC SQL 
   SELECT
      COUNT(STL.IDSUBTIPOLINHA)
   INTO
      :count
   FROM
      LINHA.LINHATELEFONICA   LT ,
      APOIO.SUBTIPOLINHA     STL
   WHERE
      LT.IDSUBTIPOLINHA = STL.IDSUBTIPOLINHA
   AND STL.CDSUBTIPOLINHA = 'CONTROLE N'
   AND LT.IDLINHATELEFONICA = :idLinhaTelefonica ;
   
   if ( count > 0 )
      retorno = true;

   tuxfw_getlogger()->information( "<<< IsControlN()" );

   return retorno;
}


bool IsVivoNext( char * idLinhaTelefonicaPrm )
{
   tuxfw_getlogger()->information( ">>> IsVivoNext()" );

   bool retorno = false;

   EXEC SQL BEGIN DECLARE SECTION;
      char * idLinhaTelefonica = idLinhaTelefonicaPrm;
      int count = 0;
   EXEC SQL END DECLARE SECTION;

   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL WHENEVER NOTFOUND CONTINUE;
   
   tuxfw_getlogger()->information("*** idLinhaTelefonica [%s]", idLinhaTelefonica );

   EXEC SQL 
   SELECT
      COUNT(STL.IDSUBTIPOLINHA)
   INTO
      :count
   FROM
      LINHA.LINHATELEFONICA   LT ,
      APOIO.SUBTIPOLINHA     STL
   WHERE
      LT.IDSUBTIPOLINHA = STL.IDSUBTIPOLINHA
   AND STL.CDSUBTIPOLINHA = 'VIVO NEXT'
   AND LT.IDLINHATELEFONICA = :idLinhaTelefonica ;
   
   if ( count > 0 )
      retorno = true;

   tuxfw_getlogger()->information( "<<< IsVivoNext()" );

   return retorno;
}

bool IsVoip( char * idLinhaTelefonicaPrm )
{
   tuxfw_getlogger()->information( ">>> IsVoip()" );
   
   bool retorno = false;

   EXEC SQL BEGIN DECLARE SECTION;
      char * idLinhaTelefonica = idLinhaTelefonicaPrm;
      int count = 0;
   EXEC SQL END DECLARE SECTION;

   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL WHENEVER NOTFOUND CONTINUE;
   
   tuxfw_getlogger()->information("*** idLinhaTelefonica [%s]", idLinhaTelefonica );

   EXEC SQL 
   SELECT
      COUNT(TT.IDTIPOTECNOLOGIA)
   INTO
      :count
   FROM
      LINHA.LINHATELEFONICA   LT ,
      APOIO.TIPOTECNOLOGIA    TT
   WHERE
      LT.IDTIPOTECNOLOGIA = TT.IDTIPOTECNOLOGIA
   AND TT.DSTIPOTECNOLOGIA = 'VOIP'
   AND LT.IDLINHATELEFONICA = :idLinhaTelefonica ;
   
   if ( count > 0 )
      retorno = true;

   tuxfw_getlogger()->information( "<<< IsVoip()" );

   return retorno;
}

bool IsCombo4P( char * idLinhaTelefonicaPrm )
{

	tuxfw_getlogger()->information( ">>> IsCombo4P()" );
	bool retorno = false;	
	EXEC SQL BEGIN DECLARE SECTION;	
		char * idLinhaTelefonica = idLinhaTelefonicaPrm;
        int count = 0;		
	EXEC SQL END DECLARE SECTION;
	
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL WHENEVER NOTFOUND CONTINUE;
	
	tuxfw_getlogger()->information("*** idLinhaTelefonica [%s]", idLinhaTelefonica );
	
	EXEC SQL 
	   SELECT COUNT(LT.IDLINHATELEFONICA) 
	     INTO :count
		 FROM LINHA.LINHATELEFONICA LT
            , APOIO.SUBTIPOLINHA STL
        WHERE LT.IDSUBTIPOLINHA = STL.IDSUBTIPOLINHA
          AND STL.CDSUBTIPOLINHA = 'PROMOCAO 4P'
          AND LT.IDLINHATELEFONICA = :idLinhaTelefonica ;
	
	if ( count > 0 )
      retorno = true;
	
	tuxfw_getlogger()->information( "<<< IsCombo4P() [%d]", retorno);
	
	return retorno;

} 

void CodigoSubSegmentoCliente(struct stStatuslinha *stLinha, struct stVlStatuslinha *stVlLinha)
{
	tuxfw_getlogger()->information("Codigo do Subsegmento");

	if (stVlLinha->i_dblIdcliente != 0) {
		//tuxfw_getlogger()->information("idpessoa do cliente nao encontrado");
		return;
	}

   EXEC SQL BEGIN DECLARE SECTION;
	VARCHAR cdCodigoSubSegmentoCliente[256];
	short i_cdCodigoSubSegmentoCliente = -1;

	double dblIdcliente = stLinha->dblIdcliente;
   EXEC SQL END DECLARE SECTION;

   memset( &cdCodigoSubSegmentoCliente, 0, sizeof( cdCodigoSubSegmentoCliente ) );

   EXEC SQL WHENEVER SQLERROR DO sql_error(stLinha, ERR_DATABASE);

	// Obtem codigo do subsegmento
   EXEC SQL
   SELECT S.SGSUBSEGMENTO
   INTO :cdCodigoSubSegmentoCliente:i_cdCodigoSubSegmentoCliente
   FROM CUSTOMER.PESSOASUBSEGMENTO PS
   	   ,APOIO.SUBSEGMENTO S
   WHERE PS.IDPESSOA = :dblIdcliente
   AND PS.IDSUBSEGMENTO = S.IDSUBSEGMENTO;

   stVlLinha->i_cdCodigoSubSegmentoCliente = i_cdCodigoSubSegmentoCliente;

	if (i_cdCodigoSubSegmentoCliente == 0) {
		cdCodigoSubSegmentoCliente.arr[cdCodigoSubSegmentoCliente.len]= 0;
		strncpy(stLinha->cdCodigoSubSegmentoCliente, (char*)cdCodigoSubSegmentoCliente.arr, cdCodigoSubSegmentoCliente.len);

		//tuxfw_getlogger()->information("Codigo do Subsegmento do Cliente Encontrado");
	}
}


void CodigoSubSegmentoGestor(struct stStatuslinha *stLinha, struct stVlStatuslinha *stVlLinha)
{
	tuxfw_getlogger()->information("Codigo do Subsegmento do Gestor");

    EXEC SQL BEGIN DECLARE SECTION;
	VARCHAR cdCodigoSubSegmentoGestor[256];
	short i_cdCodigoSubSegmentoGestor = -1;

	int idClusterLinhaGestor = 0;
	short i_idClusterLinhaGestor = -1;

	char* orachrTelefone = stLinha->chrTelefone;
    EXEC SQL END DECLARE SECTION;


    EXEC SQL
	SELECT
		SUBSEGMENTO.SGSUBSEGMENTO,
		PESSOAGESTOR.IDCLUSTERLINHAGESTOR
	INTO
		:cdCodigoSubSegmentoGestor:i_cdCodigoSubSegmentoGestor,
		:idClusterLinhaGestor:i_idClusterLinhaGestor
	FROM
	   CUSTOMER.PESSOAGESTOR PESSOAGESTOR,
	   CUSTOMER.PESSOAGESTORMASTER PESSOAGESTORMASTER,
	   APOIO.SUBSEGMENTO SUBSEGMENTO
	WHERE
	   PESSOAGESTORMASTER.NRDOCUMENTOGESTOR = PESSOAGESTOR.NRDOCUMENTO
	AND
	   ( PESSOAGESTOR.NRTELEFONECELULARVIVO = TO_NUMBER(:orachrTelefone)
	     OR
	     PESSOAGESTOR.NRTELEFONEFIXO = TO_NUMBER(:orachrTelefone)
	     OR
	     PESSOAGESTOR.NRTELEFONECELULAROUTRO = TO_NUMBER(:orachrTelefone)
	   )
	AND
	   PESSOAGESTOR.IDSUBSEGMENTOGESTOR = SUBSEGMENTO.IDSUBSEGMENTO
	AND
	   ROWNUM <= 1;


    if (i_cdCodigoSubSegmentoGestor != 0)
    {
    	i_cdCodigoSubSegmentoGestor = -1;
    	i_idClusterLinhaGestor = -1;

        EXEC SQL
    	SELECT
    		SUBSEGMENTO.SGSUBSEGMENTO,
    		PESSOAGESTOR.IDCLUSTERLINHAGESTOR
    	INTO
    		:cdCodigoSubSegmentoGestor:i_cdCodigoSubSegmentoGestor,
    		:idClusterLinhaGestor:i_idClusterLinhaGestor
    	FROM
    	   CUSTOMER.PESSOAGESTOR PESSOAGESTOR,
    	   CUSTOMER.PESSOAGESTORCONTA PESSOAGESTORCONTA,
    	   APOIO.SUBSEGMENTO SUBSEGMENTO
    	WHERE
    	   PESSOAGESTORCONTA.NRDOCUMENTO = PESSOAGESTOR.NRDOCUMENTO
    	AND
    	   ( PESSOAGESTOR.NRTELEFONECELULARVIVO = TO_NUMBER(:orachrTelefone)
    	     OR
    	     PESSOAGESTOR.NRTELEFONEFIXO = TO_NUMBER(:orachrTelefone)
    	     OR
    	     PESSOAGESTOR.NRTELEFONECELULAROUTRO = TO_NUMBER(:orachrTelefone)
    	   )
    	AND
    	   PESSOAGESTORCONTA.IDTIPORELACIONAMENTO = 5
    	AND
    	   PESSOAGESTOR.IDSUBSEGMENTOGESTOR = SUBSEGMENTO.IDSUBSEGMENTO
    	AND
    	   ROWNUM <= 1;
    }

	stLinha->idClusterLinhaGestor = idClusterLinhaGestor;
	stVlLinha->i_idClusterLinhaGestor = i_idClusterLinhaGestor;

	stVlLinha->i_cdCodigoSubSegmentoGestor = i_cdCodigoSubSegmentoGestor;

	if (i_cdCodigoSubSegmentoGestor == 0) {
		strncpy(stLinha->cdCodigoSubSegmentoGestor, (char*)cdCodigoSubSegmentoGestor.arr, cdCodigoSubSegmentoGestor.len);
	}
}



void CodigoTecnologia( char * idLinhaTelefonicaPrm, char * idTipoTecnologiaPrm )
{
   tuxfw_getlogger()->information( ">>> CodigoTecnologia()" );
   

   EXEC SQL BEGIN DECLARE SECTION;
      char * idLinhaTelefonica = idLinhaTelefonicaPrm;
      VARCHAR idTipoTecnologia[256];
      short i_idTipoTecnologia = -1;
   EXEC SQL END DECLARE SECTION;

   memset( &idTipoTecnologia, 0x0, sizeof(idTipoTecnologia) );

   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL WHENEVER NOTFOUND CONTINUE;
   
   tuxfw_getlogger()->information("*** idLinhaTelefonica [%s]", idLinhaTelefonica );

   EXEC SQL 
   SELECT
      TT.CDTIPOTECNOLOGIA as cdTipoTecnologia
   INTO
      :idTipoTecnologia:i_idTipoTecnologia
   FROM
      LINHA.LINHATELEFONICA   LT ,
      APOIO.TIPOTECNOLOGIA    TT
   WHERE
      LT.IDTIPOTECNOLOGIA = TT.IDTIPOTECNOLOGIA(+)
   AND LT.IDLINHATELEFONICA = :idLinhaTelefonica ;

   CONVIND( idTipoTecnologia, i_idTipoTecnologia );
   
   sprintf( idTipoTecnologiaPrm, "%s", (char*)idTipoTecnologia.arr );
   tuxfw_getlogger()->information("*** cdTipoTecnologia [%s]", idTipoTecnologiaPrm );

   tuxfw_getlogger()->information( "<<< CodigoTecnologia()" );

}



void CodigoSistOrigem( char * idLinhaTelefonicaPrm, char * idSistOrigemPrm )
{
   tuxfw_getlogger()->information( ">>> CodigoSistOrigem()" );
   

   EXEC SQL BEGIN DECLARE SECTION;
      char * idLinhaTelefonica = idLinhaTelefonicaPrm;
      int idSistOrigem;
      int count = 0;
   EXEC SQL END DECLARE SECTION;

   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL WHENEVER NOTFOUND CONTINUE;
   
   tuxfw_getlogger()->information("*** idLinhaTelefonica [%s]", idLinhaTelefonica );

   EXEC SQL 
   SELECT
      LT.IDSISTEMAORIGEM
   INTO
      :idSistOrigem
   FROM
      LINHA.LINHATELEFONICA   LT 
   WHERE
      LT.IDLINHATELEFONICA = :idLinhaTelefonica ;

   sprintf( idSistOrigemPrm, "%d", idSistOrigem );
   

   tuxfw_getlogger()->information( "<<< CodigoSistOrigem()" );

}
