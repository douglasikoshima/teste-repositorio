// CSenha.cpp: implementation of the CSenha class.
//
//////////////////////////////////////////////////////////////////////
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "CSenha.h"
#include "../../../negocio/commons/include/vectorlist.h"
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSenha::CSenha()
{


}

CSenha::~CSenha()
{

}

int CSenha::execute(char*linha,char*ddd)
{
	tuxfw_getlogger()->debug("CSenha::execute()");
	int iupdateSenha = 0;
	int iHistoricoSenha = 0;
	// validar dados de entrada
	if(linha == NULL || strcmp(linha,"") == 0)
		return -1;
	if(ddd == NULL || strcmp(ddd,"") == 0)
		return -2;

	strcpy(m_linha,linha);
	strcpy(m_ddd,ddd);

	if(!verificaLinha())
	{
		return -9;
	}

	// executar operações
	iupdateSenha = updateSenha();

	if(iupdateSenha < 0)
	{
		return iupdateSenha;
	}

	return 1;
}


int CSenha::updateSenha()
{
	tuxfw_getlogger()->debug("CSenha::updateSenha()");
	struct sqlca sqlca;
	int retorno = 1;

	EXEC SQL BEGIN DECLARE SECTION;
		char *linhaAux = m_linha;
		char *dddAux = m_ddd;
		struct stPessoa{
			VARCHAR idPessoaLinha[21+1];
			VARCHAR idPessoaDePara[21+1];
			VARCHAR idTipoRelacionamento[21+1];
			VARCHAR idPessoa[21+1];
		}mstPessoa;
		struct stPessoaInd{			
			short idPessoaLinha;
			short idPessoaDePara;
			short idTipoRelacionamento;
			short idPessoa;
		}mstPessoaInd;
	EXEC SQL END DECLARE SECTION;

	sqlca.sqlcode=0;	

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND do break;

	EXEC SQL DECLARE CursorPessoa CURSOR FOR
		SELECT 
			PESSOALINHA.IDPESSOALINHA,
			PESSOALINHA.IDPESSOADEPARA,
			PESSOALINHA.IDTIPORELACIONAMENTO,
			PESSOADEPARA.IDPESSOA
		FROM
			LINHA.LINHABASE LINHABASE ,
			APOIO.AREAREGISTRO AREAREGISTRO,
			LINHA.LINHATELEFONICA LINHATELEFONICA,
			CUSTOMER.PESSOALINHA PESSOALINHA,
			CUSTOMER.PESSOADEPARA PESSOADEPARA
		WHERE
			LINHABASE.NRLINHA = TO_NUMBER(:linhaAux) AND
			 AREAREGISTRO.IDAREAREGISTRO = LINHABASE.IDAREAREGISTRO AND
			 AREAREGISTRO.CDAREAREGISTRO = TO_NUMBER(:dddAux) AND
			 LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE AND
			 PESSOALINHA.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA AND
			 PESSOADEPARA.IDPESSOADEPARA = PESSOALINHA.IDPESSOADEPARA;
	EXEC SQL OPEN CursorPessoa;

	for(;;)
	{
		memset(&mstPessoa,0,sizeof(mstPessoa));
		EXEC SQL FETCH CursorPessoa INTO :mstPessoa:mstPessoaInd;
		stPessoaLinha *aux = new stPessoaLinha;
		strcpy(aux->idPessoa,(char*)mstPessoa.idPessoa.arr);
		strcpy(aux->idPessoaLinha,(char*)mstPessoa.idPessoaLinha.arr);
		strcpy(aux->idPessoaDePara,(char*)mstPessoa.idPessoaDePara.arr);
		strcpy(aux->idTipoRelacionamento,(char*)mstPessoa.idTipoRelacionamento.arr);
		m_lista.add(aux);
		retorno = this->AtualizaSenha(aux);
	}
	EXEC SQL CLOSE CursorPessoa;

	if(retorno == -10)
	{
		tuxfw_getlogger()->debug("retorno igual a -10");
		for(int i=0;i<m_lista.sizeOf();i++)
		{
			tuxfw_getlogger()->debug("Bloquear a senha");
			stPessoaLinha *aux = (stPessoaLinha*)m_lista.get(i);
			if(this->bloquearSenha(aux) > 0)
			{
				this->insertHistoricoSenha(aux);
				retorno = -10;
			}
		}
	}
	else
		tuxfw_getlogger()->debug("retorno diferente de -10");

	return retorno;
Error:
	tuxfw_getlogger()->debug("\nCSenha::updateSenha() sqlca.sqlcode = %d",sqlca.sqlcode);
	if( sqlca.sqlcode == -1 )
		return -1;
	else 
	if(sqlca.sqlcode == 1403)
		return -9;
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSenha::AtualizaSenha(stPessoaLinha*aux)
{
	tuxfw_getlogger()->debug("CSenha::updateSenha()");
	struct sqlca sqlca;
	int dataHoje = 0; // Data de HOJE em formato inteiro YYYYMMDD
	char cdataHoje[9];
	this->formatDate(cdataHoje);
	dataHoje = atoi(cdataHoje);
	int retcode = 1;

	EXEC SQL BEGIN DECLARE SECTION;
		int qtTentativaErro = 0;
		int dataBloqueio = 0;
		int dataUltimaAtualizacao = 0;
		int statusSenha = 0;
		char *idpessoa = 0;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND GOTO Error;
	
	// No caso de ser usuário
	if(strcmp(aux->idTipoRelacionamento,"1") == 0)
	{
		idpessoa = aux->idPessoaLinha;
		EXEC SQL
		SELECT
			DECODE(QTTENTATIVAERRO,'',0,QTTENTATIVAERRO) AS QTTENTATIVAERRO,
			DECODE(DTBLOQUEIO,'',0,TO_CHAR(DTBLOQUEIO,'YYYYMMDD')) AS DTBLOQUEIO,
			DECODE(DTULTIMAATUALIZACAO,'',0,TO_CHAR(DTULTIMAATUALIZACAO,'YYYYMMDD')) AS DTULTIMAATUALIZACAO,
			IDTIPOSTATUSSENHA
		INTO 
			:qtTentativaErro,
			:dataBloqueio,
			:dataUltimaAtualizacao,
			:statusSenha
		FROM
			CUSTOMER.SENHA 
		WHERE
			IDPESSOALINHA = :idpessoa;	
					
		// Zerar o contator de tentativas caso o dia for maior que o 
		// da última atualização.			
		if(dataHoje > dataUltimaAtualizacao)			
			qtTentativaErro = 0;
		
		//	Se a senha estiver desbloqueada, processar
		//	a quantidade de tentativas.
		//
		//	(1) Caso a qtde de tentativas seja menor que 3, atualizar a qtde
		//		de tentativas incrementando o valor.
		//  (2) Caso a qtde de tentativa for 3, bloquear a senha do usuário. 
		//
		if(statusSenha == 2)
			retcode= -10;
		else
		{
			qtTentativaErro++;
			if(qtTentativaErro >= 3){
				retcode = -10;
			}else{
				EXEC SQL
				UPDATE CUSTOMER.SENHA 
				SET
					QTTENTATIVAERRO = :qtTentativaErro,
					DTULTIMAATUALIZACAO = SYSDATE,
					IDUSUARIOALTERACAO=0,
					DTULTIMAALTERACAO=SYSDATE
				WHERE
					IDPESSOALINHA = :idpessoa;
			}
		}

	} // No caso de ser cliente
	else
	if(strcmp(aux->idTipoRelacionamento,"2") == 0)
	{
		idpessoa = aux->idPessoa;
		EXEC SQL
		SELECT
			DECODE(QTTENTATIVAERRO,'',0,QTTENTATIVAERRO) AS QTTENTATIVAERRO,
			DECODE(DTBLOQUEIO,'',0,TO_CHAR(DTBLOQUEIO,'YYYYMMDD')) AS DTBLOQUEIO,
			DECODE(DTULTIMAATUALIZACAO,'',0,TO_CHAR(DTULTIMAATUALIZACAO,'YYYYMMDD')) AS DTULTIMAATUALIZACAO,
			IDTIPOSTATUSSENHA
		INTO 
			:qtTentativaErro,
			:dataBloqueio,
			:dataUltimaAtualizacao,
			:statusSenha
		FROM
			CUSTOMER.SENHA 
		WHERE
			IDPESSOA = :idpessoa;	
		
			
		if(dataHoje > dataUltimaAtualizacao){							
			qtTentativaErro = 0;
		}
		
		if(statusSenha == 2)
			retcode= -10;
		else
		{
			qtTentativaErro++;
			if(qtTentativaErro >= 3){
				retcode = -10;
			}else{					
				EXEC SQL
				UPDATE CUSTOMER.SENHA 
				SET
					QTTENTATIVAERRO = :qtTentativaErro,
					DTULTIMAATUALIZACAO = SYSDATE,
					IDUSUARIOALTERACAO=0,
					DTULTIMAALTERACAO=SYSDATE
				WHERE
					IDPESSOA = :idpessoa;
			}
		}			
	}
	return retcode;
Error:
	tuxfw_getlogger()->debug("\nCSenha::atualizaSenha() sqlca.sqlcode = %d",sqlca.sqlcode);
	if( sqlca.sqlcode == -1 )
		return -1;
	else 
	if(sqlca.sqlcode == 1403)
		return -11;
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSenha::bloquearSenha(stPessoaLinha*pessoa)
{
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char *idpessoa = 0;
		VARCHAR idsenha[21+1];
		VARCHAR cdsenha[255+1];
	EXEC SQL END DECLARE SECTION;

	sqlca.sqlcode=0;
	memset(&idsenha,0,sizeof(idsenha));
	memset(&cdsenha,0,sizeof(cdsenha));

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	// No caso de ser usuário
	if(strcmp(pessoa->idTipoRelacionamento,"1") == 0)
	{
		idpessoa = pessoa->idPessoaLinha;
		EXEC SQL
		UPDATE CUSTOMER.SENHA 
		SET
			QTTENTATIVAERRO = 3,
			IDTIPOSTATUSSENHA =2,
			DTULTIMAATUALIZACAO = SYSDATE,
			DTBLOQUEIO=SYSDATE,
			INTROCASENHA=1,
			IDUSUARIOALTERACAO=0,
			DTULTIMAALTERACAO=SYSDATE
		WHERE
			IDPESSOALINHA = :idpessoa;

		EXEC SQL
			SELECT
				NVL(IDSENHA,'') AS IDSENHA,
				NVL(CDSENHA,'') AS CDSENHA
			INTO 
				:idsenha,
				:cdsenha
			FROM
				CUSTOMER.SENHA 
			WHERE
				IDPESSOALINHA = :idpessoa;
		
		if(sqlca.sqlcode >= 0)
		{
			strcpy(pessoa->idSenha,(char*)idsenha.arr);
			strcpy(pessoa->cdSenha,(char*)cdsenha.arr);
		}

	} // No caso de ser cliente
	else
	if(strcmp(pessoa->idTipoRelacionamento,"2") == 0)
	{
		idpessoa = pessoa->idPessoa;
		EXEC SQL
		UPDATE CUSTOMER.SENHA 
		SET
			QTTENTATIVAERRO = 3,
			IDTIPOSTATUSSENHA =2,
			DTULTIMAATUALIZACAO = SYSDATE,
			DTBLOQUEIO=SYSDATE,
			INTROCASENHA=1,
			IDUSUARIOALTERACAO=0,
			DTULTIMAALTERACAO=SYSDATE
		WHERE
			IDPESSOA = :idpessoa;

		EXEC SQL
			SELECT
				NVL(IDSENHA,'') AS IDSENHA,
				NVL(CDSENHA,'') AS CDSENHA
			INTO 
				:idsenha,
				:cdsenha
			FROM
				CUSTOMER.SENHA 
			WHERE
				IDPESSOA = :idpessoa;
		
		if(sqlca.sqlcode >= 0)
		{
			strcpy(pessoa->idSenha,(char*)idsenha.arr);
			strcpy(pessoa->cdSenha,(char*)cdsenha.arr);
		}
	}
	return 1;
Error:
	tuxfw_getlogger()->debug("\nbloquearSenha() sqlca.sqlcode = %d, idsenha = %s",sqlca.sqlcode,pessoa->idSenha);
	if( sqlca.sqlcode == -1 )
		return -1;
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CSenha::insertHistoricoSenha(stPessoaLinha*pessoa)
{
	
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char *idSenha = pessoa->idSenha;
		char *cdSenha = pessoa->cdSenha;
	EXEC SQL END DECLARE SECTION;

	if(idSenha == NULL || strcmp(idSenha,"")==0)
	{
		return 0;
	}

	sqlca.sqlcode=0;

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;	

	EXEC SQL
	INSERT INTO CUSTOMER.HISTORICOSENHA 
	(
		CDSENHA,
		DTEXPIRACAO,
		IDTIPOSENHA,
		IDTIPOSTATUSSENHA,
		IDTIPOHISTORICOSENHA,
		DTREGISTROHISTORICO,
		OBSREGISTRO,
		NMREPRESENTANTE,
		IDCANAL,
		IDPESSOAUSUARIO,
		IDTIPOSISTEMA,
		IDSENHA,
		IDHISTORICOSENHA,
		IDUSUARIOALTERACAO,
		DTULTIMAALTERACAO
	)
	VALUES
	(
		:cdSenha,
		SYSDATE,
		1,
		2,
		8,
		SYSDATE,
		'',
		'URA',
		9,
		0,
		2,
		:idSenha,
		CUSTOMER.HISTORICOSENHASQ.NEXTVAL,
		1,
		SYSDATE
	);
	
	return 1;
Error:
	tuxfw_getlogger()->debug("\nuinsertHistoricoSenha() sqlca.sqlcode = %d, idsenha = %s",sqlca.sqlcode,pessoa->idSenha);
	if( sqlca.sqlcode == -1 )
		return -1;
	throw TuxBasicOraException(sqlca.sqlcode);
}

bool CSenha::verificaLinha()
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		char *linhaAux = m_linha;
		char *dddAux = m_ddd;
		int count;
	EXEC SQL END DECLARE SECTION;

	sqlca.sqlcode=0;

	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
		SELECT 
			count(*)
		INTO 
			:count
		FROM
			LINHA.LINHABASE LINHABASE ,
			APOIO.AREAREGISTRO AREAREGISTRO
		WHERE
			LINHABASE.NRLINHA = TO_NUMBER(:linhaAux) AND
			 AREAREGISTRO.IDAREAREGISTRO = LINHABASE.IDAREAREGISTRO AND
			 AREAREGISTRO.CDAREAREGISTRO = TO_NUMBER(:dddAux);

	if(count == 0)
	{
		return false;
	}

	return true;
Error:
	tuxfw_getlogger()->debug("\nverificaLinha() sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);
}

void CSenha::formatDate(char*cdata)
{
	time_t ltime;
	struct tm *data = NULL;
    time( &ltime );
	data = localtime ( &ltime );

	int mes = data->tm_mon;
	int ano = data->tm_year;
	int dia = data->tm_mday;
	int hora = data->tm_hour;
	int minuto = data->tm_min;
	int segundo = data->tm_sec;
	char cano[4+1];
	char cmes[2+1];
	char cdia[2+1];
	char chora[2+1];
	char cminuto[2+1];
	char csegundo[2+1];

	if(mes+1 < 10)
		sprintf(cmes,"0%d",mes+1);
	else
		sprintf(cmes,"%d",mes+1);

	sprintf(cano,"%d",(ano+1900));

	if(dia < 10)
		sprintf(cdia,"0%d",dia);
	else
		sprintf(cdia,"%d",dia);

	if(hora < 10)
		sprintf(chora,"0%d",hora);
	else
		sprintf(chora,"%d",hora);

	if(minuto < 10)
		sprintf(cminuto,"0%d",minuto);
	else
		sprintf(cminuto,"%d",minuto);

	if(segundo < 10)
		sprintf(csegundo,"0%d",segundo);
	else
		sprintf(csegundo,"%d",segundo);

	try{
		sprintf(cdata,"%s%s%s",cano,cmes,cdia);
	}
	catch(...)
	{
		tuxfw_getlogger()->debug("tamanho de char* invalido");
	}
}