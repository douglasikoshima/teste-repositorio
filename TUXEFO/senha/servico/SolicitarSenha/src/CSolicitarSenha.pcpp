
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
#include "../include/CSolicitarSenha.h"
#include "../../SenhaBase/include/TString.h"

#include <tuxfw.h>


CSolicitarSenha::CSolicitarSenha() 
{
}


CSolicitarSenha::~CSolicitarSenha() 
{

}


void CSolicitarSenha::setSenhaGeradaCript(char* value) 
{
	strcpy (cSenhaCript, value);

}


/*
setSenhaGeradadaAuxiliar serve para ter mais uma senha, caso a linha tenha um cliente
diferente de usuário, e se a senha gerada para um for igual a outra, utilizaremos uma segunda
opção. Senha de usuario tem que ser diferente da senha de cliente.
*/

void CSolicitarSenha::setSenhaGeradaAuxiliarCript(char* value) 
{
	strcpy (cSenhaAuxiliarCript, value);

}

void CSolicitarSenha::setSenha(char* value) 
{
	strcpy (cSenhaGerada, value);

}

void CSolicitarSenha::setSenhaAuxiliar(char* value) 
{
	strcpy (cSenhaGeradaAuxiliar, value);

}


char* CSolicitarSenha::getSenha() 
{

	return cSenhaGerada;
}


char* CSolicitarSenha::getSenhaAuxiliar() 
{
	return cSenhaGeradaAuxiliar;
}

char* CSolicitarSenha::getSenhaGeradaCript() 
{

	return cSenhaCript;
}


char* CSolicitarSenha::getSenhaGeradaAuxiliarCript() 
{
	return cSenhaAuxiliarCript;
}




char* CSolicitarSenha::rtrim(char *pStr)
{
	int rInd;

	if (pStr == NULL)
			return NULL;

   rInd = strlen(pStr) - 1;
   while ( isspace(pStr[rInd]) && rInd >= 0){
      rInd--;
   }

   pStr[rInd + 1] = '\0';
   
   return pStr;
}

char* CSolicitarSenha::ltrim(char *pStr)
{
	int lInd = 0;

	if (pStr == NULL)
			return NULL;

    //rInd = strlen(pStr) - 1;

    while (isspace(pStr[lInd])){
        lInd++;
	}

	pStr = pStr + lInd;
     
   return pStr;
}

char* CSolicitarSenha::trim(char *pStr){
	return ltrim(rtrim(pStr));		
}

bool CSolicitarSenha::verificarSenhaGeradaInvalida(int iCdAreaRegistro, int iNrLinha, int iIdTipoRelacionamento, char* cSenha)
{
	ULOG_START("CSolicitarSenha::verificarSenhaInvalida()");
	//Verifica se o cliente e usuário são pessoas distintas e possuem senhas iguais.
	//true  - cliente e usuário iguais e senhas iguais. Senha inválida.
	//false - cliente e usuário distintos ou senhas distintas.
	struct sqlca sqlca;

        EXEC SQL BEGIN DECLARE SECTION;

		  int	iCdAreaRegistroSQL=0;
		  int	iNrLinhaSQL=0;		
		  int	iIdPessoaCliente=0;
		  int	iIdPessoaUsuario=0;
		  char	cCdSenhaCliente[256] = "";
		  char	cCdSenhaUsuario[256] = "";

        EXEC SQL END DECLARE SECTION;

	iCdAreaRegistroSQL = iCdAreaRegistro;
	iNrLinhaSQL = iNrLinha;

	char sCdSenhaCliente[256];
	char sCdSenhaUsuario[256];
		
	char sCdSenhaNova[256] = "";

	strcpy(sCdSenhaNova, cSenha);

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
        EXEC SQL WHENEVER SQLERROR  GOTO TuxOraException;

	//Busca a senha para o tipo de relacionamento necessário.
		EXEC SQL
			SELECT
				NVL(pdp.idPessoa, 0),
				NVL(s.cdSenha, ' ')
			INTO
				:iIdPessoaCliente,
				:cCdSenhaCliente
			FROM
				apoio.AreaRegistro 	     ar,
				linha.LinhaBase	   	  	 lb,
				linha.LinhaTelefonica 	 lt,
				customer.PessoaLinha		 pl,
				customer.PessoaDePara	 pdp,
				customer.Senha				 s
			WHERE
				ar.idAreaRegistro			 = lb.idAreaRegistro
			AND	lb.idLinhaBase				 = lt.idLinhaBase
			AND	lt.idLinhaTelefonica			 = pl.idLinhaTelefonica
			AND	pl.idPessoaDePara			 = pdp.idPessoaDePara
			AND	pdp.idPessoa				 = s.idPessoa
			AND	ar.cdAreaRegistro			 = :iCdAreaRegistroSQL
			AND	lb.nrLinha				 = :iNrLinhaSQL
			AND	pl.idTipoRelacionamento			 = 2;


		EXEC SQL
			SELECT
				NVL(pdp.idPessoa, 0),
				NVL(s.cdSenha, ' ')
			INTO
				:iIdPessoaUsuario,
				:cCdSenhaUsuario
			FROM
				apoio.AreaRegistro 	     ar,
				linha.LinhaBase	   	  	 lb,
				linha.LinhaTelefonica 	 lt,
				customer.PessoaLinha		 pl,
				customer.PessoaDePara	 pdp,
				customer.Senha				 s
			WHERE
				ar.idAreaRegistro			 = lb.idAreaRegistro
			AND	lb.idLinhaBase				 = lt.idLinhaBase
			AND lt.idLinhaTelefonica		 = pl.idLinhaTelefonica
			AND	pl.idPessoaDePara			 = pdp.idPessoaDePara
			AND pl.idPessoaLinha			 = s.idPessoaLinha
			AND	ar.cdAreaRegistro			 = :iCdAreaRegistroSQL
			AND	lb.nrLinha					 = :iNrLinhaSQL
			AND pl.idTipoRelacionamento		 = 1;

		//Atualiza a senha corrente que foi digitada, para fazer a comparação.
		if ( iIdTipoRelacionamento == 2 )
			strcpy(cCdSenhaCliente, sCdSenhaNova);

		else
			strcpy(cCdSenhaUsuario, sCdSenhaNova);

		strcpy(sCdSenhaCliente,trim(cCdSenhaCliente));
		strcpy(sCdSenhaUsuario, trim(cCdSenhaUsuario));
		
		ULOG_END("CSolicitarSenha::verificarSenhaInvalida()");

		//Caso Cliente e Usuário sejam distintos e senha iguais, retornar TRUE - senha inválida
		if ( iIdPessoaCliente != iIdPessoaUsuario)
		{
			if ( strcmp(sCdSenhaCliente, sCdSenhaUsuario) == 0)						
				return true;
			else		
				return false;
			
		}else			
			return false;
			

Erro:

  return false;

  TuxOraException:
			throw TuxBasicOraException( sqlca.sqlcode );
      

}


void CSolicitarSenha::gerarSenha(int iCdAreaRegistro, int iNrLinha, int iIdTipoRelacionamento)
{
    ULOG_START("CSolicitarSenha::gerarSenha()");
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
  
	int prefixo = 0;
	int numero  = 0;
	char cConv[3];
	char senhaOriginal[256];
	char cStringEntrada[256];
	long iIdLinhaBase = 0;
	char cDataAtual[12];
	char cSenha[35];
	char cSenhaGerada[5];
	char cSenhaGeradaCript[33];
	int idTipoRelacionamento = 0;
	int iIdPessoa = 0;
	int iIdLinhaTelefonica = 0;
    EXEC SQL END DECLARE SECTION;

    int i = 0;
    int j = 0;
    int k = 0;
   
   numero  = iNrLinha;
   prefixo = iCdAreaRegistro;
   idTipoRelacionamento = iIdTipoRelacionamento;

   memset(cStringEntrada, '\0', sizeof(cStringEntrada)); 
   memset(cDataAtual, '\0', sizeof(cDataAtual)); 
   memset(cSenha, '\0', sizeof(cSenha)); 
   memset(cSenhaGerada, '\0', sizeof(cSenhaGerada)); 
   memset(cSenhaGeradaCript, '\0', sizeof(cSenhaGeradaCript)); 

   EXEC SQL WHENEVER SQLERROR  GOTO TuxOraException; 
   EXEC SQL WHENEVER NOT FOUND GOTO TuxOraException;

   EXEC SQL
	SELECT
		LINHATELEFONICA.IDLINHATELEFONICA,
		LINHABASE.IDLINHABASE
	INTO
		:iIdLinhaTelefonica,
		:iIdLinhaBase
	FROM
		LINHA.LINHABASE LINHABASE,
		APOIO.AREAREGISTRO AREAREGISTRO,
		LINHA.LINHATELEFONICA LINHATELEFONICA
	WHERE
		LINHABASE.NRLINHA =  :numero  AND
		LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO AND
		AREAREGISTRO.CDAREAREGISTRO =  :prefixo AND
		LINHABASE.IDLINHABASE = LINHATELEFONICA.IDLINHABASE;

   EXEC SQL WHENEVER SQLERROR  GOTO TuxOraException; 
   EXEC SQL WHENEVER NOT FOUND CONTINUE;

   EXEC SQL

	SELECT
		PESSOADEPARA.IDPESSOA
	INTO
		:iIdPessoa		
	FROM		
		CUSTOMER.PESSOALINHA PESSOALINHA,
		CUSTOMER.PESSOADEPARA PESSOADEPARA
	WHERE
		PESSOALINHA.IDLINHATELEFONICA = :iIdLinhaTelefonica AND	
		PESSOALINHA.IDTIPORELACIONAMENTO = 1  AND
		PESSOALINHA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA AND
		PESSOALINHA.IDTIPORELACIONAMENTO = :idTipoRelacionamento;

   EXEC SQL
	SELECT TRUNC(SYSDATE) INTO :cDataAtual FROM DUAL;


   
   sprintf (cStringEntrada, "%d%d%s", iIdLinhaBase, iIdPessoa, cDataAtual); 
   

   for (k = 0; k < 2; k ++)
   {
	    EXEC SQL 
	    SELECT
		apoio.criptMD5(:cStringEntrada) INTO :cSenha from dual; 
	    
	   for ( i = 0; i < 32; i++)
	   {
		if (cSenha[i] >= '0' && cSenha[i] <= '9')
			cSenhaGerada[j++] = cSenha[i];

		if (j == 4)
			break;
	   }

	  memset(cSenha, '\0', sizeof(cSenha)); 

          j = 0;

	  
	  EXEC SQL 
	  SELECT
		apoio.criptMD5(:cSenhaGerada) into :cSenhaGeradaCript from dual; 

	 

	if (k == 0)
	{
		this->setSenhaGeradaCript(trim(cSenhaGeradaCript));
		this->setSenha(cSenhaGerada);

	}
	else
	{
		this->setSenhaGeradaAuxiliarCript(trim(cSenhaGeradaCript));
		this->setSenhaAuxiliar(cSenhaGerada);
	}

       strcat (cStringEntrada, cDataAtual); /*Pra gerar mais uma senha*/

   }

   
    ULOG_END("CSolicitarSenha::gerarSenha()");

    return;

 TuxOraException:
	throw TuxBasicOraException( sqlca.sqlcode );
     
}

void CSolicitarSenha::GravaSenhaSemUsuario(int iCdAreaRegistro, int iNrLinha, char* cSenhaGerada)
{

    ULOG_START("CSolicitarSenha::GravaSenhaSemUsuario()");
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
  
	int prefixo = 0;
	int numero  = 0;
	long iIdLinhaBase = 0;	
	int iIdPessoa = 0;
	char cSenha[256];
	int iIdLinhaTelefonica = 0;
	
    EXEC SQL END DECLARE SECTION;
   
   numero  = iNrLinha;
   prefixo = iCdAreaRegistro;
   memset(cSenha, '\0', sizeof(cSenha)); 

   strcpy(cSenha, cSenhaGerada);


   EXEC SQL WHENEVER SQLERROR  GOTO TuxOraException;
   EXEC SQL WHENEVER NOT FOUND CONTINUE;
   
   EXEC SQL
	SELECT
		LINHATELEFONICA.IDLINHATELEFONICA
	INTO
		:iIdLinhaTelefonica
	FROM
		LINHA.LINHABASE LINHABASE,
		APOIO.AREAREGISTRO AREAREGISTRO,
		LINHA.LINHATELEFONICA LINHATELEFONICA
	WHERE
		LINHABASE.NRLINHA  =  :numero  AND
		LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO AND
		AREAREGISTRO.CDAREAREGISTRO =  :prefixo AND
		LINHABASE.IDLINHABASE = LINHATELEFONICA.IDLINHABASE;
	
	if (iIdLinhaTelefonica)
	{
		EXEC SQL
		UPDATE 
			LINHA.LINHATELEFONICA
		SET
			CDSENHAPREATIVA = :cSenha
		WHERE
			idLinhaTelefonica = :iIdLinhaTelefonica;		

	}
	
	return;
	
 TuxOraException:
	throw TuxBasicOraException( sqlca.sqlcode );
    
}


int CSolicitarSenha::consultarLinhaExpirada(int iCdAreaRegistro, int iNrLinha)
{
  struct sqlca sqlca;
  EXEC SQL BEGIN DECLARE SECTION;

	int	iCdAreaRegistroSQL = 0;
	int	iNrLinhaSQL = 0;		
	int     iLinhaExpirada = 0;

   EXEC SQL END DECLARE SECTION;

	iCdAreaRegistroSQL = iCdAreaRegistro;
	iNrLinhaSQL = iNrLinha;
	
	EXEC SQL WHENEVER SQLERROR  GOTO TuxOraException;

	EXEC SQL
	SELECT
		COUNT(0)
	INTO
		:iLinhaExpirada
	FROM
		LINHA.LINHATELEFONICA LINHATELEFONICA,
		LINHA.LINHABASE LINHABASE,
		APOIO.AREAREGISTRO AREAREGISTRO
	WHERE
		LINHABASE.NRLINHA = :iNrLinhaSQL AND
		LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO AND
		AREAREGISTRO.CDAREAREGISTRO = :iCdAreaRegistroSQL AND
		LINHABASE.IDLINHABASE = LINHATELEFONICA.IDLINHABASE AND
		LINHATELEFONICA.DTEXPIRACAO IS NOT NULL AND
		TRUNC(LINHATELEFONICA.DTEXPIRACAO) < TRUNC(SYSDATE) - 30;

	return iLinhaExpirada;
	
 TuxOraException:
	throw TuxBasicOraException( sqlca.sqlcode );
    
}