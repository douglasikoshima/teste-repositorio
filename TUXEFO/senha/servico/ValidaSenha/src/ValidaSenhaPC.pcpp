/* $Id: ValidaSenhaPC.pcpp,v 1.1.2.15 2011/08/02 17:45:51 a5116174 Exp $ */

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
#include <ctype.h>

#include "../include/ValidaSenha.h"


#include <tuxfw.h>
#include "../../RegistraContato/include/stRegistraContato.h"

void sql_error_validasenha(sqlca*);

extern bool proCRegistraContatoAlteracao(int, stRegistraContato*);

int validaCliente(int idPessoa, char* senha, int idCanal, int idPessoaUsuario, int *idSenhaCli, long idPessoaLinha, int iIdTerminal);
int validaSenhaCliente(int idConta, int idPessoa, char* senha, int idCanal, int idPessoaUsuario, int *idSenhaCli, long idPessoaLinha, int iIdTerminal);
int registraValidacao(int tipoPessoa, int idSenha, int chave, int status, int idCanal, int idPessoaUsuario, long idPessoaLinha, long idPessoaLinhaCliente, int iIdTerminal);
void bloqueiaUsuario(int idCanal, int idPessoaUsuario, int iIdTerminal);
void bloqueiaCliente(int idPessoa, int idCanal, int idPessoaUsuario, long idPessoaLinha, int iIdTerminal);
void bloqueiaNiveisSuperiores( int idConta, int idCanal, int idPessoaUsuario, int _idSenha, int numIteracao, long idPessoaLinha, int iIdTerminal);
char* trim(char *pStr);


// Usado no bloqueio comandado pelo cliente.
long idUsuario = 0;

/**
* Valida a senha do telefone, buscando primeiro os níveis superioes.
*/

bool verificarSenhaExpirada(int idsenha)
{
    ULOG_START("consultarLinhaExpirada()");

    struct sqlca sqlca;
 
    EXEC SQL BEGIN DECLARE SECTION;
	int   iIdSenhaSQL = idsenha;
	char  cDtUltimaAtualizacao[30];
	int   iLinhaExpirada = 0;
	int   iDiasExpiracao = 0;
   EXEC SQL END DECLARE SECTION;

   
   EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);
   EXEC SQL WHENEVER NOT FOUND CONTINUE;

   EXEC SQL	
   SELECT 
	TO_NUMBER(dsvalorparametro)
   INTO
	:iDiasExpiracao
   FROM 
	apoio.parametro 
   WHERE 
	cdparametro = 'PRAZO_EXPIRACAO_SENHA_VOL';

   EXEC SQL
   SELECT
	COUNT(1) 
   INTO
	:iLinhaExpirada
   FROM
	customer.Senha 
   WHERE
	idSenha  = :iIdSenhaSQL AND 		
	DTULTIMAATUALIZACAO + :iDiasExpiracao <  SYSDATE;


   if (iLinhaExpirada == 0)
	return false;
   else
	return true;
	
 }

void validaSenha(char* telefone, char* senha, int* resultado, char* titularidade, int idCanal, int idPessoaUsuario, int iIdTerminal)
{
   ULOG_START("validaSenha()");

    struct sqlca sqlca;

    int prefixo = 0;
    int numero  = 0;
    char cConv[3];
    char senhaOriginal[256];

    int idSenhaCli = 0;

    strcpy(senhaOriginal, senha);

    if ( telefone[0]=='0' ) 
    {
        strncpy(cConv,telefone+1,2);cConv[2]=0;
        prefixo = atoi(cConv);
        numero  = atoi(telefone+3);
    }
    else
    {
        strncpy(cConv,telefone,2);cConv[2]=0;
        prefixo = atoi(cConv);
        numero  = atoi(telefone+2);
    }

    EXEC SQL BEGIN DECLARE SECTION;
        int   oprefixo         = prefixo;
        int   otelefone        = numero;
        char  osenha[256];

        long   idpessoalinha    = 0;
        short indidpessoalinha = 0;

        long   idpessoalinhacliente    = 0;
        short indidpessoalinhacliente = 0;

        char  senhabanco[256];
//      short indsenhabanco    = 0;
        int   statussenha      = 0;
        short indstatussenha   = 0;
        int   idpessoa         = 0;
        short indidpessoa      = 0;

        int   idsenha         = 0;
        short indidsenha      = 0;

        int   diaatual        = 0;

        int   diabloqueio     = 0;
        short inddiabloqueio  = 0;

        int   introcasenha    = 0;
        short indintrocasenha = 0;

    EXEC SQL END DECLARE SECTION;


    strcpy(osenha, senha);


    EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    ULOG( "Versao usando type LONG\n" );

    EXEC SQL 
        SELECT
            idPessoaLinha
        INTO
            :idpessoalinha:indidpessoalinha
        FROM
            CUSTOMER.TelefoneUsuarioV09
        WHERE
                cdAreaRegistro = :oprefixo
                AND nrLinha    = :otelefone
                AND idTipoRelacionamento = 1;

   ULOG("idpessoalinha = %ld\n",idpessoalinha);

    // Pessoa linha não encontrado.
    if (indidpessoalinha == -1 || idpessoalinha <= 0)
    {
        *resultado = -1;
        ULOG_END("validaSenha()");
        return;
    }

    idUsuario = idpessoalinha;

    EXEC SQL 
        SELECT
            idPessoa, idPessoaLinha
        INTO
            :idpessoa:indidpessoa,
            :idpessoalinhacliente:indidpessoalinhacliente
        FROM
            CUSTOMER.TelefoneUsuarioV09
        WHERE
                cdAreaRegistro = :oprefixo
                AND nrLinha    = :otelefone
                AND idTipoRelacionamento = 2;

    // Testa primeiro os níveis superiores para verificar se 
    // a senha é de um cliente.
    ULOG("Antes de recorrer os niveles superiores\n");
    int resNivelSup = validaCliente(idpessoa, osenha, idCanal, idPessoaUsuario, &idSenhaCli, idpessoalinhacliente, iIdTerminal);
    ULOG("Recorridos os niveles superiores y no encontrada senha: %d\n", resNivelSup);
    EXEC SQL
        SELECT
            NVL(cdSenha, ' '),
            idTipoStatusSenha,
            TO_CHAR(dtBloqueio,'DD') AS diaBloqueio,
            TO_CHAR(sysdate,'DD') AS diaAtual,
            idSenha,
            inTrocaSenha
        INTO
            :senhabanco,
            :statussenha:indstatussenha,
            :diabloqueio:inddiabloqueio,
            :diaatual,
            :idsenha:indidsenha,
            :introcasenha:indintrocasenha
        FROM
            customer.Senha
        WHERE
            idPessoaLinha = :idpessoalinha;

    if ((resNivelSup != -3) && (resNivelSup <= 0)) 
    {
        ULOG("Reuperando senha: %ld\n", idpessoalinha);
        if (inddiabloqueio == -1)
            diabloqueio = 0;

        if (sqlca.sqlcode == 0 ) //&& indsenhabanco != -1
        {
            
            if ( strcmp(trim(senhabanco), "") != 0 && strcmp(trim(senhabanco), senhaOriginal) == 0 && introcasenha == 0 )// Senha maior que 0 E senhabanco igual a senhaOriginal.
            {
                if ( indstatussenha != -1   && statussenha == 1 )
				{
                    int status = 1;
                                                 
                    if (indintrocasenha != -1 && introcasenha == 1)
                        status = 2;
                    *resultado = registraValidacao(1, idsenha, idpessoa, status, idCanal, idPessoaUsuario, idpessoalinha,  idpessoalinhacliente, iIdTerminal);
                }
                else
                    *resultado = registraValidacao(1, idsenha, idpessoa, -2, idCanal, idPessoaUsuario, idpessoalinha, idpessoalinhacliente, iIdTerminal);

            }
            else
            {
                if(resNivelSup == -2 && idSenhaCli > 0)
                {
                    *resultado = registraValidacao(1, idsenha, idpessoa, -2, idCanal, idPessoaUsuario, idpessoalinha, idpessoalinhacliente,  iIdTerminal);
                }
                else
                {
                    if(idsenha == 0 && indidsenha == -1)
                        *resultado = -100;
                    else if(introcasenha == 1)
                        *resultado = -101;
                    else
                        *resultado = registraValidacao(1, idsenha, idpessoa, -2, idCanal, idPessoaUsuario, idpessoalinha, idpessoalinhacliente, iIdTerminal);
                }
            }
        }
        else
        {           
            if(resNivelSup == -2 && idSenhaCli > 0)
                *resultado = registraValidacao(2, idSenhaCli, idpessoa, -2, idCanal, idPessoaUsuario, idpessoalinha, idpessoalinhacliente, iIdTerminal);
            else
                *resultado = resNivelSup;
        }

        
        strcpy( titularidade, "U" );
    }
    else
    {
        if (resNivelSup > 0) 
        {
            ULOG("Recuperando senha validada la del cliente: %ld\n", idpessoalinha);

            if (sqlca.sqlcode == 0) //&& indsenhabanco != -1
            {
                EXEC SQL
                UPDATE
                    customer.Senha
                SET
                    qtTentativaErro = null
                WHERE   
                    idSenha = :idsenha
                    AND idTipoStatusSenha = 1;
            }
        }
        strcpy( titularidade, "C" );
        *resultado = resNivelSup;
    }

    ULOG("idsenha e idsenhacli: %d %d\n", idsenha, idSenhaCli );

    if (!strcmp(titularidade, "C"))
	idsenha = idSenhaCli == 0 ? idsenha : idSenhaCli;

    if (*resultado > 0)   //senha válida
    {

	
	if( verificarSenhaExpirada(idsenha) == true)
		*resultado = -4;

    }


   ULOG_END("validaSenha()");
}


int validaCliente(int idPessoa, char* senha, int idCanal, int idPessoaUsuario, int *idSenhaCli, long idPessoaLinha, int iIdTerminal)
{
   ULOG_START("validaCliente()");
    int resultado = 0;

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        int oidpessoa = idPessoa;
        
        int   idconta    = 0;
        short indidconta = 0;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);

        // Declara o cursor a ser executado.
        EXEC SQL DECLARE clienteConta CURSOR FOR
        SELECT
            idConta
        FROM
            customer.UsuarioContaV11
        WHERE
            idPessoaOrigem = :oidpessoa;

        // Executa o cursor.
        EXEC SQL OPEN clienteConta;

        // Buscará os níveis superiores até encontar uma senha incompatível ou acabar o loop.
        while (resultado == 0) 
        {

					EXEC SQL FETCH clienteConta INTO :idconta:indidconta;

			ULOG("Recuperando Conta: %d\n", idconta);
			ULOG("Recuperando Conta: %d\n", indidconta);

			if (indidconta == -1 || idconta > 0)
			{
				resultado = validaSenhaCliente(idconta, idPessoa, senha, idCanal, idPessoaUsuario, idSenhaCli, idPessoaLinha, iIdTerminal);
			}
			else
			{
				if (idconta == 0)
					resultado = -2;
				else
					resultado = 0;
			}
			ULOG("Resultado: %d\n", resultado);
        }

        EXEC SQL CLOSE clienteConta;
        
   ULOG_END("validaCliente()");
    return resultado;
}

int validaSenhaCliente(int idConta, int idPessoa, char* senha, int idCanal, int idPessoaUsuario, int *idSenhaCli, long idPessoaLinha, int iIdTerminal)
{
   ULOG_START("validaSenhaCliente()");
    struct sqlca sqlca;

    int    resultado = 0;

    EXEC SQL BEGIN DECLARE SECTION;
        int   idcontapai      = 0;
        short indidcontapai   = 0;
        int   oidconta        = idConta;
        
        char  senhacliente[256];
        short indsenhacliente = 0;

        int   idpessoa        = 0;
        short indidpessoa     = 0;

        int   idtipostatus    = 0;
        short indidtipostatus = 0;

        int   idsenha         = 0;
        short indidsenha      = 0;

        int   diaatual        = 0;

        int   diabloqueio     = 0;
        short inddiabloqueio  = 0;

        int   introcasenha    = 0;
        short indintrocasenha = 0;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);

    EXEC SQL
        SELECT
            idContaPai
        INTO
            :idcontapai:indidcontapai
        FROM    
            customer.ContaHierarquia
        WHERE   
            idConta = :oidconta;


        ULOG("Recuperando Conta Cliente\n");

    if (indidcontapai != -1 && idcontapai > 0 && sqlca.sqlcode == 0)
        resultado = validaSenhaCliente(idcontapai, idPessoa, senha, idCanal, idPessoaUsuario, idSenhaCli, idPessoaLinha, iIdTerminal);
    
    if (resultado == 0) {

        ULOG("Tratando Resultado\n");
        EXEC SQL 
            SELECT
                senha,
                idPessoa,
                idTipoStatusSenha,
                TO_CHAR(dtBloqueio,'DD') AS diaBloqueio,
                TO_CHAR(sysdate,'DD') AS diaAtual,
                idSenha,
                inTrocaSenha
            INTO
                :senhacliente:indsenhacliente,
                :idpessoa:indidpessoa,
                :idtipostatus:indidtipostatus,
                :diabloqueio:inddiabloqueio,
                :diaatual,
                :idsenha:indidsenha,
                :introcasenha:indintrocasenha
            FROM
                customer.ContaSenhaClienteV06
            WHERE
                idConta = :oidconta;

            if (inddiabloqueio == -1)
                diabloqueio = 0;

            if (indsenhacliente != -1 && senhacliente > 0 && strcmp(trim(senhacliente), senha)==0 && introcasenha == 0)
            {
                int status = 1;
                if (  indidtipostatus != -1  && idtipostatus == 1 ) 
                {
                                                 
                    if (indintrocasenha != -1 && introcasenha == 1)
                        status = 2;
                        
                    resultado = registraValidacao(2, idsenha, idpessoa, status, idCanal, idPessoaUsuario, idPessoaLinha, idPessoaLinha, iIdTerminal);
                }
                else
                {
                    status = 3;
                    resultado = registraValidacao(2, idsenha, idpessoa, status, idCanal, idPessoaUsuario, idPessoaLinha, idPessoaLinha, iIdTerminal);
                }

            }
            else
            {
                if(idsenha == 0 && indidsenha == -1)
                    resultado = -100;
                else if(introcasenha == 1)
                    resultado = -101;
                else
                {
                    *idSenhaCli = idsenha;
                    resultado = -2;
                }
            }
    }
    
    ULOG_END("validaSenhaCliente()");
    

    if (resultado == 1)
     *idSenhaCli = idsenha;

    return resultado;
}


/**
* Executa os processos registro de histórico da validação.
*/
int registraValidacao(int tipoPessoa, int idSenha, int chave, int status, int idCanal, int idPessoaUsuario, long idPessoaLinha, long idPessoaLinhaCliente, int iIdTerminal)
{
   ULOG_START("registraValidacao()");
   ULOG("Valores de entrada tipoPessoa[%d], idSenha[%d], chave[%d], status[%d], idCanal[%d], idPessoaUsuario[%d], idPessoaLinha[%d], idPessoaLinhaCliente[%d], iIdTerminal[%d]", tipoPessoa, idSenha, chave, status, idCanal, idPessoaUsuario, idPessoaLinha, idPessoaLinhaCliente, iIdTerminal);   
   
    struct stRegistraContato m_stDados;

    memset(&m_stDados,0,sizeof(m_stDados));

    struct sqlca sqlca;

    int resultado = status;

    ULOG("registraValidacao resultado(1) = %d",resultado);

    m_stDados.idCanal              = idCanal;
    m_stDados.idPessoaUsuario      = idPessoaUsuario;
    m_stDados.idSenha              = idSenha;
    m_stDados.idTipoHistoricoSenha = 2;
    m_stDados.idTipoSistema        = 1;
    m_stDados.idTipoSenha          = 1;
    m_stDados.idTipoStatusSenha    = 1;
    m_stDados.idPessoaLinha        = idPessoaLinha;
    m_stDados.iIdTerminal          = iIdTerminal;

    EXEC SQL BEGIN DECLARE SECTION;

        int   idsenha            = idSenha;

        int   idpessoasenha      = chave;

        int   diaultimoacesso    = 0;
        short inddiaultimoacesso = 0;

        int   nrtentativas       = 0;
        short indnrtentativas    = 0;

        int   idstatussenha      = 0;
        short indstatussenha     = 0;

        char  dtUltimosAcesso[11]="";
        char  dtHoje[11]="";

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);

    ULOG("Tratando Validacao: %d para status: %d\n", idsenha, status);
    // Bem Sucedido
    if (status == 1)    
    {

        // Verifica se o usuário ja acessou o sistema uma vez.
        EXEC SQL
            SELECT
                TO_CHAR(dtPrimeiroAcesso,'DD')
            INTO
                :diaultimoacesso:inddiaultimoacesso
            FROM
                customer.Senha
            WHERE   
                idSenha = :idsenha;

        // Caso não tenha acessado ainda indica o dia do primeiro
        // acesso.
        if (inddiaultimoacesso == -1 || diaultimoacesso <= 0)
        {
            EXEC SQL 
                UPDATE 
                    customer.Senha
                SET
                    dtPrimeiroAcesso = SYSDATE
                WHERE
                idSenha = :idsenha;
        }

        EXEC SQL
            UPDATE
                customer.Senha
            SET
                dtUltimoAcesso = SYSDATE,
                dtBloqueio     = null,
                qtTentativaErro= null,
                idTipoStatusSenha = 1
            WHERE   
                idSenha = :idsenha;
            
        if (tipoPessoa == 1)
        {   
            EXEC SQL
            UPDATE
                customer.Senha
            SET
                qtTentativaErro= null
            WHERE   
                idPessoa = :idpessoasenha
                AND idTipoStatusSenha = 1;
        }
    }
    else if (status == -2)
    {
            
        EXEC SQL
            SELECT
                idTipoStatusSenha,
                qtTentativaErro,
                NVL(TO_CHAR(dtUltimoAcesso, 'dd/mm/yyyy'), ' '),
                TO_CHAR(sysdate, 'dd/mm/yyyy')
            INTO
                :idstatussenha:indstatussenha,
                :nrtentativas:indnrtentativas,
                :dtUltimosAcesso,
                :dtHoje
            FROM
                customer.Senha
            WHERE
                idSenha = :idsenha;

        if (indstatussenha != -1 && idstatussenha == 1)
        {
            //Caso o número de tentativas incorretas seja <= 2 E a última validação não tenha sido hoje, então reinicia a qtTentativaErro.
            if (nrtentativas <= 2 && strcmp(dtUltimosAcesso, dtHoje) != 0)
                nrtentativas = 0;

            if (indnrtentativas != -1 && nrtentativas < 5)
            {

                if (++nrtentativas == 5)
                {
                    EXEC SQL
                        UPDATE
                            customer.Senha
                        SET
                            idTipoStatusSenha = 2,
                            dtBloqueio = SYSDATE,
                            qtTentativaErro = :nrtentativas,
                            dtUltimoAcesso = sysdate
                        WHERE
                            idSenha = :idsenha;

                        if (tipoPessoa == 1)
                        {   
                            EXEC SQL
                            UPDATE
                                customer.Senha
                            SET
                                idTipoStatusSenha = 2,
                                dtBloqueio = SYSDATE,
                                qtTentativaErro = :nrtentativas,
                                dtUltimoAcesso = sysdate
                            WHERE   
                                idPessoa = :idpessoasenha;
                        }

                    // Resultado -3 indica o bloqueio da conta.

					if (m_stDados.idCanal == 9)
						resultado = -2;
					else
						resultado = -3;

                    m_stDados.idTipoHistoricoSenha = 8;
                    m_stDados.idTipoStatusSenha    = 2;
                    
                    bloqueiaCliente( chave, idCanal, idPessoaUsuario, idPessoaLinhaCliente, iIdTerminal);

                } 
                else
                {
                    EXEC SQL
                        UPDATE
                            customer.Senha
                        SET
                            qtTentativaErro = :nrtentativas,
                            dtUltimoAcesso = sysdate
                        WHERE
                        idSenha = :idsenha;

                    if (tipoPessoa == 1)
                    {   
                        EXEC SQL
                        UPDATE
                            customer.Senha
                        SET
                            qtTentativaErro = :nrtentativas,
                            dtUltimoAcesso = sysdate
                        WHERE   
                            idPessoa = :idpessoasenha
                            AND idTipoStatusSenha = 1;
                    }

                    m_stDados.idTipoHistoricoSenha = 10;

                }
            }
            else if (indnrtentativas == -1)
            {
                    EXEC SQL
                        UPDATE
                            customer.Senha
                        SET
                            qtTentativaErro = 1,
                            dtUltimoAcesso = sysdate
                        WHERE
                        idSenha = :idsenha;

                    if (tipoPessoa == 1)
                    {   
                        EXEC SQL
                        UPDATE
                            customer.Senha
                        SET
                            qtTentativaErro = 1,
                            dtUltimoAcesso = sysdate
                        WHERE   
                            idPessoa = :idpessoasenha
                            AND idTipoStatusSenha = 1;
                    }

                    m_stDados.idTipoHistoricoSenha = 10;
            }
        }
        else if (idstatussenha == 2)
            resultado = -3;
    }
    else if (status == 3)
    {
        resultado = -3;
    }
    proCRegistraContatoAlteracao(idSenha, &m_stDados);              
    
    ULOG("registraValidacao resultado = %d",resultado);

    ULOG_END("registraValidacao()");
    
    return resultado;
}

void bloqueiaUsuario(int idCanal, int idPessoaUsuario, int iIdTerminal) 
{
   ULOG_START("bloqueiaUsuario()");
   
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        unsigned int idpessoalinha = idUsuario;

        int   idsenha       = 0;
        short indidsenha    = 0;

    EXEC SQL END DECLARE SECTION;

    ULOG ("Bloquea: idPessoaLinha: %d\n", idpessoalinha);
        
    EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);

    EXEC SQL 
        SELECT 
            idSenha 
        INTO    
            :idsenha:indidsenha
        FROM 
            customer.Senha 
        WHERE 
            idPessoaLinha = :idpessoalinha;

    if (sqlca.sqlcode == 0 && indidsenha != -1 && idsenha > 0) {

        EXEC SQL
            UPDATE
                customer.Senha
            SET
                idTipoStatusSenha = 2,
                dtBloqueio = SYSDATE
            WHERE
                idPessoaLinha = :idpessoalinha;
            
        struct stRegistraContato m_stDados;

        memset(&m_stDados,0,sizeof(m_stDados));

        m_stDados.idCanal              = idCanal;
        m_stDados.idPessoaUsuario      = idPessoaUsuario;
        m_stDados.idTipoHistoricoSenha = 8;
        m_stDados.idTipoSistema        = 1;
        m_stDados.idTipoSenha          = 1;
        m_stDados.idTipoStatusSenha    = 1;
        m_stDados.iIdTerminal		   = iIdTerminal;

		ULOG ("bloqueiaUsuario %d\n", iIdTerminal);

        proCRegistraContatoAlteracao(idsenha, &m_stDados);              

    }

   ULOG_END("bloqueiaUsuario()");
}


void bloqueiaNiveisSuperiores( int idConta, int idCanal, int idPessoaUsuario, int _idSenha, int numIteracao, long idPessoaLinha, int iIdTerminal )
{
   ULOG_START("bloqueiaNiveisSuperiores()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int   oidconta      = idConta;
        
        int   idcontapai    = 0;
        short indidcontapai = 0;

        int   idsenha       = 0;
        short indidsenha    = 0;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);


    ULOG ("Bloquea: idConta: %d\n", oidconta);
    EXEC SQL
        SELECT
            idContaPai
        INTO
            :idcontapai:indidcontapai
        FROM    
            customer.ContaHierarquia
        WHERE   
            idConta = :oidconta;


    if (indidcontapai != -1 && idcontapai > 0 && sqlca.sqlcode == 0)
        bloqueiaNiveisSuperiores(idcontapai, idCanal, idPessoaUsuario, _idSenha, 1, idPessoaLinha, iIdTerminal);

    EXEC SQL
        SELECT
            idSenha
        INTO
            :idsenha:indidsenha
        FROM
            customer.ContaSenhaClienteV06
        WHERE
            idConta = :oidconta;

    if (sqlca.sqlcode == 0 && indidsenha != -1 && idsenha > 0 && (idsenha != _idSenha || numIteracao == 0))
    {
    ULOG ("Bloquea: idSenha: %d\n", idsenha);
        EXEC SQL
            UPDATE
                customer.Senha
            SET
                idTipoStatusSenha = 2,
                dtBloqueio = SYSDATE
            WHERE
                idSenha = :idsenha;
            
            struct stRegistraContato m_stDados;

            memset(&m_stDados,0,sizeof(m_stDados));

            m_stDados.idCanal              = idCanal;
            m_stDados.idPessoaUsuario      = idPessoaUsuario;
            m_stDados.idTipoHistoricoSenha = 8;
            m_stDados.idTipoSistema        = 1;
            m_stDados.idTipoSenha          = 1;
            m_stDados.idTipoStatusSenha    = 1;
            m_stDados.idPessoaLinha        = idPessoaLinha;
			m_stDados.iIdTerminal		   = iIdTerminal;

			ULOG ("bloqueiaNiveisSuperiores %d\n", iIdTerminal);

            proCRegistraContatoAlteracao(idsenha, &m_stDados);              
    }
    
    ULOG_END("bloqueiaNiveisSuperiores()");
}

int verificarQuatidadeTentativa(char* telefone, char* senha)
{
   
   ULOG_START("verificarQuatidadeTentativa()");
    struct sqlca sqlca;

    int prefixo = 0;
    int numero  = 0;
    char cConv[3];

    char senhaOriginal[256];
        
    strcpy(senhaOriginal, senha);

    if ( telefone[0]=='0' ) 
    {
        strncpy(cConv,telefone+1,2);cConv[2]=0;
        prefixo = atoi(cConv);
        numero  = atoi(telefone+3);
    }
    else
    {
        strncpy(cConv,telefone,2);cConv[2]=0;
        prefixo = atoi(cConv);
        numero  = atoi(telefone+2);
    }


    EXEC SQL BEGIN DECLARE SECTION;
        int   oprefixo         = prefixo;
        int   otelefone        = numero;
        char  osenha[256];

        long   idpessoalinha    = 0;
        short indidpessoalinha = 0;
        //char  senhabanco[256];
        //short indsenhabanco    = 0;

        int   idpessoa         = 0;

        int   qtTentativaErroC = 0;
        int   qtTentativaErroU = 0;


    EXEC SQL END DECLARE SECTION;


    strcpy(osenha, senha);


    EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);


    //Identifica idPessoaLinha para Usuario
    EXEC SQL 
        SELECT
            idPessoaLinha
        INTO
            :idpessoalinha:indidpessoalinha
        FROM
            CUSTOMER.TelefoneUsuarioV09
        WHERE
            cdAreaRegistro       = :oprefixo
        AND nrLinha              = :otelefone
        AND idTipoRelacionamento = 1;

    // Pessoa linha não encontrado.
    if (indidpessoalinha == -1 || idpessoalinha <= 0)
    {
       ULOG_END("verificarQuatidadeTentativa()");
        return 0;
    }

    //Identifica idPessoa para Cliente
    EXEC SQL 
        SELECT
            idPessoa
        INTO
            :idpessoa
        FROM
            CUSTOMER.TelefoneUsuarioV09
        WHERE
                cdAreaRegistro = :oprefixo
                AND nrLinha    = :otelefone
                AND idTipoRelacionamento = 2;

    //Busca a Senha do Cliente
    EXEC SQL
        SELECT
            //cdSenha,
            NVL(qtTentativaErro, 0)
        INTO
            //:senhabanco, //:indsenhabanco
            :qtTentativaErroC
        FROM
            CUSTOMER.Senha
        WHERE
            idPessoa = :idpessoa;

    //Busca a Senha do Usuario
    EXEC SQL
        SELECT
            //cdSenha,
            NVL(qtTentativaErro,0)
        INTO
            //:senhabanco, //:indsenhabanco
            :qtTentativaErroU
        FROM
            CUSTOMER.Senha
        WHERE
            idPessoaLinha = :idpessoalinha;
   ULOG_END("verificarQuatidadeTentativa()");
    if(qtTentativaErroC)
        return qtTentativaErroC;
    else
        return qtTentativaErroU;

}

void bloqueiaCliente(int idPessoa, int idCanal, int idPessoaUsuario, long idPessoaLinha, int iIdTerminal)
{
   ULOG_START("bloqueiaCliente()");
   
    struct sqlca sqlca;

    int numIteracao = 0;
    EXEC SQL BEGIN DECLARE SECTION;
        int oidpessoa = idPessoa;

        int idSenha;
        short i_idSenha = -1;

        int   idconta    = 0;
        short indidconta = 0;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);

        EXEC SQL
        SELECT
            idSenha
        INTO
            :idSenha:i_idSenha
        FROM
            customer.Senha
        WHERE
            idPessoa = :oidpessoa;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    ULOG ("Bloquea: idPessoa: %d\n", oidpessoa);
    // Declara o cursor a ser executado.
        EXEC SQL DECLARE clienteSenha CURSOR FOR
        SELECT
            idConta
        FROM
            customer.UsuarioContaV11
        WHERE
            idPessoaOrigem = :oidpessoa;

        // Executa o cursor.
        EXEC SQL OPEN clienteSenha;

        // Buscará os níveis superiores até encontar uma senha incompatível ou acabar o loop.
        while (true) 
        {

                EXEC SQL FETCH clienteSenha INTO :idconta:indidconta;

            ULOG("Recuperando Conta: %d\n", idconta);
            ULOG("Recuperando Conta: %d\n", indidconta);

            if (indidconta == -1 || idconta > 0)
            {
                bloqueiaNiveisSuperiores(idconta, idCanal, idPessoaUsuario, idSenha, numIteracao , idPessoaLinha, iIdTerminal);
                numIteracao++;
            }
        }

        EXEC SQL CLOSE clienteSenha;
    ULOG_END("bloqueiaCliente()");
}



void sql_error_validasenha(sqlca*sqlca)
{
    throw TuxBasicOraException(sqlca->sqlcode);
}




char* rtrim(char *pStr)
{
    int rInd;

    if (pStr == NULL)
            return NULL;

    rInd = strlen(pStr) - 1;
    while ( isspace(pStr[rInd]) && rInd >= 0)
    {
      rInd--;
    }

    pStr[rInd + 1] = '\0';
   
    return pStr;
}

char* ltrim(char *pStr)
{
    int lInd = 0;

    if (pStr == NULL)
            return NULL;

    //rInd = strlen(pStr) - 1;

    while (isspace(pStr[lInd])){
        lInd++;
    }

    pStr = pStr + lInd;
     
    return pStr;
}

char* trim(char *pStr){
    return ltrim(rtrim(pStr));      
}

int consultarTipoPessoaDB(int intNrLinha, int intCdAreaRegistro, int intTipoRelacionamento)
{
   
    ULOG_START("consultarTipoPessoaDB()");
   
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
    int iTipoRelacionamento;
    int iCdAreaRegistro;
    int iNrLinha;
    int idTipoPessoa;
    EXEC SQL END DECLARE SECTION;

    idTipoPessoa = -1;
    iCdAreaRegistro = intCdAreaRegistro;
    iNrLinha = intNrLinha;
    iTipoRelacionamento = intTipoRelacionamento;


    EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

    EXEC SQL WHENEVER SQLERROR GOTO OraException;
     
    EXEC SQL 
       SELECT
         TipoPessoa.IDTIPOPESSOA
	INTO 
		:idTipoPessoa
	FROM
		linha.LinhaTelefonica       LinhaTelefonica,
		linha.LinhaBase		    LinhaBase,
	        apoio.EstadoLinha        EstadoLinha,
		customer.pessoalinha        PessoaLinha,
	        customer.pessoadepara       PessoaDePara,
		customer.pessoa             Pessoa,
	        apoio.tipopessoa            TipoPessoa,
		apoio.areaRegistro	    AreaRegistro
    WHERE
	    LinhaBase.IDESTADOLINHA = EstadoLinha.idEstadoLinha
	AND LinhaBase.idareaRegistro = AreaRegistro.idAreaRegistro
        AND AreaRegistro.cdAreaRegistro = :iCdAreaRegistro
        AND LinhaBase.nrLinha = :iNrLinha
	AND LinhaBase.IDLINHABASE = LinhaTelefonica.IDLINHABASE
        AND LinhaTelefonica.IDLINHATELEFONICA = PessoaLinha.IDLINHATELEFONICA
        AND PessoaDePara.IDPESSOADEPARA = PessoaLinha.IDPESSOADEPARA
        AND PessoaDePara.IDPESSOA = Pessoa.IDPESSOA
        AND Pessoa.IDTIPOPESSOA = TipoPessoa.idtipopessoa
        AND PessoaLinha.IDTIPORELACIONAMENTO = :iTipoRelacionamento;
        
    ULOG_END("consultarTipoPessoaDB()");
   
    return idTipoPessoa;

    OraNoDataFound:
    OraException:   
        throw TuxBasicOraException(sqlca.sqlcode);  

}


int consultarTipoLinhaDB(int intNrLinha, int intCdAreaRegistro) 
{
    ULOG_START("consultarTipoLinhaDB()");
   
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
    int  iCdAreaRegistro;
    int  iNrLinha;
    int  iIdTipoLinha;
    EXEC SQL END DECLARE SECTION;
    
    iCdAreaRegistro = intCdAreaRegistro;
    iNrLinha = intNrLinha;
    iIdTipoLinha = -1;

    // Marca ponto de controle de erro
    EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

    EXEC SQL WHENEVER SQLERROR GOTO OraException;
     
    EXEC SQL
    SELECT
        LinhaTelefonica.idTipoLinha
    INTO
        :iIdTipoLinha
    FROM
        linha.LinhaTelefonica		LinhaTelefonica,
	linha.LinhaBase			LinhaBase,
        apoio.EstadoLinha		EstadoLinha,
	apoio.AreaRegistro	 	AreaRegistro
     WHERE
        LinhaBase.idEstadoLinha		= EstadoLinha.idEstadoLinha
    AND LinhaBase.idareaRegistro	= AreaRegistro.idAreaRegistro 
    AND AreaRegistro.cdAreaRegistro	= :iCdAreaRegistro
    AND LinhaBase.nrLinha		= :iNrLinha
    AND LinhaBase.idLinhaBase		= LinhaTelefonica.idLinhaBase;

    ULOG_END("consultarTipoLinhaDB()");
   
    return iIdTipoLinha;
    
    
    OraNoDataFound:
    OraException:
        throw TuxBasicOraException(sqlca.sqlcode);  

}

void validarSenhaSemUsuarioDB(char* telefone, char* senha, int* resultado)
{
   ULOG_START("validarSenhaSemUsuario()");

    struct sqlca sqlca;

    int prefixo = 0;
    int numero  = 0;  
    char cConv[3];
   
    if ( telefone[0]=='0' ) 
    {
        strncpy(cConv,telefone+1,2);cConv[2]=0;
        prefixo = atoi(cConv);
        numero  = atoi(telefone+3);
    }
    else
    {
        strncpy(cConv,telefone,2);cConv[2]=0;
        prefixo = atoi(cConv);
        numero  = atoi(telefone+2);
    }

    EXEC SQL BEGIN DECLARE SECTION;
        int   oprefixo         = prefixo;
        int   otelefone        = numero;
	char cSenhaPreAtiva[256] = "";
        int iIdLinhaTelefonica = 0;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL 
        SELECT
		NVL(CDSENHAPREATIVA,' '), idLinhaTelefonica
        INTO
		:cSenhaPreAtiva, :iIdLinhaTelefonica
        FROM
		LINHA.LINHABASE LINHABASE,
		LINHA.LINHATELEFONICA LINHATELEFONICA,
		APOIO.AREAREGISTRO AREAREGISTRO
	WHERE
		LINHABASE.NRLINHA = :otelefone AND
		LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO AND
		AREAREGISTRO.CDAREAREGISTRO = :oprefixo AND
		LINHABASE.IDLINHABASE = LINHATELEFONICA.IDLINHABASE;

	ULOG ("iIdLinhaTelefonica =  %d\n", iIdLinhaTelefonica);

	if (iIdLinhaTelefonica == 0)
		*resultado = ERR_LINHA_NAO_ENCONTRADA;

	else if (strcmp(trim(cSenhaPreAtiva), "")  == 0) //Não existe senha cadastrada
		*resultado = ERR_SENHA_NAO_CADASTRADA;

	else if (strcmp(trim(cSenhaPreAtiva), senha) == 0)
		*resultado = SENHA_ENCONTRADA; //Senha encontrada

	else
		*resultado = ERR_SENHA_INVALIDA;

    }

int recuperarInfCadastro(string & strNumTelefone, string & strDDD, ValidaSenhaC &vS)
{

   ULOG_START("recuperarInfCadastro()");
   ULOG("Valores de entrada strNumTelefone[%s], strDDD[%s]", (char*)strNumTelefone.c_str(), (char*)strDDD.c_str());   

    struct sqlca sqlca;
    int prefixo = atoi(strDDD.c_str()); 
    int numero  = atoi(strNumTelefone.c_str());



    EXEC SQL BEGIN DECLARE SECTION;
        int   oprefixo         = prefixo;
        int   otelefone        = numero;
		int   oSenhaAtiva;
        char cPrimeiroNome[256] = "";
		char cTipoLinha[256] = "";
		char cNomeCliente[256] = "";
		char cEmail[256] = "";
		char cSexo[256] = "";
		char cDTNascimento[256] = "";
		
		
		short i_oSenhaAtiva = -1;
        short i_cPrimeiroNome = -1;
		short i_cTipoLinha = -1;
		short i_cNomeCliente = -1;
		short i_cEmail = -1;
		short i_cSexo = -1;
		short i_cDTNascimento = -1;
	EXEC SQL END DECLARE SECTION;	
	EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
	memset(cPrimeiroNome,0,sizeof(cPrimeiroNome));
	memset(cTipoLinha,0,sizeof(cTipoLinha));
	memset(cNomeCliente,0,sizeof(cNomeCliente));
	memset(cEmail,0,sizeof(cEmail));
	memset(cSexo,0,sizeof(cSexo));
	memset(cDTNascimento,0,sizeof(cDTNascimento));
	oSenhaAtiva = 0;
	
	EXEC SQL
		SELECT 
			COUNT(1) 
		INTO 
			:oSenhaAtiva:i_oSenhaAtiva
		FROM 
			CUSTOMER.SENHA S,
			LINHA.LINHABASE LB,
			LINHA.LINHATELEFONICA LT,
			APOIO.AREAREGISTRO AR,
			CUSTOMER.PESSOADEPARA PDP,
			CUSTOMER.PESSOALINHA PL
		WHERE
			(PDP.IDPESSOA = S.IDPESSOA OR S.IDPESSOALINHA = PL.IDPESSOALINHA) AND
			PL.IDPESSOADEPARA = PDP.IDPESSOADEPARA AND
			PL.IDLINHATELEFONICA = LT.IDLINHATELEFONICA AND
			LT.IDLINHABASE = LB.IDLINHABASE AND
			LB.NRLINHA = :otelefone AND
			LB.IDAREAREGISTRO = AR.IDAREAREGISTRO AND
			AR.CDAREAREGISTRO = :oprefixo AND
			S.IDTIPOSTATUSSENHA = 1;
			
			
	ULOG("oSenhaAtiva[%d]", oSenhaAtiva);  
	
	if( oSenhaAtiva <= 0 ) 
	{
		return -1;
	}
	
    EXEC SQL 
		SELECT 
			   NMNOME,IDTIPOLINHA,NMPESSOA,DSSEXO,DTNASCIMENTO
		  INTO  
				:cPrimeiroNome:i_cPrimeiroNome,
				:cTipoLinha:i_cTipoLinha, 
				:cNomeCliente:i_cNomeCliente,
				:cSexo:i_cSexo,
				:cDTNascimento:i_cDTNascimento
		FROM 
		(
		  SELECT
			P.NMNOME,
			TO_CHAR(LT.IDTIPOLINHA) AS IDTIPOLINHA,
			P.NMPESSOA,
			SEX.DSSEXO AS DSSEXO,
			NVL(TO_CHAR(PF.DTNASCIMENTO,'DDMMYYYY'), ' ') AS DTNASCIMENTO
		  FROM
			LINHA.LINHABASE LB,
			LINHA.LINHATELEFONICA LT,
			APOIO.AREAREGISTRO AR,
			CUSTOMER.PESSOADEPARA PDP,
			CUSTOMER.PESSOALINHA PL,
			CUSTOMER.PESSOA P,
			CUSTOMER.PESSOAFISICA PF, 
			APOIO.SEXO SEX
		  WHERE
				LB.NRLINHA = :otelefone AND
				LB.IDAREAREGISTRO = AR.IDAREAREGISTRO AND
				AR.CDAREAREGISTRO = :oprefixo AND
				LB.IDLINHABASE = LT.IDLINHABASE AND
			PL.IDLINHATELEFONICA = LT.IDLINHATELEFONICA AND
			PL.IDPESSOADEPARA = PDP.IDPESSOADEPARA AND
			P.IDPESSOA = PDP.IDPESSOA AND
			P.IDTIPOPESSOA = 1 AND
			PF.IDPESSOA = P.IDPESSOA AND 
			PF.IDSEXO = SEX.IDSEXO
		)
		WHERE ROWNUM < 2;
		
		
		vS.m_strPrimeiroNome = cPrimeiroNome;
		vS.m_iTipoLinha = cTipoLinha;
		vS.m_strNome = cNomeCliente;
		vS.m_strSexo = cSexo;
		vS.m_strDtNascimento = cDTNascimento;
		
		
	   EXEC SQL
		SELECT 
			   DSCONTATO
		  INTO  
				:cEmail:i_cEmail
		FROM 
		(
		  SELECT
			--PC.DSCONTATO, -- EMAIL
			 NVL(PC.DSCONTATO, ' ')  AS DSCONTATO
		  FROM
			LINHA.LINHABASE LB,
			LINHA.LINHATELEFONICA LT,
			APOIO.AREAREGISTRO AR,
			CUSTOMER.PESSOADEPARA PDP,
			CUSTOMER.PESSOALINHA PL,
			CUSTOMER.PESSOA P,
			CUSTOMER.PESSOACOMUNICACAO PC,
			APOIO.TIPOCOMUNICACAO TPC

		  WHERE
			LB.NRLINHA = :otelefone AND
			LB.IDAREAREGISTRO = AR.IDAREAREGISTRO AND
			AR.CDAREAREGISTRO = :oprefixo AND
			LB.IDLINHABASE = LT.IDLINHABASE AND
			PL.IDLINHATELEFONICA = LT.IDLINHATELEFONICA AND
			PL.IDPESSOADEPARA = PDP.IDPESSOADEPARA AND
			P.IDPESSOA = PDP.IDPESSOA AND
			PC.IDPESSOA = P.IDPESSOA AND 
			PC.IDTIPOCOMUNICACAO = TPC.IDTIPOCOMUNICACAO AND 
			TPC.IDFORMARETORNO = 2 AND
			P.IDTIPOPESSOA = 1 
		ORDER BY
			PC.DTULTIMAALTERACAO DESC
		)
		WHERE ROWNUM < 2;

		
		vS.m_strEmail = cEmail;

		
		/*
	ULOG ("iIdLinhaTelefonica =  %d\n", iIdLinhaTelefonica);
	if (iIdLinhaTelefonica == 0)
		return ERR_LINHA_NAO_ENCONTRADA;

	else if (strcmp(trim(cSenhaPreAtiva), "")  == 0) //Não existe senha cadastrada
		return ERR_SENHA_NAO_CADASTRADA;

	else if (strcmp(trim(cSenhaPreAtiva), senha) == 0)
		return  SENHA_ENCONTRADA; //Senha encontrada

	else
		return  ERR_SENHA_INVALIDA;
		
		*/
		
		
	
		
		return 0;

}