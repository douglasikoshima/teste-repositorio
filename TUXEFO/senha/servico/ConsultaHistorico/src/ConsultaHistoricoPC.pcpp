/* $Id: ConsultaHistoricoPC.pcpp,v 1.1 2009/07/31 15:34:23 a5110702 Exp $ */

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#define CONV(O) \
{\
	##O.arr[##O.len]=0; \
}

#include <tuxfw.h>

void sql_error_consultahistorico(sqlca*sqlca);
void registraRetorno(char* telefone, char* dsTipoHistoricoSenha, char* nmCanal, char* dtRegistro, char* nmUsuario, char* obsRegistro, char* nmNome, XMLGen* xml_g);

bool proCConsultaHistoricoUsuario(int idPessoa, char* nrTelefone, XMLGen*xml_g)
{

   ULOG_START("proCConsultaHistoricoUsuario()");
   
	struct sqlca sqlca;

	int prefixo = 0;
	int numero  = 0;
	char cConv[3];

	if ( nrTelefone[0]=='0' ) 
	{
		strncpy(cConv,nrTelefone+1,2);cConv[2]=0;
		prefixo = atoi(cConv);
		numero  = atoi(nrTelefone+3);
	}
	else
	{
		strncpy(cConv,nrTelefone,2);cConv[2]=0;
		prefixo = atoi(cConv);
		numero  = atoi(nrTelefone+2);
	}



    EXEC SQL BEGIN DECLARE SECTION;

		VARCHAR telefone[18];
		VARCHAR dsTipoHistoricoSenha[256];
		VARCHAR nmCanal[256];
		VARCHAR dtRegistro[21];
		VARCHAR nmLoginUsuario[256];
		VARCHAR obsRegistro[256];
		VARCHAR nmNome[256];

		short i_telefone;
		short i_dsTipoHistoricoSenha;
		short i_nmCanal;
		short i_dtRegistro;
		short i_nmLoginUsuario;
		short i_obsRegistro;
		short i_nmNome;
		short i_idpessoa;

		int idpessoa;
		int oprefixo = prefixo;
		int onumero  = numero;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_consultahistorico(&sqlca);

    ULOG("Procedemos a ejecutar la query de obter linha para pessoa ......");
    EXEC SQL 
        SELECT
            idPessoaLinha
        INTO
            :idpessoa:i_idpessoa
        FROM
            customer.TelefoneUsuarioV09
        WHERE
                cdAreaRegistro = :oprefixo
                AND nrLinha    = :onumero
		AND idTipoRelacionamento = 1;
    	
    	if (i_idpessoa != -1)
    	{

		EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
    		ULOG("Procedemos a declarar la query de Historico do Usuario ......");
		EXEC SQL DECLARE historicoSenhaUsuario CURSOR FOR
		SELECT
			telefone, 
			dsTipoHistoricoSenha, 
			nmCanal, 
			dtRegistro, 
			nmLoginUsuario,
			obsRegistro,
			nmNome
		FROM(			
			SELECT
				telefone, 
				dsTipoHistoricoSenha, 
				nmCanal, 
				dtRegistro, 
				nmLoginUsuario,
				obsRegistro,
				nmNome
			FROM
				customer.ConsultaHistoricoSenhaV04
			WHERE
				    idPessoaLinha = :idpessoa
			ORDER BY
				dtRegistroHistorico DESC			
			)
		WHERE
			ROWNUM <= 500;
	
    		ULOG("Procedemos a ejecutar la query de Historico do Usuario ......");
		EXEC SQL OPEN historicoSenhaUsuario;
	
		while (true)
		{
	    		ULOG("Recorremos el cursor de la query de Historico do Usuario ......");
			EXEC SQL FETCH 
				historicoSenhaUsuario 
			INTO 
				:telefone:i_telefone,
				:dsTipoHistoricoSenha:i_dsTipoHistoricoSenha,
				:nmCanal:i_nmCanal,
				:dtRegistro:i_dtRegistro,
				:nmLoginUsuario:i_nmLoginUsuario,
				:obsRegistro:i_obsRegistro,
				:nmNome:i_nmNome;
	
	    		ULOG("Convertimos los valores recuperados ......");
			CONV(telefone);
			CONV(dsTipoHistoricoSenha);
			CONV(nmCanal);
			CONV(dtRegistro);
			CONV(nmLoginUsuario);
			CONV(obsRegistro);
			CONV(nmNome);
	
    			ULOG("Registramos el retorno ......");
			registraRetorno(
							(char*)telefone.arr, 
							(char*)dsTipoHistoricoSenha.arr, 
							(char*)nmCanal.arr, 
							(char*)dtRegistro.arr, 
							(char*)nmLoginUsuario.arr, 
							(char*)obsRegistro.arr, 
							(char*)nmNome.arr, 
							xml_g
						   );
		}
	
		EXEC SQL CLOSE historicoSenhaUsuario;
	}
	
	ULOG_END("proCConsultaHistoricoUsuario()");
	
	return true;
}

bool proCConsultaHistoricoCliente(int idPessoa, XMLGen*xml_g)
{
   ULOG_START("proCConsultaHistoricoCliente()");

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

      VARCHAR dsTipoHistoricoSenha[256];
      VARCHAR nmCanal[256];
      VARCHAR dtRegistro[21];
      VARCHAR nmLoginUsuario[256];
      VARCHAR obsRegistro[256];
      VARCHAR nmNome[256];
      
      short i_dsTipoHistoricoSenha;
      short i_nmCanal;
      short i_dtRegistro;
      short i_nmLoginUsuario;
      short i_obsRegistro;
      short i_nmNome;
      
      int idpessoa = idPessoa;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_consultahistorico(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

    	ULOG("Procedemos a declarar la query de Historico do Cliente ......");
	EXEC SQL DECLARE historicoSenhaCliente CURSOR FOR

	SELECT		
		dsTipoHistoricoSenha, 
		nmCanal, 
		dtRegistro, 
		nmLoginUsuario,
		obsRegistro,
		nmNome
	FROM(
		SELECT
			dsTipoHistoricoSenha, 
			nmCanal, 
			dtRegistro, 
			nmLoginUsuario,
			obsRegistro,
			nmNome
		FROM
			customer.ConsultaHistoricoSenhaV04
		WHERE
			idPessoa = :idpessoa
		ORDER BY
			dtRegistroHistorico DESC
	)
	WHERE
		ROWNUM <= 500;

    	ULOG("Procedemos a ejecutar la query de Historico do Cliente ......");
	EXEC SQL OPEN historicoSenhaCliente;

   while (true)
   {
   	EXEC SQL FETCH 
   		historicoSenhaCliente 
   	INTO 
   		:dsTipoHistoricoSenha:i_dsTipoHistoricoSenha,
   		:nmCanal:i_nmCanal,
   		:dtRegistro:i_dtRegistro,
   		:nmLoginUsuario:i_nmLoginUsuario,
   		:obsRegistro:i_obsRegistro,
   		:nmNome:i_nmNome;
      
         	ULOG("Convertimos los valores recuperados ......");
   	CONV(dsTipoHistoricoSenha);
   	CONV(nmCanal);
   	CONV(dtRegistro);
   	CONV(nmLoginUsuario);
   	CONV(obsRegistro);
   	CONV(nmNome);
      
      ULOG("Registramos el retorno ......");
   	registraRetorno(
   					(char *)" ", 
   					(char*)dsTipoHistoricoSenha.arr, 
   					(char*)nmCanal.arr, 
   					(char*)dtRegistro.arr, 
   					(char*)nmLoginUsuario.arr, 
   					(char*)obsRegistro.arr, 
   					(char*)nmNome.arr, 
   					xml_g
   				   );
   }
   
   EXEC SQL CLOSE historicoSenhaCliente;
   
   ULOG_END("proCConsultaHistoricoCliente()");
   
   return true;
}


bool proCConsultaNomePessoa(int idPessoa, char* tag, XMLGen*xml_g)
{

   ULOG_START("proCConsultaNomePessoa()");
   
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

		VARCHAR nmPessoa[256];

		short i_nmPessoa;

		int idpessoa = idPessoa;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_consultahistorico(&sqlca);
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL DECLARE consultaNomePessoa CURSOR FOR
		SELECT
			nmPessoa
		FROM
			customer.Pessoa
		WHERE
			idPessoa = :idpessoa;

	EXEC SQL OPEN consultaNomePessoa;

	while (true)
	{
		EXEC SQL FETCH 
			consultaNomePessoa 
		INTO 
			:nmPessoa:i_nmPessoa;

		CONV(nmPessoa);

		xml_g->addItem(tag, (char*)nmPessoa.arr);

	}

	EXEC SQL CLOSE consultaNomePessoa;
	
	ULOG_END("proCConsultaNomePessoa()");

	return true;
}

void registraRetorno(char* telefone, char* dsTipoHistoricoSenha, char* nmCanal, char* dtRegistro,char* nmLoginUsuario, char* obsRegistro, char* nmNome, XMLGen* xml_g) 
{

	xml_g->createTag("SenhaMovimentoVO");
		xml_g->addItem("telefone", telefone);
		xml_g->addItem("tipoMovimento", dsTipoHistoricoSenha);
		xml_g->addItem("canalOrigem", nmCanal);
		xml_g->addItem("data", dtRegistro);
		xml_g->addItem("login", nmLoginUsuario);
		xml_g->addItem("obsRegistro", obsRegistro);
		xml_g->addItem("nmNome", nmNome);
	xml_g->closeTag();
	
}

void sql_error_consultahistorico(sqlca*sqlca)
{
	throw TuxBasicOraException(sqlca->sqlcode);
}


bool procConsultarListaRestritiva(char* nrTelefone)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	
	int iCdAreaRegistro  = 0;
	int iNrLinha		= 0;
	int iNrRestrito = 0;
	
	EXEC SQL END DECLARE SECTION;

	char cConv[3];
	if ( nrTelefone[0]=='0' ) 
	{
		strncpy(cConv,nrTelefone+1,2);cConv[2]=0;
		iCdAreaRegistro = atoi(cConv);
		iNrLinha  = atoi(nrTelefone+3);
	}
	else
	{
		strncpy(cConv,nrTelefone,2);cConv[2]=0;
		iCdAreaRegistro = atoi(cConv);
		iNrLinha  = atoi(nrTelefone+2);
	}


	EXEC SQL WHENEVER SQLERROR  DO sql_error_consultahistorico(&sqlca);
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
	SELECT 
		COUNT(1)
	INTO
		:iNrRestrito
	FROM
		LINHA.LINHABASE LINHABASE,
		APOIO.AREAREGISTRO AREAREGISTRO,
		VOL.LISTARESTRITA  LISTARESTRITA
	WHERE
		LINHABASE.NRLINHA = :iNrLinha AND
		LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO AND
		AREAREGISTRO.CDAREAREGISTRO = :iCdAreaRegistro AND
		LINHABASE.IDLINHABASE = LISTARESTRITA.IDLINHABASE;


	if (iNrRestrito)
		return true;
	else
		return false;
	

}	
