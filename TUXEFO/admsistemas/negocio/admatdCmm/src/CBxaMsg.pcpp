#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CBxaMsg.h"

CBaixaMensagem::CBaixaMensagem()
{
}

CBaixaMensagem::~CBaixaMensagem()
{
}

int CBaixaMensagem::Insert( char* cidBaixa
					       ,char* cidTipoComunicacao
					       ,char* cidMensagem
					       ,char* cdsMensagem
					       ,char* cidUsuarioAlteracao )
{
    ULOG_START("CBaixaMensagem::Insert()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR stAuxidBaixaMensagem[21+1];
		VARCHAR stAuxidMensagemBaixa[21+1];
		char* cAuxidBaixa = cidBaixa;
		char* cAuxidTipoComunicacao = cidTipoComunicacao;
		char* cAuxidMensagem = cidMensagem;
		char* cAuxdsMensagem = cdsMensagem;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
		short iAuxidBaixaMensagem;
	EXEC SQL END DECLARE SECTION;
	
	//Zera a estrutura da classe
	ZeraBaixaMensagem();
	
	memset( &stAuxidBaixaMensagem, 0, sizeof(stAuxidBaixaMensagem) ); 
	memset( &stAuxidMensagemBaixa, 0, sizeof(stAuxidMensagemBaixa) ); 
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
	sqlca.sqlcode=0;

	if( strlennull( cAuxidMensagem ) <= 0 )
	{
		EXEC SQL
			SELECT
				IDMENSAGEMBAIXA
			INTO
				:stAuxidMensagemBaixa
			FROM
				CONTATOADM.MENSAGEMBAIXA
			WHERE
				UPPER(DSMENSAGEMBAIXA) = UPPER(:cAuxdsMensagem)
			AND
				ROWNUM < 2;

		if( stAuxidMensagemBaixa.len <= 0 )
		{
		
			EXEC SQL
				SELECT
					CONTATOADM.MENSAGEMBAIXASQ.NEXTVAL
				INTO
					:stAuxidMensagemBaixa
				FROM 
					DUAL;

			EXEC SQL
				INSERT INTO CONTATOADM.MENSAGEMBAIXA
				(
					IDMENSAGEMBAIXA
				   ,DSMENSAGEMBAIXA
				)
				VALUES
				(
					:stAuxidMensagemBaixa
				   ,:cAuxdsMensagem
				);
		}//if( stAuxidBaixaMensagem.len <= 0 )
		cAuxidMensagem = (char*)stAuxidMensagemBaixa.arr;
	}
	
	EXEC SQL
	SELECT
		IDBAIXAMENSAGEM
	INTO 
		:stAuxidBaixaMensagem:iAuxidBaixaMensagem
	FROM
		CONTATOADM.BAIXAMENSAGEM
	WHERE
		IDBAIXA = :cAuxidBaixa
	AND
		IDFORMARETORNO = :cAuxidTipoComunicacao;
	
	//Caso nao ache a mensagem associada, insere, se achar altera.
	if( stAuxidBaixaMensagem.len <= 0 )
	{

		//Pega um id unico e sequencia para a insercao
		EXEC SQL
			SELECT 
				CONTATOADM.BAIXAMENSAGEMSQ.NEXTVAL 
			INTO 
				:stAuxidBaixaMensagem 
			FROM 
				DUAL;
	
		//Realiza o insert
		EXEC SQL INSERT INTO CONTATOADM.BAIXAMENSAGEM
		(	IDBAIXAMENSAGEM,
			IDBAIXA,
			IDFORMARETORNO,
			IDMENSAGEMBAIXA,
			IDUSUARIOALTERACAO,
			DTULTIMAALTERACAO) 
		VALUES 
		(	:stAuxidBaixaMensagem,
			:cAuxidBaixa,
			:cAuxidTipoComunicacao,
			:cAuxidMensagem,
			:cAuxidUsuarioAlteracao,
			SYSDATE);
	}
	else
	{
		//Executa a instrucao de update
		EXEC SQL 
		UPDATE CONTATOADM.BAIXAMENSAGEM
		SET
			IDBAIXA = :cAuxidBaixa,
			IDFORMARETORNO = :cAuxidTipoComunicacao,
			IDMENSAGEMBAIXA = :cAuxidMensagem,
			IDUSUARIOALTERACAO = :cAuxidUsuarioAlteracao,
			DTULTIMAALTERACAO = SYSDATE
		WHERE
			IDBAIXAMENSAGEM = :stAuxidBaixaMensagem;   
	}
		
	Add( (char*)stAuxidBaixaMensagem.arr
		,cAuxidBaixa
		,cAuxidTipoComunicacao
		,""
		,cAuxidMensagem
		,cAuxdsMensagem );

    ULOG_END("CBaixaMensagem::Insert()");
	return 0;//Sucesso
	
GotoInsert:
	if(sqlca.sqlcode==-2292)
		return 1;//Warning
	else if(sqlca.sqlcode==-1)
		return -1;//Warning
	ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CBaixaMensagem::Update( char* cidBaixaMensagem
					       ,char* cidBaixa
					       ,char* cidTipoComunicacao
					       ,char* cidMensagem
					       ,char* cdsMensagem
					       ,char* cidUsuarioAlteracao)
{
    ULOG_START("CBaixaMensagem::Update()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR stAuxidMensagemBaixa[21+1];
		char* cAuxidBaixa = cidBaixa;
		char* cAuxidTipoComunicacao = cidTipoComunicacao;
		char* cAuxidMensagem = cidMensagem;
		char* cAuxdsMensagem = cdsMensagem;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
		char* cAuxidBaixaMensagem = cidBaixaMensagem;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaMensagem();
		memset( &stAuxidMensagemBaixa, 0, sizeof(stAuxidMensagemBaixa) ); 
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;

		if( strlennull( cAuxidMensagem ) <= 0 )
		{
			EXEC SQL
				SELECT
					IDMENSAGEMBAIXA
				INTO
					:stAuxidMensagemBaixa
				FROM
					CONTATOADM.MENSAGEMBAIXA
				WHERE
					UPPER(DSMENSAGEMBAIXA) = UPPER(:cAuxdsMensagem)
				AND
					ROWNUM < 2;

			if( stAuxidMensagemBaixa.len <= 0 )
			{
			
				EXEC SQL
					SELECT
						CONTATOADM.MENSAGEMBAIXASQ.NEXTVAL
					INTO
						:stAuxidMensagemBaixa
					FROM 
						DUAL;

				EXEC SQL
					INSERT INTO CONTATOADM.MENSAGEMBAIXA
					(
						IDMENSAGEMBAIXA
					   ,DSMENSAGEMBAIXA
					)
					VALUES
					(
						:stAuxidMensagemBaixa
					   ,:cAuxdsMensagem
					);
			}//if( stAuxidBaixaMensagem.len <= 0 )
			cAuxidMensagem = (char*)stAuxidMensagemBaixa.arr;
		}//if( strlennull( cAuxidMensagem ) <= 0 )
		
		//Executa a instrucao de update
		EXEC SQL 
			UPDATE 
				CONTATOADM.BAIXAMENSAGEM
			SET
				IDBAIXA = :cAuxidBaixa,
				IDFORMARETORNO = :cAuxidTipoComunicacao,
				IDMENSAGEMBAIXA = :cAuxidMensagem,
				IDUSUARIOALTERACAO = :cAuxidUsuarioAlteracao,
				DTULTIMAALTERACAO = SYSDATE
			WHERE
				IDBAIXAMENSAGEM = :cAuxidBaixaMensagem;   
		ULOG_END("CBaixaMensagem::Update()");
		return 0;
	}
	catch(...)
	{
		throw;
	}

GotoUpdate:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CBaixaMensagem::Delete( char* cidBaixaMensagem )
{
    ULOG_START("CBaixaMensagem::Delete()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;	
		char* cAuxidBaixaMensagem = cidBaixaMensagem; 
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaMensagem();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
		sqlca.sqlcode=0;
		
		//Executa a instrucao de delecao
		EXEC SQL 
			DELETE
				CONTATOADM.BAIXAMENSAGEM
			WHERE 
				IDBAIXAMENSAGEM = :cAuxidBaixaMensagem;
		ULOG_END("CBaixaMensagem::Delete()");
		return 1;
	}
	catch(...)
	{
		throw;
	}

GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CBaixaMensagem::EraseBxa( char* cidBaixa ) 
{
    ULOG_START("CBaixaMensagem::EraseBxa()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;	
		char* cAuxidBaixa = cidBaixa; 
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaMensagem();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDeleteMM0;
		sqlca.sqlcode=0;
		
		//Executa a instrucao de delecao
		EXEC SQL 
			DELETE FROM 
				CONTATOADM.BAIXAMENSAGEM
			WHERE
				IDBAIXA = :cAuxidBaixa;
		ULOG_END("CBaixaMensagem::EraseBxa()");
		return 0;
	}
	catch(...)
	{
		throw;
	}

GotoDeleteMM0:
	if( sqlca.sqlcode=-2292)
		return 1;
	else
	{
	    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		throw TuxBasicOraException(sqlca.sqlcode);
	}
}

int CBaixaMensagem::ListId( char* cidBaixaMensagem ) 
{
    ULOG_START("CBaixaMensagem::ListId()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidBaixaMensagem = cidBaixaMensagem; 
		struct
		{
			VARCHAR stidBaixaMensagem[21+1];
			VARCHAR stidBaixa[21+1];
			VARCHAR stidTipoComunicacao[21+1];
			VARCHAR stdsTipoComunicacao[255+1];
			VARCHAR stidMensagem[21+1];
			VARCHAR stdsMensagem[255+1];
		} stBaixaMensagemRegistro;
		struct
		{
			short iidBaixaMensagem;
			short iidBaixa;
			short iidTipoComunicacao;
			short idsTipoComunicacao;
			short iidMensagem;
			short idsMensagem;
		} stBaixaMensagemIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaMensagem();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
		/*
   		EXEC SQL 
   			DECLARE 
   				CursorBaixaMensagemId CURSOR FOR 
   			SELECT IDBAIXAMENSAGEM
				  ,IDBAIXA
				  ,IDFORMARETORNO
				  ,DSFORMARETORNO
				  ,IDMENSAGEMBAIXA
				  ,DSMENSAGEMBAIXA
			FROM 
				CONTATOADM.BAIXAMENSAGEMBZEROUM
			WHERE 
				IDBAIXAMENSAGEM = :cAuxidBaixaMensagem
			ORDER BY
				DSFORMARETORNO, DSMENSAGEMBAIXA;
        */
        
   		EXEC SQL 
   			DECLARE 
   				CursorBaixaMensagemId CURSOR FOR 
   			SELECT 
			     BAIXAMENSAGEM.IDBAIXAMENSAGEM
				,BAIXA.IDBAIXA
				,FORMARETORNO.IDFORMARETORNO
				,FORMARETORNO.DSFORMARETORNO
				,MENSAGEMBAIXA.IDMENSAGEMBAIXA
				,MENSAGEMBAIXA.DSMENSAGEMBAIXA
			FROM 
			    CONTATOADM.BAIXA         BAIXA,
			    CONTATOADM.FORMARETORNO  FORMARETORNO,
			    CONTATOADM.MENSAGEMBAIXA MENSAGEMBAIXA,
			    CONTATOADM.BAIXAMENSAGEM BAIXAMENSAGEM
			WHERE 
			    BAIXAMENSAGEM.IDBAIXA = BAIXA.IDBAIXA
			AND 
			    BAIXAMENSAGEM.IDFORMARETORNO = FORMARETORNO.IDFORMARETORNO
			AND 
			    BAIXAMENSAGEM.IDMENSAGEMBAIXA = MENSAGEMBAIXA.IDMENSAGEMBAIXA
			AND 
				BAIXAMENSAGEM.IDBAIXAMENSAGEM = :cAuxidBaixaMensagem
			ORDER BY
				FORMARETORNO.DSFORMARETORNO, MENSAGEMBAIXA.DSMENSAGEMBAIXA;

		//Abre o cursor
		EXEC SQL OPEN CursorBaixaMensagemId;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CBaixaMensagem::ListId()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stBaixaMensagemRegistro, 0, sizeof(stBaixaMensagemRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorBaixaMensagemId INTO :stBaixaMensagemRegistro:stBaixaMensagemIndicator;
				//Adiciona a classe
				Add( (char*)stBaixaMensagemRegistro.stidBaixaMensagem.arr
				    ,(char*)stBaixaMensagemRegistro.stidBaixa.arr
				    ,(char*)stBaixaMensagemRegistro.stidTipoComunicacao.arr
				    ,(char*)stBaixaMensagemRegistro.stdsTipoComunicacao.arr
				    ,(char*)stBaixaMensagemRegistro.stidMensagem.arr
				    ,(char*)stBaixaMensagemRegistro.stdsMensagem.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorBaixaMensagemId;
		}
		ULOG_END("CBaixaMensagem::ListId()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CBaixaMensagem::ListAll( void )
{
    ULOG_START("CBaixaMensagem::ListAll()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidBaixaMensagem[21+1];
			VARCHAR stidBaixa[21+1];
			VARCHAR stidTipoComunicacao[21+1];
			VARCHAR stdsTipoComunicacao[255+1];
			VARCHAR stidMensagem[21+1];
			VARCHAR stdsMensagem[255+1];
		} stBaixaMensagemRegistro;
		struct
		{
			short iidBaixaMensagem;
			short iidBaixa;
			short iidTipoComunicacao;
			short idsTipoComunicacao;
			short iidMensagem;
			short idsMensagem;
		} stBaixaMensagemIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaMensagem();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		/*
   		EXEC SQL 
   			DECLARE 
   				CursorBaixaMensagemAll CURSOR FOR
   			SELECT IDBAIXAMENSAGEM
				  ,IDBAIXA
				  ,IDFORMARETORNO
				  ,DSFORMARETORNO
				  ,IDMENSAGEMBAIXA
				  ,DSMENSAGEMBAIXA
			FROM 
				CONTATOADM.BAIXAMENSAGEMBZEROUM
			ORDER BY
				DSFORMARETORNO, DSMENSAGEMBAIXA;
        */

   		EXEC SQL 
   			DECLARE 
   				CursorBaixaMensagemAll CURSOR FOR
   			SELECT BAIXAMENSAGEM.IDBAIXAMENSAGEM
				  ,BAIXA.IDBAIXA
				  ,FORMARETORNO.IDFORMARETORNO
				  ,FORMARETORNO.DSFORMARETORNO
				  ,MENSAGEMBAIXA.IDMENSAGEMBAIXA
				  ,MENSAGEMBAIXA.DSMENSAGEMBAIXA
				FROM 
				   CONTATOADM.BAIXA         BAIXA,
				   CONTATOADM.FORMARETORNO  FORMARETORNO,
				   CONTATOADM.MENSAGEMBAIXA MENSAGEMBAIXA,
				   CONTATOADM.BAIXAMENSAGEM BAIXAMENSAGEM
				WHERE 
				   BAIXAMENSAGEM.IDBAIXA = BAIXA.IDBAIXA
				AND 
				   BAIXAMENSAGEM.IDFORMARETORNO = FORMARETORNO.IDFORMARETORNO
				AND 
				   BAIXAMENSAGEM.IDMENSAGEMBAIXA = MENSAGEMBAIXA.IDMENSAGEMBAIXA
	  			ORDER BY
				FORMARETORNO.DSFORMARETORNO, MENSAGEMBAIXA.DSMENSAGEMBAIXA;


		//Abre o cursor
		EXEC SQL OPEN CursorBaixaMensagemAll;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		   ULOG_END("CBaixaMensagem::ListAll()");
		   return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stBaixaMensagemRegistro, 0, sizeof(stBaixaMensagemRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorBaixaMensagemAll INTO :stBaixaMensagemRegistro:stBaixaMensagemIndicator;
				//Adiciona a classe
				Add( (char*)stBaixaMensagemRegistro.stidBaixaMensagem.arr
				    ,(char*)stBaixaMensagemRegistro.stidBaixa.arr
				    ,(char*)stBaixaMensagemRegistro.stidTipoComunicacao.arr
				    ,(char*)stBaixaMensagemRegistro.stdsTipoComunicacao.arr
				    ,(char*)stBaixaMensagemRegistro.stidMensagem.arr
				    ,(char*)stBaixaMensagemRegistro.stdsMensagem.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorBaixaMensagemAll;
		}
		ULOG_END("CBaixaMensagem::ListAll()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}





int CBaixaMensagem::ListIdBaixa( char* cidBaixa )
{
    ULOG_START("CBaixaMensagem::ListIdBaixa()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidBaixa = cidBaixa;
		struct
		{
			VARCHAR stidBaixaMensagem[21+1];
			VARCHAR stidBaixa[21+1];
			VARCHAR stidTipoComunicacao[21+1];
			VARCHAR stdsTipoComunicacao[255+1];
			VARCHAR stidMensagem[21+1];
			VARCHAR stdsMensagem[255+1];
		} stBaixaMensagemRegistro;
		struct
		{
			short iidBaixaMensagem;
			short iidBaixa;
			short iidTipoComunicacao;
			short idsTipoComunicacao;
			short iidMensagem;
			short idsMensagem;
		} stBaixaMensagemIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaMensagem();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListIdBaixa;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
		/*
   		EXEC SQL
   			DECLARE 
   				CursorBaixaMensagemIdBaixa CURSOR FOR
   			SELECT IDBAIXAMENSAGEM
				  ,IDBAIXA
				  ,IDFORMARETORNO
				  ,DSFORMARETORNO
				  ,IDMENSAGEMBAIXA
				  ,DSMENSAGEMBAIXA
			FROM 
				CONTATOADM.BAIXAMENSAGEMBZEROUM
			WHERE
				IDBAIXA = :cAuxidBaixa
			ORDER BY
				DSFORMARETORNO, DSMENSAGEMBAIXA; 
        */

   		EXEC SQL
   			DECLARE 
   				CursorBaixaMensagemIdBaixa CURSOR FOR
   			SELECT BAIXAMENSAGEM.IDBAIXAMENSAGEM
				  ,BAIXA.IDBAIXA
				  ,FORMARETORNO.IDFORMARETORNO
				  ,FORMARETORNO.DSFORMARETORNO
				  ,MENSAGEMBAIXA.IDMENSAGEMBAIXA
				  ,MENSAGEMBAIXA.DSMENSAGEMBAIXA
				FROM 
				   CONTATOADM.BAIXA         BAIXA,
				   CONTATOADM.FORMARETORNO  FORMARETORNO,
				   CONTATOADM.MENSAGEMBAIXA MENSAGEMBAIXA,
				   CONTATOADM.BAIXAMENSAGEM BAIXAMENSAGEM
				WHERE 
				   BAIXAMENSAGEM.IDBAIXA = BAIXA.IDBAIXA
				AND 
				   BAIXAMENSAGEM.IDFORMARETORNO = FORMARETORNO.IDFORMARETORNO
				AND 
				   BAIXAMENSAGEM.IDMENSAGEMBAIXA = MENSAGEMBAIXA.IDMENSAGEMBAIXA
				AND 
				   BAIXA.IDBAIXA = :cAuxidBaixa
	  			ORDER BY
				FORMARETORNO.DSFORMARETORNO, MENSAGEMBAIXA.DSMENSAGEMBAIXA;

		//Abre o cursor
		EXEC SQL OPEN CursorBaixaMensagemIdBaixa;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CBaixaMensagem::ListIdBaixa()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stBaixaMensagemRegistro, 0, sizeof(stBaixaMensagemRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorBaixaMensagemIdBaixa INTO :stBaixaMensagemRegistro:stBaixaMensagemIndicator;
				//Adiciona a classe
				Add( (char*)stBaixaMensagemRegistro.stidBaixaMensagem.arr
				    ,(char*)stBaixaMensagemRegistro.stidBaixa.arr
				    ,(char*)stBaixaMensagemRegistro.stidTipoComunicacao.arr
				    ,(char*)stBaixaMensagemRegistro.stdsTipoComunicacao.arr
				    ,(char*)stBaixaMensagemRegistro.stidMensagem.arr
				    ,(char*)stBaixaMensagemRegistro.stdsMensagem.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorBaixaMensagemIdBaixa;
		}
		ULOG_END("CBaixaMensagem::ListIdBaixa()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListIdBaixa:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CBaixaMensagem::ListTipoComunicacao( void )
{
    ULOG_START("CBaixaMensagem::ListTipoComunicacao()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidTipoComunicacao[21+1];
			VARCHAR stdsTipoComunicacao[255+1];
		} stBaixaMensagemRegistro;
		struct
		{
			short iidTipoComunicacao;
			short idsTipoComunicacao;
		} stBaixaMensagemIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaMensagem();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListTipoComunicacao;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL
   			DECLARE 
   				CursorListTipoComunicacao CURSOR FOR
   		SELECT IDFORMARETORNO
				  ,DSFORMARETORNO
			FROM 
				CONTATOADM.FORMARETORNO
			WHERE
				IDFORMARETORNO > 0
			ORDER BY
				DSFORMARETORNO;

		//Abre o cursor
		EXEC SQL OPEN CursorListTipoComunicacao;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		   ULOG_END("CBaixaMensagem::ListTipoComunicacao()");
		   return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stBaixaMensagemRegistro, 0, sizeof(stBaixaMensagemRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorListTipoComunicacao INTO :stBaixaMensagemRegistro:stBaixaMensagemIndicator;
				//Adiciona a classe
				Add( ""
				    ,""
				    ,(char*)stBaixaMensagemRegistro.stidTipoComunicacao.arr
				    ,(char*)stBaixaMensagemRegistro.stdsTipoComunicacao.arr
				    ,""
				    ,"" );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorListTipoComunicacao;
		}
		
		ULOG_END("CBaixaMensagem::ListTipoComunicacao()");
		
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListTipoComunicacao:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CBaixaMensagem::ListMensagemBaixa( void )
{
    ULOG_END("CBaixaMensagem::ListMensagemBaixa()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidMensagem[21+1];
			VARCHAR stdsMensagem[255+1];
		} stBaixaMensagemRegistro;
		struct
		{
			short iidMensagem;
			short idsMensagem;
		} stBaixaMensagemIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaMensagem();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListMensagemBaixa;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL
   			DECLARE 
   				CursorListMensagemBaixa CURSOR FOR
   			SELECT IDMENSAGEMBAIXA
				  ,DSMENSAGEMBAIXA
			FROM 
				CONTATOADM.MENSAGEMBAIXA
			WHERE
				IDMENSAGEMBAIXA > 0
			ORDER BY
				DSMENSAGEMBAIXA;

		//Abre o cursor
		EXEC SQL OPEN CursorListMensagemBaixa;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CBaixaMensagem::ListMensagemBaixa()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stBaixaMensagemRegistro, 0, sizeof(stBaixaMensagemRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorListMensagemBaixa INTO :stBaixaMensagemRegistro:stBaixaMensagemIndicator;
				//Adiciona a classe
				Add( ""
				    ,""
				    ,""
				    ,""
				    ,(char*)stBaixaMensagemRegistro.stidMensagem.arr
				    ,(char*)stBaixaMensagemRegistro.stdsMensagem.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorListMensagemBaixa;
		}
		ULOG_END("CBaixaMensagem::ListMensagemBaixa()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListMensagemBaixa:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CBaixaMensagem::GetXml( char* cNomeTagMen, char* cNomeTagTipo, char* cNomeTagMsg, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTagMen ) > 0 )
				xml->createTag(cNomeTagMen);
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idBaixaMensagem", Registro(x)->cidBaixaMensagem );

				if( strlennull( cNomeTagMsg ) > 0 )
					xml->createTag(cNomeTagMsg);

				xml->addItem("idMensagemAviso", Registro(x)->cidMensagem ); 
				xml->addItem("dsMensagemAviso", Registro(x)->cdsMensagem ); 

				if( strlennull( cNomeTagMsg ) > 0 )
				xml->closeTag();

				if( strlennull( cNomeTagTipo ) > 0 )
					xml->createTag(cNomeTagTipo);
				xml->addItem("idTipoComunicacao", Registro(x)->cidTipoComunicacao );
				xml->addItem("sgTipoComunicacao", "" );
				xml->addItem("dsTipoComunicacao", Registro(x)->cdsTipoComunicacao );
				if( strlennull( cNomeTagTipo ) > 0 )
					xml->closeTag();
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTagMen ) > 0 )
				xml->closeTag();
		}
	}
}

void CBaixaMensagem::GetXmlTipoComunicacao( char* cNomeTagTipo, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				if( strlennull( cNomeTagTipo ) > 0 )
					xml->createTag(cNomeTagTipo);
				xml->addItem("idTipoComunicacao", Registro(x)->cidTipoComunicacao );
				xml->addItem("sgTipoComunicacao", "" );
				xml->addItem("dsTipoComunicacao", Registro(x)->cdsTipoComunicacao );
				if( strlennull( cNomeTagTipo ) > 0 )
					xml->closeTag();
			}
		}
	}
}

void CBaixaMensagem::GetXmlMensagemBaixa( char* cNomeTagTipo, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				if( strlennull( cNomeTagTipo ) > 0 )
					xml->createTag(cNomeTagTipo);
				xml->addItem("idMensagemAviso", Registro(x)->cidMensagem );
				xml->addItem("dsMensagemAviso", Registro(x)->cdsMensagem );
				if( strlennull( cNomeTagTipo ) > 0 )
					xml->closeTag();
			}
		}
	}
}


//Codigos abaixo de autoria de Marcelo Nunez
int CBaixaMensagem::ListaMsgBaixaWF( 
                                     char *idFormaRetParam,
                                     char *idMsgBaixaParam,
                                     char *dsMsgBaixaParam
                                   )
{
    ULOG_START("CBaixaMensagem::ListaMsgBaixaWF()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
      int     idFormaRetorno = atoi(idFormaRetParam);

      int     idMsgBaixa;
      VARCHAR dsMsgBaixa[256];
	EXEC SQL END DECLARE SECTION;
	sqlca.sqlcode=0;

	  EXEC SQL WHENEVER NOT FOUND CONTINUE;
      EXEC SQL WHENEVER SQLERROR GOTO ErrorWF;
      EXEC SQL
         SELECT idMensagemBaixa INTO :idMsgBaixa
      FROM 
	      CONTATOADM.BAIXAMENSAGEM
      WHERE
	      IDFORMARETORNO = :idFormaRetorno;
	   if ( sqlca.sqlcode )
	   {
	       ULOG_END("CBaixaMensagem::ListaMsgBaixaWF()");
		   return 0;  //Erro
	   }

      EXEC SQL
         SELECT dsMensagemBaixa INTO :dsMsgBaixa
      FROM 
	      CONTATOADM.MENSAGEMBAIXA
      WHERE
	      idMensagemBaixa = :idMsgBaixa;
	   if ( sqlca.sqlcode )
	   {
	       ULOG_END("CBaixaMensagem::ListaMsgBaixaWF()");
		   return 0;  //Erro
	   }
      dsMsgBaixa.arr[dsMsgBaixa.len] = 0x0;

   sprintf( idMsgBaixaParam,"%d",idMsgBaixa );
   strcpy( dsMsgBaixaParam,(char *)dsMsgBaixa.arr );
   
   ULOG_END("CBaixaMensagem::ListaMsgBaixaWF()");
   return 1;

ErrorWF:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}



int CBaixaMensagem::ListTpComunicWF( char *idBaixaParam )
{
    ULOG_START("CBaixaMensagem::ListTpComunicWF()");
   CBaixaMensagem oBaixaMensagem;
   char idFormaRetorno[23];
   char idMsgBaixa[23];
   char dsMsgBaixa[256];

   idFormaRetorno[0] = 0x0;
   idMsgBaixa[0] = 0x0;
   dsMsgBaixa[0] = 0x0;

	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	
   struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
      int idBaixaAux = atoi( idBaixaParam );
      int idFormaRetornoWrk;

		struct
		{
			VARCHAR stidBaixaMensagem[21+1];
			VARCHAR stidBaixa[21+1];
			VARCHAR stidTipoComunicacao[21+1];
			VARCHAR stdsTipoComunicacao[255+1];
			VARCHAR stidMensagem[21+1];
			VARCHAR stdsMensagem[255+1];
		} stBaixaMensagemRegistro;
		struct
		{
			short iidBaixaMensagem;
			short iidBaixa;
			short iidTipoComunicacao;
			short idsTipoComunicacao;
			short iidMensagem;
			short idsMensagem;
		} stBaixaMensagemIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaMensagem();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListTpComunicWF;
		sqlca.sqlcode=0;

      EXEC SQL
         SELECT idFormaRetorno INTO :idFormaRetornoWrk
      FROM 
	      CONTATOADM.BAIXAMENSAGEM
      WHERE
	      idBaixa = :idBaixaAux
      AND
         ROWNUM <= 1;

		EXEC SQL WHENEVER NOT FOUND DO break;
		//Declara um cursor para listar todos os registros
		/*
   		EXEC SQL
   			DECLARE 
   				ReadFormaRetorno CURSOR FOR
			   SELECT IDBAIXAMENSAGEM
				     ,IDBAIXA
				     ,IDFORMARETORNO
				     ,DSFORMARETORNO
				     ,IDMENSAGEMBAIXA
				     ,DSMENSAGEMbAIXA
			   FROM 
				   CONTATOADM.BAIXAMENSAGEMBZEROUM
			   WHERE
				   IDBAIXA = :idBaixaAux
			   AND 
				   IDFORMARETORNO = :idFormaRetornoWrk;
        */
        
   		EXEC SQL
   			DECLARE 
   				ReadFormaRetorno CURSOR FOR
   			SELECT BAIXAMENSAGEM.IDBAIXAMENSAGEM
				  ,BAIXA.IDBAIXA
				  ,FORMARETORNO.IDFORMARETORNO
				  ,FORMARETORNO.DSFORMARETORNO
				  ,MENSAGEMBAIXA.IDMENSAGEMBAIXA
				  ,MENSAGEMBAIXA.DSMENSAGEMBAIXA
				FROM 
				   CONTATOADM.BAIXA         BAIXA,
				   CONTATOADM.FORMARETORNO  FORMARETORNO,
				   CONTATOADM.MENSAGEMBAIXA MENSAGEMBAIXA,
				   CONTATOADM.BAIXAMENSAGEM BAIXAMENSAGEM
				WHERE 
				   BAIXAMENSAGEM.IDBAIXA = BAIXA.IDBAIXA
				AND 
				   BAIXAMENSAGEM.IDFORMARETORNO = FORMARETORNO.IDFORMARETORNO
				AND 
				   BAIXAMENSAGEM.IDMENSAGEMBAIXA = MENSAGEMBAIXA.IDMENSAGEMBAIXA
				AND 
				   BAIXA.IDBAIXA = :idBaixaAux
			   AND 
				   FORMARETORNO.IDFORMARETORNO = :idFormaRetornoWrk;

		EXEC SQL OPEN ReadFormaRetorno;
		if(sqlca.sqlcode)
		{
		    ULOG_END("CBaixaMensagem::ListTpComunicWF()");
			return 0;//Erro
		}

		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			memset( &stBaixaMensagemRegistro, 0, sizeof(stBaixaMensagemRegistro) );

			EXEC SQL 
            FETCH 
               ReadFormaRetorno 
            INTO 
               :stBaixaMensagemRegistro:stBaixaMensagemIndicator;

/*			
         strcpy( idFormaRetorno,(char*)stBaixaMensagemRegistro.stidTipoComunicacao.arr );
         if ( oBaixaMensagem.ListaMsgBaixaWF( idFormaRetorno, idMsgBaixa, dsMsgBaixa ))
         {
            strcpy( (char *)stBaixaMensagemRegistro.stidMensagem.arr,idMsgBaixa );
            strcpy( (char *)stBaixaMensagemRegistro.stdsMensagem.arr,dsMsgBaixa );
            stBaixaMensagemRegistro.stidMensagem.len = strlen(idMsgBaixa);
            stBaixaMensagemRegistro.stdsMensagem.len = strlen(dsMsgBaixa);
         }
*/         
         //Adiciona a classe
         if ( stBaixaMensagemIndicator.idsTipoComunicacao >= 0 )
         {
			   Add( (char*)stBaixaMensagemRegistro.stidBaixaMensagem.arr
				    ,(char*)stBaixaMensagemRegistro.stidBaixa.arr
				    ,(char*)stBaixaMensagemRegistro.stidTipoComunicacao.arr
				    ,(char*)stBaixaMensagemRegistro.stdsTipoComunicacao.arr
				    ,(char*)stBaixaMensagemRegistro.stidMensagem.arr
				    ,(char*)stBaixaMensagemRegistro.stdsMensagem.arr );
			   //conta quantos existem
			   iCont++;
         }
		}
		EXEC SQL CLOSE ReadFormaRetorno;
		
		ULOG_END("CBaixaMensagem::ListTpComunicWF()");
		return iCont;   //Retorna a quantidade de registros
	}
	catch(...)
	{
		throw;
	}

GotoListTpComunicWF:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}


int CBaixaMensagem::ListTpComunicWFSel( char *idBaixaParam, int idTpComunicParam )
{
    ULOG_START("CBaixaMensagem::ListTpComunicWFSel()");
   CBaixaMensagem oBaixaMensagem;
   char idFormaRetorno[23];
   char idMsgBaixa[23];
   char dsMsgBaixa[256];

   idFormaRetorno[0] = 0x0;
   idMsgBaixa[0] = 0x0;
   dsMsgBaixa[0] = 0x0;

	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	
   struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
      int idTpComunic = idTpComunicParam;
      int idBaixaWrk  = atoi( idBaixaParam );

		struct
		{
			VARCHAR stidBaixaMensagem[21+1];
			VARCHAR stidBaixa[21+1];
			VARCHAR stidTipoComunicacao[21+1];
			VARCHAR stdsTipoComunicacao[255+1];
			VARCHAR stidMensagem[21+1];
			VARCHAR stdsMensagem[255+1];
		} stBaixaMensagemRegistro;
		struct
		{
			short iidBaixaMensagem;
			short iidBaixa;
			short iidTipoComunicacao;
			short idsTipoComunicacao;
			short iidMensagem;
			short idsMensagem;
		} stBaixaMensagemIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaMensagem();

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListTpComunicWFSel;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		/*
   		EXEC SQL
   			DECLARE 
   				ReadFormaRetornoSel CURSOR FOR
			   SELECT IDBAIXAMENSAGEM
				     ,IDBAIXA
				     ,IDFORMARETORNO
				     ,DSFORMARETORNO
				     ,IDMENSAGEMBAIXA
				     ,DSMENSAGEMbAIXA
			   FROM 
				   CONTATOADM.BAIXAMENSAGEMBZEROUM
			   WHERE
				   IDBAIXA = :idBaixaWrk
			   AND 
				   IDFORMARETORNO = :idTpComunic;
        */
        
   		EXEC SQL
   			DECLARE 
   				ReadFormaRetornoSel CURSOR FOR
			   SELECT 
			        BAIXAMENSAGEM.IDBAIXAMENSAGEM
				   ,BAIXA.IDBAIXA
				   ,FORMARETORNO.IDFORMARETORNO
				   ,FORMARETORNO.DSFORMARETORNO
				   ,MENSAGEMBAIXA.IDMENSAGEMBAIXA
				   ,MENSAGEMBAIXA.DSMENSAGEMbAIXA
			   FROM 
				   CONTATOADM.BAIXA BAIXA,
				   CONTATOADM.FORMARETORNO  FORMARETORNO,
				   CONTATOADM.MENSAGEMBAIXA MENSAGEMBAIXA,
				   CONTATOADM.BAIXAMENSAGEM BAIXAMENSAGEM
			   WHERE 
				   BAIXAMENSAGEM.IDBAIXA = BAIXA.IDBAIXA
			   AND 
				   BAIXAMENSAGEM.IDFORMARETORNO = FORMARETORNO.IDFORMARETORNO
			   AND 
				   BAIXAMENSAGEM.IDMENSAGEMBAIXA = MENSAGEMBAIXA.IDMENSAGEMBAIXA
			   AND
				   BAIXA.IDBAIXA = :idBaixaWrk
			   AND 
				   FORMARETORNO.IDFORMARETORNO = :idTpComunic;

		EXEC SQL OPEN ReadFormaRetornoSel;
		if(sqlca.sqlcode)
		{
		   ULOG_END("CBaixaMensagem::ListTpComunicWFSel()");
		   return 0;//Erro
		}

		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			memset( &stBaixaMensagemRegistro, 0, sizeof(stBaixaMensagemRegistro) );

			EXEC SQL 
            FETCH 
               ReadFormaRetornoSel 
            INTO 
               :stBaixaMensagemRegistro:stBaixaMensagemIndicator;

         //Adiciona a classe
         if ( stBaixaMensagemIndicator.idsTipoComunicacao >= 0 )
         {
			   Add( (char*)stBaixaMensagemRegistro.stidBaixaMensagem.arr
				    ,(char*)stBaixaMensagemRegistro.stidBaixa.arr
				    ,(char*)stBaixaMensagemRegistro.stidTipoComunicacao.arr
				    ,(char*)stBaixaMensagemRegistro.stdsTipoComunicacao.arr
				    ,(char*)stBaixaMensagemRegistro.stidMensagem.arr
				    ,(char*)stBaixaMensagemRegistro.stdsMensagem.arr );
			   //conta quantos existem
			   iCont++;
         }
		}
		EXEC SQL CLOSE ReadFormaRetornoSel;
		
		ULOG_END("CBaixaMensagem::ListTpComunicWFSel()");
		
		return iCont;   //Retorna a quantidade de registros
	}
	catch(...)
	{
		throw;
	}

GotoListTpComunicWFSel:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}


void CBaixaMensagem::GetXmlTpComunicWF( char* cNomeTagMen, char* cNomeTagTipo, char* cNomeTagMsg, XMLGen*xml ){
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTagMen ) > 0 )
				xml->createTag(cNomeTagMen);
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				xml->addItem("idBaixaMensagem", Registro(x)->cidMensagem ); 
				//Adiciona as tags necessarias
				if( strlennull( cNomeTagMsg ) > 0 )
					xml->createTag(cNomeTagMsg);
				xml->addItem("dsMensagemAviso", Registro(x)->cdsMensagem ); 
				if( strlennull( cNomeTagMsg ) > 0 )
					xml->closeTag();
				if( strlennull( cNomeTagTipo ) > 0 )
					xml->createTag(cNomeTagTipo);
				xml->addItem("idTipoComunicacao", Registro(x)->cidTipoComunicacao );
				xml->addItem("dsTipoComunicacao", Registro(x)->cdsTipoComunicacao );
				if( strlennull( cNomeTagTipo ) > 0 )
					xml->closeTag();
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTagMen ) > 0 )
				xml->closeTag();
		}
	}
}

