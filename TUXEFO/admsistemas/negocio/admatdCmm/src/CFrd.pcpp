#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
#include<time.h>

#include "../include/CFrd.h"

CFeriado::CFeriado()
{
}

CFeriado::~CFeriado()
{
}

int CFeriado::InsertMnc(
			char* cidMunicipio,
			char* cidFeriado,
			char* cidUsuarioAlteracao )
{
    ULOG_START("CFeriado::InsertMnc()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cAuxidMunicipioFeriado[21+1];
		char* cAuxidMunicipio = cidMunicipio;
		char* cAuxidFeriado = cidFeriado;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	memset( &cAuxidMunicipioFeriado, 0, sizeof(cAuxidMunicipioFeriado) );

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;

	//Pega um id unico e sequencia para a insercao
	EXEC SQL SELECT calendario.MunicipioFeriadoSQ.NEXTVAL INTO :cAuxidMunicipioFeriado FROM DUAL;

	//Realiza o insert
	EXEC SQL INSERT INTO CALENDARIO.MUNICIPIOFERIADO
	(	IDMUNICIPIOFERIADO,
		IDMUNICIPIO,
		IDFERIADO,
		IDUSUARIOALTERACAO,
		DTULTIMAALTERACAO)
	VALUES
	(	:cAuxidMunicipioFeriado,
		:cAuxidMunicipio,
		:cAuxidFeriado,
		:cAuxidUsuarioAlteracao,
		SYSDATE);

    ULOG_END("CFeriado::InsertMnc()");
	return 1;//Sucesso

GotoInsert:
	if(sqlca.sqlcode==-2292)
		return 2;
	else
	{
		ULOG("\nCFeriado::InsertMnc:Erro Oracle: %d\n", sqlca.sqlcode );
		ULOG("\nCFeriado::InsertMnc:Descrição..: %s\n", sqlca.sqlerrm.sqlerrmc );
        ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		throw TuxBasicOraException(sqlca.sqlcode);
	}
}

int CFeriado::InsertUF(
			char* cidUF,
			char* cidFeriado,
			char* cidUsuarioAlteracao )
{
    ULOG_START("CFeriado::InsertUF()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cAuxidUFFeriado[21+1];
		char* cAuxidUF = cidUF;
		char* cAuxidFeriado = cidFeriado;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	memset( &cAuxidUFFeriado, 0, sizeof(cAuxidUFFeriado) );

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;

	//Pega um id unico e sequencia para a insercao
	EXEC SQL SELECT calendario.UFFeriadoSQ.NEXTVAL INTO :cAuxidUFFeriado FROM DUAL;

	//Realiza o insert
	EXEC SQL INSERT INTO CALENDARIO.UFFERIADO
	(	IDUFFERIADO,
		IDUF,
		IDFERIADO,
		IDUSUARIOALTERACAO,
		DTULTIMAALTERACAO)
	VALUES
	(	:cAuxidUFFeriado,
		:cAuxidUF,
		:cAuxidFeriado,
		:cAuxidUsuarioAlteracao,
		SYSDATE);

    ULOG_END("CFeriado::InsertUF()");
	return 1;//Sucesso

GotoInsert:
	if(sqlca.sqlcode==-2292)
		return 2;
	else
	{
		ULOG("\nCFeriado::InsertUF:Erro Oracle: %d\n", sqlca.sqlcode );
		ULOG("\nCFeriado::InsertUF:Descrição..: %s\n", sqlca.sqlerrm.sqlerrmc );
        ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		throw TuxBasicOraException(sqlca.sqlcode);
	}
}

int CFeriado::Insert(   char* cidTipoFeriado,
						char* cidNomeFeriado,
						char* cdsNomeFeriado,
						char* cinFeriadoMovel,
						char* cdtDia,
					    char* cinRelatorio,
						char* cidUsuarioAlteracao,
					    char* cidUF,
					    char* cidMunicipio,
					    char* cidFeriadoRet
					)
{
    ULOG_START("CFeriado::Insert()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	int iUf;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR stAuxidFeriado[21+1];
		VARCHAR stAuxidNomeFeriado[21+1];
		VARCHAR stAuxdsFeriado[255+1];
		char* cAuxidTipoFeriado = cidTipoFeriado;
		char* cAuxidNomeFeriado = cidNomeFeriado;
		char* cAuxinFeriadoMovel = cinFeriadoMovel;
		char* cAuxdtDia = cdtDia;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
		char* cAuxdsNomeFeriado = cdsNomeFeriado;
		char* cAuxinRelatorio = cinRelatorio;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	memset( &stAuxidFeriado, 0, sizeof(stAuxidFeriado) );
	memset( &stAuxidNomeFeriado, 0, sizeof(stAuxidNomeFeriado) );
	memset( &stAuxdsFeriado, 0, sizeof(stAuxdsFeriado) );

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsertUfMnc;

	if( strlennull( cidFeriadoRet ) <= 0 )
	{

		if( strlennull( cAuxidNomeFeriado ) <= 0 )
		{
			EXEC SQL
				SELECT
					IDNOMEFERIADO
				INTO
					:stAuxidNomeFeriado
				FROM
					CALENDARIO.NOMEFERIADO
				WHERE
					UPPER( DSFERIADO ) = UPPER( :cAuxdsNomeFeriado )
				AND
					ROWNUM <= 1;

			if( stAuxidNomeFeriado.len <= 0 )
			{
				//Pega um id unico e sequencia para a insercao
				EXEC SQL
					SELECT
						CALENDARIO.NOMEFERIADOSQ.NEXTVAL
					INTO
						:stAuxidNomeFeriado
					FROM
						DUAL;

				EXEC SQL
					INSERT INTO CALENDARIO.NOMEFERIADO
						(IDNOMEFERIADO
						,DSFERIADO
						,IDUSUARIOALTERACAO
						,DTULTIMAALTERACAO)
					VALUES
						(:stAuxidNomeFeriado
						,:cAuxdsNomeFeriado
						,:cAuxidUsuarioAlteracao
						,SYSDATE);
			}
			cAuxidNomeFeriado = (char*)stAuxidNomeFeriado.arr;
		}
		//Pega um id unico e sequencia para a insercao
		EXEC SQL
			SELECT
				calendario.FeriadoSQ.NEXTVAL
			INTO
				:stAuxidFeriado
			FROM
				DUAL;

		//Realiza o insert
		EXEC SQL INSERT INTO CALENDARIO.FERIADO
		(	IDFERIADO,
			IDTIPOFERIADO,
			IDNOMEFERIADO,
			INFERIADOMOVEL,
			DTDIA,
			INRELATORIO,
			IDUSUARIOALTERACAO,
			DTULTIMAALTERACAO)
		VALUES
		(	:stAuxidFeriado,
			:cAuxidTipoFeriado,
			:cAuxidNomeFeriado,
			:cAuxinFeriadoMovel,
			TO_DATE( :cAuxdtDia, 'DD/MM/YYYY' ),
			:cAuxinRelatorio,
			:cAuxidUsuarioAlteracao,
			SYSDATE);

		strcpy( cidFeriadoRet, (char*)stAuxidFeriado.arr );
	}//if( strlennull( cidFeriadoRet ) <= 0 )
	else
	{
		strcpy( (char*)stAuxidFeriado.arr, cidFeriadoRet );
		stAuxidFeriado.len = strlen(cidFeriadoRet);
	}//if( strlennull( cidFeriadoRet ) <= 0 )

	iUf = 1;
	if( strlennull( cidMunicipio ) > 0 )
	{
		if( strcmp( cidMunicipio, "0" ) != 0 )
		{
			InsertMnc( cidMunicipio,
					   (char*)stAuxidFeriado.arr,
					   cAuxidUsuarioAlteracao );
			iUf = 0;
		}
	}
	if( iUf )
	{
		if( strlennull( cidUF ) > 0 )
		{
			if( strcmp( cidUF, "0" ) != 0 )
			{
				InsertUF( cidUF,
						  (char*)stAuxidFeriado.arr,
						  cAuxidUsuarioAlteracao );
			}
		}
	}

	ULOG_END("CFeriado::Insert()");

	return 1;//Sucesso

GotoInsertUfMnc:
	if(sqlca.sqlcode==-2291)
		return 2;
	else if(sqlca.sqlcode==-1)
		return 3;
	else
	{
		ULOG("\nCFeriado::Insert:Erro Oracle: %d\n", sqlca.sqlcode );
		ULOG("\nCFeriado::Insert:Descrição..: %s\n", sqlca.sqlerrm.sqlerrmc );
        ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		throw TuxBasicOraException(sqlca.sqlcode);
	}
}

int CFeriado::Insert(
						char* cidTipoFeriado,
						char* cidNomeFeriado,
						char* cdsNomeFeriado,
						char* cinFeriadoMovel,
						char* cdtDia,
					    char* cinRelatorio,
						char* cidUsuarioAlteracao
					)
{
    ULOG_START("CFeriado::Insert()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR stAuxidFeriado[21+1];
		VARCHAR stAuxidNomeFeriado[21+1];
		VARCHAR stAuxdsFeriado[255+1];
		char* cAuxidTipoFeriado = cidTipoFeriado;
		char* cAuxidNomeFeriado = cidNomeFeriado;
		char* cAuxinFeriadoMovel = cinFeriadoMovel;
		char* cAuxdtDia = cdtDia;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
		char* cAuxdsNomeFeriado = cdsNomeFeriado;
		char* cAuxinRelatorio = cinRelatorio;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	memset( &stAuxidFeriado, 0, sizeof(stAuxidFeriado) );
	memset( &stAuxidNomeFeriado, 0, sizeof(stAuxidNomeFeriado) );
	memset( &stAuxdsFeriado, 0, sizeof(stAuxdsFeriado) );

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;

	if( strlennull( cAuxidNomeFeriado ) <= 0 )
	{
		EXEC SQL
			SELECT
				IDNOMEFERIADO
			INTO
				:stAuxidNomeFeriado
			FROM
				CALENDARIO.NOMEFERIADO
			WHERE
				UPPER( DSFERIADO ) = UPPER( :cAuxdsNomeFeriado )
			AND
				ROWNUM <= 1;

		if( stAuxidNomeFeriado.len <= 0 )
		{
			//Pega um id unico e sequencia para a insercao
			EXEC SQL
				SELECT
					CALENDARIO.NOMEFERIADOSQ.NEXTVAL
				INTO
					:stAuxidNomeFeriado
				FROM
					DUAL;

			EXEC SQL
				INSERT INTO CALENDARIO.NOMEFERIADO
					(IDNOMEFERIADO
					,DSFERIADO
					,IDUSUARIOALTERACAO
					,DTULTIMAALTERACAO)
				VALUES
					(:stAuxidNomeFeriado
					,:cAuxdsNomeFeriado
					,:cAuxidUsuarioAlteracao
					,SYSDATE);
		}
		cAuxidNomeFeriado = (char*)stAuxidNomeFeriado.arr;
	}
	//Pega um id unico e sequencia para a insercao
	EXEC SQL
		SELECT
			calendario.FeriadoSQ.NEXTVAL
		INTO
			:stAuxidFeriado
		FROM
			DUAL;

	//Realiza o insert
	EXEC SQL INSERT INTO CALENDARIO.FERIADO
	(	IDFERIADO,
		IDTIPOFERIADO,
		IDNOMEFERIADO,
		INFERIADOMOVEL,
		DTDIA,
		INRELATORIO,
		IDUSUARIOALTERACAO,
		DTULTIMAALTERACAO)
	VALUES
	(	:stAuxidFeriado,
		:cAuxidTipoFeriado,
		:cAuxidNomeFeriado,
		:cAuxinFeriadoMovel,
		TO_DATE( :cAuxdtDia, 'DD/MM/YYYY' ),
		:cAuxinRelatorio,
		:cAuxidUsuarioAlteracao,
		SYSDATE);


	ListId( (char*)stAuxidFeriado.arr );

    ULOG_END("CFeriado::Insert()");
	return 1;//Sucesso

GotoInsert:
	if(sqlca.sqlcode==-2291)
		return 2;
	else if(sqlca.sqlcode==-1)
		return 3;
	else
	{
		ULOG("\nCFeriado::Insert:Erro Oracle: %d\n", sqlca.sqlcode );
		ULOG("\nCFeriado::Insert:Descrição..: %s\n", sqlca.sqlerrm.sqlerrmc );
        ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		throw TuxBasicOraException(sqlca.sqlcode);
	}
}

int CFeriado::RelacaoFrdMnc( char* cidFeriado
                            ,char* cidUF )
{
    ULOG_START("CFeriado::RelacaoFrdMnc()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidFeriado = cidFeriado;
		char* cAuxidUF = cidUF;
		struct
		{
			VARCHAR stidMunicipio[21+1];
			VARCHAR stnmMunicipio[255+1];
		} stFeriadoRegistro;
		struct
		{
			short iidMunicipio;
			short inmMunicipio;
		} stFeriadoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	ZeraFeriado();

	sqlca.sqlcode=0;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	//Declara um cursor para listar os Registros
	EXEC SQL
		DECLARE
			CursorRelacaoFrdMnc CURSOR FOR
		SELECT
			MUNICIPIOFERIADO.IDMUNICIPIO
		   ,MUNICIPIOFERIADO.NMMUNICIPIO
		FROM
			CONTATOADM.MUNICIPIOFERIADOV01 MUNICIPIOFERIADO
		WHERE
			MUNICIPIOFERIADO.IDFERIADO = :cAuxidFeriado
		AND
		   MUNICIPIOFERIADO.IDUF = :cAuxidUF
		ORDER BY
			MUNICIPIOFERIADO.NMMUNICIPIO;

	EXEC SQL WHENEVER SQLERROR GOTO GotoRelacaoFrdMnc;

	EXEC SQL OPEN CursorRelacaoFrdMnc;

	//Verifica se nao house erro ORACLE
	if(sqlca.sqlcode)
		return 0;//Erro
	else
	{
		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stFeriadoRegistro, 0, sizeof(stFeriadoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorRelacaoFrdMnc INTO :stFeriadoRegistro:stFeriadoIndicator;
			//Adiciona a classe
			Add(
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				(char*)stFeriadoRegistro.stidMunicipio.arr,
				(char*)stFeriadoRegistro.stnmMunicipio.arr,
				"",
				"",
				"",
				"",
				""

			   );
			//conta quantos existem
			iCont++;
		}
		//Fecha o cursor
		EXEC SQL CLOSE CursorRelacaoFrdMnc;
	}
	ULOG_END("CFeriado::RelacaoFrdMnc()");
	//Retorna a quantidade de registros
	return iCont;

GotoRelacaoFrdMnc:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}


int CFeriado::RelacaoFrdMncParPag( char* cdtDia,
							    char* cdsFeriado,
					            char* cidTipoFeriado,
							    char* cinFeriadoMovel,
					            char* cinRelatorio,
							    char* cidMunicipio,
					            char* cAno,
                                int iPagina,
                                int &iQtdeRegistros )
{
    ULOG_START("CFeriado::RelacaoFrdMncParPag()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char cAuxdtDia[21+1];
		char cAuxdsFeriado[255+1];
		char cAuxidTipoFeriado[21+1];
		char cAuxinFeriadoMovel[21+1];
		char cAuxidMunicipio[21+1];
		char cAuxinRelatorio[21+1];
		struct
		{
			VARCHAR stidFeriado[21+1];
			VARCHAR stidTipoFeriado[21+1];
			VARCHAR stdsTipoFeriado[255+1];
			VARCHAR stidNomeFeriado[21+1];
			VARCHAR stdsFeriado[255+1];
			VARCHAR stinFeriadoMovel[21+1];
			VARCHAR stdtDia[12+1];
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stidMunicipio[21+1];
			VARCHAR stnmMunicipio[255+1];
			VARCHAR stidHorarioVerao[21+1];
			VARCHAR stnrHorarioVerao[21+1];
			VARCHAR stdtInicio[12+1];
			VARCHAR stdtFim[12+1];
			VARCHAR stinRelatorio[21+1];
		} stFeriadoRegistro;
		struct
		{
			short iidFeriado;
			short iidTipoFeriado;
			short idsTipoFeriado;
			short iidNomeFeriado;
			short idsFeriado;
			short iinFeriadoMovel;
			short idtDia;
			short iidUF;
			short isgUF;
			short inmUF;
			short iidMunicipio;
			short inmMunicipio;
			short iidHorarioVerao;
			short inrHorarioVerao;
			short idtInicio;
			short idtFim;
			short iinRelatirio;
		} stFeriadoIndicator;
		char cAnoAtual[10+1];

		int	iRegistroInicio = 0;
		int iRegistroFim = 0;
	EXEC SQL END DECLARE SECTION;

    ULOG(">>>RelacaoFrdMncParPag iPagina(%d) iQtdeRegistros(%d)", iPagina, iQtdeRegistros);

	try
	{
		ZeraFeriado();

		memset( cAuxdtDia, 0, sizeof( cAuxdtDia ) );
		memset( cAuxdsFeriado, 0, sizeof( cAuxdsFeriado ) );
		memset( cAuxidTipoFeriado, 0, sizeof( cAuxidTipoFeriado ) );
		memset( cAuxinFeriadoMovel, 0, sizeof( cAuxinFeriadoMovel ) );
		memset( cAuxidMunicipio, 0, sizeof( cAuxidMunicipio ) );
		memset( cAuxinRelatorio, 0, sizeof( cAuxinRelatorio ) );
		memset( cAnoAtual, 0, sizeof( cAnoAtual ) );

		strcpy( cAuxdtDia, cdtDia );
		strcpy( cAuxdsFeriado, cdsFeriado );
		strcpy( cAuxidTipoFeriado, cidTipoFeriado );
		strcpy( cAuxinFeriadoMovel, cinFeriadoMovel );
		strcpy( cAuxidMunicipio, cidMunicipio );
		strcpy( cAuxinRelatorio, cinRelatorio );
		strcpy( cAnoAtual, cAno );

		if( strlennull( cAno ) <= 0 )
			strcpy( cAnoAtual,"-1" );

		strcpy( cAnoAtual, "-1" );
		if( strlennull( cdtDia ) <= 0 )
			strcpy( cAuxdtDia, "-1" );

		if( strlennull( cdsFeriado ) > 0 )
			sprintf( cAuxdsFeriado, "%s%%", cdsFeriado  );
		else
			strcpy( cAuxdsFeriado, "-1" );

		if( strlennull( cidTipoFeriado ) <= 0 )
			strcpy( cAuxidTipoFeriado, "-1" );

		if( strlennull( cinFeriadoMovel ) <= 0 )
			strcpy( cAuxinFeriadoMovel, "-1" );

		if( strlennull( cidMunicipio ) <= 0 )
			strcpy( cAuxidMunicipio, "-1" );

		if( strlennull( cinRelatorio ) <= 0 )
			strcpy( cAuxinRelatorio, "-1" );

        // Calcula o inicio e fim de paginacao
        iRegistroFim = iPagina * iQtdeRegistros;
        if(iRegistroFim > 0)
            iRegistroInicio = iRegistroFim - iQtdeRegistros;

        ULOG(">>>iRegistroInicio(%d) *iRegistroFim(%d)", iRegistroInicio, iRegistroFim);

		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;

		//Declara um cursor para listar os Registros
		EXEC SQL
			DECLARE
				CursorRelacaoFrdMncParPag CURSOR for
			SELECT
				 IDFERIADO
				,IDTIPOFERIADO
				,DSTIPOFERIADO
				,IDNOMEFERIADO
				,DSFERIADO
				,INFERIADOMOVEL
				,DTDIA
				,IDUF
				,SGUF
				,NMUF
				,IDMUNICIPIO
				,NMMUNICIPIO
				,IDHORARIOVERAO
				,NRHORARIOVERAO
				,DTINICIO
				,DTFIM
				,INRELATORIO
            FROM (
    			SELECT
    				 MUNICIPIOFERIADO.IDFERIADO
    				,MUNICIPIOFERIADO.IDTIPOFERIADO
    				,MUNICIPIOFERIADO.DSTIPOFERIADO
    				,MUNICIPIOFERIADO.IDNOMEFERIADO
    				,MUNICIPIOFERIADO.DSFERIADO
    				,MUNICIPIOFERIADO.INFERIADOMOVEL
    				,TO_CHAR(MUNICIPIOFERIADO.DTDIA, 'DD/MM/YYYY' ) as DTDIA
    				,MUNICIPIOFERIADO.IDUF
    				,MUNICIPIOFERIADO.SGUF
    				,MUNICIPIOFERIADO.NMUF
    				,MUNICIPIOFERIADO.IDMUNICIPIO
    				,MUNICIPIOFERIADO.NMMUNICIPIO
    				,MUNICIPIOFERIADO.IDHORARIOVERAO
    				,MUNICIPIOFERIADO.NRHORARIOVERAO
    				,TO_CHAR( MUNICIPIOFERIADO.DTINICIO, 'DD/MM/YYYY' ) as DTINICIO
    				,TO_CHAR( MUNICIPIOFERIADO.DTFIM, 'DD/MM/YYYY' ) as DTFIM
    				,MUNICIPIOFERIADO.INRELATORIO
                    ,ROWNUM NUMLINHA
    			FROM
    				CONTATOADM.MUNICIPIOFERIADOV01 MUNICIPIOFERIADO
    			WHERE
    				( IDMUNICIPIO = :cAuxidMunicipio OR :cAuxidMunicipio = '-1' )
    			AND
    				( UPPER(DSFERIADO) LIKE UPPER( :cAuxdsFeriado ) OR :cAuxdsFeriado = '-1' )
    			AND
    				( IDTIPOFERIADO = :cAuxidTipoFeriado OR :cAuxidTipoFeriado = '-1' )
    			AND
    				( INFERIADOMOVEL = :cAuxinFeriadoMovel OR :cAuxinFeriadoMovel = '-1' )
    			AND
    				( TO_CHAR( DTDIA, 'DD/MM/YYYY' ) = :cAuxdtDia OR :cAuxdtDia = '-1' )
    			AND
    				( TO_CHAR( DTDIA, 'YYYY' ) = :cAnoAtual OR :cAnoAtual = '-1' )
    			AND
    				( INRELATORIO = :cAuxinRelatorio OR :cAuxinRelatorio = '-1' )
    			ORDER BY
    				MUNICIPIOFERIADO.DTDIA
            )
            WHERE
                NUMLINHA > :iRegistroInicio
                AND NUMLINHA <= :iRegistroFim;



		EXEC SQL WHENEVER SQLERROR GOTO GotoRelacaoFrdMncPar;

		EXEC SQL OPEN CursorRelacaoFrdMncParPag;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
            // Zera a quantidade de registros para retornar o numero de linhas selecionadas
            iQtdeRegistros = 0;

			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stFeriadoRegistro, 0, sizeof(stFeriadoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorRelacaoFrdMncParPag INTO :stFeriadoRegistro:stFeriadoIndicator;
				//Adiciona a classe
				Add(
					(char*)stFeriadoRegistro.stidFeriado.arr,
					(char*)stFeriadoRegistro.stidTipoFeriado.arr,
					(char*)stFeriadoRegistro.stdsTipoFeriado.arr,
					(char*)stFeriadoRegistro.stidNomeFeriado.arr,
					(char*)stFeriadoRegistro.stdsFeriado.arr,
					(char*)stFeriadoRegistro.stinFeriadoMovel.arr,
					(char*)stFeriadoRegistro.stdtDia.arr,
					(char*)stFeriadoRegistro.stidUF.arr,
					(char*)stFeriadoRegistro.stsgUF.arr,
					(char*)stFeriadoRegistro.stnmUF.arr,
					(char*)stFeriadoRegistro.stidMunicipio.arr,
					(char*)stFeriadoRegistro.stnmMunicipio.arr,
					(char*)stFeriadoRegistro.stidHorarioVerao.arr,
					(char*)stFeriadoRegistro.stnrHorarioVerao.arr,
					(char*)stFeriadoRegistro.stdtInicio.arr,
					(char*)stFeriadoRegistro.stdtFim.arr,
					(char*)stFeriadoRegistro.stinRelatorio.arr
				   );
				//conta quantos existem
				iCont++;
        		iQtdeRegistros++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorRelacaoFrdMncParPag;
		}

		ULOG_END("CFeriado::RelacaoFrdMncParPag()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoRelacaoFrdMncPar:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CFeriado::RelacaoFrdMncPar( char* cdtDia,
							    char* cdsFeriado,
					            char* cidTipoFeriado,
							    char* cinFeriadoMovel,
					            char* cinRelatorio,
							    char* cidMunicipio,
					            char* cAno )
{
    ULOG_START("CFeriado::RelacaoFrdMncPar()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char cAuxdtDia[21+1];
		char cAuxdsFeriado[255+1];
		char cAuxidTipoFeriado[21+1];
		char cAuxinFeriadoMovel[21+1];
		char cAuxidMunicipio[21+1];
		char cAuxinRelatorio[21+1];
		struct
		{
			VARCHAR stidFeriado[21+1];
			VARCHAR stidTipoFeriado[21+1];
			VARCHAR stdsTipoFeriado[255+1];
			VARCHAR stidNomeFeriado[21+1];
			VARCHAR stdsFeriado[255+1];
			VARCHAR stinFeriadoMovel[21+1];
			VARCHAR stdtDia[12+1];
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stidMunicipio[21+1];
			VARCHAR stnmMunicipio[255+1];
			VARCHAR stidHorarioVerao[21+1];
			VARCHAR stnrHorarioVerao[21+1];
			VARCHAR stdtInicio[12+1];
			VARCHAR stdtFim[12+1];
			VARCHAR stinRelatorio[21+1];
		} stFeriadoRegistro;
		struct
		{
			short iidFeriado;
			short iidTipoFeriado;
			short idsTipoFeriado;
			short iidNomeFeriado;
			short idsFeriado;
			short iinFeriadoMovel;
			short idtDia;
			short iidUF;
			short isgUF;
			short inmUF;
			short iidMunicipio;
			short inmMunicipio;
			short iidHorarioVerao;
			short inrHorarioVerao;
			short idtInicio;
			short idtFim;
			short iinRelatirio;
		} stFeriadoIndicator;
		char cAnoAtual[10+1];
	EXEC SQL END DECLARE SECTION;

	try
	{
		ZeraFeriado();

		memset( cAuxdtDia, 0, sizeof( cAuxdtDia ) );
		memset( cAuxdsFeriado, 0, sizeof( cAuxdsFeriado ) );
		memset( cAuxidTipoFeriado, 0, sizeof( cAuxidTipoFeriado ) );
		memset( cAuxinFeriadoMovel, 0, sizeof( cAuxinFeriadoMovel ) );
		memset( cAuxidMunicipio, 0, sizeof( cAuxidMunicipio ) );
		memset( cAuxinRelatorio, 0, sizeof( cAuxinRelatorio ) );
		memset( cAnoAtual, 0, sizeof( cAnoAtual ) );

		strcpy( cAuxdtDia, cdtDia );
		strcpy( cAuxdsFeriado, cdsFeriado );
		strcpy( cAuxidTipoFeriado, cidTipoFeriado );
		strcpy( cAuxinFeriadoMovel, cinFeriadoMovel );
		strcpy( cAuxidMunicipio, cidMunicipio );
		strcpy( cAuxinRelatorio, cinRelatorio );
		strcpy( cAnoAtual, cAno );

		if( strlennull( cAno ) <= 0 )
			strcpy( cAnoAtual,"-1" );

		strcpy( cAnoAtual, "-1" );
		if( strlennull( cdtDia ) <= 0 )
			strcpy( cAuxdtDia, "-1" );

		if( strlennull( cdsFeriado ) > 0 )
			sprintf( cAuxdsFeriado, "%s%%", cdsFeriado  );
		else
			strcpy( cAuxdsFeriado, "-1" );

		if( strlennull( cidTipoFeriado ) <= 0 )
			strcpy( cAuxidTipoFeriado, "-1" );

		if( strlennull( cinFeriadoMovel ) <= 0 )
			strcpy( cAuxinFeriadoMovel, "-1" );

		if( strlennull( cidMunicipio ) <= 0 )
			strcpy( cAuxidMunicipio, "-1" );

		if( strlennull( cinRelatorio ) <= 0 )
			strcpy( cAuxinRelatorio, "-1" );

		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;

		//Declara um cursor para listar os Registros
		EXEC SQL
			DECLARE
				CursorRelacaoFrdMncPar CURSOR FOR
			SELECT
				 MUNICIPIOFERIADO.IDFERIADO
				,MUNICIPIOFERIADO.IDTIPOFERIADO
				,MUNICIPIOFERIADO.DSTIPOFERIADO
				,MUNICIPIOFERIADO.IDNOMEFERIADO
				,MUNICIPIOFERIADO.DSFERIADO
				,MUNICIPIOFERIADO.INFERIADOMOVEL
				,TO_CHAR(MUNICIPIOFERIADO.DTDIA, 'DD/MM/YYYY' )
				,MUNICIPIOFERIADO.IDUF
				,MUNICIPIOFERIADO.SGUF
				,MUNICIPIOFERIADO.NMUF
				,MUNICIPIOFERIADO.IDMUNICIPIO
				,MUNICIPIOFERIADO.NMMUNICIPIO
				,MUNICIPIOFERIADO.IDHORARIOVERAO
				,MUNICIPIOFERIADO.NRHORARIOVERAO
				,TO_CHAR( MUNICIPIOFERIADO.DTINICIO, 'DD/MM/YYYY' )
				,TO_CHAR( MUNICIPIOFERIADO.DTFIM, 'DD/MM/YYYY' )
				,MUNICIPIOFERIADO.INRELATORIO
			FROM
				CONTATOADM.MUNICIPIOFERIADOV01 MUNICIPIOFERIADO
			WHERE
				( IDMUNICIPIO = :cAuxidMunicipio OR :cAuxidMunicipio = '-1' )
			AND
				( UPPER(DSFERIADO) LIKE UPPER( :cAuxdsFeriado ) OR :cAuxdsFeriado = '-1' )
			AND
				( IDTIPOFERIADO = :cAuxidTipoFeriado OR :cAuxidTipoFeriado = '-1' )
			AND
				( INFERIADOMOVEL = :cAuxinFeriadoMovel OR :cAuxinFeriadoMovel = '-1' )
			AND
				( TO_CHAR( DTDIA, 'DD/MM/YYYY' ) = :cAuxdtDia OR :cAuxdtDia = '-1' )
			AND
				( TO_CHAR( DTDIA, 'YYYY' ) = :cAnoAtual OR :cAnoAtual = '-1' )
			AND
				( INRELATORIO = :cAuxinRelatorio OR :cAuxinRelatorio = '-1' )
			ORDER BY
				MUNICIPIOFERIADO.DTDIA;


		EXEC SQL WHENEVER SQLERROR GOTO GotoRelacaoFrdMncPar;

		EXEC SQL OPEN CursorRelacaoFrdMncPar;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CFeriado::RelacaoFrdMncPar()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stFeriadoRegistro, 0, sizeof(stFeriadoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorRelacaoFrdMncPar INTO :stFeriadoRegistro:stFeriadoIndicator;
				//Adiciona a classe
				Add(
					(char*)stFeriadoRegistro.stidFeriado.arr,
					(char*)stFeriadoRegistro.stidTipoFeriado.arr,
					(char*)stFeriadoRegistro.stdsTipoFeriado.arr,
					(char*)stFeriadoRegistro.stidNomeFeriado.arr,
					(char*)stFeriadoRegistro.stdsFeriado.arr,
					(char*)stFeriadoRegistro.stinFeriadoMovel.arr,
					(char*)stFeriadoRegistro.stdtDia.arr,
					(char*)stFeriadoRegistro.stidUF.arr,
					(char*)stFeriadoRegistro.stsgUF.arr,
					(char*)stFeriadoRegistro.stnmUF.arr,
					(char*)stFeriadoRegistro.stidMunicipio.arr,
					(char*)stFeriadoRegistro.stnmMunicipio.arr,
					(char*)stFeriadoRegistro.stidHorarioVerao.arr,
					(char*)stFeriadoRegistro.stnrHorarioVerao.arr,
					(char*)stFeriadoRegistro.stdtInicio.arr,
					(char*)stFeriadoRegistro.stdtFim.arr,
					(char*)stFeriadoRegistro.stinRelatorio.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorRelacaoFrdMncPar;
		}
		ULOG_END("CFeriado::RelacaoFrdMncPar()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoRelacaoFrdMncPar:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}


int CFeriado::ListFeriadoPag( char* cdtDia,
						   char* cdsFeriado,
					       char* cidTipoFeriado,
				           char* cinFeriadoMovel,
					       char* cinRelatorio,
					       char* cAno,
                           int iPagina,
                           int &iQtdeRegistros )
{
    ULOG_START("CFeriado::ListFeriadoPag()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char cAuxdtDia[21+1];
		char cAuxdsFeriado[255+1];
		char cAuxidTipoFeriado[21+1];
		char cAuxinFeriadoMovel[21+1];
		char cAuxinRelatorio[21+1];
		struct
		{
			VARCHAR stidFeriado[21+1];
			VARCHAR stidTipoFeriado[21+1];
			VARCHAR stdsTipoFeriado[255+1];
			VARCHAR stidNomeFeriado[21+1];
			VARCHAR stdsFeriado[255+1];
			VARCHAR stinFeriadoMovel[21+1];
			VARCHAR stdtDia[12+1];
			VARCHAR stinRelatorio[21+1];
		} stFeriadoRegistro;
		struct
		{
			short iidFeriado;
			short iidTipoFeriado;
			short idsTipoFeriado;
			short iidNomeFeriado;
			short idsFeriado;
			short iinFeriadoMovel;
			short idtDia;
			short iinRelatorio;
		} stFeriadoIndicator;
		char cAnoAtual[10+1];

		int	iRegistroInicio = 0;
		int iRegistroFim = 0;
	EXEC SQL END DECLARE SECTION;

    ULOG(">>>ListFeriadoPag iPagina(%d) iQtdeRegistros(%d)", iPagina, iQtdeRegistros);

	try
	{
		ZeraFeriado();

		memset( cAuxdtDia, 0, sizeof( cAuxdtDia ) );
		memset( cAuxdsFeriado, 0, sizeof( cAuxdsFeriado ) );
		memset( cAuxidTipoFeriado, 0, sizeof( cAuxidTipoFeriado ) );
		memset( cAuxinFeriadoMovel, 0, sizeof( cAuxinFeriadoMovel ) );
		memset( cAuxinRelatorio, 0, sizeof( cAuxinRelatorio ) );
		memset( cAnoAtual, 0, sizeof( cAnoAtual ) );


		if( strlennull( cAno ) <= 0 )
			strcpy( cAnoAtual, "-1" );
		else
			strcpy( cAnoAtual, cAno );

		if( strlennull( cdtDia ) <= 0 )
			strcpy( cAuxdtDia, "-1" );
		else
			strcpy( cAuxdtDia, cdtDia );
		if( strlennull( cdsFeriado ) > 0 )
			sprintf( cAuxdsFeriado, "%s%%", cdsFeriado  );
		else
			strcpy( cAuxdsFeriado, "-1" );

		if( strlennull( cidTipoFeriado ) <= 0 )
			strcpy( cAuxidTipoFeriado, "-1" );
		else
			strcpy( cAuxidTipoFeriado, cidTipoFeriado );

		if( strlennull( cinFeriadoMovel ) <= 0 )
			strcpy( cAuxinFeriadoMovel, "-1" );
		else
			strcpy( cAuxinFeriadoMovel, cinFeriadoMovel );

		if( strlennull( cinRelatorio ) <= 0 )
			strcpy( cAuxinRelatorio, "-1" );
		else
			strcpy( cAuxinRelatorio, cinRelatorio );


        // Calcula o inicio e fim de paginacao
        iRegistroFim = iPagina * iQtdeRegistros;
        if(iRegistroFim > 0)
            iRegistroInicio = iRegistroFim - iQtdeRegistros;

        ULOG(">>>iRegistroInicio(%d) *iRegistroFim(%d)", iRegistroInicio, iRegistroFim);

		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;

		//Declara um cursor para listar os Registros
        EXEC SQL DECLARE
        CursorListFeriadoPag CURSOR for
            SELECT
                 IDFERIADO
                ,IDTIPOFERIADO
                ,DSTIPOFERIADO
                ,IDNOMEFERIADO
                ,DSFERIADO
                ,INFERIADOMOVEL
                ,DTDIA
                ,INRELATORIO
            FROM (
                    SELECT
                         FERIADO.IDFERIADO
                        ,FERIADO.IDTIPOFERIADO
                        ,TIPOFERIADO.DSTIPOFERIADO
                        ,FERIADO.IDNOMEFERIADO
                        ,NOMEFERIADO.DSFERIADO 
                        ,FERIADO.INFERIADOMOVEL
                        ,TO_CHAR(FERIADO.DTDIA, 'DD/MM/YYYY' ) as DTDIA
                        ,FERIADO.INRELATORIO
                        ,ROWNUM NUMLINHA
                    FROM
                        CALENDARIO.NOMEFERIADO NOMEFERIADO,
                        CALENDARIO.TIPOFERIADO TIPOFERIADO,
                        CALENDARIO.FERIADO FERIADO
                    WHERE 
                        FERIADO.IDNOMEFERIADO = NOMEFERIADO.IDNOMEFERIADO
                    AND 
                        FERIADO.IDTIPOFERIADO = TIPOFERIADO.IDTIPOFERIADO
                    AND
                        ( UPPER(DSFERIADO) LIKE UPPER( :cAuxdsFeriado ) OR :cAuxdsFeriado = '-1' )
                    AND
                        ( IDTIPOFERIADO = :cAuxidTipoFeriado OR :cAuxidTipoFeriado = '-1' )
                    AND
                        ( INFERIADOMOVEL = :cAuxinFeriadoMovel OR :cAuxinFeriadoMovel = '-1' )
                    AND
                        ( TO_CHAR( DTDIA, 'DD/MM/YYYY' ) = :cAuxdtDia OR :cAuxdtDia = '-1' )
                    AND
                        ( TO_CHAR( DTDIA, 'YYYY' ) = :cAnoAtual OR :cAnoAtual = '-1' )
                    AND
                        ( INRELATORIO = :cAuxinRelatorio OR :cAuxinRelatorio = '-1' )
                    ORDER BY
                        FERIADO.DTDIA
            )
            WHERE
                NUMLINHA > :iRegistroInicio
                AND NUMLINHA <= :iRegistroFim;


        /*
        EXEC SQL
			DECLARE
				CursorListFeriadoPag CURSOR for
			SELECT
				 IDFERIADO
				,IDTIPOFERIADO
				,DSTIPOFERIADO
				,IDNOMEFERIADO
				,DSFERIADO
				,INFERIADOMOVEL
				,DTDIA
				,INRELATORIO
            FROM (
    			SELECT
    				 FERIADO.IDFERIADO
    				,FERIADO.IDTIPOFERIADO
    				,FERIADO.DSTIPOFERIADO
    				,FERIADO.IDNOMEFERIADO
    				,FERIADO.DSFERIADO
    				,FERIADO.INFERIADOMOVEL
    				,TO_CHAR(FERIADO.DTDIA, 'DD/MM/YYYY' ) as DTDIA
    				,FERIADO.INRELATORIO
        			,ROWNUM NUMLINHA
    			FROM
    				CALENDARIO.FERIADOB01 FERIADO
    			WHERE
    				( UPPER(DSFERIADO) LIKE UPPER( :cAuxdsFeriado ) OR :cAuxdsFeriado = '-1' )
    			AND
    				( IDTIPOFERIADO = :cAuxidTipoFeriado OR :cAuxidTipoFeriado = '-1' )
    			AND
    				( INFERIADOMOVEL = :cAuxinFeriadoMovel OR :cAuxinFeriadoMovel = '-1' )
    			AND
    				( TO_CHAR( DTDIA, 'DD/MM/YYYY' ) = :cAuxdtDia OR :cAuxdtDia = '-1' )
    			AND
    				( TO_CHAR( DTDIA, 'YYYY' ) = :cAnoAtual OR :cAnoAtual = '-1' )
    			AND
    				( INRELATORIO = :cAuxinRelatorio OR :cAuxinRelatorio = '-1' )
    			ORDER BY
    				FERIADO.DTDIA
            )
            WHERE
                NUMLINHA > :iRegistroInicio
                AND NUMLINHA <= :iRegistroFim;
            */

		EXEC SQL WHENEVER SQLERROR GOTO GotoListFeriado;

		EXEC SQL OPEN CursorListFeriadoPag;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		   ULOG_END("CFeriado::ListFeriadoPag()");
		   return 0;//Erro
		}
		else
		{

            // Zera a quantidade de registros para retornar o numero de linhas selecionadas
            iQtdeRegistros = 0;

    		//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stFeriadoRegistro, 0, sizeof(stFeriadoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorListFeriadoPag INTO :stFeriadoRegistro:stFeriadoIndicator;
				//Adiciona a classe
				Add(
					(char*)stFeriadoRegistro.stidFeriado.arr,
					(char*)stFeriadoRegistro.stidTipoFeriado.arr,
					(char*)stFeriadoRegistro.stdsTipoFeriado.arr,
					(char*)stFeriadoRegistro.stidNomeFeriado.arr,
					(char*)stFeriadoRegistro.stdsFeriado.arr,
					(char*)stFeriadoRegistro.stinFeriadoMovel.arr,
					(char*)stFeriadoRegistro.stdtDia.arr,
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					(char*)stFeriadoRegistro.stinRelatorio.arr

				   );
				//conta quantos existem
				iCont++;
        		iQtdeRegistros++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorListFeriadoPag;
		}
		ULOG_END("CFeriado::ListFeriadoPag()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListFeriado:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CFeriado::ListFeriado( char* cdtDia,
						   char* cdsFeriado,
					       char* cidTipoFeriado,
				           char* cinFeriadoMovel,
					       char* cinRelatorio,
					       char* cAno
						   )
{
    ULOG_START("CFeriado::ListFeriado()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char cAuxdtDia[21+1];
		char cAuxdsFeriado[255+1];
		char cAuxidTipoFeriado[21+1];
		char cAuxinFeriadoMovel[21+1];
		char cAuxinRelatorio[21+1];
		struct
		{
			VARCHAR stidFeriado[21+1];
			VARCHAR stidTipoFeriado[21+1];
			VARCHAR stdsTipoFeriado[255+1];
			VARCHAR stidNomeFeriado[21+1];
			VARCHAR stdsFeriado[255+1];
			VARCHAR stinFeriadoMovel[21+1];
			VARCHAR stdtDia[12+1];
			VARCHAR stinRelatorio[21+1];
		} stFeriadoRegistro;
		struct
		{
			short iidFeriado;
			short iidTipoFeriado;
			short idsTipoFeriado;
			short iidNomeFeriado;
			short idsFeriado;
			short iinFeriadoMovel;
			short idtDia;
			short iinRelatorio;
		} stFeriadoIndicator;
		char cAnoAtual[10+1];
	EXEC SQL END DECLARE SECTION;

	try
	{
		ZeraFeriado();

		memset( cAuxdtDia, 0, sizeof( cAuxdtDia ) );
		memset( cAuxdsFeriado, 0, sizeof( cAuxdsFeriado ) );
		memset( cAuxidTipoFeriado, 0, sizeof( cAuxidTipoFeriado ) );
		memset( cAuxinFeriadoMovel, 0, sizeof( cAuxinFeriadoMovel ) );
		memset( cAuxinRelatorio, 0, sizeof( cAuxinRelatorio ) );
		memset( cAnoAtual, 0, sizeof( cAnoAtual ) );


		if( strlennull( cAno ) <= 0 )
			strcpy( cAnoAtual, "-1" );
		else
			strcpy( cAnoAtual, cAno );

		if( strlennull( cdtDia ) <= 0 )
			strcpy( cAuxdtDia, "-1" );
		else
			strcpy( cAuxdtDia, cdtDia );
		if( strlennull( cdsFeriado ) > 0 )
			sprintf( cAuxdsFeriado, "%s%%", cdsFeriado  );
		else
			strcpy( cAuxdsFeriado, "-1" );

		if( strlennull( cidTipoFeriado ) <= 0 )
			strcpy( cAuxidTipoFeriado, "-1" );
		else
			strcpy( cAuxidTipoFeriado, cidTipoFeriado );

		if( strlennull( cinFeriadoMovel ) <= 0 )
			strcpy( cAuxinFeriadoMovel, "-1" );
		else
			strcpy( cAuxinFeriadoMovel, cinFeriadoMovel );

		if( strlennull( cinRelatorio ) <= 0 )
			strcpy( cAuxinRelatorio, "-1" );
		else
			strcpy( cAuxinRelatorio, cinRelatorio );

		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;

		//Declara um cursor para listar os Registros
		EXEC SQL
			DECLARE
				CursorListFeriado CURSOR FOR
			SELECT
				 FERIADO.IDFERIADO
				,FERIADO.IDTIPOFERIADO
				,TIPOFERIADO.DSTIPOFERIADO
				,FERIADO.IDNOMEFERIADO
				,NOMEFERIADO.DSFERIADO
				,FERIADO.INFERIADOMOVEL
				,TO_CHAR(FERIADO.DTDIA, 'DD/MM/YYYY' )
				,FERIADO.INRELATORIO
			FROM
				/* CALENDARIO.FERIADOB01 FERIADO */
                CALENDARIO.NOMEFERIADO NOMEFERIADO,
                CALENDARIO.TIPOFERIADO TIPOFERIADO,
                CALENDARIO.FERIADO FERIADO
			WHERE
                FERIADO.IDNOMEFERIADO = NOMEFERIADO.IDNOMEFERIADO
            AND 
                FERIADO.IDTIPOFERIADO = TIPOFERIADO.IDTIPOFERIADO
            AND
				( UPPER(DSFERIADO) LIKE UPPER( :cAuxdsFeriado ) OR :cAuxdsFeriado = '-1' )
			AND
				( IDTIPOFERIADO = :cAuxidTipoFeriado OR :cAuxidTipoFeriado = '-1' )
			AND
				( INFERIADOMOVEL = :cAuxinFeriadoMovel OR :cAuxinFeriadoMovel = '-1' )
			AND
				( TO_CHAR( DTDIA, 'DD/MM/YYYY' ) = :cAuxdtDia OR :cAuxdtDia = '-1' )
			AND
				( TO_CHAR( DTDIA, 'YYYY' ) = :cAnoAtual OR :cAnoAtual = '-1' )
			AND
				( INRELATORIO = :cAuxinRelatorio OR :cAuxinRelatorio = '-1' )
			ORDER BY
				FERIADO.DTDIA;


		EXEC SQL WHENEVER SQLERROR GOTO GotoListFeriado;

		EXEC SQL OPEN CursorListFeriado;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CFeriado::ListFeriado()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stFeriadoRegistro, 0, sizeof(stFeriadoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorListFeriado INTO :stFeriadoRegistro:stFeriadoIndicator;
				//Adiciona a classe
				Add(
					(char*)stFeriadoRegistro.stidFeriado.arr,
					(char*)stFeriadoRegistro.stidTipoFeriado.arr,
					(char*)stFeriadoRegistro.stdsTipoFeriado.arr,
					(char*)stFeriadoRegistro.stidNomeFeriado.arr,
					(char*)stFeriadoRegistro.stdsFeriado.arr,
					(char*)stFeriadoRegistro.stinFeriadoMovel.arr,
					(char*)stFeriadoRegistro.stdtDia.arr,
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					(char*)stFeriadoRegistro.stinRelatorio.arr

				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorListFeriado;
		}
		ULOG_END("CFeriado::ListFeriado()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListFeriado:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CFeriado::ExistemFrdMnc(  char* cidFeriado
                             ,char* cidUF )
{
    ULOG_START("CFeriado::ExistemFrdMnc()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidFeriado = cidFeriado;
		char* cAuxidUF = cidUF;
		struct
		{
			VARCHAR stidMunicipio[21+1];
			VARCHAR stnmMunicipio[255+1];
		} stFeriadoRegistro;
		struct
		{
			short iidMunicipio;
			short inmMunicipio;
		} stFeriadoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		ZeraFeriado();

        sqlca.sqlcode=0;
        EXEC SQL WHENEVER NOT FOUND CONTINUE;

        //Declara um cursor para listar os Registros
        EXEC SQL
            DECLARE
                CursorExistemFrdMnc CURSOR FOR
            SELECT
                MUNICIPIO.IDMUNICIPIO
               ,MUNICIPIO.NMMUNICIPIO
            FROM
                APOIO.MUNICIPIO MUNICIPIO
            WHERE
                MUNICIPIO.IDMUNICIPIO NOT IN
                (
                    /*
                    SELECT
                        MUNICIPIOFERIADO.IDMUNICIPIO
                    FROM
                        CALENDARIO.MUNICIPIOFERIADOB01 MUNICIPIOFERIADO
                    WHERE
                        MUNICIPIOFERIADO.IDFERIADO = :cAuxidFeriado
                    AND
                        MUNICIPIOFERIADO.IDUF = :cAuxidUF
                    */
                    
                    SELECT
                        MUNICIPIOFERIADO.IDMUNICIPIO
                    FROM
                        CALENDARIO.NOMEFERIADO NOMEFERIADO ,
                        CALENDARIO.TIPOFERIADO TIPOFERIADO ,
                        CALENDARIO.FERIADO FERIADO ,
                        APOIO.MUNICIPIO MUNICIPIO ,
                        CALENDARIO.MUNICIPIOFERIADO MUNICIPIOFERIADO
                    WHERE 
                        FERIADO.IDNOMEFERIADO = NOMEFERIADO.IDNOMEFERIADO
                    AND 
                        FERIADO.IDTIPOFERIADO = TIPOFERIADO.IDTIPOFERIADO
                    AND
                        MUNICIPIOFERIADO.IDMUNICIPIO = MUNICIPIO.IDMUNICIPIO
                    AND 
                        MUNICIPIOFERIADO.IDFERIADO = FERIADO.IDFERIADO
                    AND
                        MUNICIPIOFERIADO.IDFERIADO = :cAuxidFeriado
                    AND
                        MUNICIPIO.IDUF = :cAuxidUF
                )
			    AND
			    	MUNICIPIO.IDUF = :cAuxidUF
				ORDER BY
					MUNICIPIO.NMMUNICIPIO;

		EXEC SQL WHENEVER SQLERROR GOTO GotoExistemFrdMnc;

		EXEC SQL OPEN CursorExistemFrdMnc;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		   ULOG_END("CFeriado::ExistemFrdMnc()");
		   return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stFeriadoRegistro, 0, sizeof(stFeriadoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorExistemFrdMnc INTO :stFeriadoRegistro:stFeriadoIndicator;
				//Adiciona a classe
				Add(
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					(char*)stFeriadoRegistro.stidMunicipio.arr,
					(char*)stFeriadoRegistro.stnmMunicipio.arr,
					"",
					"",
					"",
					"",
					""

				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorExistemFrdMnc;
		}
		ULOG_END("CFeriado::ExistemFrdMnc()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoExistemFrdMnc:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CFeriado::RelacaoFrdUF( char* cidFeriado )
{
    ULOG_START("CFeriado::RelacaoFrdUF()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidFeriado = cidFeriado;
		struct
		{
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
		} stFeriadoRegistro;
		struct
		{
			short iidUF;
			short isgUF;
			short inmUF;
		} stFeriadoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		ZeraFeriado();

		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;

		//Declara um cursor para listar os Registros
		EXEC SQL
			DECLARE
				CursorRelacaoFrdUF CURSOR FOR
			SELECT
			      UFFERIADO.IDUF
			     ,UFFERIADO.SGUF
			     ,UFFERIADO.NMUF
			FROM
			     CONTATOADM.UFFERIADOV01 UFFERIADO
			WHERE
			     UFFERIADO.IDFERIADO = :cAuxidFeriado;

		EXEC SQL WHENEVER SQLERROR GOTO GotoRelacaoFrdUF;

		EXEC SQL OPEN CursorRelacaoFrdUF;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CFeriado::RelacaoFrdUF()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stFeriadoRegistro, 0, sizeof(stFeriadoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorRelacaoFrdUF INTO :stFeriadoRegistro:stFeriadoIndicator;
				//Adiciona a classe
				Add(
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					(char*)stFeriadoRegistro.stidUF.arr,
					(char*)stFeriadoRegistro.stsgUF.arr,
					(char*)stFeriadoRegistro.stnmUF.arr,
					"",
					"",
					"",
					"",
					"",
					"",
					""

				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorRelacaoFrdUF;
		}
		ULOG_END("CFeriado::RelacaoFrdUF()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoRelacaoFrdUF:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CFeriado::RelacaoFrdUFParPag( char* cdtDia,
							   char* cdsFeriado,
					           char* cidTipoFeriado,
							   char* cinFeriadoMovel,
					           char* cinRelatorio,
							   char* cidUF,
					           char* cAno,
                               int iPagina,
                               int &iQtdeRegistros )
{
    ULOG_START("CFeriado::RelacaoFrdUFParPag()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char cAuxdtDia[21+1];
		char cAuxdsFeriado[255+1];
		char cAuxidTipoFeriado[21+1];
		char cAuxinFeriadoMovel[21+1];
		char cAuxidUF[21+1];
		char cAuxinRelatorio[21+1];
		struct
		{
			VARCHAR stidFeriado[21+1];
			VARCHAR stidTipoFeriado[21+1];
			VARCHAR stdsTipoFeriado[255+1];
			VARCHAR stidNomeFeriado[21+1];
			VARCHAR stdsFeriado[255+1];
			VARCHAR stinFeriadoMovel[21+1];
			VARCHAR stdtDia[12+1];
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stidMunicipio[21+1];
			VARCHAR stnmMunicipio[255+1];
			VARCHAR stidHorarioVerao[21+1];
			VARCHAR stnrHorarioVerao[21+1];
			VARCHAR stdtInicio[12+1];
			VARCHAR stdtFim[12+1];
			VARCHAR stinRelatorio[21+1];
		} stFeriadoRegistro;
		struct
		{
			short iidFeriado;
			short iidTipoFeriado;
			short idsTipoFeriado;
			short iidNomeFeriado;
			short idsFeriado;
			short iinFeriadoMovel;
			short idtDia;
			short iidUF;
			short isgUF;
			short inmUF;
			short iidMunicipio;
			short inmMunicipio;
			short iidHorarioVerao;
			short inrHorarioVerao;
			short idtInicio;
			short idtFim;
			short iinRelatorio;
		} stFeriadoIndicator;
		char cAnoAtual[10+1];

		int	iRegistroInicio = 0;
		int iRegistroFim = 0;
	EXEC SQL END DECLARE SECTION;

    ULOG(">>>RelacaoFrdUFParPag iPagina(%d) iQtdeRegistros(%d)", iPagina, iQtdeRegistros);

	try
	{
		ZeraFeriado();

		memset( cAuxdtDia, 0, sizeof( cAuxdtDia ) );
		memset( cAuxdsFeriado, 0, sizeof( cAuxdsFeriado ) );
		memset( cAuxidTipoFeriado, 0, sizeof( cAuxidTipoFeriado ) );
		memset( cAuxinFeriadoMovel, 0, sizeof( cAuxinFeriadoMovel ) );
		memset( cAuxidUF, 0, sizeof( cAuxidUF ) );
		memset( cAuxinRelatorio, 0, sizeof( cAuxinRelatorio ) );
		memset( cAnoAtual, 0, sizeof( cAnoAtual ) );

		strcpy( cAuxdtDia, cdtDia );
		strcpy( cAuxdsFeriado, cdsFeriado );
		strcpy( cAuxidTipoFeriado, cidTipoFeriado );
		strcpy( cAuxinFeriadoMovel, cinFeriadoMovel );
		strcpy( cAuxidUF, cidUF );
		strcpy( cAuxinRelatorio, cinRelatorio );
		strcpy( cAnoAtual, cAno );

		if( strlennull( cAno ) <= 0 )
			strcpy( cAnoAtual, "-1" );

		if( strlennull( cdtDia ) <= 0 )
			strcpy( cAuxdtDia, "-1" );

		if( strlennull( cdsFeriado ) > 0 )
			sprintf( cAuxdsFeriado, "%s%%", cdsFeriado  );
		else
			strcpy( cAuxdsFeriado, "-1" );

		if( strlennull( cidTipoFeriado ) <= 0 )
			strcpy( cAuxidTipoFeriado, "-1" );

		if( strlennull( cinFeriadoMovel ) <= 0 )
			strcpy( cAuxinFeriadoMovel, "-1" );

		if( strlennull( cidUF ) <= 0 )
			strcpy( cAuxidUF, "-1" );

		if( strlennull( cinRelatorio ) <= 0 )
			strcpy( cAuxinRelatorio, "-1" );


        // Calcula o inicio e fim de paginacao
        iRegistroFim = iPagina * iQtdeRegistros;
        if(iRegistroFim > 0)
            iRegistroInicio = iRegistroFim - iQtdeRegistros;

        ULOG(">>>iRegistroInicio(%d) *iRegistroFim(%d)", iRegistroInicio, iRegistroFim);


		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;

		//Declara um cursor para listar os Registros
		EXEC SQL
			DECLARE
				CursorRelacaoFrdUFParPag CURSOR for
            SELECT
				 IDFERIADO
				,IDTIPOFERIADO
				,DSTIPOFERIADO
				,IDNOMEFERIADO
				,DSFERIADO
				,INFERIADOMOVEL
				,DTDIA
				,IDUF
				,SGUF
				,NMUF
				,IDMUNICIPIO
				,NMMUNICIPIO
				,IDHORARIOVERAO
				,NRHORARIOVERAO
				,DTINICIO
				,DTFIM
				,INRELATORIO
            FROM (
    			SELECT
    				 UFFERIADO.IDFERIADO
    				,UFFERIADO.IDTIPOFERIADO
    				,UFFERIADO.DSTIPOFERIADO
    				,UFFERIADO.IDNOMEFERIADO
    				,UFFERIADO.DSFERIADO
    				,UFFERIADO.INFERIADOMOVEL
    				,TO_CHAR(UFFERIADO.DTDIA, 'DD/MM/YYYY' ) as DTDIA
    				,UFFERIADO.IDUF
    				,UFFERIADO.SGUF
    				,UFFERIADO.NMUF
    				,0  IDMUNICIPIO
    				,'' NMMUNICIPIO
    				,UFFERIADO.IDHORARIOVERAO
    				,UFFERIADO.NRHORARIOVERAO
    				,TO_CHAR( UFFERIADO.DTINICIO, 'DD/MM/YYYY' ) as DTINICIO
    				,TO_CHAR( UFFERIADO.DTFIM, 'DD/MM/YYYY' ) as DTFIM
    				,UFFERIADO.INRELATORIO
        			,ROWNUM NUMLINHA
    			FROM
    				CONTATOADM.UFFERIADOV01 UFFERIADO
    			WHERE
    				( IDUF = :cAuxidUF OR :cAuxidUF = '-1' )
    			AND
    				( UPPER(DSFERIADO) LIKE UPPER( :cAuxdsFeriado ) OR :cAuxdsFeriado = '-1' )
    			AND
    				( IDTIPOFERIADO = :cAuxidTipoFeriado OR :cAuxidTipoFeriado = '-1' )
    			AND
    				( INFERIADOMOVEL = :cAuxinFeriadoMovel OR :cAuxinFeriadoMovel = '-1' )
    			AND
    				( TO_CHAR( DTDIA, 'DD/MM/YYYY' ) = :cAuxdtDia OR :cAuxdtDia = '-1' )
    			AND
    				( TO_CHAR( DTDIA, 'YYYY' ) = :cAnoAtual OR :cAnoAtual = '-1' )
    			AND
    				( INRELATORIO = :cAuxinRelatorio OR :cAuxinRelatorio = '-1' )
    			ORDER BY
    				UFFERIADO.DTDIA
            )
            WHERE
                NUMLINHA > :iRegistroInicio
                AND NUMLINHA <= :iRegistroFim;


		EXEC SQL WHENEVER SQLERROR GOTO GotoRelacaoFrdUFPar;

		EXEC SQL OPEN CursorRelacaoFrdUFParPag;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CFeriado::RelacaoFrdUFParPag()");
			return 0;//Erro
		}
		else
		{

            // Zera a quantidade de registros para retornar o numero de linhas selecionadas
            iQtdeRegistros = 0;

			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stFeriadoRegistro, 0, sizeof(stFeriadoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorRelacaoFrdUFParPag INTO :stFeriadoRegistro:stFeriadoIndicator;
				//Adiciona a classe
				Add(
					(char*)stFeriadoRegistro.stidFeriado.arr,
					(char*)stFeriadoRegistro.stidTipoFeriado.arr,
					(char*)stFeriadoRegistro.stdsTipoFeriado.arr,
					(char*)stFeriadoRegistro.stidNomeFeriado.arr,
					(char*)stFeriadoRegistro.stdsFeriado.arr,
					(char*)stFeriadoRegistro.stinFeriadoMovel.arr,
					(char*)stFeriadoRegistro.stdtDia.arr,
					(char*)stFeriadoRegistro.stidUF.arr,
					(char*)stFeriadoRegistro.stsgUF.arr,
					(char*)stFeriadoRegistro.stnmUF.arr,
					(char*)stFeriadoRegistro.stidMunicipio.arr,
					(char*)stFeriadoRegistro.stnmMunicipio.arr,
					(char*)stFeriadoRegistro.stidHorarioVerao.arr,
					(char*)stFeriadoRegistro.stnrHorarioVerao.arr,
					(char*)stFeriadoRegistro.stdtInicio.arr,
					(char*)stFeriadoRegistro.stdtFim.arr,
					(char*)stFeriadoRegistro.stinRelatorio.arr

				   );
				//conta quantos existem
				iCont++;
                iQtdeRegistros++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorRelacaoFrdUFParPag;
		}
		ULOG_END("CFeriado::RelacaoFrdUFParPag()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoRelacaoFrdUFPar:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CFeriado::RelacaoFrdUFPar( char* cdtDia,
							   char* cdsFeriado,
					           char* cidTipoFeriado,
							   char* cinFeriadoMovel,
					           char* cinRelatorio,
							   char* cidUF,
					           char* cAno )
{
    ULOG_START("CFeriado::RelacaoFrdUFPar()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char cAuxdtDia[21+1];
		char cAuxdsFeriado[255+1];
		char cAuxidTipoFeriado[21+1];
		char cAuxinFeriadoMovel[21+1];
		char cAuxidUF[21+1];
		char cAuxinRelatorio[21+1];
		struct
		{
			VARCHAR stidFeriado[21+1];
			VARCHAR stidTipoFeriado[21+1];
			VARCHAR stdsTipoFeriado[255+1];
			VARCHAR stidNomeFeriado[21+1];
			VARCHAR stdsFeriado[255+1];
			VARCHAR stinFeriadoMovel[21+1];
			VARCHAR stdtDia[12+1];
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stidMunicipio[21+1];
			VARCHAR stnmMunicipio[255+1];
			VARCHAR stidHorarioVerao[21+1];
			VARCHAR stnrHorarioVerao[21+1];
			VARCHAR stdtInicio[12+1];
			VARCHAR stdtFim[12+1];
			VARCHAR stinRelatorio[21+1];
		} stFeriadoRegistro;
		struct
		{
			short iidFeriado;
			short iidTipoFeriado;
			short idsTipoFeriado;
			short iidNomeFeriado;
			short idsFeriado;
			short iinFeriadoMovel;
			short idtDia;
			short iidUF;
			short isgUF;
			short inmUF;
			short iidMunicipio;
			short inmMunicipio;
			short iidHorarioVerao;
			short inrHorarioVerao;
			short idtInicio;
			short idtFim;
			short iinRelatorio;
		} stFeriadoIndicator;
		char cAnoAtual[10+1];
	EXEC SQL END DECLARE SECTION;

	try
	{
		ZeraFeriado();

		memset( cAuxdtDia, 0, sizeof( cAuxdtDia ) );
		memset( cAuxdsFeriado, 0, sizeof( cAuxdsFeriado ) );
		memset( cAuxidTipoFeriado, 0, sizeof( cAuxidTipoFeriado ) );
		memset( cAuxinFeriadoMovel, 0, sizeof( cAuxinFeriadoMovel ) );
		memset( cAuxidUF, 0, sizeof( cAuxidUF ) );
		memset( cAuxinRelatorio, 0, sizeof( cAuxinRelatorio ) );
		memset( cAnoAtual, 0, sizeof( cAnoAtual ) );

		strcpy( cAuxdtDia, cdtDia );
		strcpy( cAuxdsFeriado, cdsFeriado );
		strcpy( cAuxidTipoFeriado, cidTipoFeriado );
		strcpy( cAuxinFeriadoMovel, cinFeriadoMovel );
		strcpy( cAuxidUF, cidUF );
		strcpy( cAuxinRelatorio, cinRelatorio );
		strcpy( cAnoAtual, cAno );

		if( strlennull( cAno ) <= 0 )
			strcpy( cAnoAtual, "-1" );

		if( strlennull( cdtDia ) <= 0 )
			strcpy( cAuxdtDia, "-1" );

		if( strlennull( cdsFeriado ) > 0 )
			sprintf( cAuxdsFeriado, "%s%%", cdsFeriado  );
		else
			strcpy( cAuxdsFeriado, "-1" );

		if( strlennull( cidTipoFeriado ) <= 0 )
			strcpy( cAuxidTipoFeriado, "-1" );

		if( strlennull( cinFeriadoMovel ) <= 0 )
			strcpy( cAuxinFeriadoMovel, "-1" );

		if( strlennull( cidUF ) <= 0 )
			strcpy( cAuxidUF, "-1" );

		if( strlennull( cinRelatorio ) <= 0 )
			strcpy( cAuxinRelatorio, "-1" );

		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;

		//Declara um cursor para listar os Registros
		EXEC SQL
			DECLARE
				CursorRelacaoFrdUFPar CURSOR FOR
			SELECT
				 UFFERIADO.IDFERIADO
				,UFFERIADO.IDTIPOFERIADO
				,UFFERIADO.DSTIPOFERIADO
				,UFFERIADO.IDNOMEFERIADO
				,UFFERIADO.DSFERIADO
				,UFFERIADO.INFERIADOMOVEL
				,TO_CHAR(UFFERIADO.DTDIA, 'DD/MM/YYYY' )
				,UFFERIADO.IDUF
				,UFFERIADO.SGUF
				,UFFERIADO.NMUF
				,0  IDMUNICIPIO
				,'' NMMUNICIPIO
				,UFFERIADO.IDHORARIOVERAO
				,UFFERIADO.NRHORARIOVERAO
				,TO_CHAR( UFFERIADO.DTINICIO, 'DD/MM/YYYY' )
				,TO_CHAR( UFFERIADO.DTFIM, 'DD/MM/YYYY' )
				,UFFERIADO.INRELATORIO
			FROM
				CONTATOADM.UFFERIADOV01 UFFERIADO
			WHERE
				( IDUF = :cAuxidUF OR :cAuxidUF = '-1' )
			AND
				( UPPER(DSFERIADO) LIKE UPPER( :cAuxdsFeriado ) OR :cAuxdsFeriado = '-1' )
			AND
				( IDTIPOFERIADO = :cAuxidTipoFeriado OR :cAuxidTipoFeriado = '-1' )
			AND
				( INFERIADOMOVEL = :cAuxinFeriadoMovel OR :cAuxinFeriadoMovel = '-1' )
			AND
				( TO_CHAR( DTDIA, 'DD/MM/YYYY' ) = :cAuxdtDia OR :cAuxdtDia = '-1' )
			AND
				( TO_CHAR( DTDIA, 'YYYY' ) = :cAnoAtual OR :cAnoAtual = '-1' )
			AND
				( INRELATORIO = :cAuxinRelatorio OR :cAuxinRelatorio = '-1' )
			ORDER BY
				UFFERIADO.DTDIA;


		EXEC SQL WHENEVER SQLERROR GOTO GotoRelacaoFrdUFPar;

		EXEC SQL OPEN CursorRelacaoFrdUFPar;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CFeriado::RelacaoFrdUFPar()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stFeriadoRegistro, 0, sizeof(stFeriadoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorRelacaoFrdUFPar INTO :stFeriadoRegistro:stFeriadoIndicator;
				//Adiciona a classe
				Add(
					(char*)stFeriadoRegistro.stidFeriado.arr,
					(char*)stFeriadoRegistro.stidTipoFeriado.arr,
					(char*)stFeriadoRegistro.stdsTipoFeriado.arr,
					(char*)stFeriadoRegistro.stidNomeFeriado.arr,
					(char*)stFeriadoRegistro.stdsFeriado.arr,
					(char*)stFeriadoRegistro.stinFeriadoMovel.arr,
					(char*)stFeriadoRegistro.stdtDia.arr,
					(char*)stFeriadoRegistro.stidUF.arr,
					(char*)stFeriadoRegistro.stsgUF.arr,
					(char*)stFeriadoRegistro.stnmUF.arr,
					(char*)stFeriadoRegistro.stidMunicipio.arr,
					(char*)stFeriadoRegistro.stnmMunicipio.arr,
					(char*)stFeriadoRegistro.stidHorarioVerao.arr,
					(char*)stFeriadoRegistro.stnrHorarioVerao.arr,
					(char*)stFeriadoRegistro.stdtInicio.arr,
					(char*)stFeriadoRegistro.stdtFim.arr,
					(char*)stFeriadoRegistro.stinRelatorio.arr

				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorRelacaoFrdUFPar;
		}
		ULOG_END("CFeriado::RelacaoFrdUFPar()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoRelacaoFrdUFPar:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}


int CFeriado::ExistemFrdUF( char* cidFeriado )
{
    ULOG_START("CFeriado::ExistemFrdUF()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidFeriado = cidFeriado;
		struct
		{
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
		} stFeriadoRegistro;
		struct
		{
			short iidUF;
			short isgUF;
			short inmUF;
		} stFeriadoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		ZeraFeriado();

		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;

		//Declara um cursor para listar os Registros
		EXEC SQL
			DECLARE
				CursorExistemFrdUF CURSOR FOR
			SELECT
				 UF.IDUF
				,UF.SGUF
				,UF.NMUF
			FROM
			    APOIO.UF UF
			WHERE
			    UF.IDUF NOT IN
			    (
			    	SELECT
			        	UFFERIADO.IDUF
			        FROM
			            CALENDARIO.UFFERIADO UFFERIADO
			        WHERE
			            UFFERIADO.IDFERIADO = :cAuxidFeriado
			    )
				ORDER BY
					UF.NMUF;

		EXEC SQL WHENEVER SQLERROR GOTO GotoExistemFrdUF;

		EXEC SQL OPEN CursorExistemFrdUF;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		   ULOG_END("CFeriado::ExistemFrdUF()");
		   return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stFeriadoRegistro, 0, sizeof(stFeriadoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorExistemFrdUF INTO :stFeriadoRegistro:stFeriadoIndicator;
				//Adiciona a classe
				Add(
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					(char*)stFeriadoRegistro.stidUF.arr,
					(char*)stFeriadoRegistro.stsgUF.arr,
					(char*)stFeriadoRegistro.stnmUF.arr,
					"",
					"",
					"",
					"",
					"",
					"",
					""

				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorExistemFrdUF;
		}
		ULOG_END("CFeriado::ExistemFrdUF()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoExistemFrdUF:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CFeriado::Update(
						char* cidFeriado,
						char* cidTipoFeriado,
						char* cidNomeFeriado,
						char* cdsNomeFeriado,
						char* cinFeriadoMovel,
						char* cdtDia,
					    char* cinRelatorio,
						char* cidUsuarioAlteracao
					)
{
    ULOG_START("CFeriado::Update()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR stAuxidNomeFeriado[21+1];
		VARCHAR stAuxdsFeriado[255+1];
		char* cAuxidTipoFeriado = cidTipoFeriado;
		char* cAuxidNomeFeriado = cidNomeFeriado;
		char* cAuxinFeriadoMovel = cinFeriadoMovel;
		char* cAuxdtDia = cdtDia;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
		char* cAuxdsNomeFeriado = cdsNomeFeriado;
		char* cAuxidFeriado = cidFeriado;
		char* cAuxinRelatorio = cinRelatorio;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	//Zera a estrutura da classe
	ZeraFeriado();
	ListId( cAuxidFeriado );
	//Se mudar o tipo de feriado apaga as relacoes com municipio e ou UF
	if( strcmp( Registro()->cidTipoFeriado, cidTipoFeriado ) != 0 )
		ApagaRelacoes( cAuxidFeriado );

	memset( &stAuxidNomeFeriado, 0, sizeof(stAuxidNomeFeriado) );
	memset( &stAuxdsFeriado, 0, sizeof(stAuxdsFeriado) );

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;

	if( strlennull( cAuxidNomeFeriado ) <= 0 )
	{
		EXEC SQL
			SELECT
				IDNOMEFERIADO
			INTO
				:stAuxidNomeFeriado
			FROM
				CALENDARIO.NOMEFERIADO
			WHERE
				UPPER( DSFERIADO ) = UPPER( :cAuxdsNomeFeriado )
			AND
				ROWNUM <= 1;

		if( stAuxidNomeFeriado.len <= 0 )
		{
			//Pega um id unico e sequencia para a insercao
			EXEC SQL
				SELECT
					CALENDARIO.NOMEFERIADOSQ.NEXTVAL
				INTO
					:stAuxidNomeFeriado
				FROM
					DUAL;

			EXEC SQL
				INSERT INTO CALENDARIO.NOMEFERIADO
					(IDNOMEFERIADO
					,DSFERIADO
					,IDUSUARIOALTERACAO
					,DTULTIMAALTERACAO)
				VALUES
					(:stAuxidNomeFeriado
					,:cAuxdsNomeFeriado
					,:cAuxidUsuarioAlteracao
					,SYSDATE);
		}
		cAuxidNomeFeriado = (char*)stAuxidNomeFeriado.arr;
	}

	//Realiza o update
	EXEC SQL
		UPDATE
			CALENDARIO.FERIADO
		SET
			IDTIPOFERIADO = :cAuxidTipoFeriado,
			IDNOMEFERIADO = :cAuxidNomeFeriado,
			INFERIADOMOVEL = :cAuxinFeriadoMovel,
			DTDIA = TO_DATE( :cAuxdtDia, 'DD/MM/YYYY' ),
			IDUSUARIOALTERACAO = :cAuxidUsuarioAlteracao,
			DTULTIMAALTERACAO = SYSDATE,
			INRELATORIO = :cAuxinRelatorio
		WHERE
			IDFERIADO = :cAuxidFeriado;

	//Zera a estrutura da classe
	ZeraFeriado();

	//Recupera o Feriado atual
	ListId( cAuxidFeriado );

    ULOG_END("CFeriado::Update()");
	return 1;//Sucesso

GotoUpdate:
	if(sqlca.sqlcode==-2291)
		return 2;
	else if(sqlca.sqlcode==-1)
		return 3;
	else
	{
		ULOG("\nCFeriado::Update:Erro Oracle: %d\n", sqlca.sqlcode );
		ULOG("\nCFeriado::Update:Descrição..: %s\n", sqlca.sqlerrm.sqlerrmc );
		ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		throw TuxBasicOraException(sqlca.sqlcode);
	}
}

int CFeriado::Delete( char* cidFeriado )
{
    ULOG_START("CFeriado::Delete()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidFeriado = cidFeriado;
	EXEC SQL END DECLARE SECTION;

	//Zera a estrutura da classe
	ZeraFeriado();

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
	sqlca.sqlcode=0;
	//Apaga todas as relacoes com municipio
	EXEC SQL
		DELETE FROM
			CALENDARIO.MUNICIPIOFERIADO
		WHERE
			IDFERIADO = :cAuxidFeriado;

	//Apaga todas as relacoes com UF
	EXEC SQL
		DELETE FROM
			CALENDARIO.UFFERIADO
		WHERE
			IDFERIADO = :cAuxidFeriado;

	//Apaga o feriado
	EXEC SQL
		DELETE FROM
			CALENDARIO.FERIADO
		WHERE
			IDFERIADO = :cAuxidFeriado;

	ULOG_END("CFeriado::Delete()");
	return 0;//Sucesso

GotoDelete:
	if( sqlca.sqlcode == -2292 )
		return 2;
	else
	{
		ULOG("\nCFeriado::Delete:Erro Oracle: %d\n", sqlca.sqlcode );
		ULOG("\nCFeriado::Delete:Descrição..: %s\n", sqlca.sqlerrm.sqlerrmc );
		ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
		throw TuxBasicOraException(sqlca.sqlcode);
	}
}


int CFeriado::ApagaRelacoes( char* cidFeriado )
{
    ULOG_START("CFeriado::ApagaRelacoes()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidFeriado = cidFeriado;
	EXEC SQL END DECLARE SECTION;

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoApagaRelacoes;
	sqlca.sqlcode=0;
	//Apaga todas as relacoes com municipio
	EXEC SQL
		DELETE FROM
			CALENDARIO.MUNICIPIOFERIADO
		WHERE
			IDFERIADO = :cAuxidFeriado;

	//Apaga todas as relacoes com UF
	EXEC SQL
		DELETE FROM
			CALENDARIO.UFFERIADO
		WHERE
			IDFERIADO = :cAuxidFeriado;

	ULOG_END("CFeriado::ApagaRelacoes()");
	return 0;//Sucesso

GotoApagaRelacoes:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if( sqlca.sqlcode == -2292 )
		return 2;
	else
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CFeriado::ListId( char* cidFeriado )
{
    ULOG_START("CFeriado::ListId()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidFeriado = cidFeriado;
		struct
		{
			VARCHAR stidFeriado[21+1];
			VARCHAR stidTipoFeriado[21+1];
			VARCHAR stdsTipoFeriado[255+1];
			VARCHAR stidNomeFeriado[21+1];
			VARCHAR stdsFeriado[255+1];
			VARCHAR stinFeriadoMovel[21+1];
			VARCHAR stdtDia[12+1];
			VARCHAR stinRelatorio[21+1];
		} stFeriadoRegistro;
		struct
		{
			short iidFeriado;
			short iidTipoFeriado;
			short idsTipoFeriado;
			short iidNomeFeriado;
			short idsFeriado;
			short iinFeriadoMovel;
			short idtDia;
			short iinRelatorio;
		} stFeriadoIndicator;
	EXEC SQL END DECLARE SECTION;

    //Processamento Principal
    try
    {
        ZeraFeriado();

        sqlca.sqlcode=0;
        EXEC SQL WHENEVER NOT FOUND CONTINUE;

        //Declara um cursor para listar os Registros
        EXEC SQL DECLARE CursorListId 
        CURSOR FOR
        SELECT
             FERIADO.IDFERIADO
            ,FERIADO.IDTIPOFERIADO
            ,FERIADO.DSTIPOFERIADO
            ,FERIADO.IDNOMEFERIADO
            ,FERIADO.DSFERIADO
            ,FERIADO.INFERIADOMOVEL
            ,TO_CHAR(FERIADO.DTDIA, 'DD/MM/YYYY' )
            ,FERIADO.INRELATORIO
        FROM
            CALENDARIO.NOMEFERIADO NOMEFERIADO,
            CALENDARIO.TIPOFERIADO TIPOFERIADO,
            CALENDARIO.FERIADO FERIADO
        WHERE
            FERIADO.IDNOMEFERIADO = NOMEFERIADO.IDNOMEFERIADO
        AND 
            FERIADO.IDTIPOFERIADO = TIPOFERIADO.IDTIPOFERIADO
        AND
            FERIADO.IDFERIADO = :cAuxidFeriado
        ORDER BY
            FERIADO.DTDIA;

        EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
        EXEC SQL OPEN CursorListId;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CFeriado::ListId()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stFeriadoRegistro, 0, sizeof(stFeriadoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorListId INTO :stFeriadoRegistro:stFeriadoIndicator;
				//Adiciona a classe
				Add(
					(char*)stFeriadoRegistro.stidFeriado.arr,
					(char*)stFeriadoRegistro.stidTipoFeriado.arr,
					(char*)stFeriadoRegistro.stdsTipoFeriado.arr,
					(char*)stFeriadoRegistro.stidNomeFeriado.arr,
					(char*)stFeriadoRegistro.stdsFeriado.arr,
					(char*)stFeriadoRegistro.stinFeriadoMovel.arr,
					(char*)stFeriadoRegistro.stdtDia.arr,
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					(char*)stFeriadoRegistro.stinRelatorio.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorListId;
		}
		ULOG_END("CFeriado::ListId()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CFeriado::ListAll( void )
{
	return 1;
}

int CFeriado::List( char* cdtDia,
				    char* cdsFeriado,
		            char* cidTipoFeriado,
				    char* cinFeriadoMovel,
					char* cinRelatorio,
				    char* cidUF,
				    char* cidMunicipio )
{
	if( strlennull( cidMunicipio ) <= 0 )
	{
		if( strlennull( cidUF ) > 0 )
		{
			RelacaoFrdUFPar( cdtDia,
							 cdsFeriado,
						     cidTipoFeriado,
							 cinFeriadoMovel,
					         cinRelatorio,
							 cidUF,
							 "");
		}
		else
		{
			ListFeriado( cdtDia,
						 cdsFeriado,
				         cidTipoFeriado,
						 cinFeriadoMovel,
					     cinRelatorio,
					     "");
		}
	}
	else
	{

		RelacaoFrdMncPar( cdtDia,
						  cdsFeriado,
					      cidTipoFeriado,
						  cinFeriadoMovel,
					      cinRelatorio,
						  cidMunicipio,
						  "");
	}

	return 1;
}

int CFeriado::ListPag( char* cdtDia,
				    char* cdsFeriado,
		            char* cidTipoFeriado,
				    char* cinFeriadoMovel,
					char* cinRelatorio,
				    char* cidUF,
				    char* cidMunicipio,
					char* cAno,
                    int iPagina,
                    int &iQtdRegistros )
{
	if( strlennull( cidMunicipio ) <= 0 )
	{
        ULOG("Local 1");

		if( strlennull( cidUF ) > 0 )
		{
            ULOG("Local 2");

			RelacaoFrdUFParPag( cdtDia,
							 cdsFeriado,
						     cidTipoFeriado,
							 cinFeriadoMovel,
					         cinRelatorio,
							 cidUF,
							 cAno,
                             iPagina,
                             iQtdRegistros);
		}
		else
		{
            ULOG("Local 3");

			ListFeriadoPag( cdtDia,
						 cdsFeriado,
				         cidTipoFeriado,
						 cinFeriadoMovel,
					     cinRelatorio,
						 cAno,
                         iPagina,
                         iQtdRegistros);
		}
	}
	else
	{
        ULOG("Local 4");

		RelacaoFrdMncParPag( cdtDia,
						  cdsFeriado,
					      cidTipoFeriado,
						  cinFeriadoMovel,
					      cinRelatorio,
						  cidMunicipio,
						  cAno,
                          iPagina,
                          iQtdRegistros);

	}

	return 1;
}


int CFeriado::DiasUteis( char* cDias, char* cDataRet )
{
    ULOG_START("CFeriado::DiasUteis()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxDias = cDias;
		VARCHAR stdtDia[12+1];
		VARCHAR stDataAtual[21+1];
	EXEC SQL END DECLARE SECTION;
	try
	{
		//Zera a estrutura da classe
		ZeraFeriado();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDiasUteis;
		sqlca.sqlcode=0;

		memset( &stDataAtual, 0, sizeof( stDataAtual ) );

		//Pega a data do sistema + 1
		EXEC SQL
			SELECT TO_CHAR(SYSDATE+1, 'dd/mm/yyyy')
			  INTO :stDataAtual
			  FROM DUAL;

		//Declara um cursor para listar os IDs
	   	EXEC SQL
			SELECT MAX(DIASSEMANA.DTDIASEMANA) DATAFINAL
			  INTO :stdtDia
			  FROM (SELECT TO_CHAR(:stDataAtual, 'dd/mm/yyyy') + DIA.DIA AS DTDIASEMANA,
						   FERIADO.DTDIA
					  FROM (SELECT CALENDARIO.FERIADO.DTDIA
							  FROM CALENDARIO.FERIADO
							 WHERE CALENDARIO.FERIADO.IDTIPOFERIADO = 1 //Feriado Nacional
						   ) FERIADO,
						   CALENDARIO.DIA DIA
					 WHERE TO_CHAR(TO_CHAR(:stDataAtual, 'dd/mm/yyyy') + DIA.DIA, 'D') NOT IN (1, 7)
						   AND TO_CHAR(:stDataAtual, 'dd/mm/yyyy') + DIA.DIA = FERIADO.DTDIA(+)
					 ORDER BY DIA.DIA
					) DIASSEMANA
			 WHERE DTDIA IS NULL AND ROWNUM <= :cAuxDias;
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CFeriado::DiasUteis()");
	//Verifica se nao house erro ORACLE
	if(sqlca.sqlcode)
		return 0;//Erro
	else
	{
		stdtDia.arr[stdtDia.len] = 0;
		strcpy( cDataRet, (char*)stdtDia.arr );
	}
	return 1;//Sucesso

GotoDiasUteis:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CFeriado::DiasUteisUF( char* cDias, char* cUF, char* cDataRet )
{
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxUF = cUF;
		char* cAuxDias = cDias;
		VARCHAR stdtDia[12+1];
		VARCHAR stDataAtual[21+1];
	EXEC SQL END DECLARE SECTION;
	try
	{
		//Zera a estrutura da classe
		ZeraFeriado();

		memset( &stDataAtual, 0, sizeof( stDataAtual ) );

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND continue;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDiasUteisUF;
		sqlca.sqlcode=0;

		//Pega a data do sistema + 1
		EXEC SQL
			SELECT TO_CHAR(SYSDATE+1, 'dd/mm/yyyy')
			  INTO :stDataAtual
			  FROM DUAL;

		//Declara um cursor para listar os IDs
	   	EXEC SQL
			SELECT MAX(DIASSEMANA.DTDIASEMANA) DATAFINAL
			  INTO :stdtDia
			  FROM (SELECT TO_CHAR(:stDataAtual, 'dd/mm/yyyy') + DIA.DIA AS DTDIASEMANA,
						   FERIADO.DTDIA
					  FROM (SELECT CALENDARIO.FERIADO.DTDIA
							  FROM CALENDARIO.FERIADO,
								   APOIO.UF UF,
								   APOIO.AREAREGISTRO AREAREGISTRO,
								   CUSTOMER.UFOPERADORA UFOPERADORA
							 WHERE UF.IDUF = UFOPERADORA.IDUF
								   AND AREAREGISTRO.IDUFOPERADORA = UFOPERADORA.IDUFOPERADORA
								   AND UF.SGUF = :cAuxUF
						   ) FERIADO,
						   CALENDARIO.DIA DIA
					 WHERE TO_CHAR(TO_CHAR(:stDataAtual, 'dd/mm/yyyy') + DIA.DIA, 'D') NOT IN (1, 7)
						   AND TO_CHAR(:stDataAtual, 'dd/mm/yyyy') + DIA.DIA = FERIADO.DTDIA(+)
					 ORDER BY DIA.DIA
					) DIASSEMANA
			 WHERE DTDIA IS NULL AND ROWNUM <= :cAuxDias;
	}
	catch(...)
	{
		throw;
	}
	//Verifica se nao house erro ORACLE
	if(sqlca.sqlcode)
		return 0;//Erro
	else
	{
		stdtDia.arr[stdtDia.len] = 0;
		strcpy( cDataRet, (char*)stdtDia.arr );
		return 1;//Sucesso
	}

GotoDiasUteisUF:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CFeriado::DiasUteisUFId( char* cDias, char* cidUF, char* cDataRet )
{
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidUF = cidUF;
		char* cAuxDias = cDias;
		VARCHAR stdtDia[12+1];
		VARCHAR stDataAtual[21+1];
	EXEC SQL END DECLARE SECTION;
	try
	{
		//Zera a estrutura da classe
		ZeraFeriado();

		memset( &stDataAtual, 0, sizeof( stDataAtual ) );

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDiasUteisUFId;
		sqlca.sqlcode=0;

		EXEC SQL
			SELECT TO_CHAR(SYSDATE+1, 'dd/mm/yyyy')
			  INTO :stDataAtual
			  FROM DUAL;

		//Declara um cursor para listar os IDs
	   	EXEC SQL
			SELECT MAX(DIASSEMANA.DTDIASEMANA) DATAFINAL
			  INTO :stdtDia
			  FROM (SELECT TO_CHAR(:stDataAtual, 'dd/mm/yyyy') + DIA.DIA AS DTDIASEMANA,
						   FERIADO.DTDIA
					  FROM (SELECT CALENDARIO.FERIADO.DTDIA
							  FROM CALENDARIO.FERIADO,
								   APOIO.AREAREGISTRO AREAREGISTRO,
								   CUSTOMER.UFOPERADORA UFOPERADORA
							 WHERE AREAREGISTRO.IDUFOPERADORA = UFOPERADORA.IDUFOPERADORA
								   AND UFOPERADORA.IDUF = :cAuxidUF
						   ) FERIADO,
						   CALENDARIO.DIA DIA
					 WHERE TO_CHAR(TO_CHAR(:stDataAtual, 'dd/mm/yyyy') + DIA.DIA, 'D') NOT IN (1, 7)
						   AND TO_CHAR(:stDataAtual, 'dd/mm/yyyy') + DIA.DIA = FERIADO.DTDIA(+)
					 ORDER BY DIA.DIA
					) DIASSEMANA
			 WHERE DTDIA IS NULL AND ROWNUM <= :cAuxDias;
	}
	catch(...)
	{
		throw;
	}
	//Verifica se nao house erro ORACLE
	if(sqlca.sqlcode)
		return 0;//Erro
	else
	{
		stdtDia.arr[stdtDia.len] = 0;
		strcpy( cDataRet, (char*)stdtDia.arr );
		return 1;//Sucesso
	}

GotoDiasUteisUFId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CFeriado::DDDToUF( char* cDDDin, char* cUFout )
{
    ULOG_START("CFeriado::DDDToUF()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxDDDin = cDDDin;
		VARCHAR stidUF[12+1];
	EXEC SQL END DECLARE SECTION;
	try
	{
		memset( &stidUF, 0, sizeof( stidUF ) );

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDDDToUF;
		sqlca.sqlcode=0;

		//Recebendo um DDD, retorna uma UF
		EXEC SQL
			SELECT UFOPERADORA.IDUF
			  INTO :stidUF
			  FROM APOIO.AREAREGISTRO AREAREGISTRO,
			       CUSTOMER.UFOPERADORA UFOPERADORA
			 WHERE UFOPERADORA.IDUFOPERADORA = AREAREGISTRO.IDUFOPERADORA
	       	   AND AREAREGISTRO.CDAREAREGISTRO = :cAuxDDDin;

		//Caso nao localize o DDD, entao usa a UF de Sao Paulo
		if( stidUF.len <= 0 )
		{
			EXEC SQL
				SELECT UF.IDUF
			  	  INTO :stidUF
				  FROM APOIO.UF UF
				 WHERE UF.SGUF = 'SP';
		}
		stidUF.arr[stidUF.len] = 0;
		strcpy( cUFout, (char*)stidUF.arr );
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CFeriado::DDDToUF()");
	return 1;//Sucesso

GotoDDDToUF:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

char* CFeriado::DiaUtil( char* cDDD, char* cDias )
{
	char cidUF[12+1];
	char cDataRet[12+1];
	try
	{
		memset( &cidUF, 0, sizeof( cidUF ) );
		memset( &cDataRet, 0, sizeof( cDataRet ) );
		if( DDDToUF( cDDD, cidUF ) )
		{
			if( !DiasUteisUFId( cDias, cidUF, cDataRet ) )
				return 0;//Erro ORACLE
			else
				Add(
					"",
					"",
					"",
					"",
					"",
					"",
					cDataRet,
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					""

				 );

		}
		else
			return 0;//Erro ORACLE
	}
	catch(...)
	{
		throw;
	}
	return Registro(0)->cdtDia;
}

char* CFeriado::DiaUtil( int iDDD, int iDias )
{
	char cDDD[12+1];
	char cDias[12+1];
	memset( &cDDD, 0, sizeof( cDDD ) );
	memset( &cDias, 0, sizeof( cDias ) );
	sprintf( cDDD, "%d", iDDD );
	sprintf( cDias, "%d", iDias );
	return DiaUtil( cDDD, cDias );
}

void CFeriado::GetXml( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			xml->createTag(cNomeTag);
			//Adiciona a proprieda necessaria para o Weblogic
			xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{
				//Adiciona as tags necessarias
				xml->addItem("idFeriado", Registro(x)->cidFeriado );
				xml->addItem("idTipoFeriado", Registro(x)->cidTipoFeriado );
				xml->addItem("idNomeFeriado", Registro(x)->cidNomeFeriado );
				xml->addItem("inFeriadoMovel", Registro(x)->cinFeriadoMovel );
				xml->addItem("dtDia", Registro(x)->cdtDia );
				xml->addItem("inRelatorio", Registro(x)->cinRelatorio );
			}
			//So fecha um tag se abriu anteriormente
			xml->closeTag();
		}
	}
}

int CFeriado::FindFeriado( char* cidFeriado )
{
	int iRet = 0;
	for( int x = 0; x <Quantidade(); x++ )
	{
		if( strcmp( cidFeriado, Registro(x)->cidFeriado ) == 0 )
		{
			iRet++;
			break;
		}
	}
	return iRet;
}

void CFeriado::RelacaoFeriadoUF( char* cidFeriado, XMLGen*xml_g)
{
	int x;

	xml_g->createTag( "AdmCalendarioContainerVO" );
	xml_g->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
	xml_g->addProp( "xmlns:ns1", "cliente.fo.vivo.com.br/vo" );
	xml_g->addComment("Tag principal de pesquisa");

	xml_g->createTag( "AdmFeriadoVO" );

	xml_g->addItem("idFeriado", cidFeriado );
	xml_g->addItem("dtFeriado", "" );
	xml_g->addItem("idDsFeriado", "" );
	xml_g->addItem("dsFeriado", "" );
	xml_g->addItem("idTipoFeriado", "" );
	xml_g->addItem("relDlri", "" );
	xml_g->addItem("indMovel", "" );
	xml_g->addItem("idUf", "" );
	xml_g->addItem("idMunicipio", "" );
	xml_g->addItem("dsTipoFeriado", "" );
	xml_g->addItem("nmUF", "" );
	xml_g->addItem("inRelatorio", "0" );

	xml_g->createTag( "relacionados" );
	xml_g->addComment("Na pesquisa esta tag fica vazia");
	RelacaoFrdUF( cidFeriado );
	for( x=0; x<Quantidade();x++ )
	{
		xml_g->createTag( "ns1:UFVO" );
		xml_g->addComment("Na pesquisa esta tag fica vazia");

		xml_g->addItem("ns1:idUF", Registro(x)->cidUF );
		xml_g->addItem("ns1:sgUF", Registro(x)->csgUF );
		xml_g->addItem("ns1:nmUF", Registro(x)->cnmUF );

		xml_g->closeTag();
	}

	xml_g->closeTag();

	xml_g->createTag( "existentes" );
	xml_g->addComment("Na pesquisa esta tag fica vazia");
	ExistemFrdUF( cidFeriado );
	for( x=0; x<Quantidade();x++ )
	{
		xml_g->createTag( "ns1:UFVO" );
		xml_g->addComment("Na pesquisa esta tag fica vazia");

		xml_g->addItem("ns1:idUF", Registro(x)->cidUF );
		xml_g->addItem("ns1:sgUF", Registro(x)->csgUF );
		xml_g->addItem("ns1:nmUF", Registro(x)->cnmUF );

		xml_g->closeTag();
	}

	xml_g->closeTag();

	xml_g->closeTag();
}

void CFeriado::RelacaoFeriadoMunicipio( char* cidUf, char* cidFeriado, XMLGen*xml_g)
{
	int x;
	xml_g->createTag( "AdmCalendarioContainerVO" );
	xml_g->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
	xml_g->addComment("Tag principal de pesquisa");

	xml_g->createTag( "AdmFeriadoVO" );

	xml_g->addItem("idFeriado", cidFeriado );
	xml_g->addItem("dtFeriado", "" );
	xml_g->addItem("idDsFeriado", "" );
	xml_g->addItem("dsFeriado", "" );
	xml_g->addItem("idTipoFeriado", "" );
	xml_g->addItem("relDlri", "" );
	xml_g->addItem("indMovel", "" );
	xml_g->addItem("idUf", cidUf );
	xml_g->addItem("idMunicipio", "" );
	xml_g->addItem("dsTipoFeriado", "" );
	xml_g->addItem("nmUF", "" );
	xml_g->addItem("inRelatorio", "0" );

	xml_g->createTag( "relacionados" );
	xml_g->addComment("Na pesquisa esta tag fica vazia");
	RelacaoFrdMnc( cidFeriado, cidUf );
	for( x=0; x<Quantidade();x++ )
	{
		xml_g->createTag( "MunicipioVO" );
		xml_g->addComment("Na pesquisa esta tag fica vazia");

		xml_g->addItem("idUf", cidUf );
		xml_g->addItem("idMunicipio", Registro(x)->cidMunicipio );
		xml_g->addItem("nmMunicipio", Registro(x)->cnmMunicipio );

		xml_g->closeTag();
	}

	xml_g->closeTag();

	xml_g->createTag( "existentes" );
	xml_g->addComment("Na pesquisa esta tag fica vazia");
	ExistemFrdMnc( cidFeriado, cidUf );
	for( x=0; x<Quantidade();x++ )
	{
		xml_g->createTag( "MunicipioVO" );
		xml_g->addComment("Na pesquisa esta tag fica vazia");

		xml_g->addItem("idUf", cidUf );
		xml_g->addItem("idMunicipio", Registro(x)->cidMunicipio );
		xml_g->addItem("nmMunicipio", Registro(x)->cnmMunicipio );

		xml_g->closeTag();
	}

	xml_g->closeTag();

	xml_g->closeTag();
}

int CFeriado::CopiaCalendario( char* cAnoBase
		                      ,char* cAnoCopia
		                      ,char* cidUsuarioAlteracao
		                     )
{
    ULOG_START("CFeriado::CopiaCalendario()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxAnoBase = cAnoBase;
		char* cAuxAnoCopia = cAnoCopia;
		int   iAnoCopia;
		int   iAnoBase;
		int   iMeses;
		int   iTemDataCadastrada = 0;
		struct
		{
			VARCHAR stidFeriado[21+1];
			VARCHAR stidTipoFeriado[21+1];
			VARCHAR stdsTipoFeriado[255+1];
			VARCHAR stidNomeFeriado[21+1];
			VARCHAR stdsFeriado[255+1];
			VARCHAR stinFeriadoMovel[21+1];
			VARCHAR stdtDia[12+1];
			VARCHAR stdtDiaCopia[12+1];
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
			VARCHAR stidMunicipio[21+1];
			VARCHAR stnmMunicipio[255+1];
			VARCHAR stinRelatorio[21+1];
		} stFeriadoRegistro;
		struct
		{
			short iidFeriado;
			short iidTipoFeriado;
			short idsTipoFeriado;
			short iidNomeFeriado;
			short idsFeriado;
			short iinFeriadoMovel;
			short idtDia;
			short idtDiaCopia;
			short iidUF;
			short isgUF;
			short inmUF;
			short iidMunicipio;
			short inmMunicipio;
			short iinRelatorio;
		} stFeriadoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	ZeraFeriado();

	iAnoCopia = atoi( cAnoCopia );
	iAnoBase = atoi( cAnoBase );
	iMeses = (iAnoCopia-iAnoBase)*12;

	sqlca.sqlcode=0;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoCopiaCalendario;

	//Apaga todas as associacoes com UF
	EXEC SQL
	DELETE FROM
		CALENDARIO.UFFERIADO
	WHERE
		IDFERIADO IN
		(
			SELECT
				IDFERIADO
			FROM
				CALENDARIO.FERIADO
			WHERE
				TO_CHAR(FERIADO.DTDIA, 'YYYY' ) = :cAuxAnoCopia
		);

	//Apaga todas as associacoes com MUNICIPIO
	EXEC SQL
	DELETE FROM
		CALENDARIO.MUNICIPIOFERIADO
	WHERE
		IDFERIADO IN
		(
			SELECT
				IDFERIADO
			FROM
				CALENDARIO.FERIADO
			WHERE
				TO_CHAR(FERIADO.DTDIA, 'YYYY' ) = :cAuxAnoCopia
		);

	//Apaga todos os feriados do ANO DESTINO
	EXEC SQL
	DELETE FROM
		CALENDARIO.FERIADO FERIADO
	WHERE
		TO_CHAR(FERIADO.DTDIA, 'YYYY' ) = :cAuxAnoCopia;

	EXEC SQL WHENEVER NOT FOUND DO break;
	//Declara um cursor para listar os Registros
	EXEC SQL
		DECLARE
			CursorCopiaCalendario CURSOR FOR
		SELECT
	         FERIADO.IDFERIADO
	        ,FERIADO.IDTIPOFERIADO
	        ,FERIADO.DSTIPOFERIADO
	        ,FERIADO.IDNOMEFERIADO
	        ,FERIADO.DSFERIADO
	        ,FERIADO.INFERIADOMOVEL
	        ,FERIADO.DTDIA
	        ,TO_CHAR( ADD_MONTHS( FERIADO.DTDIA, :iMeses ), 'DD/MM/YYYY' )
	        ,FERIADO.IDUF
	        ,FERIADO.SGUF
	        ,FERIADO.NMUF
	        ,FERIADO.IDMUNICIPIO
	        ,FERIADO.NMMUNICIPIO
			,FERIADO.INRELATORIO
		FROM
			CALENDARIO.FERIADOV01 FERIADO
		WHERE
			TO_CHAR( FERIADO.DTDIA, 'YYYY' ) = :cAuxAnoBase
		AND
			FERIADO.IDTIPOFERIADO NOT IN( '4', '5', '6' ) //Nao copia pontes
		ORDER BY
			DTDIA, IDNOMEFERIADO;

	EXEC SQL OPEN CursorCopiaCalendario;

	char cidFeriado[21+1];
	char cidFeriadoRet[21+1];
	memset( cidFeriadoRet, 0, sizeof(cidFeriadoRet) );
	memset( cidFeriado, 0, sizeof(cidFeriado) );
	for(;;)
	{
		//Zera a estrutura de restorno
		memset( &stFeriadoRegistro, 0, sizeof(stFeriadoRegistro) );
		//Pega um registro no CURSOR
		EXEC SQL FETCH CursorCopiaCalendario INTO :stFeriadoRegistro:stFeriadoIndicator;
		//Insere os novo registro
		if( strcmp( (char*)stFeriadoRegistro.stinFeriadoMovel.arr, "1" ) == 0 )
		{
			//Adiciona a classe
			Add( (char*)stFeriadoRegistro.stidFeriado.arr,
				 (char*)stFeriadoRegistro.stidTipoFeriado.arr,
				 (char*)stFeriadoRegistro.stdsTipoFeriado.arr,
				 (char*)stFeriadoRegistro.stidNomeFeriado.arr,
			 	 (char*)stFeriadoRegistro.stdsFeriado.arr,
				 (char*)stFeriadoRegistro.stinFeriadoMovel.arr,
				 (char*)stFeriadoRegistro.stdtDiaCopia.arr,
				 (char*)stFeriadoRegistro.stidUF.arr,
				 (char*)stFeriadoRegistro.stsgUF.arr,
				 (char*)stFeriadoRegistro.stnmUF.arr,
				 (char*)stFeriadoRegistro.stidMunicipio.arr,
				 (char*)stFeriadoRegistro.stnmMunicipio.arr,
				 "",
				 "",
				 "",
				 "",
				 (char*)stFeriadoRegistro.stinRelatorio.arr
			   );
		}
		else
		{
			if( strcmp( cidFeriado, (char*)stFeriadoRegistro.stidFeriado.arr ) != 0 )
			{
				strcpy( cidFeriado, (char*)stFeriadoRegistro.stidFeriado.arr );
				memset( cidFeriadoRet, 0, sizeof(cidFeriadoRet) );
			}
			Insert( (char*)stFeriadoRegistro.stidTipoFeriado.arr,
					(char*)stFeriadoRegistro.stidNomeFeriado.arr,
				    "",
					(char*)stFeriadoRegistro.stinFeriadoMovel.arr,
					(char*)stFeriadoRegistro.stdtDiaCopia.arr,
					(char*)stFeriadoRegistro.stinRelatorio.arr,
					cidUsuarioAlteracao,
					(char*)stFeriadoRegistro.stidUF.arr,
					(char*)stFeriadoRegistro.stidMunicipio.arr,
					cidFeriadoRet
				 );
		}
		//conta quantos existem
		iCont++;
	}
	//Fecha o cursor
	EXEC SQL CLOSE CursorCopiaCalendario;

	ULOG_END("CFeriado::CopiaCalendario()");
	//Retorna a quantidade de registros
	return iCont;

GotoCopiaCalendario:
	ULOG("\nCFeriado::CopiaCalendario:Erro Oracle: %d\n", sqlca.sqlcode );
	ULOG("\nCFeriado::CopiaCalendario:Descrição..: %s\n", sqlca.sqlerrm.sqlerrmc );
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CFeriado::ListaPonte( char* cAnoBase )
{
    ULOG_START("CFeriado::ListaPonte()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxAnoBase = cAnoBase;
		char  cTipoPonte[2];
		struct
		{
			VARCHAR stidFeriado[21+1];
			VARCHAR stidTipoFeriado[21+1];
			VARCHAR stdsTipoFeriado[255+1];
			VARCHAR stidNomeFeriado[21+1];
			VARCHAR stdsFeriado[255+1];
			VARCHAR stinFeriadoMovel[21+1];
			VARCHAR stdtDia[12+1];
			VARCHAR stinRelatorio[21+1];
		} stFeriadoRegistro;
		struct
		{
			short iidFeriado;
			short iidTipoFeriado;
			short idsTipoFeriado;
			short iidNomeFeriado;
			short idsFeriado;
			short iinFeriadoMovel;
			short idtDia;
			short iinRelatorio;
		} stFeriadoIndicator;
	EXEC SQL END DECLARE SECTION;


	//Processamento Principal
	ZeraFeriado();

	sqlca.sqlcode=0;
	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListaPonte;

	//Declara um cursor para listar os Registros
	EXEC SQL
		DECLARE
			CursorListaPonte CURSOR FOR
		SELECT
			FERIADO.IDFERIADO
		   ,FERIADO.IDTIPOFERIADO
		   ,FERIADO.DSTIPOFERIADO
		   ,FERIADO.IDNOMEFERIADO
		   ,FERIADO.DSFERIADO
		   ,FERIADO.INFERIADOMOVEL
		   ,FERIADO.PONTE
		   ,FERIADO.INRELATORIO
		FROM
		   CALENDARIO.PONTEV01 FERIADO
		WHERE
		   ANO = :cAuxAnoBase
		ORDER BY
            FERIADO.DTDIA;

	EXEC SQL OPEN CursorListaPonte;

	//Verifica se nao house erro ORACLE
	if(sqlca.sqlcode)
	{
	   ULOG_END("CFeriado::ListaPonte()");
  	   return 0;//Erro
  	}
	else
	{
		memset( &cTipoPonte, 0, sizeof(cTipoPonte) );
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stFeriadoRegistro, 0, sizeof(stFeriadoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListaPonte INTO :stFeriadoRegistro:stFeriadoIndicator;
			if( strcmp( (char*)stFeriadoRegistro.stidTipoFeriado.arr, "1" ) == 0 )
				cTipoPonte[0] = '4';//Ponte municipal
			else if( strcmp( (char*)stFeriadoRegistro.stidTipoFeriado.arr, "2" ) == 0 )
				cTipoPonte[0] = '5';//Ponte Estadual
			else
				cTipoPonte[0] = '6';//Ponte Nacional
			//Insere os novo registro
			Add( (char*)stFeriadoRegistro.stidFeriado.arr,
				 cTipoPonte, //Id da ponte
				 "",
				 (char*)stFeriadoRegistro.stidNomeFeriado.arr,
				 (char*)stFeriadoRegistro.stdsFeriado.arr,
				 (char*)stFeriadoRegistro.stinFeriadoMovel.arr,
				 (char*)stFeriadoRegistro.stdtDia.arr,
				 "",
				 "",
				 "",
				 "",
				 "",
				 "",
				 "",
				 "",
				 "",
				 (char*)stFeriadoRegistro.stinRelatorio.arr
			   );
			//conta quantos existem
			iCont++;
		}
		//Fecha o cursor
		EXEC SQL CLOSE CursorListaPonte;
	}
	ULOG_END("CFeriado::ListaPonte()");
	//Retorna a quantidade de registros
	return iCont;

GotoListaPonte:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

void CFeriado::RangeAnos( int &iAnoInicial, int& iAnoFinal )
{
    ULOG_START("CFeriado::RangeAnos()");
		//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		int iAnoInicialAux = 0;
		int iAnoFinalAux = 0;
	EXEC SQL END DECLARE SECTION;

	sqlca.sqlcode=0;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoRangeAnos;

	EXEC SQL
	SELECT
	    MIN( TO_CHAR(DTDIA, 'YYYY') ),
	    MAX( TO_CHAR(DTDIA, 'YYYY') )
	INTO
		:iAnoInicialAux,
		:iAnoFinalAux
	FROM
	    CALENDARIO.FERIADO;

	iAnoInicial = iAnoInicialAux;
	iAnoFinal = iAnoFinalAux;

    ULOG_END("CFeriado::RangeAnos()");
	return;

GotoRangeAnos:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}