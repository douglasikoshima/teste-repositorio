/**
 * @modulo  ADM
 * @usecase ADM
 * @author  
 * @version $Revision: 1.1 $
 * @CVS     $Author: a5110702 $ - $Date: 2009/07/31 15:33:14 $
 **/

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CContatoTipoRetornoRelacoes.h"

CContatoTipoRetornoRelacoes::CContatoTipoRetornoRelacoes()
{
}

CContatoTipoRetornoRelacoes::~CContatoTipoRetornoRelacoes()
{
}

int CContatoTipoRetornoRelacoes::InsertCanal( 
					char* cidContatoTipoRetorno,
					char* cidCanal,
					char* cidUsuarioAlteracao 
			      )
{
    ULOG_START("CContatoTipoRetornoRelacoes::InsertCanal()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContatoTipoRetorno = cidContatoTipoRetorno;
		char* cAuxidCanal = cidCanal;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsertCanal;
		
		//Realiza o insert
		EXEC SQL 
			INSERT INTO CONTATOADM.CONTATOTIPORETORNOCANAL
			(	IDCONTATOTIPORETORNOCANAL,
				IDCONTATOTIPORETORNO,
				IDCANAL,
				IDUSUARIOALTERACAO,
				DTULTIMAALTERACAO
			)
			VALUES 
			(	CONTATOADM.CONTATOTIPORETORNOCANALSQ.NEXTVAL,
				:cAuxidContatoTipoRetorno,
				:cAuxidCanal,
				:cAuxidUsuarioAlteracao,
				SYSDATE
			);

        ULOG_END("CContatoTipoRetornoRelacoes::InsertCanal()");
		return 0;//Sucesso
	}
	catch(...)
	{
		throw;
	}
	
GotoInsertCanal:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}			      
int CContatoTipoRetornoRelacoes::InsertTpRelacionamento( 
					char* cidContatoTipoRetorno,
					char* cidTipoRelacionamento,
					char* cidUsuarioAlteracao 
			      )
{
    ULOG_START("CContatoTipoRetornoRelacoes::InsertTpRelacionamento()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContatoTipoRetorno = cidContatoTipoRetorno;
		char* cAuxidTipoRelacionamento = cidTipoRelacionamento;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsertTipoRelacionamento;
		
		//Realiza o insert
		EXEC SQL 
			INSERT INTO CONTATOADM.TIPOPESSOATPRELACIONAMENTO
			(	IDTIPOPESSOATPRELACIONAMENTO,
				IDCONTATOTIPORETORNO,
				IDTIPORELACIONAMENTO,
				IDUSUARIOALTERACAO,
				DTULTIMAALTERACAO
			)
			VALUES 
			(	CONTATOADM.TIPOPESSOATPRELACIONAMENTOSQ.NEXTVAL,
				:cAuxidContatoTipoRetorno,
				:cAuxidTipoRelacionamento,
				:cAuxidUsuarioAlteracao,
				SYSDATE
			);
			
		ULOG_END("CContatoTipoRetornoRelacoes::InsertTpRelacionamento()");

		return 0;//Sucesso
	}
	catch(...)
	{
		throw;
	}
	
GotoInsertTipoRelacionamento:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}
int CContatoTipoRetornoRelacoes::InsertSegmentacao( 
					char* cidContatoTipoRetorno,
					char* cidSegmentacao,
					char* cidUsuarioAlteracao 
			      )
{
    ULOG_START("CContatoTipoRetornoRelacoes::InsertSegmentacao()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContatoTipoRetorno = cidContatoTipoRetorno;
		char* cAuxidSegmentacao = cidSegmentacao;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsertSegmentacao;
		
		//Realiza o insert
		EXEC SQL 
			INSERT INTO CONTATOADM.TIPORETORNOSEGMENTACAO
			(	IDTIPORETORNOSEGMENTACAO,
				IDCONTATOTIPORETORNO,
				IDSEGMENTACAO,
				IDUSUARIOALTERACAO,
				DTULTIMAALTERACAO
			)
			VALUES 
			(	CONTATOADM.TIPORETORNOSEGMENTACAOSQ.NEXTVAL,
				:cAuxidContatoTipoRetorno,
				:cAuxidSegmentacao,
				:cAuxidUsuarioAlteracao,
				SYSDATE
			);
        ULOG_END("CContatoTipoRetornoRelacoes::InsertSegmentacao()");
		return 0;//Sucesso
	}
	catch(...)
	{
		throw;
	}
	
GotoInsertSegmentacao:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}
int CContatoTipoRetornoRelacoes::InsertProcedencia( 
					char* cidContatoTipoRetorno,
					char* cidProcedencia,
					char* cidUsuarioAlteracao 
			      )
{
    ULOG_START("CContatoTipoRetornoRelacoes::InsertProcedencia()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContatoTipoRetorno = cidContatoTipoRetorno;
		char* cAuxidProcedencia = cidProcedencia;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsertProcedencia;
		
		//Realiza o insert
		EXEC SQL 
			INSERT INTO CONTATOADM.TIPORETORNOPROCEDENCIA
			(	IDTIPORETORNOPROCEDENCIA,
				IDCONTATOTIPORETORNO,
				IDPROCEDENCIA,
				IDUSUARIOALTERACAO,
				DTULTIMAALTERACAO
			)
			VALUES 
			(	CONTATOADM.TIPORETORNOPROCEDENCIASQ.NEXTVAL,
				:cAuxidContatoTipoRetorno,
				:cAuxidProcedencia,
				:cAuxidUsuarioAlteracao,
				SYSDATE
			);

        ULOG_END("CContatoTipoRetornoRelacoes::InsertProcedencia()");
		return 0;//Sucesso
	}
	catch(...)
	{
		throw;
	}
	
GotoInsertProcedencia:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}
int CContatoTipoRetornoRelacoes::InsertTipoLinha( 
					char* cidContatoTipoRetorno,
					char* cidTipoLinha,
					char* cidUsuarioAlteracao 
			      )
{
    ULOG_START("CContatoTipoRetornoRelacoes::InsertTipoLinha()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContatoTipoRetorno = cidContatoTipoRetorno;
		char* cAuxidTipoLinha = cidTipoLinha;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsertTipoLinha;
		
		//Realiza o insert
		EXEC SQL 
			INSERT INTO CONTATOADM.TIPORETORNOTIPOLINHA
			(	IDTIPORETORNOTIPOLINHA,
				IDCONTATOTIPORETORNO,
				IDTIPOLINHA,
				IDUSUARIOALTERACAO,
				DTULTIMAALTERACAO
			)
			VALUES 
			(	CONTATOADM.TIPORETORNOTIPOLINHASQ.NEXTVAL,
				:cAuxidContatoTipoRetorno,
				:cAuxidTipoLinha,
				:cAuxidUsuarioAlteracao,
				SYSDATE
			);

        ULOG_END("CContatoTipoRetornoRelacoes::InsertTipoLinha()");
		return 0;//Sucesso
	}
	catch(...)
	{
		throw;
	}
	
GotoInsertTipoLinha:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}
int CContatoTipoRetornoRelacoes::InsertTipoCarteira( 
					char* cidContatoTipoRetorno,
					char* cidTipoCarteira,
					char* cidUsuarioAlteracao 
			      )
{
    ULOG_START("CContatoTipoRetornoRelacoes::InsertTipoCarteira()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContatoTipoRetorno = cidContatoTipoRetorno;
		char* cAuxidTipoCarteira = cidTipoCarteira;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsertTipoCarteira;
		
		//Realiza o insert
		EXEC SQL 
			INSERT INTO CONTATOADM.TIPORETORNOTIPOCARTEIRA
			(	IDTIPORETORNOTIPOCARTEIRA,
				IDCONTATOTIPORETORNO,
				IDTIPOCARTEIRA,
				IDUSUARIOALTERACAO,
				DTULTIMAALTERACAO
			)
			VALUES 
			(	CONTATOADM.TIPORETORNOTIPOCARTEIRASQ.NEXTVAL,
				:cAuxidContatoTipoRetorno,
				:cAuxidTipoCarteira,
				:cAuxidUsuarioAlteracao,
				SYSDATE
			);

        ULOG_END("CContatoTipoRetornoRelacoes::InsertTipoCarteira()");
		return 0;//Sucesso
	}
	catch(...)
	{
		throw;
	}
	
GotoInsertTipoCarteira:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}
int CContatoTipoRetornoRelacoes::InsertTipoPessoa( 
					char* cidContatoTipoRetorno,
					char* cidTipoPessoa,
					char* cidUsuarioAlteracao 
			      )
{
    ULOG_START("CContatoTipoRetornoRelacoes::InsertTipoPessoa()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContatoTipoRetorno = cidContatoTipoRetorno;
		char* cAuxidTipoPessoa = cidTipoPessoa;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsertTipoPessoa;
		
		//Realiza o insert
		EXEC SQL 
			INSERT INTO CONTATOADM.TIPORETORNOTIPOPESSOA
			(	IDTIPORETORNOTIPOPESSOA,
				IDCONTATOTIPORETORNO,
				IDTIPOPESSOA,
				IDUSUARIOALTERACAO,
				DTULTIMAALTERACAO
			)
			VALUES 
			(	CONTATOADM.TIPORETORNOTIPOPESSOASQ.NEXTVAL,
				:cAuxidContatoTipoRetorno,
				:cAuxidTipoPessoa,
				:cAuxidUsuarioAlteracao,
				SYSDATE
			);
			
        ULOG_END("CContatoTipoRetornoRelacoes::InsertTipoPessoa()");
		return 0;//Sucesso
	}
	catch(...)
	{
		throw;
	}
	
GotoInsertTipoPessoa:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}
int CContatoTipoRetornoRelacoes::InsertRegional( 
					char* cidContatoTipoRetorno,
					char* cidRegional,
					char* cidUsuarioAlteracao 
			      )
{
    ULOG_START("CContatoTipoRetornoRelacoes::InsertRegional()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContatoTipoRetorno = cidContatoTipoRetorno;
		char* cAuxidRegional = cidRegional;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsertRegional;
		
		//Realiza o insert
		EXEC SQL 
			INSERT INTO CONTATOADM.TIPORETORNOUFOPERADORA
			(	IDTIPORETORNOUFOPERADORA,
				IDCONTATOTIPORETORNO,
				IDUFOPERADORA,
				IDUSUARIOALTERACAO,
				DTULTIMAALTERACAO
			)
			VALUES 
			(	CONTATOADM.TIPORETORNOUFOPERADORASQ.NEXTVAL,
				:cAuxidContatoTipoRetorno,
				:cAuxidRegional,
				:cAuxidUsuarioAlteracao,
				SYSDATE
			);

        ULOG_END("CContatoTipoRetornoRelacoes::InsertRegional()");
		return 0;//Sucesso
	}
	catch(...)
	{
		throw;
	}
	
GotoInsertRegional:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CContatoTipoRetornoRelacoes::ListIdContatoCanal( char* cidContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListIdContatoCanal()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
		struct
		{
			VARCHAR stidContatoTipoRetornoRelacoes[21+1];
			VARCHAR stidContatoTipoRetorno[21+1];
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stidTipoRetornoContato[21+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoTipoRetornoRelacoes;
			short iidContatoTipoRetorno;
			short iidContatoRelacao;
			short iidTipoRetornoContato;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListIdContatoCanal;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorListIdContatoCanal CURSOR FOR 
			SELECT 
			    RELACAO.IDCONTATOTIPORETORNOCANAL
   			   ,RELACAO.IDCONTATOTIPORETORNO
			   ,RELACAO.IDCANAL
			   ,CONTATOTIPORETORNO.IDTIPORETORNOCONTATO
			FROM 
			    CONTATOADM.CONTATOTIPORETORNOCANAL RELACAO
			   ,CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO
			WHERE
			    RELACAO.IDCONTATOTIPORETORNO = CONTATOTIPORETORNO.IDCONTATOTIPORETORNO
			AND
			    CONTATOTIPORETORNO.IDCONTATO = :cAuxidContato;

		//Abre o cursor
		EXEC SQL OPEN CursorListIdContatoCanal;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListIdContatoCanal INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoTipoRetornoRelacoes.arr,
				(char*)stRelacaoRegistro.stidContatoTipoRetorno.arr, 
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stidTipoRetornoContato.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListIdContatoCanal;
		
		ULOG_END("CContatoTipoRetornoRelacoes::ListIdContatoCanal()");

	}
	catch(...)
	{
		throw;
	}

	//Retorna a quantidade de registros
	return iCont;

GotoListIdContatoCanal:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}
int CContatoTipoRetornoRelacoes::ListIdContatoTpRelacionamento( char* cidContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListIdContatoTpRelacionamento()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
		struct
		{
			VARCHAR stidContatoTipoRetornoRelacoes[21+1];
			VARCHAR stidContatoTipoRetorno[21+1];
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stidTipoRetornoContato[21+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoTipoRetornoRelacoes;
			short iidContatoTipoRetorno;
			short iidContatoRelacao;
			short iidTipoRetornoContato;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListIdContatoTpRelacionamento;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorListIdContatoTpRelacionamento CURSOR FOR 
			SELECT 
			    RELACAO.IDTIPOPESSOATPRELACIONAMENTO
   			   ,RELACAO.IDCONTATOTIPORETORNO
			   ,RELACAO.IDTIPORELACIONAMENTO
			   ,CONTATOTIPORETORNO.IDTIPORETORNOCONTATO
			FROM 
			    CONTATOADM.TIPOPESSOATPRELACIONAMENTO RELACAO
			   ,CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO
			WHERE
			    RELACAO.IDCONTATOTIPORETORNO = CONTATOTIPORETORNO.IDCONTATOTIPORETORNO
			AND
			    CONTATOTIPORETORNO.IDCONTATO = :cAuxidContato;

		//Abre o cursor
		EXEC SQL OPEN CursorListIdContatoTpRelacionamento;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListIdContatoTpRelacionamento INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoTipoRetornoRelacoes.arr,
				(char*)stRelacaoRegistro.stidContatoTipoRetorno.arr, 
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stidTipoRetornoContato.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListIdContatoTpRelacionamento;
		
		ULOG_END("CContatoTipoRetornoRelacoes::ListIdContatoTpRelacionamento()");

	}
	catch(...)
	{
		throw;
	}

	//Retorna a quantidade de registros
	return iCont;

GotoListIdContatoTpRelacionamento:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListIdContatoSegmentacao( char* cidContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListIdContatoSegmentacao()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
		struct
		{
			VARCHAR stidContatoTipoRetornoRelacoes[21+1];
			VARCHAR stidContatoTipoRetorno[21+1];
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stidTipoRetornoContato[21+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoTipoRetornoRelacoes;
			short iidContatoTipoRetorno;
			short iidContatoRelacao;
			short iidTipoRetornoContato;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListIdContatoSegmentacao;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorListIdContatoSegmentacao CURSOR FOR 
			SELECT 
			    RELACAO.IDTIPORETORNOSEGMENTACAO
   			   ,RELACAO.IDCONTATOTIPORETORNO
			   ,RELACAO.IDSEGMENTACAO
			   ,CONTATOTIPORETORNO.IDTIPORETORNOCONTATO
			FROM 
			    CONTATOADM.TIPORETORNOSEGMENTACAO RELACAO
			   ,CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO
			WHERE
			    RELACAO.IDCONTATOTIPORETORNO = CONTATOTIPORETORNO.IDCONTATOTIPORETORNO
			AND
			    CONTATOTIPORETORNO.IDCONTATO = :cAuxidContato;

		//Abre o cursor
		EXEC SQL OPEN CursorListIdContatoSegmentacao;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListIdContatoSegmentacao INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoTipoRetornoRelacoes.arr,
				(char*)stRelacaoRegistro.stidContatoTipoRetorno.arr, 
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stidTipoRetornoContato.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListIdContatoSegmentacao;
		
        ULOG_END("CContatoTipoRetornoRelacoes::ListIdContatoSegmentacao()");
	}
	catch(...)
	{
		throw;
	}

	//Retorna a quantidade de registros
	return iCont;

GotoListIdContatoSegmentacao:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListIdContatoProcedencia( char* cidContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListIdContatoProcedencia()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
		struct
		{
			VARCHAR stidContatoTipoRetornoRelacoes[21+1];
			VARCHAR stidContatoTipoRetorno[21+1];
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stidTipoRetornoContato[21+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoTipoRetornoRelacoes;
			short iidContatoTipoRetorno;
			short iidContatoRelacao;
			short iidTipoRetornoContato;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListIdContatoProcedencia;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorListIdContatoProcedencia CURSOR FOR 
			SELECT 
			    RELACAO.IDTIPORETORNOPROCEDENCIA
   			   ,RELACAO.IDCONTATOTIPORETORNO
			   ,RELACAO.IDPROCEDENCIA
			   ,CONTATOTIPORETORNO.IDTIPORETORNOCONTATO
			FROM 
			    CONTATOADM.TIPORETORNOPROCEDENCIA RELACAO
			   ,CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO
			WHERE
			    RELACAO.IDCONTATOTIPORETORNO = CONTATOTIPORETORNO.IDCONTATOTIPORETORNO
			AND
			    CONTATOTIPORETORNO.IDCONTATO = :cAuxidContato;

		//Abre o cursor
		EXEC SQL OPEN CursorListIdContatoProcedencia;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListIdContatoProcedencia INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoTipoRetornoRelacoes.arr,
				(char*)stRelacaoRegistro.stidContatoTipoRetorno.arr, 
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stidTipoRetornoContato.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListIdContatoProcedencia;
		
		ULOG_END("CContatoTipoRetornoRelacoes::ListIdContatoProcedencia()");

	}
	catch(...)
	{
		throw;
	}

	//Retorna a quantidade de registros
	return iCont;

GotoListIdContatoProcedencia:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListIdContatoTipoLinha( char* cidContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListIdContatoTipoLinha()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
		struct
		{
			VARCHAR stidContatoTipoRetornoRelacoes[21+1];
			VARCHAR stidContatoTipoRetorno[21+1];
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stidTipoRetornoContato[21+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoTipoRetornoRelacoes;
			short iidContatoTipoRetorno;
			short iidContatoRelacao;
			short iidTipoRetornoContato;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListIdContatoTipoLinha;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorListIdContatoTipoLinha CURSOR FOR 
			SELECT 
			    RELACAO.IDTIPORETORNOTIPOLINHA
   			   ,RELACAO.IDCONTATOTIPORETORNO
			   ,RELACAO.IDTIPOLINHA
			   ,CONTATOTIPORETORNO.IDTIPORETORNOCONTATO
			FROM 
			    CONTATOADM.TIPORETORNOTIPOLINHA RELACAO
			   ,CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO
			WHERE
			    RELACAO.IDCONTATOTIPORETORNO = CONTATOTIPORETORNO.IDCONTATOTIPORETORNO
			AND
			    CONTATOTIPORETORNO.IDCONTATO = :cAuxidContato;

		//Abre o cursor
		EXEC SQL OPEN CursorListIdContatoTipoLinha;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListIdContatoTipoLinha INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoTipoRetornoRelacoes.arr,
				(char*)stRelacaoRegistro.stidContatoTipoRetorno.arr, 
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stidTipoRetornoContato.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListIdContatoTipoLinha;
		
		ULOG_END("CContatoTipoRetornoRelacoes::ListIdContatoTipoLinha()");

	}
	catch(...)
	{
		throw;
	}

	//Retorna a quantidade de registros
	return iCont;

GotoListIdContatoTipoLinha:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListIdContatoTipoCarteira( char* cidContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListIdContatoTipoCarteira()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
		struct
		{
			VARCHAR stidContatoTipoRetornoRelacoes[21+1];
			VARCHAR stidContatoTipoRetorno[21+1];
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stidTipoRetornoContato[21+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoTipoRetornoRelacoes;
			short iidContatoTipoRetorno;
			short iidContatoRelacao;
			short iidTipoRetornoContato;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListIdContatoTipoCarteira;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorListIdContatoTipoCarteira CURSOR FOR 
			SELECT 
			    RELACAO.IDTIPORETORNOTIPOCARTEIRA
   			   ,RELACAO.IDCONTATOTIPORETORNO
			   ,RELACAO.IDTIPOCARTEIRA
			   ,CONTATOTIPORETORNO.IDTIPORETORNOCONTATO
			FROM 
			    CONTATOADM.TIPORETORNOTIPOCARTEIRA RELACAO
			   ,CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO
			WHERE
			    RELACAO.IDCONTATOTIPORETORNO = CONTATOTIPORETORNO.IDCONTATOTIPORETORNO
			AND
			    CONTATOTIPORETORNO.IDCONTATO = :cAuxidContato;

		//Abre o cursor
		EXEC SQL OPEN CursorListIdContatoTipoCarteira;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListIdContatoTipoCarteira INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoTipoRetornoRelacoes.arr,
				(char*)stRelacaoRegistro.stidContatoTipoRetorno.arr, 
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stidTipoRetornoContato.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListIdContatoTipoCarteira;
		
		ULOG_END("CContatoTipoRetornoRelacoes::ListIdContatoTipoCarteira()");

	}
	catch(...)
	{
		throw;
	}

	//Retorna a quantidade de registros
	return iCont;

GotoListIdContatoTipoCarteira:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListIdContatoTipoPessoa( char* cidContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListIdContatoTipoPessoa()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
		struct
		{
			VARCHAR stidContatoTipoRetornoRelacoes[21+1];
			VARCHAR stidContatoTipoRetorno[21+1];
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stidTipoRetornoContato[21+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoTipoRetornoRelacoes;
			short iidContatoTipoRetorno;
			short iidContatoRelacao;
			short iidTipoRetornoContato;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListIdContatoTipoPessoa;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorListIdContatoTipoPessoa CURSOR FOR 
			SELECT 
			    RELACAO.IDTIPORETORNOTIPOPESSOA
   			   ,RELACAO.IDCONTATOTIPORETORNO
			   ,RELACAO.IDTIPOPESSOA
			   ,CONTATOTIPORETORNO.IDTIPORETORNOCONTATO
			FROM 
			    CONTATOADM.TIPORETORNOTIPOPESSOA RELACAO
			   ,CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO
			WHERE
			    RELACAO.IDCONTATOTIPORETORNO = CONTATOTIPORETORNO.IDCONTATOTIPORETORNO
			AND
			    CONTATOTIPORETORNO.IDCONTATO = :cAuxidContato;

		//Abre o cursor
		EXEC SQL OPEN CursorListIdContatoTipoPessoa;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListIdContatoTipoPessoa INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoTipoRetornoRelacoes.arr,
				(char*)stRelacaoRegistro.stidContatoTipoRetorno.arr, 
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stidTipoRetornoContato.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListIdContatoTipoPessoa;
		
		ULOG_START("CContatoTipoRetornoRelacoes::ListIdContatoTipoPessoa()");

	}
	catch(...)
	{
		throw;
	}

	//Retorna a quantidade de registros
	return iCont;

GotoListIdContatoTipoPessoa:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListIdContatoRegional( char* cidContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListIdContatoRegional()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
		struct
		{
			VARCHAR stidContatoTipoRetornoRelacoes[21+1];
			VARCHAR stidContatoTipoRetorno[21+1];
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stidTipoRetornoContato[21+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoTipoRetornoRelacoes;
			short iidContatoTipoRetorno;
			short iidContatoRelacao;
			short iidTipoRetornoContato;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListIdContatoRegional;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorListIdContatoRegional CURSOR FOR 
			SELECT 
			    RELACAO.IDTIPORETORNOUFOPERADORA
   			   ,RELACAO.IDCONTATOTIPORETORNO
			   ,RELACAO.IDUFOPERADORA
			   ,CONTATOTIPORETORNO.IDTIPORETORNOCONTATO
			FROM 
			    CONTATOADM.TIPORETORNOUFOPERADORA RELACAO
			   ,CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO
			WHERE
			    RELACAO.IDCONTATOTIPORETORNO = CONTATOTIPORETORNO.IDCONTATOTIPORETORNO
			AND
			    CONTATOTIPORETORNO.IDCONTATO = :cAuxidContato;

		//Abre o cursor
		EXEC SQL OPEN CursorListIdContatoRegional;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListIdContatoRegional INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoTipoRetornoRelacoes.arr,
				(char*)stRelacaoRegistro.stidContatoTipoRetorno.arr, 
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stidTipoRetornoContato.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListIdContatoRegional;
		
		ULOG_START("CContatoTipoRetornoRelacoes::ListIdContatoRegional()");

	}
	catch(...)
	{
		throw;
	}

	//Retorna a quantidade de registros
	return iCont;

GotoListIdContatoRegional:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

void CContatoTipoRetornoRelacoes::GetXml( char* cNomeTag
							            , char* cidContatoTipoRetornoRelacao
							            , char* cidContatoTipoRetorno
							            , char* cidRelacao
							            , XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
				xml->createTag(cNomeTag);
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem(cidContatoTipoRetornoRelacao, Registro(x)->cidContatoTipoRetornoRelacoes );
				xml->addItem(cidContatoTipoRetorno, Registro(x)->cidContatoTipoRetorno );
				xml->addItem(cidRelacao, Registro(x)->cidContatoRelacao ); 
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}


void CContatoTipoRetornoRelacoes::GetXml( char* cNomeTag
							            , char* cidContatoRelacao
							            , char* cdsContatoRelacao
							            , XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
				xml->createTag(cNomeTag);
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem(cidContatoRelacao, Registro(x)->cidContatoRelacao );
				xml->addItem(cdsContatoRelacao, Registro(x)->cdsContatoRelacao );
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}

void CContatoTipoRetornoRelacoes::GetXmlSigla( char* cNomeTag
							                 , char* cidContatoRelacao
							                 , char* csgContatoRelacao
							                 , char* cdsContatoRelacao
							                 , XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
				xml->createTag(cNomeTag);
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem(cidContatoRelacao, Registro(x)->cidContatoRelacao );
				xml->addItem(csgContatoRelacao, "" );
				xml->addItem(cdsContatoRelacao, Registro(x)->cdsContatoRelacao );
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}

int CContatoTipoRetornoRelacoes::ListCanal( char* cidTipoContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListCanal()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidTipoContato = cidTipoContato; 
		struct
		{
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stdsContatoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoRelacao;
			short idsContatoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListCanal;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
		/*
   		EXEC SQL 
   			DECLARE 
   				CursorListCanal CURSOR FOR 
			SELECT 
			    RELACAO.IDCANAL
			   ,RELACAO.NMCANAL
			FROM 
			    CONTATOADM.CONTATOTIPORETORNOCANALBZEROUM RELACAO
			WHERE
			    RELACAO.IDCONTATOTIPORETORNO = :cAuxidTipoContato;
	    */

   		EXEC SQL 
   			DECLARE 
   				CursorListCanal CURSOR FOR 
			SELECT 
			    CANAL.IDCANAL
			   ,CANAL.NMCANAL
			FROM 
			    APOIO.CANAL CANAL,
			    CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO,
			    CONTATOADM.CONTATOTIPORETORNOCANAL CONTATOTIPORETORNOCANAL
			WHERE 
			    CONTATOTIPORETORNOCANAL.IDCANAL = CANAL.IDCANAL
			AND 
			    CONTATOTIPORETORNOCANAL.IDCONTATOTIPORETORNO = CONTATOTIPORETORNO.IDCONTATOTIPORETORNO
			AND
			    CONTATOTIPORETORNO.IDCONTATOTIPORETORNO = :cAuxidTipoContato;

		//Abre o cursor
		EXEC SQL OPEN CursorListCanal;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListCanal INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stdsContatoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListCanal;

	}
	catch(...)
	{
		throw;
	}

    ULOG_END("CContatoTipoRetornoRelacoes::ListCanal()");
	//Retorna a quantidade de registros
	return iCont;

GotoListCanal:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}
int CContatoTipoRetornoRelacoes::ListTpRelacionamento( char* cidTipoContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListTpRelacionamento()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidTipoContato = cidTipoContato; 
		struct
		{
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stdsContatoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoRelacao;
			short idsContatoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListTpRelacionamento;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		/*
   		EXEC SQL 
   			DECLARE 
   				CursorListTpRelacionamento CURSOR FOR 
			SELECT 
			    RELACAO.IDTIPORELACIONAMENTO
			   ,RELACAO.NMTIPORELACIONAMENTO
			FROM 
			    CONTATOADM.TIPOPESSOATPRELACIONAMENTOBZEROUM RELACAO
			WHERE
			    RELACAO.IDCONTATOTIPORETORNO = :cAuxidTipoContato;
        */
   		EXEC SQL 
   			DECLARE 
   				CursorListTpRelacionamento CURSOR FOR 
			SELECT 
			    TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
			   ,TIPORELACIONAMENTO.NMTIPORELACIONAMENTO
			FROM CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO,
			    CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTO,
			    CONTATOADM.TIPOPESSOATPRELACIONAMENTO TIPOPESSOATPRELACIONAMENTO
			WHERE TIPOPESSOATPRELACIONAMENTO.IDCONTATOTIPORETORNO = CONTATOTIPORETORNO.IDCONTATOTIPORETORNO
			AND TIPOPESSOATPRELACIONAMENTO.IDTIPORELACIONAMENTO = TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
			AND
			    CONTATOTIPORETORNO.IDCONTATOTIPORETORNO = :cAuxidTipoContato;
        
        
		//Abre o cursor
		EXEC SQL OPEN CursorListTpRelacionamento;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListTpRelacionamento INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stdsContatoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListTpRelacionamento;

	}
	catch(...)
	{
		throw;
	}
    ULOG_END("CContatoTipoRetornoRelacoes::ListTpRelacionamento()");
	//Retorna a quantidade de registros
	return iCont;

GotoListTpRelacionamento:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListSegmentacao( char* cidTipoContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListSegmentacao()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidTipoContato = cidTipoContato; 
		struct
		{
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stdsContatoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoRelacao;
			short idsContatoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListSegmentacao;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		/*
   		EXEC SQL 
   			DECLARE 
   				CursorListSegmentacao CURSOR FOR 
			SELECT 
			    RELACAO.IDSEGMENTACAO
			   ,RELACAO.DSSEGMENTACAO
			FROM 
			    CONTATOADM.TIPORETORNOSEGMENTACAOBZEROUM RELACAO
			WHERE
			    RELACAO.IDCONTATOTIPORETORNO = :cAuxidTipoContato;
        */

   		EXEC SQL 
   			DECLARE 
   				CursorListSegmentacao CURSOR FOR 
			SELECT 
			    SEGMENTACAO.IDSEGMENTACAO
			   ,SEGMENTACAO.DSSEGMENTACAO
			FROM CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO,
			    APOIO.SEGMENTACAO SEGMENTACAO,
			    CONTATOADM.TIPORETORNOSEGMENTACAO TIPORETORNOSEGMENTACAO
			WHERE TIPORETORNOSEGMENTACAO.IDSEGMENTACAO = SEGMENTACAO.IDSEGMENTACAO
			AND TIPORETORNOSEGMENTACAO.IDCONTATOTIPORETORNO = CONTATOTIPORETORNO.IDCONTATOTIPORETORNO
			AND CONTATOTIPORETORNO.IDCONTATOTIPORETORNO = :cAuxidTipoContato;
        
		//Abre o cursor
		EXEC SQL OPEN CursorListSegmentacao;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListSegmentacao INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stdsContatoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListSegmentacao;

	}
	catch(...)
	{
		throw;
	}
    ULOG_END("CContatoTipoRetornoRelacoes::ListSegmentacao()");
	//Retorna a quantidade de registros
	return iCont;

GotoListSegmentacao:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListProcedencia( char* cidTipoContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListProcedencia()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidTipoContato = cidTipoContato; 
		struct
		{
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stdsContatoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoRelacao;
			short idsContatoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListProcedencia;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		/*
   		EXEC SQL 
   			DECLARE 
   				CursorListProcedencia CURSOR FOR 
			SELECT 
			    RELACAO.IDPROCEDENCIA
			   ,RELACAO.DSPROCEDENCIA
			FROM 
			    CONTATOADM.TIPORETORNOPROCEDENCIABZEROUM RELACAO
			WHERE
			    RELACAO.IDCONTATOTIPORETORNO = :cAuxidTipoContato;
        */
   		EXEC SQL 
   			DECLARE 
   				CursorListProcedencia CURSOR FOR 
			SELECT 
			    PROCEDENCIA.IDPROCEDENCIA
			   ,PROCEDENCIA.DSPROCEDENCIA
			FROM CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO,
			    APOIO.PROCEDENCIA PROCEDENCIA,
			    CONTATOADM.TIPORETORNOPROCEDENCIA TIPORETORNOPROCEDENCIA
			WHERE TIPORETORNOPROCEDENCIA.IDPROCEDENCIA = PROCEDENCIA.IDPROCEDENCIA
			AND TIPORETORNOPROCEDENCIA.IDCONTATOTIPORETORNO = CONTATOTIPORETORNO.IDCONTATOTIPORETORNO
			AND
			    CONTATOTIPORETORNO.IDCONTATOTIPORETORNO = :cAuxidTipoContato;
        
		//Abre o cursor
		EXEC SQL OPEN CursorListProcedencia;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListProcedencia INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stdsContatoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListProcedencia;

	}
	catch(...)
	{
		throw;
	}

    ULOG_END("CContatoTipoRetornoRelacoes::ListProcedencia()");
	//Retorna a quantidade de registros
	return iCont;

GotoListProcedencia:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListTipoLinha( char* cidTipoContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListTipoLinha()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidTipoContato = cidTipoContato; 
		struct
		{
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stdsContatoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoRelacao;
			short idsContatoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListTipoLinha;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		/*
   		EXEC SQL 
   			DECLARE 
   				CursorListTipoLinha CURSOR FOR 
			SELECT 
			    RELACAO.IDTIPOLINHA
			   ,RELACAO.DSTIPOLINHA
			FROM 
			    CONTATOADM.TIPORETORNOTIPOLINHABZEROUM RELACAO
			WHERE
			    RELACAO.IDCONTATOTIPORETORNO = :cAuxidTipoContato;
        */
   		EXEC SQL 
   			DECLARE 
   				CursorListTipoLinha CURSOR FOR 
			SELECT 
			    TIPOLINHA.IDTIPOLINHA
			   ,TIPOLINHA.DSTIPOLINHA
			FROM CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO,
			    APOIO.TIPOLINHA TIPOLINHA,
			    CONTATOADM.TIPORETORNOTIPOLINHA TIPORETORNOTIPOLINHA
			WHERE TIPORETORNOTIPOLINHA.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
			AND TIPORETORNOTIPOLINHA.IDCONTATOTIPORETORNO = CONTATOTIPORETORNO.IDCONTATOTIPORETORNO
			AND
			    CONTATOTIPORETORNO.IDCONTATOTIPORETORNO = :cAuxidTipoContato;
        
		//Abre o cursor
		EXEC SQL OPEN CursorListTipoLinha;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListTipoLinha INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stdsContatoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListTipoLinha;

	}
	catch(...)
	{
		throw;
	}
    ULOG_END("CContatoTipoRetornoRelacoes::ListTipoLinha()");
	//Retorna a quantidade de registros
	return iCont;

GotoListTipoLinha:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListTipoCarteira( char* cidTipoContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListTipoCarteira()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidTipoContato = cidTipoContato; 
		struct
		{
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stdsContatoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoRelacao;
			short idsContatoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListTipoCarteira;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		/*
   		EXEC SQL 
   			DECLARE 
   				CursorListTipoCarteira CURSOR FOR 
			SELECT 
			    RELACAO.IDTIPOCARTEIRA
			   ,RELACAO.DSTIPOCARTEIRA
			FROM 
			    CONTATOADM.TIPORETORNOTIPOCARTEIRABZEROUM RELACAO
			WHERE
			    RELACAO.IDCONTATOTIPORETORNO = :cAuxidTipoContato;
        */
   		EXEC SQL 
   			DECLARE 
   				CursorListTipoCarteira CURSOR FOR 
			SELECT 
			    TIPOCARTEIRA.IDTIPOCARTEIRA
			   ,TIPOCARTEIRA.DSTIPOCARTEIRA
			FROM CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO,
			    APOIO.TIPOCARTEIRA TIPOCARTEIRA,
			    CONTATOADM.TIPORETORNOTIPOCARTEIRA TIPORETORNOTIPOCARTEIRA
			WHERE TIPORETORNOTIPOCARTEIRA.IDTIPOCARTEIRA = TIPOCARTEIRA.IDTIPOCARTEIRA
			AND TIPORETORNOTIPOCARTEIRA.IDCONTATOTIPORETORNO = CONTATOTIPORETORNO.IDCONTATOTIPORETORNO
			AND
			    CONTATOTIPORETORNO.IDCONTATOTIPORETORNO = :cAuxidTipoContato;
        
        
		//Abre o cursor
		EXEC SQL OPEN CursorListTipoCarteira;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListTipoCarteira INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stdsContatoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListTipoCarteira;

	}
	catch(...)
	{
		throw;
	}

    ULOG_START("CContatoTipoRetornoRelacoes::ListTipoCarteira()");
	//Retorna a quantidade de registros
	return iCont;

GotoListTipoCarteira:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListTipoPessoa( char* cidTipoContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListTipoPessoa()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidTipoContato = cidTipoContato; 
		struct
		{
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stdsContatoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoRelacao;
			short idsContatoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListTipoPessoa;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		/*
   		EXEC SQL 
   			DECLARE 
   				CursorListTipoPessoa CURSOR FOR 
			SELECT 
			    RELACAO.IDTIPOPESSOA
			   ,RELACAO.DSTIPOPESSOA
			FROM 
			    CONTATOADM.TIPORETORNOTIPOPESSOABZEROUM RELACAO
			WHERE
			    RELACAO.IDCONTATOTIPORETORNO = :cAuxidTipoContato;
        */
        
   		EXEC SQL 
   			DECLARE 
   				CursorListTipoPessoa CURSOR FOR 
			SELECT 
			    TIPOPESSOA.IDTIPOPESSOA
  		       ,TIPOPESSOA.DSTIPOPESSOA
		    FROM 
		        CONTATOADM.TIPORETORNOCONTATO TIPORETORNOCONTATO,
		        CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO,
		        APOIO.TIPOPESSOA TIPOPESSOA,
		        CONTATOADM.TIPORETORNOTIPOPESSOA TIPORETORNOTIPOPESSOA
		    WHERE 
			    CONTATOTIPORETORNO.IDTIPORETORNOCONTATO = TIPORETORNOCONTATO.IDTIPORETORNOCONTATO
		    AND 
			    TIPORETORNOTIPOPESSOA.IDTIPOPESSOA = TIPOPESSOA.IDTIPOPESSOA
		    AND 
			    TIPORETORNOTIPOPESSOA.IDCONTATOTIPORETORNO = CONTATOTIPORETORNO.IDCONTATOTIPORETORNO
			AND
			    CONTATOTIPORETORNO.IDCONTATOTIPORETORNO = :cAuxidTipoContato;

		//Abre o cursor
		EXEC SQL OPEN CursorListTipoPessoa;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListTipoPessoa INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stdsContatoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListTipoPessoa;

	}
	catch(...)
	{
		throw;
	}

    ULOG_END("CContatoTipoRetornoRelacoes::ListTipoPessoa()");
	//Retorna a quantidade de registros
	return iCont;

GotoListTipoPessoa:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListGrupo( char* cidContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListGrupo()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
		struct
		{
			//VARCHAR stidContatoTipoRetornoRelacoes[21+1];
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stdsContatoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			//short iidContatoTipoRetornoRelacoes;
			short iidContatoRelacao;
			short idsContatoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListGrupo;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		/*
   		EXEC SQL 
   			DECLARE 
   				CursorListGrupo CURSOR FOR 
			SELECT DISTINCT
			    //RELACAO.IDCONTATOGRUPO
			    RELACAO.IDGRUPO
			   ,RELACAO.NMGRUPO
			FROM 
			    CONTATOADM.CONTATOGRUPOBZEROUM RELACAO
			WHERE
			    RELACAO.IDCONTATO = :cAuxidContato
			ORDER BY
				RELACAO.NMGRUPO;
        */
        
   		EXEC SQL 
   			DECLARE 
   				CursorListGrupo CURSOR FOR 
			SELECT DISTINCT
			    GRUPO.IDGRUPO
			   ,GRUPO.NMGRUPO
			FROM 
			    ACESSO.GRUPO GRUPO,
			    CONTATOADM.CONTATOGRUPO CONTATOGRUPO
			WHERE 
			    CONTATOGRUPO.IDGRUPO = GRUPO.IDGRUPO
			AND 
			    CONTATOGRUPO.IDCONTATO = :cAuxidContato
			ORDER BY
				GRUPO.NMGRUPO;

		//Abre o cursor
		EXEC SQL OPEN CursorListGrupo;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListGrupo INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				//(char*)stRelacaoRegistro.stidContatoTipoRetornoRelacoes.arr,
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stdsContatoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListGrupo;

	}
	catch(...)
	{
		throw;
	}
    ULOG_END("CContatoTipoRetornoRelacoes::ListGrupo()");
	//Retorna a quantidade de registros
	return iCont;

GotoListGrupo:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListTipoSequencia( char* cidGrupo, char* cidContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListTipoSequencia()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidGrupo = cidGrupo; 
		char* cAuxidContato = cidContato;
		struct
		{
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stdsContatoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoRelacao;
			short idsContatoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListTipoSequencia;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorListTipoSequencia CURSOR FOR 
			SELECT DISTINCT
			    TIPOSEQUENCIA.IDTIPOSEQUENCIA
			   ,TIPOSEQUENCIA.NMTIPOSEQUENCIA
			FROM 
			    CONTATOADM.SEQUENCIA SEQUENCIA,
                CONTATOADM.TIPOSEQUENCIA TIPOSEQUENCIA,
                CONTATOADM.CONTATOGRUPO CONTATOGRUPO
			WHERE
                CONTATOGRUPO.IDCONTATOGRUPO = SEQUENCIA.IDCONTATOGRUPO
			AND
                SEQUENCIA.IDTIPOSEQUENCIA = TIPOSEQUENCIA.IDTIPOSEQUENCIA
			AND
                SEQUENCIA.DTEXCLUSAO IS NULL
            AND
			    CONTATOGRUPO.IDGRUPO = :cAuxidGrupo
			AND
				CONTATOGRUPO.IDCONTATO = :cAuxidContato;

		//Abre o cursor
		EXEC SQL OPEN CursorListTipoSequencia;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListTipoSequencia INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stdsContatoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListTipoSequencia;

	}
	catch(...)
	{
		throw;
	}

    ULOG_END("CContatoTipoRetornoRelacoes::ListTipoSequencia()");
	//Retorna a quantidade de registros
	return iCont;

GotoListTipoSequencia:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListGrupoCanal( char* cidGrupo )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListGrupoCanal()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidGrupo = cidGrupo; 
		struct
		{
			VARCHAR stidGrupoRelacao[21+1];
			VARCHAR stdsGrupoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidGrupoRelacao;
			short idsGrupoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListGrupoCanal;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		/*
   		EXEC SQL 
   			DECLARE 
   				CursorListGrupoCanal CURSOR FOR 
			SELECT 
			    RELACAO.IDCANAL
			   ,RELACAO.NMCANAL
			FROM 
			    ACESSO.GRUPOCANALBZEROUM RELACAO
			WHERE
			    RELACAO.IDGRUPO = :cAuxidGrupo;
        */
        
        
   		EXEC SQL 
   			DECLARE 
   				CursorListGrupoCanal CURSOR FOR 
			SELECT 
			    CANAL.IDCANAL
			   ,CANAL.NMCANAL
			FROM APOIO.CANAL CANAL,
			    ACESSO.GRUPO GRUPO,
			    ACESSO.GRUPOCANAL GRUPOCANAL
			WHERE GRUPOCANAL.IDGRUPO = GRUPO.IDGRUPO
			AND GRUPOCANAL.IDCANAL = CANAL.IDCANAL
			AND GRUPO.IDGRUPO = :cAuxidGrupo;
				
		//Abre o cursor
		EXEC SQL OPEN CursorListGrupoCanal;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListGrupoCanal INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidGrupoRelacao.arr,
				(char*)stRelacaoRegistro.stdsGrupoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListGrupoCanal;

	}
	catch(...)
	{
		throw;
	}

    ULOG_END("CContatoTipoRetornoRelacoes::ListGrupoCanal()");
	//Retorna a quantidade de registros
	return iCont;

GotoListGrupoCanal:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListGrupoTpRelacionamento( char* cidGrupo )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListGrupoTpRelacionamento()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidGrupo = cidGrupo; 
		struct
		{
			VARCHAR stidGrupoRelacao[21+1];
			VARCHAR stdsGrupoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidGrupoRelacao;
			short idsGrupoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListGrupoTpRelacionamento;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		/*
   		EXEC SQL 
   			DECLARE 
   				CursorListGrupoTpRelacionamento CURSOR FOR 
			SELECT 
			    RELACAO.IDTIPORELACIONAMENTO
			   ,RELACAO.NMTIPORELACIONAMENTO
			FROM 
			    CONTATOADM.TIPORELACIONAMENTOGRUPOBZEROUM RELACAO
			WHERE
			    RELACAO.IDGRUPO = :cAuxidGrupo;
        */
        
   		EXEC SQL 
   			DECLARE 
   				CursorListGrupoTpRelacionamento CURSOR FOR 
			SELECT 
			    TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
			   ,TIPORELACIONAMENTO.NMTIPORELACIONAMENTO
			FROM 
			    ACESSO.GRUPO GRUPO,
			    CUSTOMER.TIPORELACIONAMENTO TIPORELACIONAMENTO,
			    CONTATOADM.TIPORELACIONAMENTOGRUPO TIPORELACIONAMENTOGRUPO
			WHERE 
			    TIPORELACIONAMENTOGRUPO.IDGRUPO = GRUPO.IDGRUPO
			AND 
			    TIPORELACIONAMENTOGRUPO.IDTIPORELACIONAMENTO = TIPORELACIONAMENTO.IDTIPORELACIONAMENTO
			AND GRUPO.IDGRUPO = :cAuxidGrupo;

		//Abre o cursor
		EXEC SQL OPEN CursorListGrupoTpRelacionamento;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListGrupoTpRelacionamento INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidGrupoRelacao.arr,
				(char*)stRelacaoRegistro.stdsGrupoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListGrupoTpRelacionamento;

	}
	catch(...)
	{
		throw;
	}

    ULOG_END("CContatoTipoRetornoRelacoes::ListGrupoTpRelacionamento()");
	//Retorna a quantidade de registros
	return iCont;

GotoListGrupoTpRelacionamento:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListGrupoSegmentacao( char* cidGrupo )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListGrupoSegmentacao()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidGrupo = cidGrupo; 
		struct
		{
			VARCHAR stidGrupoRelacao[21+1];
			VARCHAR stdsGrupoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidGrupoRelacao;
			short idsGrupoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListGrupoSegmentacao;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		/*
   		EXEC SQL 
   			DECLARE 
   				CursorListGrupoSegmentacao CURSOR FOR 
			SELECT 
			    RELACAO.IDSEGMENTACAO
			   ,RELACAO.DSSEGMENTACAO
			FROM 
			    CONTATOADM.SEGMENTACAOGRUPOBZEROUM RELACAO
			WHERE
			    RELACAO.IDGRUPO = :cAuxidGrupo;
        */
   		EXEC SQL 
   			DECLARE 
   				CursorListGrupoSegmentacao CURSOR FOR 
			SELECT 
			    SEGMENTACAO.IDSEGMENTACAO
			   ,SEGMENTACAO.DSSEGMENTACAO
			FROM 
			    ACESSO.GRUPO GRUPO,
			    APOIO.SEGMENTACAO SEGMENTACAO,
			    CONTATOADM.SEGMENTACAOGRUPO SEGMENTACAOGRUPO
			WHERE SEGMENTACAOGRUPO.IDGRUPO = GRUPO.IDGRUPO
			AND SEGMENTACAOGRUPO.IDSEGMENTACAO = SEGMENTACAO.IDSEGMENTACAO
			AND GRUPO.IDGRUPO = :cAuxidGrupo;
				        
		//Abre o cursor
		EXEC SQL OPEN CursorListGrupoSegmentacao;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListGrupoSegmentacao INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidGrupoRelacao.arr,
				(char*)stRelacaoRegistro.stdsGrupoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListGrupoSegmentacao;

	}
	catch(...)
	{
		throw;
	}

    ULOG_END("CContatoTipoRetornoRelacoes::ListGrupoSegmentacao()");
	//Retorna a quantidade de registros
	return iCont;

GotoListGrupoSegmentacao:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListGrupoProcedencia( char* cidGrupo )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListGrupoProcedencia()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidGrupo = cidGrupo; 
		struct
		{
			VARCHAR stidGrupoRelacao[21+1];
			VARCHAR stdsGrupoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidGrupoRelacao;
			short idsGrupoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListGrupoProcedencia;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		/*
   		EXEC SQL 
   			DECLARE 
   				CursorListGrupoProcedencia CURSOR FOR 
			SELECT 
			    RELACAO.IDPROCEDENCIA
			   ,RELACAO.DSPROCEDENCIA
			FROM 
			    CONTATOADM.PROCEDENCIAGRUPOBZEROUM RELACAO
			WHERE
			    RELACAO.IDGRUPO = :cAuxidGrupo;
        */
        
   		EXEC SQL 
   			DECLARE 
   				CursorListGrupoProcedencia CURSOR FOR 
			SELECT 
			    PROCEDENCIA.IDPROCEDENCIA
			   ,PROCEDENCIA.DSPROCEDENCIA
			FROM 
			    ACESSO.GRUPO GRUPO,
			    APOIO.PROCEDENCIA PROCEDENCIA,
			    CONTATOADM.PROCEDENCIAGRUPO PROCEDENCIAGRUPO
			WHERE PROCEDENCIAGRUPO.IDGRUPO = GRUPO.IDGRUPO
            AND PROCEDENCIAGRUPO.IDPROCEDENCIA = PROCEDENCIA.IDPROCEDENCIA
			AND GRUPO.IDGRUPO = :cAuxidGrupo;

		//Abre o cursor
		EXEC SQL OPEN CursorListGrupoProcedencia;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListGrupoProcedencia INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidGrupoRelacao.arr,
				(char*)stRelacaoRegistro.stdsGrupoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListGrupoProcedencia;

	}
	catch(...)
	{
		throw;
	}
    ULOG_END("CContatoTipoRetornoRelacoes::ListGrupoProcedencia()");
	//Retorna a quantidade de registros
	return iCont;

GotoListGrupoProcedencia:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListGrupoTipoLinha( char* cidGrupo )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListGrupoTipoLinha()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidGrupo = cidGrupo; 
		struct
		{
			VARCHAR stidGrupoRelacao[21+1];
			VARCHAR stdsGrupoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidGrupoRelacao;
			short idsGrupoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListGrupoTipoLinha;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
		/*
   		EXEC SQL 
   			DECLARE 
   				CursorListGrupoTipoLinha CURSOR FOR 
			SELECT 
			    RELACAO.IDTIPOLINHA
			   ,RELACAO.DSTIPOLINHA
			FROM 
			    CONTATOADM.TIPOLINHAGRUPOBZEROUM RELACAO
			WHERE
			    RELACAO.IDGRUPO = :cAuxidGrupo;
        */
   		EXEC SQL 
   			DECLARE 
   				CursorListGrupoTipoLinha CURSOR FOR 
			SELECT 
			    TIPOLINHA.IDTIPOLINHA
			   ,TIPOLINHA.DSTIPOLINHA
			FROM 
			    ACESSO.GRUPO GRUPO,
			    APOIO.TIPOLINHA TIPOLINHA,
			    CONTATOADM.TIPOLINHAGRUPO TIPOLINHAGRUPO
			WHERE TIPOLINHAGRUPO.IDGRUPO = GRUPO.IDGRUPO
			AND TIPOLINHAGRUPO.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
			AND GRUPO.IDGRUPO = :cAuxidGrupo;
				        
		//Abre o cursor
		EXEC SQL OPEN CursorListGrupoTipoLinha;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListGrupoTipoLinha INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidGrupoRelacao.arr,
				(char*)stRelacaoRegistro.stdsGrupoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListGrupoTipoLinha;
		
		ULOG_END("CContatoTipoRetornoRelacoes::ListGrupoTipoLinha()");

	}
	catch(...)
	{
		throw;
	}

	//Retorna a quantidade de registros
	return iCont;

GotoListGrupoTipoLinha:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListGrupoTipoCarteira( char* cidGrupo )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListGrupoTipoCarteira()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidGrupo = cidGrupo; 
		struct
		{
			VARCHAR stidGrupoRelacao[21+1];
			VARCHAR stdsGrupoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidGrupoRelacao;
			short idsGrupoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListGrupoTipoCarteira;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		/*
   		EXEC SQL 
   			DECLARE 
   				CursorListGrupoTipoCarteira CURSOR FOR 
			SELECT 
			    RELACAO.IDTIPOCARTEIRA
			   ,RELACAO.DSTIPOCARTEIRA
			FROM 
			    CONTATOADM.TIPOCARTEIRAGRUPOBZEROUM RELACAO
			WHERE
			    RELACAO.IDGRUPO = :cAuxidGrupo;
        */

   		EXEC SQL 
   			DECLARE 
   				CursorListGrupoTipoCarteira CURSOR FOR 
			SELECT 
			    TIPOCARTEIRA.IDTIPOCARTEIRA
			   ,TIPOCARTEIRA.DSTIPOCARTEIRA
			FROM 
			    ACESSO.GRUPO GRUPO,
			    APOIO.TIPOCARTEIRA TIPOCARTEIRA,
			    CONTATOADM.TIPOCARTEIRAGRUPO TIPOCARTEIRAGRUPO
			WHERE TIPOCARTEIRAGRUPO.IDGRUPO = GRUPO.IDGRUPO
			AND TIPOCARTEIRAGRUPO.IDTIPOCARTEIRA = TIPOCARTEIRA.IDTIPOCARTEIRA
			AND GRUPO.IDGRUPO = :cAuxidGrupo;
				        
		//Abre o cursor
		EXEC SQL OPEN CursorListGrupoTipoCarteira;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListGrupoTipoCarteira INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidGrupoRelacao.arr,
				(char*)stRelacaoRegistro.stdsGrupoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListGrupoTipoCarteira;
		
		ULOG_END("CContatoTipoRetornoRelacoes::ListGrupoTipoCarteira()");

	}
	catch(...)
	{
		throw;
	}

	//Retorna a quantidade de registros
	return iCont;

GotoListGrupoTipoCarteira:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListGrupoTipoPessoa( char* cidGrupo )
{
    
    ULOG_START("CContatoTipoRetornoRelacoes::ListGrupoTipoPessoa()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidGrupo = cidGrupo; 
		struct
		{
			VARCHAR stidGrupoRelacao[21+1];
			VARCHAR stdsGrupoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidGrupoRelacao;
			short idsGrupoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListGrupoTipoPessoa;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
		/*
   		EXEC SQL 
   			DECLARE 
   				CursorListGrupoTipoPessoa CURSOR FOR 
			SELECT 
			    RELACAO.IDTIPOPESSOA
			   ,RELACAO.DSTIPOPESSOA
			FROM 
			    CONTATOADM.TIPOPESSOAGRUPOBZEROUM RELACAO
			WHERE
			    RELACAO.IDGRUPO = :cAuxidGrupo;
        */
   		EXEC SQL 
   			DECLARE 
   				CursorListGrupoTipoPessoa CURSOR FOR 
			SELECT 
			    TIPOPESSOA.IDTIPOPESSOA
			   ,TIPOPESSOA.DSTIPOPESSOA
			FROM 
			    ACESSO.GRUPO GRUPO,
			    APOIO.TIPOPESSOA TIPOPESSOA,
			    CONTATOADM.TIPOPESSOAGRUPO TIPOPESSOAGRUPO
			WHERE 
				TIPOPESSOAGRUPO.IDGRUPO = GRUPO.IDGRUPO
			AND 
			    TIPOPESSOAGRUPO.IDTIPOPESSOA = TIPOPESSOA.IDTIPOPESSOA
			AND
			    GRUPO.IDGRUPO = :cAuxidGrupo;        
		//Abre o cursor
		EXEC SQL OPEN CursorListGrupoTipoPessoa;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListGrupoTipoPessoa INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidGrupoRelacao.arr,
				(char*)stRelacaoRegistro.stdsGrupoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListGrupoTipoPessoa;
		
		ULOG_END("CContatoTipoRetornoRelacoes::ListGrupoTipoPessoa()");

	}
	catch(...)
	{
		throw;
	}

	//Retorna a quantidade de registros
	return iCont;

GotoListGrupoTipoPessoa:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListContatoTipoRetorno( char* cidContato )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListContatoTipoRetorno()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
		struct
		{
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stdsContatoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoRelacao;
			short idsContatoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListContatoTipoRetorno;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorListContatoTipoRetorno CURSOR FOR 
			SELECT 
			    CONTATOTIPORETORNO.IDCONTATOTIPORETORNO
			   ,TIPORETORNOCONTATO.NMTIPORETORNOCONTATO
			FROM 
			    CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO,
                CONTATOADM.TIPORETORNOCONTATO TIPORETORNOCONTATO
            WHERE
                CONTATOTIPORETORNO.IDTIPORETORNOCONTATO = TIPORETORNOCONTATO.IDTIPORETORNOCONTATO
			AND
			    CONTATOTIPORETORNO.IDCONTATO = :cAuxidContato;

		//Abre o cursor
		EXEC SQL OPEN CursorListContatoTipoRetorno;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListContatoTipoRetorno INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stdsContatoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListContatoTipoRetorno;
		
		ULOG_END("CContatoTipoRetornoRelacoes::ListContatoTipoRetorno()");

	}
	catch(...)
	{
		throw;
	}

	//Retorna a quantidade de registros
	return iCont;

GotoListContatoTipoRetorno:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListTipoGrupoAbertura( char* cidTipoContato )
{
    
    ULOG_START("CContatoTipoRetornoRelacoes::ListTipoGrupoAbertura()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidTipoContato = cidTipoContato; 
		struct
		{
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stdsContatoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoRelacao;
			short idsContatoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListTipoGrupo;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
        // ====================================================================
   		// Remoo de views BZEROUM - Maio/2007 -- Cassio
        // ====================================================================
        // EXEC SQL 
   		// 	DECLARE 
   		// 		CursorListTipoGrupo CURSOR FOR 
		// 	SELECT DISTINCT
		// 	    RELACAO.IDGRUPO
		// 	   ,RELACAO.NMGRUPO
		// 	FROM 
		// 	    CONTATOADM.TIPORETORNOSEQUENCIABZEROUM RELACAO
		// 	WHERE
        //         RELACAO.IDTIPOSEQUENCIA = 1 //Recupera apenas os grupos de abertura (eu nao gosto de usar ID hardcode em codigo, Eder, mas como nao tem sigla)
        //     AND
		// 	    RELACAO.IDCONTATOTIPORETORNO = :cAuxidTipoContato;

        EXEC SQL 
            DECLARE 
                CursorListTipoGrupo CURSOR FOR
			SELECT DISTINCT
			    GRUPO.IDGRUPO
			   ,GRUPO.NMGRUPO
			FROM 
				CONTATOADM.CONTATOTIPORETORNO CONTATOTIPORETORNO,
				CONTATOADM.TIPORETORNOSEQUENCIA TIPORETORNOSEQUENCIA,
				CONTATOADM.SEQUENCIA SEQUENCIA,
				CONTATOADM.CONTATOGRUPO CONTATOGRUPO,
				ACESSO.GRUPO GRUPO,
				CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
				CONTATOADM.TIPOSEQUENCIA TIPOSEQUENCIA
			WHERE
			    CONTATOTIPORETORNO.IDCONTATOTIPORETORNO = TIPORETORNOSEQUENCIA.IDCONTATOTIPORETORNO
			AND TIPORETORNOSEQUENCIA.IDSEQUENCIA = SEQUENCIA.IDSEQUENCIA
			AND SEQUENCIA.IDCONTATOGRUPO = CONTATOGRUPO.IDCONTATOGRUPO
			AND CONTATOGRUPO.IDCONTATO = CONTATOFOLHA.IDCONTATO
			AND SEQUENCIA.IDTIPOSEQUENCIA = TIPOSEQUENCIA.IDTIPOSEQUENCIA
			AND TIPOSEQUENCIA.NMTIPOSEQUENCIA = 'ABERTURA'
			AND CONTATOGRUPO.IDGRUPO = GRUPO.IDGRUPO
			AND GRUPO.DTEXCLUSAO IS NULL
		    AND SEQUENCIA.DTEXCLUSAO IS NULL
            AND CONTATOTIPORETORNO.IDCONTATOTIPORETORNO = :cAuxidTipoContato;

		//Abre o cursor
		EXEC SQL OPEN CursorListTipoGrupo;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListTipoGrupo INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stdsContatoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorListTipoGrupo;

	}
	catch(...)
	{
		throw;
	}
    ULOG_END("CContatoTipoRetornoRelacoes::ListTipoGrupoAbertura()");
	//Retorna a quantidade de registros
	return iCont;

GotoListTipoGrupo:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoTipoRetornoRelacoes::ListGrupoAbertura( char* cidGrupo )
{
    ULOG_START("CContatoTipoRetornoRelacoes::ListGrupoAbertura()");
	//Variavel de controle para a quantidade de registros retornada
	int iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidGrupo = cidGrupo; 
		struct
		{
			VARCHAR stidContatoRelacao[21+1];
			VARCHAR stdsContatoRelacao[255+1];
		} stRelacaoRegistro;
		struct
		{
			short iidContatoRelacao;
			short idsContatoRelacao;
		} stRelacaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoTipoRetornoRelacoes();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoGrupoAbertura;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorGrupoAbertura CURSOR FOR 
			SELECT DISTINCT
			    GRUPO.IDGRUPO
			   ,GRUPO.NMGRUPO
			FROM 
			    CONTATOADM.GRUPOABERTURAGRUPO GRUPOABERTURA,
                ACESSO.GRUPO GRUPO
			WHERE
                GRUPOABERTURA.IDGRUPOPAI = GRUPO.IDGRUPO
            AND
			    GRUPOABERTURA.IDGRUPO = :cAuxidGrupo;

		//Abre o cursor
		EXEC SQL OPEN CursorGrupoAbertura;

		//Caso inexista registros sair do loop
		EXEC SQL WHENEVER NOT FOUND DO break;
		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRelacaoRegistro, 0, sizeof(stRelacaoRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorGrupoAbertura INTO :stRelacaoRegistro:stRelacaoIndicator;
			//Adiciona a classe
			Add( 	
				(char*)stRelacaoRegistro.stidContatoRelacao.arr,
				(char*)stRelacaoRegistro.stdsContatoRelacao.arr
			);
			//conta quantos existem
			iCont++;
		}
		//Fecha o CURSOR
		EXEC SQL CLOSE CursorGrupoAbertura;

	}
	catch(...)
	{
		throw;
	}
	
	ULOG_END("CContatoTipoRetornoRelacoes::ListGrupoAbertura()");

	//Retorna a quantidade de registros
	return iCont;

GotoGrupoAbertura:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}
