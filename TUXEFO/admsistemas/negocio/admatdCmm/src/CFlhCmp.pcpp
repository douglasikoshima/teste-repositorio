#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CFlhCmp.h"
#include "../include/CSafePointer.h"

#include<list>
#include<iterator>

using namespace std;

#define NRO_MAX_REGS 100

#define CONVIND(O,I) \
{\
	if (I == -1) { \
		##O.arr[0]=0; \
	} else { \
		##O.arr[##O.len]=0; \
	} \
}

#define strToOra(vchar,bstr)   vchar.len = strlen(bstr);strncpy((char *)vchar.arr,bstr,vchar.len);vchar.arr[vchar.len] = 0


typedef list<unsigned long> ListaGrupos;
list<unsigned long>::iterator itGrupoLoad;
ListaGrupos LGrupos;

CContatoFolhaCampo::CContatoFolhaCampo()
{
}

CContatoFolhaCampo::CContatoFolhaCampo( DOMNode* dnode,LISTA_UF * pUF_Prm,LISTA_TPLINHA * pTpLinha_Prm )
{
	CSafePointer oSafePointer;
	idClassificadorPrm = strtoul((char *)oSafePointer.getTag(dnode,"idClassificadorCampoAtual",0),0,10);
	idContatoPrm = strtoul((char *)oSafePointer.getTag(dnode, "idContato",0),0,10);
	idFaseProcessoPrm = strtoul((char *)oSafePointer.getTag(dnode,"idFaseProcessoAtual",0),0,10);

	pUF = pUF_Prm;
	pTpLinha = pTpLinha_Prm;
}

CContatoFolhaCampo::~CContatoFolhaCampo()
{
}

int CContatoFolhaCampo::InsertArray( char* cidUsuarioAlteracao )
{
    ULOG_START("CContatoFolhaCampo::InsertArray()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			char cidContato[300][21+1];
			char cidUFOperadora[300][21+1];
			char cidTipoLinha[300][21+1];
			char cidCampo[300][21+1];
			char csqOrdemApresentacao[300][21+1];
			char cidFaseProcesso[300][21+1];
			char cidUsuarioAlteracao[300][21+1];
		}stRegistros;
		struct
		{
			short iidContato[300];
			short iidUFOperadora[300];
			short iidTipoLinha[300];
			short iidCampo[300];
			short isqOrdemApresentacao[300];
			short iidFaseProcesso[300];
			short iidUsuarioAlteracao[300];
		}stIndicator;
		int iCont = 0;
	EXEC SQL END DECLARE SECTION;

	memset( &stRegistros, 0, sizeof(stRegistros) );
	memset( &stIndicator, 0, sizeof(stIndicator) );
	for( int x=0; x < Quantidade(); x++ )
	{
		if( Registro(x)->iInsertArray == 1 )
		{
			strcpy( stRegistros.cidContato[iCont], Registro(x)->cidContato );
			strcpy( stRegistros.cidUFOperadora[iCont], Registro(x)->cidUFOperadora );
			strcpy( stRegistros.cidTipoLinha[iCont], Registro(x)->cidTipoLinha );
			strcpy( stRegistros.cidCampo[iCont], Registro(x)->cidCampo );
			strcpy( stRegistros.csqOrdemApresentacao[iCont], Registro(x)->csqOrdemApresentacao );
			strcpy( stRegistros.cidFaseProcesso[iCont], Registro(x)->cidFaseProcesso );
			strcpy( stRegistros.cidUsuarioAlteracao[iCont], cidUsuarioAlteracao );
			iCont++;
		}
		if( ( iCont == 300 ) || ( x == ( Quantidade()-1 ) ) )
		{
			EXEC SQL WHENEVER NOT FOUND CONTINUE;
			EXEC SQL WHENEVER SQLERROR CONTINUE;

			//Realiza o insert
			EXEC SQL INSERT INTO CONTATOADM.CONTATOFOLHACAMPO
			(	idContatoFolhaCampo,
				idContato,
				idUFOperadora,
				idTipoLinha,
				idCampo,
				sqOrdemApresentacao,
				idFaseProcesso,
				idUsuarioAlteracao,
				dtUltimaAlteracao
			)
			VALUES
			(	CONTATOADM.CONTATOFOLHACAMPOSQ.NEXTVAL,
				:stRegistros.cidContato,
				:stRegistros.cidUFOperadora,
				:stRegistros.cidTipoLinha,
				:stRegistros.cidCampo,
				:stRegistros.csqOrdemApresentacao,
				:stRegistros.cidFaseProcesso,
				:stRegistros.cidUsuarioAlteracao,
				SYSDATE
			);

			if( sqlca.sqlcode < 0 )
			{
				if( sqlca.sqlcode != -1400 ) //Ignorando a mensagem de erro ao inserir nulo
					goto GotoInsertArray;
			}
			memset( &stRegistros, 0, sizeof(stRegistros) );
			memset( &stIndicator, 0, sizeof(stIndicator) );
			iCont = 0;
		}
	}//for( int x=0; x < Quantidade(); x++ )
	ULOG_END("CContatoFolhaCampo::InsertArray()");
	return 1;//Sucesso

GotoInsertArray:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContatoFolhaCampo::Insert(
			char* cidContato,
			char* cidUFOperadora,
			char* cidTipoLinha,
			char* cidCampo,
			char* csqOrdemApresentacao,
			char* cidFaseProcesso,
			char* cidUsuarioAlteracao )
{
    ULOG_START("CContatoFolhaCampo::Insert()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cAuxidContatoFolhaCampo[21+1];
		char* cAuxidContato = cidContato;
		char* cAuxidUFOperadora = cidUFOperadora;
		char* cAuxidTipoLinha = cidTipoLinha;
		char* cAuxidCampo = cidCampo;
		char* cAuxsqOrdemApresentacao = csqOrdemApresentacao;
		char* cAuxidFaseProcesso = cidFaseProcesso;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		memset( &cAuxidContatoFolhaCampo, 0, sizeof(cAuxidContatoFolhaCampo) );

		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;

		//Pega um id unico e sequencia para a insercao
		EXEC SQL
			SELECT
				contatoadm.ContatoFolhaCampoSQ.NEXTVAL
			INTO
				:cAuxidContatoFolhaCampo
			FROM
				DUAL;

		//Realiza o insert
		EXEC SQL INSERT INTO contatoadm.ContatoFolhaCampo
		(	idContatoFolhaCampo,
			idContato,
			idUFOperadora,
			idTipoLinha,
			idCampo,
			sqOrdemApresentacao,
			idFaseProcesso,
			idUsuarioAlteracao,
			dtUltimaAlteracao)
		VALUES
		(	:cAuxidContatoFolhaCampo,
			:cAuxidContato,
			:cAuxidUFOperadora,
			:cAuxidTipoLinha,
			:cAuxidCampo,
			:cAuxsqOrdemApresentacao,
			:cAuxidFaseProcesso,
			:cAuxidUsuarioAlteracao,
			SYSDATE);

		Add( (char*)cAuxidContatoFolhaCampo.arr,
			 cAuxidContato,
			 cAuxidUFOperadora,
			 cAuxidTipoLinha,
			 cAuxidCampo,
			 cAuxsqOrdemApresentacao,
			 cAuxidFaseProcesso
		);

        ULOG_END("CContatoFolhaCampo::Insert()");
		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode) {
			return 0;//Erro
		}
		else {
			return 1;//Sucesso
		}
	}
	catch(...)
	{
		throw;
	}

GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContatoFolhaCampo::InsertFalso(
			char* cidContato,
			char* cidUFOperadora,
			char* cidTipoLinha,
			char* cidCampo,
			char* csqOrdemApresentacao,
			char* cidFaseProcesso )
{
	AddArray( "",
		 cidContato,
		 cidUFOperadora,
		 cidTipoLinha,
		 cidCampo,
		 csqOrdemApresentacao,
		 cidFaseProcesso
	);

	return 1;//Sucesso
}

int CContatoFolhaCampo::Update(
			char* cidContatoFolhaCampo,
			char* cidContato,
			char* cidUFOperadora,
			char* cidTipoLinha,
			char* cidCampo,
			char* csqOrdemApresentacao,
			char* cidFaseProcesso,
			char* cidUsuarioAlteracao )
{
    ULOG_START("CContatoFolhaCampo::Update()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
			char* cAuxidContatoFolhaCampo = cidContatoFolhaCampo;
			char* cAuxidContato = cidContato;
			char* cAuxidUFOperadora = cidUFOperadora;
			char* cAuxidTipoLinha = cidTipoLinha;
			char* cAuxidCampo = cidCampo;
			char* cAuxsqOrdemApresentacao = csqOrdemApresentacao;
			char* cAuxidFaseProcesso = cidFaseProcesso;
			char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoFolhaCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;

		//Executa a instrucao de update
		EXEC SQL
		UPDATE contatoadm.ContatoFolhaCampo
		SET 	idContato = :cAuxidContato,
		idUFOperadora = :cAuxidUFOperadora,
		idTipoLinha = :cAuxidTipoLinha,
		idCampo = :cAuxidCampo,
		sqOrdemApresentacao = :cAuxsqOrdemApresentacao,
		idFaseProcesso = :cAuxidFaseProcesso,
		idUsuarioAlteracao = :cAuxidUsuarioAlteracao,
		dtUltimaAlteracao = SYSDATE
		WHERE 	idContatoFolhaCampo = :cAuxidContatoFolhaCampo;

		ULOG_END("CContatoFolhaCampo::Update()");
		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
			return sqlca.sqlerrd[2];//Quantidade de linhas afetadas
	}
	catch(...)
	{
		throw;
	}

GotoUpdate:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContatoFolhaCampo::Delete( char* cidContatoFolhaCampo )
{
    ULOG_START("CContatoFolhaCampo::Delete()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContatoFolhaCampo = cidContatoFolhaCampo;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoFolhaCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
		sqlca.sqlcode=0;

		//Executa a instrucao de delecao
		EXEC SQL DELETE FROM contatoadm.ContatoFolhaCampo
		WHERE (idContatoFolhaCampo = :cAuxidContatoFolhaCampo);

		ULOG_END("CContatoFolhaCampo::Delete()");
		return 1;
	}
	catch(...)
	{
		throw;
	}

GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if( sqlca.sqlcode == -2292 )
		return 2;
	else
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoFolhaCampo::ListId( char* cidContato, char* cidFaseProcesso, char* cidCampoClassificador )
{
    ULOG_START("CContatoFolhaCampo::ListId()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		char* cAuxidFaseProcesso = cidFaseProcesso;
		char* cAuxidCampoClassificador = cidCampoClassificador;
		struct
		{
			VARCHAR stidContatoFolhaCampo[21+1];
			VARCHAR stidContato[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stidTipoLinha[21+1];
			VARCHAR stidCampo[21+1];
			VARCHAR stsqOrdemApresentacao[21+1];
			VARCHAR stidFaseProcesso[21+1];
		} stContatoFolhaCampoRegistro;
		struct
		{
			short iidContatoFolhaCampo;
			short iidContato;
			short iidUFOperadora;
			short iidTipoLinha;
			short iidCampo;
			short isqOrdemApresentacao;
			short iidFaseProcesso;
		} stContatoFolhaCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoFolhaCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs

/*   			SELECT
				IDCONTATOFOLHACAMPO,
				IDCONTATO,
				IDUFOPERADORA,
				IDTIPOLINHA,
				IDCAMPO,
				SQORDEMAPRESENTACAO,
				IDFASEPROCESSO
			FROM
				CONTATOADM.CONTATOFOLHACAMPOBZEROUM
			WHERE
				IDCONTATO = :cAuxidContato
			AND
				IDFASEPROCESSO = :cAuxidFaseProcesso
			AND
				IDCLASSIFICADORCAMPO = :cAuxidCampoClassificador;*/

		/*REMOVENDO BZEROUM
		 TCOSTA 18/06/2007 MPOG
		*/
   		EXEC SQL
			DECLARE
				CursorContatoFolhaCampoId CURSOR FOR
		 SELECT CONTATOFOLHACAMPO.IDCONTATOFOLHACAMPO,
				CONTATOFOLHACAMPO.IDCONTATO,
				CONTATOFOLHACAMPO.IDUFOPERADORA,
				CONTATOFOLHACAMPO.IDTIPOLINHA,
				CONTATOFOLHACAMPO.IDCAMPO,
				CONTATOFOLHACAMPO.SQORDEMAPRESENTACAO,
				CONTATOFOLHACAMPO.IDFASEPROCESSO
			FROM
				CONTATOADM.CONTATOFOLHACAMPO CONTATOFOLHACAMPO,
				CONTATOADM.CAMPO CAMPO
			WHERE CAMPO.IDCAMPO=CONTATOFOLHACAMPO.IDCAMPO			
			AND CONTATOFOLHACAMPO.IDCONTATO = :cAuxidContato
			AND CONTATOFOLHACAMPO.IDFASEPROCESSO = :cAuxidFaseProcesso
			AND	CAMPO.IDCLASSIFICADORCAMPO = :cAuxidCampoClassificador;

		//Abre o cursor
		EXEC SQL OPEN CursorContatoFolhaCampoId;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CContatoFolhaCampo::ListId()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stContatoFolhaCampoRegistro, 0, sizeof(stContatoFolhaCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorContatoFolhaCampoId INTO :stContatoFolhaCampoRegistro:stContatoFolhaCampoIndicator;
				//Adiciona a classe
				Add( 	(char*)stContatoFolhaCampoRegistro.stidContatoFolhaCampo.arr,
				(char*)stContatoFolhaCampoRegistro.stidContato.arr,
				(char*)stContatoFolhaCampoRegistro.stidUFOperadora.arr,
				(char*)stContatoFolhaCampoRegistro.stidTipoLinha.arr,
				(char*)stContatoFolhaCampoRegistro.stidCampo.arr,
				(char*)stContatoFolhaCampoRegistro.stsqOrdemApresentacao.arr,
				(char*)stContatoFolhaCampoRegistro.stidFaseProcesso.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorContatoFolhaCampoId;
		}
		ULOG_END("CContatoFolhaCampo::ListId()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContatoFolhaCampo::ListId( char* cidContato )
{
    ULOG_START("CContatoFolhaCampo::ListId()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		struct
		{
			VARCHAR stidContatoFolhaCampo[21+1];
			VARCHAR stidContato[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stidTipoLinha[21+1];
			VARCHAR stidCampo[21+1];
			VARCHAR stsqOrdemApresentacao[21+1];
			VARCHAR stidFaseProcesso[21+1];
		} stContatoFolhaCampoRegistro;
		struct
		{
			short iidContatoFolhaCampo;
			short iidContato;
			short iidUFOperadora;
			short iidTipoLinha;
			short iidCampo;
			short isqOrdemApresentacao;
			short iidFaseProcesso;
		} stContatoFolhaCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoFolhaCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListIdContato;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL
			DECLARE
				CursorContatoFolhaCampoIdContato CURSOR FOR
   			SELECT
				IDCONTATOFOLHACAMPO,
				IDCONTATO,
				IDUFOPERADORA,
				IDTIPOLINHA,
				IDCAMPO,
				SQORDEMAPRESENTACAO,
				IDFASEPROCESSO
			FROM
				CONTATOADM.CONTATOFOLHACAMPO
			WHERE
				IDCONTATO = :cAuxidContato;

		//Abre o cursor
		EXEC SQL OPEN CursorContatoFolhaCampoIdContato;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CContatoFolhaCampo::ListId()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stContatoFolhaCampoRegistro, 0, sizeof(stContatoFolhaCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorContatoFolhaCampoIdContato INTO :stContatoFolhaCampoRegistro:stContatoFolhaCampoIndicator;
				//Adiciona a classe
				Add(
					(char*)stContatoFolhaCampoRegistro.stidContatoFolhaCampo.arr,
					(char*)stContatoFolhaCampoRegistro.stidContato.arr,
					(char*)stContatoFolhaCampoRegistro.stidUFOperadora.arr,
					(char*)stContatoFolhaCampoRegistro.stidTipoLinha.arr,
					(char*)stContatoFolhaCampoRegistro.stidCampo.arr,
					(char*)stContatoFolhaCampoRegistro.stsqOrdemApresentacao.arr,
					(char*)stContatoFolhaCampoRegistro.stidFaseProcesso.arr
				);
				//conta quantos existem
				iCont++;
			}
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorContatoFolhaCampoIdContato;
		}
		ULOG_END("CContatoFolhaCampo::ListId()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListIdContato:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);


}

int CContatoFolhaCampo::ListAll( void )
{
    ULOG_START("CContatoFolhaCampo::ListAll()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidContatoFolhaCampo[21+1];
			VARCHAR stidContato[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stidTipoLinha[21+1];
			VARCHAR stidCampo[21+1];
			VARCHAR stsqOrdemApresentacao[21+1];
			VARCHAR stidFaseProcesso[21+1];
		} stContatoFolhaCampoRegistro;
		struct
		{
			short iidContatoFolhaCampo;
			short iidContato;
			short iidUFOperadora;
			short iidTipoLinha;
			short iidCampo;
			short isqOrdemApresentacao;
			short iidFaseProcesso;
		} stContatoFolhaCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoFolhaCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL DECLARE CursorContatoFolhaCampoAll CURSOR FOR
   		SELECT 	idContatoFolhaCampo,
		idContato,
		idUFOperadora,
		idTipoLinha,
		idCampo,
		sqOrdemApresentacao,
		idFaseProcesso
		FROM contatoadm.ContatoFolhaCampo;

		//Abre o cursor
		EXEC SQL OPEN CursorContatoFolhaCampoAll;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CContatoFolhaCampo::ListAll()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stContatoFolhaCampoRegistro, 0, sizeof(stContatoFolhaCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorContatoFolhaCampoAll INTO :stContatoFolhaCampoRegistro:stContatoFolhaCampoIndicator;
				//Adiciona a classe
				Add( 	(char*)stContatoFolhaCampoRegistro.stidContatoFolhaCampo.arr,
				(char*)stContatoFolhaCampoRegistro.stidContato.arr,
				(char*)stContatoFolhaCampoRegistro.stidUFOperadora.arr,
				(char*)stContatoFolhaCampoRegistro.stidTipoLinha.arr,
				(char*)stContatoFolhaCampoRegistro.stidCampo.arr,
				(char*)stContatoFolhaCampoRegistro.stsqOrdemApresentacao.arr,
				(char*)stContatoFolhaCampoRegistro.stidFaseProcesso.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorContatoFolhaCampoAll;
		}
		ULOG_END("CContatoFolhaCampo::ListAll()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CContatoFolhaCampo::GetXml( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			xml->createTag(cNomeTag);
			//Adiciona a proprieda necessaria para o Weblogic
			xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{
				//Adiciona as tags necessarias
				xml->addItem("idContatoFolhaCampo", Registro(x)->cidContatoFolhaCampo );
				xml->addItem("idContato", Registro(x)->cidContato );
				xml->addItem("idUFOperadora", Registro(x)->cidUFOperadora );
				xml->addItem("idTipoLinha", Registro(x)->cidTipoLinha );
				xml->addItem("idCampo", Registro(x)->cidCampo );
				xml->addItem("sqOrdemApresentacao", Registro(x)->csqOrdemApresentacao );
				xml->addItem("idFaseProcesso", Registro(x)->cidFaseProcesso );
			}
			//So fecha um tag se abriu anteriormente
			xml->closeTag();
		}
	}
}

int CContatoFolhaCampo::Find( char* cidContato
							 ,char* cidUFOperadora
							 ,char* cidTipoLinha
							 ,char* cidCampo
							 ,char* cidFaseProcesso )
{
	int iRet = 0;
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			if( ( strcmp( cidContato, Registro(x)->cidContato ) == 0 ) &&
				( strcmp( cidUFOperadora, Registro(x)->cidUFOperadora ) == 0 ) &&
				( strcmp( cidTipoLinha, Registro(x)->cidTipoLinha ) == 0 ) &&
				( strcmp( cidCampo, Registro(x)->cidCampo ) == 0 ) &&
				( strcmp( cidFaseProcesso, Registro(x)->cidFaseProcesso ) == 0 ) )
			{
				iRet = 1;
				break;
			}
		}
	}
	return iRet;
}

void CContatoFolhaCampo::AddExistente( char* cidContato
									 ,char* cidUFOperadora
									 ,char* cidTipoLinha
									 ,char* cidCampo
									 ,char* cidFaseProcesso )
{
		Add( "",
			 cidContato,
			 cidUFOperadora,
			 cidTipoLinha,
			 cidCampo,
			 "",
			 cidFaseProcesso
		);
}

void CContatoFolhaCampo::Copy( char* cidContatoOrigem
		                      ,char* cidContatoDestino
		                      ,char* cidUser )
{
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidContatoOrigemAux = cidContatoOrigem;
		char* cidContatoDestinoAux = cidContatoDestino;
		char* cidUserAux = cidUser;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoCopy;

	//Realiza o insert de todos os campos de um certo contato
	EXEC SQL
	INSERT INTO
		CONTATOADM.CONTATOFOLHACAMPO
	VALUE
	(
		IDCONTATOFOLHACAMPO,
		IDUFOPERADORA,
		IDTIPOLINHA,
		IDFASEPROCESSO,
		IDCAMPO,
		SQORDEMAPRESENTACAO,
		IDCONTATO,
		IDUSUARIOALTERACAO,
		DTULTIMAALTERACAO
	)
	SELECT
		CONTATOADM.CONTATOFOLHACAMPOSQ.NEXTVAL,
		IDUFOPERADORA,
		IDTIPOLINHA,
		IDFASEPROCESSO,
		IDCAMPO,
		SQORDEMAPRESENTACAO,
		:cidContatoDestinoAux,
		:cidUserAux,
		SYSDATE
	FROM
		CONTATOADM.CONTATOFOLHACAMPO
	WHERE
		IDCONTATO = :cidContatoOrigemAux;

	return;

GotoCopy:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}



int CContatoFolhaCampo::Selecao(  XMLGen * xml_g  )
{
    ULOG_START( "CContatoFolhaCampo::Selecao" );
	int    iCont = 0;
	struct sqlca sqlca;

	string consulta;
	char buffer[128];

	EXEC SQL BEGIN DECLARE SECTION;

		char* query;

		unsigned long idContatoFolhaCampo;
		unsigned long idCampo;
		unsigned long idClassificador;
		unsigned long idSubFormulario;

		VARCHAR nmClassificador[256];
		short   i_nmClassificador = -1;

		VARCHAR nmCampo[256];
		short   i_nmCampo = -1;

		VARCHAR nmGrupo[256];
		short   i_nmGrupo = -1;

		short i_idSubFormulario = -1;

	EXEC SQL END DECLARE SECTION;

	try
	{
		CarregaGrupos() ;

		consulta =
			"SELECT DISTINCT "
			"	CONTATOFOLHACAMPO.IDCAMPO,"
			"	CAMPO.IDCLASSIFICADORCAMPO,"
			"   CAMPO.NMCAMPO,"
			"	CONTATOFOLHACAMPO.IDSUBFORMULARIO "
			"FROM "
			"	CONTATOADM.CAMPO CAMPO,"
			"	CONTATOADM.CONTATOFOLHACAMPO CONTATOFOLHACAMPO "
			"WHERE "
			" CONTATOFOLHACAMPO.IDCAMPO = CAMPO.IDCAMPO ";

		consulta +=
			" AND CONTATOFOLHACAMPO.IDFASEPROCESSO = ";

		sprintf(buffer,"%lu",idFaseProcessoPrm);
		consulta += buffer;

        consulta +=
			" AND CONTATOFOLHACAMPO.IDCONTATO = ";
		sprintf(buffer,"%lu",idContatoPrm);
		consulta += buffer;

/*
        consulta +=	" AND CONTATOFOLHACAMPO.IDUFOPERADORA IN (";
		pUF->sort();
		pUF->unique();
		bool flag = false;
		for (it = pUF->begin(); it != pUF->end(); it++)
		{
			if ( flag ) consulta += ",";
			sprintf(buffer,"%lu",*it);
			consulta += buffer;
			flag = true;
		}

		consulta += ")";

		consulta +=
			" AND CONTATOFOLHACAMPO.IDTIPOLINHA IN (";

		flag = false;
		pTpLinha->sort();
		pTpLinha->unique();
		for (it = pTpLinha->begin(); it != pTpLinha->end(); it++)
		{
			if ( flag ) consulta += ",";
			sprintf(buffer,"%lu",*it);
			consulta += buffer;
			flag = true;
		}
		consulta += ") ORDER BY CAMPO.NMCAMPO";
*/
		consulta += " ORDER BY CAMPO.NMCAMPO";

	    query = (char *)consulta.c_str();
	    ULOG( "Query [%s]",query );

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoSelecao;

		EXEC SQL PREPARE Campos FROM :query;
		EXEC SQL DECLARE CursorSelecao CURSOR FOR Campos;

		EXEC SQL OPEN CursorSelecao;

		if(sqlca.sqlcode)
		{
		    ULOG_END( "CContatoFolhaCampo::Selecao" );
			return 0;//Erro
		}
		else
		{
			EXEC SQL WHENEVER NOT FOUND DO break;

			bool grupo = false;
			for(;;)
			{
				i_idSubFormulario = -1;

				EXEC SQL FETCH CursorSelecao INTO :idCampo ,
					                              :idClassificador ,
					                              :nmCampo:i_nmCampo ,
					                              :idSubFormulario:i_idSubFormulario ;

			    CONVIND( nmCampo,i_nmCampo );

			    consulta = (char*)nmCampo.arr;
			    trim2(consulta);
				strToOra(nmCampo,(char*)consulta.c_str());

                ULOG( "idCampo             [%lu]",idCampo );
                ULOG( "nmCampo [%s]",(char*)nmCampo.arr );
                if ( i_idSubFormulario != -1 )
                   ULOG( "idSubFormulario [%lu]",idSubFormulario );

			    for (itGrupoLoad = LGrupos.begin(); itGrupoLoad != LGrupos.end(); itGrupoLoad++)
            	{
            		if ( idSubFormulario == *itGrupoLoad )
            		{

	            		ULOG("Vai mostrar grupo");
						ULOG( "Buscando classificador..." );

						EXEC SQL
						SELECT
						   DSTIPOGRUPOCAMPO
						INTO
						   :nmClassificador:i_nmClassificador
						FROM
						   APOIO.TIPOSUBFORMULARIO
						WHERE
						   IDTIPOSUBFORMULARIO
						IN
						(
			                SELECT
			                	IDTIPOSUBFORMULARIO
			                FROM
			                   CONTATOADM.SUBFORMULARIO
			                WHERE
			                   IDSUBFORMULARIO = :idSubFormulario
						) ;

					    CONVIND( nmClassificador,i_nmClassificador );
						ULOG( "nmClassificador [%s]",(char*)nmClassificador.arr );

		                EXEC SQL
		                SELECT
		                	NMSUBFORMULARIO
		                INTO
		                   :nmGrupo:i_nmGrupo
		                FROM
		                   CONTATOADM.SUBFORMULARIO
		                WHERE
		                   IDSUBFORMULARIO = :idSubFormulario;

					    CONVIND( nmGrupo,i_nmGrupo );

						ULOG( "Mostrando grupo [%s]",(char*)nmGrupo.arr );

						xml_g->createTag( "CampoObjetoFormularioVO" );
						xml_g->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
							xml_g->addItem("idCampoObjeto", idSubFormulario );
							xml_g->addItem("nmCampoObjeto", (char *)nmGrupo.arr );
							xml_g->addItem("nmClassificadorComponente", (char *)nmClassificador.arr );
							xml_g->addItem("inClassificadorComponente", "Componente" );
							xml_g->addItem("idClassificadorComponente", idClassificador );
						xml_g->closeTag();

            			LGrupos.erase(itGrupoLoad);
            			break;

            		}

            	}
            	if ( i_idSubFormulario == -1 )
            	{
            		ULOG("Vai mostrar campo...");
/*
	                if ( LGrupos.empty() )
	                {
*/		                EXEC SQL
		                SELECT
		                   NMCLASSIFICADORCAMPO
		                INTO
		                   :nmClassificador:i_nmClassificador
		                FROM
		                   CONTATOADM.CAMPOCLASSIFICADOR
		                WHERE
		                   IDCLASSIFICADORCAMPO = :idClassificador;

					    CONVIND( nmClassificador,i_nmClassificador );

						xml_g->createTag( "CampoObjetoFormularioVO" );
						xml_g->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
							xml_g->addItem("idCampoObjeto", idCampo );
							xml_g->addItem("nmCampoObjeto", (char *)nmCampo.arr );
							xml_g->addItem("nmClassificadorComponente", (char *)nmClassificador.arr );
							xml_g->addItem("inClassificadorComponente", "Campo" );
							xml_g->addItem("idClassificadorComponente", idClassificador );
						xml_g->closeTag();
	/*
					}
    */
                }
			}
			EXEC SQL CLOSE CursorSelecao;

			xml_g->closeTag();
		}
		ULOG_END( "CContatoFolhaCampo::Selecao" );

		return 0;
	}
	catch(...)
	{
		throw;
	}

GotoSelecao:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	ULOG_END( "CContatoFolhaCampo::Selecao" );
	throw TuxBasicOraException(sqlca.sqlcode);

}




void CContatoFolhaCampo::trim2(string& str)
{
  string::size_type pos = str.find_last_not_of(' ');
  if(pos != string::npos) {
    str.erase(pos + 1);
    pos = str.find_first_not_of(' ');
    if(pos != string::npos) str.erase(0, pos);
  }
  else str.erase(str.begin(), str.end());
}




int CContatoFolhaCampo::CarregaGrupos( void )
{
    ULOG_START( "CContatoFolhaCampo::CarregaGrupos" );
	struct sqlca sqlca;

	string consulta;
	char buffer[128];

	EXEC SQL BEGIN DECLARE SECTION;

		char* query;

		unsigned long idGrupo;
		short i_idGrupo = -1;

	EXEC SQL END DECLARE SECTION;

	try
	{

		consulta =
			"SELECT DISTINCT "
			"	CONTATOFOLHACAMPO.IDSUBFORMULARIO "
			"FROM "
			"	CONTATOADM.CONTATOFOLHACAMPO CONTATOFOLHACAMPO "
			"WHERE "
			"  CONTATOFOLHACAMPO.IDFASEPROCESSO = ";
		sprintf(buffer,"%lu",idFaseProcessoPrm);
		consulta += buffer;

        consulta +=
			" AND CONTATOFOLHACAMPO.IDCONTATO = ";
		sprintf(buffer,"%lu",idContatoPrm);
		consulta += buffer;

/*
        consulta +=	" AND CONTATOFOLHACAMPO.IDUFOPERADORA IN (";
		pUF->sort();
		pUF->unique();
		bool flag = false;
		for (it = pUF->begin(); it != pUF->end(); it++)
		{
			if ( flag ) consulta += ",";
			sprintf(buffer,"%lu",*it);
			consulta += buffer;
			flag = true;
		}
		consulta += ")";

		consulta +=
			" AND CONTATOFOLHACAMPO.IDTIPOLINHA IN (";

		flag = false;
		pTpLinha->sort();
		pTpLinha->unique();
		for (it = pTpLinha->begin(); it != pTpLinha->end(); it++)
		{
			if ( flag ) consulta += ",";
			sprintf(buffer,"%lu",*it);
			consulta += buffer;
			flag = true;
		}
		consulta += ")";
*/

	    query = (char *)consulta.c_str();
	    ULOG( "Query [%s]",query );

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoCarregaGrupos;

		EXEC SQL PREPARE CarregaGrupos FROM :query;
		EXEC SQL DECLARE CursorCarregaGrupos CURSOR FOR CarregaGrupos;

		EXEC SQL OPEN CursorCarregaGrupos;

		EXEC SQL WHENEVER NOT FOUND DO break;

		LGrupos.clear();
		for(;;)
		{

			EXEC SQL FETCH CursorCarregaGrupos INTO :idGrupo:i_idGrupo ;
			if ( i_idGrupo != -1 )
				LGrupos.push_back(idGrupo);

		}
		EXEC SQL CLOSE CursorCarregaGrupos;
		LGrupos.sort();
		LGrupos.unique();

		ULOG_END( "CContatoFolhaCampo::CarregaGrupos" );

		return 0;
	}
	catch(...)
	{
		throw;
	}

GotoCarregaGrupos:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	ULOG_END( "CContatoFolhaCampo::CarregaGrupos" );
	throw TuxBasicOraException(sqlca.sqlcode);

}
