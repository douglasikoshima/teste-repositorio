#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CAtv.h"

CAtribuicao::CAtribuicao()
{
}

CAtribuicao::~CAtribuicao()
{
}

int CAtribuicao::Insert(
			char* cnmAtribuicao,
			char* cidUsuarioAlteracao )
{
    ULOG_START("CAtribuicao::Insert()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cAuxidAtribuicao[255+1];
		int iContador;
		char* cAuxnmAtribuicao = cnmAtribuicao;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraAtribuicao();

		memset( &cAuxidAtribuicao, 0, sizeof(cAuxidAtribuicao) );

		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;

		//Verifica se a descricao do registro ja existe
		//Retorna codigo de erro se confirmado
		EXEC SQL SELECT COUNT(nmAtribuicao)
		INTO: iContador
		FROM organograma.Atribuicao
		WHERE TRIM(UPPER(nmAtribuicao)) = TRIM(UPPER(:cAuxnmAtribuicao));

		if (iContador>0)
			return -1;//Nome duplicado

		//Pega um id unico e sequencia para a insercao
		EXEC SQL SELECT organograma.AtribuicaoSQ.NEXTVAL INTO :cAuxidAtribuicao FROM DUAL;

		//Realiza o insert
		EXEC SQL INSERT INTO organograma.Atribuicao
		(	idAtribuicao,
			nmAtribuicao,
			idUsuarioAlteracao,
			dtUltimaAlteracao)
		VALUES
		(	:cAuxidAtribuicao,
			TRIM(:cAuxnmAtribuicao),
			:cAuxidUsuarioAlteracao,
			SYSDATE);

		ULOG_END("CAtribuicao::Insert()");

		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
			return sqlca.sqlerrd[2];//Quantidade de linhas afetadas
	}
	catch(...)
	{
		throw;
	}

GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if(sqlca.sqlcode < 0)
		return sqlca.sqlcode;
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CAtribuicao::RelacaoCA( char* cid, char* cNomeIdTag, char* cNomeTag, char* cNomeTagAssociadasExterna, char* cNomeTagAssociadas, char* cNomeTagExistentesExterna, char* cNomeTagExistentes, XMLGen*xml )
{
    ULOG_START("CAtribuicao::RelacaoCA()");
	//Reader
	xml->createTag( cNomeTag );
	xml->addProp( "xmlns", "usuario.fo.vivo.com.br/vo" );

	//Consistencia
	if( strlennull( cid ) <= 0 )
		return 0; //Retorno com erro

	//Registros
	xml->addItem( cNomeIdTag, cid );

	//Outros itens

	//Associados
	RelacaoCA( cid );
	GetXml( cNomeTagAssociadasExterna, cNomeTagAssociadas, xml );

	//Existentes
	ExistemCA( cid );
	GetXml( cNomeTagExistentesExterna, cNomeTagExistentes, xml );

	//Reader
	xml->closeTag();

    ULOG_END("CAtribuicao::RelacaoCA()");

	//Retorno com sucesso
	return 1;
}
int CAtribuicao::RelacaoCA( char* cidCargo )
{
    ULOG_START("CAtribuicao::RelacaoCA()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidCargo = cidCargo;
		struct
		{
			VARCHAR stidAtribuicao[21+1];
			VARCHAR stnmAtribuicao[255+1];
		} stAtribuicaoRegistro;
		struct
		{
			short iidAtribuicao;
			short inmAtribuicao;
		} stAtribuicaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		ZeraAtribuicao();

		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;

		//Declara um cursor para listar os Registros
/*
		EXEC SQL DECLARE CursorAtribuicaoRelacao_00 CURSOR FOR
   		SELECT organograma.AtribuicaoB0.idAtribuicao, organograma.AtribuicaoB0.nmAtribuicao
		FROM organograma.AtribuicaoB0, organograma.CargoAtribuicaoBZEROUM
		WHERE organograma.AtribuicaoB0.idAtribuicao = organograma.CargoAtribuicaoBZEROUM.idAtribuicao
		AND
			organograma.CargoAtribuicaoBZEROUM.idCargo = :cAuxidCargo
		ORDER BY organograma.AtribuicaoB0.nmAtribuicao;
*/

		EXEC SQL DECLARE CursorAtribuicaoRelacao_00 CURSOR FOR
		SELECT
		   ATRIBUICAO.IDATRIBUICAO,
		   ATRIBUICAO.NMATRIBUICAO
		FROM
		   ORGANOGRAMA.CARGOATRIBUICAO CARGOATRIBUICAO,
		   ORGANOGRAMA.ATRIBUICAO ATRIBUICAO
		WHERE
		   CARGOATRIBUICAO.IDATRIBUICAO = ATRIBUICAO.IDATRIBUICAO
		AND
		   CARGOATRIBUICAO.IDCARGO = :cAuxidCargo
		ORDER BY
		   ATRIBUICAO.NMATRIBUICAO ;

		EXEC SQL WHENEVER SQLERROR GOTO GotoRelacao;

		EXEC SQL OPEN CursorAtribuicaoRelacao_00;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stAtribuicaoRegistro, 0, sizeof(stAtribuicaoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorAtribuicaoRelacao_00 INTO :stAtribuicaoRegistro:stAtribuicaoIndicator;
				//Adiciona a classe
				Add( 	(char*)stAtribuicaoRegistro.stidAtribuicao.arr,
				(char*)stAtribuicaoRegistro.stnmAtribuicao.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorAtribuicaoRelacao_00;
		}

		ULOG_END("CAtribuicao::RelacaoCA()");

		//Retorna sucesso

		return 1;
	}
	catch(...)
	{
		throw;
	}

GotoRelacao:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CAtribuicao::ExistemCA( char* cidCargo )
{
    ULOG_START("CAtribuicao::ExistemCA()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidCargo = cidCargo;
		struct
		{
			VARCHAR stidAtribuicao[21+1];
			VARCHAR stnmAtribuicao[255+1];
		} stAtribuicaoRegistro;
		struct
		{
			short iidAtribuicao;
			short inmAtribuicao;
		} stAtribuicaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		ZeraAtribuicao();

		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;

		//Declara um cursor para listar os Registros
/*
   		EXEC SQL DECLARE CursorAtribuicaoExistem_00 CURSOR FOR
   		SELECT organograma.AtribuicaoB0.idAtribuicao, organograma.AtribuicaoB0.nmAtribuicao
		FROM organograma.AtribuicaoB0
		WHERE organograma.AtribuicaoB0.idAtribuicao
		NOT IN ( SELECT organograma.AtribuicaoB0.idAtribuicao
			 FROM organograma.AtribuicaoB0, organograma.CargoAtribuicaoBZEROUM
			 WHERE organograma.AtribuicaoB0.idAtribuicao = organograma.CargoAtribuicaoBZEROUM.idAtribuicao
			 AND organograma.CargoAtribuicaoBZEROUM.idCargo = :cAuxidCargo  )
		ORDER BY organograma.AtribuicaoB0.nmAtribuicao;
*/

		//Declara um cursor para listar os Registros
   		EXEC SQL DECLARE CursorAtribuicaoExistem_00 CURSOR FOR
		SELECT
		   ORGATRIBUICAO.IDATRIBUICAO,
		   ORGATRIBUICAO.NMATRIBUICAO
		FROM
		   ORGANOGRAMA.ATRIBUICAO ORGATRIBUICAO
		WHERE
		   ORGATRIBUICAO.IDATRIBUICAO
		NOT IN
		(
			SELECT
			   ATRIBUICAO.IDATRIBUICAO
			FROM
			   ORGANOGRAMA.CARGOATRIBUICAO CARGOATRIBUICAO,
			   ORGANOGRAMA.ATRIBUICAO ATRIBUICAO
			WHERE
			   CARGOATRIBUICAO.IDATRIBUICAO = ATRIBUICAO.IDATRIBUICAO
			AND
			   CARGOATRIBUICAO.IDCARGO = :cAuxidCargo
		)
		ORDER BY ORGATRIBUICAO.NMATRIBUICAO;

		EXEC SQL WHENEVER SQLERROR GOTO GotoExistem;

		EXEC SQL OPEN CursorAtribuicaoExistem_00;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CAtribuicao::ExistemCA()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stAtribuicaoRegistro, 0, sizeof(stAtribuicaoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorAtribuicaoExistem_00 INTO :stAtribuicaoRegistro:stAtribuicaoIndicator;
				//Adiciona a classe
				Add( 	(char*)stAtribuicaoRegistro.stidAtribuicao.arr,
				(char*)stAtribuicaoRegistro.stnmAtribuicao.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorAtribuicaoExistem_00;
		}

		ULOG_END("CAtribuicao::ExistemCA()");

		//Retorna sucesso
		return 1;
	}
	catch(...)
	{
		throw;
	}

GotoExistem:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CAtribuicao::Update(
			char* cidAtribuicao,
			char* cnmAtribuicao,
			char* cidUsuarioAlteracao )
{
    ULOG_START("CAtribuicao::Update()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;

			int iContador;
			char* cAuxidAtribuicao = cidAtribuicao;
			char* cAuxnmAtribuicao = cnmAtribuicao;
			char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraAtribuicao();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;

		//Verifica se a descricao do registro ja existe
		//Retorna codigo de erro se confirmado
		EXEC SQL SELECT COUNT(nmAtribuicao)
		INTO: iContador
		FROM organograma.Atribuicao
		WHERE TRIM(UPPER(nmAtribuicao)) = TRIM(UPPER(:cAuxnmAtribuicao))
		AND idAtribuicao != :cAuxidAtribuicao;

		if (iContador>0)
		{
		    ULOG_END("CAtribuicao::Update()");
			return -1;//Nome duplicado
		}

		//Executa a instrucao de update
		EXEC SQL
		UPDATE organograma.Atribuicao
		SET 	nmAtribuicao = :cAuxnmAtribuicao,
		idUsuarioAlteracao = :cAuxidUsuarioAlteracao,
		dtUltimaAlteracao = SYSDATE
		WHERE 	idAtribuicao = :cAuxidAtribuicao;

		ULOG_END("CAtribuicao::Update()");

		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
			return 1;//Sucesso
	}
	catch(...)
	{
		throw;
	}

GotoUpdate:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if(sqlca.sqlcode < 0)
		return sqlca.sqlcode;
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CAtribuicao::Delete( char* cidAtribuicao )
{
    ULOG_START("CAtribuicao::Delete()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidAtribuicao = cidAtribuicao;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraAtribuicao();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
		sqlca.sqlcode=0;

		//Executa a instrucao de delecao
		EXEC SQL DELETE FROM organograma.Atribuicao
		WHERE (idAtribuicao = :cAuxidAtribuicao);

		ULOG_END("CAtribuicao::Delete()");

		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
			return 1;//Sucesso
	}
	catch(...)
	{
		throw;
	}

GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if(sqlca.sqlcode == -2292)
		return sqlca.sqlcode;
	else
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CAtribuicao::List( char* cidAtribuicao,
			           char* cnmAtribuicao,
			           char* cidUsuarioAlteracao )
{
    ULOG_START("CAtribuicao::List()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char cAuxidAtribuicao[21+1];
		char cAuxnmAtribuicao[255+1];
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
		struct
		{
			VARCHAR stidAtribuicao[21+1];
			VARCHAR stnmAtribuicao[255+1];
		} stAtribuicaoRegistro;
		struct
		{
			short iidAtribuicao;
			short inmAtribuicao;
		} stAtribuicaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Zera a estrutura da classe
	ZeraAtribuicao();
	memset( cAuxidAtribuicao, 0, sizeof(cAuxidAtribuicao) );
	memset( cAuxnmAtribuicao, 0, sizeof(cAuxnmAtribuicao) );

	if ( strlen( cidAtribuicao ) == 0 )
		strcpy(cAuxidAtribuicao , "-1" );
	else
		strcpy(cAuxidAtribuicao , cidAtribuicao );

	if ( strlen( cnmAtribuicao ) == 0 )
		strcpy(cAuxnmAtribuicao , "-1" );
	else
		sprintf(cAuxnmAtribuicao,"%.*s%%",255,cnmAtribuicao);



	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
	sqlca.sqlcode=0;

	//Declara um cursor para listar os Registros
	EXEC SQL
	DECLARE
		CursorAtribuicao CURSOR FOR
	SELECT
		idAtribuicao,
		nmAtribuicao
	FROM
		organograma.Atribuicao
	WHERE
	(
		IDATRIBUICAO = :cAuxidAtribuicao OR '-1' = :cAuxidAtribuicao
	)
	AND
	(
		UPPER(NMATRIBUICAO) LIKE UPPER(:cAuxnmAtribuicao) OR '-1' = :cAuxnmAtribuicao
	)
	ORDER BY UPPER(NMATRIBUICAO);

	// Abre o cursor
	EXEC SQL OPEN CursorAtribuicao;

	//Caso inexista registros sair do loop
	EXEC SQL WHENEVER NOT FOUND DO break;
	for(;;)
	{
		//Zera a estrutura de restorno
		memset( &stAtribuicaoRegistro, 0, sizeof(stAtribuicaoRegistro) );
		//Pega um registro no CURSOR
		EXEC SQL FETCH CursorAtribuicao INTO :stAtribuicaoRegistro:stAtribuicaoIndicator;
		//Adiciona a classe
		Add( (char*)stAtribuicaoRegistro.stidAtribuicao.arr,
		     (char*)stAtribuicaoRegistro.stnmAtribuicao.arr );
		//conta quantos existem
		iCont++;
	}
	//Fecha o CURSOR
	EXEC SQL CLOSE CursorAtribuicao;

	ULOG_END("CAtribuicao::List()");

	//Retorna a quantidade de registros
	return iCont;

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CAtribuicao::ListId( char* cidAtribuicao )
{
    ULOG_START("CAtribuicao::ListId()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidAtribuicao = cidAtribuicao;
		struct
		{
			VARCHAR stidAtribuicao[21+1];
			VARCHAR stnmAtribuicao[255+1];
		} stAtribuicaoRegistro;
		struct
		{
			short iidAtribuicao;
			short inmAtribuicao;
		} stAtribuicaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraAtribuicao();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL DECLARE CursorAtribuicaoId CURSOR FOR
   		SELECT 	idAtribuicao, nmAtribuicao
		FROM organograma.Atribuicao
		WHERE idAtribuicao = :cAuxidAtribuicao;

		//Abre o cursor
		EXEC SQL OPEN CursorAtribuicaoId;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CAtribuicao::ListId()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stAtribuicaoRegistro, 0, sizeof(stAtribuicaoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorAtribuicaoId INTO :stAtribuicaoRegistro:stAtribuicaoIndicator;
				//Adiciona a classe
				Add( 	(char*)stAtribuicaoRegistro.stidAtribuicao.arr,
				(char*)stAtribuicaoRegistro.stnmAtribuicao.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorAtribuicaoId;
		}
		ULOG_END("CAtribuicao::ListId()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CAtribuicao::ListAll( void )
{
    ULOG_START("CAtribuicao::ListAll()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidAtribuicao[21+1];
			VARCHAR stnmAtribuicao[255+1];
		} stAtribuicaoRegistro;
		struct
		{
			short iidAtribuicao;
			short inmAtribuicao;
		} stAtribuicaoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraAtribuicao();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL DECLARE CursorAtribuicaoAll CURSOR FOR
   		SELECT 	idAtribuicao,
		nmAtribuicao
		FROM organograma.Atribuicao;

		//Abre o cursor
		EXEC SQL OPEN CursorAtribuicaoAll;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CAtribuicao::ListAll()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stAtribuicaoRegistro, 0, sizeof(stAtribuicaoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorAtribuicaoAll INTO :stAtribuicaoRegistro:stAtribuicaoIndicator;
				//Adiciona a classe
				Add( 	(char*)stAtribuicaoRegistro.stidAtribuicao.arr,
				(char*)stAtribuicaoRegistro.stnmAtribuicao.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorAtribuicaoAll;
		}

		ULOG_END("CAtribuicao::ListAll()");

		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CAtribuicao::GetXml( char* cNomeTag, XMLGen*xml )
{

	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
				xml->createTag(cNomeTag);
			//Adiciona a propriedade necessaria para o xml
			xml->addProp( "xmlns", "usuario.fo.vivo.com.br/vo" );
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{
				//Adiciona as tags necessarias
				xml->addItem("idAtividade", Registro(x)->cidAtribuicao );
				xml->addItem("nmAtividade", Registro(x)->cnmAtribuicao );
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}

}

void CAtribuicao::GetXml( char* cNomeTagArray, char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() >= 0 )
	{
		//Caso nao tenha recebido uma tag padrao, deixa sem
		if( strlennull( cNomeTagArray ) > 0 ) {
			xml->createTag(cNomeTagArray);
			//Adiciona a propriedade necessaria para o xml
			xml->addProp( "xmlns", "usuario.fo.vivo.com.br/vo" );
		}
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 ) {
				xml->createTag(cNomeTag);
				//Adiciona a propriedade necessaria para o xml
				xml->addProp( "xmlns", "usuario.fo.vivo.com.br/vo" );
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{
				//Adiciona as tags necessarias
				xml->addItem("idAtividade", Registro(x)->cidAtribuicao );
				xml->addItem("nmAtividade", Registro(x)->cnmAtribuicao );
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
		//So fecha um tag se abriu anteriormente
		if( strlennull( cNomeTagArray ) > 0 )
			xml->closeTag();
	}
}
