/* charls */
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CFlh.h"

CContatoFolha::CContatoFolha()
{
}

CContatoFolha::~CContatoFolha()
{
}

int CContatoFolha::Insert( 
					          char* cidContato
					         ,char* cidPagina
					         ,char* cidTipoRetorno
					         ,char* cidTipoFechamento
					         ,char* cidTipoProcesso
					         ,char* cqtHorasPrazo
					         ,char* cinFechamentoImediato
					         ,char* cvlPeso
					         ,char* cinProcessoTecnico
			                 ,char* cidUsuarioAlteracao
                             ,char* cqtHorasPrazoAnatel
                             ,char* cInSmsPrm
                             ,char* cDsSmsPrm
                             ,char* cInRelacionamentoPrm
                             ,char* cInProtocoloPrm
                             ,char* cInexibeProtocoloPrm
                             ,char* cDsContatoCanaisPrm
                             ,char* cDsMsgExcecaoPrm
							 ,char* cInCancelamentoPrm
							 ,char* cIdClassificacaoSmsPrm
                             ,char* cInAberturaContato
                             ,char* cSgRegraEncaminhamentoPrm
                             ,char* cSgFluxoAtendimentoPrm
			             )
{
    ULOG_START("CContatoFolha::Insert()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* paramOraIdContato = cidContato;
		char* paramOraIdPagina = cidPagina;
		char* paramOraIdTipoRetorno = cidTipoRetorno;
		char* paramOraIdTipoFechamento = cidTipoFechamento;
		char* paramOraIdTipoProcesso = cidTipoProcesso;
		char* paramOraQtHorasPrazo = cqtHorasPrazo;
		char* paramOraInFechamentoImediato = cinFechamentoImediato;
		char* paramOraVlPeso = cvlPeso;
		char* paramOraInProcessoTecnico = cinProcessoTecnico;
		char* paramOraIdUsuarioAlteracao = cidUsuarioAlteracao;
		char* paramOraQtHorasPrazoAnatel = cqtHorasPrazoAnatel;
		char* paramOraCInSms = cInSmsPrm;
		char* paramOraCDsSms = cDsSmsPrm;
		char* paramOraCInRelacionamento = cInRelacionamentoPrm;
		char* paramOraCInProtocolo = cInProtocoloPrm;
        char* paramOraCInexibeProtocoloPrm = cInexibeProtocoloPrm==0?"0":*cInexibeProtocoloPrm==0?"0":cInexibeProtocoloPrm;
		char* paramOraCDsContatoCanais = cDsContatoCanaisPrm;
		char* paramOraCDsMsgExcecao = cDsMsgExcecaoPrm;
    	char* paramOraCInCancelamento = cInCancelamentoPrm;
    	char* paramOraCIdClassificacaoSms = cIdClassificacaoSmsPrm;
        char* paramOraCInAberturaContato = cInAberturaContato;
        char* paramOraCSgRegraEncaminhamento = cSgRegraEncaminhamentoPrm;
        char* paramOraCSgFluxoAtendimento = cSgFluxoAtendimentoPrm;

        short statOraSgRegraEncaminhamento = -1;
        short statOraSgFluxoAtendimento = -1;

	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoFolha();
				
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
		
        if ( paramOraCSgRegraEncaminhamento )
        {
            if ( strcmp(paramOraCSgRegraEncaminhamento,"MC")==0 )
            {
                if ( paramOraCSgFluxoAtendimento==0 && *paramOraCSgFluxoAtendimento==0 )
                {
                    paramOraCSgFluxoAtendimento = "MC3";
                }

                statOraSgRegraEncaminhamento=1;
                statOraSgFluxoAtendimento=1;
            }
            else
            {// se a regra não for de MeuCliente então o fluxo não pode ser também.
                paramOraCSgFluxoAtendimento = 0;
                statOraSgFluxoAtendimento = -1;
            }
        }

        ULOG("==>             paramOraIdContato='%s'",paramOraIdContato?paramOraIdContato:"(null)");
		ULOG("==>              paramOraIdPagina='%s'",paramOraIdPagina?paramOraIdPagina:"(null)");
		ULOG("==>         paramOraIdTipoRetorno='%s'",paramOraIdTipoRetorno?paramOraIdTipoRetorno:"(null)");
		ULOG("==>      paramOraIdTipoFechamento='%s'",paramOraIdTipoFechamento?paramOraIdTipoFechamento:"(null)");
		ULOG("==>        paramOraIdTipoProcesso='%s'",paramOraIdTipoProcesso?paramOraIdTipoProcesso:"(null)");
		ULOG("==>          paramOraQtHorasPrazo='%s'",paramOraQtHorasPrazo?paramOraQtHorasPrazo:"(null)");
		ULOG("==>  paramOraInFechamentoImediato='%s'",paramOraInFechamentoImediato?paramOraInFechamentoImediato:"(null)");
		ULOG("==>                paramOraVlPeso='%s'",paramOraVlPeso?paramOraVlPeso:"(null)");
		ULOG("==>     paramOraInProcessoTecnico='%s'",paramOraInProcessoTecnico?paramOraInProcessoTecnico:"(null)");
		ULOG("==>    paramOraIdUsuarioAlteracao='%s'",paramOraIdUsuarioAlteracao?paramOraIdUsuarioAlteracao:"(null)");
		ULOG("==>    paramOraQtHorasPrazoAnatel='%s'",paramOraQtHorasPrazoAnatel?paramOraQtHorasPrazoAnatel:"(null)");
		ULOG("==>                paramOraCInSms='%s'",paramOraCInSms?paramOraCInSms:"(null)");
		ULOG("==>                paramOraCDsSms='%s'",paramOraCDsSms?paramOraCDsSms:"(null)");
		ULOG("==>     paramOraCInRelacionamento='%s'",paramOraCInRelacionamento?paramOraCInRelacionamento:"(null)");
		ULOG("==>          paramOraCInProtocolo='%s'",paramOraCInProtocolo?paramOraCInProtocolo:"(null)");
		ULOG("==>  paramOraCInexibeProtocoloPrm='%s'",paramOraCInexibeProtocoloPrm?paramOraCInexibeProtocoloPrm:"(null)");
		ULOG("==>      paramOraCDsContatoCanais='%s'",paramOraCDsContatoCanais?paramOraCDsContatoCanais:"(null)");
		ULOG("==>         paramOraCDsMsgExcecao='%s'",paramOraCDsMsgExcecao?paramOraCDsMsgExcecao:"(null)");
    	ULOG("==>       paramOraCInCancelamento='%s'",paramOraCInCancelamento?paramOraCInCancelamento:"(null)");
    	ULOG("==>   paramOraCIdClassificacaoSms='%s'",paramOraCIdClassificacaoSms?paramOraCIdClassificacaoSms:"(null)");
    	ULOG("==>    paramOraCInAberturaContato='%s'",paramOraCInAberturaContato?paramOraCInAberturaContato:"(null)");
    	ULOG("==>paramOraCSgRegraEncaminhamento='%s'",paramOraCSgRegraEncaminhamento?paramOraCSgRegraEncaminhamento:"(null)");
    	ULOG("==>   paramOraCSgFluxoAtendimento='%s'",paramOraCSgFluxoAtendimento?paramOraCSgFluxoAtendimento:"(null)");

		//Realiza o insert
		EXEC SQL 
			INSERT INTO 
				CONTATOADM.CONTATOFOLHA
			(
				 IDUNIDADE
				,IDCONTATO
				,QTHORASPRAZOCONTATO
				,INFECHAMENTOIMEDIATO
				,VLPESOCONTATO
				,IDTIPORETORNOCONTATO
				,INPROCESSOTECNICO
				,IDTIPOFECHAMENTOCONTATO
				,IDTIPOPROCESSO
				,IDUSUARIOALTERACAO
				,DTULTIMAALTERACAO
                ,QTHORASPRAZOANATEL
                ,INSMS
                ,DSSMS
                ,DTSTATUSSMS
                ,IDUSUARIOSTATUSSMS
                ,INRELACIONAMENTO
                ,INPROTOCOLO
                ,DSCONTATOCANAIS
                ,DSMSGEXCECAO
				,INCANCELAMENTO
				,IDCLASSIFICACAOSMS
                ,INEXIBEPROTOCOLO
                ,INABERTURACONTATO
                ,SGREGRAENCAMINHAMENTO
                ,SGFLUXOATENDIMENTO
			)
			VALUES
			(
				 :paramOraIdPagina
				,:paramOraIdContato
				,:paramOraQtHorasPrazo
				,:paramOraInFechamentoImediato
				,:paramOraVlPeso
				,:paramOraIdTipoRetorno
				,:paramOraInProcessoTecnico
				,:paramOraIdTipoFechamento
				,:paramOraIdTipoProcesso
				,:paramOraIdUsuarioAlteracao
				, SYSDATE
                ,:paramOraQtHorasPrazoAnatel
                ,:paramOraCInSms
                ,:paramOraCDsSms
                , SYSDATE
                ,:paramOraIdUsuarioAlteracao
                ,:paramOraCInRelacionamento
                ,:paramOraCInProtocolo
                ,:paramOraCDsContatoCanais
                ,:paramOraCDsMsgExcecao
				,:paramOraCInCancelamento
				,:paramOraCIdClassificacaoSms
                ,:paramOraCInexibeProtocoloPrm
                ,:paramOraCInAberturaContato
                ,:paramOraCSgRegraEncaminhamento:statOraSgRegraEncaminhamento
                ,:paramOraCSgFluxoAtendimento:statOraSgFluxoAtendimento
			);
			
        ULOG_END("CContatoFolha::Insert()");
		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode) {
			return 0;//Erro
		}
		else {
			return 1;//Sucesso
		}
	}
	catch(...)
	{
		throw;
	}
	
GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CContatoFolha::Update( 
					          char* cidContato
					         ,char* cidPagina
					         ,char* cidTipoRetorno
					         ,char* cidTipoFechamento
					         ,char* cidTipoProcesso
					         ,char* cqtHorasPrazo
					         ,char* cinFechamentoImediato
					         ,char* cvlPeso
					         ,char* cinProcessoTecnico
			                 ,char* cidUsuarioAlteracao
                             ,char* cqtHorasPrazoAnatel
                             ,char* cInSmsPrm
                             ,char* cDsSmsPrm
                             ,char* cInRelacionamentoPrm
                             ,char* cInProtocoloPrm
                             ,char* cDsContatoCanaisPrm
                             ,char* cDsMsgExcecaoPrm
							 ,char* cInCancelamentoPrm
    	                     ,char* cIdClassificacaoSmsPrm
                             ,char* cSgRegraEncaminhamentoPrm
                             ,char* cSgFluxoAtendimentoPrm
			             )
{
    ULOG_START("CContatoFolha::Update()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		char* cAuxidPagina = cidPagina;
		char* cAuxidTipoRetorno = cidTipoRetorno;
		char* cAuxidTipoFechamento = cidTipoFechamento;
		char* cAuxidTipoProcesso = cidTipoProcesso;
		char* cAuxqtHorasPrazo = cqtHorasPrazo;
		char* cAuxinFechamentoImediato = cinFechamentoImediato;
		char* cAuxvlPeso = cvlPeso;
		char* cAuxinProcessoTecnico = cinProcessoTecnico;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
        char* cAuxqtHorasPrazoAnatel = cqtHorasPrazoAnatel;
		char* cInSms = cInSmsPrm;
		char* cDsSms = cDsSmsPrm;
		char* cInRelacionamento = cInRelacionamentoPrm;
		char* cInProtocolo = cInProtocoloPrm;
		char* cDsContatoCanais = cDsContatoCanaisPrm;
		char* cDsMsgExcecao = cDsMsgExcecaoPrm;
		char* cInCancelamento = cInCancelamentoPrm;
    	char* cIdClassificacaoSms = cIdClassificacaoSmsPrm;
        char* cSgRegraEncaminhamento = cSgRegraEncaminhamentoPrm;
        char* cSgFluxoAtendimento = cSgFluxoAtendimentoPrm;
       
        short iSgRegraEncaminhamento = -1;
        short iSgFluxoAtendimento = -1;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoFolha();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
		
        if ( cSgRegraEncaminhamentoPrm )
        {
            if ( strcmp(cSgRegraEncaminhamentoPrm,"MC")==0 )
            {
                iSgRegraEncaminhamento=1;

                if ( cSgFluxoAtendimento==0 && *cSgFluxoAtendimento==0 )
                {
                    cSgFluxoAtendimento = "MC3";
                }

                if ( cSgFluxoAtendimento && *cSgFluxoAtendimento )
                    iSgFluxoAtendimento = 1;
            }
            else
            {// se a regra não for de MeuCliente então o fluxo não pode ser também.
                cSgFluxoAtendimento = 0;
                iSgFluxoAtendimento = -1;
            }
        }

        ULOG( "cAuxidContato            [%s]",cAuxidContato );
		ULOG( "cAuxidPagina             [%s]",cAuxidPagina );
		ULOG( "cAuxqtHorasPrazo         [%s]",cAuxqtHorasPrazo );
		ULOG( "cAuxinFechamentoImediato [%s]",cAuxinFechamentoImediato );
		ULOG( "cAuxvlPeso               [%s]",cAuxvlPeso );
		ULOG( "cInSms                   [%s]",cInSms );
		ULOG( "cDsSms                   [%s]",cDsSms );
		ULOG( "cAuxidUsuarioAlteracao   [%s]",cAuxidUsuarioAlteracao );
		ULOG( "cInRelacionamento        [%s]",cInRelacionamento );
		ULOG( "cInProtocolo             [%s]",cInProtocolo );
		ULOG( "cDsContatoCanais         [%s]",cDsContatoCanais );
		ULOG( "cDsMsgExcecao            [%s]",cDsMsgExcecao );
		ULOG( "cSgRegraEncaminhamento   [%s]",cSgRegraEncaminhamentoPrm );
		ULOG( "cSgFluxoAtendimento      [%s]",cSgFluxoAtendimento );

		//Executa a instrucao de update
		EXEC SQL 
			UPDATE 
				CONTATOADM.ContatoFolha
			SET
				 IDUNIDADE = :cAuxidPagina
				,QTHORASPRAZOCONTATO = :cAuxqtHorasPrazo
				,INFECHAMENTOIMEDIATO = :cAuxinFechamentoImediato
				,VLPESOCONTATO = :cAuxvlPeso
				,IDTIPORETORNOCONTATO = :cAuxidTipoRetorno
				,INPROCESSOTECNICO = :cAuxinProcessoTecnico
				,IDTIPOFECHAMENTOCONTATO = :cAuxidTipoFechamento
				,IDTIPOPROCESSO = :cAuxidTipoProcesso
				,IDUSUARIOALTERACAO = :cAuxidUsuarioAlteracao
				,DTULTIMAALTERACAO = SYSDATE
                ,QTHORASPRAZOANATEL = :cAuxqtHorasPrazoAnatel
                ,INSMS = :cInSms
                ,DSSMS = :cDsSms
                ,DTSTATUSSMS = SYSDATE
                ,IDUSUARIOSTATUSSMS = :cAuxidUsuarioAlteracao
                ,INRELACIONAMENTO = :cInRelacionamento
                ,INPROTOCOLO = :cInProtocolo
                ,DSCONTATOCANAIS = :cDsContatoCanais
                ,DSMSGEXCECAO = :cDsMsgExcecao
				,INCANCELAMENTO = :cInCancelamento
			    ,IDCLASSIFICACAOSMS = :cIdClassificacaoSms
                ,SGREGRAENCAMINHAMENTO = :cSgRegraEncaminhamento:iSgRegraEncaminhamento
                ,SGFLUXOATENDIMENTO = :cSgFluxoAtendimento:iSgFluxoAtendimento
			WHERE
                IDCONTATO = :cAuxidContato;   
		
		ULOG_END("CContatoFolha::Update()");
		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
			return sqlca.sqlerrd[2];//Quantidade de linhas afetadas
	}
	catch(...)
	{
		throw;
	}

GotoUpdate:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CContatoFolha::Delete( char* cidContato )
{
    ULOG_START("CContatoFolha::Delete()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;	
		char* cAuxidContato = cidContato; 
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoFolha();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
		sqlca.sqlcode=0;
		
		//Executa a instrucao de delecao
		EXEC SQL 
			DELETE FROM 
				CONTATOADM.CONTATOFOLHA
			WHERE 
				IDCONTATO = :cAuxidContato;
				
		ULOG_END("CContatoFolha::Delete()");
		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
			return 1;//Sucesso
	}
	catch(...)
	{
		throw;
	}

GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if(sqlca.sqlcode = -2292)
		return 2;//Contraint
	else
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CContatoFolha::ListId( char* cidContato ) 
{
    ULOG_START("CContatoFolha::ListId()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato; 
		struct
		{
			VARCHAR stidMensagem[21+1];
			VARCHAR stnmMensagem[255+1];
		} stMensagem;
		struct
		{
			short iidMensagem;
			short inmMensagem;
		} stMensagemInd;
		struct
		{
			VARCHAR stidContato[21+1];
			VARCHAR stdsContato[255+1];
			VARCHAR stidPagina[21+1];
			VARCHAR stdsPagina[255+1];
			VARCHAR stidTipoRetorno[21+1];
			VARCHAR stdsTipoRetorno[255+1];
			VARCHAR stidTipoFechamento[21+1];
			VARCHAR stdsTipoFechamento[255+1];
			VARCHAR stidTipoProcesso[21+1];
			VARCHAR stdsTipoProcesso[255+1];
			VARCHAR stqtHorasPrazo[21+1];
			VARCHAR stinFechamentoImediato[21+1];
			VARCHAR stvlPeso[21+1];
			VARCHAR stinProcessoTecnico[21+1];
            VARCHAR stqtHorasPrazoAnatel[21+1];
			VARCHAR stInSms[1+1];
			VARCHAR stDsSms[50+1];
			VARCHAR stInRelacionamento[1+1];
			VARCHAR stInProtocolo[1+1];
			VARCHAR stInexibeProtocolo[1+1];
			VARCHAR stDsContatoCanais[50+1];
			VARCHAR stdsMsgExcessao[60+1];
			VARCHAR stInCancelamento[1+1];
			VARCHAR stIdClassificacaoSms[40+1];
            VARCHAR stInAberturaContato[2];
            VARCHAR stSgRegraEncaminhamento[3+1];
            VARCHAR stSgFluxoAtendimento[3+1];
		} stContatoFolhaRegistro;
		struct
		{
			short iidContato;
			short idsContato;
			short iidPagina;
			short idsPagina;
			short iidTipoRetorno;
			short idsTipoRetorno;
			short iidTipoFechamento;
			short idsTipoFechamento;
			short iidTipoProcesso;
			short idsTipoProcesso;
			short iqtHorasPrazo;
			short iinFechamentoImediato;
			short ivlPeso;
			short iinProcessoTecnico;
            short iqtHorasPrazoAnatel;
			short i_InSms;
			short i_DsSms;
			short i_InRelacionamento;
			short i_InProtocolo;
			short i_InexibeProtocolo;
			short i_DsContatoCanais;
			short i_dsMsgExcessao;
			short i_InCancelamento;
			short i_IdClassificacaoSms;
            short i_InAberturaContato;
            short i_SgRegraEncaminhamento;
            short i_SgFluxoAtendimento;
		} stContatoFolhaIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoFolha();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL 
   			DECLARE 
   				CursorContatoFolhaId CURSOR FOR 
            SELECT 
                CONTATO.IDCONTATO,
                NOMECONTATO.NMCONTATO,
                UNIDADE.IDUNIDADE,
                UNIDADE.NMUNIDADE,
                TIPORETORNOCONTATO.IDTIPORETORNOCONTATO,
                TIPORETORNOCONTATO.NMTIPORETORNOCONTATO,
                TIPOFECHAMENTOCONTATO.IDTIPOFECHAMENTOCONTATO,
                TIPOFECHAMENTOCONTATO.NMTIPOFECHAMENTOCONTATO,
                TIPOPROCESSO.IDTIPOPROCESSO,
                TIPOPROCESSO.DSTIPOPROCESSO,
                CONTATOFOLHA.QTHORASPRAZOCONTATO,
                CONTATOFOLHA.INFECHAMENTOIMEDIATO,
                CONTATOFOLHA.VLPESOCONTATO,
                CONTATOFOLHA.INPROCESSOTECNICO,
                CONTATOFOLHA.QTHORASPRAZOANATEL,
                CONTATOFOLHA.INSMS ,
                CONTATOFOLHA.DSSMS ,
                CONTATOFOLHA.INRELACIONAMENTO ,
                CONTATOFOLHA.INPROTOCOLO ,
                CONTATOFOLHA.INEXIBEPROTOCOLO ,
                CONTATOFOLHA.DSCONTATOCANAIS ,
                CONTATOFOLHA.DSMSGEXCECAO,
                CONTATOFOLHA.INCANCELAMENTO,
                CONTATOFOLHA.IDCLASSIFICACAOSMS ,
                CONTATOFOLHA.INABERTURACONTATO ,
                NVL(CONTATOFOLHA.SGREGRAENCAMINHAMENTO,'WRK') AS SGREGRAENCAMINHAMENTO ,
                CONTATOFOLHA.SGFLUXOATENDIMENTO
            FROM
                CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
                CONTATOADM.TIPORETORNOCONTATO TIPORETORNOCONTATO,
                CONTATOADM.TIPOFECHAMENTOCONTATO TIPOFECHAMENTOCONTATO,
                CONTATOADM.CONTATO CONTATO,
                CONTATOADM.NOMECONTATO NOMECONTATO,
                WORKFLOW.TIPOPROCESSO TIPOPROCESSO,
                ACESSO.UNIDADE UNIDADE
            WHERE
                CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO
            AND CONTATO.IDCONTATO = CONTATOFOLHA.IDCONTATO
            AND CONTATOFOLHA.IDTIPORETORNOCONTATO = TIPORETORNOCONTATO.IDTIPORETORNOCONTATO
            AND CONTATOFOLHA.IDTIPOFECHAMENTOCONTATO = TIPOFECHAMENTOCONTATO.IDTIPOFECHAMENTOCONTATO
            AND CONTATOFOLHA.IDTIPOPROCESSO = TIPOPROCESSO.IDTIPOPROCESSO
            AND CONTATOFOLHA.IDUNIDADE = UNIDADE.IDUNIDADE
			AND CONTATOFOLHA.IDCONTATO = :cAuxidContato;

		//Abre o cursor
		EXEC SQL OPEN CursorContatoFolhaId;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CContatoFolha::ListId()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			for(;;)
			{
				EXEC SQL WHENEVER NOT FOUND DO break;
				//Zera a estrutura de restorno
				memset( &stMensagem, 0, sizeof(stMensagem) );
				memset( &stContatoFolhaRegistro, 0, sizeof(stContatoFolhaRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorContatoFolhaId INTO :stContatoFolhaRegistro:stContatoFolhaIndicator;
							
				EXEC SQL WHENEVER NOT FOUND CONTINUE;

				EXEC SQL
					SELECT 
					    CONTATOFOLHAMENSAGEMAVISO.IDMENSAGEMAVISO,
					    MENSAGEMAVISO.DSMENSAGEMAVISO
					INTO
						:stMensagem:stMensagemInd
					FROM
					    CONTATOADM.CONTATOFOLHAMENSAGEMAVISO CONTATOFOLHAMENSAGEMAVISO,
						CONTATOADM.MENSAGEMAVISO MENSAGEMAVISO
					WHERE
						 MENSAGEMAVISO.IDMENSAGEMAVISO=CONTATOFOLHAMENSAGEMAVISO.IDMENSAGEMAVISO
					AND
						CONTATOFOLHAMENSAGEMAVISO.IDCONTATO =:stContatoFolhaRegistro.stidContato
					AND
						ROWNUM <= 1;

				//Adiciona a classe
				Add( (char*)stContatoFolhaRegistro.stidContato.arr
				    ,(char*)stContatoFolhaRegistro.stdsContato.arr
				    ,(char*)stContatoFolhaRegistro.stidPagina.arr
				    ,(char*)stContatoFolhaRegistro.stdsPagina.arr
				    ,(char*)stContatoFolhaRegistro.stidTipoRetorno.arr
				    ,(char*)stContatoFolhaRegistro.stdsTipoRetorno.arr
				    ,(char*)stContatoFolhaRegistro.stidTipoFechamento.arr
				    ,(char*)stContatoFolhaRegistro.stdsTipoFechamento.arr
				    ,(char*)stContatoFolhaRegistro.stidTipoProcesso.arr
				    ,(char*)stContatoFolhaRegistro.stdsTipoProcesso.arr
				    ,(char*)stContatoFolhaRegistro.stqtHorasPrazo.arr
				    ,(char*)stContatoFolhaRegistro.stinFechamentoImediato.arr
				    ,(char*)stContatoFolhaRegistro.stvlPeso.arr
				    ,(char*)stContatoFolhaRegistro.stinProcessoTecnico.arr
				    ,(char*)stMensagem.stidMensagem.arr
				    ,(char*)stMensagem.stnmMensagem.arr
				    ,(char*)stContatoFolhaRegistro.stqtHorasPrazoAnatel.arr
				    ,(char*)stContatoFolhaRegistro.stInSms.arr
			        ,(char*)stContatoFolhaRegistro.stDsSms.arr
			        ,(char*)stContatoFolhaRegistro.stInRelacionamento.arr
			        ,(char*)stContatoFolhaRegistro.stInProtocolo.arr
			        ,(char*)stContatoFolhaRegistro.stInexibeProtocolo.arr
			        ,(char*)stContatoFolhaRegistro.stDsContatoCanais.arr
			        ,(char*)stContatoFolhaRegistro.stdsMsgExcessao.arr
   				    ,(char*)stContatoFolhaRegistro.stInCancelamento.arr
   				    ,(char*)stContatoFolhaRegistro.stIdClassificacaoSms.arr
                    ,(char*)stContatoFolhaRegistro.stInAberturaContato.arr
                    ,(char*)stContatoFolhaRegistro.stSgRegraEncaminhamento.arr
                    ,(char*)stContatoFolhaRegistro.stSgFluxoAtendimento.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorContatoFolhaId;
		}
		ULOG_END("CContatoFolha::ListId()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContatoFolha::ListAll( void )
{
    ULOG_START("CContatoFolha::ListAll()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidMensagem[21+1];
			VARCHAR stnmMensagem[255+1];
		} stMensagem;
		struct
		{
			VARCHAR stidContato[21+1];
			VARCHAR stdsContato[255+1];
			VARCHAR stidPagina[21+1];
			VARCHAR stdsPagina[255+1];
			VARCHAR stidTipoRetorno[21+1];
			VARCHAR stdsTipoRetorno[255+1];
			VARCHAR stidTipoFechamento[21+1];
			VARCHAR stdsTipoFechamento[255+1];
			VARCHAR stidTipoProcesso[21+1];
			VARCHAR stdsTipoProcesso[255+1];
			VARCHAR stqtHorasPrazo[21+1];
			VARCHAR stinFechamentoImediato[21+1];
			VARCHAR stvlPeso[21+1];
			VARCHAR stinProcessoTecnico[21+1];
            VARCHAR stqtHorasPrazoAnatel[21+1];
			VARCHAR stInSms[1+1];
			VARCHAR stDsSms[50+1];
			VARCHAR stInRelacionamento[1+1];
			VARCHAR stInProtocolo[1+1];
			VARCHAR stInexibeProtocolo[1+1];
			VARCHAR stDsContatoCanais[50+1];
			VARCHAR stdsMsgExcessao[60+1];
			VARCHAR stInCancelamento[1+1];
			VARCHAR stIdClassificacaoSms[40+1];
            VARCHAR stInAberturaContato[2];
            VARCHAR stSgRegraEncaminhamento[3+1];
            VARCHAR stSgFluxoAtendimento[3+1];
		} stContatoFolhaRegistro;
		struct
		{
			short iidContato;
			short idsContato;
			short iidPagina;
			short idsPagina;
			short iidTipoRetorno;
			short idsTipoRetorno;
			short iidTipoFechamento;
			short idsTipoFechamento;
			short iidTipoProcesso;
			short idsTipoProcesso;
			short iqtHorasPrazo;
			short iinFechamentoImediato;
			short ivlPeso;
			short iinProcessoTecnico;
            short iqtHorasPrazoAnatel;
			short i_InSms;
			short i_DsSms;
			short i_InRelacionamento;
			short i_InProtocolo;
			short i_InexibeProtocolo;
			short i_DsContatoCanais;
			short i_dsMsgExcessao;
			short i_InCancelamento;
			short i_IdClassificacaoSms;
            short i_InAberturaContato;
            short i_SgRegraEncaminhamento;
            short i_SgFluxoAtendimento;
		} stContatoFolhaIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoFolha();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL 
   			DECLARE 
   				CursorContatoFolhaAll CURSOR FOR
			SELECT 
				CONTATO.IDCONTATO,
				NOMECONTATO.NMCONTATO,
				UNIDADE.IDUNIDADE,
				UNIDADE.NMUNIDADE,
				TIPORETORNOCONTATO.IDTIPORETORNOCONTATO,
				TIPORETORNOCONTATO.NMTIPORETORNOCONTATO,
				TIPOFECHAMENTOCONTATO.IDTIPOFECHAMENTOCONTATO,
				TIPOFECHAMENTOCONTATO.NMTIPOFECHAMENTOCONTATO,
				TIPOPROCESSO.IDTIPOPROCESSO,
				TIPOPROCESSO.DSTIPOPROCESSO,
				CONTATOFOLHA.QTHORASPRAZOCONTATO,
				CONTATOFOLHA.INFECHAMENTOIMEDIATO,
				CONTATOFOLHA.VLPESOCONTATO,
				CONTATOFOLHA.INPROCESSOTECNICO,
                CONTATOFOLHA.QTHORASPRAZOANATEL,
                CONTATOFOLHA.INSMS ,
                CONTATOFOLHA.DSSMS ,
                CONTATOFOLHA.INRELACIONAMENTO ,
                CONTATOFOLHA.INPROTOCOLO ,
                CONTATOFOLHA.INEXIBEPROTOCOLO ,
                CONTATOFOLHA.DSCONTATOCANAIS ,
                CONTATOFOLHA.DSMSGEXCECAO ,
				CONTATOFOLHA.INCANCELAMENTO ,
                CONTATOFOLHA.IDCLASSIFICACAOSMS ,
                CONTATOFOLHA.INABERTURACONTATO ,
                CONTATOFOLHA.SGREGRAENCAMINHAMENTO ,
                CONTATOFOLHA.SGFLUXOATENDIMENTO
			FROM
				CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
                CONTATOADM.TIPORETORNOCONTATO TIPORETORNOCONTATO,
                CONTATOADM.TIPOFECHAMENTOCONTATO TIPOFECHAMENTOCONTATO,
                CONTATOADM.CONTATO CONTATO,
                CONTATOADM.NOMECONTATO NOMECONTATO,
                WORKFLOW.TIPOPROCESSO TIPOPROCESSO,
                ACESSO.UNIDADE UNIDADE
			WHERE
				CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO
            AND CONTATO.IDCONTATO = CONTATOFOLHA.IDCONTATO
            AND CONTATOFOLHA.IDTIPORETORNOCONTATO = TIPORETORNOCONTATO.IDTIPORETORNOCONTATO
            AND CONTATOFOLHA.IDTIPOFECHAMENTOCONTATO = TIPOFECHAMENTOCONTATO.IDTIPOFECHAMENTOCONTATO
            AND CONTATOFOLHA.IDTIPOPROCESSO = TIPOPROCESSO.IDTIPOPROCESSO;

		//Abre o cursor
		EXEC SQL OPEN CursorContatoFolhaAll;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CContatoFolha::ListAll()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stMensagem, 0, sizeof(stMensagem) );
				memset( &stContatoFolhaRegistro, 0, sizeof(stContatoFolhaRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorContatoFolhaAll INTO :stContatoFolhaRegistro:stContatoFolhaIndicator;
				
				EXEC SQL
				SELECT 
					    CONTATOFOLHAMENSAGEMAVISO.IDMENSAGEMAVISO,
					    MENSAGEMAVISO.DSMENSAGEMAVISO
					INTO
						:stMensagem	
					FROM
					    CONTATOADM.CONTATOFOLHAMENSAGEMAVISO CONTATOFOLHAMENSAGEMAVISO,
						CONTATOADM.MENSAGEMAVISO MENSAGEMAVISO
					WHERE
						 MENSAGEMAVISO.IDMENSAGEMAVISO=CONTATOFOLHAMENSAGEMAVISO.IDMENSAGEMAVISO
					AND
						CONTATOFOLHAMENSAGEMAVISO.IDCONTATO =:stContatoFolhaRegistro.stidContato;

				//Adiciona a classe
				Add( (char*)stContatoFolhaRegistro.stidContato.arr
				    ,(char*)stContatoFolhaRegistro.stdsContato.arr
				    ,(char*)stContatoFolhaRegistro.stidPagina.arr
				    ,(char*)stContatoFolhaRegistro.stdsPagina.arr
				    ,(char*)stContatoFolhaRegistro.stidTipoRetorno.arr
				    ,(char*)stContatoFolhaRegistro.stdsTipoRetorno.arr
				    ,(char*)stContatoFolhaRegistro.stidTipoFechamento.arr
				    ,(char*)stContatoFolhaRegistro.stdsTipoFechamento.arr
				    ,(char*)stContatoFolhaRegistro.stidTipoProcesso.arr
				    ,(char*)stContatoFolhaRegistro.stdsTipoProcesso.arr
				    ,(char*)stContatoFolhaRegistro.stqtHorasPrazo.arr
				    ,(char*)stContatoFolhaRegistro.stinFechamentoImediato.arr
				    ,(char*)stContatoFolhaRegistro.stvlPeso.arr
				    ,(char*)stContatoFolhaRegistro.stinProcessoTecnico.arr
				    ,(char*)stMensagem.stidMensagem.arr
				    ,(char*)stMensagem.stnmMensagem.arr
                    ,(char*)stContatoFolhaRegistro.stqtHorasPrazoAnatel.arr
				    ,(char*)stContatoFolhaRegistro.stInSms.arr
			        ,(char*)stContatoFolhaRegistro.stDsSms.arr
			        ,(char*)stContatoFolhaRegistro.stInRelacionamento.arr
			        ,(char*)stContatoFolhaRegistro.stInProtocolo.arr
			        ,(char*)stContatoFolhaRegistro.stInexibeProtocolo.arr
			        ,(char*)stContatoFolhaRegistro.stDsContatoCanais.arr
			        ,(char*)stContatoFolhaRegistro.stdsMsgExcessao.arr
					,(char*)stContatoFolhaRegistro.stInCancelamento.arr
   				    ,(char*)stContatoFolhaRegistro.stIdClassificacaoSms.arr
                    ,(char*)stContatoFolhaRegistro.stInAberturaContato.arr
                    ,(char*)stContatoFolhaRegistro.stSgRegraEncaminhamento.arr
                    ,(char*)stContatoFolhaRegistro.stSgFluxoAtendimento.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorContatoFolhaAll;
		}
		ULOG_END("CContatoFolha::ListAll()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CContatoFolha::GetXml( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
				xml->createTag(cNomeTag);
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idPaginaAtual", Registro(x)->cidPagina );
				xml->addItem("idTipoFechamentoAtual", Registro(x)->cidTipoFechamento ); 
				xml->addItem("idTipoProcessoAtual", Registro(x)->cidTipoProcesso ); 
				xml->addItem("inProcessoTecnico", Registro(x)->cinProcessoTecnico ); 
				xml->addItem("qtDiasPrazoContato", Registro(x)->cqtHorasPrazo ); 
				xml->addItem("vlPesoContato", Registro(x)->cvlPeso ); 
				xml->addItem("idMensagemAviso", Registro(x)->cidMensagem ); 
				xml->addItem("nmMensagemAviso", Registro(x)->cnmMensagem ); 
				xml->addItem("idTipoRetornoAtual", Registro(x)->cidTipoRetorno );
                xml->addItem("vlPrazoAnatel", Registro(x)->cqtHorasPrazoAnatel );
                xml->addItem("sgRegraEncaminhamento", Registro(x)->cSgRegraEncaminhamento );
                xml->addItem("sgFluxoAtendimento", Registro(x)->cSgFluxoAtendimento );
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}


void CContatoFolha::GetXmlSMP( XMLGen*xml )
{
	char sidClassificacaoSMS[32];
	
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
            if ( Registro(x)->cInProtocolo[0] != 0x0 )
            {
            	sidClassificacaoSMS[0] = 0x0;
            	GetIdClassificacaoSMS( Registro(x)->cidContato,sidClassificacaoSMS );
                xml->createTag("SmpVO");
                    xml->createTag("canais");
        				xml->addItem("inProtocolo", Registro(x)->cInProtocolo );
        				xml->addItem("inRelacionamento", Registro(x)->cInRelacionamento );
						xml->addItem("inComprovanteCancelamento", Registro(x)->cInCancelamento);
        				xml->addItem("dsContatoCanais", Registro(x)->cDsContatoCanais );
        				xml->addItem("dsMsgExcecao", Registro(x)->cDsMsgExcecao );
                    xml->closeTag();
                    xml->createTag("sms");
        				xml->addItem("inSMS", Registro(x)->cInSms );
        				xml->addItem("dsSMS", Registro(x)->cDsSms );
        				xml->addItem("idClassificacao", sidClassificacaoSMS );
        			xml->closeTag();
                xml->closeTag();
            }
            else
            {
                xml->createTag("SmpVO");
                    xml->createTag("canais");
        				xml->addItem("inProtocolo", 0 );
        				xml->addItem("inRelacionamento", 0 );
						xml->addItem("inComprovanteCancelamento",0);
        				xml->addItem("dsContatoCanais", "" );
        				xml->addItem("inExibeProtocolo", 0 );
        				xml->addItem("dsMsgExcecao", "" );
                    xml->closeTag();
                    xml->createTag("sms");
        				xml->addItem("inSMS", 1 );
        				xml->addItem("dsSMS", "" );
        				xml->addItem("idClassificacao", "" );
                    xml->closeTag();
                xml->closeTag();
            }  
        }
	}
	else
    {
        xml->createTag("SmpVO");
            xml->createTag("canais");
				xml->addItem("inProtocolo", 0 );
				xml->addItem("inRelacionamento", 0 );
				xml->addItem("dsContatoCanais", "" );
				xml->addItem("inExibeProtocolo", 0 );
				xml->addItem("dsMsgExcecao", "" );
            xml->closeTag();
            xml->createTag("sms");
				xml->addItem("inSMS", 1 );
				xml->addItem("dsSMS", "" );
            xml->closeTag();
        xml->closeTag();
    }
}



int CContatoFolha::TemTipoFechamento( char* cidContato, char* cidFase )
{
    ULOG_START("CContatoFolha::TemTipoFechamento()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		int iCount = 0;
		char* cidContatoAux = cidContato;
		char* cidFaseAux = cidFase;
	EXEC SQL END DECLARE SECTION;

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoTemTipoFechamento;
	sqlca.sqlcode=0;

	//Verifica se um certo contato contem algum tipo de fechamaneto
   	EXEC SQL 
	SELECT 
		COUNT(1)
	INTO
		:iCount
	FROM
		CONTATOADM.TIPOFECHAMENTOCONTATO TIPOFECHAMENTOCONTATO,
		WORKFLOW.FLUXOFASEGRUPO FLUXOFASEGRUPO
	WHERE
		TIPOFECHAMENTOCONTATO.IDTIPOFECHAMENTOCONTATO = FLUXOFASEGRUPO.IDTIPOFECHAMENTOCONTATO
	AND
		TIPOFECHAMENTOCONTATO.IDFASE = :cidFaseAux
	AND
		FLUXOFASEGRUPO.IDCONTATO = :cidContatoAux;
		
    ULOG_END("CContatoFolha::TemTipoFechamento()");
	return iCount;

GotoTemTipoFechamento:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}



void CContatoFolha::GetIdClassificacaoSMS( char * cidContato, char * sidClassificacaoSMS )
{
    ULOG_START("CContatoFolha::GetIdClassificacaoSMS()");

	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidContatoAux = cidContato;
		VARCHAR sidClSMS[32];
		short i_sidClSMS = -1;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoGetIdClassificacaoSMS;
	sqlca.sqlcode=0;

   	EXEC SQL 
	SELECT idclassificacaosms
	  INTO :sidClSMS:i_sidClSMS
	  FROM contatoadm.contatofolha
	 WHERE idcontato = :cidContatoAux;
 	sprintf( sidClassificacaoSMS,"%.*s",sidClSMS.len,(char *)sidClSMS.arr );
    ULOG_END("CContatoFolha::GetIdClassificacaoSMS()");
	return;
	
GotoGetIdClassificacaoSMS:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}
