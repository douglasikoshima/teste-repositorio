#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CCmpDom.h"

CCampoDominio::CCampoDominio()
{
}

CCampoDominio::~CCampoDominio()
{
}

int CCampoDominio::ListId( char* cidCampo ) 
{
    ULOG_START("CCampoDominio::ListId()");		
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidCampo = cidCampo; 
		struct
		{
			VARCHAR stidCampo[21+1];
			VARCHAR stdsQuery[500+1];
			VARCHAR stnmAtributoIdentificador[255+1];
			VARCHAR stnmAtributoDescritivo[255+1];
			VARCHAR stidTabelaDominio[21+1];
		} stCampoDominioRegistro;
		struct
		{
			short iidCampo;
			short idsQuery;
			short inmAtributoIdentificador;
			short inmAtributoDescritivo;
			short iidTabelaDominio;
		} stCampoDominioIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraCampoDominio();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL DECLARE CursorCampoDominioId CURSOR FOR 
   		SELECT
   			IDCAMPO,
			DSQUERY,
			NMATRIBUTOIDENTIFICADOR,
			NMATRIBUTODESCRITIVO,
			IDTABELADOMINIO
		FROM
			CONTATOADM.CAMPODOMINIO
		WHERE
			IDCAMPO = :cAuxidCampo;

		//Abre o cursor
		EXEC SQL OPEN CursorCampoDominioId;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stCampoDominioRegistro, 0, sizeof(stCampoDominioRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorCampoDominioId INTO :stCampoDominioRegistro:stCampoDominioIndicator;
				//Adiciona a classe
				Add(
					(char*)stCampoDominioRegistro.stidCampo.arr,
					(char*)stCampoDominioRegistro.stdsQuery.arr,
					(char*)stCampoDominioRegistro.stnmAtributoIdentificador.arr,
					(char*)stCampoDominioRegistro.stnmAtributoDescritivo.arr,
					(char*)stCampoDominioRegistro.stidTabelaDominio.arr 
				);
				//conta quantos existem
				iCont++;
			}
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorCampoDominioId;
		}
		ULOG_END("CCampoDominio::ListId()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CCampoDominio::ListAll( void )
{
    ULOG_START("CCampoDominio::ListAll()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidCampo[21+1];
			VARCHAR stdsQuery[500+1];
			VARCHAR stnmAtributoIdentificador[255+1];
			VARCHAR stnmAtributoDescritivo[255+1];
			VARCHAR stidTabelaDominio[21+1];
		} stCampoDominioRegistro;
		struct
		{
			short iidCampo;
			short idsQuery;
			short inmAtributoIdentificador;
			short inmAtributoDescritivo;
			short iidTabelaDominio;
		} stCampoDominioIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraCampoDominio();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL DECLARE CursorCampoDominioAll CURSOR FOR
   		SELECT
   			IDCAMPO,
			DSQUERY,
			NMATRIBUTOIDENTIFICADOR,
			NMATRIBUTODESCRITIVO,
			IDTABELADOMINIO
		FROM CONTATOADM.CAMPODOMINIO; 

		//Abre o cursor
		EXEC SQL OPEN CursorCampoDominioAll;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stCampoDominioRegistro, 0, sizeof(stCampoDominioRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorCampoDominioAll INTO :stCampoDominioRegistro:stCampoDominioIndicator;
				//Adiciona a classe
				Add(
					(char*)stCampoDominioRegistro.stidCampo.arr,
					(char*)stCampoDominioRegistro.stdsQuery.arr,
					(char*)stCampoDominioRegistro.stnmAtributoIdentificador.arr,
					(char*)stCampoDominioRegistro.stnmAtributoDescritivo.arr,
					(char*)stCampoDominioRegistro.stidTabelaDominio.arr
				);
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorCampoDominioAll;
		}
		ULOG_END("CCampoDominio::ListAll()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CCampoDominio::GetXml( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			xml->createTag(cNomeTag);
			//Adiciona a proprieda necessaria para o Weblogic
			xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idCampo", Registro(x)->cidCampo );
				xml->addItem("dsQuery", Registro(x)->cdsQuery );
				xml->addItem("nmAtributoIdentificador", Registro(x)->cnmAtributoIdentificador );
				xml->addItem("nmAtributoDescritivo", Registro(x)->cnmAtributoDescritivo );
				xml->addItem("idTabelaDominio", Registro(x)->cidTabelaDominio );
			}
			//So fecha um tag se abriu anteriormente
			xml->closeTag();
		}
	}
}

void CCampoDominio::GetXml( XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idCampo", Registro(x)->cidCampo );
				xml->addItem("dsQuery", Registro(x)->cdsQuery );
				xml->addItem("nmAtributoIdentificador", Registro(x)->cnmAtributoIdentificador );
				xml->addItem("nmAtributoDescritivo", Registro(x)->cnmAtributoDescritivo );
				xml->addItem("idTabelaDominio", Registro(x)->cidTabelaDominio );
			}
		}
	}
}

int CCampoDominio::Insert(
					 char* cidCampo
					,char* cdsQuery
					,char* cnmAtributoIdentificador
					,char* cnmAtributoDescritivo
					,char* cidTabelaDominio
					,char* cidUser
	 )
{
    ULOG_START("CCampoDominio::Insert()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidUserAux = cidUser;
		char* cidCampoAux = cidCampo;
		char* cdsQueryAux = cdsQuery;
		char* cnmAtributoIdentificadorAux = cnmAtributoIdentificador;
		char* cnmAtributoDescritivoAux = cnmAtributoDescritivo;
		char* cidTabelaDominioAux = cidTabelaDominio;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );
	sqlca.sqlcode = 0;

	if((cidTabelaDominio != NULL && cdsQuery != NULL ) ||
		(cidTabelaDominio == NULL && cdsQuery == NULL) ||
		(cidCampo == NULL))
	{
		return -5;
	}

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;


	//Insere um registro
	EXEC SQL 
	INSERT INTO CONTATOADM.CAMPODOMINIO
	( 
		 IDCAMPO
		,DSQUERY
		,NMATRIBUTOIDENTIFICADOR
		,NMATRIBUTODESCRITIVO
		,IDTABELADOMINIO
		,IDUSUARIOALTERACAO
		,DTULTIMAALTERACAO
	)
	VALUES 
	( 
		:cidCampoAux
		,:cdsQueryAux
		,:cnmAtributoIdentificadorAux
		,:cnmAtributoDescritivoAux
		,:cidTabelaDominioAux
		,:cidUserAux
		,SYSDATE 
	);
	
	if(cnmAtributoIdentificador == NULL)
	{
		cnmAtributoIdentificador = "";
	}
	if(cnmAtributoDescritivo == NULL)
	{
		cnmAtributoDescritivo = "";
	}
	if(cidTabelaDominio == NULL)
	{
		cidTabelaDominio = "";
	}
	if(cdsQueryAux == NULL)
	{
		cdsQueryAux = "";
	}

	//Salva o registro na estrutura interna
	Add(
		cidCampo
		,cdsQuery
		,cnmAtributoIdentificador
		,cnmAtributoDescritivo
		,cidTabelaDominio
	);
	
    ULOG_END("CCampoDominio::Insert()");
    
	return 0;

GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);

	if( sqlca.sqlcode == -1 )
		return -1;
	else
	if( sqlca.sqlcode == -2291)
		return -2;
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CCampoDominio::Update(
					 char* cidCampo
					,char* cdsQuery
					,char* cnmAtributoIdentificador
					,char* cnmAtributoDescritivo
					,char* cidTabelaDominio
					,char* cidUser
	 ) 
{
    ULOG_START("CCampoDominio::Update()");
	if(cnmAtributoIdentificador == NULL)
	{
		cnmAtributoIdentificador = "";
	}
	if(cnmAtributoDescritivo == NULL)
	{
		cnmAtributoDescritivo = "";
	}
	if(cidTabelaDominio == NULL)
	{
		cidTabelaDominio = "";
	}
	if(cdsQuery == NULL)
	{
		cdsQuery = "";
	}

	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidUserAux = cidUser;
		char* cidCampoAux = cidCampo;
		char* cdsQueryAux = cdsQuery;
		char* cnmAtributoIdentificadorAux = cnmAtributoIdentificador;
		char* cnmAtributoDescritivoAux = cnmAtributoDescritivo;
		char* cidTabelaDominioAux = cidTabelaDominio;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;

	//Atualiza um registro
	EXEC SQL 
	UPDATE 
		CONTATOADM.CAMPODOMINIO
	SET 
		 DSQUERY = :cdsQueryAux
		,NMATRIBUTOIDENTIFICADOR = :cnmAtributoIdentificadorAux
		,NMATRIBUTODESCRITIVO = :cnmAtributoDescritivoAux
		,IDTABELADOMINIO = :cidTabelaDominioAux
		,IDUSUARIOALTERACAO = :cidUserAux
		,DTULTIMAALTERACAO = SYSDATE
	WHERE
		IDCAMPO = :cidCampoAux;

	//Salva o registro na estrutura interna
	Add(
		 cidCampo
		,cdsQuery
		,cnmAtributoIdentificador
		,cnmAtributoDescritivo
		,cidTabelaDominio
	);
    ULOG_END("CCampoDominio::Update()");
	return 1;

GotoUpdate:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CCampoDominio::Delete( 
					 char* cidCampo
				  ) 
{
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidCampoAux = cidCampo;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;

	//Apaga um registro
	EXEC SQL 
	DELETE FROM 
		CONTATOADM.CAMPODOMINIO
	WHERE 
		IDCAMPO = :cidCampoAux;

	return 1;

GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}