/* charls */
#undef SQLCA
#define SQLCA_NONE
#include <tuxfw.h>
#include <sqlca.h>
#include <sqlda.h>


#include<CCttCmb.h>

CContatoCombos::CContatoCombos()
{
}

CContatoCombos::~CContatoCombos()
{
}

int CContatoCombos::Relacao(XMLGen*xml_g)
{

    ULOG_START("CContatoCombos::Relacao()");
	ListaTipoFechamento();
	GetXmlTipoFechamento( "AdmTipoFechamentoVO", xml_g );

	ListaTipoProcesso();
	GetXmlTipoProcesso( "AdmTipoProcessoVO", xml_g );

	ListaMensagemAviso();
	GetXmlContatoFolhaMensagenAviso( "AdmMensagemAvisoVO", xml_g );
    
	ListaTipoRetorno();
	GetXmlTipoRetornoContato( "AdmTipoRetornoContatoVO", xml_g );

	ListaPrazoAtendimento();
	GetXmlPrazoAtendimento( "AdmPrazoVO", xml_g );

//  Resposta Cliente

	ListaPrazoAnatel();

	GetXmlPrazoAnatel( "AdmPrazoAnatelVO", xml_g );

	ListaPesoPrioridade();
	GetXmlPesoPrioridade( "AdmPrioridadeVO", xml_g );


    ULOG_END("CContatoCombos::Relacao()");
    
	return 1;
}



void CContatoCombos::GetXmlTipoFechamento( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
			{
				xml->createTag(cNomeTag);
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idTipoFechamento", Registro(x)->cidCombo );
				xml->addItem("nmTipoFechamento", Registro(x)->cdsCombo ); 
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}
void CContatoCombos::GetXmlTipoProcesso( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
			{
				xml->createTag(cNomeTag);
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idTipoProcesso", Registro(x)->cidCombo );
				xml->addItem("dsTipoProcesso", Registro(x)->cdsCombo ); 
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}
void CContatoCombos::GetXmlContatoFolhaMensagenAviso( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
			{
				xml->createTag(cNomeTag);
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idMensagemAviso", Registro(x)->cidCombo );
				xml->addItem("dsMensagemAviso", Registro(x)->cdsCombo ); 
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}
void CContatoCombos::GetXmlTipoRetornoContato( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
			{
				xml->createTag(cNomeTag);
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idTipoRetornoContato", Registro(x)->cidCombo );
				xml->addItem("nmTipoRetornoContato", Registro(x)->cdsCombo ); 
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}

void CContatoCombos::GetXmlPrazoAnatel( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
			{
				xml->createTag(cNomeTag);
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("vlPrazoAnatel", Registro(x)->cdsCombo ); 
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}

void CContatoCombos::GetXmlPrazoAtendimento( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
			{
				xml->createTag(cNomeTag);
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("vlPrazo", Registro(x)->cdsCombo ); 
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}

void CContatoCombos::GetXmlPesoPrioridade( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
			{
				xml->createTag(cNomeTag);
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("vlPrioridade", Registro(x)->cdsCombo ); 
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}


int CContatoCombos::ListaTipoFechamento( void )
{
    ULOG_START("CContatoCombos::ListaTipoFechamento()");
    // setStatusCode("14I0000","inicio do metodo ListaTipoFechamento ");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidCombo[21+1];
			VARCHAR stdsCombo[255+1];
		} stRegistro;
		struct
		{
			short iidCombo;
			short idsCombo;
		} stIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoCombos();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListaTipoFechamento;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL 
   			DECLARE 
   				CursorListaTipoFechamento CURSOR FOR
			SELECT 
				IDTIPOFECHAMENTOCONTATO, 
				NMTIPOFECHAMENTOCONTATO
			FROM 
				CONTATOADM.TIPOFECHAMENTOCONTATO;
		//Abre o cursor
		EXEC SQL OPEN CursorListaTipoFechamento;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stRegistro, 0, sizeof(stRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorListaTipoFechamento INTO :stRegistro:stIndicator;
				//Adiciona a classe
				Add( (char*)stRegistro.stidCombo.arr
				    ,""
				    ,(char*)stRegistro.stdsCombo.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorListaTipoFechamento;
		}
		ULOG_END("CContatoCombos::ListaTipoFechamento()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListaTipoFechamento:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContatoCombos::ListaTipoProcesso( void )
{
    ULOG_START("CContatoCombos::ListaTipoProcesso()");
	//Variavel de controle para a quantidade de registros retornada
    // setStatusCode("14I0000","inicio do metodo ListaTipoProcesso ");
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidCombo[21+1];
			VARCHAR stdsCombo[255+1];
		} stRegistro;
		struct
		{
			short iidCombo;
			short idsCombo;
		} stIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoCombos();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListaTipoProcesso;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL 
   			DECLARE 
   				CursorListaTipoProcesso CURSOR FOR
		SELECT
		      IDTIPOPROCESSO
		     ,DSTIPOPROCESSO
		FROM
			WORKFLOW.TIPOPROCESSO;
		//Abre o cursor
		EXEC SQL OPEN CursorListaTipoProcesso;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		   ULOG_END("CContatoCombos::ListaTipoProcesso()");
		   return 0;//Erro
		}
		else
		{
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stRegistro, 0, sizeof(stRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorListaTipoProcesso INTO :stRegistro:stIndicator;
				//Adiciona a classe
				Add( (char*)stRegistro.stidCombo.arr
				    ,""
				    ,(char*)stRegistro.stdsCombo.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorListaTipoProcesso;
		}
		ULOG_END("CContatoCombos::ListaTipoProcesso()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListaTipoProcesso:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}


int CContatoCombos::ListaMensagemAviso( void )
{
    ULOG_START("CContatoCombos::ListaMensagemAviso()");
    // setStatusCode("14I0000","inicio do metodo ListaMensagemAviso ");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidCombo[21+1];
			VARCHAR stdsCombo[255+1];
		} stRegistro;
		struct
		{
			short iidCombo;
			short idsCombo;
		} stIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoCombos();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListaMensagemAviso;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL 
   			DECLARE 
   				CursorListaMensagemAviso CURSOR FOR
			SELECT
				 IDMENSAGEMAVISO
				,DSMENSAGEMAVISO
			FROM
			     CONTATOADM.MENSAGEMAVISO;
		//Abre o cursor
		EXEC SQL OPEN CursorListaMensagemAviso;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CContatoCombos::ListaMensagemAviso()");
			return 0;//Erro
		}
		else
		{
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stRegistro, 0, sizeof(stRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorListaMensagemAviso INTO :stRegistro:stIndicator;
				//Adiciona a classe
				Add( (char*)stRegistro.stidCombo.arr
				    ,""
				    ,(char*)stRegistro.stdsCombo.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorListaMensagemAviso;
		}
		ULOG_END("CContatoCombos::ListaMensagemAviso()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListaMensagemAviso:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContatoCombos::ListaTipoRetorno( void )
{
    ULOG_START("CContatoCombos::ListaTipoRetorno()");
    // setStatusCode("14I0000","inicio do metodo ListaTipoRetorno ");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidCombo[21+1];
			VARCHAR stdsCombo[255+1];
		} stRegistro;
		struct
		{
			short iidCombo;
			short idsCombo;
		} stIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoCombos();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListaTipoRetorno;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL 
   			DECLARE 
   				CursorListaTipoRetorno CURSOR FOR
			SELECT
	 			 IDTIPORETORNOCONTATO
				,NMTIPORETORNOCONTATO
			FROM
				CONTATOADM.TIPORETORNOCONTATO;
		//Abre o cursor
		EXEC SQL OPEN CursorListaTipoRetorno;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		   ULOG_END("CContatoCombos::ListaTipoRetorno()");
  		   return 0;//Erro
  		}
		else
		{
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stRegistro, 0, sizeof(stRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorListaTipoRetorno INTO :stRegistro:stIndicator;
				//Adiciona a classe
				Add( (char*)stRegistro.stidCombo.arr
				    ,""
				    ,(char*)stRegistro.stdsCombo.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorListaTipoRetorno;
		}
		ULOG_END("CContatoCombos::ListaTipoRetorno()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListaTipoRetorno:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CContatoCombos::ListaPrazoAtendimento( void  )
{
    ULOG_START("CContatoCombos::ListaPrazoAtendimento()");
    // setStatusCode("14I0000","inicio do metodo ListaPrazoAtendimento ");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidCombo[21+1];
			VARCHAR stdsCombo[255+1];
		} stRegistro;
		struct
		{
			short iidCombo;
			short idsCombo;
		} stIndicator;
		
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoCombos();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListaPrazoAtendimento;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL 
   			DECLARE 
   				CursorListaPrazoAtendimento CURSOR FOR
			SELECT
				IDPRAZOATENDIMENTOWF,
				VLPRAZOATENDIMENTOWF 
			FROM
				APOIO.PRAZOATENDIMENTOWF
            WHERE 
                INPRAZOANATEL = 0
			ORDER BY
				VLPRAZOATENDIMENTOWF;

		//Abre o cursor
		EXEC SQL OPEN CursorListaPrazoAtendimento;

		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRegistro, 0, sizeof(stRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListaPrazoAtendimento INTO :stRegistro:stIndicator;
			//Adiciona a classe
			Add( (char*)stRegistro.stidCombo.arr
			    ,""
			    ,(char*)stRegistro.stdsCombo.arr
			   );
			//conta quantos existem
			iCont++;
		}
		//Fecha o cursor
		EXEC SQL CLOSE CursorListaPrazoAtendimento;
		
        ULOG_END("CContatoCombos::ListaPrazoAtendimento()");
        
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListaPrazoAtendimento:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}



int CContatoCombos::ListaPrazoAnatel( void )
{
    ULOG_START("CContatoCombos::ListaPrazoAnatel()");
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidCombo[21+1];
			VARCHAR stdsCombo[255+1];
		} stRegistro;
		struct
		{
			short iidCombo;
			short idsCombo;
		} stIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoCombos();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListaPrazoAtendimento;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL 
   			DECLARE 
   				CursorListaPrazoAtendimentoAnatel CURSOR FOR
			SELECT
				IDPRAZOATENDIMENTOWF,
				VLPRAZOATENDIMENTOWF 
			FROM
				APOIO.PRAZOATENDIMENTOWF
            WHERE 
                INPRAZOANATEL = 1
			ORDER BY
				VLPRAZOATENDIMENTOWF;

		//Abre o cursor
		EXEC SQL OPEN CursorListaPrazoAtendimentoAnatel;

		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRegistro, 0, sizeof(stRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListaPrazoAtendimentoAnatel INTO :stRegistro:stIndicator;
			//Adiciona a classe
			Add( (char*)stRegistro.stidCombo.arr
			    ,""
			    ,(char*)stRegistro.stdsCombo.arr
			   );
			//conta quantos existem
			iCont++;
		}
		//Fecha o cursor
		EXEC SQL CLOSE CursorListaPrazoAtendimentoAnatel;
		
        ULOG_END("CContatoCombos::ListaPrazoAnatel()");
        
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListaPrazoAtendimento:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}



int CContatoCombos::ListaPesoPrioridade( void )
{
    ULOG_START("CContatoCombos::ListaPesoPrioridade()");
    // setStatusCode("14I0000","inicio do metodo ListaPesoPrioridade ");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidCombo[21+1];
			VARCHAR stdsCombo[255+1];
		} stRegistro;
		struct
		{
			short iidCombo;
			short idsCombo;
		} stIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraContatoCombos();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListaPesoPrioridade;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL 
   			DECLARE 
   				CursorListaPesoPrioridade CURSOR FOR
			SELECT
				IDPESOPRIORIDADEWF, 
				VLPESOPRAZOPRIORIDADEWF 
			FROM
				APOIO.PESOPRIORIDADEWF
			ORDER BY
				VLPESOPRAZOPRIORIDADEWF;

		//Abre o cursor
		EXEC SQL OPEN CursorListaPesoPrioridade;

		for(;;)
		{
			//Zera a estrutura de restorno
			memset( &stRegistro, 0, sizeof(stRegistro) );
			//Pega um registro no CURSOR
			EXEC SQL FETCH CursorListaPesoPrioridade INTO :stRegistro:stIndicator;
			//Adiciona a classe
			Add( (char*)stRegistro.stidCombo.arr
			    ,""
			    ,(char*)stRegistro.stdsCombo.arr
			   );
			//conta quantos existem
			iCont++;
		}
		//Fecha o cursor
		EXEC SQL CLOSE CursorListaPesoPrioridade;
		
        ULOG_END("CContatoCombos::ListaPesoPrioridade()");
        
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListaPesoPrioridade:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

