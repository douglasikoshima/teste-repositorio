#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/COU.h"
#include "../include/CPss.h"
#include "../include/CHUP.h"
#include "../include/CUnd.h"

COrganizacaoDepartamento::COrganizacaoDepartamento()
{
}

COrganizacaoDepartamento::~COrganizacaoDepartamento()
{
}

int COrganizacaoDepartamento::Insert( 
			char* cidDepartamento,
			char* cidOrganizacao,
			char* cidUsuarioAlteracao )
{
    ULOG_START("COrganizacaoDepartamento::Insert()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR cAuxidOrganizacaoDepartamento[21+1];
		VARCHAR cidOrganizacaoDepartamento[21+1];
		char* cAuxidDepartamento = cidDepartamento;
		char* cAuxidOrganizacao = cidOrganizacao;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraOrganizacaoDepartamento();
		
		memset( &cAuxidOrganizacaoDepartamento, 0, sizeof(cAuxidOrganizacaoDepartamento) ); 
		memset( &cidOrganizacaoDepartamento, 0, sizeof(cidOrganizacaoDepartamento) ); 
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
		sqlca.sqlcode = 0;

		EXEC SQL SELECT idOrganizacaoDepartamento INTO :cidOrganizacaoDepartamento FROM organograma.OrganizacaoDepartamento
		WHERE idDepartamento = :cAuxidDepartamento AND idOrganizacao = :cAuxidOrganizacao AND ROWNUM <= 1;
		
		if( cidOrganizacaoDepartamento.len <= 0 )
		{
			//Pega um id unico e sequencia para a insercao
			EXEC SQL SELECT organograma.OrganizacaoDepartamentoSQ.NEXTVAL INTO :cAuxidOrganizacaoDepartamento FROM DUAL;

			//Realiza o insert
			EXEC SQL INSERT INTO organograma.OrganizacaoDepartamento
			(	idOrganizacaoDepartamento,
				idDepartamento,
				idOrganizacao,
				idUsuarioAlteracao,
				dtUltimaAlteracao) 
			VALUES 
			(	:cAuxidOrganizacaoDepartamento,
				:cAuxidDepartamento,
				:cAuxidOrganizacao,
				:cAuxidUsuarioAlteracao,
				SYSDATE);
		}
		ULOG_END("COrganizacaoDepartamento::Insert()");
		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode) {
			return 0;//Erro
		}
		else {
			return 1;//Sucesso
		}
	}
	catch(...)
	{
		throw;
	}
	
GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int COrganizacaoDepartamento::Delete( char* cidOrganizacaoDepartamento )
{
    ULOG_START("COrganizacaoDepartamento::Delete()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;	
		char* cAuxidOrganizacaoDepartamento = cidOrganizacaoDepartamento; 
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraOrganizacaoDepartamento();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
		sqlca.sqlcode=0;
		
		//Executa a instrucao de delecao
		EXEC SQL DELETE FROM organograma.OrganizacaoDepartamento
		WHERE (idOrganizacaoDepartamento = :cAuxidOrganizacaoDepartamento);
		
		ULOG_END("COrganizacaoDepartamento::Delete()");
		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode) {
			return 0;//Erro
		}
		else {
			return 1;//Sucesso
		}
	}
	catch(...)
	{
		throw;
	}

GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int COrganizacaoDepartamento::List( 
			char* cidOrganizacaoDepartamento,
			char* cidDepartamento,
			char* cidOrganizacao,
			char* cidUsuarioAlteracao )
{
    ULOG_START("COrganizacaoDepartamento::List()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		
			char cAuxidOrganizacaoDepartamento[255+1];
			char cAuxidDepartamento[255+1];
			char cAuxidOrganizacao[255+1];
			char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
		struct
		{
			VARCHAR stidOrganizacaoDepartamento[21+1];
			VARCHAR stidDepartamento[21+1];
			VARCHAR stidOrganizacao[21+1];
		} stOrganizacaoDepartamentoRegistro;
		struct
		{
			short iidOrganizacaoDepartamento;
			short iidDepartamento;
			short iidOrganizacao;
		} stOrganizacaoDepartamentoIndicator;
	EXEC SQL END DECLARE SECTION;


	if ( strlennull( cidOrganizacaoDepartamento ) <= 0 )
		strcpy(cAuxidOrganizacaoDepartamento,"-1");
		else
		strcpy(cAuxidOrganizacaoDepartamento,cidOrganizacaoDepartamento);
	
	if ( strlennull( cidDepartamento ) <= 0 )
		strcpy(cAuxidDepartamento,"-1");
		else
		strcpy(cAuxidDepartamento,cidDepartamento);
	
	if ( strlennull( cidOrganizacao ) <= 0 )
		strcpy(cAuxidOrganizacao,"-1");
		else
		strcpy(cAuxidOrganizacao,cidOrganizacao);
	

	//Processamento Principal
	try
	{

		//Zera a estrutura da classe
		ZeraOrganizacaoDepartamento();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os Registros
   		EXEC SQL DECLARE CursorOrganizacaoDepartamento CURSOR FOR 
   		SELECT 	idOrganizacaoDepartamento,
	            idDepartamento,
	            idOrganizacao
		FROM organograma.OrganizacaoDepartamento
		WHERE ( ((idOrganizacaoDepartamento = :cAuxidOrganizacaoDepartamento) OR ('-1' = :cAuxidOrganizacaoDepartamento))
	      AND ((idDepartamento = :cAuxidDepartamento) OR ('-1' = :cAuxidDepartamento))
	      AND ((idOrganizacao = :cAuxidOrganizacao) OR ('-1' = :cAuxidOrganizacao)) );

		// Abre o cursor
		EXEC SQL OPEN CursorOrganizacaoDepartamento;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("COrganizacaoDepartamento::List()");
			return -1;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stOrganizacaoDepartamentoRegistro, 0, sizeof(stOrganizacaoDepartamentoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorOrganizacaoDepartamento INTO :stOrganizacaoDepartamentoRegistro:stOrganizacaoDepartamentoIndicator;
				//Adiciona a classe
				Add( 	(char*)stOrganizacaoDepartamentoRegistro.stidOrganizacaoDepartamento.arr,
				(char*)stOrganizacaoDepartamentoRegistro.stidDepartamento.arr,
				(char*)stOrganizacaoDepartamentoRegistro.stidOrganizacao.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorOrganizacaoDepartamento;
		}
		ULOG_END("COrganizacaoDepartamento::List()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int COrganizacaoDepartamento::RelacionaOrg( char*cidOrganizacao, char*cNomeIdTag, char*cidUsuarioAlteracao, DOMNode*dnode )
{
    ULOG_START("COrganizacaoDepartamento::RelacionaOrg()");
	//Auxiliares
	int iCont = 0;
	int iRet = 0;
	TuxHelper tuxHelper;
	
	//Consistencia
	if ( strlennull( cidOrganizacao ) <=0 )
	{
	    ULOG_END("COrganizacaoDepartamento::RelacionaOrg()");
		return -1;
	}
	
	CDepartamento oDepartamento;	
	CPessoa oPessoa;
	CHierarquiaDeptoPessoa oHierarquiaDeptoPessoa;

	//Gera lista dos departamentos relacionados a organizacao
	oDepartamento.RelacaoOU( cidOrganizacao );

	//Procurar dentre todos os departamentos relacionados a organizacao todos os idOrganizacaoDepartamento
	for( int y = 0; y < oDepartamento.Quantidade(); y++ ) {
		if (List( "", oDepartamento.Registro(y)->cidDepartamento, cidOrganizacao, cidUsuarioAlteracao )>0)
			if (oHierarquiaDeptoPessoa.List( "", "", "", Registro(0)->cidOrganizacaoDepartamento, cidUsuarioAlteracao )==0)
			{
				// Varrer no por no e apagar apenas os desrelacionados
				char cAux[22]; 
				strcpy(cAux,Registro(0)->cidOrganizacaoDepartamento);
				Delete(cAux);
			} else {
				// No caso de haver dependencia dos Relacionados em outra tabela
				iRet = -2292;
			}
	}

	//Adiciona as novas relacoes
	for(iCont = 0;;iCont++)
	{
		char* cidDepartamento = tuxHelper.walkTree(dnode,"idUnidade",iCont);

		if (strlennull(cidDepartamento)<=0)
			break;

		if (List( "", cidDepartamento, cidOrganizacao, cidUsuarioAlteracao )==0)
			Insert(  cidDepartamento, cidOrganizacao, cidUsuarioAlteracao );
		else
			if (oHierarquiaDeptoPessoa.List( "", Registro(0)->cidOrganizacaoDepartamento, "", "", cidUsuarioAlteracao )==0)
				Insert(  cidDepartamento, cidOrganizacao, cidUsuarioAlteracao );
	}
	
	ULOG_END("COrganizacaoDepartamento::RelacionaOrg()");
	return iRet;
}
int COrganizacaoDepartamento::EraseOrg( char* cidOrganizacao ) 
{
    ULOG_START("COrganizacaoDepartamento::EraseOrg()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;	
		char* cAuxidOrganizacao = cidOrganizacao; 
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraOrganizacaoDepartamento();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDeleteMM0;
		sqlca.sqlcode=0;
		
		//Executa a instrucao de delecao
		EXEC SQL DELETE FROM organograma.OrganizacaoDepartamento
		WHERE (idOrganizacao = :cAuxidOrganizacao);
		
		ULOG_END("COrganizacaoDepartamento::EraseOrg()");
		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode) {
			return 0;//Erro
		}
		else {
			return 1;//Sucesso
		}
	}
	catch(...)
	{
		throw;
	}

GotoDeleteMM0:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if(sqlca.sqlcode == -2292 )
		return -2292;
	else
		throw TuxBasicOraException(sqlca.sqlcode);
}

int COrganizacaoDepartamento::RelacionaUnd( char*cidDepartamento, char*cNomeIdTag, char*cidUsuarioAlteracao, DOMNode*dnode )
{
    ULOG_START("COrganizacaoDepartamento::RelacionaUnd()");
	//Auxiliares
	int iCont;
	TuxHelper tuxHelper;
	
	//Consistencia
	if ( strlennull( cidDepartamento ) <=0 )
	{
	    ULOG_END("COrganizacaoDepartamento::RelacionaUnd()");
		return -1;
	}
	
	//Apaga todas as relacionadas ao id recebido
	int iRet = EraseUnd( cidDepartamento );
	
	// No caso de haver dependencia dos Relacionados em outra tabela, consultar metodo Existem
	// Varrer no por no e apagar apenas os desrelacionados
	//Adiciona as novas relacoes
	if (iRet!=-2292)
	for(iCont = 0;;iCont++)
	{		
		char* cidDepartamento = tuxHelper.walkTree(dnode,"idUnidade",iCont);
		char* cidOrganizacao = tuxHelper.walkTree(dnode,"idOrganizacao",iCont);

		if ((strlennull(cidDepartamento)<=0)||(strlennull(cidOrganizacao)<=0))
			break;

		Insert(  cidDepartamento, cidOrganizacao, cidUsuarioAlteracao );
	}
	ULOG_END("COrganizacaoDepartamento::RelacionaUnd()");
	return iRet;
}
int COrganizacaoDepartamento::EraseUnd( char* cidDepartamento ) 
{
    ULOG_START("COrganizacaoDepartamento::EraseUnd()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;	
		char* cAuxidDepartamento = cidDepartamento; 
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraOrganizacaoDepartamento();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDeleteMM1;
		sqlca.sqlcode=0;
		
		//Executa a instrucao de delecao
		EXEC SQL DELETE FROM organograma.OrganizacaoDepartamento
		WHERE (idDepartamento = :cAuxidDepartamento);
		
		ULOG_END("COrganizacaoDepartamento::EraseUnd()");
		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode) {
			return 0;//Erro
		}
		else {
			return 1;//Sucesso
		}
	}
	catch(...)
	{
		throw;
	}

GotoDeleteMM1:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if(sqlca.sqlcode == -2292)
		return -2292;
	else
		throw TuxBasicOraException(sqlca.sqlcode);
}

int COrganizacaoDepartamento::ListId( char* cidOrganizacaoDepartamento ) 
{
    ULOG_START("COrganizacaoDepartamento::ListId()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidOrganizacaoDepartamento = cidOrganizacaoDepartamento; 
		struct
		{
			VARCHAR stidOrganizacaoDepartamento[21+1];
			VARCHAR stidDepartamento[21+1];
			VARCHAR stidOrganizacao[21+1];
		} stOrganizacaoDepartamentoRegistro;
		struct
		{
			short iidOrganizacaoDepartamento;
			short iidDepartamento;
			short iidOrganizacao;
		} stOrganizacaoDepartamentoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraOrganizacaoDepartamento();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL DECLARE CursorOrganizacaoDepartamentoId CURSOR FOR 
   		SELECT 	idOrganizacaoDepartamento,
	            idDepartamento,
	            idOrganizacao
		FROM organograma.OrganizacaoDepartamento
		WHERE idOrganizacaoDepartamento = :cAuxidOrganizacaoDepartamento;

		//Abre o cursor
		EXEC SQL OPEN CursorOrganizacaoDepartamentoId;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
     	    ULOG_END("COrganizacaoDepartamento::ListId()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stOrganizacaoDepartamentoRegistro, 0, sizeof(stOrganizacaoDepartamentoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorOrganizacaoDepartamentoId INTO :stOrganizacaoDepartamentoRegistro:stOrganizacaoDepartamentoIndicator;
				//Adiciona a classe
				Add( 	(char*)stOrganizacaoDepartamentoRegistro.stidOrganizacaoDepartamento.arr,
				(char*)stOrganizacaoDepartamentoRegistro.stidDepartamento.arr,
				(char*)stOrganizacaoDepartamentoRegistro.stidOrganizacao.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorOrganizacaoDepartamentoId;
		}
		ULOG_END("COrganizacaoDepartamento::ListId()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int COrganizacaoDepartamento::ListAll( void )
{
    ULOG_START("COrganizacaoDepartamento::ListAll()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidOrganizacaoDepartamento[21+1];
			VARCHAR stidDepartamento[21+1];
			VARCHAR stidOrganizacao[21+1];
		} stOrganizacaoDepartamentoRegistro;
		struct
		{
			short iidOrganizacaoDepartamento;
			short iidDepartamento;
			short iidOrganizacao;
		} stOrganizacaoDepartamentoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraOrganizacaoDepartamento();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL DECLARE CursorOrganizacaoDepartamentoAll CURSOR FOR
   		SELECT 	idOrganizacaoDepartamento,
		idDepartamento,
		idOrganizacao
		FROM organograma.OrganizacaoDepartamento; 

		//Abre o cursor
		EXEC SQL OPEN CursorOrganizacaoDepartamentoAll;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("COrganizacaoDepartamento::ListAll()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stOrganizacaoDepartamentoRegistro, 0, sizeof(stOrganizacaoDepartamentoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorOrganizacaoDepartamentoAll INTO :stOrganizacaoDepartamentoRegistro:stOrganizacaoDepartamentoIndicator;
				//Adiciona a classe
				Add( 	(char*)stOrganizacaoDepartamentoRegistro.stidOrganizacaoDepartamento.arr,
				(char*)stOrganizacaoDepartamentoRegistro.stidDepartamento.arr,
				(char*)stOrganizacaoDepartamentoRegistro.stidOrganizacao.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorOrganizacaoDepartamentoAll;
		}
		ULOG_END("COrganizacaoDepartamento::ListAll()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

void COrganizacaoDepartamento::GetXml( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
				xml->createTag(cNomeTag);
			//Adiciona a propriedade necessaria para o xml
			xml->addProp( "xmlns", "usuario.fo.vivo.com.br/vo" );
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idOrganizacaoUnidade", Registro(x)->cidOrganizacaoDepartamento );
				xml->addItem("idUnidade", Registro(x)->cidDepartamento );
				xml->addItem("idOrganizacao", Registro(x)->cidOrganizacao ); 
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}

void COrganizacaoDepartamento::GetXml( char* cNomeTagArray, char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() >= 0 )
	{
		//Caso nao tenha recebido uma tag padrao, deixa sem
		if( strlennull( cNomeTagArray ) > 0 ) {
			xml->createTag(cNomeTagArray);
			//Adiciona a propriedade necessaria para o xml
			xml->addProp( "xmlns", "usuario.fo.vivo.com.br/vo" );
		}
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 ) {
				xml->createTag(cNomeTag);
				//Adiciona a propriedade necessaria para o xml
				xml->addProp( "xmlns", "usuario.fo.vivo.com.br/vo" );
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idOrganizacaoUnidade", Registro(x)->cidOrganizacaoDepartamento );
				xml->addItem("idUnidade", Registro(x)->cidDepartamento );
				xml->addItem("idOrganizacao", Registro(x)->cidOrganizacao ); 
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
		//So fecha um tag se abriu anteriormente
		if( strlennull( cNomeTagArray ) > 0 )
			xml->closeTag();
	}
}
