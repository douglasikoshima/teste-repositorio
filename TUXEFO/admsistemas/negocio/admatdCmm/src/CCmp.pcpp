#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CCmp.h"
#include "../include/CSafePointer.h"

#include<list>
#include<iterator>

using namespace std;

#define CONVIND(O,I) \
{\
	if (I == -1) { \
		##O.arr[0]=0; \
	} else { \
		##O.arr[##O.len]=0; \
	} \
}

#define endOraStr(varstr)      varstr.arr[varstr.len]= 0x0;
#define oraToStr(bstr,vchar)   if(!bstr) strncpy(bstr,vchar.arr,vchar.len)
#define strToOra(vchar,bstr)   vchar.len = strlen(bstr);strncpy((char *)vchar.arr,bstr,vchar.len);vchar.arr[vchar.len] = 0

typedef list<unsigned long> ListaCampos;
list<unsigned long>::iterator itCampos;
list<unsigned long>::iterator itCamposAux;
list<unsigned long>::iterator itUF;
list<unsigned long>::iterator itTipoLinha;
list<unsigned long>::iterator itGrupo;

ListaCampos L;

class TuxHelperImpl:public TuxHelper
{
    public:
        DOMNode * walkDOMImpl( DOMNode*a , char*b , int*c , int d )
        {
                return walkDOM( a , b , c , d );
        }
};

CCampo::CCampo()
{
}

CCampo::CCampo( DOMNode* dnode,LISTA_UF * pUF_Prm,LISTA_TPLINHA * pTpLinha_Prm )
{
	CSafePointer oSafePointer;
	idClassificadorPrm = strtoul((char *)oSafePointer.getTag(dnode,"idClassificadorCampoAtual",0),0,10);
	idContatoPrm = strtoul((char *)oSafePointer.getTag(dnode, "idContato",0),0,10);
	idFaseProcessoPrm = strtoul((char *)oSafePointer.getTag(dnode,"idFaseProcessoAtual",0),0,10);

	pUF = pUF_Prm;
	pTpLinha = pTpLinha_Prm;
}

CCampo::CCampo( DOMNode* dnode,LISTA_UF * pUF_Prm,LISTA_TPLINHA * pTpLinha_Prm,ListCampos * pCamposPrm,ListGrupos * pGruposPrm )
{
	CSafePointer oSafePointer;
	idClassificadorPrm = strtoul((char *)oSafePointer.getTag(dnode,"idClassificadorCampoAtual",0),0,10);
	idContatoPrm = strtoul((char *)oSafePointer.getTag(dnode, "idContato",0),0,10);
	idFaseProcessoPrm = strtoul((char *)oSafePointer.getTag(dnode,"idFaseProcessoAtual",0),0,10);

	pUF = pUF_Prm;
	pTpLinha = pTpLinha_Prm;
	pCampos = pCamposPrm;
	pGrupos = pGruposPrm;
}  



CCampo::CCampo( DOMNode* dnode )
{
    TuxHelper     tx;
    TuxHelperImpl tuxhelperIMPL;
    DOMNode * pDOMAux;
	CSafePointer oSafePointer;
	char strValor[4096]; 
	char * result = 0x0;
	char * p = 0x0;
	char delims[] = "|";
	unsigned long idCampo;
	int it,i;

	idContatoFolhaCampoPrm = strtoul((char *)oSafePointer.getTag( dnode, "idContatoFolhaCampo", 0 ),0,10);
	idGrupoCampoPrm = strtoul((char *)oSafePointer.getTag( dnode, "idGrupoCampos", 0 ),0,10);
	strcpy( nmGrupoCampoPrm,(char *)oSafePointer.getTag(dnode,"nmGrupoCampos",0) );

	idContatoPrm = strtoul((char *)oSafePointer.getTag( dnode, "idContato", 0 ),0,10);

	idClassificadorPrm = strtoul((char *)oSafePointer.getTag( dnode, "idClassificadorCampoAtual", 0 ),0,10);

	/*----- Inserir Campos -----*/
    it = 0;
    pDOMAux = tuxhelperIMPL.walkDOMImpl( dnode,"AdmCampoVO",&it,0 );
    if ( pDOMAux != 0x0 )
    {    
        strValor[0] = 0x0;
        if ( p = tx.walkTree( pDOMAux, "IdsInclusao", 0 ),p ) 
        {
            strcpy(strValor,p);
            XMLString::release(&p);
        }
	}
	result = strtok(strValor,delims);
	while( result != 0x0 ) 
	{
		idCampo = strtoul(result,0,10);
		if (!idCampo) break;
		pCamposDinamicos.push_back(idCampo);
		result = strtok( NULL, delims );
	}            
   	/*--------------------------------------------------------------------*/
   	
   	
   	
	/*----- Excluir Campos -----*/
    it = 0;
    pDOMAux = tuxhelperIMPL.walkDOMImpl( dnode,"AdmCampoVO",&it,0 );
    if ( pDOMAux != 0x0 )
    {    
        strValor[0] = 0x0;
        if ( p = tx.walkTree( pDOMAux, "IdsExclusao", 0 ),p ) 
        {
            strcpy(strValor,p);
            XMLString::release(&p);
        }
	}
	result = strtok(strValor,delims);
	while( result != 0x0 ) 
	{
		idCampo = strtoul(result,0,10);
		if (!idCampo) break;
		pCamposExcluir.push_back(idCampo);
		result = strtok( NULL, delims );
	}            
   	/*--------------------------------------------------------------------*/

    /*
	for(int i=0;;i++ )
	{
		idCampo = strtoul((char *)oSafePointer.getTag(dnode,"idCampo",i),0,10);
		if (!idCampo) break;
		pCamposDinamicos.push_back(idCampo);
	}
    */
	
}



CCampo::~CCampo()
{
}



int CCampo::GravaAgrupamento( XMLGen * xml )
{
    ULOG_START("CCampo::GravaAgrupamento()");

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	   unsigned long idGrupo = idGrupoCampoPrm;
	   unsigned long idUsuario = idUsuarioPrm;
	   unsigned long idCampo;
	   VARCHAR nmGrupo[256];
	   VARCHAR nmLogin[256];
	   short i_nmLogin = -1;
	EXEC SQL END DECLARE SECTION;

    strToOra(nmGrupo,nmGrupoCampoPrm);
	try
	{
		EXEC SQL WHENEVER SQLERROR GOTO GotoGravaAgrupamento;

        EXEC SQL
        SELECT NMLOGINUSUARIO INTO :nmLogin:i_nmLogin FROM ACESSO.USUARIO WHERE IDPESSOAUSUARIO = :idUsuario;

        ULOG( "idUsuario [%lu]",idUsuario );

        CONVIND( nmLogin,i_nmLogin );

        ULOG( "nmLogin [%s]",(char*)nmLogin.arr );

		ULOG( "Grupo [%d]",idGrupo );
		if ( !idGrupo )
		{
			EXEC SQL
			SELECT CONTATOADM.SUBFORMULARIOSQ.NextVal INTO :idGrupo FROM DUAL;

    		ULOG( "Obteve Grupo [%d]",idGrupo );

			EXEC SQL
			INSERT INTO CONTATOADM.SUBFORMULARIO
			(
			   IDSUBFORMULARIO ,
			   NMSUBFORMULARIO ,
			   IDTIPOSUBFORMULARIO
			)
			VALUES
			(
			   :idGrupo ,
			   :nmGrupo ,
			   	1
			);

		}
		else
		{
			ULOG( "Removendo LOG do grupo [%lu]",idGrupo );

		/*
			EXEC SQL
			    DELETE FROM CONTATOADM.SUBFORMULARIOCAMPOLOG WHERE IDSUBFORMULARIO = :idGrupo;
			EXEC SQL
				DELETE FROM CONTATOADM.SUBFORMULARIOCAMPO WHERE IDSUBFORMULARIO = :idGrupo;
	    */

			for (it = pCamposExcluir.begin(); it != pCamposExcluir.end(); it++)
			{
				idCampo = *it;
				ULOG( "Removendo de SubFormularioCampo o Campo [%lu]",idCampo);
				//EXEC SQL
				    //DELETE FROM CONTATOADM.SUBFORMULARIOCAMPOLOG WHERE IDCAMPO = :idCampo;

				EXEC SQL
					DELETE FROM CONTATOADM.SUBFORMULARIOCAMPO WHERE IDCAMPO = :idCampo AND IDSUBFORMULARIO = :idGrupo;
						
                ULOG( "Inserindo campos a excluir..." );
                
				EXEC SQL
				    INSERT INTO CONTATOADM.PROCESSASUBFORMULARIO 
				    (
				       IDPROCESSASUBFORMULARIO ,
				       IDSUBFORMULARIO ,
				       IDCAMPO ,
				       TPOPERACAO ,
				       INPROCESSAMENTO
				    ) 
				    VALUES 
				    (
				       CONTATOADM.PROCESSASUBFORMULARIOSQ.NextVal ,
				       :idGrupo ,
				       :idCampo ,
				       3 ,
				       0
				    );

			}	    
		}


		for (it = pCamposDinamicos.begin(); it != pCamposDinamicos.end(); it++)
		{
			idCampo = *it;
			
            ULOG( "Grupo [%d], Campo [%d]",idGrupo,idCampo);

			EXEC SQL
			    INSERT
                INTO CONTATOADM.SUBFORMULARIOCAMPO(IDSUBFORMULARIO,IDCAMPO)
                VALUES (:idGrupo,:idCampo);

            ULOG( "Inserindo LOG em CONTATOADM.SUBFORMULARIOCAMPOLOG ..." );

			EXEC SQL
			    INSERT INTO CONTATOADM.SUBFORMULARIOCAMPOLOG
			    (
					IDSUBFORMULARIOCAMPOLOG ,
					NMLOGINUSUARIO ,
					DTULTIMAALTERACAO ,
					IDSUBFORMULARIO
			    )
			    VALUES
			    (
			        CONTATOADM.SUBFORMULARIOCAMPOLOGSQ.NEXTVAL ,
			        :nmLogin ,
			        SYSDATE ,
			        :idGrupo
			    );
               
                	
                ULOG( "Inserindo campos a incluir em CONTATOADM.PROCESSASUBFORMULARIO..." );
				EXEC SQL
				    INSERT INTO CONTATOADM.PROCESSASUBFORMULARIO 
				    (
				       IDPROCESSASUBFORMULARIO ,
				       IDSUBFORMULARIO ,
				       IDCAMPO ,
				       TPOPERACAO ,
				       INPROCESSAMENTO
				    ) 
				    VALUES 
				    (
				       CONTATOADM.PROCESSASUBFORMULARIOSQ.NEXTVAL ,
				       :idGrupo ,
				       :idCampo ,
				       1 ,
				       0
				    );

		}

		ULOG_END("CCampo::GravaAgrupamento");

		return 0;
	}
	catch(...)
	{
		throw;
	}

GotoGravaAgrupamento:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	ULOG_END("CCampo::GravaAgrupamento()");
	throw TuxBasicOraException(sqlca.sqlcode);

}



int CCampo::AtualizaCampos( XMLGen * xml )
{
    ULOG_START( "CCampo::AtualizaCampos()" );

	struct sqlca sqlca;
	string consulta;
	char buffer[256];
	char MsgErro[256];

	EXEC SQL BEGIN DECLARE SECTION;

	   unsigned long idContato = idContatoPrm;
	   unsigned long idFase = idFaseProcessoPrm;
	   unsigned long idCampo;
	   unsigned long idUF;
	   unsigned long idTipoLinha;
	   unsigned long idUsuario = idUsuarioPrm;
	   unsigned long idGrupo;
	   unsigned long idContatoFolhaCampo;
	   int ctCampo;
	   char * query;

	   VARCHAR nmLogin[256];
	   short i_nmLogin = -1;

	   VARCHAR nmCampo[2001];
	   short i_nmCampo = -1;

	EXEC SQL END DECLARE SECTION;
    bool flgDelete = false;

	try
	{
		EXEC SQL WHENEVER SQLERROR GOTO GotoAtualizaCampos;

		consulta =	"DELETE FROM "
					"   CONTATOADM.CONTATOFOLHACAMPO "
					"WHERE "
					"   IDCONTATO = ";

			sprintf(buffer,"%lu",idContatoPrm);
			consulta += buffer;

			consulta += " AND idFaseProcesso = ";
			sprintf(buffer,"%lu",idFaseProcessoPrm);
			consulta += buffer;


	    query = (char *)consulta.c_str();

        EXEC SQL
        SELECT NMLOGINUSUARIO INTO :nmLogin:i_nmLogin FROM ACESSO.USUARIO WHERE IDPESSOAUSUARIO = :idUsuario;
        CONVIND( nmLogin,i_nmLogin );
        
        if ( !pGrupos->empty() )
        {
        	ULOG( "Existe grupo a ser salvo..." );

			for ( itGrupo=pGrupos->begin();itGrupo!=pGrupos->end();itGrupo++ )
			{
				idGrupo = *itGrupo;
				L.clear();
				CarregaCampos( idGrupo,&L );

				for ( itUF=pUF->begin();itUF!=pUF->end();itUF++ )
				{
					idUF = *itUF;
				 	ULOG( "Inserindo idUF [%lu]",idUF );
					for ( itTipoLinha=pTpLinha->begin();itTipoLinha!=pTpLinha->end();itTipoLinha++ )
					{
					     idTipoLinha = *itTipoLinha;
					 	ULOG( "Inserindo idTipoLinha [%lu]",idTipoLinha );

						 	ULOG( "Inserindo idGrupo [%lu]",idGrupo );

							 for ( itCampos=L.begin();itCampos!=L.end();itCampos++ )
							 {
							 	idCampo = *itCampos;
							 	if ( !idCampo ) break;

								 for ( itCamposAux=pCampos->begin();itCamposAux!=pCampos->end();itCamposAux++ )
								 {
								 	ULOG("idCampo [%lu] - itCamposAux [%lu]",idCampo,*itCamposAux );
								 	if ( idCampo == *itCamposAux )
								 	{
										EXEC SQL
										SELECT NMCAMPO INTO :nmCampo:i_nmCampo FROM CONTATOADM.CAMPO WHERE IDCAMPO = :idCampo;
								        CONVIND( nmCampo,i_nmCampo );
										consulta = (char*)nmCampo.arr;
										trim2(consulta);
								 		ULOG( "Campos iguais, nao deverah inserir..." );
								 		sprintf(MsgErro,"O campo %s faz parte do(s) grupo(s) já selecionado(s), e o sistema não permite a inclusão do mesmo campo mais de uma vez, favor remover o(s) Grupo(s) ou o campo em questão",(char*)consulta.c_str() );
										xml->addItem("msgRetorno",MsgErro );
										return 0;
								 	}
								 }

								if ( flgDelete == false )
								{
									ULOG( "Query [%s]",query );
									EXEC SQL PREPARE Remove FROM :query;
									EXEC SQL EXECUTE Remove;
									flgDelete = true;
								}

								EXEC SQL
								SELECT
								   COUNT(1)
								INTO
								   :ctCampo
								FROM
								   CONTATOADM.CONTATOFOLHACAMPO
								WHERE 
								   IDCONTATO = :idContato
								AND 
								   IDUFOPERADORA = :idUF
								AND 
								   IDTIPOLINHA = :idTipoLinha
								AND 
								   IDFASEPROCESSO = :idFase
								AND 
								   IDCAMPO = :idCampo;

							 	if ( ctCampo > 0 )
							 	{
									EXEC SQL
									SELECT NMCAMPO INTO :nmCampo:i_nmCampo FROM CONTATOADM.CAMPO WHERE IDCAMPO = :idCampo;
							        CONVIND( nmCampo,i_nmCampo );
									consulta = (char*)nmCampo.arr;
									trim2(consulta);
							 		ULOG( "Campos iguais, nao deverah inserir..." );
							 		sprintf(MsgErro,"O campo %s faz parte do(s) grupo(s) já selecionado(s), e o sistema não permite a inclusão do mesmo campo mais de uma vez, favor remover o(s) Grupo(s) ou o campo em questão",(char*)consulta.c_str() );
									xml->addItem("msgRetorno",MsgErro );
									return 0;
							 	}
								   	
                                /*
								if ( VerificaCampos(idContato,idUF,idTipoLinha,idCampo,MsgErro) )
								{
									throw MsgErro;
				                }
                                */
								ULOG( "Inserindo idCampo [%lu] - idGrupo [%lu] idUsuario [%lu] idTipoLinha [%lu]",idCampo,idGrupo,idUsuario,idTipoLinha );
								ULOG( "Inserindo CONTATOFOLHACAMPOAK1 idContato [%lu] idUF [%lu] idTipoLinha [%lu] idCampo [%lu]",idContato,idUF,idTipoLinha,idCampo );

								EXEC SQL
								SELECT CONTATOADM.CONTATOFOLHACAMPOSQ.NextVal INTO :idContatoFolhaCampo FROM DUAL;

								EXEC SQL
								DELETE FROM CONTATOADM.CONTATOFOLHACAMPO
								WHERE IDCONTATO = :idContato
								AND IDUFOPERADORA = :idUF
								AND IDTIPOLINHA = :idTipoLinha
								AND IDFASEPROCESSO = :idFase
								AND IDCAMPO = :idCampo;

								EXEC SQL
								    INSERT INTO CONTATOADM.CONTATOFOLHACAMPO
								    (
								       IDCONTATOFOLHACAMPO ,
								       IDCONTATO ,
								       IDUFOPERADORA ,
								       IDTIPOLINHA ,
								       IDCAMPO ,
								       SQORDEMAPRESENTACAO ,
								       IDFASEPROCESSO ,
								       IDUSUARIOALTERACAO ,
								       DTULTIMAALTERACAO ,
								       IDSUBFORMULARIO
								    )
								    VALUES
								    (
								       :idContatoFolhaCampo ,
								       :idContato ,
								       :idUF ,
								       :idTipoLinha ,
								       :idCampo ,
								       0 ,
								       :idFase ,
								       :idUsuario ,
								       SYSDATE ,
								       :idGrupo
								    );

							 }
					}
				}
			}  // fim loop grupos

		}
        if ( !pCampos->empty() )
		{
        	ULOG( "Campo a ser salvo..." );

            bool Next = false;
			for ( itUF=pUF->begin();itUF!=pUF->end();itUF++ )
			{
				idUF = *itUF;
				if ( !idUF ) break;
				ULOG( "Inserindo idUFOperadora [%lu]",idUF );
				for ( itTipoLinha=pTpLinha->begin();itTipoLinha!=pTpLinha->end();itTipoLinha++ )
				{
				     idTipoLinha = *itTipoLinha;
				     if ( !idTipoLinha ) break;
	 				 ULOG( "Inserindo idTipoLinha [%lu]",idTipoLinha );
	 				 Next = false;
 					 for ( itCampos=pCampos->begin();itCampos!=pCampos->end();itCampos++ )
					 {
	 				 	 idCampo = *itCampos;
	 				 	 ULOG( "Lendo idCampo [%lu]",idCampo );
                         /*
    					 for ( itCamposAux=L.begin();itCamposAux!=L.end();itCamposAux++ )
						 {
						 	ULOG("idCampo [%lu] - itCamposAux [%lu]",idCampo,*itCamposAux );
						 	if ( idCampo == *itCamposAux )
						 	{
						 		ULOG( "Campos iguais, nao deverah inserir..." );
						 		Next = true;
						 		break;
						 	}
						 }
						 if ( Next == true )
						 {
						 	Next = false;
					 		ULOG( "Buscando proximo campo..." );
						 	continue;
						 }
                        */
					 	if ( !idCampo ) break;

	 				    ULOG( "Inserindo idCampo [%lu]",idCampo );

                  /*
                  if ( flgDelete == false )
                  {
                     ULOG( "Query [%s]",query );
                     EXEC SQL PREPARE Remove FROM :query;
                     EXEC SQL EXECUTE Remove;
                     flgDelete = true;
                  }
                  */

					    EXEC SQL
					        SELECT CONTATOADM.CONTATOFOLHACAMPOSQ.NextVal INTO :idContatoFolhaCampo FROM DUAL;

                    ULOG( "Campo - idContatoFolhaCampo [%lu] idCampo [%lu] idTipoLinha [%lu]",idContatoFolhaCampo,idCampo,idTipoLinha );

						EXEC SQL
						DELETE FROM CONTATOADM.CONTATOFOLHACAMPO
						WHERE IDCONTATO = :idContato
						AND IDUFOPERADORA = :idUF
						AND IDTIPOLINHA = :idTipoLinha
						AND IDFASEPROCESSO = :idFase
						AND IDCAMPO = :idCampo;
							
						EXEC SQL
						    INSERT INTO CONTATOADM.CONTATOFOLHACAMPO
						    (
						       IDCONTATOFOLHACAMPO ,
						       IDCONTATO ,
						       IDUFOPERADORA ,
						       IDTIPOLINHA ,
						       IDCAMPO ,
						       SQORDEMAPRESENTACAO ,
						       IDFASEPROCESSO ,
						       IDUSUARIOALTERACAO ,
						       DTULTIMAALTERACAO
						    )
						    VALUES
						    (
						       :idContatoFolhaCampo ,
						       :idContato ,
						       :idUF ,
						       :idTipoLinha ,
						       :idCampo ,
						       0 ,
						       :idFase ,
						       :idUsuario ,
						       SYSDATE
						    );

					 }  // end for ( itCampos=pCampos->begin();itCampos!=pCampos->end();itCampos++ )
				}
			}
		}

        /*
		if ( flgDelete == false )
		{
			ULOG( "Nao existem campos ou grupos associados, removendo contatofolhacampo para esta fase..." );
			ULOG( "Query [%s]",query );
			EXEC SQL PREPARE Remove FROM :query;
			EXEC SQL EXECUTE Remove;
			flgDelete = true;
		}
        */

		ULOG_END( "CCampo::AtualizaCampos()" );

		return 0;
	}
    catch ( char  * MsgErro )
    {
    	throw MsgErro;
    }
	catch(...)
	{
		throw;
	}

GotoAtualizaCampos:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	ULOG_END( "CCampo::AtualizaCampos()" );
	throw TuxBasicOraException(sqlca.sqlcode);

}


int CCampo::CarregaCampos( unsigned long idGrupoPrm,ListCampos *L )
{
    ULOG_START( "CCampo::CarregaCampos()" );
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	   unsigned long idGrupo = idGrupoPrm;
	   unsigned long idCampo;
	EXEC SQL END DECLARE SECTION;

    ULOG( "Pesquisando idGrupo [%lu]",idGrupo );

	try
	{
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoCarregaCampos;

   		EXEC SQL DECLARE CursorCampos CURSOR FOR
			SELECT
			   idCampo
			FROM
			   ContatoAdm.SUBFORMULARIOCAMPO
			WHERE
			   IDSUBFORMULARIO = :idGrupo;

		EXEC SQL OPEN CursorCampos;

		for(;;)
		{
			EXEC SQL FETCH CursorCampos INTO :idCampo;
			L->push_back( idCampo );
		}

		EXEC SQL CLOSE CursorCampos;
		ULOG_END( "CCampo::CarregaCampos()" );
		return 0;
	}
	catch(...)
	{
		throw;
	}

GotoCarregaCampos:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	ULOG_END( "CCampo::CarregaCampos()" );
	throw TuxBasicOraException(sqlca.sqlcode);

}



int CCampo::ListId( char* cidCampo )
{
    ULOG_START("CCampo::ListId()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidCampo = cidCampo;
		struct
		{
			VARCHAR stidCampo[21+1];
			VARCHAR stnmCampo[2000+1];
			VARCHAR stidTipoDadoCampo[21+1];
			VARCHAR stidMascaraApresentacaoCampo[21+1];
			VARCHAR stidLayoutApresentacaoCampo[21+1];
			VARCHAR stnrTamanho[21+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stidClassificadorCampo[21+1];
			VARCHAR stinFiltro[21+1];
		} stCampoRegistro;
		struct
		{
			short iidCampo;
			short inmCampo;
			short iidTipoDadoCampo;
			short iidMascaraApresentacaoCampo;
			short iidLayoutApresentacaoCampo;
			short inrTamanho;
			short iinDisponibilidade;
			short iidClassificadorCampo;
			short iinFiltro;
		} stCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL
   			DECLARE
   				CursorCampoId CURSOR FOR
			SELECT
				IDCAMPO,
				NMCAMPO,
				IDTIPODADOCAMPO,
				IDMASCARAAPRESENTACAOCAMPO,
				IDLAYOUTAPRESENTACAOCAMPO,
				NRTAMANHO,
				INDISPONIBILIDADE,
				IDCLASSIFICADORCAMPO,
				INFILTRO
			FROM
				CONTATOADM.CAMPO
			WHERE
				IDCAMPO = :cAuxidCampo;

		//Abre o cursor
		EXEC SQL OPEN CursorCampoId;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stCampoRegistro, 0, sizeof(stCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorCampoId INTO :stCampoRegistro:stCampoIndicator;
				//Adiciona a classe
				Add((char*)stCampoRegistro.stidCampo.arr,
					(char*)stCampoRegistro.stnmCampo.arr,
					(char*)stCampoRegistro.stidTipoDadoCampo.arr,
					(char*)stCampoRegistro.stidMascaraApresentacaoCampo.arr,
					(char*)stCampoRegistro.stidLayoutApresentacaoCampo.arr,
					(char*)stCampoRegistro.stnrTamanho.arr,
					(char*)stCampoRegistro.stinDisponibilidade.arr,
					(char*)stCampoRegistro.stidClassificadorCampo.arr,
					"",
					(char*)stCampoRegistro.stinFiltro.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorCampoId;
		}

		ULOG_END("CCampo::ListId()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}
int CCampo::ListPar(char* cidCampo)
{
	return ListPar(	cidCampo
					,NULL
					,NULL
					,NULL
					,NULL
					,NULL
					,NULL
					,NULL
					,NULL
					,NULL
					,NULL);
}
int CCampo::ListPar(
					 char* cidCampo
					,char* cnmCampo
					,char* cidTipoDadoCampo
					,char* cidMascaraApresentacaoCampo
					,char* cidLayoutApresentacaoCampo
					,char* cnrTamanho
					,char* cinDisponibilidade
					,char* cidClassificadorCampo
					,char* cinFiltro
					,char* cinPesquisa
					,char* cinObrigatorio
					)
{
    ULOG_START("CCampo::ListPar()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
			char* cAuxidCampo = cidCampo;
			char* cAuxnmCampo = cnmCampo;
			char* cAuxidTipoDadoCampo = cidTipoDadoCampo;
			char* cAuxidMascaraApresentacaoCampo = cidMascaraApresentacaoCampo;
			char* cAuxidLayoutApresentacaoCampo = cidLayoutApresentacaoCampo;
			char* cAuxnrTamanho = cnrTamanho;
			char* cAuxinDisponibilidade = cinDisponibilidade;
			char* cAuxidClassificadorCampo = cidClassificadorCampo;
			char* cAuxinFiltro = cinFiltro;
			char* cAuxinPesquisa = cinPesquisa;
			char* cAuxinObrigatorio = cinObrigatorio;
		struct
		{
			VARCHAR stidCampo[21+1];
			VARCHAR stnmCampo[2000+1];
			VARCHAR stidTipoDadoCampo[21+1];
			VARCHAR stsgTipoDadoCampo[255+1];
			VARCHAR stnmTipoDadoCampo[255+1];
			VARCHAR stinDominio[255+1];
			VARCHAR stidMascaraApresentacaoCampo[21+1];
			VARCHAR stnmMascaraApresentacaoCampo[255+1];
			VARCHAR stsgMascaraApresentacaoCampo[255+1];
			VARCHAR stidLayoutApresentacaoCampo[21+1];
			VARCHAR stnmLayoutApresentacaoCampo[255+1];
			VARCHAR stsgLayoutApresentacaoCampo[255+1];
			VARCHAR stnrTamanho[21+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stidClassificadorCampo[21+1];
			VARCHAR stnmClassificadorCampo[255+1];
			VARCHAR stinFiltro[21+1];
			VARCHAR stinPesquisa[21+1];
			VARCHAR stinObrigatorio[21+1];
			VARCHAR sttemDominio[21+1];
		} stCampoRegistro;
		struct
		{
			short iidCampo;
			short inmCampo;
			short iidTipoDadoCampo;
			short isgTipoDadoCampo;
			short inmTipoDadoCampo;
			short iinDominio;
			short iidMascaraApresentacaoCampo;
			short inmMascaraApresentacaoCampo;
			short isgMascaraApresentacaoCampo;
			short iidLayoutApresentacaoCampo;
			short inmLayoutApresentacaoCampo;
			short isgLayoutApresentacaoCampo;
			short inrTamanho;
			short iinDisponibilidade;
			short iidClassificadorCampo;
			short inmClassificadorCampo;
			short iinFiltro;
			short iinPesquisa;
			short iinObrigatorio;
			short iitemDominio;
		} stCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	cAuxidCampo = (cAuxidCampo==NULL)?"-1":cAuxidCampo;
	cAuxnmCampo = (cAuxnmCampo==NULL)?"-1":cAuxnmCampo;
	cAuxidTipoDadoCampo = (cAuxidTipoDadoCampo==NULL)?"-1":cAuxidTipoDadoCampo;
	cAuxidMascaraApresentacaoCampo = (cAuxidMascaraApresentacaoCampo==NULL)?"-1":cAuxidMascaraApresentacaoCampo;
	cAuxidLayoutApresentacaoCampo = (cAuxidLayoutApresentacaoCampo==NULL)?"-1":cAuxidLayoutApresentacaoCampo;
	cAuxnrTamanho = (cAuxnrTamanho==NULL)?"-1":cAuxnrTamanho;
	cAuxinDisponibilidade = (cAuxinDisponibilidade==NULL)?"-1":cAuxinDisponibilidade;
	cAuxidClassificadorCampo = (cAuxidClassificadorCampo==NULL)?"-1":cAuxidClassificadorCampo;
	cAuxinFiltro = (cAuxinFiltro==NULL)?"-1":cAuxinFiltro;
	cAuxinPesquisa = (cAuxinPesquisa==NULL)?"-1":cAuxinPesquisa;
	cAuxinObrigatorio = (cAuxinObrigatorio==NULL)?"-1":cAuxinObrigatorio;

	if(strcmp(cAuxnmCampo,"-1") != 0)
	{
		sprintf(cAuxnmCampo,"%.*s%%",2000,cnmCampo);
	}

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL
   			DECLARE
   				CursorCampoAllId CURSOR FOR
				SELECT
					  C.IDCAMPO,
					  C.NMCAMPO,
					  TDC.IDTIPODADOCAMPO,
					  TDC.SGTIPODADOCAMPO,
					  TDC.NMTIPODADOCAMPO,
					  TDC.INDOMINIO,
					  MAC.IDMASCARAAPRESENCAOCAMPO,
					  MAC.NMMASCARAAPRESENCAOCAMPO,
					  MAC.SGMASCARAAPRESENCAOCAMPO,
					  LAC.IDLAYOUTAPRESENTACAOCAMPO,
					  LAC.NMLAYOUTAPRESENTACAOCAMPO,
					  LAC.SGLAYOUTAPRESENTACAOCAMPO,
					  C.NRTAMANHO,
					  C.INDISPONIBILIDADE,
					  C.IDCLASSIFICADORCAMPO,
					  CC.NMCLASSIFICADORCAMPO,
					  C.INFILTRO,
					  C.INPESQUISA,
					  C.INOBRIGATORIO,
					  DECODE( CD.IDCAMPO, NULL, 0, 1 ) AS TEMDOMINIO
				FROM
					 CONTATOADM.CAMPO C,
					 APOIO.MASCARAAPRESENTACAOCAMPO MAC,
					 APOIO.TIPODADOCAMPO TDC,
					 APOIO.LAYOUTAPRESENTACAOCAMPO LAC,
					 CONTATOADM.CAMPOCLASSIFICADOR	 CC,
					 CONTATOADM.CAMPODOMINIO CD
				WHERE
					 C.IDCLASSIFICADORCAMPO = CC.IDCLASSIFICADORCAMPO AND
					 C.IDLAYOUTAPRESENTACAOCAMPO = LAC.IDLAYOUTAPRESENTACAOCAMPO AND
					 C.IDTIPODADOCAMPO = TDC.IDTIPODADOCAMPO AND
					 C.IDMASCARAAPRESENCAOCAMPO = MAC.IDMASCARAAPRESENCAOCAMPO AND
					 (C.IDCAMPO = :cAuxidCampo OR  :cAuxidCampo = '-1') AND
					 (C.IDCLASSIFICADORCAMPO = :cAuxidClassificadorCampo OR :cAuxidClassificadorCampo= '-1') AND
					 (C.IDLAYOUTAPRESENTACAOCAMPO = :cAuxidLayoutApresentacaoCampo OR :cAuxidLayoutApresentacaoCampo = '-1') AND
					 (C.IDMASCARAAPRESENCAOCAMPO = :cAuxidMascaraApresentacaoCampo OR :cAuxidMascaraApresentacaoCampo = '-1') AND
					 (C.IDTIPODADOCAMPO = :cAuxidTipoDadoCampo OR :cAuxidTipoDadoCampo = '-1') AND
					 (C.INDISPONIBILIDADE = :cAuxinDisponibilidade OR :cAuxinDisponibilidade = '-1') AND
					 (C.INFILTRO = :cAuxinFiltro OR :cAuxinFiltro = '-1') AND
					 (C.INOBRIGATORIO = :cAuxinObrigatorio OR :cAuxinObrigatorio = '-1') AND
					 (C.INPESQUISA = :cAuxinPesquisa OR :cAuxinPesquisa = '-1') AND
					 (C.NRTAMANHO = :cAuxnrTamanho OR :cAuxnrTamanho = '-1') AND
					 (UPPER(C.NMCAMPO) LIKE UPPER(:cAuxnmCampo) OR :cAuxnmCampo = '-1') AND
					 (C.IDCAMPO = CD.IDCAMPO(+))
				ORDER BY
					C.NMCAMPO;

		//Abre o cursor
		EXEC SQL OPEN CursorCampoAllId;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stCampoRegistro, 0, sizeof(stCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorCampoAllId INTO :stCampoRegistro:stCampoIndicator;
				//Adiciona a classe
				Add(
					(char*)stCampoRegistro.stidCampo.arr,
					(char*)stCampoRegistro.stnmCampo.arr,
					(char*)stCampoRegistro.stidTipoDadoCampo.arr,
					(char*)stCampoRegistro.stsgTipoDadoCampo.arr,
					(char*)stCampoRegistro.stnmTipoDadoCampo.arr,
					(char*)stCampoRegistro.stinDominio.arr,
					(char*)stCampoRegistro.stidMascaraApresentacaoCampo.arr,
					(char*)stCampoRegistro.stnmMascaraApresentacaoCampo.arr,
					(char*)stCampoRegistro.stsgMascaraApresentacaoCampo.arr,
					(char*)stCampoRegistro.stidLayoutApresentacaoCampo.arr,
					(char*)stCampoRegistro.stnmLayoutApresentacaoCampo.arr,
					(char*)stCampoRegistro.stsgLayoutApresentacaoCampo.arr,
					(char*)stCampoRegistro.stnrTamanho.arr,
					(char*)stCampoRegistro.stinDisponibilidade.arr,
					(char*)stCampoRegistro.stidClassificadorCampo.arr,
					(char*)stCampoRegistro.stnmClassificadorCampo.arr,
					(char*)stCampoRegistro.stinFiltro.arr,
					(char*)stCampoRegistro.stinPesquisa.arr,
					(char*)stCampoRegistro.stinObrigatorio.arr,
					(char*)stCampoRegistro.sttemDominio.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorCampoAllId;
		}
		//Retorna a quantidade de registros
		ULOG_END("CCampo::ListPar()");
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CCampo::ListAll( void )
{
    ULOG_START("CCampo::ListAll()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidCampo[21+1];
			VARCHAR stnmCampo[2000+1];
			VARCHAR stidTipoDadoCampo[21+1];
			VARCHAR stidMascaraApresentacaoCampo[21+1];
			VARCHAR stidLayoutApresentacaoCampo[21+1];
			VARCHAR stnrTamanho[21+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stidClassificadorCampo[21+1];
			VARCHAR stinFiltro[21+1];
		} stCampoRegistro;
		struct
		{
			short iidCampo;
			short inmCampo;
			short iidTipoDadoCampo;
			short iidMascaraApresentacaoCampo;
			short iidLayoutApresentacaoCampo;
			short inrTamanho;
			short iinDisponibilidade;
			short iidClassificadorCampo;
			short iinFiltro;
		} stCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL
   			DECLARE
   				CursorCampoAll CURSOR FOR
	   		SELECT
		   		IDCAMPO,
				NMCAMPO,
				IDTIPODADOCAMPO,
				IDMASCARAAPRESENTACAOCAMPO,
				IDLAYOUTAPRESENTACAOCAMPO,
				NRTAMANHO,
				INDISPONIBILIDADE,
				IDCLASSIFICADORCAMPO,
				INFILTRO
			FROM
				CONTATOADM.CAMPO
			WHERE
				IDCAMPO > 0
			ORDER BY
				NMCAMPO;

		//Abre o cursor
		EXEC SQL OPEN CursorCampoAll;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stCampoRegistro, 0, sizeof(stCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorCampoAll INTO :stCampoRegistro:stCampoIndicator;
				//Adiciona a classe
				Add(
				    (char*)stCampoRegistro.stidCampo.arr,
					(char*)stCampoRegistro.stnmCampo.arr,
					(char*)stCampoRegistro.stidTipoDadoCampo.arr,
					(char*)stCampoRegistro.stidMascaraApresentacaoCampo.arr,
					(char*)stCampoRegistro.stidLayoutApresentacaoCampo.arr,
					(char*)stCampoRegistro.stnrTamanho.arr,
					(char*)stCampoRegistro.stinDisponibilidade.arr,
					(char*)stCampoRegistro.stidClassificadorCampo.arr,
					"",
					(char*)stCampoRegistro.stinFiltro.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorCampoAll;
		}
		ULOG_END("CCampo::ListAll()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}



int CCampo::ListClassificadorCampo( void )
{
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidClassificadorCampo[21+1];
			VARCHAR stnmClassificadorCampo[255+1];
		} stCampoRegistro;
		struct
		{
			short iidClassificadorCampo;
			short inmClassificadorCampo;
		} stCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL
   			DECLARE
   				CursorClassificador CURSOR FOR
				SELECT
					  CC.IDCLASSIFICADORCAMPO,
					  CC.NMCLASSIFICADORCAMPO
				FROM
					 CONTATOADM.CAMPOCLASSIFICADOR	 CC
				ORDER BY
					CC.NMCLASSIFICADORCAMPO ASC;

		//Abre o cursor
		EXEC SQL OPEN CursorClassificador;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stCampoRegistro, 0, sizeof(stCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorClassificador INTO :stCampoRegistro:stCampoIndicator;
				//Adiciona a classe
				Add(
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					(char*)stCampoRegistro.stidClassificadorCampo.arr,
					(char*)stCampoRegistro.stnmClassificadorCampo.arr,
					"",
					"",
					"",
					""
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorClassificador;
		}
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}
int CCampo::ListTipoDadoCampo( void )
{
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidTipoDadoCampo[21+1];
			VARCHAR stsgTipoDadoCampo[255+1];
			VARCHAR stnmTipoDadoCampo[255+1];
			VARCHAR stinDominio[21+1];
		} stCampoRegistro;
		struct
		{
			short iidTipoDadoCampo;
			short inmClassificadorCampo;
			short inmTipoDadoCampo;
			short iinDominio;
		} stCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL
   			DECLARE
   				CursorTipoDado CURSOR FOR
				SELECT
					  TDC.IDTIPODADOCAMPO,
					  TDC.SGTIPODADOCAMPO,
					  TDC.NMTIPODADOCAMPO,
					  TDC.INDOMINIO
				FROM
					APOIO.TIPODADOCAMPO TDC
				ORDER BY
					 TDC.NMTIPODADOCAMPO ASC;

		//Abre o cursor
		EXEC SQL OPEN CursorTipoDado;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stCampoRegistro, 0, sizeof(stCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorTipoDado INTO :stCampoRegistro:stCampoIndicator;
				//Adiciona a classe
				Add(
					"",
					"",
					(char*)stCampoRegistro.stidTipoDadoCampo.arr,
					(char*)stCampoRegistro.stsgTipoDadoCampo.arr,
					(char*)stCampoRegistro.stnmTipoDadoCampo.arr,
					(char*)stCampoRegistro.stinDominio.arr,
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					""
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorTipoDado;
		}
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}
int CCampo::ListMascaraApresentacaoCampo( void )
{
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidMascaraApresentacaoCampo[21+1];
			VARCHAR stsgMascaraApresentacaoCampo[255+1];
			VARCHAR stnmMascaraApresentacaoCampo[255+1];
		} stCampoRegistro;
		struct
		{
			short iidMascaraApresentacaoCampo;
			short isgMascaraApresentacaoCampo;
			short inmMascaraApresentacaoCampo;
		} stCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL
   			DECLARE
   				CursorMascaraApresentacao CURSOR FOR
				SELECT
					  MAC.IDMASCARAAPRESENCAOCAMPO,
					  MAC.NMMASCARAAPRESENCAOCAMPO,
					  MAC.SGMASCARAAPRESENCAOCAMPO
				FROM
					  APOIO.MASCARAAPRESENTACAOCAMPO MAC
				ORDER BY
					  MAC.NMMASCARAAPRESENCAOCAMPO ASC;

		//Abre o cursor
		EXEC SQL OPEN CursorMascaraApresentacao;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stCampoRegistro, 0, sizeof(stCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorMascaraApresentacao INTO :stCampoRegistro:stCampoIndicator;
				//Adiciona a classe
				Add(
					"",
					"",
					"",
					"",
					"",
					"",
					(char*)stCampoRegistro.stidMascaraApresentacaoCampo.arr,
					(char*)stCampoRegistro.stnmMascaraApresentacaoCampo.arr,
					(char*)stCampoRegistro.stsgMascaraApresentacaoCampo.arr,
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					""
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorMascaraApresentacao;
		}
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}
int CCampo::ListLayoutApresentacaoCampo(void)
{
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidLayoutApresentacaoCampo[21+1];
			VARCHAR stnmLayoutApresentacaoCampo[255+1];
			VARCHAR stsgLayoutApresentacaoCampo[255+1];
		} stCampoRegistro;
		struct
		{
			short iidLayoutApresentacaoCampo;
			short inmLayoutApresentacaoCampo;
			short isgLayoutApresentacaoCampo;
		} stCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL
   			DECLARE
   				CursorLayoutApresentacao CURSOR FOR
				SELECT
					  IDLAYOUTAPRESENTACAOCAMPO,
					  NMLAYOUTAPRESENTACAOCAMPO,
					  SGLAYOUTAPRESENTACAOCAMPO
				FROM
					  APOIO.LAYOUTAPRESENTACAOCAMPO
				ORDER BY
					  NMLAYOUTAPRESENTACAOCAMPO ASC;

		//Abre o cursor
		EXEC SQL OPEN CursorLayoutApresentacao;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stCampoRegistro, 0, sizeof(stCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorLayoutApresentacao INTO :stCampoRegistro:stCampoIndicator;
				//Adiciona a classe
				Add(
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					(char*)stCampoRegistro.stidLayoutApresentacaoCampo.arr,
					(char*)stCampoRegistro.stnmLayoutApresentacaoCampo.arr,
					(char*)stCampoRegistro.stsgLayoutApresentacaoCampo.arr,
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					""
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorLayoutApresentacao;
		}
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

void CCampo::GetXmlClassificador(char* cNomeTag, XMLGen*xml)
{
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
			{
				xml->createTag(cNomeTag);
				//Adiciona a proprieda necessaria para o Weblogic
				//xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{
				//Adiciona as tags necessarias
				xml->addItem("idClassificadorCampo", Registro(x)->cidClassificadorCampo );
				xml->addItem("nmClassificadorCampo", Registro(x)->cnmClassificadorCampo );
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}
void CCampo::GetXmlTipoDado(char* cNomeTag, XMLGen*xml)
{
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
			{
				xml->createTag(cNomeTag);
				//Adiciona a proprieda necessaria para o Weblogic
				//xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{
				//Adiciona as tags necessarias
				xml->addItem("idTipoDadoCampo", Registro(x)->cidTipoDadoCampo );
				xml->addItem("sgTipoDadoCampo", Registro(x)->csgTipoDadoCampo );
				xml->addItem("nmTipoDadoCampo", Registro(x)->cnmTipoDadoCampo );
				xml->addItem("inDominio", Registro(x)->cinDominio );
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}
void CCampo::GetXmlLayoutApresentacao(char* cNomeTag, XMLGen*xml)
{
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
			{
				xml->createTag(cNomeTag);
				//Adiciona a proprieda necessaria para o Weblogic
				//xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{
				//Adiciona as tags necessarias
				xml->addItem("idLayoutApresentacaoCampo", Registro(x)->cidLayoutApresentacaoCampo );
				xml->addItem("nmLayoutApresentacaoCampo", Registro(x)->cnmLayoutApresentacaoCampo );
				xml->addItem("sgLayoutApresentacaoCampo", Registro(x)->csgLayoutApresentacaoCampo );
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}
void CCampo::GetXmlMascaraApresentacao(char* cNomeTag, XMLGen*xml)
{
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
			{
				xml->createTag(cNomeTag);
				//Adiciona a proprieda necessaria para o Weblogic
				//xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{
				//Adiciona as tags necessarias
				xml->addItem("idMascaraApresentacao", Registro(x)->cidMascaraApresentacaoCampo );
				xml->addItem("nmMascaraApresentacao", Registro(x)->cnmMascaraApresentacaoCampo );
				xml->addItem("sgMascaraApresentacao", Registro(x)->csgMascaraApresentacaoCampo );
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}

void CCampo::GetXml( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
			{
				xml->createTag(cNomeTag);
				//Adiciona a proprieda necessaria para o Weblogic
				xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			}
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{
				//Adiciona as tags necessarias
				xml->addItem("idCampo", Registro(x)->cidCampo );
				xml->addItem("nmCampo", Registro(x)->cnmCampo );
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}

void CCampo::GetXmlCampos( XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		xml->createTag("AdmClassificadorCamposVO");
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag("AdmClassificadorCampoVO");
			//Adiciona a proprieda necessaria para o Weblogic
			//xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{
				xml->addItem("idClassificadorCampo", Registro(x)->cidCampo );
				xml->addItem("nmClassificadorCampo", Registro(x)->cnmCampo );
			}
			xml->closeTag();
		}
		xml->closeTag();
	}
}

void CCampo::GetCurrentID(char *id)
{
	if( Quantidade() > 0 )
	{
		strcpy(id,Registro(0)->cidCampo);
	}
}

int CCampo::Relacionados( char* cidContato )
{
    ULOG_START("CCampo::Relacionados()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidAuxContato = cidContato;
		struct
		{
			VARCHAR stidCampo[21+1];
			VARCHAR stnmCampo[2000+1];
			VARCHAR stidTipoDadoCampo[21+1];
			VARCHAR stidMascaraApresentacaoCampo[21+1];
			VARCHAR stidLayoutApresentacaoCampo[21+1];
			VARCHAR stnrTamanho[21+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stidClassificadorCampo[21+1];
			VARCHAR stinFiltro[21+1];
		} stCampoRegistro;
		struct
		{
			short iidCampo;
			short inmCampo;
			short iidTipoDadoCampo;
			short iidMascaraApresentacaoCampo;
			short iidLayoutApresentacaoCampo;
			short inrTamanho;
			short iinDisponibilidade;
			short iidClassificadorCampo;
			short iinFiltro;
		} stCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoRelacionados;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
		/*
   		EXEC SQL
   			DECLARE
   				CursorRelacionados CURSOR FOR
	   		SELECT DISTINCT
		   		CONTATOFOLHACAMPO.IDCAMPO,
				CONTATOFOLHACAMPO.NMCAMPO,
				CONTATOFOLHACAMPO.IDTIPODADOCAMPO,
				CONTATOFOLHACAMPO.IDMASCARAAPRESENCAOCAMPO,
				CONTATOFOLHACAMPO.IDLAYOUTAPRESENTACAOCAMPO,
				CONTATOFOLHACAMPO.NRTAMANHO,
				CONTATOFOLHACAMPO.INDISPONIBILIDADE,
				CONTATOFOLHACAMPO.IDCLASSIFICADORCAMPO,
				CONTATOFOLHACAMPO.INFILTRO
			FROM
				CONTATOADM.CONTATOFOLHACAMPOBZEROUM CONTATOFOLHACAMPO
			WHERE
				IDCONTATO = :cidAuxContato
			ORDER BY
				CONTATOFOLHACAMPO.NMCAMPO;
        */
   		EXEC SQL
   			DECLARE
   				CursorRelacionados CURSOR FOR
	   		SELECT DISTINCT
		   		CAMPO.IDCAMPO,
				CAMPO.NMCAMPO,
				CAMPO.IDTIPODADOCAMPO,
				CAMPO.IDMASCARAAPRESENCAOCAMPO,
				CAMPO.IDLAYOUTAPRESENTACAOCAMPO,
				CAMPO.NRTAMANHO,
				CAMPO.INDISPONIBILIDADE,
				CAMPO.IDCLASSIFICADORCAMPO,
				CAMPO.INFILTRO
			FROM CONTATOADM.CAMPOCLASSIFICADOR CAMPOCLASSIFICADOR,
			    APOIO.LAYOUTAPRESENTACAOCAMPO LAYOUTAPRESENTACAOCAMPO,
			    APOIO.MASCARAAPRESENTACAOCAMPO MASCARAAPRESENTACAOCAMPO,
			    APOIO.TIPODADOCAMPO TIPODADOCAMPO,
			    CONTATOADM.CAMPO CAMPO,
                CONTATOADM.NOMECONTATO NOMECONTATO,
                CONTATOADM.CONTATO CONTATO,
                WORKFLOW.FASE FASE,
                CONTATOADM.TIPOFECHAMENTOCONTATO TIPOFECHAMENTOCONTATO,
                WORKFLOW.TIPOPROCESSO TIPOPROCESSO,
                CONTATOADM.TIPORETORNOCONTATO TIPORETORNOCONTATO,
                ACESSO.UNIDADE UNIDADE,
                CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
			    CONTATOADM.FASEPROCESSO FASEPROCESSO,
			    APOIO.TIPOLINHA TIPOLINHA,
                CUSTOMER.GRUPOOPERADORA GRUPOOPERADORA,
                CUSTOMER.PESSOA PESSOA1,
                CUSTOMER.PESSOA PESSOA2,
                CUSTOMER.PESSOADEPARA PESSOADEPARA,
                CUSTOMER.OPERADORA OPERADORA,
				APOIO.UF UF,
				CUSTOMER.UFOPERADORA UFOPERADORA,
			    CONTATOADM.CONTATOFOLHACAMPO CONTATOFOLHACAMPO
			WHERE CONTATOFOLHACAMPO.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
			AND PESSOADEPARA.IDPESSOA = PESSOA1.IDPESSOA
			AND PESSOADEPARA.IDPESSOAORIGEM = PESSOA2.IDPESSOA
			AND OPERADORA.IDGRUPOOPERADORA = GRUPOOPERADORA.IDGRUPOOPERADORA
			AND OPERADORA.IDPESSOADEPARAOPERADORA = PESSOADEPARA.IDPESSOADEPARA
			AND UFOPERADORA.IDUF = UF.IDUF
			AND UFOPERADORA.IDPESSOADEPARAOPERADORA = OPERADORA.IDPESSOADEPARAOPERADORA
            AND CONTATO.IDNOMECONTATO = NOMECONTATO.IDNOMECONTATO
            AND TIPOFECHAMENTOCONTATO.IDFASE = FASE.IDFASE
			AND CONTATOFOLHACAMPO.IDCAMPO = CAMPO.IDCAMPO
			AND CONTATOFOLHACAMPO.IDCONTATO = CONTATOFOLHA.IDCONTATO
			AND CONTATOFOLHACAMPO.IDFASEPROCESSO = FASEPROCESSO.IDFASEPROCESSO
			AND CONTATOFOLHACAMPO.IDUFOPERADORA = UFOPERADORA.IDUFOPERADORA
			AND CAMPO.IDLAYOUTAPRESENTACAOCAMPO = LAYOUTAPRESENTACAOCAMPO.IDLAYOUTAPRESENTACAOCAMPO
			AND CAMPO.IDMASCARAAPRESENCAOCAMPO = MASCARAAPRESENTACAOCAMPO.IDMASCARAAPRESENCAOCAMPO
			AND CAMPO.IDTIPODADOCAMPO = TIPODADOCAMPO.IDTIPODADOCAMPO
			AND CAMPO.IDCLASSIFICADORCAMPO = CAMPOCLASSIFICADOR.IDCLASSIFICADORCAMPO
            AND CONTATOFOLHA.IDUNIDADE = UNIDADE.IDUNIDADE
      		AND CONTATOFOLHA.IDCONTATO = CONTATO.IDCONTATO
      		AND CONTATOFOLHA.IDTIPOFECHAMENTOCONTATO = TIPOFECHAMENTOCONTATO.IDTIPOFECHAMENTOCONTATO
      		AND CONTATOFOLHA.IDTIPORETORNOCONTATO = TIPORETORNOCONTATO.IDTIPORETORNOCONTATO
      		AND CONTATOFOLHA.IDTIPOPROCESSO = TIPOPROCESSO.IDTIPOPROCESSO
			AND CONTATOFOLHACAMPO.IDCONTATO = :cidAuxContato
			ORDER BY
				CAMPO.NMCAMPO;


		//Abre o cursor
		EXEC SQL OPEN CursorRelacionados;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stCampoRegistro, 0, sizeof(stCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorRelacionados INTO :stCampoRegistro:stCampoIndicator;
				//Adiciona a classe
				Add(
				    (char*)stCampoRegistro.stidCampo.arr,
					(char*)stCampoRegistro.stnmCampo.arr,
					(char*)stCampoRegistro.stidTipoDadoCampo.arr,
					(char*)stCampoRegistro.stidMascaraApresentacaoCampo.arr,
					(char*)stCampoRegistro.stidLayoutApresentacaoCampo.arr,
					(char*)stCampoRegistro.stnrTamanho.arr,
					(char*)stCampoRegistro.stinDisponibilidade.arr,
					(char*)stCampoRegistro.stidClassificadorCampo.arr,
					"",
					(char*)stCampoRegistro.stinFiltro.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorRelacionados;
		}
		ULOG_END("CCampo::Relacionados()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoRelacionados:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}


int CCampo::NaoRelacionados( char* cidContato )
{
    ULOG_START("CCampo::NaoRelacionados()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidAuxContato = cidContato;
		struct
		{
			VARCHAR stidCampo[21+1];
			VARCHAR stnmCampo[2000+1];
			VARCHAR stidTipoDadoCampo[21+1];
			VARCHAR stidMascaraApresentacaoCampo[21+1];
			VARCHAR stidLayoutApresentacaoCampo[21+1];
			VARCHAR stnrTamanho[21+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stidClassificadorCampo[21+1];
			VARCHAR stinFiltro[21+1];
		} stCampoRegistro;
		struct
		{
			short iidCampo;
			short inmCampo;
			short iidTipoDadoCampo;
			short iidMascaraApresentacaoCampo;
			short iidLayoutApresentacaoCampo;
			short inrTamanho;
			short iinDisponibilidade;
			short iidClassificadorCampo;
			short iinFiltro;
		} stCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoNaoRelacionados;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		/*
   		EXEC SQL
   			DECLARE
   				CursorNaoRelacionados CURSOR FOR
	   		SELECT
		   		CAMPO.IDCAMPO,
				CAMPO.NMCAMPO,
				CAMPO.IDTIPODADOCAMPO,
				CAMPO.IDMASCARAAPRESENCAOCAMPO,
				CAMPO.IDLAYOUTAPRESENTACAOCAMPO,
				CAMPO.NRTAMANHO,
				CAMPO.INDISPONIBILIDADE,
				CAMPO.IDCLASSIFICADORCAMPO,
				CAMPO.INFILTRO
			FROM
				CONTATOADM.CAMPOBZEROUM CAMPO
			WHERE
				CAMPO.IDCAMPO NOT IN
                (
        	   		SELECT DISTINCT
        		   		IDCAMPO
        			FROM
        				CONTATOADM.CONTATOFOLHACAMPO
        			WHERE
        				IDCONTATO = :cidAuxContato
                )
          	ORDER BY
          		CAMPO.NMCAMPO;
        */

   		EXEC SQL
   			DECLARE
   				CursorNaoRelacionados CURSOR FOR
	   		SELECT
		   		CAMPO.IDCAMPO,
				CAMPO.NMCAMPO,
				CAMPO.IDTIPODADOCAMPO,
				CAMPO.IDMASCARAAPRESENCAOCAMPO,
				CAMPO.IDLAYOUTAPRESENTACAOCAMPO,
				CAMPO.NRTAMANHO,
				CAMPO.INDISPONIBILIDADE,
				CAMPO.IDCLASSIFICADORCAMPO,
				CAMPO.INFILTRO
			FROM
			    CONTATOADM.CAMPOCLASSIFICADOR CAMPOCLASSIFICADOR,
			    APOIO.LAYOUTAPRESENTACAOCAMPO LAYOUTAPRESENTACAOCAMPO,
			    APOIO.MASCARAAPRESENTACAOCAMPO MASCARAAPRESENTACAOCAMPO,
			    APOIO.TIPODADOCAMPO TIPODADOCAMPO,
			    CONTATOADM.CAMPO CAMPO
			WHERE CAMPO.IDLAYOUTAPRESENTACAOCAMPO = LAYOUTAPRESENTACAOCAMPO.IDLAYOUTAPRESENTACAOCAMPO
			AND CAMPO.IDMASCARAAPRESENCAOCAMPO = MASCARAAPRESENTACAOCAMPO.IDMASCARAAPRESENCAOCAMPO
			AND CAMPO.IDTIPODADOCAMPO = TIPODADOCAMPO.IDTIPODADOCAMPO
			AND CAMPO.IDCLASSIFICADORCAMPO = CAMPOCLASSIFICADOR.IDCLASSIFICADORCAMPO
			AND
				CAMPO.IDCAMPO NOT IN
                (
        	   		SELECT DISTINCT
        		   		IDCAMPO
        			FROM
        				CONTATOADM.CONTATOFOLHACAMPO
        			WHERE
        				IDCONTATO = :cidAuxContato
                )
          	ORDER BY
          		CAMPO.NMCAMPO;

		//Abre o cursor
		EXEC SQL OPEN CursorNaoRelacionados;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stCampoRegistro, 0, sizeof(stCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorNaoRelacionados INTO :stCampoRegistro:stCampoIndicator;
				//Adiciona a classe
				Add(
				    (char*)stCampoRegistro.stidCampo.arr,
					(char*)stCampoRegistro.stnmCampo.arr,
					(char*)stCampoRegistro.stidTipoDadoCampo.arr,
					(char*)stCampoRegistro.stidMascaraApresentacaoCampo.arr,
					(char*)stCampoRegistro.stidLayoutApresentacaoCampo.arr,
					(char*)stCampoRegistro.stnrTamanho.arr,
					(char*)stCampoRegistro.stinDisponibilidade.arr,
					(char*)stCampoRegistro.stidClassificadorCampo.arr,
					"",
					(char*)stCampoRegistro.stinFiltro.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorNaoRelacionados;
		}
		ULOG_END("CCampo::NaoRelacionados()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoNaoRelacionados:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CCampo::Relacionados( char* cidContato, char* cidClassificadorCampo )
{
    ULOG_START("CCampo::Relacionados()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidAuxContato = cidContato;
		char* cAuxidClassificadorCampo = cidClassificadorCampo;
		struct
		{
			VARCHAR stidCampo[21+1];
			VARCHAR stnmCampo[2000+1];
			VARCHAR stidTipoDadoCampo[21+1];
			VARCHAR stidMascaraApresentacaoCampo[21+1];
			VARCHAR stidLayoutApresentacaoCampo[21+1];
			VARCHAR stnrTamanho[21+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stidClassificadorCampo[21+1];
			VARCHAR stinFiltro[21+1];
		} stCampoRegistro;
		struct
		{
			short iidCampo;
			short inmCampo;
			short iidTipoDadoCampo;
			short iidMascaraApresentacaoCampo;
			short iidLayoutApresentacaoCampo;
			short inrTamanho;
			short iinDisponibilidade;
			short iidClassificadorCampo;
			short iinFiltro;
		} stCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoRelacionadosCls;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
        // Esta query foi otimizada conforme incidência de Homologação Vivo 4328
   		EXEC SQL
   			DECLARE
   				CursorRelacionadosCls CURSOR FOR
	   		SELECT DISTINCT
		   		CONTATOFOLHACAMPO.IDCAMPO,
            CAMPO.NMCAMPO,
            CAMPO.IDTIPODADOCAMPO,
            CAMPO.IDMASCARAAPRESENCAOCAMPO,
            CAMPO.IDLAYOUTAPRESENTACAOCAMPO,
            CAMPO.NRTAMANHO,
            CAMPO.INDISPONIBILIDADE,
            CAMPO.IDCLASSIFICADORCAMPO,
            CAMPO.INFILTRO
         FROM CONTATOADM.CAMPO CAMPO,
              CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
              CONTATOADM.FASEPROCESSO FASEPROCESSO,
              APOIO.TIPOLINHA TIPOLINHA,
              CUSTOMER.UFOPERADORA UFOPERADORA,
              CONTATOADM.CONTATOFOLHACAMPO CONTATOFOLHACAMPO
        WHERE CONTATOFOLHACAMPO.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
          AND CONTATOFOLHACAMPO.IDCAMPO = CAMPO.IDCAMPO
          AND CONTATOFOLHACAMPO.IDCONTATO = CONTATOFOLHA.IDCONTATO
          AND CONTATOFOLHACAMPO.IDFASEPROCESSO = FASEPROCESSO.IDFASEPROCESSO
          AND CONTATOFOLHACAMPO.IDUFOPERADORA = UFOPERADORA.IDUFOPERADORA
	      AND CONTATOFOLHACAMPO.IDCONTATO = :cidAuxContato
	      AND CAMPO.IDCLASSIFICADORCAMPO = :cAuxidClassificadorCampo
			ORDER BY
		      CAMPO.NMCAMPO;

		//Abre o cursor
		EXEC SQL OPEN CursorRelacionadosCls;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stCampoRegistro, 0, sizeof(stCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorRelacionadosCls INTO :stCampoRegistro:stCampoIndicator;
				//Adiciona a classe
				Add(
				    (char*)stCampoRegistro.stidCampo.arr,
					(char*)stCampoRegistro.stnmCampo.arr,
					(char*)stCampoRegistro.stidTipoDadoCampo.arr,
					(char*)stCampoRegistro.stidMascaraApresentacaoCampo.arr,
					(char*)stCampoRegistro.stidLayoutApresentacaoCampo.arr,
					(char*)stCampoRegistro.stnrTamanho.arr,
					(char*)stCampoRegistro.stinDisponibilidade.arr,
					(char*)stCampoRegistro.stidClassificadorCampo.arr,
					"",
					(char*)stCampoRegistro.stinFiltro.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorRelacionadosCls;
		}
		ULOG_END("CCampo::Relacionados()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoRelacionadosCls:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}


int CCampo::RelacionadosClassif( XMLGen * xml_g )
{
    ULOG_START("CCampo::RelacionadosClassif()");
	int    iCont = 0;
	struct sqlca sqlca;
	string consulta;
	char buffer[128];

	EXEC SQL BEGIN DECLARE SECTION;

		char * query;
		unsigned long idClassificadorCampo = idClassificadorPrm;
		unsigned long idCampo;
		VARCHAR nmCampo[2001];
		short   i_nmCampo = -1;
		VARCHAR nmClassificador[256];
        short   i_nmClassificador = -1;

	EXEC SQL END DECLARE SECTION;

	try
	{
		consulta =
		   	"SELECT DISTINCT"
			"    CAMPO.IDCAMPO,"
	        "    CAMPO.NMCAMPO "
	        "FROM "
			"    CONTATOADM.CAMPO CAMPO "
	        "WHERE "
	            "CAMPO.IDCAMPO NOT IN "
	            "( "
	                "SELECT "
					"   IDCAMPO "
					"FROM "
					"   CONTATOADM.CONTATOFOLHACAMPO "
					"WHERE "
					"   IDCONTATO = ";
			sprintf(buffer,"%lu",idContatoPrm);
			consulta += buffer;

			consulta += " AND idFaseProcesso IN (1,2) ";
            /*
			sprintf(buffer,"%lu",idFaseProcessoPrm);
			consulta += buffer;
            */
			bool flag = false;

			consulta +=
			") ";
	        consulta +=
	        " AND "
		    "    CAMPO.IDCLASSIFICADORCAMPO = ";

		    sprintf(buffer,"%lu",idClassificadorCampo);
		    consulta += buffer;
		    consulta += 
		    " AND CAMPO.IDCLASSIFICADORCAMPO != 41 "
			" ORDER BY CAMPO.NMCAMPO";

	    query = (char *)consulta.c_str();

	    ULOG( "Query [%s]",query );

		ZeraCampo();

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoRelacionadosClassif;
		EXEC SQL PREPARE Campos FROM :query;
		EXEC SQL DECLARE CamposRelacionadosClassif CURSOR FOR Campos;

		EXEC SQL OPEN CamposRelacionadosClassif;

		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			EXEC SQL WHENEVER NOT FOUND DO break;

			xml_g->createTag( "disponiveis" );
			xml_g->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
			xml_g->addProp("xmlns:ns1", "usuario.fo.vivo.com.br/vo" );

			for(;;)
			{

				EXEC SQL FETCH CamposRelacionadosClassif INTO :idCampo ,
					                                          :nmCampo:i_nmCampo ;

				xml_g->createTag( "CampoObjetoFormularioVO" );
				xml_g->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
				xml_g->addProp("xmlns:ns1", "usuario.fo.vivo.com.br/vo" );

			    CONVIND( nmCampo,i_nmCampo );

			    EXEC SQL SELECT NMCLASSIFICADORCAMPO INTO :nmClassificador:i_nmClassificador FROM CONTATOADM.CAMPOCLASSIFICADOR WHERE IDCLASSIFICADORCAMPO = :idClassificadorCampo;
			    CONVIND( nmClassificador,i_nmClassificador );
				consulta = (char *)nmCampo.arr;
				trim2(consulta);
					xml_g->addItem("idCampoObjeto", idCampo );
					xml_g->addItem("nmCampoObjeto", (char *)consulta.c_str() );
					xml_g->addItem("nmClassificadorComponente", (char *)nmClassificador.arr );
					xml_g->addItem("inClassificadorComponente", "Classificador" );
					xml_g->addItem("idClassificadorComponente", idClassificadorCampo );
				xml_g->closeTag();

			}
			EXEC SQL CLOSE CamposRelacionadosClassif;

			xml_g->closeTag();

		}
		ULOG_END("CCampo::RelacionadosClassif()");

		return 0;
	}
	catch(...)
	{
		throw;
	}

GotoRelacionadosClassif:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	ULOG_END("CCampo::RelacionadosClassif()");
	throw TuxBasicOraException(sqlca.sqlcode);
}



int CCampo::NaoRelacionados( char* cidContato, char* cidClassificadorCampo )
{
    ULOG_START("CCampo::NaoRelacionados()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidAuxContato = cidContato;
		char* cAuxidClassificadorCampo = cidClassificadorCampo;
		struct
		{
			VARCHAR stidCampo[21+1];
			VARCHAR stnmCampo[2000+1];
			VARCHAR stidTipoDadoCampo[21+1];
			VARCHAR stidMascaraApresentacaoCampo[21+1];
			VARCHAR stidLayoutApresentacaoCampo[21+1];
			VARCHAR stnrTamanho[21+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stidClassificadorCampo[21+1];
			VARCHAR stinFiltro[21+1];
		} stCampoRegistro;
		struct
		{
			short iidCampo;
			short inmCampo;
			short iidTipoDadoCampo;
			short iidMascaraApresentacaoCampo;
			short iidLayoutApresentacaoCampo;
			short inrTamanho;
			short iinDisponibilidade;
			short iidClassificadorCampo;
			short iinFiltro;
		} stCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoNaoRelacionadosCls;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
        // Esta query foi otimizada conforme incidência de Homologação Vivo 4328
   		EXEC SQL
   			DECLARE
   				CursorNaoRelacionadosCls CURSOR FOR
	   		SELECT
		   		CAMPO.IDCAMPO,
				CAMPO.NMCAMPO,
				CAMPO.IDTIPODADOCAMPO,
				CAMPO.IDMASCARAAPRESENCAOCAMPO,
		    LAYOUTAPRESENTACAOCAMPO.IDLAYOUTAPRESENTACAOCAMPO,
				CAMPO.NRTAMANHO,
				CAMPO.INDISPONIBILIDADE,
				CAMPO.IDCLASSIFICADORCAMPO,
				CAMPO.INFILTRO
         FROM CONTATOADM.CAMPOCLASSIFICADOR CAMPOCLASSIFICADOR,
              APOIO.LAYOUTAPRESENTACAOCAMPO LAYOUTAPRESENTACAOCAMPO,
              APOIO.MASCARAAPRESENTACAOCAMPO MASCARAAPRESENTACAOCAMPO,
              APOIO.TIPODADOCAMPO TIPODADOCAMPO,
              CONTATOADM.CAMPO CAMPO
        WHERE CAMPO.IDLAYOUTAPRESENTACAOCAMPO = LAYOUTAPRESENTACAOCAMPO.IDLAYOUTAPRESENTACAOCAMPO
          AND CAMPO.IDMASCARAAPRESENCAOCAMPO = MASCARAAPRESENTACAOCAMPO.IDMASCARAAPRESENCAOCAMPO
          AND CAMPO.IDTIPODADOCAMPO = TIPODADOCAMPO.IDTIPODADOCAMPO
          AND CAMPO.IDCLASSIFICADORCAMPO = CAMPOCLASSIFICADOR.IDCLASSIFICADORCAMPO
	      AND CAMPO.IDCAMPO NOT IN
                (
        	   		SELECT DISTINCT
        		   		IDCAMPO
        			FROM
        				    CONTATOADM.CONTATOFOLHACAMPO
        			WHERE
        				IDCONTATO = :cidAuxContato
                )
            AND
            	CAMPO.IDCLASSIFICADORCAMPO = :cAuxidClassificadorCampo
            ORDER BY
            	CAMPO.NMCAMPO;

		//Abre o cursor
		EXEC SQL OPEN CursorNaoRelacionadosCls;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stCampoRegistro, 0, sizeof(stCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorNaoRelacionadosCls INTO :stCampoRegistro:stCampoIndicator;
				//Adiciona a classe
				Add(
				    (char*)stCampoRegistro.stidCampo.arr,
					(char*)stCampoRegistro.stnmCampo.arr,
					(char*)stCampoRegistro.stidTipoDadoCampo.arr,
					(char*)stCampoRegistro.stidMascaraApresentacaoCampo.arr,
					(char*)stCampoRegistro.stidLayoutApresentacaoCampo.arr,
					(char*)stCampoRegistro.stnrTamanho.arr,
					(char*)stCampoRegistro.stinDisponibilidade.arr,
					(char*)stCampoRegistro.stidClassificadorCampo.arr,
					"",
					(char*)stCampoRegistro.stinFiltro.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorNaoRelacionadosCls;
		}
		ULOG_END("CCampo::NaoRelacionados()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoNaoRelacionadosCls:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CCampo::Relacionados( char* cidContato, char* cidClassificadorCampo, char* cidFaseProcesso )
{
    ULOG_START("CCampo::Relacionados()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidAuxContato = cidContato;
		char* cAuxidClassificadorCampo = cidClassificadorCampo;
		char* cAuxidFaseProcesso = cidFaseProcesso;
		struct
		{
			VARCHAR stidCampo[21+1];
			VARCHAR stnmCampo[2000+1];
			VARCHAR stidTipoDadoCampo[21+1];
			VARCHAR stidMascaraApresentacaoCampo[21+1];
			VARCHAR stidLayoutApresentacaoCampo[21+1];
			VARCHAR stnrTamanho[21+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stidClassificadorCampo[21+1];
			VARCHAR stinFiltro[21+1];
		} stCampoRegistro;
		struct
		{
			short iidCampo;
			short inmCampo;
			short iidTipoDadoCampo;
			short iidMascaraApresentacaoCampo;
			short iidLayoutApresentacaoCampo;
			short inrTamanho;
			short iinDisponibilidade;
			short iidClassificadorCampo;
			short iinFiltro;
		} stCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoRelacionadosClsFase;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL
   			DECLARE
   				CursorRelacionadosClsFase CURSOR FOR
	   		SELECT DISTINCT
		   		CONTATOFOLHACAMPO.IDCAMPO,
		    CAMPO.NMCAMPO,
		    CAMPO.IDTIPODADOCAMPO,
		    CAMPO.IDMASCARAAPRESENCAOCAMPO,
		    CAMPO.IDLAYOUTAPRESENTACAOCAMPO,
		    CAMPO.NRTAMANHO,
		    CAMPO.INDISPONIBILIDADE,
		    CAMPO.IDCLASSIFICADORCAMPO,
		    CAMPO.INFILTRO
         FROM CONTATOADM.CAMPO CAMPO,
              CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
              CONTATOADM.FASEPROCESSO FASEPROCESSO,
              APOIO.TIPOLINHA TIPOLINHA,
              CUSTOMER.UFOPERADORA UFOPERADORA,
              CONTATOADM.CONTATOFOLHACAMPO CONTATOFOLHACAMPO
        WHERE CONTATOFOLHACAMPO.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
          AND CONTATOFOLHACAMPO.IDCAMPO = CAMPO.IDCAMPO
          AND CONTATOFOLHACAMPO.IDCONTATO = CONTATOFOLHA.IDCONTATO
          AND CONTATOFOLHACAMPO.IDFASEPROCESSO = FASEPROCESSO.IDFASEPROCESSO
          AND CONTATOFOLHACAMPO.IDUFOPERADORA = UFOPERADORA.IDUFOPERADORA
	      AND CONTATOFOLHACAMPO.IDCONTATO = :cidAuxContato
	      AND CAMPO.IDCLASSIFICADORCAMPO = :cAuxidClassificadorCampo
	      AND CONTATOFOLHACAMPO.IDFASEPROCESSO = :cAuxidFaseProcesso
			ORDER BY
		      CAMPO.NMCAMPO;

		//Abre o cursor
		EXEC SQL OPEN CursorRelacionadosClsFase;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stCampoRegistro, 0, sizeof(stCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorRelacionadosClsFase INTO :stCampoRegistro:stCampoIndicator;
				//Adiciona a classe
				Add(
				    (char*)stCampoRegistro.stidCampo.arr,
					(char*)stCampoRegistro.stnmCampo.arr,
					(char*)stCampoRegistro.stidTipoDadoCampo.arr,
					(char*)stCampoRegistro.stidMascaraApresentacaoCampo.arr,
					(char*)stCampoRegistro.stidLayoutApresentacaoCampo.arr,
					(char*)stCampoRegistro.stnrTamanho.arr,
					(char*)stCampoRegistro.stinDisponibilidade.arr,
					(char*)stCampoRegistro.stidClassificadorCampo.arr,
					"",
					(char*)stCampoRegistro.stinFiltro.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorRelacionadosClsFase;
		}
		//Retorna a quantidade de registros
		ULOG_END("CCampo::Relacionados()");
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoRelacionadosClsFase:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}


int CCampo::NaoRelacionados( char* cidContato, char* cidClassificadorCampo, char* cidFaseProcesso )
{
    ULOG_START("CCampo::NaoRelacionados()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidAuxContato = cidContato;
		char* cAuxidClassificadorCampo = cidClassificadorCampo;
		char* cAuxidFaseProcesso = cidFaseProcesso;
		struct
		{
			VARCHAR stidCampo[21+1];
			VARCHAR stnmCampo[2000+1];
			VARCHAR stidTipoDadoCampo[21+1];
			VARCHAR stidMascaraApresentacaoCampo[21+1];
			VARCHAR stidLayoutApresentacaoCampo[21+1];
			VARCHAR stnrTamanho[21+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stidClassificadorCampo[21+1];
			VARCHAR stinFiltro[21+1];
		} stCampoRegistro;
		struct
		{
			short iidCampo;
			short inmCampo;
			short iidTipoDadoCampo;
			short iidMascaraApresentacaoCampo;
			short iidLayoutApresentacaoCampo;
			short inrTamanho;
			short iinDisponibilidade;
			short iidClassificadorCampo;
			short iinFiltro;
		} stCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoNaoRelacionadosClsFase;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL
   			DECLARE
   				CursorNaoRelacionadosClsFase CURSOR FOR
	   		SELECT
		   		CAMPO.IDCAMPO,
				CAMPO.NMCAMPO,
				CAMPO.IDTIPODADOCAMPO,
				CAMPO.IDMASCARAAPRESENCAOCAMPO,
		    LAYOUTAPRESENTACAOCAMPO.IDLAYOUTAPRESENTACAOCAMPO,
				CAMPO.NRTAMANHO,
				CAMPO.INDISPONIBILIDADE,
				CAMPO.IDCLASSIFICADORCAMPO,
				CAMPO.INFILTRO
         FROM CONTATOADM.CAMPOCLASSIFICADOR CAMPOCLASSIFICADOR,
              APOIO.LAYOUTAPRESENTACAOCAMPO LAYOUTAPRESENTACAOCAMPO,
              APOIO.MASCARAAPRESENTACAOCAMPO MASCARAAPRESENTACAOCAMPO,
              APOIO.TIPODADOCAMPO TIPODADOCAMPO,
              CONTATOADM.CAMPO CAMPO
        WHERE CAMPO.IDLAYOUTAPRESENTACAOCAMPO = LAYOUTAPRESENTACAOCAMPO.IDLAYOUTAPRESENTACAOCAMPO
          AND CAMPO.IDMASCARAAPRESENCAOCAMPO = MASCARAAPRESENTACAOCAMPO.IDMASCARAAPRESENCAOCAMPO
          AND CAMPO.IDTIPODADOCAMPO = TIPODADOCAMPO.IDTIPODADOCAMPO
          AND CAMPO.IDCLASSIFICADORCAMPO = CAMPOCLASSIFICADOR.IDCLASSIFICADORCAMPO
	      AND CAMPO.IDCAMPO NOT IN
                (
        	   		SELECT DISTINCT
        		   		IDCAMPO
        			FROM
        				    CONTATOADM.CONTATOFOLHACAMPO
        			WHERE
        				IDCONTATO = :cidAuxContato
			        AND
				        IDFASEPROCESSO = :cAuxidFaseProcesso
                )
            AND
            	CAMPO.IDCLASSIFICADORCAMPO = :cAuxidClassificadorCampo
            ORDER BY
            	CAMPO.NMCAMPO;

		//Abre o cursor
		EXEC SQL OPEN CursorNaoRelacionadosClsFase;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stCampoRegistro, 0, sizeof(stCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorNaoRelacionadosClsFase INTO :stCampoRegistro:stCampoIndicator;
				//Adiciona a classe
				Add(
				    (char*)stCampoRegistro.stidCampo.arr,
					(char*)stCampoRegistro.stnmCampo.arr,
					(char*)stCampoRegistro.stidTipoDadoCampo.arr,
					(char*)stCampoRegistro.stidMascaraApresentacaoCampo.arr,
					(char*)stCampoRegistro.stidLayoutApresentacaoCampo.arr,
					(char*)stCampoRegistro.stnrTamanho.arr,
					(char*)stCampoRegistro.stinDisponibilidade.arr,
					(char*)stCampoRegistro.stidClassificadorCampo.arr,
					"",
					(char*)stCampoRegistro.stinFiltro.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorNaoRelacionadosClsFase;
		}
		ULOG_END("CCampo::NaoRelacionados()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoNaoRelacionadosClsFase:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}



/* OS 448 */
int CCampo::RelacionadosFase( char* cidContato, char* cidFaseProcesso )
{
    ULOG_START("CCampo::RelacionadosFase()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidAuxContato = cidContato;
		char* cAuxidFaseProcesso = cidFaseProcesso;
		struct
		{
			VARCHAR stidCampo[21+1];
			VARCHAR stnmCampo[2000+1];
			VARCHAR stidTipoDadoCampo[21+1];
			VARCHAR stidMascaraApresentacaoCampo[21+1];
			VARCHAR stidLayoutApresentacaoCampo[21+1];
			VARCHAR stnrTamanho[21+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stidClassificadorCampo[21+1];
			VARCHAR stinFiltro[21+1];
		} stCampoRegistro;
		struct
		{
			short iidCampo;
			short inmCampo;
			short iidTipoDadoCampo;
			short iidMascaraApresentacaoCampo;
			short iidLayoutApresentacaoCampo;
			short inrTamanho;
			short iinDisponibilidade;
			short iidClassificadorCampo;
			short iinFiltro;
		} stCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoCamposRelacionadosFase;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL
   			DECLARE
   				CamposRelacionadosFase CURSOR FOR
	   		SELECT DISTINCT
		   		CONTATOFOLHACAMPO.IDCAMPO,
		    CAMPO.NMCAMPO,
		    CAMPO.IDTIPODADOCAMPO,
		    CAMPO.IDMASCARAAPRESENCAOCAMPO,
		    CAMPO.IDLAYOUTAPRESENTACAOCAMPO,
		    CAMPO.NRTAMANHO,
		    CAMPO.INDISPONIBILIDADE,
		    CAMPO.IDCLASSIFICADORCAMPO,
		    CAMPO.INFILTRO
         FROM CONTATOADM.CAMPO CAMPO,
              CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
              CONTATOADM.FASEPROCESSO FASEPROCESSO,
              APOIO.TIPOLINHA TIPOLINHA,
              CUSTOMER.UFOPERADORA UFOPERADORA,
              CONTATOADM.CONTATOFOLHACAMPO CONTATOFOLHACAMPO
        WHERE CONTATOFOLHACAMPO.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
          AND CONTATOFOLHACAMPO.IDCAMPO = CAMPO.IDCAMPO
          AND CONTATOFOLHACAMPO.IDCONTATO = CONTATOFOLHA.IDCONTATO
          AND CONTATOFOLHACAMPO.IDFASEPROCESSO = FASEPROCESSO.IDFASEPROCESSO
          AND CONTATOFOLHACAMPO.IDUFOPERADORA = UFOPERADORA.IDUFOPERADORA
	      AND CONTATOFOLHACAMPO.IDCONTATO = :cidAuxContato
	      AND CONTATOFOLHACAMPO.IDFASEPROCESSO = :cAuxidFaseProcesso
			ORDER BY
		      CAMPO.NMCAMPO;

		//Abre o cursor
		EXEC SQL OPEN CamposRelacionadosFase;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stCampoRegistro, 0, sizeof(stCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CamposRelacionadosFase INTO :stCampoRegistro:stCampoIndicator;
				//Adiciona a classe
				Add(
				    (char*)stCampoRegistro.stidCampo.arr,
					(char*)stCampoRegistro.stnmCampo.arr,
					(char*)stCampoRegistro.stidTipoDadoCampo.arr,
					(char*)stCampoRegistro.stidMascaraApresentacaoCampo.arr,
					(char*)stCampoRegistro.stidLayoutApresentacaoCampo.arr,
					(char*)stCampoRegistro.stnrTamanho.arr,
					(char*)stCampoRegistro.stinDisponibilidade.arr,
					(char*)stCampoRegistro.stidClassificadorCampo.arr,
					"",
					(char*)stCampoRegistro.stinFiltro.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CamposRelacionadosFase;
		}
		//Retorna a quantidade de registros
		ULOG_END("CCampo::RelacionadosFase()");
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoCamposRelacionadosFase:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}



/* OS 448 */
int CCampo::NaoRelacionadosFase( char* cidContato, char* cidFaseProcesso )
{
    ULOG_START("CCampo::NaoRelacionadosFase()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidAuxContato = cidContato;
		char* cAuxidFaseProcesso = cidFaseProcesso;
		struct
		{
			VARCHAR stidCampo[21+1];
			VARCHAR stnmCampo[2000+1];
			VARCHAR stidTipoDadoCampo[21+1];
			VARCHAR stidMascaraApresentacaoCampo[21+1];
			VARCHAR stidLayoutApresentacaoCampo[21+1];
			VARCHAR stnrTamanho[21+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stidClassificadorCampo[21+1];
			VARCHAR stinFiltro[21+1];
		} stCampoRegistro;
		struct
		{
			short iidCampo;
			short inmCampo;
			short iidTipoDadoCampo;
			short iidMascaraApresentacaoCampo;
			short iidLayoutApresentacaoCampo;
			short inrTamanho;
			short iinDisponibilidade;
			short iidClassificadorCampo;
			short iinFiltro;
		} stCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraCampo();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoCamposNaoRelacionadosFase;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL
   			DECLARE
   				CamposNaoRelacionadosFase CURSOR FOR
	   		SELECT
		   		CAMPO.IDCAMPO,
				CAMPO.NMCAMPO,
				CAMPO.IDTIPODADOCAMPO,
				CAMPO.IDMASCARAAPRESENCAOCAMPO,
		        LAYOUTAPRESENTACAOCAMPO.IDLAYOUTAPRESENTACAOCAMPO,
				CAMPO.NRTAMANHO,
				CAMPO.INDISPONIBILIDADE,
				CAMPO.IDCLASSIFICADORCAMPO,
				CAMPO.INFILTRO
         FROM CONTATOADM.CAMPOCLASSIFICADOR CAMPOCLASSIFICADOR,
              APOIO.LAYOUTAPRESENTACAOCAMPO LAYOUTAPRESENTACAOCAMPO,
              APOIO.MASCARAAPRESENTACAOCAMPO MASCARAAPRESENTACAOCAMPO,
              APOIO.TIPODADOCAMPO TIPODADOCAMPO,
              CONTATOADM.CAMPO CAMPO
        WHERE CAMPO.IDLAYOUTAPRESENTACAOCAMPO = LAYOUTAPRESENTACAOCAMPO.IDLAYOUTAPRESENTACAOCAMPO
          AND CAMPO.IDMASCARAAPRESENCAOCAMPO = MASCARAAPRESENTACAOCAMPO.IDMASCARAAPRESENCAOCAMPO
          AND CAMPO.IDTIPODADOCAMPO = TIPODADOCAMPO.IDTIPODADOCAMPO
          AND CAMPO.IDCLASSIFICADORCAMPO = CAMPOCLASSIFICADOR.IDCLASSIFICADORCAMPO
	      AND CAMPO.IDCAMPO NOT IN
                (
        	   		SELECT DISTINCT
        		   		IDCAMPO
        			FROM
        				    CONTATOADM.CONTATOFOLHACAMPO
        			WHERE
        				IDCONTATO = :cidAuxContato
			        AND
				        IDFASEPROCESSO = :cAuxidFaseProcesso
                )
            ORDER BY
            	CAMPO.NMCAMPO;

		//Abre o cursor
		EXEC SQL OPEN CamposNaoRelacionadosFase;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stCampoRegistro, 0, sizeof(stCampoRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CamposNaoRelacionadosFase INTO :stCampoRegistro:stCampoIndicator;
				//Adiciona a classe
				Add(
				    (char*)stCampoRegistro.stidCampo.arr,
					(char*)stCampoRegistro.stnmCampo.arr,
					(char*)stCampoRegistro.stidTipoDadoCampo.arr,
					(char*)stCampoRegistro.stidMascaraApresentacaoCampo.arr,
					(char*)stCampoRegistro.stidLayoutApresentacaoCampo.arr,
					(char*)stCampoRegistro.stnrTamanho.arr,
					(char*)stCampoRegistro.stinDisponibilidade.arr,
					(char*)stCampoRegistro.stidClassificadorCampo.arr,
					"",
					(char*)stCampoRegistro.stinFiltro.arr
				   );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CamposNaoRelacionadosFase;
		}
		ULOG_END("CCampo::NaoRelacionadosFase()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoCamposNaoRelacionadosFase:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}



int CCampo::ListaAssociada( char* cidContato )
{
    ULOG_START("CCampo::ListaAssociada()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		struct
		{
			VARCHAR stidCampo[21+1];
			VARCHAR stnmCampo[2000+1];
			VARCHAR stidClassificadorCampo[21+1];
			VARCHAR stnmClassificadorCampo[255+1];
		} stCampoRegistro;
		struct
		{
			short iidCampo;
			short inmCampo;
			short iidClassificadorCampo;
			short inmClassificadorCampo;
		} stCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraCampo();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListaAssociada;
	sqlca.sqlcode=0;

	/*
   	EXEC SQL
   		DECLARE
			CursorListaAssociada CURSOR FOR
		SELECT DISTINCT
			IDCAMPO
		   ,NMCAMPO
		   ,IDCLASSIFICADORCAMPO
		   ,NMCLASSIFICADORCAMPO
		FROM
			CONTATOADM.CONTATOFOLHACAMPOBZEROUM
		WHERE
			IDCONTATO = :cAuxidContato
        ORDER BY
            NMCLASSIFICADORCAMPO, NMCAMPO;
    */

   	EXEC SQL
   		DECLARE
			CursorListaAssociada CURSOR FOR
		SELECT DISTINCT
			CONTATOFOLHACAMPO.IDCAMPO
		   ,CAMPO.NMCAMPO
		   ,CAMPO.IDCLASSIFICADORCAMPO
		   ,CAMPOCLASSIFICADOR.NMCLASSIFICADORCAMPO
		FROM
		    CONTATOADM.FASEPROCESSO FASEPROCESSO,
		    APOIO.TIPOLINHA TIPOLINHA,
		    CONTATOADM.CONTATOFOLHACAMPO CONTATOFOLHACAMPO,
            CONTATOADM.CAMPOCLASSIFICADOR CAMPOCLASSIFICADOR,
            APOIO.LAYOUTAPRESENTACAOCAMPO LAYOUTAPRESENTACAOCAMPO,
            APOIO.MASCARAAPRESENTACAOCAMPO MASCARAAPRESENTACAOCAMPO,
            APOIO.TIPODADOCAMPO TIPODADOCAMPO,
            CONTATOADM.CAMPO CAMPO,
		    APOIO.UF UF,
		    CUSTOMER.UFOPERADORA UFOPERADORA,
		    CONTATOADM.CONTATO CONTATO,
		    WORKFLOW.TIPOPROCESSO TIPOPROCESSO,
		    CONTATOADM.TIPORETORNOCONTATO TIPORETORNOCONTATO,
		    ACESSO.UNIDADE UNIDADE,
		    CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
            CUSTOMER.GRUPOOPERADORA GRUPOOPERADORA,
            CUSTOMER.OPERADORA OPERADORA,
		    CUSTOMER.PESSOA PESSOA1,
		    CUSTOMER.PESSOA PESSOA2,
		    CUSTOMER.PESSOADEPARA PESSOADEPARA,
		    WORKFLOW.FASE FASE,
		    CONTATOADM.TIPOFECHAMENTOCONTATO TIPOFECHAMENTOCONTATO
		WHERE TIPOFECHAMENTOCONTATO.IDFASE = FASE.IDFASE
		AND PESSOADEPARA.IDPESSOA = PESSOA1.IDPESSOA
		AND PESSOADEPARA.IDPESSOAORIGEM = PESSOA2.IDPESSOA
        AND OPERADORA.IDGRUPOOPERADORA = GRUPOOPERADORA.IDGRUPOOPERADORA
        AND OPERADORA.IDPESSOADEPARAOPERADORA = PESSOADEPARA.IDPESSOADEPARA
		AND CONTATOFOLHA.IDUNIDADE = UNIDADE.IDUNIDADE
		AND CONTATOFOLHA.IDCONTATO = CONTATO.IDCONTATO
		AND CONTATOFOLHA.IDTIPOFECHAMENTOCONTATO = TIPOFECHAMENTOCONTATO.IDTIPOFECHAMENTOCONTATO
		AND CONTATOFOLHA.IDTIPORETORNOCONTATO = TIPORETORNOCONTATO.IDTIPORETORNOCONTATO
		AND CONTATOFOLHA.IDTIPOPROCESSO = TIPOPROCESSO.IDTIPOPROCESSO
		AND UFOPERADORA.IDUF = UF.IDUF
		AND UFOPERADORA.IDPESSOADEPARAOPERADORA = OPERADORA.IDPESSOADEPARAOPERADORA
        AND CAMPO.IDLAYOUTAPRESENTACAOCAMPO = LAYOUTAPRESENTACAOCAMPO.IDLAYOUTAPRESENTACAOCAMPO
        AND CAMPO.IDMASCARAAPRESENCAOCAMPO = MASCARAAPRESENTACAOCAMPO.IDMASCARAAPRESENCAOCAMPO
        AND CAMPO.IDTIPODADOCAMPO = TIPODADOCAMPO.IDTIPODADOCAMPO
        AND CAMPO.IDCLASSIFICADORCAMPO = CAMPOCLASSIFICADOR.IDCLASSIFICADORCAMPO
		AND CONTATOFOLHACAMPO.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
		AND CONTATOFOLHACAMPO.IDCAMPO = CAMPO.IDCAMPO
		AND CONTATOFOLHACAMPO.IDCONTATO = CONTATOFOLHA.IDCONTATO
		AND CONTATOFOLHACAMPO.IDFASEPROCESSO = FASEPROCESSO.IDFASEPROCESSO
		AND CONTATOFOLHACAMPO.IDUFOPERADORA = UFOPERADORA.IDUFOPERADORA
		AND
			CONTATOFOLHACAMPO.IDCONTATO = :cAuxidContato
        ORDER BY
            NMCLASSIFICADORCAMPO, NMCAMPO;

	EXEC SQL OPEN CursorListaAssociada;

	if(sqlca.sqlcode)
		return 0;
	else
	{
		for(;;)
		{
			memset( &stCampoRegistro, 0, sizeof(stCampoRegistro) );
			EXEC SQL FETCH CursorListaAssociada INTO :stCampoRegistro:stCampoIndicator;
			Add(
				(char*)stCampoRegistro.stidCampo.arr,
				(char*)stCampoRegistro.stnmCampo.arr,
				"",
				"",
				"",
				"",
				"",
				(char*)stCampoRegistro.stidClassificadorCampo.arr,
				(char*)stCampoRegistro.stnmClassificadorCampo.arr,
				""
			   );
			iCont++;
		}
		EXEC SQL CLOSE CursorListaAssociada;
	}

	ULOG_END("CCampo::ListaAssociada()");
	if(sqlca.sqlcode)
		return 0;

	return iCont;

GotoListaAssociada:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}


int CCampo::ListaAssociada( char* cidContato, char* cidFaseProcesso )
{
    ULOG_START("CCampo::ListaAssociada()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		char* cAuxidFaseProcesso = cidFaseProcesso;
		struct
		{
			VARCHAR stidCampo[21+1];
			VARCHAR stnmCampo[2000+1];
			VARCHAR stidClassificadorCampo[21+1];
			VARCHAR stnmClassificadorCampo[255+1];
		} stCampoRegistro;
		struct
		{
			short iidCampo;
			short inmCampo;
			short iidClassificadorCampo;
			short inmClassificadorCampo;
		} stCampoIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraCampo();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListaAssociadaFase;
	sqlca.sqlcode=0;


    // Esta query foi otimizada conforme incidência de Homologação Vivo 4328
   	EXEC SQL
   		DECLARE
			CursorListaAssociadaFase CURSOR FOR
		SELECT DISTINCT
		         CONTATOFOLHACAMPO.IDCAMPO
		         ,CAMPO.NMCAMPO
		         ,CAMPO.IDCLASSIFICADORCAMPO
		         ,CAMPOCLASSIFICADOR.NMCLASSIFICADORCAMPO
            FROM CONTATOADM.CAMPO CAMPO,
 	             CONTATOADM.CAMPOCLASSIFICADOR CAMPOCLASSIFICADOR,
                 CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
                 CONTATOADM.FASEPROCESSO FASEPROCESSO,
                 APOIO.TIPOLINHA TIPOLINHA,
                 CUSTOMER.UFOPERADORA UFOPERADORA,
                 CONTATOADM.CONTATOFOLHACAMPO CONTATOFOLHACAMPO
           WHERE CONTATOFOLHACAMPO.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
             AND CONTATOFOLHACAMPO.IDCAMPO = CAMPO.IDCAMPO
  	         AND CAMPOCLASSIFICADOR.IDCLASSIFICADORCAMPO = CAMPO.IDCLASSIFICADORCAMPO
             AND CONTATOFOLHACAMPO.IDCONTATO = CONTATOFOLHA.IDCONTATO
             AND CONTATOFOLHACAMPO.IDFASEPROCESSO = FASEPROCESSO.IDFASEPROCESSO
             AND CONTATOFOLHACAMPO.IDUFOPERADORA = UFOPERADORA.IDUFOPERADORA
	         AND CONTATOFOLHA.IDCONTATO = :cAuxidContato
	         AND FASEPROCESSO.IDFASEPROCESSO = :cAuxidFaseProcesso
        ORDER BY
            NMCLASSIFICADORCAMPO, NMCAMPO;

	EXEC SQL OPEN CursorListaAssociadaFase;

	if(sqlca.sqlcode)
		return 0;
	else
	{
		for(;;)
		{
			memset( &stCampoRegistro, 0, sizeof(stCampoRegistro) );
			EXEC SQL FETCH CursorListaAssociadaFase INTO :stCampoRegistro:stCampoIndicator;
			Add(
				(char*)stCampoRegistro.stidCampo.arr,
				(char*)stCampoRegistro.stnmCampo.arr,
				"",
				"",
				"",
				"",
				"",
				(char*)stCampoRegistro.stidClassificadorCampo.arr,
				(char*)stCampoRegistro.stnmClassificadorCampo.arr,
				""
			   );
			iCont++;
		}
		EXEC SQL CLOSE CursorListaAssociadaFase;
	}

	ULOG_END("CCampo::ListaAssociada()");
	if(sqlca.sqlcode)
		return 0;

	return iCont;

GotoListaAssociadaFase:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}


void CCampo::GetXmlListaAssociada( char* cNomeTag, char* cNomeClassificador, char* cNomeCampo, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
            //TAG principal
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
				xml->createTag(cNomeTag);

            //Classificador
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeClassificador ) > 0 )
				xml->createTag(cNomeClassificador);
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{
				//Adiciona as tags necessarias
				xml->addItem("idClassificadorCampo", Registro(x)->cidClassificadorCampo );
				xml->addItem("nmClassificadorCampo", Registro(x)->cnmClassificadorCampo );
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeClassificador ) > 0 )
				xml->closeTag();
            //Campo
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeCampo ) > 0 )
				xml->createTag(cNomeCampo);
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{
				//Adiciona as tags necessarias
				xml->addItem("idCampo", Registro(x)->cidCampo );
				xml->addItem("nmCampo", Registro(x)->cnmCampo );
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeCampo ) > 0 )
				xml->closeTag();

			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();

		}
	}
}

void CCampo::GetXmlListAll(char* cNomeTag, XMLGen*xml)
{
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			if( Registro( x ) != NULL )
			{
				if( strlennull( cNomeTag ) > 0 )
				{
					xml->createTag(cNomeTag);
				}
				xml->addItem("idCampo",Registro(x)->cidCampo);
				xml->addItem("nmCampo",Registro(x)->cnmCampo);
				xml->addItem("nrTamanho",Registro(x)->cnrTamanho);
				xml->addItem("inFiltro",Registro(x)->cinFiltro);
				xml->addItem("inDisponibilidade",Registro(x)->cinDisponibilidade);
				xml->addItem("inObrigatorio",Registro(x)->cinObrigatorio);
				xml->addItem("inPesquisa",Registro(x)->cinPesquisa);
				xml->addItem("inDominio",Registro(x)->ctemDominio);
				xml->createTag("AdmClassificadorCampoVO");
				xml->addItem("idClassificadorCampo",Registro(x)->cidClassificadorCampo);
				xml->addItem("nmClassificadorCampo",Registro(x)->cnmClassificadorCampo);
				xml->closeTag();
				xml->createTag("AdmTipoDadoCampoVO");
				xml->addItem("idTipoDadoCampo",Registro(x)->cidTipoDadoCampo);
				xml->addItem("sgTipoDadoCampo",Registro(x)->csgTipoDadoCampo);
				xml->addItem("nmTipoDadoCampo",Registro(x)->cnmTipoDadoCampo);
				xml->addItem("inDominio",Registro(x)->cinDominio);
				xml->closeTag();
				xml->createTag("AdmMascaraApresentacaoVO");
				xml->addItem("idMascaraApresentacao",Registro(x)->cidMascaraApresentacaoCampo);
				xml->addItem("nmMascaraApresentacao",Registro(x)->cnmMascaraApresentacaoCampo);
				xml->addItem("sgMascaraApresentacao",Registro(x)->csgMascaraApresentacaoCampo);
				xml->closeTag();
				xml->createTag("AdmLayoutApresentacaoCampoVO");
				xml->addItem("idLayoutApresentacaoCampo",Registro(x)->cidLayoutApresentacaoCampo);
				xml->addItem("nmLayoutApresentacaoCampo",Registro(x)->cnmLayoutApresentacaoCampo);
				xml->addItem("sgLayoutApresentacaoCampo",Registro(x)->csgLayoutApresentacaoCampo);
				xml->closeTag();
				if( strlennull( cNomeTag ) > 0 )
				{
					xml->closeTag();
				}
			}
		}
	}
}

int CCampo::Insert(
					 char* cnmCampo
					,char* cidTipoDadoCampo
					,char* cidMascaraApresentacaoCampo
					,char* cidLayoutApresentacaoCampo
					,char* cnrTamanho
					,char* cinDisponibilidade
					,char* cidClassificadorCampo
					,char* cinFiltro
					,char* cinPesquisa
					,char* cinObrigatorio
					,char* cidUser
	 )
{
    ULOG_START("CCampo::Insert()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidUserAux = cidUser;
		VARCHAR stidCampo[38+1];
		char* cnmCampoAux = cnmCampo;
		char* cidTipoDadoCampoAux = cidTipoDadoCampo;
		char* cidMascaraApresentacaoCampoAux = cidMascaraApresentacaoCampo;
		char* cidLayoutApresentacaoCampoAux = cidLayoutApresentacaoCampo;
		char* cnrTamanhoAux = cnrTamanho;
		char* cinDisponibilidadeAux = cinDisponibilidade;
		char* cidClassificadorCampoAux = cidClassificadorCampo;
		char* cinFiltroAux = cinFiltro;
		char* cinPesquisaAux = cinPesquisa;
		char* cinObrigatorioAux = cinObrigatorio;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );
	memset( &stidCampo, 0, sizeof( stidCampo ) );

	if(cidUserAux == NULL ||
		cnmCampoAux == NULL ||
		cidTipoDadoCampoAux == NULL ||
		cidMascaraApresentacaoCampoAux == NULL ||
		cidLayoutApresentacaoCampoAux == NULL ||
		cidClassificadorCampoAux == NULL
		)
	{
		return 0;
	}

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;

	//Recupera um id unico
	EXEC SQL
	SELECT
		CONTATOADM.CAMPOSQ.NEXTVAL
	INTO
		:stidCampo
	FROM
		DUAL;

	//Insere um registro
	EXEC SQL
	INSERT INTO CONTATOADM.CAMPO
	(
		 IDCAMPO
		,NMCAMPO
		,IDTIPODADOCAMPO
		,IDMASCARAAPRESENCAOCAMPO
		,IDLAYOUTAPRESENTACAOCAMPO
		,NRTAMANHO
		,INDISPONIBILIDADE
		,IDCLASSIFICADORCAMPO
		,INFILTRO
		,INPESQUISA
		,INOBRIGATORIO
		,IDUSUARIOALTERACAO
		,DTULTIMAALTERACAO
	)
	VALUES
	(
		:stidCampo
		,:cnmCampoAux
		,:cidTipoDadoCampoAux
		,:cidMascaraApresentacaoCampoAux
		,:cidLayoutApresentacaoCampoAux
		,:cnrTamanhoAux
		,:cinDisponibilidadeAux
		,:cidClassificadorCampoAux
		,:cinFiltroAux
		,:cinPesquisaAux
		,:cinObrigatorioAux
		,:cidUserAux
		,SYSDATE
	);

	//Salva o registro na estrutura interna
	Add(
		 (char*)stidCampo.arr
		,cnmCampo
		,cidTipoDadoCampo
		,cidMascaraApresentacaoCampo
		,cidLayoutApresentacaoCampo
		,cnrTamanho
		,cinDisponibilidade
		,cidClassificadorCampo
		,""
		,cinFiltro
		,cinPesquisa
		,cinObrigatorio
	);

    ULOG_END("CCampo::Insert()");
	return 1;

GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if( sqlca.sqlcode == -1 )
		return -1;
	if( sqlca.sqlcode == -2291 )
		return -2;
	else if( sqlca.sqlcode == -2292 )
		return -3;
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CCampo::Update(  char* cidCampo
					,char* cnmCampo
					,char* cidTipoDadoCampo
					,char* cidMascaraApresentacaoCampo
					,char* cidLayoutApresentacaoCampo
					,char* cnrTamanho
					,char* cinDisponibilidade
					,char* cidClassificadorCampo
					,char* cinFiltro
					,char* cinPesquisa
					,char* cinObrigatorio
					,char* cidUser
	 )
{
    ULOG_START("CCampo::Update()");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidUserAux = cidUser;
		char* cidCampoAux = cidCampo;
		char* cnmCampoAux = cnmCampo;
		char* cidTipoDadoCampoAux = cidTipoDadoCampo;
		char* cidMascaraApresentacaoCampoAux = cidMascaraApresentacaoCampo;
		char* cidLayoutApresentacaoCampoAux = cidLayoutApresentacaoCampo;
		char* cnrTamanhoAux = cnrTamanho;
		char* cinDisponibilidadeAux = cinDisponibilidade;
		char* cidClassificadorCampoAux = cidClassificadorCampo;
		char* cinFiltroAux = cinFiltro;
		char* cinPesquisaAux = cinPesquisa;
		char* cinObrigatorioAux = cinObrigatorio;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	if(cidUserAux == NULL ||
		cnmCampoAux == NULL ||
		cidTipoDadoCampoAux == NULL ||
		cidMascaraApresentacaoCampoAux == NULL ||
		cidLayoutApresentacaoCampoAux == NULL ||
		cidClassificadorCampoAux == NULL
		)
	{
	    ULOG_END("CCampo::Update() return 0");
		return 0;
	}

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;

	//Atualiza um registro
	EXEC SQL
	UPDATE
		CONTATOADM.CAMPO
	SET
		 NMCAMPO = :cnmCampoAux
		,IDTIPODADOCAMPO = :cidTipoDadoCampoAux
		,IDMASCARAAPRESENCAOCAMPO = :cidMascaraApresentacaoCampoAux
		,IDLAYOUTAPRESENTACAOCAMPO = :cidLayoutApresentacaoCampoAux
		,NRTAMANHO = :cnrTamanhoAux
		,INDISPONIBILIDADE = :cinDisponibilidadeAux
		,IDCLASSIFICADORCAMPO = :cidClassificadorCampoAux
		,INFILTRO = :cinFiltroAux
		,INPESQUISA = :cinPesquisaAux
		,INOBRIGATORIO = :cinObrigatorioAux
		,IDUSUARIOALTERACAO = :cidUserAux
		,DTULTIMAALTERACAO = SYSDATE
	WHERE
		IDCAMPO = :cidCampoAux;

	//Salva o registro na estrutura interna
	Add(
		 cidCampo
		,cnmCampo
		,cidTipoDadoCampo
		,cidMascaraApresentacaoCampo
		,cidLayoutApresentacaoCampo
		,cnrTamanho
		,cinDisponibilidade
		,cidClassificadorCampo
		,""
		,cinFiltro
		,cinPesquisa
		,cinObrigatorio
	);
    ULOG_END("CCampo::Update() return 1");
	return 1;

GotoUpdate:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CCampo::Delete(
					 char* cidCampo
				  )
{
    ULOG_START("CCampo::Delete() return 0");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidCampoAux = cidCampo;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	//Ativa as acoes decorrentes de erros ORACLE
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;

	// Deleta da tabela campodominio
	EXEC SQL
	DELETE FROM
		CONTATOADM.CAMPODOMINIO
	WHERE
		IDCAMPO = :cidCampoAux;

	//Apaga um registro
	EXEC SQL
	DELETE FROM
		CONTATOADM.CAMPO
	WHERE
		IDCAMPO = :cidCampoAux;
    ULOG_START("CCampo::Delete()");
	return 1;

GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if(sqlca.sqlcode = -2292)
	{
		return -1;
	}
	throw TuxBasicOraException(sqlca.sqlcode);
}



void CCampo::IncluirGrupoDependentes( void )
{
    ULOG_START( "CCampo::IncluirGrupoDependentes" );

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		unsigned long idCampo;
		unsigned long idGrupoCampo;
		VARCHAR nmGrupo[256];
		unsigned long idUsuario = strtoul(cidUser,0,10);
		unsigned long idContatoFolhaCampo = idContatoFolhaCampoPrm;
		VARCHAR nmUsuario[256];
		short i_nmUsuario=-1;
	EXEC SQL END DECLARE SECTION;

	strToOra(nmGrupo,nmGrupoCampoPrm);
	ULOG( "Inserindo Grupo:[%s]",(char*)nmGrupo.arr);

	EXEC SQL WHENEVER SQLERROR GOTO GotoIncluirGrupoDependentes;

    EXEC SQL
	    SELECT
	        NMLOGINUSUARIO
	    INTO
	        :nmUsuario:i_nmUsuario
	    FROM
	        ACESSO.USUARIO
	    WHERE
	        IDPESSOAUSUARIO = :idUsuario;

    CONVIND( nmUsuario,i_nmUsuario );

	EXEC SQL SELECT ContatoAdm.GrupoCampoSQ.NextVal INTO :idGrupoCampo FROM DUAL;
	EXEC SQL INSERT INTO ContatoAdm.GrupoCampo
	(
	    idGrupoCampo,
	    nmGrupoCampo,
	    idTipoGrupoCampo
    )
	VALUES
	(
	    :idGrupoCampo,
		:nmGrupo,
		1
	);

	for(it = pCamposDinamicos.begin(); it != pCamposDinamicos.end(); it++)
	{
		idCampo = *it;
		EXEC SQL INSERT INTO ContatoAdm.AgrupamentoCampo
		(
		    idGrupoCampo,
		    idCampo
        )
		VALUES
		(
		    :idGrupoCampo,
			:idCampo
		);

		EXEC SQL INSERT INTO ContatoAdm.AgrupamentoLog
		(
			idAgrupamentoLog,
			nmLoginUsuario,
		    idGrupoCampo,
		    idCampo,
		    idContatoFolhaCampo,
		    dtUltimaAlteracao
        )
		VALUES
		(
		    ContatoAdm.AgrupamentoLogSQ.NextVal,
		    :nmUsuario,
		    :idGrupoCampo,
			:idCampo,
			:idContatoFolhaCampo,
			SYSDATE
		);

	}

    ULOG_END( "CCampo::IncluirGrupoDependentes" );

GotoIncluirGrupoDependentes:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    ULOG_END( "ERRO --> CCampo::IncluirGrupoDependentes" );
	throw TuxBasicOraException(sqlca.sqlcode);
}



void CCampo::AlterarGrupoDependentes( void )
{
    ULOG_START( "CCampo::AlterarGrupoDependentes" );

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		unsigned long idCampo;
		unsigned long idGrupoCampo = idGrupoCampoPrm;
		unsigned long idUsuario = strtoul(cidUser,0,10);
		unsigned long idContatoFolhaCampo = idContatoFolhaCampoPrm;
		VARCHAR nmGrupo[256];
		VARCHAR nmUsuario[256];
		short i_nmUsuario=-1;
	EXEC SQL END DECLARE SECTION;

	strToOra(nmGrupo,nmGrupoCampoPrm);

	EXEC SQL WHENEVER SQLERROR GOTO GotoAlterarGrupoDependentes;

    EXEC SQL
	    SELECT
	        NMLOGINUSUARIO
	    INTO
	        :nmUsuario:i_nmUsuario
	    FROM
	        ACESSO.USUARIO
	    WHERE
	        IDPESSOAUSUARIO = :idUsuario;

    CONVIND( nmUsuario,i_nmUsuario );

    EXEC SQL
	    UPDATE
	        ContatoAdm.GrupoCampo
	    SET
	        nmGrupoCampo = :nmGrupo
	    WHERE
	        idGrupoCampo = :idGrupoCampo;

    EXEC SQL
	    DELETE FROM
	        ContatoAdm.AgrupamentoCampo
	    WHERE
	        idGrupoCampo = :idGrupoCampo;

	for(it=pCamposDinamicos.begin();it!=pCamposDinamicos.end();it++)
	{
		idCampo=*it;
		EXEC SQL INSERT INTO ContatoAdm.AgrupamentoCampo
		(
		    idGrupoCampo,
		    idCampo
        )
		VALUES
		(
		    :idGrupoCampo,
			:idCampo
		);

		EXEC SQL INSERT INTO ContatoAdm.AgrupamentoLog
		(
			idAgrupamentoLog,
			nmLoginUsuario,
		    idGrupoCampo,
		    idCampo,
		    idContatoFolhaCampo,
		    dtUltimaAlteracao
        )
		VALUES
		(
		    ContatoAdm.AgrupamentoLogSQ.NextVal,
		    :nmUsuario,
		    :idGrupoCampo,
			:idCampo,
			:idContatoFolhaCampo,
			SYSDATE
		);

	}

    ULOG_END( "CCampo::AlterarGrupoDependentes" );

GotoAlterarGrupoDependentes:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    ULOG_END( "ERRO --> CCampo::AlterarGrupoDependentes" );
	throw TuxBasicOraException(sqlca.sqlcode);
}



void CCampo::SelecaoGruposDinamicos( XMLGen* xml )
{
    ULOG_START( "CCampo::SelecaoGruposDinamicos" );

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;

		unsigned long idGrupoCampo;
		VARCHAR nmGrupo[256];
		unsigned long idClassificador;
		VARCHAR nmClassificador[256];

		short i_nmGrupo = -1;
		short i_nmClassificador = -1;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL DECLARE GruposDinamicos CURSOR FOR
		SELECT
		   IDGRUPOCAMPO,
		   NMGRUPOCAMPO
		FROM
		   CONTATOADM.GRUPOCAMPO
		WHERE
		   IDGRUPOCAMPO > 0
		AND
		   IDTIPOGRUPOCAMPO = 1;

	EXEC SQL WHENEVER SQLERROR GOTO GotoSelecaoGruposDinamicos;
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	EXEC SQL OPEN GruposDinamicos;
	for(;;)
	{
		EXEC SQL FETCH GruposDinamicos INTO :idGrupoCampo,
			                                :nmGrupo:i_nmGrupo;
	    CONVIND( nmGrupo,i_nmGrupo );
	}
	EXEC SQL CLOSE GruposDinamicos;


    /* Classificadores */
	EXEC SQL DECLARE Classificadores CURSOR FOR
		SELECT
		   IDCLASSIFICADORCAMPO,
		   NMCLASSIFICADORCAMPO
		FROM
		   CONTATOADM.CAMPOCLASSIFICADOR
		WHERE
		   IDCLASSIFICADORCAMPO > 0;

	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	EXEC SQL OPEN Classificadores;
	for(;;)
	{
		EXEC SQL FETCH Classificadores INTO :idClassificador,
			                                :nmClassificador:i_nmClassificador;
	    CONVIND( nmClassificador,i_nmClassificador );
	}
	EXEC SQL CLOSE Classificadores;

    ULOG_END( "CCampo::SelecaoGruposDinamicos" );

GotoSelecaoGruposDinamicos:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    ULOG_END( "ERRO --> CCampo::SelecaoGruposDinamicos" );
	throw TuxBasicOraException(sqlca.sqlcode);   
	
}



void CCampo::ListaCamposDinamicos( void )
{
    ULOG_START( "CCampo::ListaCamposDinamicos" );

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;

		unsigned long idCampo;
		VARCHAR nmCampo[2001];
		unsigned long idClassificador = idClassificadorPrm;
		short i_nmCampo = -1;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL DECLARE CamposDinamicos CURSOR FOR
		SELECT
		   IDCAMPO,
		   NMCAMPO
		FROM
		   CONTATOADM.CAMPO
		WHERE
		   IDCLASSIFICADORCAMPO = :idClassificador
		AND
		   IDCAMPO > 0;

	EXEC SQL WHENEVER SQLERROR GOTO GotoListaCamposDinamicos;
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	EXEC SQL OPEN CamposDinamicos;
	for(;;)
	{
		EXEC SQL FETCH CamposDinamicos INTO :idCampo,
			                                :nmCampo:i_nmCampo;
	    CONVIND( nmCampo,i_nmCampo );
	}
	EXEC SQL CLOSE CamposDinamicos;

    ULOG_END( "CCampo::ListaCamposDinamicos" );

GotoListaCamposDinamicos:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    ULOG_END( "ERRO --> CCampo::ListaCamposDinamicos" );
	throw TuxBasicOraException(sqlca.sqlcode);
}



void CCampo::CamposDinamicosGrupoRelacion( void )
{
    ULOG_START( "CCampo::CamposDinamicosGrupoRelacion" );

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;

		unsigned long idCampo;
		VARCHAR nmCampo[2001];
		unsigned long idClassificador = idClassificadorPrm;
		unsigned long idGrupoCampo = idGrupoCampoPrm;

		short i_nmCampo = -1;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL DECLARE CamposDinamicosGrupoRelacion CURSOR FOR
		SELECT
		   CAMPO.IDCAMPO,
		   CAMPO.NMCAMPO
		FROM
		   CONTATOADM.CAMPO CAMPO
		WHERE
		   CAMPO.IDCAMPO IN
		   (SELECT AGRUPAMENTOCAMPO.IDCAMPO FROM CONTATOADM.AGRUPAMENTOCAMPO AGRUPAMENTOCAMPO WHERE AGRUPAMENTOCAMPO.IDGRUPOCAMPO = :idGrupoCampo)
		AND
		   CAMPO.IDCLASSIFICADORCAMPO = :idClassificador;

	EXEC SQL WHENEVER SQLERROR GOTO GotoCamposDinamicosGrupoRelacion;
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	EXEC SQL OPEN CamposDinamicosGrupoRelacion;
	for(;;)
	{
		EXEC SQL FETCH CamposDinamicosGrupoRelacion INTO :idCampo,
			                                :nmCampo:i_nmCampo;
	    CONVIND( nmCampo,i_nmCampo );
	}
	EXEC SQL CLOSE CamposDinamicosGrupoRelacion;

    ULOG_END( "CCampo::CamposDinamicosGrupoRelacion" );

GotoCamposDinamicosGrupoRelacion:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    ULOG_END( "ERRO --> CCampo::CamposDinamicosGrupoRelacion" );
	throw TuxBasicOraException(sqlca.sqlcode);
}



void CCampo::CamposDinamicosGrupoNaoRelacion( void )
{
    ULOG_START( "CCampo::CamposDinamicosGrupoNaoRelacion" );

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;

		unsigned long idCampo;
		VARCHAR nmCampo[2001];
		unsigned long idClassificador = idClassificadorPrm;
		unsigned long idGrupoCampo = idGrupoCampoPrm;

		short i_nmCampo = -1;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL DECLARE CamposDinamicosGrupoNaoRelacion CURSOR FOR
		SELECT
		   CAMPO.IDCAMPO,
		   CAMPO.NMCAMPO
		FROM
		   CONTATOADM.CAMPO CAMPO
		WHERE
		   CAMPO.IDCAMPO NOT IN
		   (SELECT AGRUPAMENTOCAMPO.IDCAMPO FROM CONTATOADM.AGRUPAMENTOCAMPO AGRUPAMENTOCAMPO WHERE AGRUPAMENTOCAMPO.IDGRUPOCAMPO = :idGrupoCampo)
		AND
		   CAMPO.IDCLASSIFICADORCAMPO = :idClassificador;

	EXEC SQL WHENEVER SQLERROR GOTO GotoCamposDinamicosGrupoNaoRelacion;
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	EXEC SQL OPEN CamposDinamicosGrupoNaoRelacion;
	for(;;)
	{
		EXEC SQL FETCH CamposDinamicosGrupoNaoRelacion INTO :idCampo,
			                                :nmCampo:i_nmCampo;
	    CONVIND( nmCampo,i_nmCampo );
	}
	EXEC SQL CLOSE CamposDinamicosGrupoNaoRelacion;

    ULOG_END( "CCampo::CamposDinamicosGrupoNaoRelacion" );

GotoCamposDinamicosGrupoNaoRelacion:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    ULOG_END( "ERRO --> CCampo::CamposDinamicosGrupoNaoRelacion" );
	throw TuxBasicOraException(sqlca.sqlcode);
}



int CCampo::ListaComponentes( XMLGen* xml )
{
    ULOG_START( "CCampo::ListaComponentes" );

	struct sqlca sqlca;


	EXEC SQL BEGIN DECLARE SECTION;

		unsigned long idComponente;
		VARCHAR nmComponente[256];

		short i_nmComponente = -1;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL DECLARE Componentes CURSOR FOR
		SELECT
		   IDTIPOSUBFORMULARIO,
		   DSTIPOGRUPOCAMPO
		FROM
		   APOIO.TIPOSUBFORMULARIO
		WHERE
		   IDTIPOSUBFORMULARIO > 0;

	EXEC SQL WHENEVER SQLERROR GOTO GotoComponentes;
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	EXEC SQL OPEN Componentes;
	for(;;)
	{
		EXEC SQL FETCH Componentes INTO :idComponente,
			                            :nmComponente:i_nmComponente;
	    CONVIND( nmComponente,i_nmComponente );

		xml->createTag("AdmClassificadorCampoVO");
		xml->addItem("idClassificadorCampo", idComponente );
		xml->addItem("nmClassificadorCampo", (char *)nmComponente.arr );
		xml->closeTag();
	}
	EXEC SQL CLOSE Componentes;

    ULOG_END( "CCampo::ListaComponentes" );
    return 0;

GotoComponentes:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    ULOG_END( "ERRO --> CCampo::ListaComponentes" );
	throw TuxBasicOraException(sqlca.sqlcode);
}



int CCampo::GrupoCamposDependentes( XMLGen* xml )
{
    ULOG_START( "CCampo::GrupoCamposDependentes" );

	struct sqlca sqlca;


	EXEC SQL BEGIN DECLARE SECTION;

		unsigned long idGrupo;
		VARCHAR nmGrupo[256];

		short i_nmGrupo = -1;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL DECLARE GrupoDependentes CURSOR FOR
		SELECT
		  IDSUBFORMULARIO ,
		  NMSUBFORMULARIO
		FROM
		  CONTATOADM.SUBFORMULARIO
		WHERE
		  IDTIPOSUBFORMULARIO = 2;

	EXEC SQL WHENEVER SQLERROR GOTO GotoGrupoDependentes;
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	xml->createTag( "AdmGruposCamposVO" );
	xml->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
	xml->addProp("xmlns:ns1", "usuario.fo.vivo.com.br/vo" );
	EXEC SQL OPEN GrupoDependentes;
	for(;;)
	{
		EXEC SQL FETCH GrupoDependentes INTO :idGrupo,
			                                 :nmGrupo:i_nmGrupo;
	    CONVIND( nmGrupo,i_nmGrupo );

		xml->createTag("AdmGrupoCamposVO");
		xml->addItem("idGrupoCampos", idGrupo );
		xml->addItem("nmGrupoCampos", (char *)nmGrupo.arr );
		xml->closeTag();
	}
	EXEC SQL CLOSE GrupoDependentes;
	xml->closeTag();

    ULOG_END( "CCampo::GrupoCamposDependentes" );
    return 0;

GotoGrupoDependentes:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    ULOG_END( "ERRO --> CCampo::GrupoCamposDependentes" );
	throw TuxBasicOraException(sqlca.sqlcode);
}



int CCampo::ListaGrupoComponentes( XMLGen* xml )
{
    ULOG_START( "CCampo::ListaGrupoComponentes" );

	struct sqlca sqlca;
	string consulta;

	char buffer[128];


	EXEC SQL BEGIN DECLARE SECTION;

        char * query;

		unsigned long idTipoSubFormulario = idClassificadorPrm;
		unsigned long idComponente;
		VARCHAR nmComponente[256];

		short i_nmComponente = -1;

		VARCHAR nmClassificador[256];

		short i_nmClassificador = -1;

	EXEC SQL END DECLARE SECTION;

    ULOG( "Pesquisando componente [%lu]",idTipoSubFormulario );

    consulta =
		"SELECT "
		"   IDSUBFORMULARIO, "
		"   NMSUBFORMULARIO "
		"FROM "
		"   CONTATOADM.SUBFORMULARIO "
		"WHERE "
		"   IDTIPOSUBFORMULARIO = ";

	sprintf(buffer,"%lu",idClassificadorPrm);
	consulta += buffer;

	consulta +=
	    " AND IDSUBFORMULARIO NOT IN "
		"( "
		"SELECT "
		"   CONTATOFOLHACAMPO.IDSUBFORMULARIO "
		"FROM "
		"   CONTATOADM.CAMPO CAMPO, "
		"   CONTATOADM.CONTATOFOLHACAMPO CONTATOFOLHACAMPO "
		"WHERE ";

    consulta +=
        "   CONTATOFOLHACAMPO.IDFASEPROCESSO IN (1,2) ";

    consulta +=
        " AND CONTATOFOLHACAMPO.IDCONTATO = ";
    sprintf(buffer,"%lu",idContatoPrm);
    consulta += buffer;

    consulta +=
        " AND CAMPO.IDCAMPO = CONTATOFOLHACAMPO.IDCAMPO "
        " AND CONTATOFOLHACAMPO.IDSUBFORMULARIO IS NOT NULL ";

	bool flag = false;

	consulta += ") ORDER BY UPPER(NMSUBFORMULARIO)";

	query = (char *)consulta.c_str();
	ULOG( "Query [%s]",query );

	EXEC SQL WHENEVER SQLERROR GOTO GotoGrupoComponentes;
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL PREPARE Grupos FROM :query;
	EXEC SQL DECLARE GrupoComponentes CURSOR FOR Grupos;

	EXEC SQL OPEN GrupoComponentes;

		xml->createTag( "disponiveis" );
		xml->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
		xml->addProp("xmlns:ns1", "usuario.fo.vivo.com.br/vo" );
		for(;;)
		{
			EXEC SQL FETCH GrupoComponentes INTO :idComponente,
				                            :nmComponente:i_nmComponente;
		    CONVIND( nmComponente,i_nmComponente );
            /*
			EXEC SQL SELECT NMCLASSIFICADORCAMPO INTO :nmClassificador:i_nmClassificador FROM CONTATOADM.CAMPOCLASSIFICADOR WHERE IDCLASSIFICADORCAMPO = :idTipoSubFormulario;
			CONVIND( nmClassificador,i_nmClassificador );
            */                          
			EXEC SQL SELECT DSTIPOGRUPOCAMPO INTO :nmClassificador:i_nmClassificador FROM APOIO.TIPOSUBFORMULARIO WHERE IDTIPOSUBFORMULARIO = :idTipoSubFormulario;
			CONVIND( nmClassificador,i_nmClassificador );

			xml->createTag( "CampoObjetoFormularioVO" );
				xml->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
				xml->addProp("xmlns:ns1", "usuario.fo.vivo.com.br/vo" );


					xml->addItem("idCampoObjeto", idComponente );
					xml->addItem("nmCampoObjeto", (char *)nmComponente.arr );
					xml->addItem("nmClassificadorComponente", (char *)nmClassificador.arr );
					xml->addItem("inClassificadorComponente", "Componente" );
					xml->addItem("idClassificadorComponente", idTipoSubFormulario );
				xml->closeTag();

		}
	xml->closeTag();
	EXEC SQL CLOSE GrupoComponentes;

    ULOG_END( "CCampo::ListaGrupoComponentes" );
    return 0;

GotoGrupoComponentes:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    ULOG_END( "ERRO --> CCampo::ListaGrupoComponentes" );
	throw TuxBasicOraException(sqlca.sqlcode);
}



int CCampo::ListaGrupoCampos( XMLGen * xml )
{
    ULOG_START("CCampo::ListaGrupoCampos()");

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	   unsigned long idGrupo;
	   VARCHAR       nmGrupo[256];
	   short         i_nmGrupo = -1;
	EXEC SQL END DECLARE SECTION;

	try
	{

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListaGrupoCampos;

   		EXEC SQL
   			DECLARE
   				CursorGrupoCampos CURSOR FOR
			SELECT
			   SUBFORMULARIO.IDSUBFORMULARIO,
			   SUBFORMULARIO.NMSUBFORMULARIO
			FROM
			   CONTATOADM.SUBFORMULARIO SUBFORMULARIO
			WHERE
			   SUBFORMULARIO.IDSUBFORMULARIO > 0
			AND
			   SUBFORMULARIO.IDTIPOSUBFORMULARIO = 1
			ORDER BY
			   SUBFORMULARIO.NMSUBFORMULARIO;

		EXEC SQL OPEN CursorGrupoCampos;

		if(sqlca.sqlcode)
			return 0;
		else
		{
			EXEC SQL WHENEVER NOT FOUND DO break;
			xml->createTag( "AdmGruposCamposVO" );
			xml->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
			xml->addProp("xmlns:ns1", "usuario.fo.vivo.com.br/vo" );
			for(;;)
			{

				EXEC SQL FETCH CursorGrupoCampos INTO :idGrupo ,
					                                  :nmGrupo:i_nmGrupo;

			    CONVIND( nmGrupo,i_nmGrupo );

				xml->createTag("AdmGrupoCamposVO");
				xml->addItem("idGrupoCampos", idGrupo );
				xml->addItem("nmGrupoCampos", (char *)nmGrupo.arr );
				xml->closeTag();

			}
			EXEC SQL CLOSE CursorGrupoCampos;

			xml->closeTag();
		}
		ULOG_END("CCampo::ListaGrupoCampos");

		return 0;
	}
	catch(...)
	{
		throw;
	}

GotoListaGrupoCampos:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	ULOG_END("CCampo::ListaGrupoCampos");
	throw TuxBasicOraException(sqlca.sqlcode);

}



int CCampo::CamposNaoRelac( XMLGen * xml )
{
    ULOG_START("CCampo::CamposNaoRelac()");

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	   unsigned long idClassificador = idClassificadorPrm;
	   unsigned long idGrupo = idGrupoCampoPrm;
	   unsigned long idCampo;
	   VARCHAR       nmCampo[2001];
	   short         i_nmCampo = -1;
	EXEC SQL END DECLARE SECTION;

	try
	{

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoCamposNaoRelac;

		ULOG( "Grupo [%d]",idGrupo );
		ULOG( "Classificador [%d]",idClassificador );

   		EXEC SQL
   			DECLARE
   				CursorCamposNaoRelac CURSOR FOR
			SELECT
			   CAMPO.IDCAMPO ,
			   CAMPO.NMCAMPO
			FROM
			   CONTATOADM.CAMPO CAMPO
			WHERE
			   CAMPO.IDCAMPO
			NOT IN
			(
			   SELECT
			      IDCAMPO
			   FROM
			      CONTATOADM.SUBFORMULARIOCAMPO SUBFORMULARIOCAMPO ,
				  CONTATOADM.SUBFORMULARIO SUBFORMULARIO
			   WHERE
			      SUBFORMULARIO.IDTIPOSUBFORMULARIO = 1
			   AND
			      SUBFORMULARIO.IDSUBFORMULARIO = SUBFORMULARIOCAMPO.IDSUBFORMULARIO
			   AND
			      SUBFORMULARIO.IDSUBFORMULARIO = :idGrupo
			)
			AND
			   CAMPO.IDCAMPO > 0
			AND
			   CAMPO.IDCLASSIFICADORCAMPO = :idClassificador
			ORDER BY CAMPO.NMCAMPO;

		EXEC SQL OPEN CursorCamposNaoRelac;

		EXEC SQL WHENEVER NOT FOUND DO break;
		xml->createTag( "disponiveis" );
		xml->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
		xml->addProp("xmlns:ns1", "usuario.fo.vivo.com.br/vo" );

		ULOG( "Iniciando o LOOP" );

 		for(;;)
		{

			EXEC SQL FETCH CursorCamposNaoRelac INTO :idCampo ,
				                                     :nmCampo:i_nmCampo;


		    CONVIND( nmCampo,i_nmCampo );

			ULOG( "Nome Campo [%s]",(char *)nmCampo.arr);

			xml->createTag("AdmCampoVO");
			xml->addItem("idCampo", idCampo );
			xml->addItem("nmCampo", (char *)nmCampo.arr );
			xml->closeTag();

		}
		xml->closeTag();
		EXEC SQL CLOSE CursorCamposNaoRelac;

		ULOG_END("CCampo::CamposNaoRelac");

		return 0;
	}
	catch(...)
	{
		throw;
	}

GotoCamposNaoRelac:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	ULOG_END("CCampo::CamposNaoRelac()");
	throw TuxBasicOraException(sqlca.sqlcode);

}



int CCampo::CamposRelac( XMLGen * xml )
{
    ULOG_START("CCampo::CamposRelac()");

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	   unsigned long idGrupo = idGrupoCampoPrm;
	   unsigned long idCampo;
	   VARCHAR       nmCampo[2001];
	   short         i_nmCampo = -1;
	EXEC SQL END DECLARE SECTION;

	try
	{

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoCamposRelac;

		ULOG( "Grupo [%d]",idGrupo );

   		EXEC SQL
   			DECLARE
   				CursorCamposRelac CURSOR FOR
			SELECT
			   CAMPO.IDCAMPO ,
			   CAMPO.NMCAMPO
			FROM
			   CONTATOADM.CAMPO CAMPO
			WHERE
			   CAMPO.IDCAMPO
			IN
			(
			   SELECT
			      IDCAMPO
			   FROM
			      CONTATOADM.SUBFORMULARIOCAMPO SUBFORMULARIOCAMPO ,
				  CONTATOADM.SUBFORMULARIO SUBFORMULARIO
			   WHERE
			      SUBFORMULARIO.IDTIPOSUBFORMULARIO = 1
			   AND
			      SUBFORMULARIO.IDSUBFORMULARIO = SUBFORMULARIOCAMPO.IDSUBFORMULARIO
			   AND
			      SUBFORMULARIO.IDSUBFORMULARIO = :idGrupo
			)
			AND
			   CAMPO.IDCAMPO > 0
			ORDER BY CAMPO.NMCAMPO;

		EXEC SQL OPEN CursorCamposRelac;

		if(sqlca.sqlcode)
			return 0;
		else
		{
			EXEC SQL WHENEVER NOT FOUND DO break;
			xml->createTag( "selecionados" );
			xml->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
			xml->addProp("xmlns:ns1", "usuario.fo.vivo.com.br/vo" );
			for(;;)
			{

				EXEC SQL FETCH CursorCamposRelac INTO :idCampo ,
					                                  :nmCampo:i_nmCampo;

			    CONVIND( nmCampo,i_nmCampo );
				xml->createTag("AdmCampoVO");
				xml->addItem("idCampo", idCampo );
				xml->addItem("nmCampo", (char *)nmCampo.arr );
				xml->closeTag();

			}
			xml->closeTag();
			EXEC SQL CLOSE CursorCamposRelac;
		}
		ULOG_END("CCampo::CamposRelac");

		return 0;
	}
	catch(...)
	{
		throw;
	}

GotoCamposRelac:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	ULOG_END("CCampo::CamposRelac()");
	throw TuxBasicOraException(sqlca.sqlcode);

}



int CCampo::MostraCampos( XMLGen * xml )
{
    ULOG_START("CCampo::MostraCampos()");

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	   unsigned long idGrupo = idGrupoCampoPrm;
	   unsigned long idCampo;
	   VARCHAR       nmCampo[2001];
	   short         i_nmCampo = -1;
	EXEC SQL END DECLARE SECTION;

	try
	{

		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoMostraCampos;

   		EXEC SQL
   			DECLARE
   				MostraCampos CURSOR FOR
			SELECT
			   CAMPO.IDCAMPO ,
			   CAMPO.NMCAMPO
			FROM
			   CONTATOADM.CAMPO CAMPO
			WHERE
			   CAMPO.IDCAMPO
			IN
			(
			   SELECT
			      IDCAMPO
			   FROM
			      CONTATOADM.SUBFORMULARIOCAMPO SUBFORMULARIOCAMPO ,
				  CONTATOADM.SUBFORMULARIO SUBFORMULARIO
			   WHERE
			      SUBFORMULARIO.IDSUBFORMULARIO = SUBFORMULARIOCAMPO.IDSUBFORMULARIO
			   AND
			      SUBFORMULARIO.IDSUBFORMULARIO = :idGrupo
			)
			AND
			   CAMPO.IDCAMPO > 0
			ORDER BY CAMPO.NMCAMPO;

		EXEC SQL OPEN MostraCampos;

		if(sqlca.sqlcode)
			return 0;
		else
		{
			EXEC SQL WHENEVER NOT FOUND DO break;
			xml->createTag( "selecionados" );
			xml->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
			xml->addProp("xmlns:ns1", "usuario.fo.vivo.com.br/vo" );
			for(;;)
			{

				EXEC SQL FETCH MostraCampos INTO :idCampo ,
					                             :nmCampo:i_nmCampo;

			    CONVIND( nmCampo,i_nmCampo );

				xml->createTag("AdmCampoVO");
				xml->addItem("idCampo", idCampo );
				xml->addItem("nmCampo", (char *)nmCampo.arr );
				xml->closeTag();

			}
			EXEC SQL CLOSE MostraCampos;

    		xml->closeTag();
		}

		ULOG_END("CCampo::MostraCampos");

		return 0;
	}
	catch(...)
	{
		throw;
	}

GotoMostraCampos:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	ULOG_END("CCampo::MostraCampos()");
	throw TuxBasicOraException(sqlca.sqlcode);

}



int CCampo::CamposValores( XMLGen* xml )
{
    ULOG_START( "CCampo::CamposValores()" );

	struct sqlca sqlca;


	EXEC SQL BEGIN DECLARE SECTION;

		unsigned long idGrupo = idGrupoCampoPrm;
		unsigned long idCampo;
		unsigned long idNivel;
		VARCHAR nmCampo[2001];

		short i_nmCampo = -1;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL DECLARE CamposValores CURSOR FOR
		SELECT
		   IDCAMPO ,
		   IDNIVELCAMPOVALOR
		FROM
		   CONTATOADM.SUBFORMULARIOCAMPO
		WHERE
		   IDSUBFORMULARIO = :idGrupo
		ORDER BY IDNIVELCAMPOVALOR;

	EXEC SQL WHENEVER SQLERROR GOTO GotoCamposValores;
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	xml->createTag( "AdmGruposCamposDependentesVO" );
	xml->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo" );
	xml->addProp("xmlns:ns1", "usuario.fo.vivo.com.br/vo" );
	EXEC SQL OPEN CamposValores;
	for(;;)
	{
		EXEC SQL FETCH CamposValores INTO :idCampo ,
			                              :idNivel ;

        EXEC SQL
        SELECT NMCAMPO INTO :nmCampo:i_nmCampo FROM CONTATOADM.CAMPO WHERE IDCAMPO = :idCampo;
	    CONVIND( nmCampo,i_nmCampo );

		xml->createTag( "AdmGrupoCamposDependentesVO" );
		xml->addItem("idCampo", idCampo );
		xml->addItem("nmCampo", (char *)nmCampo.arr );
		xml->addItem("nrNivel", idNivel );
		ObtemValores( idCampo,xml );
		xml->closeTag();

	}
	EXEC SQL CLOSE CamposValores;
	xml->closeTag();

    ULOG_END( "CCampo::CamposValores()" );
    return 0;

GotoCamposValores:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    ULOG_END( "CCampo::CamposValores()" );
	throw TuxBasicOraException(sqlca.sqlcode);
}



int CCampo::ObtemValores( unsigned long idCampoPrm,XMLGen* xml )
{
    ULOG_START( "CCampo::ObtemValores()" );

	struct sqlca sqlca;


	EXEC SQL BEGIN DECLARE SECTION;

		unsigned long idGrupo = idGrupoCampoPrm;
		unsigned long idCampo = idCampoPrm;
		unsigned long idValor;
		VARCHAR nmValor[256];
		short i_nmValor = -1;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL DECLARE Valores CURSOR FOR
		SELECT
		   IDTABELADOMINIO ,
		   NMTABELADOMINIO
		FROM
		   CONTATOADM.TABELADOMINIO
		WHERE
		   IDTABELADOMINIO
		IN
		(
			SELECT
			   IDTABELADOMINIO
			FROM
			   CONTATOADM.DOMINIO
			WHERE
			   IDDOMINIO
			IN
			(
			   SELECT
			      IDDOMINIOPAI
			   FROM
			      CONTATOADM.DOMINIOHIERARQUIA
			   WHERE
			      IDSUBFORMULARIO = :idGrupo
			   AND
			      IDCAMPO = :idCampo
			)
		);

	EXEC SQL WHENEVER SQLERROR GOTO GotoValores;
	EXEC SQL WHENEVER NOT FOUND DO BREAK;

	EXEC SQL OPEN Valores;
	for(;;)
	{
        ULOG( "Pesquisando idGrupo [%lu] - idCampo [%lu]",idGrupo,idCampo );
		EXEC SQL FETCH Valores INTO :idValor ,
				                        :nmValor:i_nmValor ;
		CONVIND( nmValor,i_nmValor );

        ULOG( "Obteve idValor [%lu] - nmValor [%s]",idValor,(char *)nmValor.arr );

		xml->createTag( "AdmCampoVO" );
			xml->addItem("idCampo", idValor );
			xml->addItem("nmCampo", (char *)nmValor.arr );
		xml->closeTag();
    }
	EXEC SQL CLOSE Valores;

    ULOG_END( "CCampo::ObtemValores()" );
    return 0;

GotoValores:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    ULOG_END( "CCampo::ObtemValores()" );
	throw TuxBasicOraException(sqlca.sqlcode);
}


void CCampo::trim2(string& str)
{
  string::size_type pos = str.find_last_not_of(' ');
  if(pos != string::npos) {
    str.erase(pos + 1);
    pos = str.find_first_not_of(' ');
    if(pos != string::npos) str.erase(0, pos);
  }
  else str.erase(str.begin(), str.end());
}



bool CCampo::VerificaCampos( unsigned long idContatoPrm,unsigned long idUFPrm,unsigned long idTipoLinhaPrm,unsigned long idCampoPrm, char * MsgErro )
{
    ULOG_START( "CCampo::VerificaCampos()" );

	char nmGrupo[256];

	struct sqlca sqlca;
    bool existe = false;
    string consulta;

	EXEC SQL BEGIN DECLARE SECTION;

		unsigned long idContato = idContatoPrm;
		unsigned long idUF = idUFPrm;
		unsigned long idTipoLinha = idTipoLinhaPrm;
		unsigned long idCampoAux = idCampoPrm;
		unsigned long idCampo;

		VARCHAR nmCampo[2001];
		short i_nmCampo = -1;

	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR GOTO GotoVerificaCampos;

	EXEC SQL DECLARE VCampo CURSOR FOR
		SELECT
		   IDCAMPO
		FROM
		   CONTATOADM.CONTATOFOLHACAMPO
		WHERE
		   IDCONTATO = :idContato
		AND
		   IDUFOPERADORA = :idUF
		AND
		   IDTIPOLINHA = :idTipoLinha
		AND IDCAMPO > 0;

	EXEC SQL OPEN VCampo;

	for(;;)
	{
		EXEC SQL FETCH VCampo INTO :idCampo;

		if ( idCampo == idCampoPrm )
	    {
	    	existe = true;
	    	ULOG( "Buscando idCampo [%lu]",idCampoAux);
			EXEC SQL
			SELECT NMCAMPO INTO :nmCampo:i_nmCampo FROM CONTATOADM.CAMPO WHERE IDCAMPO = :idCampoAux;
	        CONVIND( nmCampo,i_nmCampo );
			consulta = (char*)nmCampo.arr;
			trim2(consulta);
	 		sprintf(MsgErro,"O campo %s faz parte do(s) grupo(s) de campos já selecionado(s), e o sistema não permite a inclusão do mesmo campo mais de uma vez, favor remover o(s) Grupo(s) ou o campo em questão",(char*)consulta.c_str() );
	 		break;
		}

	}

	EXEC SQL CLOSE VCampo;

    ULOG_END( "CCampo::VerificaCampos()" );
    return existe;

GotoVerificaCampos:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    ULOG_END( "CCampo::VerificaCampos()" );
	throw TuxBasicOraException(sqlca.sqlcode);
}
