#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CFluxoFaseGrupo.h"

CFluxoFaseGrupo::CFluxoFaseGrupo()
{
}

CFluxoFaseGrupo::~CFluxoFaseGrupo()
{
}

int CFluxoFaseGrupo::Insert( char* cidGrupo, 
					         char* cidContato, 
					         char* cidTipoLinha, 
					         char* cidTipoPessoa,
					         char* cidTipoRelacionamento,
					         char* cidTipoCarteira,
				             char* cidSegmentacao,
				             char* cidTipoFechamentoContato,
				             char* cidUser )
{
    ULOG_START("CFluxoFaseGrupo::Insert()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR stAuxidFluxoFaseGrupo[21+1];
		char* cAuxidGrupo  = cidGrupo;
		char* cAuxidContato  = cidContato;
		char* cAuxidTipoLinha  = cidTipoLinha;
		char* cAuxidTipoPessoa = cidTipoPessoa;
		char* cAuxidTipoRelacionamento  = cidTipoRelacionamento;
		char* cAuxidTipoCarteira = cidTipoCarteira;
		char* cAuxidSegmentacao = cidSegmentacao;
		char* cAuxidTipoFechamentoContato = cidTipoFechamentoContato;
		char* cAuxidUser = cidUser;
	EXEC SQL END DECLARE SECTION;
	
	memset( &stAuxidFluxoFaseGrupo, 0, sizeof(stAuxidFluxoFaseGrupo) );
	memset( &sqlca, 0, sizeof( sqlca ) );
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;

	//Pega um id unico e sequencia para a insercao
	EXEC SQL
		SELECT WORKFLOW.FLUXOFASEGRUPOSQ.NEXTVAL
		INTO :stAuxidFluxoFaseGrupo
		FROM DUAL;

	EXEC SQL 
	INSERT INTO WORKFLOW.FLUXOFASEGRUPO
	(
		IDFLUXOFASEGRUPO, 
		IDGRUPO,
		IDCONTATO,
		IDTIPOLINHA,
		IDTIPOPESSOA,
		IDTIPORELACIONAMENTO,
		IDTIPOCARTEIRA,
		IDSEGMENTACAO,
		IDTIPOFECHAMENTOCONTATO,
		IDUSUARIOALTERACAO,
		DTULTIMAALTERACAO
	)
	VALUES
	(
		:stAuxidFluxoFaseGrupo, 
		:cAuxidGrupo, 
		:cAuxidContato, 
		:cAuxidTipoLinha, 
		:cAuxidTipoPessoa, 
		:cAuxidTipoRelacionamento,
		:cAuxidTipoCarteira,
		:cAuxidSegmentacao,
		:cAuxidTipoFechamentoContato,
		:cAuxidUser,
		SYSDATE
	);
	
	
	Add( (char*)stAuxidFluxoFaseGrupo.arr, 
         cAuxidGrupo, 
	     cAuxidContato, 
	     cAuxidTipoLinha, 
	     cAuxidTipoPessoa,
	     cAuxidTipoRelacionamento,
	     cAuxidTipoCarteira,
	     cAuxidSegmentacao,
	     cAuxidTipoFechamentoContato );

    ULOG_END("CFluxoFaseGrupo::Insert()");		   
	return 1;//Sucesso

GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CFluxoFaseGrupo::Update( char* cidFluxoFaseGrupo, 
                             char* cidGrupo, 
					         char* cidContato, 
					         char* cidTipoLinha, 
					         char* cidTipoPessoa,
                             char* cidTipoRelacionamento,
					         char* cidTipoCarteira,
				             char* cidSegmentacao,
				             char* cidTipoFechamentoContato,
				             char* cidUser )
{
    ULOG_START("CFluxoFaseGrupo::Update()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidFluxoFaseGrupo = cidFluxoFaseGrupo;
		char* cAuxidGrupo  = cidGrupo;
		char* cAuxidContato  = cidContato;
		char* cAuxidTipoLinha  = cidTipoLinha;
		char* cAuxidTipoPessoa = cidTipoPessoa;
		char* cAuxidTipoRelacionamento  = cidTipoRelacionamento;
		char* cAuxidTipoCarteira = cidTipoCarteira;
		char* cAuxidSegmentacao = cidSegmentacao;
		char* cAuxidTipoFechamentoContato = cidTipoFechamentoContato;
		char* cAuxidUser = cidUser;
	EXEC SQL END DECLARE SECTION;

	ZeraFluxoFaseGrupo();
	memset( &sqlca, 0, sizeof( sqlca ) );
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;


	EXEC SQL 
	UPDATE 
		WORKFLOW.FLUXOFASEGRUPO
	SET 
		IDGRUPO = :cAuxidGrupo,
		IDCONTATO = :cAuxidContato,
		IDTIPOLINHA = :cAuxidTipoLinha,
		IDTIPOPESSOA = :cAuxidTipoPessoa,
		IDTIPORELACIONAMENTO = :cAuxidTipoRelacionamento,
		IDTIPOCARTEIRA = :cAuxidTipoCarteira,
		IDSEGMENTACAO = :cAuxidSegmentacao,
		IDTIPOFECHAMENTOCONTATO = :cAuxidTipoFechamentoContato,
		IDUSUARIOALTERACAO = :cAuxidUser,
		DTULTIMAALTERACAO = SYSDATE
	WHERE 
		IDFLUXOFASEGRUPO = :cAuxidFluxoFaseGrupo;   
	
	Add( cAuxidFluxoFaseGrupo, 
         cAuxidGrupo, 
	     cAuxidContato, 
	     cAuxidTipoLinha, 
	     cAuxidTipoPessoa,
	     cAuxidTipoRelacionamento,
	     cAuxidTipoCarteira,
	     cAuxidSegmentacao,
	     cAuxidTipoFechamentoContato );

    ULOG_END("CFluxoFaseGrupo::Update()");
	return 1;

GotoUpdate:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}


int CFluxoFaseGrupo::ListId( char* cidFluxoFaseGrupo )
{
    ULOG_START("CFluxoFaseGrupo::ListId()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidFluxoFaseGrupo = cidFluxoFaseGrupo;
		struct
		{
			VARCHAR stidFluxoFaseGrupo[21+1];
			VARCHAR stidGrupo[21+1];
			VARCHAR stidContato[256+1];
			VARCHAR stidTipoLinha[256+1];
			VARCHAR stidTipoPessoa[21+1];
			VARCHAR stidTipoRelacionamento[21+1];
			VARCHAR stidTipoCarteira[21+1];
			VARCHAR stidSegmentacao[21+1];
			VARCHAR stidTipoFechamentoContato[21+1];
		} stFluxoFaseGrupoRegistro;
		struct
		{
			short iidFluxoFaseGrupo;
			short iidGrupo;
			short iidContato;
			short iidTipoPessoa;
			short iidTipoLinha;
			short iidTipoRelacionamento;
			short iidTipoCarteira;
			short iidSegmentacao;
			short iidTipoFechamentoContato;
		} stFluxoFaseGrupoIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraFluxoFaseGrupo();
	memset( &sqlca, 0, sizeof( sqlca ) );

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListId;

   	EXEC SQL 
	DECLARE 
		CursorFluxoFaseGrupoId CURSOR FOR
	SELECT 
		IDFLUXOFASEGRUPO, 
		IDGRUPO,
		IDCONTATO,
		IDTIPOLINHA,
		IDTIPOPESSOA,
		IDTIPORELACIONAMENTO,
		IDTIPOCARTEIRA,
		IDSEGMENTACAO,
		IDTIPOFECHAMENTOCONTATO
	INTO 
		:stFluxoFaseGrupoRegistro:stFluxoFaseGrupoIndicator
	FROM 
		WORKFLOW.FLUXOFASEGRUPO
	WHERE 
		IDFLUXOFASEGRUPO = :cAuxidFluxoFaseGrupo;

	EXEC SQL OPEN CursorFluxoFaseGrupoId;


	if( stFluxoFaseGrupoRegistro.stidFluxoFaseGrupo.len > 0 )
	{
		Add( (char*)stFluxoFaseGrupoRegistro.stidFluxoFaseGrupo.arr, 
		     (char*)stFluxoFaseGrupoRegistro.stidGrupo.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidContato.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidTipoLinha.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidTipoPessoa.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidTipoRelacionamento.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidTipoCarteira.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidSegmentacao.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidTipoFechamentoContato.arr );
	}

    ULOG_END("CFluxoFaseGrupo::ListId()");
	return Quantidade();

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CFluxoFaseGrupo::ListAll( void )
{
    ULOG_START("CFluxoFaseGrupo::ListAll()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidFluxoFaseGrupo[21+1];
			VARCHAR stidGrupo[21+1];
			VARCHAR stidContato[256+1];
			VARCHAR stidTipoLinha[256+1];
			VARCHAR stidTipoPessoa[21+1];
			VARCHAR stidTipoRelacionamento[21+1];
			VARCHAR stidTipoCarteira[21+1];
			VARCHAR stidSegmentacao[21+1];
			VARCHAR stidTipoFechamentoContato[21+1];
		} stFluxoFaseGrupoRegistro;
		struct
		{
			short iidFluxoFaseGrupo;
			short iidGrupo;
			short iidContato;
			short iidTipoPessoa;
			short iidTipoLinha;
			short iidTipoRelacionamento;
			short iidTipoCarteira;
			short iidSegmentacao;
			short iidTipoFechamentoContato;
		} stFluxoFaseGrupoIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraFluxoFaseGrupo();
	memset( &sqlca, 0, sizeof( sqlca ) );

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;

   	EXEC SQL 
	DECLARE 
		CursorFluxoFaseGrupoAll CURSOR FOR
	SELECT 
		IDFLUXOFASEGRUPO, 
		IDGRUPO,
		IDCONTATO,
		IDTIPOLINHA,
		IDTIPOPESSOA,
		IDTIPORELACIONAMENTO,
		IDTIPOCARTEIRA,
		IDSEGMENTACAO,
		IDTIPOFECHAMENTOCONTATO
	FROM 
		WORKFLOW.FLUXOFASEGRUPO
	WHERE 
		IDFLUXOFASEGRUPO > 0;

	EXEC SQL OPEN CursorFluxoFaseGrupoAll;

	for(;;)
	{
		memset( &stFluxoFaseGrupoRegistro, 0, sizeof(stFluxoFaseGrupoRegistro) );
		EXEC SQL FETCH CursorFluxoFaseGrupoAll INTO :stFluxoFaseGrupoRegistro:stFluxoFaseGrupoIndicator;

		Add( (char*)stFluxoFaseGrupoRegistro.stidFluxoFaseGrupo.arr, 
		     (char*)stFluxoFaseGrupoRegistro.stidGrupo.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidContato.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidTipoLinha.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidTipoPessoa.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidTipoRelacionamento.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidTipoCarteira.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidSegmentacao.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidTipoFechamentoContato.arr );

	}
	EXEC SQL CLOSE CursorFluxoFaseGrupoAll;
	
    ULOG_END("CFluxoFaseGrupo::ListAll()");
	return 	Quantidade();

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CFluxoFaseGrupo::ListIdContato( char* cidContato )
{
    ULOG_START("CFluxoFaseGrupo::ListIdContato()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		struct
		{
			VARCHAR stidFluxoFaseGrupo[21+1];
			VARCHAR stidGrupo[21+1];
			VARCHAR stidContato[256+1];
			VARCHAR stidTipoLinha[256+1];
			VARCHAR stidTipoPessoa[21+1];
			VARCHAR stidTipoRelacionamento[21+1];
			VARCHAR stidTipoCarteira[21+1];
			VARCHAR stidSegmentacao[21+1];
			VARCHAR stidTipoFechamentoContato[21+1];
		} stFluxoFaseGrupoRegistro;
		struct
		{
			short iidFluxoFaseGrupo;
			short iidGrupo;
			short iidContato;
			short iidTipoPessoa;
			short iidTipoLinha;
			short iidTipoRelacionamento;
			short iidTipoCarteira;
			short iidSegmentacao;
			short iidTipoFechamentoContato;
		} stFluxoFaseGrupoIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraFluxoFaseGrupo();
	memset( &sqlca, 0, sizeof( sqlca ) );

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListIdContato;

   	EXEC SQL 
	DECLARE 
		CursorListIdContato CURSOR FOR
	SELECT 
		IDFLUXOFASEGRUPO, 
		IDGRUPO,
		IDCONTATO,
		IDTIPOLINHA,
		IDTIPOPESSOA,
		IDTIPORELACIONAMENTO,
		IDTIPOCARTEIRA,
		IDSEGMENTACAO,
		IDTIPOFECHAMENTOCONTATO
	FROM 
		WORKFLOW.FLUXOFASEGRUPO
	WHERE 
		IDFLUXOFASEGRUPO > 0
	AND
		IDCONTATO = :cAuxidContato;

	EXEC SQL OPEN CursorListIdContato;

	for(;;)
	{
		memset( &stFluxoFaseGrupoRegistro, 0, sizeof(stFluxoFaseGrupoRegistro) );
		EXEC SQL FETCH CursorListIdContato INTO :stFluxoFaseGrupoRegistro:stFluxoFaseGrupoIndicator;

		Add( (char*)stFluxoFaseGrupoRegistro.stidFluxoFaseGrupo.arr, 
		     (char*)stFluxoFaseGrupoRegistro.stidGrupo.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidContato.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidTipoLinha.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidTipoPessoa.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidTipoRelacionamento.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidTipoCarteira.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidSegmentacao.arr,
		     (char*)stFluxoFaseGrupoRegistro.stidTipoFechamentoContato.arr );

	}
	EXEC SQL CLOSE CursorListIdContato;
    ULOG_END("CFluxoFaseGrupo::ListIdContato()");
	return 	Quantidade();

GotoListIdContato:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}


void CFluxoFaseGrupo::Copia( char* cidContatoOrigem, 
							 char* cidContatoDestino,
				             char* cidUser )
{
    ULOG_START("CFluxoFaseGrupo::Copia()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContatoOrigem = cidContatoOrigem;
		char* cAuxidContatoDestino = cidContatoDestino;
		char* cAuxidUser = cidUser;
		struct
		{
			VARCHAR stidFaseGrupoFechamento[21+1];
			VARCHAR stidContato[21+1];
			VARCHAR stidGrupo[21+1];
			VARCHAR stidTipoFechamentoContato[21+1];
		}stRegistro;
		struct
		{
			VARCHAR stidFaseGrupoFechamento[21+1];
		}stRegistroNovo;
		struct
		{
			short iidFaseGrupoFechamento;
		}stIndicator;
	EXEC SQL END DECLARE SECTION;

	memset( &sqlca, 0, sizeof( sqlca ) );

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoCopia;

	//Cursor para retornar todos os parametros de um certo contato
	EXEC SQL 
	DECLARE 
		CursorFluxoFaseGrupoCopia CURSOR FOR
	SELECT
		 IDFASEGRUPOFECHAMENTO 
		,IDCONTATO 
		,IDGRUPO 
		,IDTIPOFECHAMENTOCONTATO 
	FROM 
		CONTATOADM.FASEGRUPOFECHAMENTO
	WHERE 
		IDFASEGRUPOFECHAMENTO > 0
	AND
		IDCONTATO = :cAuxidContatoOrigem;

	EXEC SQL OPEN CursorFluxoFaseGrupoCopia;


	for(;;)
	{
		memset( &stRegistro, 0, sizeof(stRegistro) );
		memset( &stRegistroNovo, 0, sizeof(stRegistroNovo) );
		//Recupera os registros do cursor
		EXEC SQL 
		FETCH 
			CursorFluxoFaseGrupoCopia 
		INTO 
			:stRegistro:stIndicator;

		//Recupera um ID unico
		EXEC SQL
		SELECT
			CONTATOADM.FASEGRUPOFECHAMENTOSQ.NEXTVAL
		INTO
			:stRegistroNovo.stidFaseGrupoFechamento:stIndicator.iidFaseGrupoFechamento
		FROM
			DUAL;

		//Insere um registro novo
		EXEC SQL 
		INSERT INTO CONTATOADM.FASEGRUPOFECHAMENTO
		(		
			 IDFASEGRUPOFECHAMENTO 
			,IDCONTATO 
			,IDGRUPO 
			,IDTIPOFECHAMENTOCONTATO 
		)
		VALUES
		(
			 :stRegistroNovo.stidFaseGrupoFechamento
			,:cAuxidContatoDestino
			,:stRegistro.stidGrupo
			,:stRegistro.stidTipoFechamentoContato
		);
		
		//Copia FECHAMENTOSEGMENTACAO relacionada ao antigo FASEGRUPOFECHAMENTO
		EXEC SQL 
		INSERT INTO CONTATOADM.FECHAMENTOSEGMENTACAO
		(		
			 IDFASEGRUPOFECHAMENTO 
			,IDFECHAMENTOSEGMENTACAO 
			,IDSEGMENTACAO 
		)
		SELECT
            :stRegistroNovo.stidFaseGrupoFechamento
            ,CONTATOADM.FECHAMENTOSEGMENTACAOSQ.NEXTVAL
            ,FECHAMENTOSEGMENTACAO.IDSEGMENTACAO 
		FROM 
			CONTATOADM.FECHAMENTOSEGMENTACAO FECHAMENTOSEGMENTACAO
		WHERE 
			FECHAMENTOSEGMENTACAO.IDFASEGRUPOFECHAMENTO = :stRegistro.stidFaseGrupoFechamento;

		//Copia FECHAMENTOTIPOLINHA relacionada ao antigo FASEGRUPOFECHAMENTO
		EXEC SQL 
		INSERT INTO CONTATOADM.FECHAMENTOTIPOLINHA
		(		
			 IDFASEGRUPOFECHAMENTO 
			,IDFECHAMENTOTIPOLINHA 
			,IDTIPOLINHA 
		)
		SELECT
            :stRegistroNovo.stidFaseGrupoFechamento
            ,CONTATOADM.FECHAMENTOTIPOLINHASQ.NEXTVAL
            ,FECHAMENTOTIPOLINHA.IDTIPOLINHA
		FROM 
			CONTATOADM.FECHAMENTOTIPOLINHA FECHAMENTOTIPOLINHA
		WHERE 
			FECHAMENTOTIPOLINHA.IDFASEGRUPOFECHAMENTO = :stRegistro.stidFaseGrupoFechamento;

		//Copia FECHAMENTOTPCARTEIRA relacionada ao antigo FASEGRUPOFECHAMENTO
		EXEC SQL 
		INSERT INTO CONTATOADM.FECHAMENTOTPCARTEIRA
		(		
			 IDFASEGRUPOFECHAMENTO 
			,IDFECHAMENTOTPCARTEIRA 
			,IDTIPOCARTEIRA 
		)
		SELECT
            :stRegistroNovo.stidFaseGrupoFechamento
            ,CONTATOADM.FECHAMENTOTPCARTEIRASQ.NEXTVAL
            ,FECHAMENTOTPCARTEIRA.IDTIPOCARTEIRA
		FROM 
			CONTATOADM.FECHAMENTOTPCARTEIRA FECHAMENTOTPCARTEIRA
		WHERE 
			FECHAMENTOTPCARTEIRA.IDFASEGRUPOFECHAMENTO = :stRegistro.stidFaseGrupoFechamento;

		//Copia FECHAMENTOTIPOPESSOA relacionada ao antigo FASEGRUPOFECHAMENTO
		EXEC SQL 
		INSERT INTO CONTATOADM.FECHAMENTOTIPOPESSOA
		(		
			 IDFASEGRUPOFECHAMENTO 
			,IDFECHAMENTOTIPOPESSOA 
			,IDTIPOPESSOA 
		)
		SELECT
            :stRegistroNovo.stidFaseGrupoFechamento
            ,CONTATOADM.FECHAMENTOTIPOPESSOASQ.NEXTVAL
            ,FECHAMENTOTIPOPESSOA.IDTIPOPESSOA
		FROM 
			CONTATOADM.FECHAMENTOTIPOPESSOA FECHAMENTOTIPOPESSOA
		WHERE 
			FECHAMENTOTIPOPESSOA.IDFASEGRUPOFECHAMENTO = :stRegistro.stidFaseGrupoFechamento;

		//Copia FECHAMENTOTPRELACIONAMENTO relacionada ao antigo FASEGRUPOFECHAMENTO
		EXEC SQL 
		INSERT INTO CONTATOADM.FECHAMENTOTPRELACIONAMENTO
		(		
			 IDFASEGRUPOFECHAMENTO 
			,IDFECHAMENTOTPRELACIONAMENTO 
			,IDTIPORELACIONAMENTO 
		)
		SELECT
            :stRegistroNovo.stidFaseGrupoFechamento
            ,CONTATOADM.FECHAMENTOTPRELACIONAMENTOSQ.NEXTVAL
            ,FECHAMENTOTPRELACIONAMENTO.IDTIPORELACIONAMENTO
		FROM 
			CONTATOADM.FECHAMENTOTPRELACIONAMENTO FECHAMENTOTPRELACIONAMENTO
		WHERE 
			FECHAMENTOTPRELACIONAMENTO.IDFASEGRUPOFECHAMENTO = :stRegistro.stidFaseGrupoFechamento;

	}//for(;;)
	ULOG_END("CFluxoFaseGrupo::Copia()");
	return;

GotoCopia:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}
