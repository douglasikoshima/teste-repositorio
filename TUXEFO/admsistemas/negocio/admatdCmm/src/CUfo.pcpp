#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CUfo.h"

CUFOperadora::CUFOperadora()
{
}

CUFOperadora::~CUFOperadora()
{
}

int CUFOperadora::RelacaoCttUfo( char* cidContato )
{
    ULOG_START("CUFOperadora::RelacaoCttUfo()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		struct
		{
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stidPessoaDeParaOperadora[21+1];
			VARCHAR stidUF[21+1];
		} stUFOperadoraRegistro;
		struct
		{
			short iidUFOperadora;
			short iidPessoaDeParaOperadora;
			short iidUF;
		} stUFOperadoraIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		ZeraUFOperadora();

		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;

		//Declara um cursor para listar os Registros
		/*
        EXEC SQL DECLARE CursorUFOperadoraRelacao_00 CURSOR FOR
   		SELECT customer.UFOperadora.idUFOperadora, customer.UFOperadora.idUFOperadora, customer.UFOperadora.idUFOperadora
		FROM customer.UFOperadora, contatoadm.ContatoUfoperadoraB01
		WHERE customer.UFOperadora.idUFOperadora = contatoadm.ContatoUfoperadoraB01.idContato AND contatoadm.ContatoUfoperadoraB01.idContato = :cAuxidContato ;
        */

        EXEC SQL DECLARE CursorUFOperadoraRelacao_00 CURSOR FOR
   		SELECT 
		   UFOperadora.idUFOperadora, 
		   UFOperadora.idUFOperadora, 
		   UFOperadora.idUFOperadora
		FROM 
		   customer.UFOperadora            UFOperadora 
		  ,CONTATOADM.CONTATOUFOPERADORA  CONTATOUFOPERADORA
		WHERE 
		   UFOperadora.idUFOperadora = CONTATOUFOPERADORA.idUFOperadora 
		AND 
		   CONTATOUFOPERADORA.idContato = :cAuxidContato ;
           
		EXEC SQL WHENEVER SQLERROR GOTO GotoRelacao;

		EXEC SQL OPEN CursorUFOperadoraRelacao_00;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		   ULOG_END("CUFOperadora::RelacaoCttUfo()");
		   return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stUFOperadoraRegistro, 0, sizeof(stUFOperadoraRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorUFOperadoraRelacao_00 INTO :stUFOperadoraRegistro:stUFOperadoraIndicator;
				//Adiciona a classe
				Add( 	(char*)stUFOperadoraRegistro.stidUFOperadora.arr,
				(char*)stUFOperadoraRegistro.stidPessoaDeParaOperadora.arr,
				(char*)stUFOperadoraRegistro.stidUF.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorUFOperadoraRelacao_00;
		}
		ULOG_END("CUFOperadora::RelacaoCttUfo()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoRelacao:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUFOperadora::ExistemCttUfo( char* cidContato )
{
    ULOG_START("CUFOperadora::ExistemCttUfo()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		struct
		{
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stidPessoaDeParaOperadora[21+1];
			VARCHAR stidUF[21+1];
		} stUFOperadoraRegistro;
		struct
		{
			short iidUFOperadora;
			short iidPessoaDeParaOperadora;
			short iidUF;
		} stUFOperadoraIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		ZeraUFOperadora();

		sqlca.sqlcode=0;
		EXEC SQL WHENEVER NOT FOUND CONTINUE;

		//Declara um cursor para listar os Registros
   		/*
        EXEC SQL DECLARE CursorUFOperadoraExistem_00 CURSOR FOR
   		SELECT customer.UFOperadora.idUFOperadora, customer.UFOperadora.idUFOperadora, customer.UFOperadora.idUFOperadora
		FROM customer.UFOperadora
		WHERE customer.UFOperadora.idUFOperadora NOT IN ( SELECT customer.UFOperadora.idUFOperadora FROM customer.UFOperadora, contatoadm.ContatoUfoperadoraB01 WHERE customer.UFOperadora.idUFOperadora = contatoadm.ContatoUfoperadoraB01.idContato AND contatoadm.ContatoUfoperadoraB01.idContato = :cAuxidContato  );
        */

        EXEC SQL DECLARE CursorUFOperadoraExistem_00 CURSOR FOR
   		SELECT 
		   customer.UFOperadora.idUFOperadora, 
		   customer.UFOperadora.idUFOperadora, 
		   customer.UFOperadora.idUFOperadora
		FROM 
		   customer.UFOperadora
		WHERE 
		   customer.UFOperadora.idUFOperadora 
		NOT IN 
		( 
	   		SELECT 
			   UFOperadora.idUFOperadora
			FROM 
			   customer.UFOperadora            UFOperadora 
			  ,CONTATOADM.CONTATOUFOPERADORA  CONTATOUFOPERADORA
			WHERE 
			   UFOperadora.idUFOperadora = CONTATOUFOPERADORA.idUFOperadora 
			AND 
			   CONTATOUFOPERADORA.idContato = :cAuxidContato
		);

		EXEC SQL WHENEVER SQLERROR GOTO GotoExistem;

		EXEC SQL OPEN CursorUFOperadoraExistem_00;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		   ULOG_END("CUFOperadora::ExistemCttUfo()");
		   return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stUFOperadoraRegistro, 0, sizeof(stUFOperadoraRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorUFOperadoraExistem_00 INTO :stUFOperadoraRegistro:stUFOperadoraIndicator;
				//Adiciona a classe
				Add( 	(char*)stUFOperadoraRegistro.stidUFOperadora.arr,
				(char*)stUFOperadoraRegistro.stidPessoaDeParaOperadora.arr,
				(char*)stUFOperadoraRegistro.stidUF.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorUFOperadoraExistem_00;
		}
		ULOG_END("CUFOperadora::ExistemCttUfo()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoExistem:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUFOperadora::ListId( char* cidUFOperadora )
{
    ULOG_START("CUFOperadora::ListId()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidUFOperadora = cidUFOperadora;
		struct
		{
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stidPessoaDeParaOperadora[21+1];
			VARCHAR stidUF[21+1];
		} stUFOperadoraRegistro;
		struct
		{
			short iidUFOperadora;
			short iidPessoaDeParaOperadora;
			short iidUF;
		} stUFOperadoraIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraUFOperadora();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		EXEC SQL DECLARE CursorUFOperadoraId CURSOR FOR
   		SELECT 	idUFOperadora,
	idPessoaDeParaOperadora,
	idUF
		FROM customer.UFOperadora
		WHERE idUFOperadora = :cAuxidUFOperadora;

		//Abre o cursor
		EXEC SQL OPEN CursorUFOperadoraId;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		   ULOG_END("CUFOperadora::ListId()");
           return 0;//Erro
        }
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stUFOperadoraRegistro, 0, sizeof(stUFOperadoraRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorUFOperadoraId INTO :stUFOperadoraRegistro:stUFOperadoraIndicator;
				//Adiciona a classe
				Add( 	(char*)stUFOperadoraRegistro.stidUFOperadora.arr,
				(char*)stUFOperadoraRegistro.stidPessoaDeParaOperadora.arr,
				(char*)stUFOperadoraRegistro.stidUF.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorUFOperadoraId;
		}
		ULOG_END("CUFOperadora::ListId()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CUFOperadora::ListAll( void )
{

    ULOG_START("CUFOperadora::ListAll()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stnmUFOperadora[255+1];
			VARCHAR stidPessoaDeParaOperadora[21+1];
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
		} stUFOperadoraRegistro;
		struct
		{
			short iidUFOperadora;
			short inmUFOperadora;
			short iidPessoaDeParaOperadora;
			short iidUF;
			short isgUF;
			short inmUF;
		} stUFOperadoraIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraUFOperadora();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		/*
        EXEC SQL
			DECLARE
				CursorUFOperadoraAll CURSOR FOR
	   		SELECT
	   			 UFOPERADORA.IDUFOPERADORA
                ,UFOPERADORA.NMPESSOA
				,UFOPERADORA.IDPESSOADEPARAOPERADORA
				,UFOPERADORA.IDUF
                ,UFOPERADORA.SGUF
                ,UFOPERADORA.NMUF
			FROM
				CUSTOMER.UFOPERADORAB01 UFOPERADORA
			WHERE
				UFOPERADORA.IDUFOPERADORA > 0
			ORDER BY
				UPPER(UFOPERADORA.SGUF), UPPER(UFOPERADORA.NMPESSOA);
        */
        
   		EXEC SQL
        DECLARE
            CursorUFOperadoraAll CURSOR FOR
        SELECT
             UFOPERADORA.IDUFOPERADORA
            ,PESSOA.NMPESSOA
            ,UFOPERADORA.IDPESSOADEPARAOPERADORA
            ,UF.IDUF
            ,UF.SGUF
            ,UF.NMUF
        FROM
            CUSTOMER.UFOPERADORA            UFOPERADORA                    
           ,CUSTOMER.OPERADORA              OPERADORA
           ,CUSTOMER.PESSOA                 PESSOA
           ,CUSTOMER.PESSOADEPARA           PESSOADEPARA
           ,APOIO.UF                        UF
        WHERE
            UFOPERADORA.IDUFOPERADORA > 0
        AND UFOPERADORA.IDPESSOADEPARAOPERADORA = OPERADORA.IDPESSOADEPARAOPERADORA
        AND PESSOA.IDPESSOA = PESSOADEPARA.IDPESSOA
        AND PESSOADEPARA.IDPESSOADEPARA = OPERADORA.IDPESSOADEPARAOPERADORA
        AND UFOPERADORA.IDUF = UF.IDUF
        ORDER BY
            UPPER(UF.SGUF), UPPER(PESSOA.NMPESSOA);

            
		//Abre o cursor
		EXEC SQL OPEN CursorUFOperadoraAll;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		   ULOG_END("CUFOperadora::ListAll()");
		   return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stUFOperadoraRegistro, 0, sizeof(stUFOperadoraRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorUFOperadoraAll INTO :stUFOperadoraRegistro:stUFOperadoraIndicator;
				//Adiciona a classe
				Add(
					(char*)stUFOperadoraRegistro.stidUFOperadora.arr
				   ,(char*)stUFOperadoraRegistro.stnmUFOperadora.arr
				   ,(char*)stUFOperadoraRegistro.stidPessoaDeParaOperadora.arr
				   ,(char*)stUFOperadoraRegistro.stidUF.arr
				   ,(char*)stUFOperadoraRegistro.stsgUF.arr
				   ,(char*)stUFOperadoraRegistro.stnmUF.arr
				);
				//conta quantos existem
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorUFOperadoraAll;
		}
		//Retorna a quantidade de registros
		ULOG("return iCont = [%d] ",iCont);
		ULOG_END("CUFOperadora::ListAll()");
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CUFOperadora::GetXml( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			xml->createTag(cNomeTag);
			//Adiciona a proprieda necessaria para o Weblogic
			xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{
				//Adiciona as tags necessarias
				xml->addItem("idUFOperadora", Registro(x)->cidUFOperadora );
				xml->addItem("idPessoaDeParaOperadora", Registro(x)->cidPessoaDeParaOperadora );
				xml->addItem("idUF", Registro(x)->cidUF );
			}
			//So fecha um tag se abriu anteriormente
			xml->closeTag();
		}
	}
}

void CUFOperadora::GetXmlFrm( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	char cdsUfo[300];
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			xml->createTag(cNomeTag);
			xml->addProp("xmlns:ns1", "usuario.fo.vivo.com.br/vo" );
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{
				//Adiciona as tags necessarias
				memset( cdsUfo, 0, sizeof( cdsUfo ) );
				sprintf( cdsUfo, "%s - %s", Registro(x)->csgUF, Registro(x)->cnmUFOperadora );
				xml->addItem("ns1:idUFOperadora", Registro(x)->cidUFOperadora );
				xml->addItem("ns1:dsUFOperadora", cdsUfo );
			}
			//So fecha um tag se abriu anteriormente
			xml->closeTag();
		}
	}
}

void CUFOperadora::GetXmlPadrao( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	char cdsUfo[300];
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			if( strlennull( cNomeTag ) > 0 )
				xml->createTag(cNomeTag);
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{
				//Adiciona as tags necessarias
				memset( cdsUfo, 0, sizeof( cdsUfo ) );
				sprintf( cdsUfo, "%s - %s", Registro(x)->csgUF, Registro(x)->cnmUFOperadora );
				xml->addItem("idUFOperadora", Registro(x)->cidUFOperadora );
				xml->addItem("dsUFOperadora", cdsUfo );
			}
			//So fecha um tag se abriu anteriormente
			if( strlennull( cNomeTag ) > 0 )
				xml->closeTag();
		}
	}
}
int CUFOperadora::Relacionadas( char* cidContato )
{
    ULOG_START("CUFOperadora::Relacionadas() Parametro cidContato");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		struct
		{
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stnmUFOperadora[255+1];
			VARCHAR stidPessoaDeParaOperadora[21+1];
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
		} stUFOperadoraRegistro;
		struct
		{
			short iidUFOperadora;
			short inmUFOperadora;
			short iidPessoaDeParaOperadora;
			short iidUF;
			short isgUF;
			short inmUF;
		} stUFOperadoraIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraUFOperadora();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoRelacionados;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		/*
        EXEC SQL
   			DECLARE
   				CursorRelacionados CURSOR FOR
	   		SELECT DISTINCT
	   			 CONTATOFOLHACAMPO.IDUFOPERADORA
                ,CONTATOFOLHACAMPO.NMPESSOA
				,CONTATOFOLHACAMPO.IDPESSOADEPARAOPERADORA
				,CONTATOFOLHACAMPO.IDUF
                ,CONTATOFOLHACAMPO.SGUF
                ,CONTATOFOLHACAMPO.NMUF
			FROM
				CONTATOADM.CONTATOFOLHACAMPOB01 CONTATOFOLHACAMPO
			WHERE
				CONTATOFOLHACAMPO.IDCONTATO = :cAuxidContato;
        */
        
        EXEC SQL
        DECLARE CursorRelacionados CURSOR FOR
        SELECT DISTINCT
             UFOPERADORA.IDUFOPERADORA
            ,PESSOA.NMPESSOA
            ,PESSOADEPARA.IDPESSOADEPARA
            ,UF.IDUF
            ,UF.SGUF
            ,UF.NMUF
        FROM
            CONTATOADM.CONTATOUFOPERADORA   CONTATOUFOPERADORA
           ,APOIO.UF                        UF
           ,CUSTOMER.UFOPERADORA            UFOPERADORA                    
           ,CUSTOMER.OPERADORA              OPERADORA
           ,CUSTOMER.PESSOA                 PESSOA
           ,CUSTOMER.PESSOADEPARA           PESSOADEPARA
        WHERE
            CONTATOUFOPERADORA.IDCONTATO = :cAuxidContato
        AND CONTATOUFOPERADORA.IDUFOPERADORA = UFOPERADORA.IDUFOPERADORA
        AND UFOPERADORA.IDUF = UF.IDUF
        AND UFOPERADORA.IDPESSOADEPARAOPERADORA = OPERADORA.IDPESSOADEPARAOPERADORA
        AND PESSOA.IDPESSOA = PESSOADEPARA.IDPESSOA
        AND PESSOADEPARA.IDPESSOADEPARA = OPERADORA.IDPESSOADEPARAOPERADORA;
        
        //Abre o cursor
		EXEC SQL OPEN CursorRelacionados;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CUFOperadora::Relacionadas()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stUFOperadoraRegistro, 0, sizeof(stUFOperadoraRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorRelacionados INTO :stUFOperadoraRegistro:stUFOperadoraIndicator;
				//Adiciona a classe
				Add(
					(char*)stUFOperadoraRegistro.stidUFOperadora.arr
				   ,(char*)stUFOperadoraRegistro.stnmUFOperadora.arr
				   ,(char*)stUFOperadoraRegistro.stidPessoaDeParaOperadora.arr
				   ,(char*)stUFOperadoraRegistro.stidUF.arr
				   ,(char*)stUFOperadoraRegistro.stsgUF.arr
				   ,(char*)stUFOperadoraRegistro.stnmUF.arr
				);
				//conta quantos existem
				iCont++;
			}
			//Fecha o Relacionados
			EXEC SQL CLOSE CursorRelacionados;
		}
		ULOG_END("CUFOperadora::Relacionadas()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoRelacionados:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUFOperadora::NaoRelacionadas( char* cidContato )
{
    ULOG_START("CUFOperadora::NaoRelacionadas()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		struct
		{
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stnmUFOperadora[255+1];
			VARCHAR stidPessoaDeParaOperadora[21+1];
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
		} stUFOperadoraRegistro;
		struct
		{
			short iidUFOperadora;
			short inmUFOperadora;
			short iidPessoaDeParaOperadora;
			short iidUF;
			short isgUF;
			short inmUF;
		} stUFOperadoraIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraUFOperadora();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoNaoRelacionados;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		/*
        EXEC SQL
   			DECLARE
   				CursorNaoRelacionados CURSOR FOR
	   		SELECT DISTINCT
	   			 UFOPERADORA.IDUFOPERADORA
                ,UFOPERADORA.NMPESSOA
				,UFOPERADORA.IDPESSOADEPARAOPERADORA
				,UFOPERADORA.IDUF
                ,UFOPERADORA.SGUF
                ,UFOPERADORA.NMUF
			FROM
				CUSTOMER.UFOPERADORAB01 UFOPERADORA
            WHERE
                UFOPERADORA.IDUFOPERADORA NOT IN
                (
        	   		SELECT
        	   			IDUFOPERADORA
        			FROM
        				CONTATOADM.CONTATOFOLHACAMPO
                    WHERE
                        IDCONTATO = :cAuxidContato
                )
         	AND
         		UFOPERADORA.IDUFOPERADORA > 0;
        */
        
        EXEC SQL
        DECLARE
            CursorNaoRelacionados CURSOR FOR
        SELECT DISTINCT
             UFOPERADORA.IDUFOPERADORA
            ,PESSOA.NMPESSOA
            ,UFOPERADORA.IDPESSOADEPARAOPERADORA
            ,UF.IDUF
            ,UF.SGUF
            ,UF.NMUF
        FROM
            CUSTOMER.UFOPERADORA            UFOPERADORA                    
           ,CUSTOMER.OPERADORA              OPERADORA
           ,CUSTOMER.PESSOA                 PESSOA
           ,CUSTOMER.PESSOADEPARA           PESSOADEPARA
           ,APOIO.UF                        UF
        WHERE
            UFOPERADORA.IDPESSOADEPARAOPERADORA = OPERADORA.IDPESSOADEPARAOPERADORA
        AND PESSOA.IDPESSOA = PESSOADEPARA.IDPESSOA
        AND PESSOADEPARA.IDPESSOADEPARA = OPERADORA.IDPESSOADEPARAOPERADORA
        AND UFOPERADORA.IDUF = UF.IDUF
        AND UFOPERADORA.IDUFOPERADORA NOT IN
            (
                SELECT
                    IDUFOPERADORA
                FROM
                    CONTATOADM.CONTATOFOLHACAMPO
                WHERE
                    IDCONTATO = :cAuxidContato
            )
        AND
            UFOPERADORA.IDUFOPERADORA > 0;
        
		//Abre o cursor
		EXEC SQL OPEN CursorNaoRelacionados;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		   ULOG_END("CUFOperadora::NaoRelacionadas()");
           return 0;//Erro
        }
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stUFOperadoraRegistro, 0, sizeof(stUFOperadoraRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorNaoRelacionados INTO :stUFOperadoraRegistro:stUFOperadoraIndicator;
				//Adiciona a classe
				Add(
					(char*)stUFOperadoraRegistro.stidUFOperadora.arr
				   ,(char*)stUFOperadoraRegistro.stnmUFOperadora.arr
				   ,(char*)stUFOperadoraRegistro.stidPessoaDeParaOperadora.arr
				   ,(char*)stUFOperadoraRegistro.stidUF.arr
				   ,(char*)stUFOperadoraRegistro.stsgUF.arr
				   ,(char*)stUFOperadoraRegistro.stnmUF.arr
				);
				//conta quantos existem
				iCont++;
			}
			//Fecha o NaoRelacionados
			EXEC SQL CLOSE CursorNaoRelacionados;
		}
		ULOG_END("CUFOperadora::NaoRelacionadas()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoNaoRelacionados:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUFOperadora::Relacionadas( char* cidContato, char* cidFaseProcesso )
{
    ULOG_START("CUFOperadora::Relacionadas() Parametro cidContato, cidFaseProcesso");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		char* cAuxidFaseProcesso = cidFaseProcesso;
		struct
		{
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stnmUFOperadora[255+1];
			VARCHAR stidPessoaDeParaOperadora[21+1];
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
		} stUFOperadoraRegistro;
		struct
		{
			short iidUFOperadora;
			short inmUFOperadora;
			short iidPessoaDeParaOperadora;
			short iidUF;
			short isgUF;
			short inmUF;
		} stUFOperadoraIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraUFOperadora();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoRelacionadasFase;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
        // Esta query foi otimizada conforme incidência de Homologação Vivo 4328
   		EXEC SQL
   			DECLARE
   				CursorRelacionadasFase CURSOR FOR
	   		SELECT DISTINCT
	   			 CONTATOFOLHACAMPO.IDUFOPERADORA
	        ,PESSOA.NMPESSOA
	        ,UFOPERADORA.IDPESSOADEPARAOPERADORA
	        ,UFOPERADORA.IDUF
	        ,UF.SGUF
	        ,UF.NMUF
        FROM CONTATOADM.CAMPO CAMPO,
            CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
            CONTATOADM.FASEPROCESSO FASEPROCESSO,
            APOIO.TIPOLINHA TIPOLINHA,
            CUSTOMER.UFOPERADORA UFOPERADORA,
	        APOIO.UF UF,
            CONTATOADM.CONTATOFOLHACAMPO CONTATOFOLHACAMPO,
	        CUSTOMER.PESSOA PESSOA,
	        CUSTOMER.OPERADORA OPERADORA,
	        CUSTOMER.PESSOADEPARA PESSOADEPARA
        WHERE CONTATOFOLHACAMPO.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
	        AND CONTATOFOLHACAMPO.IDCAMPO = CAMPO.IDCAMPO
	        AND CONTATOFOLHACAMPO.IDCONTATO = CONTATOFOLHA.IDCONTATO
	        AND CONTATOFOLHACAMPO.IDFASEPROCESSO = FASEPROCESSO.IDFASEPROCESSO
	        AND CONTATOFOLHACAMPO.IDUFOPERADORA = UFOPERADORA.IDUFOPERADORA
	        AND UF.IDUF = UFOPERADORA.IDUF
	        AND UFOPERADORA.IDPESSOADEPARAOPERADORA = OPERADORA.IDPESSOADEPARAOPERADORA
	        AND PESSOADEPARA.IDPESSOADEPARA = OPERADORA.IDPESSOADEPARAOPERADORA
	        AND PESSOADEPARA.IDPESSOA = PESSOA.IDPESSOA
	        AND CONTATOFOLHACAMPO.IDCONTATO = :cAuxidContato
	        AND CONTATOFOLHACAMPO.IDFASEPROCESSO = :cAuxidFaseProcesso;


		//Abre o cursor
		EXEC SQL OPEN CursorRelacionadasFase;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CUFOperadora::Relacionadas()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stUFOperadoraRegistro, 0, sizeof(stUFOperadoraRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorRelacionadasFase INTO :stUFOperadoraRegistro:stUFOperadoraIndicator;
				//Adiciona a classe
				Add(
					(char*)stUFOperadoraRegistro.stidUFOperadora.arr
				   ,(char*)stUFOperadoraRegistro.stnmUFOperadora.arr
				   ,(char*)stUFOperadoraRegistro.stidPessoaDeParaOperadora.arr
				   ,(char*)stUFOperadoraRegistro.stidUF.arr
				   ,(char*)stUFOperadoraRegistro.stsgUF.arr
				   ,(char*)stUFOperadoraRegistro.stnmUF.arr
				);
				//conta quantos existem
				iCont++;
			}
			//Fecha o RelacionadasFase
			EXEC SQL CLOSE CursorRelacionadasFase;
		}

		ULOG_END("CUFOperadora::Relacionadas()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoRelacionadasFase:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CUFOperadora::NaoRelacionadas( char* cidContato, char* cidFaseProcesso )
{
    ULOG_START("CUFOperadora::NaoRelacionadas()");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidContato = cidContato;
		char* cAuxidFaseProcesso = cidFaseProcesso;
		struct
		{
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stnmUFOperadora[255+1];
			VARCHAR stidPessoaDeParaOperadora[21+1];
			VARCHAR stidUF[21+1];
			VARCHAR stsgUF[255+1];
			VARCHAR stnmUF[255+1];
		} stUFOperadoraRegistro;
		struct
		{
			short iidUFOperadora;
			short inmUFOperadora;
			short iidPessoaDeParaOperadora;
			short iidUF;
			short isgUF;
			short inmUF;
		} stUFOperadoraIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraUFOperadora();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoNaoRelacionadasFase;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		EXEC SQL
   			DECLARE
   				CursorNaoRelacionadasFase CURSOR FOR
	   		SELECT DISTINCT
	   			 UFOPERADORA.IDUFOPERADORA
                  ,PESSOA.NMPESSOA
				,UFOPERADORA.IDPESSOADEPARAOPERADORA
		          ,UF.IDUF
                  ,UF.SGUF
                  ,UF.NMUF
             FROM CUSTOMER.OPERADORA OPERADORA,
                  APOIO.UF UF,
                  CUSTOMER.UFOPERADORA UFOPERADORA,
                  CUSTOMER.PESSOA PESSOA,
	              CUSTOMER.PESSOADEPARA PESSOADEPARA
            WHERE UFOPERADORA.IDUF = UF.IDUF
              AND UFOPERADORA.IDPESSOADEPARAOPERADORA = OPERADORA.IDPESSOADEPARAOPERADORA
	          AND UFOPERADORA.IDPESSOADEPARAOPERADORA = OPERADORA.IDPESSOADEPARAOPERADORA
	          AND PESSOADEPARA.IDPESSOADEPARA = OPERADORA.IDPESSOADEPARAOPERADORA
	          AND PESSOADEPARA.IDPESSOA = PESSOA.IDPESSOA
              AND UFOPERADORA.IDUFOPERADORA NOT IN
                (
        	   		SELECT
        	   			IDUFOPERADORA
        			FROM
	       				        CONTATOADM.CONTATOFOLHACAMPO
                    WHERE
                        IDCONTATO = :cAuxidContato
					AND
						IDFASEPROCESSO = :cAuxidFaseProcesso
                )
   	          AND UFOPERADORA.IDUFOPERADORA > 0;

		//Abre o cursor
		EXEC SQL OPEN CursorNaoRelacionadasFase;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
		{
		    ULOG_END("CUFOperadora::NaoRelacionadas()");
			return 0;//Erro
		}
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stUFOperadoraRegistro, 0, sizeof(stUFOperadoraRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorNaoRelacionadasFase INTO :stUFOperadoraRegistro:stUFOperadoraIndicator;
				//Adiciona a classe
				Add(
					(char*)stUFOperadoraRegistro.stidUFOperadora.arr
				   ,(char*)stUFOperadoraRegistro.stnmUFOperadora.arr
				   ,(char*)stUFOperadoraRegistro.stidPessoaDeParaOperadora.arr
				   ,(char*)stUFOperadoraRegistro.stidUF.arr
				   ,(char*)stUFOperadoraRegistro.stsgUF.arr
				   ,(char*)stUFOperadoraRegistro.stnmUF.arr
				);
				//conta quantos existem
				iCont++;
			}
			//Fecha o NaoRelacionadasFase
			EXEC SQL CLOSE CursorNaoRelacionadasFase;
		}
		ULOG_END("CUFOperadora::NaoRelacionadas()");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoNaoRelacionadasFase:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}
