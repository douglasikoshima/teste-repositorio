#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CRes.h"

CResposta::CResposta()
{
}

CResposta::~CResposta()
{
}

int CResposta::Mover( char* cidResposta
				     ,int   inMoveUp
					 ,char* cLogUser )
{
    ULOG_START("CResposta::Mover()");
	//Declarar Estruturas
	struct sqlca sqlca; 
	
	//Declarar Variaveis e Estruturas para uso na PL/SQL
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR  stidPergunta[21+1];
		short    iRegidItemMen;
		VARCHAR  cRegidResposta[21+1];
		char* cAuxLogUser     = cLogUser;
		char* cAuxidResposta  = cidResposta;
		int   inMoverParaCima = 0;//default: para cima
		int   inMoverParaCimaAux;
		int   iCont;
		int   iRespostaAtual = 0;
	EXEC SQL END DECLARE SECTION;

	/************************************************************************
	 * Processamento Principal
	 ************************************************************************/
	memset( &stidPergunta, 0, sizeof( stidPergunta ) );
	if( strlennull( cidResposta ) <= 0 )
	{
	    ULOG_END("CResposta::Mover()");
		return 1;
	}

	if( strlennull( cLogUser ) <= 0 )
	{
	    ULOG_END("CResposta::Mover()");
		return 2;
	}

	if( inMoveUp <= 0 )
		inMoverParaCima = 1;//Dependendo do parametro de entrada, muda para baixo
	
	sqlca.sqlcode=0;
	EXEC SQL WHENEVER SQLERROR GOTO GotoMover;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	//Recupera o id do Pergunta, para poder recuperar as repostas e ordena-las
	EXEC SQL
		SELECT
			IDPERGUNTA
		INTO
			:stidPergunta
		FROM
			QUESTIONARIO.RESPOSTA
		WHERE
			IDRESPOSTA = :cAuxidResposta
		AND 
			ROWNUM <= 1;

	//Recupera todas as perguntas do Pergunta em questao, no qual a pergunta faz parte
	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL
		DECLARE 
			CursorMover CURSOR FOR
		SELECT 
			IDRESPOSTA
		FROM
			QUESTIONARIO.RESPOSTA
		WHERE
			IDPERGUNTA = :stidPergunta
		ORDER BY 
			SQAPRESENTACAO;

	EXEC SQL OPEN CursorMover;
	
	//Recupera todas as respostas relativas a mesma Pergunta que a resposta em questao
	//para reordena-las todas, para garantir a integridade
	for(iCont = 0;;iCont++)
	{
		memset( &cRegidResposta, 0, sizeof( cRegidResposta ) );
		EXEC SQL FETCH CursorMover INTO :cRegidResposta:iRegidItemMen;
		if( strcmp( (char*)cRegidResposta.arr, cAuxidResposta ) == 0 )
			iRespostaAtual = iCont;//Salva a posicao
		Add( (char*)cRegidResposta.arr
			,iCont );
	}
	EXEC SQL CLOSE CursorMover;

	if( Quantidade() <= 1 )
	{
	    ULOG_END("CResposta::Mover()");
		return 3;//Nao ha registros para relizar as modificacoes de posicoes
	}

	//Soh realiza alguma operacao se nao for a primeira a tentar mover para cima 
	//ou nao for a ultima e tentar mover para baixo
	if( !( ( ( iRespostaAtual == (Quantidade()-1) ) && ( inMoverParaCima ) ) 
	    || ( ( iRespostaAtual == 0 ) && ( !inMoverParaCima ) ) ) )
	{
		//Troca a numeracao, dependendo da escolha
		if( !inMoverParaCima )
			inMoverParaCima = -1;
		Registro(iRespostaAtual)->isqApresentacao = Registro(iRespostaAtual)->isqApresentacao + inMoverParaCima;
		inMoverParaCimaAux = inMoverParaCima*(-1);
		Registro(iRespostaAtual+inMoverParaCima)->isqApresentacao = Registro(iRespostaAtual)->isqApresentacao + inMoverParaCimaAux;
	}
	else
	{
	    ULOG_END("CResposta::Mover()");
		return 4;//Eh a primeiro ou ultima e tentou mover para o lado que nao da mais
	}

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	//Acerta todas as sequencias do mesmo quastionario que o ID passado com parametro
	for(iCont = 0;iCont < Quantidade();iCont++)
	{
		cAuxidResposta = Registro(iCont)->cidResposta;
		iRespostaAtual = Registro(iCont)->isqApresentacao;
		EXEC SQL 
			UPDATE
				QUESTIONARIO.RESPOSTA 
			SET 	
				SQAPRESENTACAO     = :iRespostaAtual,
				IDUSUARIOALTERACAO = :cAuxLogUser, 
				DTULTIMAALTERACAO  =  SYSDATE
			WHERE 	
				IDRESPOSTA = :cAuxidResposta;
	}
	ULOG_END("CResposta::Mover()");
	return 0;

/************************************************************************
 * Tratamento de Exception
 ************************************************************************/

GotoMover:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}


int CResposta::Insert( char* cidPergunta, 
					   char* cdsResposta, 
					   char* cdsScriptResposta, 
					   char* cinEncerramento,
					   char* cinDisponibilidade,
				       char* cidPerguntaSalto,
				       char* cinAtivo,
				       char* cidUser )
{
    ULOG_START("CResposta::Insert()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidUser      = cidUser;
		VARCHAR stAuxidResposta[21+1];
		char* cAuxidPergunta  = cidPergunta;
		char* cAuxdsResposta  = cdsResposta;
		char* cAuxdsScriptResposta  = cdsScriptResposta;
		VARCHAR stsqApresentacao[21+1];
		char* cAuxinEncerramento  = cinEncerramento;
		char* cAuxinDisponibilidade = cinDisponibilidade;
		char* cAuxidPerguntaSalto = cidPerguntaSalto;
		char* cAuxinAtivo = cinAtivo;
	EXEC SQL END DECLARE SECTION;
	
	ZeraResposta();
	
	memset( &stAuxidResposta, 0, sizeof(stAuxidResposta) );
	memset( &stsqApresentacao, 0, sizeof(stsqApresentacao) );
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;
	sqlca.sqlcode=0;

	EXEC SQL
		SELECT
			IDRESPOSTA
		INTO
			:stAuxidResposta
		FROM
			QUESTIONARIO.RESPOSTA
		WHERE
			IDPERGUNTA = :cAuxidPergunta
		AND
			TRIM(UPPER(DSRESPOSTA)) = TRIM(UPPER(:cAuxdsResposta));

	//Reposta ja existe para esta pergunta
	if( stAuxidResposta.len > 0 )
	{
	    ULOG_END("CResposta::Insert()");
		return 0;//Warning
	}

	//Recupera a quantidade de repostas de uma certa pergunta
	EXEC SQL
		SELECT
			COUNT(IDRESPOSTA)
		INTO
			:stsqApresentacao
		FROM
			QUESTIONARIO.RESPOSTA
		WHERE
			IDPERGUNTA = :cAuxidPergunta;

	memset( &stAuxidResposta, 0, sizeof(stAuxidResposta) );
	//Pega um id unico e sequencia para a insercao
	EXEC SQL
		SELECT QUESTIONARIO.RESPOSTASQ.NEXTVAL
		INTO :stAuxidResposta
		FROM DUAL;

	EXEC SQL 
		INSERT INTO QUESTIONARIO.RESPOSTA
		  (IDRESPOSTA, 
		   IDPERGUNTA, 
		   DSRESPOSTA, 
		   INDISPONIBILIDADE, 
		   SQAPRESENTACAO, 
		   DSSCRIPTRESPOSTA, 
		   INENCERRAMENTO,
		   IDUSUARIOALTERACAO,
		   DTULTIMAALTERACAO)
		VALUES
		  (:stAuxidResposta, 
		   :cAuxidPergunta, 
		   :cAuxdsResposta, 
		   :cAuxinDisponibilidade, 
		   :stsqApresentacao, 
		   :cAuxdsScriptResposta, 
		   :cAuxinEncerramento,
		   :cAuxidUser,
		   SYSDATE);
	
	if( sqlca.sqlcode != 0 )
	{
	    ULOG_END("CResposta::Insert()");
		return 0;
	}
		
	if( strlennull( cAuxidPerguntaSalto ) > 0 )
	{
		EXEC SQL
			INSERT INTO QUESTIONARIO.RESPOSTAPROXIMAPERGUNTA
			  (IDRESPPXPERG,
			   INATIVO,
			   IDRESPOSTA,
			   IDPERGUNTA,
			   IDUSUARIOALTERACAO,
			   DTULTIMAALTERACAO)
			VALUES
			  (QUESTIONARIO.RESPOSTAPROXIMAPERGUNTASQ.NEXTVAL,
			   :cAuxinAtivo,
			   :stAuxidResposta,
			   :cAuxidPerguntaSalto,
			   :cAuxidUser,
			   SYSDATE);
			   
		if( sqlca.sqlcode != 0 )
		{
		    ULOG_END("CResposta::Insert()");
			return 0;
		}
	}
	
	Add( (char*)stAuxidResposta.arr, 
         cAuxidPergunta, 
	     cAuxdsResposta, 
	     cAuxdsScriptResposta, 
	     (char*)stsqApresentacao.arr,
	     cAuxinEncerramento,
	     cAuxinDisponibilidade,
	     cAuxidPerguntaSalto,
	     cAuxinAtivo );
	     
	ULOG_END("CResposta::Insert()");	   
	return 1;//Sucesso

GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CResposta::Update( char* cidResposta, 
                       char* cidPergunta, 
					   char* cdsResposta, 
					   char* cdsScriptResposta, 
					   char* cinEncerramento,
					   char* cinDisponibilidade,
				       char* cidPerguntaSalto,
				       char* cinAtivo,
				       char* cidUser )
{
    ULOG_START("CResposta::Update()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR stAuxidResposta[21+1];
		char* cAuxidUser      = cidUser;
		char* cAuxidResposta  = cidResposta;
		char* cAuxidPergunta  = cidPergunta;
		char* cAuxdsResposta  = cdsResposta;
		char* cAuxdsScriptResposta  = cdsScriptResposta;
		char* cAuxinEncerramento  = cinEncerramento;
		char* cAuxinDisponibilidade = cinDisponibilidade;
		char* cAuxidPerguntaSalto = cidPerguntaSalto;
		char* cAuxinAtivo = cinAtivo;
	EXEC SQL END DECLARE SECTION;

	ZeraResposta();
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
	sqlca.sqlcode=0;

	memset( &stAuxidResposta, 0, sizeof(stAuxidResposta) );
	EXEC SQL
		SELECT
			IDRESPOSTA
		INTO
			:stAuxidResposta
		FROM
			QUESTIONARIO.RESPOSTA
		WHERE
			IDPERGUNTA = :cAuxidPergunta
		AND
			TRIM(UPPER(DSRESPOSTA)) = TRIM(UPPER(:cAuxdsResposta))
		AND
			IDRESPOSTA <> :cAuxidResposta
		AND 
			ROWNUM <= 1;
	
	//Reposta ja existe para esta pergunta
	if( stAuxidResposta.len > 0 )
	{
	    ULOG_END("CResposta::Update()");
		return 0;
	}

	EXEC SQL 
		UPDATE QUESTIONARIO.RESPOSTA
		   SET DSRESPOSTA        = :cAuxdsResposta,
		       INENCERRAMENTO    = :cAuxinEncerramento,
		       INDISPONIBILIDADE = :cAuxinDisponibilidade,
		       DSSCRIPTRESPOSTA  = :cAuxdsScriptResposta,
		       IDUSUARIOALTERACAO = :cAuxidUser,
		       DTULTIMAALTERACAO = SYSDATE
		 WHERE IDRESPOSTA = :cAuxidResposta;   
	
	EXEC SQL
		DELETE 
			QUESTIONARIO.RESPOSTAPROXIMAPERGUNTA
		WHERE
			IDRESPOSTA = :cAuxidResposta;
			
	sqlca.sqlcode = 0;

	if( strlennull( cAuxidPerguntaSalto ) > 0 )
	{
		EXEC SQL
			INSERT INTO QUESTIONARIO.RESPOSTAPROXIMAPERGUNTA
			  (IDRESPPXPERG,
			   INATIVO,
			   IDRESPOSTA,
			   IDPERGUNTA,
			   IDUSUARIOALTERACAO,
			   DTULTIMAALTERACAO)
			VALUES
			  (QUESTIONARIO.RESPOSTAPROXIMAPERGUNTASQ.NEXTVAL,
			   :cAuxinAtivo,
			   :cAuxidResposta,
			   :cAuxidPerguntaSalto,
			   :cAuxidUser,
			   SYSDATE);
	}
	
	if( strlennull( cAuxidPerguntaSalto ) <= 0 )
	{
		Add( cAuxidResposta, 
	         cAuxidPergunta, 
		     cAuxdsResposta, 
		     cAuxdsScriptResposta, 
		     "",
		     cAuxinEncerramento,
		     cAuxinDisponibilidade,
		     "",
		     "" );
	}
	else
	{
		Add( cAuxidResposta, 
	         cAuxidPergunta, 
		     cAuxdsResposta, 
		     cAuxdsScriptResposta, 
		     "",
		     cAuxinEncerramento,
		     cAuxinDisponibilidade,
		     cAuxidPerguntaSalto,
		     cAuxinAtivo );
	}
	ULOG_END("CResposta::Update()");
	return 1;

GotoUpdate:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);	
}


int CResposta::ListId( char* cidResposta )
{
    ULOG_START("CResposta::ListId()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidResposta = cidResposta;
		struct
		{
			VARCHAR stidResposta[21+1];
			VARCHAR stidPergunta[21+1];
			VARCHAR stdsResposta[256+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stsqApresentacao[21+1];
			VARCHAR stdsScriptResposta[256+1];
			VARCHAR stinEncerramento[21+1];
			VARCHAR stidPerguntaSalto[21+1];
			VARCHAR stinAtivo[21+1];
		} stRespostaRegistro;
		struct
		{
			short iidResposta;
			short iidPergunta;
			short idsResposta;
			short iinDisponibilidade;
			short isqApresentacao;
			short idsScriptResposta;
			short iinEncerramento;
			short iidPerguntaSalto;
			short iinAtivo;
		} stRespostaIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraResposta();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
	sqlca.sqlcode=0;

   	EXEC SQL 
   		DECLARE 
   			CursorRespostaId CURSOR FOR
		SELECT 
			IDRESPOSTA, 
		    IDPERGUNTA, 
		    DSRESPOSTA, 
		    INDISPONIBILIDADE, 
		    SQAPRESENTACAO, 
		    DSSCRIPTRESPOSTA, 
		    INENCERRAMENTO,
		    INATIVO,
		    IDPERGUNTASALTO
		  FROM 
		  	QUESTIONARIO.RESPOSTAV01
		 WHERE 
		 	IDRESPOSTA = :cAuxidResposta;

	EXEC SQL OPEN CursorRespostaId;

	if(sqlca.sqlcode)
	{
	    ULOG_END("CResposta::ListId()");
		return 0;
	}
	else
	{
		for(;;)
		{
			memset( &stRespostaRegistro, 0, sizeof(stRespostaRegistro) );
			EXEC SQL FETCH CursorRespostaId INTO :stRespostaRegistro:stRespostaIndicator;

			Add( (char*)stRespostaRegistro.stidResposta.arr, 
			     (char*)stRespostaRegistro.stidPergunta.arr,
			     (char*)stRespostaRegistro.stdsResposta.arr,
			     (char*)stRespostaRegistro.stdsScriptResposta.arr,
			     (char*)stRespostaRegistro.stsqApresentacao.arr,
			     (char*)stRespostaRegistro.stinEncerramento.arr,
			     (char*)stRespostaRegistro.stinDisponibilidade.arr,
			     (char*)stRespostaRegistro.stidPerguntaSalto.arr,
			     (char*)stRespostaRegistro.stinAtivo.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorRespostaId;
	}
	
    ULOG_END("CResposta::ListId()");
	return iCont;

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CResposta::ListAll( void )
{
    ULOG_START("CResposta::ListAll()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidResposta[21+1];
			VARCHAR stidPergunta[21+1];
			VARCHAR stdsResposta[256+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stsqApresentacao[21+1];
			VARCHAR stdsScriptResposta[256+1];
			VARCHAR stinEncerramento[21+1];
			VARCHAR stidPerguntaSalto[21+1];
			VARCHAR stinAtivo[21+1];
		} stRespostaRegistro;
		struct
		{
			short iidResposta;
			short iidPergunta;
			short idsResposta;
			short iinDisponibilidade;
			short isqApresentacao;
			short idsScriptResposta;
			short iinEncerramento;
			short iidPerguntaSalto;
			short iinAtivo;
		} stRespostaIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraResposta();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
	sqlca.sqlcode=0;

   	EXEC SQL 
   		DECLARE 
   			CursorRespostaAll CURSOR FOR
		SELECT 
			IDRESPOSTA, 
		    IDPERGUNTA, 
		    DSRESPOSTA, 
		    INDISPONIBILIDADE, 
		    SQAPRESENTACAO, 
		    DSSCRIPTRESPOSTA, 
		    INENCERRAMENTO,
		    INATIVO,
		    IDPERGUNTASALTO
		  FROM 
		  	QUESTIONARIO.RESPOSTAV01;

	EXEC SQL OPEN CursorRespostaAll;

	if(sqlca.sqlcode)
	{
	    ULOG_END("CResposta::ListAll()");
		return 0;
	}
	else
	{
		for(;;)
		{
			memset( &stRespostaRegistro, 0, sizeof(stRespostaRegistro) );
			EXEC SQL FETCH CursorRespostaAll INTO :stRespostaRegistro:stRespostaIndicator;

			Add( (char*)stRespostaRegistro.stidResposta.arr, 
			     (char*)stRespostaRegistro.stidPergunta.arr,
			     (char*)stRespostaRegistro.stdsResposta.arr,
			     (char*)stRespostaRegistro.stdsScriptResposta.arr,
			     (char*)stRespostaRegistro.stsqApresentacao.arr,
			     (char*)stRespostaRegistro.stinEncerramento.arr,
			     (char*)stRespostaRegistro.stinDisponibilidade.arr,
			     (char*)stRespostaRegistro.stidPerguntaSalto.arr,
			     (char*)stRespostaRegistro.stinAtivo.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorRespostaAll;
	}
	
    ULOG_END("CResposta::ListAll()");
	return iCont;

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CResposta::ListIdPergunta( char* cidPergunta )
{
    ULOG_START("CResposta::ListIdPergunta()");
	int    iCont = 0;
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidOra = cidPergunta;
		struct
		{
			VARCHAR stidResposta[21+1];
			VARCHAR stidPergunta[21+1];
			VARCHAR stdsResposta[256+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stsqApresentacao[21+1];
			VARCHAR stdsScriptResposta[256+1];
			VARCHAR stinEncerramento[21+1];
			VARCHAR stidPerguntaSalto[21+1];
			VARCHAR stinAtivo[21+1];
		} stRespostaRegistro;
		struct
		{
			short iidResposta;
			short iidPergunta;
			short idsResposta;
			short iinDisponibilidade;
			short isqApresentacao;
			short idsScriptResposta;
			short iinEncerramento;
			short iidPerguntaSalto;
			short iinAtivo;
		} stRespostaIndicator;
	EXEC SQL END DECLARE SECTION;

	ZeraResposta();

	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoListIdPergunta;
	sqlca.sqlcode=0;

   	EXEC SQL 
   		DECLARE 
   			CursorRespostaIdPergunta CURSOR FOR
		SELECT 
			IDRESPOSTA, 
		    IDPERGUNTA, 
		    DSRESPOSTA, 
		    INDISPONIBILIDADE, 
		    SQAPRESENTACAO, 
		    DSSCRIPTRESPOSTA, 
		    INENCERRAMENTO,
		    INATIVO,
		    IDPERGUNTASALTO
		  FROM 
		  	QUESTIONARIO.RESPOSTAV01
		 WHERE
		 	IDPERGUNTA = :cidOra
		 ORDER BY
			SQAPRESENTACAO;

	EXEC SQL OPEN CursorRespostaIdPergunta;

	if(sqlca.sqlcode)
	{
	    ULOG_END("CResposta::ListIdPergunta()");
		return 0;
	}
	else
	{
		for(;;)
		{
			memset( &stRespostaRegistro, 0, sizeof(stRespostaRegistro) );
			EXEC SQL FETCH CursorRespostaIdPergunta INTO :stRespostaRegistro:stRespostaIndicator;

			Add( (char*)stRespostaRegistro.stidResposta.arr, 
			     (char*)stRespostaRegistro.stidPergunta.arr,
			     (char*)stRespostaRegistro.stdsResposta.arr,
			     (char*)stRespostaRegistro.stdsScriptResposta.arr,
			     (char*)stRespostaRegistro.stsqApresentacao.arr,
			     (char*)stRespostaRegistro.stinEncerramento.arr,
			     (char*)stRespostaRegistro.stinDisponibilidade.arr,
			     (char*)stRespostaRegistro.stidPerguntaSalto.arr,
			     (char*)stRespostaRegistro.stinAtivo.arr );

			iCont++;

		}
		EXEC SQL CLOSE CursorRespostaIdPergunta;
	}

    ULOG_END("CResposta::ListIdPergunta()");
	return iCont;

GotoListIdPergunta:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CResposta::Delete( char* cidResposta )
{
    ULOG_START("CResposta::Delete()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidResposta = cidResposta;
	EXEC SQL END DECLARE SECTION;
	
	ZeraResposta();
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
	sqlca.sqlcode=0;

	//Apaga uma relacao
	EXEC SQL
		DELETE FROM 
			QUESTIONARIO.RESPOSTAPROXIMAPERGUNTA
		WHERE
			IDRESPOSTA = :cAuxidResposta;

	//Apaga uma reposta
	EXEC SQL
		DELETE FROM 
			QUESTIONARIO.RESPOSTA
		WHERE
			IDRESPOSTA = :cAuxidResposta;
			
		ULOG_END("CResposta::Delete()");	
		return 1;

GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if( sqlca.sqlcode == -2292 )
		return 0;
	else
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CResposta::DeleteIdPergunta( char* cidPergunta )
{
    ULOG_START("CResposta::DeleteIdPergunta()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidPergunta = cidPergunta;
		VARCHAR stidResposta[21+1];
	EXEC SQL END DECLARE SECTION;
	
	ZeraResposta();
	
	EXEC SQL WHENEVER NOT FOUND DO break;
	EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
	sqlca.sqlcode=0;

	EXEC SQL
		DECLARE 
			CursorDeleteIdResposta CURSOR FOR
		SELECT
			IDRESPOSTA
		INTO
			:stidResposta
		FROM
			QUESTIONARIO.RESPOSTA
		WHERE
			IDPERGUNTA = :cAuxidPergunta;
		
	EXEC SQL OPEN CursorDeleteIdResposta;
	
	for(;;)
	{
		memset( &stidResposta , 0, sizeof( stidResposta ) );
		EXEC SQL FETCH CursorDeleteIdResposta INTO :stidResposta;

		Delete( (char*)stidResposta.arr );

	}
	EXEC SQL CLOSE CursorDeleteIdResposta;
    ULOG_END("CResposta::DeleteIdPergunta()");
	return 1;

GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	if( sqlca.sqlcode == -2292 )
		return 0;
	else
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CResposta::VerifcaTipoPergunta( char* cidPergunta, char* csgTipoPergunta )
{
    ULOG_START("CResposta::VerifcaTipoPergunta()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidPerguntaAux     = cidPergunta;
		char* csgTipoPerguntaAux = csgTipoPergunta;
		int   iCont = 0;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO GotoVerifcaTipoPergunta;
	sqlca.sqlcode=0;

   	EXEC SQL 
	SELECT 
		COUNT(1)
	INTO
		:iCont
	FROM 
		QUESTIONARIO.PERGUNTA
	WHERE
		IDPERGUNTA = :cidPerguntaAux
	AND
		IDTIPOAPRESENTACAOPERGUNTA IN
		( 
			SELECT 
				IDTIPOAPRESENTACAOPERGUNTA 
			FROM
				APOIO.TIPOAPRESENTACAOPERGUNTA
			WHERE
				SGTIPOAPRESENTACAOPERGUNTA = :csgTipoPerguntaAux
		);
		
    ULOG_END("CResposta::VerifcaTipoPergunta()");
	return iCont;

GotoVerifcaTipoPergunta:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

void CResposta::GetXml( char* cNomeTag, XMLGen*xml )
{
	if( Quantidade() > 0 )
	{
		for( int x = 0; x < Quantidade(); x++ )
		{
			xml->createTag(cNomeTag);
			xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
			if( Registro( x ) != NULL )
			{
				xml->addItem("idResposta", Registro(x)->cidResposta );
				xml->addItem("dsResposta", Registro(x)->cdsResposta );
				xml->addItem("dsScriptResposta", Registro(x)->cdsScriptResposta );
				xml->addItem("inEncerramento", Registro(x)->cinEncerramento );
				xml->addItem("sqApresentacao", Registro(x)->csqApresentacao );
				xml->addItem("inDisponibilidade", Registro(x)->cinDisponibilidade );
				if( strlennull( Registro(x)->cidPerguntaSalto ) > 0 )
				{
					xml->createTag("AdmSaltoVO");
					xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
					xml->addItem("idPergunta", Registro(x)->cidPerguntaSalto );
					xml->addItem("ativo", Registro(x)->cinAtivo );
					xml->closeTag();
				}
			}
			xml->closeTag();
		}
	}
}
