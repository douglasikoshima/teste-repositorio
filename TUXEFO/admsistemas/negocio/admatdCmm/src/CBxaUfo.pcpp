#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CBxaUfo.h"

CBaixaUfoperadora::CBaixaUfoperadora()
{
}

CBaixaUfoperadora::~CBaixaUfoperadora()
{
}

int CBaixaUfoperadora::Insert( 
			char* cidBaixa,
			char* cidUFOperadora,
			char* cdtInicioVigencia,
			char* cdtFimVigencia,
			char* cinDisponibilidade,
			char* cidUsuarioAlteracao )
{
    ULOG_START("CBaixaUfoperadora::Insert");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR stidBaixaUFOperadora[21+1];
		char* cAuxidBaixa = cidBaixa;
		char* cAuxidUFOperadora = cidUFOperadora;
		char* cAuxdtInicioVigencia = cdtInicioVigencia;
		char* cAuxdtFimVigencia = cdtFimVigencia;
		char* cAuxinDisponibilidade = cinDisponibilidade;
		char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		//ZeraBaixaUfoperadora();
		memset( &stidBaixaUFOperadora, 0 , sizeof( stidBaixaUFOperadora ) );
		
		
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoInsert;

		EXEC SQL
			SELECT
				CONTATOADM.BAIXAUFOPERADORASQ.NEXTVAL
			INTO
				:stidBaixaUFOperadora
			FROM
				DUAL;
		
		if( strlennull( cAuxdtFimVigencia ) > 0 )
		{
			//Realiza o insert com data de fim
			EXEC SQL INSERT INTO CONTATOADM.BAIXAUFOPERADORA
			(	IDBAIXAUFOPERADORA,
				IDBAIXA,
				IDUFOPERADORA,
				DTINICIOVIGENCIA,
				DTFIMVIGENCIA,
				INDISPONIBILIDADE,
				IDUSUARIOALTERACAO,
				DTULTIMAALTERACAO) 
			VALUES 
			(	:stidBaixaUFOperadora,
				:cAuxidBaixa,
				:cAuxidUFOperadora,
				TO_DATE(:cAuxdtInicioVigencia, 'DD/MM/YYYY'),
				TO_DATE(:cAuxdtFimVigencia, 'DD/MM/YYYY'),
				:cAuxinDisponibilidade,
				:cAuxidUsuarioAlteracao,
				SYSDATE
			);
		} //if( strlennull( cAuxdtFimVigencia ) > 0 )
		else
		{
			//Realiza o insert
			EXEC SQL INSERT INTO CONTATOADM.BAIXAUFOPERADORA
			(	IDBAIXAUFOPERADORA,
				IDBAIXA,
				IDUFOPERADORA,
				DTINICIOVIGENCIA,
				INDISPONIBILIDADE,
				IDUSUARIOALTERACAO,
				DTULTIMAALTERACAO) 
			VALUES 
			(	:stidBaixaUFOperadora,
				:cAuxidBaixa,
				:cAuxidUFOperadora,
				TO_DATE(:cAuxdtInicioVigencia, 'DD/MM/YYYY'),
				:cAuxinDisponibilidade,
				:cAuxidUsuarioAlteracao,
				SYSDATE
			);
		}// else if( strlennull( cAuxdtFimVigencia ) > 0 )

		Add( (char*)stidBaixaUFOperadora.arr
			,cAuxidBaixa
			,cAuxidUFOperadora
			,""
			,cAuxdtInicioVigencia
			,cAuxdtFimVigencia
			,cAuxinDisponibilidade
			,"" );

        ULOG_END("CBaixaUfoperadora::Insert");
		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
			return 1;//Sucesso
	}
	catch(...)
	{
		throw;
	}
	
GotoInsert:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CBaixaUfoperadora::Update( 
			char* cidBaixaUFOperadora,
			char* cidBaixa,
			char* cidUFOperadora,
			char* cdtInicioVigencia,
			char* cdtFimVigencia,
			char* cinDisponibilidade,
			char* cidUsuarioAlteracao )
{
    ULOG_START("CBaixaUfoperadora::Update");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
			char* cAuxidBaixaUFOperadora = cidBaixaUFOperadora;
			char* cAuxidBaixa = cidBaixa;
			char* cAuxidUFOperadora = cidUFOperadora;
			char* cAuxdtInicioVigencia = cdtInicioVigencia;
			char* cAuxdtFimVigencia = cdtFimVigencia;
			char* cAuxinDisponibilidade = cinDisponibilidade;
			char* cAuxidUsuarioAlteracao = cidUsuarioAlteracao;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		//ZeraBaixaUfoperadora();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoUpdate;
		
		if( strlennull( cAuxdtFimVigencia ) > 0 )
		{
			//Executa a instrucao de update
			EXEC SQL 
				UPDATE 
					CONTATOADM.BAIXAUFOPERADORA
				SET	
					DTINICIOVIGENCIA = TO_DATE(:cAuxdtInicioVigencia, 'DD/MM/YYYY'),
					DTFIMVIGENCIA = TO_DATE( :cAuxdtFimVigencia, 'DD/MM/YYYY'),
					INDISPONIBILIDADE = :cAuxinDisponibilidade,
					IDUSUARIOALTERACAO = :cAuxidUsuarioAlteracao,
					DTULTIMAALTERACAO = SYSDATE
				WHERE
					IDUFOPERADORA = :cAuxidUFOperadora
				AND
					IDBAIXA = :cAuxidBaixa;
		}
		else
		{
			//Executa a instrucao de update
			EXEC SQL 
				UPDATE 
					CONTATOADM.BAIXAUFOPERADORA
				SET	
					DTINICIOVIGENCIA = TO_DATE(:cAuxdtInicioVigencia, 'DD/MM/YYYY'),
					DTFIMVIGENCIA = NULL,
					INDISPONIBILIDADE = :cAuxinDisponibilidade,
					IDUSUARIOALTERACAO = :cAuxidUsuarioAlteracao,
					DTULTIMAALTERACAO = SYSDATE
				WHERE
					IDUFOPERADORA = :cAuxidUFOperadora
				AND
					IDBAIXA = :cAuxidBaixa;
		}

		Add( ""
			,cAuxidBaixa
			,cAuxidUFOperadora
			,""
			,cAuxdtInicioVigencia
			,cAuxdtFimVigencia
			,cAuxinDisponibilidade
			,"" );
		
		ULOG_END("CBaixaUfoperadora::Update");
		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
			return 1;//Sucesso
	}
	catch(...)
	{
		throw;
	}

GotoUpdate:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
	
}

int CBaixaUfoperadora::Delete( char* cidBaixaUFOperadora )
{
    ULOG_START("CBaixaUfoperadora::Delete");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;	
		char* cAuxidBaixaUFOperadora = cidBaixaUFOperadora; 
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		//ZeraBaixaUfoperadora();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDelete;
		sqlca.sqlcode=0;
		
		//Executa a instrucao de delecao
		EXEC SQL 
			DELETE FROM 
				CONTATOADM.BAIXAUFOPERADORA
			WHERE 
				IDBAIXAUFOPERADORA = :cAuxidBaixaUFOperadora;
		ULOG_END("CBaixaUfoperadora::Delete");
		return 1;
	}
	catch(...)
	{
		throw;
	}

GotoDelete:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CBaixaUfoperadora::EraseFlh( char* cidBaixa ) 
{
    ULOG_START("CBaixaUfoperadora::EraseFlh");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;	
		char* cAuxidBaixa = cidBaixa; 
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaUfoperadora();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDeleteMM0;
		sqlca.sqlcode=0;
		
		//Executa a instrucao de delecao
		EXEC SQL 
			DELETE FROM 
				CONTATOADM.BAIXAUFOPERADORA
			WHERE IDBAIXA = :cAuxidBaixa;
		
	}
	catch(...)
	{
		throw;
	}
	ULOG_END("CBaixaUfoperadora::EraseFlh");
	return 1;

GotoDeleteMM0:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CBaixaUfoperadora::EraseUfo( char* cidUFOperadora ) 
{
    ULOG_START("CBaixaUfoperadora::EraseUfo");
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;	
		char* cAuxidUFOperadora = cidUFOperadora; 
	EXEC SQL END DECLARE SECTION;
	
	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaUfoperadora();
		
		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND CONTINUE;
		EXEC SQL WHENEVER SQLERROR GOTO GotoDeleteMM1;
		sqlca.sqlcode=0;
		
		//Executa a instrucao de delecao
		EXEC SQL 
		DELETE 
			FROM CONTATOADM.BAIXAUFOPERADORA
		WHERE 
			IDUFOPERADORA = :cAuxidUFOperadora;
		ULOG_END("CBaixaUfoperadora::EraseUfo");
		//Verifica se houve ou nao erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
			return sqlca.sqlerrd[2];//Quantidade de linhas afetadas
	}
	catch(...)
	{
		throw;
	}

GotoDeleteMM1:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);
}

int CBaixaUfoperadora::ListId( char* cidBaixaUFOperadora ) 
{
    ULOG_START("CBaixaUfoperadora::ListId");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidBaixaUFOperadora = cidBaixaUFOperadora; 
		struct
		{
			VARCHAR stidBaixaUFOperadora[21+1];
			VARCHAR stidBaixa[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stdsUFOperadora[265+1];
			VARCHAR stdtInicioVigencia[12+1];
			VARCHAR stdtFimVigencia[12+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stsgUF[255+1];
		} stBaixaUfoperadoraRegistro;
		struct
		{
			short iidBaixaUFOperadora;
			short iidBaixa;
			short iidUFOperadora;
			short idsUFOperadora;
			short idtInicioVigencia;
			short idtFimVigencia;
			short iinDisponibilidade;
			short isgUF;
		} stBaixaUfoperadoraIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaUfoperadora();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
		/*
   		EXEC SQL 
   			DECLARE 
   				CursorBaixaUfoperadoraId CURSOR FOR 
	   		SELECT
		   		IDBAIXAUFOPERADORA,
				IDBAIXA,
				IDUFOPERADORA,
				SGUF || ' - ' || NMPESSOA,
				TO_CHAR(DTINICIOVIGENCIA, 'DD/MM/YYYY'),
				TO_CHAR(DTFIMVIGENCIA, 'DD/MM/YYYY'),
				INDISPONIBILIDADE,
				SGUF
			FROM 
				CONTATOADM.BAIXAUFOPERADORABZEROUM
			WHERE 
				IDBAIXAUFOPERADORA = :cAuxidBaixaUFOperadora
			ORDER BY
				SGUF, NMPESSOA;
        */

   		EXEC SQL 
   			DECLARE 
   				CursorBaixaUfoperadoraId CURSOR FOR 
	   		SELECT
		   		BAIXAUFOPERADORA.IDBAIXAUFOPERADORA,
				BAIXA.IDBAIXA,
				UFOPERADORA.IDUFOPERADORA,
				UF.SGUF || ' - ' || PESSOA1.NMPESSOA,
				TO_CHAR(BAIXAUFOPERADORA.DTINICIOVIGENCIA, 'DD/MM/YYYY'),
				TO_CHAR(BAIXAUFOPERADORA.DTFIMVIGENCIA, 'DD/MM/YYYY'),
				BAIXAUFOPERADORA.INDISPONIBILIDADE,
				UF.SGUF
			FROM 
			    CONTATOADM.BAIXA            BAIXA,
                CONTATOADM.NOMEBAIXA        NOMEBAIXA,
 			    CUSTOMER.UFOPERADORA        UFOPERADORA,
			    CONTATOADM.BAIXAUFOPERADORA BAIXAUFOPERADORA,
                CUSTOMER.GRUPOOPERADORA     GRUPOOPERADORA,
 	            CUSTOMER.PESSOA             PESSOA1,
	            CUSTOMER.PESSOA             PESSOA2,
	            CUSTOMER.PESSOADEPARA       PESSOADEPARA,
                CUSTOMER.OPERADORA          OPERADORA,
			    APOIO.UF                    UF
            WHERE PESSOADEPARA.IDPESSOA = PESSOA1.IDPESSOA
            AND PESSOADEPARA.IDPESSOAORIGEM = PESSOA2.IDPESSOA
			AND OPERADORA.IDGRUPOOPERADORA = GRUPOOPERADORA.IDGRUPOOPERADORA
            AND OPERADORA.IDPESSOADEPARAOPERADORA = PESSOADEPARA.IDPESSOADEPARA
			AND UFOPERADORA.IDUF = UF.IDUF
			AND UFOPERADORA.IDPESSOADEPARAOPERADORA = OPERADORA.IDPESSOADEPARAOPERADORA
			AND BAIXAUFOPERADORA.IDBAIXA = BAIXA.IDBAIXA
            AND BAIXA.IDNOMEBAIXA = NOMEBAIXA.IDNOMEBAIXA
			AND BAIXAUFOPERADORA.IDUFOPERADORA = UFOPERADORA.IDUFOPERADORA
			AND BAIXAUFOPERADORA.IDBAIXAUFOPERADORA = :cAuxidBaixaUFOperadora
			ORDER BY UF.SGUF, UPPER(PESSOA1.NMPESSOA);
        
		//Abre o cursor
		EXEC SQL OPEN CursorBaixaUfoperadoraId;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stBaixaUfoperadoraRegistro, 0, sizeof(stBaixaUfoperadoraRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorBaixaUfoperadoraId INTO :stBaixaUfoperadoraRegistro:stBaixaUfoperadoraIndicator;
				//Adiciona a classe
				Add( (char*)stBaixaUfoperadoraRegistro.stidBaixaUFOperadora.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stidBaixa.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stidUFOperadora.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stdsUFOperadora.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stdtInicioVigencia.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stdtFimVigencia.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stinDisponibilidade.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stsgUF.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorBaixaUfoperadoraId;
		}
		ULOG_END("CBaixaUfoperadora::ListId");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CBaixaUfoperadora::ListIdBaixa( char* cidBaixa ) 
{
    ULOG_START("CBaixaUfoperadora::ListIdBaixa");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidBaixa = cidBaixa; 
		struct
		{
			VARCHAR stidBaixaUFOperadora[21+1];
			VARCHAR stidBaixa[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stdsUFOperadora[265+1];
			VARCHAR stdtInicioVigencia[12+1];
			VARCHAR stdtFimVigencia[12+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stsgUF[255+1];
		} stBaixaUfoperadoraRegistro;
		struct
		{
			short iidBaixaUFOperadora;
			short iidBaixa;
			short iidUFOperadora;
			short idsUFOperadora;
			short idtInicioVigencia;
			short idtFimVigencia;
			short iinDisponibilidade;
			short isgUF;
		} stBaixaUfoperadoraIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaUfoperadora();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListIdBaixa;
		sqlca.sqlcode=0;

		//Declara um cursor para listar os IDs
   		/*
   		EXEC SQL 
   			DECLARE 
   				CursorListIdBaixa CURSOR FOR 
	   		SELECT
		   		IDBAIXAUFOPERADORA,
				IDBAIXA,
				IDUFOPERADORA,
				SGUF || ' - ' || NMPESSOA,
				TO_CHAR(DTINICIOVIGENCIA, 'DD/MM/YYYY'),
				TO_CHAR(DTFIMVIGENCIA, 'DD/MM/YYYY'),
				INDISPONIBILIDADE,
				SGUF
			FROM 
				CONTATOADM.BAIXAUFOPERADORABZEROUM
			WHERE 
				IDBAIXA = :cAuxidBaixa;
        */
   		EXEC SQL 
   			DECLARE 
   				CursorListIdBaixa CURSOR FOR 
	   		SELECT
		   		BAIXAUFOPERADORA.IDBAIXAUFOPERADORA,
				BAIXA.IDBAIXA,
				UFOPERADORA.IDUFOPERADORA,
				UF.SGUF || ' - ' || PESSOA1.NMPESSOA,
				TO_CHAR(BAIXAUFOPERADORA.DTINICIOVIGENCIA, 'DD/MM/YYYY'),
				TO_CHAR(BAIXAUFOPERADORA.DTFIMVIGENCIA, 'DD/MM/YYYY'),
				BAIXAUFOPERADORA.INDISPONIBILIDADE,
				UF.SGUF
			FROM 
			    CONTATOADM.BAIXA            BAIXA,
                CONTATOADM.NOMEBAIXA        NOMEBAIXA,
 			    CUSTOMER.UFOPERADORA        UFOPERADORA,
			    CONTATOADM.BAIXAUFOPERADORA BAIXAUFOPERADORA,
                CUSTOMER.GRUPOOPERADORA     GRUPOOPERADORA,
 	            CUSTOMER.PESSOA             PESSOA1,
	            CUSTOMER.PESSOA             PESSOA2,
	            CUSTOMER.PESSOADEPARA       PESSOADEPARA,
                CUSTOMER.OPERADORA          OPERADORA,
			    APOIO.UF                    UF
            WHERE PESSOADEPARA.IDPESSOA = PESSOA1.IDPESSOA
            AND PESSOADEPARA.IDPESSOAORIGEM = PESSOA2.IDPESSOA
			AND OPERADORA.IDGRUPOOPERADORA = GRUPOOPERADORA.IDGRUPOOPERADORA
            AND OPERADORA.IDPESSOADEPARAOPERADORA = PESSOADEPARA.IDPESSOADEPARA
			AND UFOPERADORA.IDUF = UF.IDUF
			AND UFOPERADORA.IDPESSOADEPARAOPERADORA = OPERADORA.IDPESSOADEPARAOPERADORA
			AND BAIXAUFOPERADORA.IDBAIXA = BAIXA.IDBAIXA
            AND BAIXA.IDNOMEBAIXA = NOMEBAIXA.IDNOMEBAIXA
			AND BAIXAUFOPERADORA.IDUFOPERADORA = UFOPERADORA.IDUFOPERADORA
			AND BAIXA.IDBAIXA = :cAuxidBaixa;
        
        
		//Abre o cursor
		EXEC SQL OPEN CursorListIdBaixa;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stBaixaUfoperadoraRegistro, 0, sizeof(stBaixaUfoperadoraRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorListIdBaixa INTO :stBaixaUfoperadoraRegistro:stBaixaUfoperadoraIndicator;
				//Adiciona a classe
				Add( (char*)stBaixaUfoperadoraRegistro.stidBaixaUFOperadora.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stidBaixa.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stidUFOperadora.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stdsUFOperadora.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stdtInicioVigencia.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stdtFimVigencia.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stinDisponibilidade.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stsgUF.arr );
				//conta quantos existem
				iCont++;
			}
			//Fecha o CURSOR
			EXEC SQL CLOSE CursorListIdBaixa;
		}
		ULOG_END("CBaixaUfoperadora::ListIdBaixa");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListIdBaixa:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CBaixaUfoperadora::ListAll( void )
{
    ULOG_START("CBaixaUfoperadora::ListAll");
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stidBaixaUFOperadora[21+1];
			VARCHAR stidBaixa[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stdsUFOperadora[265+1];
			VARCHAR stdtInicioVigencia[12+1];
			VARCHAR stdtFimVigencia[12+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stsgUF[255+1];
		} stBaixaUfoperadoraRegistro;
		struct
		{
			short iidBaixaUFOperadora;
			short iidBaixa;
			short iidUFOperadora;
			short idsUFOperadora;
			short idtInicioVigencia;
			short idtFimVigencia;
			short iinDisponibilidade;
			short isgUF;
		} stBaixaUfoperadoraIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaUfoperadora();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros 
		/*
   		EXEC SQL 
   			DECLARE 
   				CursorBaixaUfoperadoraAll CURSOR FOR
	   		SELECT
		   		IDBAIXAUFOPERADORA,
				IDBAIXA,
				IDUFOPERADORA,
				SGUF || ' - ' || NMPESSOA,
				TO_CHAR(DTINICIOVIGENCIA, 'DD/MM/YYYY'),
				TO_CHAR(DTFIMVIGENCIA, 'DD/MM/YYYY'),
				INDISPONIBILIDADE,
				SGUF
			FROM 
				CONTATOADM.BAIXAUFOPERADORABZEROUM
			ORDER BY
				SGUF, NMPESSOA; 
        */

   		EXEC SQL 
   			DECLARE 
   				CursorBaixaUfoperadoraAll CURSOR FOR
	   		SELECT
		   		BAIXAUFOPERADORA.IDBAIXAUFOPERADORA,
				BAIXA.IDBAIXA,
				UFOPERADORA.IDUFOPERADORA,
				UF.SGUF || ' - ' || PESSOA1.NMPESSOA,
				TO_CHAR(BAIXAUFOPERADORA.DTINICIOVIGENCIA, 'DD/MM/YYYY'),
				TO_CHAR(BAIXAUFOPERADORA.DTFIMVIGENCIA, 'DD/MM/YYYY'),
				BAIXAUFOPERADORA.INDISPONIBILIDADE,
				UF.SGUF
			FROM 
			    CONTATOADM.BAIXA            BAIXA,
                CONTATOADM.NOMEBAIXA        NOMEBAIXA,
 			    CUSTOMER.UFOPERADORA        UFOPERADORA,
			    CONTATOADM.BAIXAUFOPERADORA BAIXAUFOPERADORA,
                CUSTOMER.GRUPOOPERADORA     GRUPOOPERADORA,
 	            CUSTOMER.PESSOA             PESSOA1,
	            CUSTOMER.PESSOA             PESSOA2,
	            CUSTOMER.PESSOADEPARA       PESSOADEPARA,
                CUSTOMER.OPERADORA          OPERADORA,
			    APOIO.UF                    UF
            WHERE PESSOADEPARA.IDPESSOA = PESSOA1.IDPESSOA
            AND PESSOADEPARA.IDPESSOAORIGEM = PESSOA2.IDPESSOA
			AND OPERADORA.IDGRUPOOPERADORA = GRUPOOPERADORA.IDGRUPOOPERADORA
            AND OPERADORA.IDPESSOADEPARAOPERADORA = PESSOADEPARA.IDPESSOADEPARA
			AND UFOPERADORA.IDUF = UF.IDUF
			AND UFOPERADORA.IDPESSOADEPARAOPERADORA = OPERADORA.IDPESSOADEPARAOPERADORA
			AND BAIXAUFOPERADORA.IDBAIXA = BAIXA.IDBAIXA
            AND BAIXA.IDNOMEBAIXA = NOMEBAIXA.IDNOMEBAIXA
			AND BAIXAUFOPERADORA.IDUFOPERADORA = UFOPERADORA.IDUFOPERADORA
			ORDER BY UF.SGUF, UPPER(PESSOA1.NMPESSOA);
        
		//Abre o cursor
		EXEC SQL OPEN CursorBaixaUfoperadoraAll;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stBaixaUfoperadoraRegistro, 0, sizeof(stBaixaUfoperadoraRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorBaixaUfoperadoraAll INTO :stBaixaUfoperadoraRegistro:stBaixaUfoperadoraIndicator;
				//Adiciona a classe
				Add( (char*)stBaixaUfoperadoraRegistro.stidBaixaUFOperadora.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stidBaixa.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stidUFOperadora.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stdsUFOperadora.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stdtInicioVigencia.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stdtFimVigencia.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stinDisponibilidade.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stsgUF.arr );
				//conta quantos existem                                       
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorBaixaUfoperadoraAll;
		}
		ULOG_END("CBaixaUfoperadora::ListAll");
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

void CBaixaUfoperadora::GetXml( char* cNomeTag, XMLGen*xml )
{
	//Soh monta o XML padrao se existir algum registro para isto
	if( Quantidade() > 0 )
	{
		//Corre todos os registros do iterator
		for( int x = 0; x < Quantidade(); x++ )
		{
			//Caso nao tenha recebido uma tag padrao, deixa sem
			xml->createTag(cNomeTag);
			//Para garantir que existe um registro
			if( Registro( x ) != NULL )
			{ 
				//Adiciona as tags necessarias
				xml->addItem("idBaixaUFOperadora", Registro(x)->cidBaixaUFOperadora );
				xml->addItem("idUFOperadora", Registro(x)->cidUFOperadora );
				xml->addItem("dtInicioVigencia", Registro(x)->cdtInicioVigencia );
				xml->addItem("dtFimVigencia", Registro(x)->cdtFimVigencia );
				xml->addItem("inDisponibilidade", Registro(x)->cinDisponibilidade ); 
				xml->addItem("sgUf", Registro(x)->cdsUFOperadora ); 
			}
			//So fecha um tag se abriu anteriormente
			xml->closeTag();
		}
	}
}

int CBaixaUfoperadora::Relacionadas( char* cidBaixa )
{
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidBaixa = cidBaixa;
		struct
		{
			VARCHAR stidBaixaUFOperadora[21+1];
			VARCHAR stidBaixa[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stdsUFOperadora[265+1];
			VARCHAR stdtInicioVigencia[12+1];
			VARCHAR stdtFimVigencia[12+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stsgUF[255+1];
		} stBaixaUfoperadoraRegistro;
		struct
		{
			short iidBaixaUFOperadora;
			short iidBaixa;
			short iidUFOperadora;
			short idsUFOperadora;
			short idtInicioVigencia;
			short idtFimVigencia;
			short iinDisponibilidade;
			short isgUF;
		} stBaixaUfoperadoraIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaUfoperadora();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoRelacionadas;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros
   		/*
   		EXEC SQL 
   			DECLARE 
   				CursorRelacionadas CURSOR FOR
	   		SELECT
		   		IDBAIXAUFOPERADORA,
				IDBAIXA,
				IDUFOPERADORA,
				SGUF || ' - ' || NMPESSOA OPERADORA,
				TO_CHAR(DTINICIOVIGENCIA,'DD/MM/YYYY'),
				TO_CHAR(DTFIMVIGENCIA,'DD/MM/YYYY'),
				INDISPONIBILIDADE,
				SGUF
			FROM 
				CONTATOADM.BAIXAUFOPERADORABZEROUM
			WHERE
				IDBAIXA = :cAuxidBaixa
			ORDER BY
				SGUF, NMPESSOA; 
        */
   		EXEC SQL 
   			DECLARE 
   				CursorRelacionadas CURSOR FOR
	   		SELECT
		   		BAIXAUFOPERADORA.IDBAIXAUFOPERADORA,
				BAIXA.IDBAIXA,
				UFOPERADORA.IDUFOPERADORA,
				UF.SGUF || ' - ' || PESSOA1.NMPESSOA,
				TO_CHAR(BAIXAUFOPERADORA.DTINICIOVIGENCIA, 'DD/MM/YYYY'),
				TO_CHAR(BAIXAUFOPERADORA.DTFIMVIGENCIA, 'DD/MM/YYYY'),
				BAIXAUFOPERADORA.INDISPONIBILIDADE,
				UF.SGUF
			FROM 
			    CONTATOADM.BAIXA            BAIXA,
                CONTATOADM.NOMEBAIXA        NOMEBAIXA,
 			    CUSTOMER.UFOPERADORA        UFOPERADORA,
			    CONTATOADM.BAIXAUFOPERADORA BAIXAUFOPERADORA,
                CUSTOMER.GRUPOOPERADORA     GRUPOOPERADORA,
 	            CUSTOMER.PESSOA             PESSOA1,
	            CUSTOMER.PESSOA             PESSOA2,
	            CUSTOMER.PESSOADEPARA       PESSOADEPARA,
                CUSTOMER.OPERADORA          OPERADORA,
			    APOIO.UF                    UF
            WHERE PESSOADEPARA.IDPESSOA = PESSOA1.IDPESSOA
            AND PESSOADEPARA.IDPESSOAORIGEM = PESSOA2.IDPESSOA
			AND OPERADORA.IDGRUPOOPERADORA = GRUPOOPERADORA.IDGRUPOOPERADORA
            AND OPERADORA.IDPESSOADEPARAOPERADORA = PESSOADEPARA.IDPESSOADEPARA
			AND UFOPERADORA.IDUF = UF.IDUF
			AND UFOPERADORA.IDPESSOADEPARAOPERADORA = OPERADORA.IDPESSOADEPARAOPERADORA
			AND BAIXAUFOPERADORA.IDBAIXA = BAIXA.IDBAIXA
            AND BAIXA.IDNOMEBAIXA = NOMEBAIXA.IDNOMEBAIXA
			AND BAIXAUFOPERADORA.IDUFOPERADORA = UFOPERADORA.IDUFOPERADORA
			AND BAIXA.IDBAIXA = :cAuxidBaixa
			ORDER BY UF.SGUF, PESSOA1.NMPESSOA;
        
        
		//Abre o cursor
		EXEC SQL OPEN CursorRelacionadas;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stBaixaUfoperadoraRegistro, 0, sizeof(stBaixaUfoperadoraRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorRelacionadas INTO :stBaixaUfoperadoraRegistro:stBaixaUfoperadoraIndicator;
				//Adiciona a classe
				Add( (char*)stBaixaUfoperadoraRegistro.stidBaixaUFOperadora.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stidBaixa.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stidUFOperadora.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stdsUFOperadora.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stdtInicioVigencia.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stdtFimVigencia.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stinDisponibilidade.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stsgUF.arr );
				//conta quantos existem                                       
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorRelacionadas;
		}
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoRelacionadas:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}

int CBaixaUfoperadora::NaoRelacionadas( char* cidBaixa )
{
	//Variavel de controle para a quantidade de registros retornada
	int    iCont = 0;
	//Variavel de status do oracle para PROC
	struct sqlca sqlca;
	//Declaracao das variaveis para o PROC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cAuxidBaixa = cidBaixa;
		struct
		{
			VARCHAR stidBaixaUFOperadora[21+1];
			VARCHAR stidBaixa[21+1];
			VARCHAR stidUFOperadora[21+1];
			VARCHAR stdsUFOperadora[265+1];
			VARCHAR stdtInicioVigencia[12+1];
			VARCHAR stdtFimVigencia[12+1];
			VARCHAR stinDisponibilidade[21+1];
			VARCHAR stsgUF[255+1];
		} stBaixaUfoperadoraRegistro;
		struct
		{
			short iidBaixaUFOperadora;
			short iidBaixa;
			short iidUFOperadora;
			short idsUFOperadora;
			short idtInicioVigencia;
			short idtFimVigencia;
			short iinDisponibilidade;
			short isgUF;
		} stBaixaUfoperadoraIndicator;
	EXEC SQL END DECLARE SECTION;

	//Processamento Principal
	try
	{
		//Zera a estrutura da classe
		ZeraBaixaUfoperadora();

		//Ativa as acoes decorrentes de erros ORACLE
		EXEC SQL WHENEVER NOT FOUND DO break;
		EXEC SQL WHENEVER SQLERROR GOTO GotoNaoRelacionadas;
		sqlca.sqlcode=0;

		//Declara um cursor para listar todos os registros 
		/*
   		EXEC SQL 
   			DECLARE 
   				CursorNaoRelacionadas CURSOR FOR
	   		SELECT
		   		0 IDBAIXAUFOPERADORA,
				0 IDBAIXA,
				IDUFOPERADORA,
				SGUF || ' - ' || NMPESSOA,
				'' DTINICIOVIGENCIA,
				'' DTFIMVIGENCIA,
				0,
				SGUF
			FROM 
				CUSTOMER.UFOPERADORABZEROUM
			WHERE
				IDUFOPERADORA NOT IN
				(
			   		SELECT
						IDUFOPERADORA
					FROM 
						CONTATOADM.BAIXAUFOPERADORA
					WHERE
						IDBAIXA = :cAuxidBaixa				
				)
			ORDER BY
				SGUF, NMPESSOA; 
        */
        
   		EXEC SQL 
   			DECLARE 
   				CursorNaoRelacionadas CURSOR FOR
	   		SELECT
		   		0 IDBAIXAUFOPERADORA,
				0 IDBAIXA,
				UFOPERADORA.IDUFOPERADORA,
				UF.SGUF || ' - ' || PESSOA1.NMPESSOA,
				'' DTINICIOVIGENCIA,
				'' DTFIMVIGENCIA,
				0,
				UF.SGUF
            FROM CUSTOMER.GRUPOOPERADORA GRUPOOPERADORA,
                 CUSTOMER.OPERADORA OPERADORA,
			     APOIO.UF UF,
			     CUSTOMER.UFOPERADORA UFOPERADORA,
			     CUSTOMER.PESSOA PESSOA1,
			     CUSTOMER.PESSOA PESSOA2,
			     CUSTOMER.PESSOADEPARA PESSOADEPARA
			WHERE PESSOADEPARA.IDPESSOA = PESSOA1.IDPESSOA
			AND PESSOADEPARA.IDPESSOAORIGEM = PESSOA2.IDPESSOA
            AND OPERADORA.IDGRUPOOPERADORA = GRUPOOPERADORA.IDGRUPOOPERADORA
            AND OPERADORA.IDPESSOADEPARAOPERADORA = PESSOADEPARA.IDPESSOADEPARA
			AND UFOPERADORA.IDUF = UF.IDUF
			AND UFOPERADORA.IDPESSOADEPARAOPERADORA = OPERADORA.IDPESSOADEPARAOPERADORA
			AND
				IDUFOPERADORA NOT IN
				(
			   		SELECT
						IDUFOPERADORA
					FROM 
						CONTATOADM.BAIXAUFOPERADORA
					WHERE
						IDBAIXA = :cAuxidBaixa
				)
			ORDER BY
				UF.SGUF, PESSOA1.NMPESSOA;
        
        
		//Abre o cursor
		EXEC SQL OPEN CursorNaoRelacionadas;

		//Verifica se nao house erro ORACLE
		if(sqlca.sqlcode)
			return 0;//Erro
		else
		{
			//Caso inexista registros sair do loop
			EXEC SQL WHENEVER NOT FOUND DO break;
			for(;;)
			{
				//Zera a estrutura de restorno
				memset( &stBaixaUfoperadoraRegistro, 0, sizeof(stBaixaUfoperadoraRegistro) );
				//Pega um registro no CURSOR
				EXEC SQL FETCH CursorNaoRelacionadas INTO :stBaixaUfoperadoraRegistro:stBaixaUfoperadoraIndicator;
				//Adiciona a classe
				Add( (char*)stBaixaUfoperadoraRegistro.stidBaixaUFOperadora.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stidBaixa.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stidUFOperadora.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stdsUFOperadora.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stdtInicioVigencia.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stdtFimVigencia.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stinDisponibilidade.arr
				    ,(char*)stBaixaUfoperadoraRegistro.stsgUF.arr );
				//conta quantos existem                                       
				iCont++;
			}
			//Fecha o cursor
			EXEC SQL CLOSE CursorNaoRelacionadas;
		}
		//Retorna a quantidade de registros
		return iCont;
	}
	catch(...)
	{
		throw;
	}

GotoNaoRelacionadas:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
	throw TuxBasicOraException(sqlca.sqlcode);

}


int CBaixaUfoperadora::Relacao( char* cidBaixa, XMLGen*xml )
{
	xml->createTag( "AdmOperadorasVO" );
	xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
	
	if( strlennull( cidBaixa ) <= 0 )
		return 0;

	
	if( Relacionadas( cidBaixa ) > 0 )
	{
		xml->addItem( "idBaixa", cidBaixa );
		if( strlennull( Registro(0)->cdtFimVigencia ) > 0 )
			xml->addItem( "indeterminado", 0 );
		else
			xml->addItem( "indeterminado", 1 );
		xml->addItem( "dtInicioVigencia", Registro(0)->cdtInicioVigencia );
		xml->addItem( "dtFimVigencia", Registro(0)->cdtFimVigencia );
		
	}
	else
	{
		xml->addItem( "idBaixa", cidBaixa );
		xml->addItem( "indeterminado", 0 );
		xml->addItem( "dtInicioVigencia", "" );
		xml->addItem( "dtFimVigencia", "" );
	}
	//Relacionadas
	xml->createTag( "operadorasAssociadas" );
	GetXml( "AdmContatoUFOperadoraVO", xml );
	xml->closeTag();//operadorasAssociadas
	
	//Nao Relacionadas
	NaoRelacionadas( cidBaixa );
	xml->createTag( "operadorasExistentes" );
	GetXml( "AdmContatoUFOperadoraVO", xml );
	xml->closeTag();//operadorasExistentes
	
	xml->createTag( "AdmContatoUFOperadorasVO" );
	ListIdBaixa( cidBaixa );
	GetXml( "AdmContatoUFOperadoraVO", xml );
	xml->closeTag();//AdmContatoUFOperadorasVO

	xml->closeTag();//AdmOperadorasVO

	return 1;
}

int CBaixaUfoperadora::Find( char* cidBaixa, char* cidUFOperadora )
{
	int iRet = -1;
	if( Quantidade() > 0 )
	{
		for( int x = 0; x<Quantidade(); x++ )
		{
			if( ( strcmp( cidBaixa, Registro(x)->cidBaixa ) == 0 )
			 && ( strcmp( cidUFOperadora, Registro(x)->cidUFOperadora ) == 0 ) )
			{
				iRet = x;
				break;
			}
		}
	}
	return iRet;
}

void CBaixaUfoperadora::Adicionar( char* cidBaixaUFOperadora,
		                             char* cidBaixa,
					                 char* cidUFOperadora )
{
	Add( cidBaixaUFOperadora
		,cidBaixa
		,cidUFOperadora
		,""
		,""
		,""
		,""
		,"" );
}
