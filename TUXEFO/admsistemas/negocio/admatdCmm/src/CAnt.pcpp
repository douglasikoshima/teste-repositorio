#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#include "../include/CAnt.h"

CIndicadorAnatel::CIndicadorAnatel()
{
}

CIndicadorAnatel::~CIndicadorAnatel()
{
}

int CIndicadorAnatel::RelacaoFlhAnt( char* cidContato )
{
    ULOG_START("CIndicadorAnatel::RelacaoFlhAnt()");
    //Variavel de controle para a quantidade de registros retornada
    int    iCont = 0;
    //Variavel de status do oracle para PROC
    struct sqlca sqlca;
    //Declaracao das variaveis para o PROC
    EXEC SQL BEGIN DECLARE SECTION;
        char* cAuxidContato = cidContato;
        struct
        {
            VARCHAR stidIndicadorAnatel[21+1];
            VARCHAR stsgIndicador[255+1];
            VARCHAR stdsIndicador[255+1];
        } stIndicadorAnatelRegistro;
        struct
        {
            short iidIndicadorAnatel;
            short isgIndicador;
            short idsIndicador;
        } stIndicadorAnatelIndicator;
    EXEC SQL END DECLARE SECTION;

    //Processamento Principal
    try
    {
        ZeraIndicadorAnatel();

        sqlca.sqlcode=0;
        EXEC SQL WHENEVER NOT FOUND CONTINUE;

        //Declara um cursor para listar os Registros
        EXEC SQL DECLARE CursorIndicadorAnatelRelacao_00 CURSOR FOR
		SELECT
		    IndicadorAnatel.idIndicadorAnatel,
		    IndicadorAnatel.idIndicadorAnatel,
		    IndicadorAnatel.idIndicadorAnatel
		FROM
		    APOIO.INDICADORANATEL INDICADORANATEL,
			CONTATOADM.CONTATO CONTATO,
			CONTATOADM.TIPOFECHAMENTOCONTATO TIPOFECHAMENTOCONTATO,
			WORKFLOW.TIPOPROCESSO TIPOPROCESSO,
			CONTATOADM.TIPORETORNOCONTATO TIPORETORNOCONTATO,
			ACESSO.UNIDADE UNIDADE,
		    CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
		    CONTATOADM.INDICADORCONTATOFOLHA INDICADORCONTATOFOLHA
		WHERE
		    IndicadorAnatel.idIndicadorAnatel = INDICADORCONTATOFOLHA.IDCONTATO
		AND
		    INDICADORCONTATOFOLHA.IDINDICADORANATEL = INDICADORANATEL.IDINDICADORANATEL
		AND
		    INDICADORCONTATOFOLHA.IDCONTATO = CONTATOFOLHA.IDCONTATO
		AND
		    CONTATOFOLHA.IDUNIDADE = UNIDADE.IDUNIDADE
		AND
		    CONTATOFOLHA.IDCONTATO = CONTATO.IDCONTATO
		AND
		    CONTATOFOLHA.IDTIPOFECHAMENTOCONTATO = TIPOFECHAMENTOCONTATO.IDTIPOFECHAMENTOCONTATO
		AND
		    CONTATOFOLHA.IDTIPORETORNOCONTATO = TIPORETORNOCONTATO.IDTIPORETORNOCONTATO
		AND
		    CONTATOFOLHA.IDTIPOPROCESSO = TIPOPROCESSO.IDTIPOPROCESSO
		AND
		    INDICADORCONTATOFOLHA.IDCONTATO = :cAuxidContato ;



/*  Marcelo - Retirada das chamadas  e B01 - Marco/2007
        EXEC SQL DECLARE CursorIndicadorAnatelRelacao_00 CURSOR FOR
            SELECT apoio.IndicadorAnatel.idIndicadorAnatel, apoio.IndicadorAnatel.idIndicadorAnatel, apoio.IndicadorAnatel.idIndicadorAnatel
        FROM apoio.IndicadorAnatel, contatoadm.IndicadorContatoFolhaB01
        WHERE apoio.IndicadorAnatel.idIndicadorAnatel = contatoadm.IndicadorContatoFolhaB01.idContato AND contatoadm.IndicadorContatoFolhaB01.idContato = :cAuxidContato ;
*/

        EXEC SQL WHENEVER SQLERROR GOTO GotoRelacao;

        EXEC SQL OPEN CursorIndicadorAnatelRelacao_00;

        //Verifica se nao house erro ORACLE
        if(sqlca.sqlcode)
            return 0;//Erro
        else
        {
            //Caso inexista registros sair do loop
            EXEC SQL WHENEVER NOT FOUND DO break;
            for(;;)
            {
                //Zera a estrutura de restorno
                memset( &stIndicadorAnatelRegistro, 0, sizeof(stIndicadorAnatelRegistro) );
                //Pega um registro no CURSOR
                EXEC SQL FETCH CursorIndicadorAnatelRelacao_00 INTO :stIndicadorAnatelRegistro:stIndicadorAnatelIndicator;
                //Adiciona a classe
                Add(  (char*)stIndicadorAnatelRegistro.stidIndicadorAnatel.arr,
                (char*)stIndicadorAnatelRegistro.stsgIndicador.arr,
                (char*)stIndicadorAnatelRegistro.stdsIndicador.arr );
                //conta quantos existem
                iCont++;
            }
            //Fecha o cursor
            EXEC SQL CLOSE CursorIndicadorAnatelRelacao_00;
        }
        //Retorna a quantidade de registros
        ULOG_END("CIndicadorAnatel::RelacaoFlhAnt()");
        return iCont;
    }
    catch(...)
    {
        throw;
    }

GotoRelacao:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}

int CIndicadorAnatel::ExistemFlhAnt( char* cidContato )
{
    ULOG_START("CIndicadorAnatel::ExistemFlhAnt()");
    //Variavel de controle para a quantidade de registros retornada
    int    iCont = 0;
    //Variavel de status do oracle para PROC
    struct sqlca sqlca;
    //Declaracao das variaveis para o PROC
    EXEC SQL BEGIN DECLARE SECTION;
        char* cAuxidContato = cidContato;
        struct
        {
            VARCHAR stidIndicadorAnatel[21+1];
            VARCHAR stsgIndicador[255+1];
            VARCHAR stdsIndicador[255+1];
        } stIndicadorAnatelRegistro;
        struct
        {
            short iidIndicadorAnatel;
            short isgIndicador;
            short idsIndicador;
        } stIndicadorAnatelIndicator;
    EXEC SQL END DECLARE SECTION;

    //Processamento Principal
    try
    {
        ZeraIndicadorAnatel();

        sqlca.sqlcode=0;
        EXEC SQL WHENEVER NOT FOUND CONTINUE;

        //Declara um cursor para listar os Registros
/* @Marcelo - Retirada de  e B01. March/2007
            EXEC SQL DECLARE CursorIndicadorAnatelExistem_00 CURSOR FOR
            SELECT apoio.IndicadorAnatel.idIndicadorAnatel, apoio.IndicadorAnatel.idIndicadorAnatel, apoio.IndicadorAnatel.idIndicadorAnatel
        FROM apoio.IndicadorAnatel
        WHERE apoio.IndicadorAnatel.idIndicadorAnatel NOT IN ( SELECT apoio.IndicadorAnatel.idIndicadorAnatel FROM apoio.IndicadorAnatel, contatoadm.IndicadorContatoFolhaB01 WHERE apoio.IndicadorAnatel.idIndicadorAnatel = contatoadm.IndicadorContatoFolhaB01.idContato AND contatoadm.IndicadorContatoFolhaB01.idContato = :cAuxidContato  );
*/

        //Declara um cursor para listar os Registros
        EXEC SQL DECLARE CursorIndicadorAnatelExistem_00 CURSOR FOR
		SELECT
		   Anatel.idIndicadorAnatel,
		   Anatel.idIndicadorAnatel,
		   Anatel.idIndicadorAnatel
		FROM
		   apoio.IndicadorAnatel Anatel
		WHERE
		   Anatel.idIndicadorAnatel
		NOT IN
		(
				SELECT
				    INDICADORANATEL.idIndicadorAnatel
				FROM
				    APOIO.INDICADORANATEL INDICADORANATEL,
					CONTATOADM.CONTATO CONTATO,
					CONTATOADM.TIPOFECHAMENTOCONTATO TIPOFECHAMENTOCONTATO,
					WORKFLOW.TIPOPROCESSO TIPOPROCESSO,
					CONTATOADM.TIPORETORNOCONTATO TIPORETORNOCONTATO,
					ACESSO.UNIDADE UNIDADE,
				    CONTATOADM.CONTATOFOLHA CONTATOFOLHA,
				    CONTATOADM.INDICADORCONTATOFOLHA INDICADORCONTATOFOLHA
				WHERE
				    INDICADORANATEL.idIndicadorAnatel = INDICADORCONTATOFOLHA.IDCONTATO
				AND
				    INDICADORCONTATOFOLHA.IDINDICADORANATEL = INDICADORANATEL.IDINDICADORANATEL
				AND
				    INDICADORCONTATOFOLHA.IDCONTATO = CONTATOFOLHA.IDCONTATO
				AND
				    CONTATOFOLHA.IDUNIDADE = UNIDADE.IDUNIDADE
				AND
				    CONTATOFOLHA.IDCONTATO = CONTATO.IDCONTATO
				AND
				    CONTATOFOLHA.IDTIPOFECHAMENTOCONTATO = TIPOFECHAMENTOCONTATO.IDTIPOFECHAMENTOCONTATO
				AND
				    CONTATOFOLHA.IDTIPORETORNOCONTATO = TIPORETORNOCONTATO.IDTIPORETORNOCONTATO
				AND
				    CONTATOFOLHA.IDTIPOPROCESSO = TIPOPROCESSO.IDTIPOPROCESSO
				AND
				    INDICADORCONTATOFOLHA.IDCONTATO = :cAuxidContato
		);

        EXEC SQL WHENEVER SQLERROR GOTO GotoExistem;

        EXEC SQL OPEN CursorIndicadorAnatelExistem_00;

        //Verifica se nao house erro ORACLE
        if(sqlca.sqlcode)
            return 0;//Erro
        else
        {
            //Caso inexista registros sair do loop
            EXEC SQL WHENEVER NOT FOUND DO break;
            for(;;)
            {
                //Zera a estrutura de restorno
                memset( &stIndicadorAnatelRegistro, 0, sizeof(stIndicadorAnatelRegistro) );
                //Pega um registro no CURSOR
                EXEC SQL FETCH CursorIndicadorAnatelExistem_00 INTO :stIndicadorAnatelRegistro:stIndicadorAnatelIndicator;
                //Adiciona a classe
                Add(  (char*)stIndicadorAnatelRegistro.stidIndicadorAnatel.arr,
                (char*)stIndicadorAnatelRegistro.stsgIndicador.arr,
                (char*)stIndicadorAnatelRegistro.stdsIndicador.arr );
                //conta quantos existem
                iCont++;
            }
            //Fecha o cursor
            EXEC SQL CLOSE CursorIndicadorAnatelExistem_00;
        }
        //Retorna a quantidade de registros
        ULOG_END("CIndicadorAnatel::ExistemFlhAnt()");
        return iCont;
    }
    catch(...)
    {
        throw;
    }

GotoExistem:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}

int CIndicadorAnatel::RelacaoBxaAnt( char* cidContato )
{
    ULOG_START("CIndicadorAnatel::RelacaoBxaAnt()");
    //Variavel de controle para a quantidade de registros retornada
    int    iCont = 0;
    //Variavel de status do oracle para PROC
    struct sqlca sqlca;
    //Declaracao das variaveis para o PROC
    EXEC SQL BEGIN DECLARE SECTION;
        char* cAuxidContato = cidContato;
        struct
        {
            VARCHAR stidIndicadorAnatel[21+1];
            VARCHAR stsgIndicador[255+1];
            VARCHAR stdsIndicador[255+1];
        } stIndicadorAnatelRegistro;
        struct
        {
            short iidIndicadorAnatel;
            short isgIndicador;
            short idsIndicador;
        } stIndicadorAnatelIndicator;
    EXEC SQL END DECLARE SECTION;

    //Processamento Principal
    try
    {
        ZeraIndicadorAnatel();

        sqlca.sqlcode=0;
        EXEC SQL WHENEVER NOT FOUND CONTINUE;

        // @Marcelo - Retirada de  e B01, este metodo nao eh chamado, pois na
        //            execucao do statment, dá erro na query.
        //Declara um cursor para listar os Registros
        EXEC SQL DECLARE CursorIndicadorAnatelRelacao_01 CURSOR FOR
            SELECT apoio.IndicadorAnatel.idIndicadorAnatel, apoio.IndicadorAnatel.idIndicadorAnatel, apoio.IndicadorAnatel.idIndicadorAnatel
        FROM apoio.IndicadorAnatel, contatoadm.IndicadorAnatelBaixaB01
        WHERE apoio.IndicadorAnatel.idIndicadorAnatel = contatoadm.IndicadorAnatelBaixaB01.idContato AND contatoadm.IndicadorAnatelBaixaB01.idContato = :cAuxidContato ;

        EXEC SQL WHENEVER SQLERROR GOTO GotoRelacao;

        EXEC SQL OPEN CursorIndicadorAnatelRelacao_01;

        //Verifica se nao house erro ORACLE
        if(sqlca.sqlcode)
            return 0;//Erro
        else
        {
            //Caso inexista registros sair do loop
            EXEC SQL WHENEVER NOT FOUND DO break;
            for(;;)
            {
                //Zera a estrutura de restorno
                memset( &stIndicadorAnatelRegistro, 0, sizeof(stIndicadorAnatelRegistro) );
                //Pega um registro no CURSOR
                EXEC SQL FETCH CursorIndicadorAnatelRelacao_01 INTO :stIndicadorAnatelRegistro:stIndicadorAnatelIndicator;
                //Adiciona a classe
                Add(  (char*)stIndicadorAnatelRegistro.stidIndicadorAnatel.arr,
                (char*)stIndicadorAnatelRegistro.stsgIndicador.arr,
                (char*)stIndicadorAnatelRegistro.stdsIndicador.arr );
                //conta quantos existem
                iCont++;
            }
            //Fecha o cursor
            EXEC SQL CLOSE CursorIndicadorAnatelRelacao_01;
        }
        //Retorna a quantidade de registros
        ULOG_END("CIndicadorAnatel::RelacaoBxaAnt()");
        return iCont;
    }
    catch(...)
    {
        throw;
    }

GotoRelacao:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}

int CIndicadorAnatel::ExistemBxaAnt( char* cidContato )
{
    ULOG_START("CIndicadorAnatel::ExistemBxaAnt()");
    //Variavel de controle para a quantidade de registros retornada
    int    iCont = 0;
    //Variavel de status do oracle para PROC
    struct sqlca sqlca;
    //Declaracao das variaveis para o PROC
    EXEC SQL BEGIN DECLARE SECTION;
        char* cAuxidContato = cidContato;
        struct
        {
            VARCHAR stidIndicadorAnatel[21+1];
            VARCHAR stsgIndicador[255+1];
            VARCHAR stdsIndicador[255+1];
        } stIndicadorAnatelRegistro;
        struct
        {
            short iidIndicadorAnatel;
            short isgIndicador;
            short idsIndicador;
        } stIndicadorAnatelIndicator;
    EXEC SQL END DECLARE SECTION;

    //Processamento Principal
    try
    {
        ZeraIndicadorAnatel();

        sqlca.sqlcode=0;
        EXEC SQL WHENEVER NOT FOUND CONTINUE;
        
        // @Marcelo - Retirada de bezerozero e BZERO UM, aparentemente nao usado, apresenta erros.
        //Declara um cursor para listar os Registros
            EXEC SQL DECLARE CursorIndicadorAnatelExistem_01 CURSOR FOR 
			  SELECT INDICADORANATEL.IDINDICADORANATEL,
					 INDICADORANATEL.SGINDICADOR,
					 INDICADORANATEL.DSINDICADOR
		      FROM APOIO.INDICADORANATEL INDICADORANATEL
			  WHERE INDICADORANATEL.IDINDICADORANATEL NOT IN
                    ( 
                        SELECT DISTINCT		
                            INDICADORANATEL.IDINDICADORANATEL		
                        FROM 
                            APOIO.INDICADORANATEL INDICADORANATEL,
                            CONTATOADM.INDICADORANATELBAIXA INDICADORANATELBAIXA,
                            CONTATOADM.CONTATOFOLHABAIXA CONTATOFOLHABAIXA
                        WHERE
                            INDICADORANATEL.IDINDICADORANATEL = INDICADORANATELBAIXA.IDINDICADORANATEL 
                        AND CONTATOFOLHABAIXA.IDCONTATO = :cAuxidContato
                    );

        EXEC SQL WHENEVER SQLERROR GOTO GotoExistem;

        EXEC SQL OPEN CursorIndicadorAnatelExistem_01;

        //Verifica se nao house erro ORACLE
        if(sqlca.sqlcode)
            return 0;//Erro
        else
        {
            //Caso inexista registros sair do loop
            EXEC SQL WHENEVER NOT FOUND DO break;
            for(;;)
            {
                //Zera a estrutura de restorno
                memset( &stIndicadorAnatelRegistro, 0, sizeof(stIndicadorAnatelRegistro) );
                //Pega um registro no CURSOR
                EXEC SQL FETCH CursorIndicadorAnatelExistem_01 INTO :stIndicadorAnatelRegistro:stIndicadorAnatelIndicator;
                //Adiciona a classe
                Add(  (char*)stIndicadorAnatelRegistro.stidIndicadorAnatel.arr,
                (char*)stIndicadorAnatelRegistro.stsgIndicador.arr,
                (char*)stIndicadorAnatelRegistro.stdsIndicador.arr );
                //conta quantos existem
                iCont++;
            }
            //Fecha o cursor
            EXEC SQL CLOSE CursorIndicadorAnatelExistem_01;
        }
        //Retorna a quantidade de registros

        ULOG_END("CIndicadorAnatel::ExistemBxaAnt()");

        return iCont;
    }
    catch(...)
    {
        throw;
    }

GotoExistem:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);
}

int CIndicadorAnatel::ListId( char* cidIndicadorAnatel )
{
    ULOG_START("CIndicadorAnatel::ListId()");
    //Variavel de controle para a quantidade de registros retornada
    int    iCont = 0;
    //Variavel de status do oracle para PROC
    struct sqlca sqlca;
    //Declaracao das variaveis para o PROC
    EXEC SQL BEGIN DECLARE SECTION;
        char* cAuxidIndicadorAnatel = cidIndicadorAnatel;
        struct
        {
            VARCHAR stidIndicadorAnatel[21+1];
            VARCHAR stsgIndicador[255+1];
            VARCHAR stdsIndicador[255+1];
        } stIndicadorAnatelRegistro;
        struct
        {
            short iidIndicadorAnatel;
            short isgIndicador;
            short idsIndicador;
        } stIndicadorAnatelIndicator;
    EXEC SQL END DECLARE SECTION;

    //Processamento Principal
    try
    {
        //Zera a estrutura da classe
        ZeraIndicadorAnatel();

        //Ativa as acoes decorrentes de erros ORACLE
        EXEC SQL WHENEVER NOT FOUND DO break;
        EXEC SQL WHENEVER SQLERROR GOTO GotoListId;
        sqlca.sqlcode=0;

        //Declara um cursor para listar os IDs
		EXEC SQL DECLARE CursorIndicadorAnatelId CURSOR FOR
		SELECT
			idIndicadorAnatel,
			sgIndicador,
			dsIndicador
		FROM
			apoio.IndicadorAnatel
		WHERE
		    idIndicadorAnatel = :cAuxidIndicadorAnatel;

        //Abre o cursor
        EXEC SQL OPEN CursorIndicadorAnatelId;

        //Verifica se nao house erro ORACLE
        if(sqlca.sqlcode)
            return 0;//Erro
        else
        {
            //Caso inexista registros sair do loop
            EXEC SQL WHENEVER NOT FOUND DO break;
            for(;;)
            {
                //Zera a estrutura de restorno
                memset( &stIndicadorAnatelRegistro, 0, sizeof(stIndicadorAnatelRegistro) );
                //Pega um registro no CURSOR
                EXEC SQL FETCH CursorIndicadorAnatelId INTO :stIndicadorAnatelRegistro:stIndicadorAnatelIndicator;
                //Adiciona a classe
                Add(  (char*)stIndicadorAnatelRegistro.stidIndicadorAnatel.arr,
                (char*)stIndicadorAnatelRegistro.stsgIndicador.arr,
                (char*)stIndicadorAnatelRegistro.stdsIndicador.arr );
                //conta quantos existem
                iCont++;
            }
            //Fecha o CURSOR
            EXEC SQL CLOSE CursorIndicadorAnatelId;
        }
        //Retorna a quantidade de registros
        ULOG_END("CIndicadorAnatel::ListId()");
        return iCont;
    }
    catch(...)
    {
        throw;
    }

GotoListId:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);

}

int CIndicadorAnatel::ListAll( void )
{
    ULOG_START("CIndicadorAnatel::ListAll()");
    //Variavel de controle para a quantidade de registros retornada
    int    iCont = 0;
    //Variavel de status do oracle para PROC
    struct sqlca sqlca;
    //Declaracao das variaveis para o PROC
    EXEC SQL BEGIN DECLARE SECTION;
        struct
        {
            VARCHAR stidIndicadorAnatel[21+1];
            VARCHAR stsgIndicador[255+1];
            VARCHAR stdsIndicador[255+1];
        } stIndicadorAnatelRegistro;
        struct
        {
            short iidIndicadorAnatel;
            short isgIndicador;
            short idsIndicador;
        } stIndicadorAnatelIndicator;
    EXEC SQL END DECLARE SECTION;

    //Processamento Principal
    try
    {
        //Zera a estrutura da classe
        ZeraIndicadorAnatel();

        //Ativa as acoes decorrentes de erros ORACLE
        EXEC SQL WHENEVER NOT FOUND DO break;
        EXEC SQL WHENEVER SQLERROR GOTO GotoListAll;
        sqlca.sqlcode=0;

        //Declara um cursor para listar todos os registros
		EXEC SQL DECLARE CursorIndicadorAnatelAll CURSOR FOR
		SELECT
			idIndicadorAnatel,
			sgIndicador,
			dsIndicador
		FROM
			apoio.IndicadorAnatel;

        //Abre o cursor
        EXEC SQL OPEN CursorIndicadorAnatelAll;

        //Verifica se nao house erro ORACLE
        if(sqlca.sqlcode)
            return 0;//Erro
        else
        {
            //Caso inexista registros sair do loop
            EXEC SQL WHENEVER NOT FOUND DO break;
            for(;;)
            {
                //Zera a estrutura de restorno
                memset( &stIndicadorAnatelRegistro, 0, sizeof(stIndicadorAnatelRegistro) );
                //Pega um registro no CURSOR
                EXEC SQL FETCH CursorIndicadorAnatelAll INTO :stIndicadorAnatelRegistro:stIndicadorAnatelIndicator;
                //Adiciona a classe
                Add(  (char*)stIndicadorAnatelRegistro.stidIndicadorAnatel.arr,
                (char*)stIndicadorAnatelRegistro.stsgIndicador.arr,
                (char*)stIndicadorAnatelRegistro.stdsIndicador.arr );
                //conta quantos existem
                iCont++;
            }
            //Fecha o cursor
            EXEC SQL CLOSE CursorIndicadorAnatelAll;
        }
        //Retorna a quantidade de registros

        ULOG_END("CIndicadorAnatel::ListAll()");
        return iCont;
    }
    catch(...)
    {
        throw;
    }

GotoListAll:
    ULOGE( "ERRO ORACLE:sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
    throw TuxBasicOraException(sqlca.sqlcode);

}

void CIndicadorAnatel::GetXml( char* cNomeTag, XMLGen*xml )
{

    //Soh monta o XML padrao se existir algum registro para isto
    if( Quantidade() > 0 )
    {
        //Corre todos os registros do iterator
        for( int x = 0; x < Quantidade(); x++ )
        {
            //Caso nao tenha recebido uma tag padrao, deixa sem
            xml->createTag(cNomeTag);
            //Adiciona a proprieda necessaria para o Weblogic
            xml->addProp( "xmlns", "admsistemas.fo.vivo.com.br/vo" );
            //Para garantir que existe um registro
            if( Registro( x ) != NULL )
            {
                //Adiciona as tags necessarias
                xml->addItem("idIndicadorAnatel", Registro(x)->cidIndicadorAnatel );
                xml->addItem("sgIndicador", Registro(x)->csgIndicador );
                xml->addItem("dsIndicador", Registro(x)->cdsIndicador );
            }
            //So fecha um tag se abriu anteriormente
            xml->closeTag();
        }
    }


}
