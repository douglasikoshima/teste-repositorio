#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>

#include "tuxfw.h"
#include "AcaoPortabilidadepcPORT.h"

EXEC SQL BEGIN DECLARE SECTION;
#include "PPGlobalPORT.h"
EXEC SQL END DECLARE SECTION;

/****************************************************************************************/
bool CAcaoPortabilidadepc::proCBuscaAcaoPortabilidade(TAcaoPortabilidade *ptAcaoPortabilidade)
{
    ULOG_START("CAcaoPortabilidadepc::proCBuscaAcaoPortabilidade");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdAcaoPortabilidade[LEN_IDACAOPORTABILIDADE];
        VARCHAR oszDsAcaoPortabilidade[LEN_DSACAOPORTABILIDADE];

        short iIdAcaoPortabilidade = 0;
        short iDsAcaoPortabilidade = 0;
    EXEC SQL END DECLARE SECTION;

	struct sqlca sqlca;

	STRCPY_TO_ORA(oszDsAcaoPortabilidade, ptAcaoPortabilidade->szDsAcaoPortabilidade);

	EXEC SQL WHENEVER SQLERROR	goto erro;
	EXEC SQL WHENEVER NOT FOUND goto naoexiste;

	EXEC SQL
        SELECT
            aap.idacaoportabilidade,
            aap.dsacaoportabilidade
        INTO
            :oszIdAcaoPortabilidade:iIdAcaoPortabilidade,
            :oszDsAcaoPortabilidade:iDsAcaoPortabilidade
        FROM
            apoio.acaoportabilidade aap
        WHERE
            aap.dsacaoportabilidade = :oszDsAcaoPortabilidade;



    if(iIdAcaoPortabilidade != -1) {
        STRCPY_FROM_ORA(ptAcaoPortabilidade->szIdAcaoPortabilidade, oszIdAcaoPortabilidade);
    }
    if(iDsAcaoPortabilidade != -1) {
        STRCPY_FROM_ORA(ptAcaoPortabilidade->szDsAcaoPortabilidade, oszDsAcaoPortabilidade);
    }

    ULOGI("Finalizando proCBuscaAcaoPortabilidade <OK>");
    ULOG_END("CAcaoPortabilidadepc::proCBuscaAcaoPortabilidade");
    return true;

    naoexiste:
        ULOGI("Finalizando proCBuscaAcaoPortabilidade <NOT FOUND>");
        ULOG_END("CAcaoPortabilidadepc::proCBuscaAcaoPortabilidade");
        return false;

    erro:
        ULOGE("Finalizando proCBuscaAcaoPortabilidade <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}
