#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>

#include "tuxfw.h"
#include "TipoDocumentopcPORT.h"

EXEC SQL BEGIN DECLARE SECTION;
#include "PPGlobalPORT.h"
EXEC SQL END DECLARE SECTION;

/****************************************************************************************/
bool CTipoDocumentopc::proCBuscaTipoDocumento(TTipoDocumento *ptTipoDocumento)
{
    ULOG_START("CTipoDocumentopc::proCBuscaTipoDocumento");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdTipoDocumento[LEN_IDTIPODOCUMENTO];
        VARCHAR oszSgTipoDocumento[LEN_SGTIPODOCUMENTO];
        VARCHAR oszDsTipoDocumento[LEN_DSTIPODOCUMENTO];
        VARCHAR oszIdTipoPessoa[LEN_IDTIPOPESSOA];
        VARCHAR oszNrPrioridade[LEN_NRPRIORIDADE];
        VARCHAR oszSgClassificacao[LEN_SGCLASSIFICACAO];

        short iIdTipoDocumento = 0;
        short iSgTipoDocumento = 0;
        short iDsTipoDocumento = 0;
        short iIdTipoPessoa = 0;
        short iNrPrioridade = 0;
        short iSgClassificacao = 0;
    EXEC SQL END DECLARE SECTION;

	struct sqlca sqlca;


	/* atribuicao de valores para as variaveis proc */
	STRCPY_TO_ORA(oszSgClassificacao, ptTipoDocumento->szSgClassificacao);

	EXEC SQL WHENEVER SQLERROR	goto erro;
	EXEC SQL WHENEVER NOT FOUND goto naoexiste;

	EXEC SQL
        SELECT
            idtipodocumento,
            sgclassificacao,
            dstipodocumento,
            idtipopessoa,
            nrprioridade,
            sgclassificacao
        INTO
            :oszIdTipoDocumento:iIdTipoDocumento,
            :oszSgTipoDocumento:iSgTipoDocumento,
            :oszDsTipoDocumento:iDsTipoDocumento,
            :oszIdTipoPessoa:iIdTipoPessoa,
            :oszNrPrioridade:iNrPrioridade,
            :oszSgClassificacao:iSgClassificacao
        FROM
            apoio.tipodocumento
        WHERE
            SGTIPODOCUMENTO = :oszSgClassificacao;

    if(iIdTipoDocumento != -1) {
        STRCPY_FROM_ORA(ptTipoDocumento->szIdTipoDocumento, oszIdTipoDocumento);
    }
    if(iSgTipoDocumento != -1) {
        STRCPY_FROM_ORA(ptTipoDocumento->szSgTipoDocumento, oszSgTipoDocumento);
    }
    if(iDsTipoDocumento != -1) {
        STRCPY_FROM_ORA(ptTipoDocumento->szDsTipoDocumento, oszDsTipoDocumento);
    }
    if(iIdTipoPessoa != -1) {
        STRCPY_FROM_ORA(ptTipoDocumento->szIdTipoPessoa, oszIdTipoPessoa);
    }
    if(iNrPrioridade != -1) {
        STRCPY_FROM_ORA(ptTipoDocumento->szNrPrioridade, oszNrPrioridade);
    }
    if(iSgClassificacao != -1) {
        STRCPY_FROM_ORA(ptTipoDocumento->szSgClassificacao, oszSgClassificacao);
    }

    ULOGI("Finalizando proCBuscaTipoDocumento <OK>");
    ULOG_END("CTipoDocumentopc::proCBuscaTipoDocumento");
    return true;

    naoexiste:
        ULOGI("Finalizando proCBuscaTipoDocumento <NOT FOUND>");
        ULOG_END("CTipoDocumentopc::proCBuscaTipoDocumento");
        return false;

    erro:
        ULOGE("Finalizando proCBuscaTipoDocumento <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/****************************************************************************************/
bool CTipoDocumentopc::proCBuscaTipoDocumentoInscricao(TTipoDocumento *ptTipoDocumento)
{
    ULOG_START("CTipoDocumentopc::proCBuscaTipoDocumentoInscricao");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdTipoDocumento[LEN_IDTIPODOCUMENTO];
        VARCHAR oszSgTipoDocumento[LEN_SGTIPODOCUMENTO];
        VARCHAR oszSgClassificacao[LEN_SGCLASSIFICACAO];
        VARCHAR oszDsTipoDocumento[LEN_DSTIPODOCUMENTO];

        short iIdTipoDocumento = 0;
        short iSgTipoDocumento = 0;
        short iSgClassificacao = 0;
        short iDsTipoDocumento = 0;
    EXEC SQL END DECLARE SECTION;

	struct sqlca sqlca;

	/* atribuicao de valores para as variaveis proc */
	STRCPY_TO_ORA(oszSgClassificacao, ptTipoDocumento->szSgClassificacao);

	EXEC SQL WHENEVER SQLERROR	goto erro;
	EXEC SQL WHENEVER NOT FOUND goto naoexiste;

	EXEC SQL
        SELECT
            atd.idtipodocumento,
            atd.sgtipodocumento,
            atd.dstipodocumento,
            atd.sgclassificacao
        INTO
            :oszIdTipoDocumento:iIdTipoDocumento,
            :oszSgTipoDocumento:iSgTipoDocumento,
            :oszDsTipoDocumento:iDsTipoDocumento,
            :oszSgClassificacao:iSgClassificacao
        FROM
            apoio.tipodocumento atd
        WHERE  
            atd.sgclassificacao = :oszSgClassificacao
        AND     
            atd.invisualiza = 1
        AND
            atd.sgclassificacao IN ('IE', 'IF', 'IM', 'II');


    if(iIdTipoDocumento != -1) {
        STRCPY_FROM_ORA(ptTipoDocumento->szIdTipoDocumento, oszIdTipoDocumento);
    }

    if(iSgTipoDocumento != -1) {
        STRCPY_FROM_ORA(ptTipoDocumento->szSgTipoDocumento, oszSgTipoDocumento);
    }

    if(iDsTipoDocumento != -1) {
        STRCPY_FROM_ORA(ptTipoDocumento->szDsTipoDocumento, oszDsTipoDocumento);
    }

    if(iSgClassificacao != -1) {
        STRCPY_FROM_ORA(ptTipoDocumento->szSgClassificacao, oszSgClassificacao);
    }

    ULOGI("Finalizando proCBuscaTipoDocumentoInscricao <OK>");
    ULOG_END("CTipoDocumentopc::proCBuscaTipoDocumentoInscricao");
    return true;

    naoexiste:
        ULOGI("Finalizando proCBuscaTipoDocumentoInscricao <NOT FOUND>");
        ULOG_END("CTipoDocumentopc::proCBuscaTipoDocumentoInscricao");
        return false;

    erro:
        ULOGE("Finalizando proCBuscaTipoDocumentoInscricao <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}
