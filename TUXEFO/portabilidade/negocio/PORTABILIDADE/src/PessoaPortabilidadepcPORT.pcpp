#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>

#include "tuxfw.h"
#include "PessoaPortabilidadepcPORT.h"

EXEC SQL BEGIN DECLARE SECTION;
#include "PPGlobalPORT.h"
EXEC SQL END DECLARE SECTION;

/****************************************************************************************/
bool CPessoaPortabilidadepc::proCInserePessoaPortabilidade(TPessoaPortabilidade *ptPessoaPortabilidade)
{
    ULOG_START("CPessoaPortabilidadepc::proCInserePessoaPortabilidade");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszInSincronizado[LEN_INSINCRONIZADO];
        VARCHAR oszIdTipoPessoa[LEN_IDTIPOPESSOA];
        VARCHAR oszIdPessoaDePara[LEN_IDPESSOADEPARA];
        VARCHAR oszIdTipoLinha[LEN_IDTIPOLINHA];
        VARCHAR oszCdAreaRegistro[LEN_CDAREAREGISTRO];
        VARCHAR oszNrLinha[LEN_NRLINHA];
        VARCHAR oszIdAcaoPortabilidade[LEN_IDACAOPORTABILIDADE];
        VARCHAR oszIdUsuarioAlteracao[LEN_IDUSUARIOALTERACAO];
    EXEC SQL END DECLARE SECTION;

	struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro;

	STRCPY_TO_ORA(oszInSincronizado,        ptPessoaPortabilidade->szInSincronizado);
	STRCPY_TO_ORA(oszIdTipoPessoa,          ptPessoaPortabilidade->szIdTipoPessoa);
	STRCPY_TO_ORA(oszIdPessoaDePara,        ptPessoaPortabilidade->szIdPessoaDePara);
	STRCPY_TO_ORA(oszIdTipoLinha,           ptPessoaPortabilidade->szIdTipoLinha);
	STRCPY_TO_ORA(oszCdAreaRegistro,        ptPessoaPortabilidade->szCdAreaRegistro);
	STRCPY_TO_ORA(oszNrLinha,               ptPessoaPortabilidade->szNrLinha);
	STRCPY_TO_ORA(oszIdAcaoPortabilidade,   ptPessoaPortabilidade->szIdAcaoPortabilidade);
	STRCPY_TO_ORA(oszIdUsuarioAlteracao,    ptPessoaPortabilidade->szIdUsuarioAlteracao);


    EXEC SQL INSERT INTO customer.pessoaportabilidade
        ( 
            insincronizado,
            idtipopessoa,
            idpessoadepara,
            idtipolinha,
            cdarearegistro,
            nrlinha,
            idacaoportabilidade,
            idusuarioalteracao,
            dtultimaalteracao
        )
        VALUES
        (
            :oszInSincronizado,
            :oszIdTipoPessoa,
            :oszIdPessoaDePara,
            :oszIdTipoLinha,
            :oszCdAreaRegistro,
            :oszNrLinha,
            :oszIdAcaoPortabilidade,
            :oszIdUsuarioAlteracao,
            SYSDATE
        );

    ULOGI("Finalizando proCInserePessoaPortabilidade <OK>");
    ULOG_END("CPessoaPortabilidadepc::proCInserePessoaPortabilidade");
    return true;

    erro:
        ULOGE("Finalizando proCInserePessoaPortabilidade <ERROR>");
        ULOGE( "*** ERRO: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc );
        return false;
        /* throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml); */
}

/****************************************************************************************/
void CPessoaPortabilidadepc::proCAtualizaPessoaPortabilidade(TPessoaPortabilidade *ptPessoaPortabilidade)
{
    ULOG_START("CPessoaPortabilidadepc::proCAtualizaPessoaPortabilidade");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoaDePara[LEN_IDPESSOADEPARA + LEN_EOS];
        VARCHAR oszIdUsuarioAlteracao[LEN_IDUSUARIOALTERACAO + LEN_EOS];
	    VARCHAR oszIdTipoLinha[LEN_IDTIPOLINHA + LEN_EOS];
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

	STRCPY_TO_ORA(oszIdPessoaDePara,        ptPessoaPortabilidade->szIdPessoaDePara);
	STRCPY_TO_ORA(oszIdUsuarioAlteracao,    ptPessoaPortabilidade->szIdUsuarioAlteracao);
	STRCPY_TO_ORA(oszIdTipoLinha,           ptPessoaPortabilidade->szIdTipoLinha);

    EXEC SQL WHENEVER SQLERROR goto erro;

    EXEC SQL UPDATE customer.pessoaportabilidade
                SET
                    idtipolinha = :oszIdTipoLinha,
                    idusuarioalteracao = :oszIdUsuarioAlteracao,
                    dtultimaalteracao = SYSDATE
              WHERE
                    idpessoadepara = :oszIdPessoaDePara; 

    ULOGI("Finalizando proCAtualizaPessoaPortabilidade <OK>");
    ULOG_END("CPessoaPortabilidadepc::proCAtualizaPessoaPortabilidade");
    return;

    erro:
        ULOGE("Finalizando proCAtualizaPessoaPortabilidade <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}

/****************************************************************************************/
bool CPessoaPortabilidadepc::proCBuscaPessoaPortabilidade(TPessoaPortabilidade *ptPessoaPortabilidade)
{
    ULOG_START("CPessoaPortabilidadepc::proCBuscaPessoaPortabilidade");

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszInSincronizado[LEN_INSINCRONIZADO];
        VARCHAR oszIdTipoPessoa[LEN_IDTIPOPESSOA];
        VARCHAR oszIdPessoaDePara[LEN_IDPESSOADEPARA];
        VARCHAR oszIdTipoLinha[LEN_IDTIPOLINHA];
        VARCHAR oszCdAreaRegistro[LEN_CDAREAREGISTRO];
        VARCHAR oszNrLinha[LEN_NRLINHA];
        VARCHAR oszIdUsuarioAlteracao[LEN_IDUSUARIOALTERACAO];
        VARCHAR oszIdAcaoPortabilidade[LEN_IDACAOPORTABILIDADE];

        short oiInSincronizado = 0;
        short oiIdTipoPessoa = 0;
        short oiIdPessoaDePara = 0;
        short oiIdTipoLinha = 0;
        short oiCdAreaRegistro = 0;
        short oiNrLinha = 0;
        short oiIdUsuarioAlteracao = 0;
        short oiIdAcaoPortabilidade = 0;
    EXEC SQL END DECLARE SECTION;

	struct sqlca sqlca;


	/* atribuicao de valores para as variaveis proc */
	STRCPY_TO_ORA(oszCdAreaRegistro, ptPessoaPortabilidade->szCdAreaRegistro);
	STRCPY_TO_ORA(oszNrLinha, ptPessoaPortabilidade->szNrLinha);
	STRCPY_TO_ORA(oszIdTipoPessoa, ptPessoaPortabilidade->szIdTipoPessoa);
	STRCPY_TO_ORA(oszIdTipoLinha, ptPessoaPortabilidade->szIdTipoLinha);

	EXEC SQL WHENEVER SQLERROR	goto erro;
	EXEC SQL WHENEVER NOT FOUND goto naoexiste;

	EXEC SQL
        SELECT
            insincronizado,
            idtipopessoa,
            idpessoadepara,
            idtipolinha,
            cdarearegistro,
            nrlinha,
            idacaoportabilidade,
            idusuarioalteracao
        INTO
            :oszInSincronizado:oiInSincronizado,
            :oszIdTipoPessoa:oiIdTipoPessoa,
            :oszIdPessoaDePara:oiIdPessoaDePara,
            :oszIdTipoLinha:oiIdTipoLinha,
            :oszCdAreaRegistro:oiCdAreaRegistro,
            :oszNrLinha:oiNrLinha,
            :oszIdAcaoPortabilidade:oiIdAcaoPortabilidade,
            :oszIdUsuarioAlteracao:oiIdUsuarioAlteracao
        FROM
            customer.pessoaportabilidade
        WHERE
            insincronizado = 0
        AND
            nrlinha = :oszNrLinha
        AND
            cdarearegistro = :oszCdAreaRegistro
        --//AND
        --//    idtipolinha = :oszIdTipoLinha
        AND
            idtipopessoa = :oszIdTipoPessoa;


    if(oiInSincronizado != -1) {
        STRCPY_FROM_ORA(ptPessoaPortabilidade->szInSincronizado, oszInSincronizado);
    }
    if(oiIdTipoPessoa != -1) {
        STRCPY_FROM_ORA(ptPessoaPortabilidade->szIdTipoPessoa, oszIdTipoPessoa);
    }
    if(oiIdPessoaDePara != -1) {
        STRCPY_FROM_ORA(ptPessoaPortabilidade->szIdPessoaDePara, oszIdPessoaDePara);
    }
    if(oiIdTipoLinha != -1) {
        STRCPY_FROM_ORA(ptPessoaPortabilidade->szIdTipoLinha, oszIdTipoLinha);
    }
    if(oiCdAreaRegistro != -1) {
        STRCPY_FROM_ORA(ptPessoaPortabilidade->szCdAreaRegistro, oszCdAreaRegistro);
    }
    if(oiNrLinha != -1) {
        STRCPY_FROM_ORA(ptPessoaPortabilidade->szNrLinha, oszNrLinha);
    }
    if(oiIdAcaoPortabilidade != -1) {
        STRCPY_FROM_ORA(ptPessoaPortabilidade->szIdAcaoPortabilidade, oszIdAcaoPortabilidade);
    }
    if(oiIdUsuarioAlteracao != -1) {
        STRCPY_FROM_ORA(ptPessoaPortabilidade->szIdUsuarioAlteracao, oszIdUsuarioAlteracao);
    }


    ULOGI("Finalizando proCBuscaPessoaPortabilidade <OK>");
    ULOG_END("CPessoaPortabilidadepc::proCBuscaPessoaPortabilidade");
    return true;

    naoexiste:
        ULOGI("Finalizando proCBuscaPessoaPortabilidade <NOT FOUND>");
        ULOG_END("CPessoaPortabilidadepc::proCBuscaPessoaPortabilidade");
        return false;

    erro:
        ULOGE("Finalizando proCBuscaPessoaPortabilidade <ERROR>");
        throw new TuxBasicOraException(sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, sqlca.sqlerrm.sqlerrml);
}
