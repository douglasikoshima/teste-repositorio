
#undef SQLCA
#define SQLCA_NONE

#include <tuxfw.h>
#include <sqlca.h>
#include <ctype.h>
 
EXEC SQL INCLUDE SQLCA;

char * rtrim(char *pStr)
{
	int rInd;

	if (pStr == NULL)
			return NULL;

   rInd = strlen(pStr) - 1;
   while ( isspace(pStr[rInd]) && rInd >= 0){
      rInd--;
   }

   pStr[rInd + 1] = '\0';
   
   return pStr;
}

char * ltrim(char *pStr)
{
	int lInd = 0;

	if (pStr == NULL)
			return NULL;

    //rInd = strlen(pStr) - 1;

    while (isspace(pStr[lInd])){
        lInd++;
	}

	pStr = pStr + lInd;
     
   return pStr;
}

char * trim(char *pStr){
	return ltrim(rtrim(pStr));		
}



void getByNumeroProcesso( char * cdContaPrm, char * numeroProcessoPrm, XMLGen * xml_g )
{
    ULOG_START( "getByNumeroProcesso()" );
    
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

       char cdConta[256];
       char numeroProcesso[256];
       
       char processo[256];
       char descricao[256];
       char status[256];
       char data[16];
       char cdcontaOUT[256];
       
       short i_processo  = -1;
       short i_descricao = -1;
       short i_status    = -1;
       short i_data      = -1;
       short i_cdcontaOUT   = -1;
       
    EXEC SQL END DECLARE SECTION;

    strcpy( cdConta       , cdContaPrm );
    strcpy( numeroProcesso, numeroProcessoPrm );
    
    ULOG( "cdConta        [%s]", cdConta ); 
    ULOG( "numeroProcesso [%s]", numeroProcesso );
    
    memset( processo            , 0x0, sizeof(processo) );
    memset( descricao, 0x0, sizeof(descricao) );
    memset( status  , 0x0, sizeof(status) );
    memset( data, 0x0, sizeof(data) );
    memset( cdcontaOUT  , 0x0, sizeof(cdcontaOUT) );

    EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
    EXEC SQL DECLARE csrNumeroProcesso CURSOR FOR
    select 
       processo, 
       descricao, 
       status, 
       data, 
       cdconta 
    from 
       contatoadm.solicitacoesvolev01 
    where cdconta = :cdConta
    and processo = :numeroProcesso
    order by processo desc;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL OPEN csrNumeroProcesso;
    for( ;; ) 
    {
        EXEC SQL FETCH csrNumeroProcesso INTO
             :processo:i_processo ,
             :descricao:i_descricao ,
             :status:i_status ,
             :data:i_data ,
             :cdcontaOUT:i_cdcontaOUT ;

        xml_g->createTag( "NumeroProcessoVO" );
            xml_g->addItem( "Processo",  trim(processo) );
            xml_g->addItem( "Descricao", trim(descricao) );
            xml_g->addItem( "Status", trim(status) );
            xml_g->addItem( "Data", trim(data) );
            xml_g->addItem( "cdConta", trim(cdcontaOUT) );
        xml_g->closeTag();
    }

    EXEC SQL CLOSE csrNumeroProcesso;

    ULOG_END( "getByNumeroProcesso()" );

    return;
 
    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode); 
}



void getByDateRange( char * cdContaPrm, char * startDatePrm, char * endDatePrm, XMLGen * xml_g )
{
    ULOG_START( "getByDateRange()" );
    
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

       char cdConta[256];
       char startDate[16];
       char endDate[16];
       
       char processo[256];
       char descricao[256];
       char status[256];
       char data[16];
       char cdcontaOUT[256];
       
       short i_processo  = -1;
       short i_descricao = -1;
       short i_status    = -1;
       short i_data      = -1;
       short i_cdcontaOUT   = -1;
       
    EXEC SQL END DECLARE SECTION;

    strcpy( cdConta   , cdContaPrm );
    strcpy( startDate , startDatePrm );
    strcpy( endDate   , endDatePrm );

    ULOG( "cdConta   [%s]", cdConta );
    ULOG( "startDate [%s]", startDate );
    ULOG( "endDate   [%s]", endDate );
    
    memset( processo            , 0x0, sizeof(processo) );
    memset( descricao, 0x0, sizeof(descricao) );
    memset( status  , 0x0, sizeof(status) );
    memset( data, 0x0, sizeof(data) );
    memset( cdcontaOUT  , 0x0, sizeof(cdcontaOUT) );

    EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
    EXEC SQL DECLARE csrNrProcessoFaixa CURSOR FOR
    select 
       processo, 
       descricao, 
       status, 
       data, 
       cdconta 
    from 
       contatoadm.solicitacoesvolev01 
    where cdconta = :cdConta
	and data between to_date( :startDate, 'DD/MM/YYYY') and to_date( :endDate, 'DD/MM/YYYY')
	order by processo desc;
    
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL OPEN csrNrProcessoFaixa;
    for( ;; ) 
    {
        EXEC SQL FETCH csrNrProcessoFaixa INTO
             :processo:i_processo ,
             :descricao:i_descricao ,
             :status:i_status ,
             :data:i_data ,
             :cdcontaOUT:i_cdcontaOUT ;

        xml_g->createTag( "NumeroProcessoVO" );
            xml_g->addItem( "Processo",  trim(processo) );
            xml_g->addItem( "Descricao", trim(descricao) );
            xml_g->addItem( "Status", trim(status) );
            xml_g->addItem( "Data", trim(data) );
            xml_g->addItem( "cdConta", trim(cdcontaOUT) );
        xml_g->closeTag();
    }

    EXEC SQL CLOSE csrNrProcessoFaixa;

    ULOG_END( "getByDateRange()" );

    return;
 
    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode); 
}



void getByConta( char * cdContaPrm, XMLGen * xml_g )
{
    ULOG_START( "getByConta()" );
    
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

       char cdConta[256];
       char startDate[16];
       char endDate[16];
       
       char processo[256];
       char descricao[256];
       char status[256];
       char data[16];
       char cdcontaOUT[256];
       
       short i_processo  = -1;
       short i_descricao = -1;
       short i_status    = -1;
       short i_data      = -1;
       short i_cdcontaOUT   = -1;
       
    EXEC SQL END DECLARE SECTION;

    strcpy( cdConta   , cdContaPrm );

    ULOG( "cdConta   [%s]", cdConta );
    
    memset( processo            , 0x0, sizeof(processo) );
    memset( descricao, 0x0, sizeof(descricao) );
    memset( status  , 0x0, sizeof(status) );
    memset( data, 0x0, sizeof(data) );
    memset( cdcontaOUT  , 0x0, sizeof(cdcontaOUT) );

    EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
    EXEC SQL DECLARE csrNrProcessoConta CURSOR FOR
    select 
       processo, 
       descricao, 
       status, 
       data, 
       cdconta 
    from 
       contatoadm.solicitacoesvolev01
    where 
       cdconta = :cdConta
    order by processo desc;
    
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL OPEN csrNrProcessoConta;
    for( ;; ) 
    {
        EXEC SQL FETCH csrNrProcessoConta INTO
             :processo:i_processo ,
             :descricao:i_descricao ,
             :status:i_status ,
             :data:i_data ,
             :cdcontaOUT:i_cdcontaOUT ;

        xml_g->createTag( "NumeroProcessoVO" );
            xml_g->addItem( "Processo",  trim(processo) );
            xml_g->addItem( "Descricao", trim(descricao) );
            xml_g->addItem( "Status", trim(status) );
            xml_g->addItem( "Data", trim(data) );
            xml_g->addItem( "cdConta", trim(cdcontaOUT) );
        xml_g->closeTag();
    }

    EXEC SQL CLOSE csrNrProcessoConta;

    ULOG_END( "getByConta()" );

    return;
 
    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode); 
}



void getProcessoStatusByNumeroProcesso( char * nrProcessoPrm, XMLGen * xml_g )
{
    ULOG_START( "getProcessoStatusByNumeroProcesso()" );
    
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

       char nrProcesso[256];
       
       char processo[256];
       char descricao[256];
       char status[256];
       char data[16];
       
       short i_processo  = -1;
       short i_descricao = -1;
       short i_status    = -1;
       short i_data      = -1;
       
    EXEC SQL END DECLARE SECTION;

    strcpy( nrProcesso , nrProcessoPrm );

    ULOG( "nrProcesso [%s]", nrProcesso );
    
    memset( processo   , 0x0, sizeof(processo) );
    memset( descricao  , 0x0, sizeof(descricao) );
    memset( status     , 0x0, sizeof(status) );
    memset( data       , 0x0, sizeof(data) );

    EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
    EXEC SQL DECLARE csrStatusProcesso CURSOR FOR
    select 
       processo, 
       status, 
       data 
    from 
       contatoadm.statusvolev01 
    where 
       processo = :nrProcesso ;
                     
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL OPEN csrStatusProcesso;
    for( ;; ) 
    {
        EXEC SQL FETCH csrStatusProcesso INTO
             :processo:i_processo ,
             :descricao:i_descricao ,
             :status:i_status ,
             :data:i_data ;

        xml_g->createTag( "NumeroProcessoVO" );
            xml_g->addItem( "Processo",  trim(processo) );
            xml_g->addItem( "Descricao", trim(descricao) );
            xml_g->addItem( "Status", trim(status) );
            xml_g->addItem( "Data", trim(data) );
        xml_g->closeTag();
    }

    EXEC SQL CLOSE csrStatusProcesso;

    ULOG_END( "getProcessoStatusByNumeroProcesso()" );

    return;
 
    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode); 
}



void getProcessoCamposByNumeroProcesso( char * nrProcessoPrm, XMLGen * xml_g )
{
    ULOG_START( "getProcessoCamposByNumeroProcesso()" );
    
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

       char nrProcesso[256];
       
       char idcampo[43];
       char nmcampo[256];
       char dsvalor[256];
       char processo[256];

       short i_idcampo  = -1;
       short i_nmcampo  = -1;
       short i_dsvalor  = -1;
       short i_processo = -1;
       
    EXEC SQL END DECLARE SECTION;

    strcpy( nrProcesso , nrProcessoPrm );

    ULOG( "nrProcesso [%s]", nrProcesso );
    
    memset( idcampo  , 0x0, sizeof(idcampo) );
    memset( nmcampo  , 0x0, sizeof(nmcampo) );
    memset( dsvalor  , 0x0, sizeof(dsvalor) );
    memset( processo , 0x0, sizeof(processo) );

    EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
    EXEC SQL DECLARE csrProcessoCampo CURSOR FOR
    select 
       cv.idcampo, 
       c.nmcampo, 
       cv.dsvalor, 
       cv.processo 
    from 
       contatoadm.campo c, 
       contatoadm.camposvolev01 cv 
    where 
       cv.idcampo = c.idcampo 
    and 
       cv.processo = :nrProcesso 
    order by cv.sequencia asc;
                     
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL OPEN csrProcessoCampo;
    for( ;; ) 
    {
        EXEC SQL FETCH csrProcessoCampo INTO
             :idcampo:i_idcampo ,
             :nmcampo:i_nmcampo ,
             :dsvalor:i_dsvalor ,
             :processo:i_processo ;

        xml_g->createTag( "ProcessoCampoVO" );
            xml_g->addItem( "idCampo",  trim(idcampo) );
            xml_g->addItem( "nmCampo", trim(nmcampo) );
            xml_g->addItem( "dsValor", trim(dsvalor) );
            xml_g->addItem( "Processo", trim(processo) );
        xml_g->closeTag();
    }

    EXEC SQL CLOSE csrProcessoCampo;

    ULOG_END( "getProcessoCamposByNumeroProcesso()" );

    return;
 
    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode); 
}
