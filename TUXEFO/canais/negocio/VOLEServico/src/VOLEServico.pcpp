
#undef SQLCA
#define SQLCA_NONE

#include <tuxfw.h>
#include <sqlca.h>
#include <ctype.h>
 
EXEC SQL INCLUDE SQLCA;

char * rtrim(char *pStr)
{
	int rInd;

	if (pStr == NULL)
			return NULL;

   rInd = strlen(pStr) - 1;
   while ( isspace(pStr[rInd]) && rInd >= 0){
      rInd--;
   }

   pStr[rInd + 1] = '\0';
   
   return pStr;
}

char * ltrim(char *pStr)
{
	int lInd = 0;

	if (pStr == NULL)
			return NULL;

    //rInd = strlen(pStr) - 1;

    while (isspace(pStr[lInd])){
        lInd++;
	}

	pStr = pStr + lInd;
     
   return pStr;
}

char * trim(char *pStr){
	return ltrim(rtrim(pStr));		
}



/*
void getSenhaByIdPessoaGestor( char * idPessoaGestorPrm, XMLGen* xml_g )
{
    ULOG_START( "getSenhaByIdPessoaGestor()" );
    
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

       char idPessoaGestor[42];
       char cdSenha[256];
       int  inTrocaSenha;
       int  qtTentativaErro;
       char dtUltimaAtualizacao[16];
       char sgtipostatussenha[256];
       
       short i_cdSenha             = -1;
       short i_inTrocaSenha        = -1;
       short i_qtTentativaErro     = -1;
       short i_dtUltimaAtualizacao = -1;
       short i_sgtipostatussenha   = -1;
       
    EXEC SQL END DECLARE SECTION;	
    
    memset( cdSenha            , 0x0, sizeof(cdSenha) );
    memset( dtUltimaAtualizacao, 0x0, sizeof(dtUltimaAtualizacao) );
    memset( sgtipostatussenha  , 0x0, sizeof(sgtipostatussenha) );
    strcpy( idPessoaGestor, idPessoaGestorPrm );
    
    ULOG( "idPessoaGestor [%s]", idPessoaGestor );

    EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
    EXEC SQL DECLARE csrSenhaPessoaGestor CURSOR FOR
        select 
           pgs.cdsenha, 
           pgs.introcasenha, 
           pgs.qttentativaerro, 
           TO_CHAR( pgs.dtultimaatualizacao, 'DD/MM/YYYY HH24:MI:SS') , 
           ss.sgtipostatussenha 
        from 
           customer.pessoagestorsenha pgs, 
           apoio.tipostatussenha ss 
        where 
           ss.idtipostatussenha = pgs.idtipostatussenha 
        and pgs.idpessoagestor = :idPessoaGestor;


    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL OPEN csrSenhaPessoaGestor;
    for( ;; ) 
    {
        EXEC SQL FETCH csrSenhaPessoaGestor INTO
             :cdSenha:i_cdSenha ,
             :inTrocaSenha:i_inTrocaSenha ,
             :qtTentativaErro:i_qtTentativaErro ,
             :dtUltimaAtualizacao:i_dtUltimaAtualizacao ,
             :sgtipostatussenha:i_sgtipostatussenha ;

        xml_g->createTag( "PessoaGestorVO" );
            xml_g->addItem( "cdSenha",  trim(cdSenha) );
            xml_g->addItem( "inTrocaSenha", inTrocaSenha );
            xml_g->addItem( "qtTentativaErro", qtTentativaErro );
            xml_g->addItem( "dtUltimaAtualizacao", trim(dtUltimaAtualizacao) );
            xml_g->addItem( "sgtipostatussenha", trim(sgtipostatussenha) );
        xml_g->closeTag();
    }

    EXEC SQL CLOSE csrSenhaPessoaGestor;

    ULOG_END( "getSenhaByIdPessoaGestor()" );

    return;
 
    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode); 
}
*/



/*
void insertSolicitacao( stServico * pServico )
{
    ULOG_START( "insertSolicitacao()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;	

        char nrProcessoServico[256];
        char idConta[256];
        char nmServico[256];
        char nrProtocolo[256];
        char nmAcao[256];
        char dsEmail[256];
        char nrSequencia[256];
        char nrSms[256];
        char dtCadastro[32];
        
    EXEC SQL END DECLARE SECTION;	

    strcpy( nrProcessoServico, (char*)pServico->nrProcessoServico );
    strcpy( idConta          , (char*)pServico->idConta );
    strcpy( nmServico        , (char*)pServico->nmServico );
    strcpy( nrProtocolo      , (char*)pServico->nrProtocolo );
    strcpy( nmAcao           , (char*)pServico->nmAcao );
    strcpy( dsEmail          , (char*)pServico->dsEmail );
    strcpy( nrSequencia      , (char*)pServico->nrSequencia );
    strcpy( nrSms            , (char*)pServico->nrSms );
    strcpy( dtCadastro       , (char*)pServico->dtCadastro );

    ULOG( "nrProcessoServico [%s]", nrProcessoServico );
    ULOG( "idConta           [%s]", idConta );
    ULOG( "nmServico         [%s]", nmServico );
    ULOG( "nrProtocolo       [%s]", nrProtocolo );
    ULOG( "nmAcao            [%s]", nmAcao );
    ULOG( "dsEmail           [%s]", dsEmail );
    ULOG( "nrSequencia       [%s]", nrSequencia );
    ULOG( "nrSms             [%s]", nrSms );
    ULOG( "dtCadastro        [%s]", dtCadastro );

    EXEC SQL WHENEVER SQLERROR  GOTO  sqlErrorConstrutor;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
    INSERT INTO vole.processoservico
    (
       nrprocessoservico ,
       idconta , 
       nmservico , 
       nrprotocolo , 
       nmacao ,  
       dsemail ,
       nrsequencia ,
       nrsms ,
       dtcadastro
    ) 
    VALUES
    (
       :nrProcessoServico ,
       :idConta ,
       :nmServico , 
       :nrProtocolo , 
       :nmAcao , 
       :dsEmail , 
       :nrSequencia ,
       :nrSms ,
       TO_DATE(:dtCadastro, "DD/MM/YYYY HH24:MI:SS" )
    );

    ULOG_END( "insertSolicitacao()" );

    return;

    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode);

}
*/



/*
bool isSenhaJaCadastrada( char * gestorIdPrm )
{
    ULOG_START( "isSenhaJaCadastrada()" );

    struct sqlca sqlca;
    bool retorno;

    EXEC SQL BEGIN DECLARE SECTION;

       int ct;
       char gestorId[42];
       
    EXEC SQL END DECLARE SECTION;
    
    strcpy( gestorId, gestorIdPrm );
    
    ULOG( "gestorId [%s]", gestorId );

    EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    EXEC SQL
    SELECT 
       count(idpessoagestor) as count
    INTO
       :ct
    FROM 
       customer.pessoagestorsenha 
    WHERE 
       idpessoagestor = :gestorId;

    ULOG( "ct [%d]", ct );
    
    retorno = (ct > 0) ? true : false ;
    
    ULOG( "retorno [%d]", retorno );

    ULOG_END( "isSenhaJaCadastrada()" );

    return retorno;
 
    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode); 
}



void getSenhaByConta( char * cdContaPrm, XMLGen * xml_g )
{
    ULOG_START( "getSenhaByConta()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

       char cdConta[256];
       char cdSenha[256];
       char flStatus[2];
       
       short i_cdSenha       = -1;
       short i_flStatus      = -1;
       
    EXEC SQL END DECLARE SECTION;	
    
    memset( cdSenha  , 0x0, sizeof(cdSenha) );
    memset( flStatus , 0x0, sizeof(flStatus) );
    strcpy( cdConta, cdContaPrm );
    
    ULOG( "cdConta [%s]", cdConta );

    EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    
    EXEC SQL DECLARE csrSenhaConta CURSOR FOR
        select 
           cs.cdsenha, 
           cs.flstatus 
        from 
           customer.contasenha cs 
        where 
           cs.cdconta = :cdConta ;


    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL OPEN csrSenhaConta;
    for( ;; ) 
    {
        EXEC SQL FETCH csrSenhaConta INTO
             :cdSenha:i_cdSenha ,
             :flStatus:i_flStatus ;

        xml_g->createTag( "SenhaContaVO" );
            xml_g->addItem( "cdSenha",  trim(cdSenha) );
            xml_g->addItem( "flStatus", trim(flStatus) );
        xml_g->closeTag();
    }

    EXEC SQL CLOSE csrSenhaConta;

    ULOG_END( "getSenhaByConta()" );

    return;
 
    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode); 
}



void incrementTentativesCounter( char * idPessoaGestorPrm )
{
    ULOG_START( "incrementTentativesCounter()" );
    
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;	

        char gestorId[256];
        
    EXEC SQL END DECLARE SECTION;

    strcpy ( gestorId, idPessoaGestorPrm );
    
    ULOG( "idpessoagestor [%s]", gestorId );

    EXEC SQL WHENEVER SQLERROR  GOTO  sqlErrorConstrutor;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
    update customer.pessoagestorsenha 
       set dtultimaatualizacao = sysdate, 
           qttentativaerro = qttentativaerro + 1 
     where idpessoagestor = :gestorId ;

    ULOG_END( "incrementTentativesCounter()" );
    return;

    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode);

}



void resetTentativesCounter( char * idPessoaGestorPrm )
{
    ULOG_START( "resetTentativesCounter()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;	

        char gestorId[256];
        
    EXEC SQL END DECLARE SECTION;

    strcpy ( gestorId, idPessoaGestorPrm );
    
    ULOG( "idpessoagestor [%s]", gestorId );

    EXEC SQL WHENEVER SQLERROR  GOTO  sqlErrorConstrutor;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
    update customer.pessoagestorsenha 
       set dtultimaatualizacao = sysdate, 
           qttentativaerro = 0 
     where idpessoagestor = :gestorId;
 
    ULOG_END( "resetTentativesCounter()" );

    return;

    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode);

}



void blockSenha( char * idPessoaGestorPrm )
{
    ULOG_START( "blockSenha()" );
    
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;	

        char gestorId[256];
        
    EXEC SQL END DECLARE SECTION;

    strcpy ( gestorId, idPessoaGestorPrm );
    ULOG( "idpessoagestor [%s]", gestorId );

    EXEC SQL WHENEVER SQLERROR  GOTO  sqlErrorConstrutor;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
    update customer.pessoagestorsenha 
       set dtultimaatualizacao = sysdate, 
           idtipostatussenha = (select t.idtipostatussenha 
                                  from apoio.tipostatussenha t 
                                 where t.sgtipostatussenha = 'B') 
     where idpessoagestor = :gestorId ;
 
    ULOG_END( "blockSenha()" );

    return;

    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode);

}



void atualizaSenha( char * gestorIdPrm, char * senhaTemporariaPrm, char * inTrocaSenhaPrm )
{
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;	

        char gestorId[256];
        char cdSenha[256];
        char inTrocaSenha[2];
        
    EXEC SQL END DECLARE SECTION;

    strcpy ( gestorId     , gestorIdPrm );
    strcpy ( cdSenha      , senhaTemporariaPrm );
    strcpy ( inTrocaSenha , inTrocaSenhaPrm );

    ULOG( "idpessoagestor [%s]", gestorId );
    ULOG( "cdSenha        [%s]", cdSenha );
    ULOG( "inTrocaSenha   [%s]", inTrocaSenha );

    EXEC SQL WHENEVER SQLERROR  GOTO  sqlErrorConstrutor;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
    update customer.pessoagestorsenha 
       set cdsenha = :cdSenha , 
           introcasenha = :inTrocaSenha , 
           dtultimaatualizacao = sysdate, 
           idtipostatussenha = 1, 
           qttentativaerro = 0 
     where idpessoagestor = :gestorId ;
 
    return;

    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode);

}

*/
