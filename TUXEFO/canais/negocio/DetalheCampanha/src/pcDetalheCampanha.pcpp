#include <stdio.h>
#include <tuxfw.h>

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
#include<string>
#include <iterator>
#include <list>
#include "../../negocio/UtilCanais/include/UtilCanais/UtilCanais.hpp"


using namespace std;

#define CONVIND(O,I) \
{\
    if (I == -1) { \
        ##O.arr[0]=0; \
    } else { \
        ##O.arr[##O.len]=0; \
    } \
}

typedef list<int> LISTA_ID;


// Prototipos
void SqlErrorDetalheCampanha( sqlca * sqlca );
void proCDetalheCampanha( int idCampanhaPrm, XMLGen * Saida );
void proCDetalheCampanhaDDD_Sel( int idCampanhaPrm, XMLGen * Saida );
void proCDetalheCampanhaTipoLinha_Sel( int idCampanhaPrm, XMLGen * Saida );
void proCDetalheCampanhaSegmentacao_Sel( int idCampanhaPrm, XMLGen * Saida );
void proCDetalheCampanhaDDD_Disp( int idCampanhaPrm, XMLGen * Saida );
void proCDetalheCampanhaTipoLinha_Disp( int idCampanhaPrm, XMLGen * Saida );
void proCDetalheCampanhaSegmentacao_Disp( int idCampanhaPrm, XMLGen * Saida );
void proCListaContatoDetalhe( int idCampanhaPrm, XMLGen * Saida );


void proCDetalheCampanha( int idCampanhaPrm, XMLGen * Saida )
{
      ULOG_START( "proCDetalheCampanha()" );
      
      struct sqlca sqlca;
      
      EXEC SQL BEGIN DECLARE SECTION;
         
         int idCampanha = idCampanhaPrm;
         int inExibeTermo;
         int idContato;
	 int inExibeCupom;
 	 int inExibePremio;
	 int inExibeQuestionario;
 	 int inPrecedente;
	 int tpCampanha;
         VARCHAR nmCampanha[51];
         VARCHAR dsCampanha[2001];
         VARCHAR dsRegulamento[2001];
         VARCHAR dtInicio[32];
         VARCHAR dtTermino[32];
         VARCHAR nmHistoricoRelac[31];
         VARCHAR cdSGP[16];
	 VARCHAR cdSGPConsulta[16];
	 int	 idItemMenu;
	 VARCHAR dsUrlAutenticador[210];
	 VARCHAR dsUrlFinal[210];
	 VARCHAR txtExplicativo[310];
	 VARCHAR dsPergunta[210];
	 VARCHAR dsRespostaCorreta[60];
	 VARCHAR dsRespostaIncorreta[60];
	 VARCHAR cdLegado[60];
	 int tpPessoa = 1;
         
         short i_nmCampanha = -1;
         short i_dsCampanha = -1;
         short i_dsRegulamento = -1;
         short i_dtInicio = -1;
         short i_dtTermino = -1;
         short i_nmHistoricoRelac = -1;
         short i_cdSGP = -1;
	 short i_inExibeCupom = -1;
	 short i_inExibePremio = -1;
	 short i_inExibeQuestionario = -1;
	 short i_inPrecedente = -1;
	 short i_cdSGPConsulta = -1;
	 short i_tpCampanha = -1;
	 short i_idItemMenu = -1;
	 short i_dsUrlAutenticador = -1;
	 short i_dsUrlFinal = -1;
	 
	
         
      EXEC SQL END DECLARE SECTION;
      
      memset( &nmCampanha,0x0,sizeof(nmCampanha) );
      memset( &dsCampanha,0x0,sizeof(dsCampanha) );
      memset( &dsRegulamento,0x0,sizeof(dsRegulamento) );
      memset( &dtInicio,0x0,sizeof(dtInicio) );
      memset( &dtTermino,0x0,sizeof(dtTermino) );
      memset( &nmHistoricoRelac,0x0,sizeof(nmHistoricoRelac) );
      memset( &dtTermino,0x0,sizeof(dtTermino) );
      memset( &nmHistoricoRelac,0x0,sizeof(nmHistoricoRelac) );
      memset( &cdSGP,0x0,sizeof(cdSGP) );
      memset( &cdSGPConsulta,0x0,sizeof(cdSGPConsulta) );
      memset( &dsUrlAutenticador,0x0,sizeof(dsUrlAutenticador) );
      memset( &dsUrlFinal,0x0,sizeof(dsUrlFinal) );
      
      memset( &txtExplicativo,0x0,sizeof(txtExplicativo) );
      memset( &dsPergunta,0x0,sizeof(dsPergunta) );
      memset( &dsRespostaCorreta,0x0,sizeof(dsRespostaCorreta) );
      memset( &dsRespostaIncorreta,0x0,sizeof(dsRespostaIncorreta) );
	  memset( &cdLegado,0x0,sizeof(cdLegado) );
	  


      EXEC SQL WHENEVER SQLERROR DO SqlErrorDetalheCampanha( &sqlca );

      EXEC SQL 
      SELECT
         NMCAMPANHA ,
         DSCAMPANHA ,
         DSREGULAMENTO ,
         INEXIBETERMO ,
         IDCONTATO ,
         NMHISTORICORELAC ,
         CDSGP ,
         TO_CHAR(TRUNC(DTINICIO),'DD/MM/YYYY')   ,
         TO_CHAR(TRUNC(DTTERMINO),'DD/MM/YYYY') ,
	 INEXIBECUPOM,
	 INPRECEDENTE,
	 INEXIBEQUESTIONARIO,
	 INEXIBEPREMIO,
	 CDSGPCONSULTA,
	 TPCAMPANHA,
	 DECODE (IDITEMMENU, NULL, 0, IDITEMMENU),
	 NVL (DSURLAUTENTICADOR, ' '),
	 NVL (DSURLFINAL, ' '),
	 NVL (DSTEXTOEXPLICATIVO, ' '),
	 NVL (DSPERGUNTA, ' '),
	 NVL (DSRESPOSTACORRETA, ' '),
 	 NVL (DSRESPOSTAINCORRETA, ' '),
	 IDTIPOPESSOA,
	 NVL (CDLEGADO, ' ')
      INTO
         :nmCampanha:i_nmCampanha ,
         :dsCampanha:i_dsCampanha ,
         :dsRegulamento:i_dsRegulamento ,
         :inExibeTermo ,
         :idContato ,
         :nmHistoricoRelac:i_nmHistoricoRelac ,
         :cdSGP:i_cdSGP ,
         :dtInicio:i_dtInicio ,
         :dtTermino:i_dtTermino,
	 :inExibeCupom:i_inExibeCupom,
	 :inPrecedente:i_inPrecedente,
 	 :inExibeQuestionario:i_inExibeQuestionario,
 	 :inExibePremio:i_inExibePremio,
         :cdSGPConsulta:i_cdSGPConsulta,
	 :tpCampanha:i_tpCampanha,
	 :idItemMenu:i_idItemMenu,
	 :dsUrlAutenticador:i_dsUrlAutenticador,
	 :dsUrlFinal:i_dsUrlFinal,
	 :txtExplicativo,
	 :dsPergunta,
	 :dsRespostaCorreta,
	 :dsRespostaIncorreta,
	 :tpPessoa,
	 :cdLegado
      FROM
         vol.campanhace campanhace
      WHERE
         campanhace.idcampanha = :idCampanha;

      CONVIND( nmCampanha,i_nmCampanha );
      CONVIND( dsCampanha,i_dsCampanha );
      CONVIND( dsRegulamento,i_dsRegulamento );
      CONVIND( nmHistoricoRelac,i_nmHistoricoRelac );
      CONVIND( cdSGP,i_cdSGP );
      CONVIND( cdSGPConsulta, i_cdSGP );
      CONVIND( dtInicio,i_dtInicio );
      CONVIND( dtTermino,i_dtTermino );
              
      Saida->addItem( "idCampanha"   , idCampanha );
	   //Saida->addProp("xmlns:vo","campanha.fo.vivo.com.br/vo");

      Saida->addItem( "nmCampanha"   , (char *)nmCampanha.arr );
	   //Saida->addProp("xmlns:vo","campanha.fo.vivo.com.br/vo");

      Saida->addItem( "dsCampanha"   , (char *)dsCampanha.arr );
	   //Saida->addProp("xmlns:vo","campanha.fo.vivo.com.br/vo");

      Saida->addItem( "dsRegulamento"   , (char *)dsRegulamento.arr );
	   //Saida->addProp("xmlns:vo","campanha.fo.vivo.com.br/vo");

      Saida->addItem( "inAceite"   , inExibeTermo );
	   //Saida->addProp("xmlns:vo","campanha.fo.vivo.com.br/vo");

      Saida->addItem( "idContato"   , idContato );
	   //Saida->addProp("xmlns:vo","campanha.fo.vivo.com.br/vo");

      Saida->addItem( "dsHistRelacionamento"   , (char *)nmHistoricoRelac.arr );
	   //Saida->addProp("xmlns:vo","campanha.fo.vivo.com.br/vo");

      Saida->addItem( "dsCodigo"   , (char *)cdSGP.arr );
	   //Saida->addProp("xmlns:vo","campanha.fo.vivo.com.br/vo");

      Saida->addItem( "dtValidadeDe" , (char *)dtInicio.arr );
	   //Saida->addProp("xmlns:vo","campanha.fo.vivo.com.br/vo");

      Saida->addItem( "dtValidadeAte", (char *)dtTermino.arr );
	   //Saida->addProp("xmlns:vo","campanha.fo.vivo.com.br/vo");

      Saida->addItem( "inExibeCupom", inExibeCupom );

      Saida->addItem( "inExibePremio", inExibePremio );

      Saida->addItem( "inExibeQuestionario", inExibeQuestionario );

      Saida->addItem( "inPrecedente", inPrecedente );

      Saida->addItem( "cdSGPConsulta", (char *)cdSGPConsulta.arr );

      Saida->addItem( "tpCampanha", tpCampanha);

      Saida->addItem( "idItemMenu", idItemMenu);

      Saida->addItem( "dsUrlAutenticador", CUtilCanais::trim((char *)dsUrlAutenticador.arr));

      Saida->addItem( "dsUrlFinal", CUtilCanais::trim((char *)dsUrlFinal.arr));

      Saida->addItem( "txtExplicativo", CUtilCanais::trim((char *)txtExplicativo.arr));

      Saida->addItem( "dsPergunta", CUtilCanais::trim((char *)dsPergunta.arr));

      Saida->addItem( "dsRespostaCorreta", CUtilCanais::trim((char *)dsRespostaCorreta.arr));

      Saida->addItem( "dsRespostaIncorreta",CUtilCanais::trim( (char *)dsRespostaIncorreta.arr));
	  
	  Saida->addItem( "tpPessoa"   , tpPessoa );
	  
	  Saida->addItem( "cdLegado"   , CUtilCanais::trim( (char *)cdLegado.arr) );
	  
      ULOG_END("proCDetalheCampanha()");

}


void proCDetalheCampanhaDDD_Sel( int idCampanhaPrm, XMLGen * Saida )
{
      ULOG_START( "proCDetalheCampanhaDDD_Sel()" );
      
      struct sqlca sqlca;
      
      EXEC SQL BEGIN DECLARE SECTION;
         int idCampanha = idCampanhaPrm;
         int idAreaRegistro;
         VARCHAR cdAreaRegistro[256];
         
         short   i_cdAreaRegistro = -1;
      EXEC SQL END DECLARE SECTION;

      memset( &cdAreaRegistro,0x0,sizeof(cdAreaRegistro) );

      EXEC SQL 
      DECLARE crConsultaAreaRegistro CURSOR FOR 
      SELECT 
         arearegistro.idarearegistro ,
         arearegistro.cdarearegistro
      FROM
         apoio.arearegistro arearegistro ,
         vol.campanhaceddd  campanhaceddd
      WHERE
         campanhaceddd.idarearegistro = arearegistro.idarearegistro
      AND
         campanhaceddd.idcampanha = :idCampanha
      ORDER BY arearegistro.cdarearegistro;
        
      EXEC SQL WHENEVER SQLERROR DO SqlErrorDetalheCampanha( &sqlca );
      
      EXEC SQL WHENEVER NOT FOUND DO BREAK;
      EXEC SQL OPEN crConsultaAreaRegistro;
      
      for( ;; )
      {
        EXEC SQL FETCH crConsultaAreaRegistro 
                       INTO :idAreaRegistro ,
                            :cdAreaRegistro:i_cdAreaRegistro ;


        CONVIND( cdAreaRegistro,i_cdAreaRegistro );

        Saida->createTag( "DDDVO" );
           Saida->addItem( "idDDD",idAreaRegistro );
           Saida->addItem( "dsDDD", (char*)cdAreaRegistro.arr );
        Saida->closeTag();
    }

    EXEC SQL CLOSE crConsultaAreaRegistro;

    ULOG_END("proCDetalheCampanhaDDD_Sel()");

}



void proCDetalheCampanhaTipoLinha_Sel( int idCampanhaPrm, XMLGen * Saida )
{
      ULOG_START( "proCDetalheCampanhaTipoLinha_Sel()" );
      
      struct sqlca sqlca;
      
      EXEC SQL BEGIN DECLARE SECTION;
         int idCampanha = idCampanhaPrm;
         int idtipolinha;
         VARCHAR dstipolinha[256];
         
         short   i_dstipolinha = -1;
      EXEC SQL END DECLARE SECTION;

      memset( &dstipolinha,0x0,sizeof(dstipolinha) );

      EXEC SQL 
      DECLARE crConsultaTipoLinha CURSOR FOR 
      SELECT 
         tipolinha.idtipolinha ,
         tipolinha.dstipolinha
      FROM
         apoio.tipolinha         tipolinha ,
         vol.campanhacetipolinha campanhacetipolinha
      WHERE
         campanhacetipolinha.idtipolinha = tipolinha.idtipolinha
      AND
         campanhacetipolinha.idcampanha = :idCampanha
      ORDER BY tipolinha.dstipolinha;
        
      EXEC SQL WHENEVER SQLERROR DO SqlErrorDetalheCampanha( &sqlca );
      
      EXEC SQL WHENEVER NOT FOUND DO BREAK;
      EXEC SQL OPEN crConsultaTipoLinha;
      
      for( ;; )
      {
        EXEC SQL FETCH crConsultaTipoLinha 
                       INTO :idtipolinha ,
                            :dstipolinha:i_dstipolinha ;


        CONVIND( dstipolinha,i_dstipolinha );

        Saida->createTag( "ns2:TipoLinhaVO" );
           Saida->addItem( "ns2:id",idtipolinha );
           Saida->addItem( "ns2:descricao", (char*)dstipolinha.arr );
        Saida->closeTag();
    }

    EXEC SQL CLOSE crConsultaTipoLinha;

    ULOG_END("proCDetalheCampanhaTipoLinha_Sel()");

}



void proCDetalheCampanhaSegmentacao_Sel( int idCampanhaPrm, XMLGen * Saida )
{
      ULOG_START( "proCDetalheCampanhaSegmentacao_Sel()" );
      
      struct sqlca sqlca;
      
      EXEC SQL BEGIN DECLARE SECTION;
         int idCampanha = idCampanhaPrm;
         int idSegmentacao;
         VARCHAR dsSegmentacao[256];
         
         short   i_dsSegmentacao = -1;
      EXEC SQL END DECLARE SECTION;

      memset( &dsSegmentacao,0x0,sizeof(dsSegmentacao) );

      EXEC SQL 
      DECLARE crConsultaSegmentacao CURSOR FOR 
      SELECT 
         segmentacao.idsegmentacao ,
         segmentacao.dssegmentacao
      FROM
         apoio.segmentacao         segmentacao ,
         vol.campanhacesegmentacao campanhacesegmentacao
      WHERE
         campanhacesegmentacao.idsegmentacao = segmentacao.idsegmentacao
      AND
         campanhacesegmentacao.idcampanha = :idCampanha
      ORDER BY segmentacao.dssegmentacao;
        
      EXEC SQL WHENEVER SQLERROR DO SqlErrorDetalheCampanha( &sqlca );
      
      EXEC SQL WHENEVER NOT FOUND DO BREAK;
      EXEC SQL OPEN crConsultaSegmentacao;
      
      for( ;; )
      {
        EXEC SQL FETCH crConsultaSegmentacao 
                       INTO :idSegmentacao ,
                            :dsSegmentacao:i_dsSegmentacao ;


        CONVIND( dsSegmentacao,i_dsSegmentacao );

        Saida->createTag( "ns3:SegmentacaoVO" );
           Saida->addItem( "ns3:idSegmentacao",idSegmentacao );
           Saida->addItem( "ns3:descricao", (char*)dsSegmentacao.arr );
        Saida->closeTag();
    }

    EXEC SQL CLOSE crConsultaSegmentacao;

    ULOG_END("proCDetalheCampanhaSegmentacao_Sel()");

}



void proCDetalheCampanhaDDD_Disp( int idCampanhaPrm, XMLGen * Saida )
{
      ULOG_START( "proCDetalheCampanhaDDD_Disp()" );
      
      struct sqlca sqlca;
      
      EXEC SQL BEGIN DECLARE SECTION;
         int idCampanha = idCampanhaPrm;
         int idAreaRegistro;
         VARCHAR cdAreaRegistro[256];
         
         short   i_cdAreaRegistro = -1;
      EXEC SQL END DECLARE SECTION;

      memset( &cdAreaRegistro,0x0,sizeof(cdAreaRegistro) );

      EXEC SQL 
      DECLARE crConsultaAreaRegistro_Disp CURSOR FOR 
      SELECT 
         a.idarearegistro ,
         a.cdarearegistro 
      FROM
         apoio.arearegistro a
      WHERE
         a.idarearegistro > 0
      AND
         a.idarearegistro NOT IN
         (
            SELECT 
               arearegistro.idarearegistro 
            FROM
               apoio.arearegistro arearegistro ,
               vol.campanhaceddd  campanhaceddd
            WHERE
               campanhaceddd.idarearegistro = arearegistro.idarearegistro
            AND
               campanhaceddd.idcampanha = :idCampanha
         )
         ORDER BY a.cdarearegistro;
              
      EXEC SQL WHENEVER SQLERROR DO SqlErrorDetalheCampanha( &sqlca );
      
      EXEC SQL WHENEVER NOT FOUND DO BREAK;
      EXEC SQL OPEN crConsultaAreaRegistro_Disp;
      
      for( ;; )
      {
        EXEC SQL FETCH crConsultaAreaRegistro_Disp 
                       INTO :idAreaRegistro ,
                            :cdAreaRegistro:i_cdAreaRegistro ;


        CONVIND( cdAreaRegistro,i_cdAreaRegistro );

        Saida->createTag( "DDDVO" );
           Saida->addItem( "idDDD",idAreaRegistro );
           Saida->addItem( "dsDDD", (char*)cdAreaRegistro.arr );
        Saida->closeTag();
    }

    EXEC SQL CLOSE crConsultaAreaRegistro_Disp;

    ULOG_END("proCDetalheCampanhaDDD_Disp()");

}



void proCDetalheCampanhaTipoLinha_Disp( int idCampanhaPrm, XMLGen * Saida )
{
      ULOG_START( "proCDetalheCampanhaTipoLinha_Disp()" );
      
      struct sqlca sqlca;
      
      EXEC SQL BEGIN DECLARE SECTION;
         int idCampanha = idCampanhaPrm;
         int idtipolinha;
         VARCHAR dstipolinha[256];
         
         short   i_dstipolinha = -1;
      EXEC SQL END DECLARE SECTION;

      memset( &dstipolinha,0x0,sizeof(dstipolinha) );

      EXEC SQL 
      DECLARE crConsultaTipoLinha_Disp CURSOR FOR 
      SELECT 
         a.idtipolinha ,
         a.dstipolinha
      FROM
         apoio.tipolinha  a 
      WHERE
         a.idtipolinha > 0
      AND
         a.idtipolinha NOT IN
         (
		      SELECT 
		         tipolinha.idtipolinha 
		      FROM
		         apoio.tipolinha         tipolinha ,
		         vol.campanhacetipolinha campanhacetipolinha
		      WHERE
		         campanhacetipolinha.idtipolinha = tipolinha.idtipolinha
		      AND
		         campanhacetipolinha.idcampanha = :idCampanha
         )
         ORDER BY a.dstipolinha;
         
      EXEC SQL WHENEVER SQLERROR DO SqlErrorDetalheCampanha( &sqlca );
      
      EXEC SQL WHENEVER NOT FOUND DO BREAK;
      EXEC SQL OPEN crConsultaTipoLinha_Disp;
      
      for( ;; )
      {
        EXEC SQL FETCH crConsultaTipoLinha_Disp 
                       INTO :idtipolinha ,
                            :dstipolinha:i_dstipolinha ;


        CONVIND( dstipolinha,i_dstipolinha );

        Saida->createTag( "ns2:TipoLinhaVO" );
           Saida->addItem( "ns2:id",idtipolinha );
           Saida->addItem( "ns2:descricao", (char*)dstipolinha.arr );
        Saida->closeTag();
    }

    EXEC SQL CLOSE crConsultaTipoLinha_Disp;

    ULOG_END("proCDetalheCampanhaTipoLinha_Disp()");

}



void proCDetalheCampanhaSegmentacao_Disp( int idCampanhaPrm, XMLGen * Saida )
{
      ULOG_START( "proCDetalheCampanhaSegmentacao_Disp()" );
      
      struct sqlca sqlca;
      
      EXEC SQL BEGIN DECLARE SECTION;
         int idCampanha = idCampanhaPrm;
         int idSegmentacao;
         VARCHAR dsSegmentacao[256];
         
         short   i_dsSegmentacao = -1;
      EXEC SQL END DECLARE SECTION;

      memset( &dsSegmentacao,0x0,sizeof(dsSegmentacao) );

      EXEC SQL 
      DECLARE crConsultaSegmentacao_Disp CURSOR FOR 
      SELECT 
         a.idsegmentacao ,
         a.dssegmentacao
      FROM
         apoio.segmentacao   a
      WHERE
         a.idsegmentacao > 0
	   AND
	     a.idsegmentacao NOT IN
      (
			SELECT 
			   segmentacao.idsegmentacao 
			FROM
			   apoio.segmentacao         segmentacao ,
			   vol.campanhacesegmentacao campanhacesegmentacao
			WHERE
			   campanhacesegmentacao.idsegmentacao = segmentacao.idsegmentacao
			AND
			   campanhacesegmentacao.idcampanha = :idCampanha
	   )
      ORDER BY a.dssegmentacao;
              
      EXEC SQL WHENEVER SQLERROR DO SqlErrorDetalheCampanha( &sqlca );
      
      EXEC SQL WHENEVER NOT FOUND DO BREAK;
      EXEC SQL OPEN crConsultaSegmentacao_Disp;
      
      for( ;; )
      {
        EXEC SQL FETCH crConsultaSegmentacao_Disp 
                       INTO :idSegmentacao ,
                            :dsSegmentacao:i_dsSegmentacao ;


        CONVIND( dsSegmentacao,i_dsSegmentacao );

        Saida->createTag( "ns3:SegmentacaoVO" );
           Saida->addItem( "ns3:idSegmentacao",idSegmentacao );
           Saida->addItem( "ns3:descricao", (char*)dsSegmentacao.arr );
        Saida->closeTag();
    }

    EXEC SQL CLOSE crConsultaSegmentacao_Disp;

    ULOG_END("proCDetalheCampanhaSegmentacao_Disp()");

}



void proCListaContatoDetalhe( int idCampanhaPrm, XMLGen * Saida )
{
      ULOG_START( "proCListaContatoDetalhe()" );
      
      struct sqlca sqlca;
      
      EXEC SQL BEGIN DECLARE SECTION;
         int idCampanha = idCampanhaPrm;
         int idcontato;
         VARCHAR nmpath[256];
         VARCHAR raiz[256];
         
         short   i_nmpath = -1;
         short   i_raiz = -1;
      EXEC SQL END DECLARE SECTION;

      ULOG( "idCampanha [%d]",idCampanha );
      memset( &nmpath,0x0,sizeof(nmpath) );
      
      EXEC SQL WHENEVER SQLERROR DO SqlErrorDetalheCampanha( &sqlca );
      
      EXEC SQL WHENEVER NOT FOUND CONTINUE;
      EXEC SQL
      SELECT
         parametro.dsvalorparametro
      INTO
         :raiz:i_raiz
      FROM
         apoio.parametro parametro
      WHERE
         parametro.cdparametro = 'CMP';
     
      CONVIND( raiz,i_raiz );

      EXEC SQL 
      select 
         c.idcontato, 
         n.nmcontato
      INTO :idcontato ,
           :nmpath:i_nmpath
      from 
         contatoadm.contatohierarquia h,
         contatoadm.contato c,
         vol.campanhace     a, 
         contatoadm.nomecontato n
      where 
         h.idcontato = c.idcontato
      and 
         n.idnomecontato = c.idnomecontato
      and 
         h.idcontatopai = TO_NUMBER( :raiz )
      and
         a.idcampanha = :idCampanha
      and
         a.idcontato = c.idcontato;
      
      ULOG( "Contato Relacionado [%d]",idcontato );

      if ( i_nmpath != -1 )
      {
         
         CONVIND( nmpath,i_nmpath );
         Saida->createTag( "ns3:AdmContatoVO" );
            Saida->addItem( "ns3:idContato",idcontato );
            Saida->addItem( "ns3:nmContato", (char*)nmpath.arr );
         Saida->closeTag();
      }
      i_nmpath = -1;

      
      /*
      EXEC SQL 
      DECLARE crConsultaContato CURSOR FOR 
      select 
         c.idcontato, 
         n.nmcontato 
      from 
         contatoadm.contatohierarquia h, 
         contatoadm.contato c, 
         contatoadm.nomecontato n
      where 
         h.idcontato = c.idcontato
      and 
         n.idnomecontato = c.idnomecontato
      and 
         h.idcontatopai = TO_NUMBER( :raiz )      
      order by n.nmcontato;
      */
      
      EXEC SQL 
      DECLARE crConsultaContato CURSOR FOR 
      select 
         c.idcontato, 
         n.nmcontato 
      from 
         contatoadm.contatohierarquia h,
         contatoadm.contato c, 
         contatoadm.nomecontato n
      where 
         h.idcontato = c.idcontato
      and 
         n.idnomecontato = c.idnomecontato
      and 
         h.idcontatopai = TO_NUMBER( :raiz )
      and
         c.idcontato not in
         (
            select
               idcontato
            from
               vol.campanhace
         )      
      order by n.nmcontato;
      
      
      EXEC SQL WHENEVER NOT FOUND DO BREAK;
      EXEC SQL OPEN crConsultaContato;
      
      for( ;; )
      {
        EXEC SQL FETCH crConsultaContato 
                       INTO :idcontato ,
                            :nmpath:i_nmpath ;

         ULOG( "Contato Nao Relacionado [%d]",idcontato );

        CONVIND( nmpath,i_nmpath );

        Saida->createTag( "ns3:AdmContatoVO" );
           Saida->addItem( "ns3:idContato",idcontato );
           Saida->addItem( "ns3:nmContato", (char*)nmpath.arr );
        Saida->closeTag();
    }

    EXEC SQL CLOSE crConsultaContato;

    ULOG_END("proCListaContatoDetalhe()");

}



void SqlErrorDetalheCampanha( sqlca * sqlca )
{
   ULOGE("SqlError -> sqlcode=%d,sqlerrmc=%.256s",sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc);
   throw new TuxBasicOraException(sqlca->sqlcode
                                  ,sqlca->sqlerrm.sqlerrmc
                                  ,sqlca->sqlerrm.sqlerrml);
}
