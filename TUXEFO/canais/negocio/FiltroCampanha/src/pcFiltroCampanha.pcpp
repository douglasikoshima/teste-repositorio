#include <stdio.h>
#include <tuxfw.h>

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>

#define CONVIND(O,I) \
{\
    if (I == -1) { \
        ##O.arr[0]=0; \
    } else { \
        ##O.arr[##O.len]=0; \
    } \
}

// Prototipos
void SqlErrorFiltroCampanha( sqlca * sqlca );
void proCListaAreaRegistro( XMLGen * Saida );
void proCListaTipoLinha( XMLGen * Saida );
void proCListaSegmentacao( XMLGen * Saida );
void proCListaCampanha( XMLGen * Saida, int tpCampanha);
void proCListaContato( XMLGen * Saida );


void proCListaAreaRegistro( XMLGen * Saida )
{
      ULOG_START( "proCListaAreaRegistro()" );
      
      struct sqlca sqlca;
      
      EXEC SQL BEGIN DECLARE SECTION;
         int idAreaRegistro;
         VARCHAR cdAreaRegistro[256];
         
         short   i_cdAreaRegistro = -1;
      EXEC SQL END DECLARE SECTION;

      memset( &cdAreaRegistro,0x0,sizeof(cdAreaRegistro) );

      EXEC SQL 
      DECLARE crConsultaAreaRegistro CURSOR FOR 
      SELECT 
         arearegistro.idarearegistro , 
         arearegistro.cdarearegistro
      FROM 
         apoio.arearegistro arearegistro
      WHERE
         arearegistro.idarearegistro > 0
      ORDER BY arearegistro.cdarearegistro;
        
      EXEC SQL WHENEVER SQLERROR DO SqlErrorFiltroCampanha( &sqlca );
      
      EXEC SQL WHENEVER NOT FOUND DO BREAK;
      EXEC SQL OPEN crConsultaAreaRegistro;
      
      for( ;; )
      {
        EXEC SQL FETCH crConsultaAreaRegistro 
                       INTO :idAreaRegistro ,
                            :cdAreaRegistro:i_cdAreaRegistro ;


        CONVIND( cdAreaRegistro,i_cdAreaRegistro );

        Saida->createTag( "DDDVO" );
           Saida->addItem( "idDDD",idAreaRegistro );
           Saida->addItem( "dsDDD", (char*)cdAreaRegistro.arr );
        Saida->closeTag();
    }

    EXEC SQL CLOSE crConsultaAreaRegistro;

    ULOG_END("proCListaAreaRegistro()");

}




void proCListaSegmentacao( XMLGen * Saida )
{
      ULOG_START( "proCListaSegmentacao()" );
      
      struct sqlca sqlca;
      
      EXEC SQL BEGIN DECLARE SECTION;
         int idSegmentacao;
         VARCHAR dsSegmentacao[256];
         
         short   i_dsSegmentacao = -1;
      EXEC SQL END DECLARE SECTION;

      memset( &dsSegmentacao,0x0,sizeof(dsSegmentacao) );

      EXEC SQL 
      DECLARE crConsultaSegmentacao CURSOR FOR 
      SELECT 
         segmentacao.idsegmentacao , 
         segmentacao.dssegmentacao
      FROM 
         apoio.segmentacao segmentacao
      WHERE
         segmentacao.idsegmentacao > 0
      ORDER BY segmentacao.dssegmentacao;
        
      EXEC SQL WHENEVER SQLERROR DO SqlErrorFiltroCampanha( &sqlca );
      
      EXEC SQL WHENEVER NOT FOUND DO BREAK;
      EXEC SQL OPEN crConsultaSegmentacao;
      
      for( ;; )
      {
        EXEC SQL FETCH crConsultaSegmentacao 
                       INTO :idSegmentacao ,
                            :dsSegmentacao:i_dsSegmentacao ;


        CONVIND( dsSegmentacao,i_dsSegmentacao );

        Saida->createTag( "ns3:SegmentacaoVO" );
           Saida->addItem( "ns3:idSegmentacao",idSegmentacao );
           Saida->addItem( "ns3:descricao", (char*)dsSegmentacao.arr );
        Saida->closeTag();
    }

    EXEC SQL CLOSE crConsultaSegmentacao;

    ULOG_END("proCListaSegmentacao()");

}



void proCListaTipoLinha( XMLGen * Saida )
{
      ULOG_START( "proCListaTipoLinha()" );
      
      struct sqlca sqlca;
      
      EXEC SQL BEGIN DECLARE SECTION;
         int idtipolinha;
         VARCHAR dstipolinha[256];
         
         short   i_dstipolinha = -1;
      EXEC SQL END DECLARE SECTION;

      memset( &dstipolinha,0x0,sizeof(dstipolinha) );

      EXEC SQL 
      DECLARE crConsultaTipoLinha CURSOR FOR 
      SELECT 
         tipolinha.idtipolinha , 
         tipolinha.dstipolinha
      FROM 
         apoio.tipolinha tipolinha
      WHERE
         tipolinha.idtipolinha > 0
      ORDER BY tipolinha.dstipolinha;
        
      EXEC SQL WHENEVER SQLERROR DO SqlErrorFiltroCampanha( &sqlca );
      
      EXEC SQL WHENEVER NOT FOUND DO BREAK;
      EXEC SQL OPEN crConsultaTipoLinha;
      
      for( ;; )
      {
        EXEC SQL FETCH crConsultaTipoLinha 
                       INTO :idtipolinha ,
                            :dstipolinha:i_dstipolinha ;


        CONVIND( dstipolinha,i_dstipolinha );

        Saida->createTag( "ns2:TipoLinhaVO" );
           Saida->addItem( "ns2:id",idtipolinha );
           Saida->addItem( "ns2:descricao", (char*)dstipolinha.arr );
        Saida->closeTag();
    }

    EXEC SQL CLOSE crConsultaTipoLinha;

    ULOG_END("proCListaTipoLinha()");

}



void proCListaCampanha( XMLGen * Saida, int tpCampanha )
{
      ULOG_START( "proCListaCampanha()" );
      
      struct sqlca sqlca;
      
      EXEC SQL BEGIN DECLARE SECTION;
         int idcampanha;
         VARCHAR nmcampanha[256];
	 int tpCampanhaSql = 0;
         
         short   i_nmcampanha = -1;
      EXEC SQL END DECLARE SECTION;

      memset( &nmcampanha,0x0,sizeof(nmcampanha) );
      tpCampanhaSql = tpCampanha;

      EXEC SQL 
      DECLARE crConsultaCampanha CURSOR FOR 
      SELECT
        campanhace.idcampanha ,
        campanhace.nmcampanha 
      FROM
        vol.campanhace
      WHERE
        campanhace.idcampanha > 0 AND
	 (tpCampanha = :tpCampanhaSql OR :tpCampanhaSql = 0)
		AND idtipopessoa = (select idtipopessoa from apoio.tipopessoa where sgtipopessoa = 'PF')
      ORDER BY campanhace.nmcampanha;
        
      EXEC SQL WHENEVER SQLERROR DO SqlErrorFiltroCampanha( &sqlca );
      
      EXEC SQL WHENEVER NOT FOUND DO BREAK;
      EXEC SQL OPEN crConsultaCampanha;
      
      for( ;; )
      {
        EXEC SQL FETCH crConsultaCampanha 
                       INTO :idcampanha ,
                            :nmcampanha:i_nmcampanha ;


        CONVIND( nmcampanha,i_nmcampanha );

        Saida->createTag( "CampanhaVO" );
           Saida->addItem( "idCampanha",idcampanha );
           Saida->addItem( "nmCampanha", (char*)nmcampanha.arr );
        Saida->closeTag();
      }
      
      EXEC SQL CLOSE crConsultaCampanha;

      ULOG_END("proCListaCampanha()");

}




void proCListaContato( XMLGen * Saida )
{
      ULOG_START( "proCListaContato()" );
      
      struct sqlca sqlca;
      
      EXEC SQL BEGIN DECLARE SECTION;
         int idcontato;
         VARCHAR nmpath[256];
         VARCHAR raiz[256];
         
         short   i_nmpath = -1;
         short   i_raiz = -1;
      EXEC SQL END DECLARE SECTION;

      memset( &nmpath,0x0,sizeof(nmpath) );
      
      EXEC SQL WHENEVER SQLERROR DO SqlErrorFiltroCampanha( &sqlca );
      
      EXEC SQL WHENEVER NOT FOUND CONTINUE;
      EXEC SQL
      SELECT
         parametro.dsvalorparametro
      INTO
         :raiz:i_raiz
      FROM
         apoio.parametro parametro
      WHERE
         parametro.cdparametro = 'CMP';
     
      CONVIND( raiz,i_raiz );

      /*
      EXEC SQL 
      DECLARE crConsultaContato CURSOR FOR 
      select 
         c.idcontato, 
         n.nmcontato 
      from 
         contatoadm.contatohierarquia h, 
         contatoadm.contato c, 
         contatoadm.nomecontato n
      where 
         h.idcontato = c.idcontato
      and 
         n.idnomecontato = c.idnomecontato
      and 
         h.idcontatopai = TO_NUMBER( :raiz )      
      order by n.nmcontato;
      */
      
      EXEC SQL 
      DECLARE crConsultaContato CURSOR FOR 
      select 
         c.idcontato, 
         n.nmcontato 
      from 
         contatoadm.contatohierarquia h,
         contatoadm.contato c, 
         contatoadm.nomecontato n
      where 
         h.idcontato = c.idcontato
      and 
         n.idnomecontato = c.idnomecontato
      and 
         h.idcontatopai = TO_NUMBER( :raiz )
      and
         c.idcontato not in
         (
            select
               idcontato
            from
               vol.campanhace
            where
               idCampanha > 0 
			   and idtipopessoa = (select idtipopessoa from apoio.tipopessoa where sgtipopessoa = 'PF')
         )      
      order by n.nmcontato;

              
      EXEC SQL WHENEVER NOT FOUND DO BREAK;
      EXEC SQL OPEN crConsultaContato;
      
      for( ;; )
      {
        EXEC SQL FETCH crConsultaContato 
                       INTO :idcontato ,
                            :nmpath:i_nmpath ;


        CONVIND( nmpath,i_nmpath );

        Saida->createTag( "ns3:AdmContatoVO" );
           Saida->addItem( "ns3:idContato",idcontato );
           Saida->addItem( "ns3:nmContato", (char*)nmpath.arr );
        Saida->closeTag();
    }

    EXEC SQL CLOSE crConsultaContato;

    ULOG_END("proCListaContato()");

}



void SqlErrorFiltroCampanha( sqlca * sqlca )
{
   ULOGE("SqlError -> sqlcode=%d,sqlerrmc=%.256s",sqlca->sqlcode,sqlca->sqlerrm.sqlerrmc);
   throw new TuxBasicOraException(sqlca->sqlcode
                                  ,sqlca->sqlerrm.sqlerrmc
                                  ,sqlca->sqlerrm.sqlerrml);
}
