
#undef SQLCA
#define SQLCA_NONE

#include <tuxfw.h>
#include <sqlca.h>
#include <ctype.h>
 
EXEC SQL INCLUDE SQLCA;

char * rtrim(char *pStr)
{
	int rInd;

	if (pStr == NULL)
			return NULL;

   rInd = strlen(pStr) - 1;
   while ( isspace(pStr[rInd]) && rInd >= 0){
      rInd--;
   }

   pStr[rInd + 1] = '\0';
   
   return pStr;
}

char * ltrim(char *pStr)
{
	int lInd = 0;

	if (pStr == NULL)
			return NULL;

    //rInd = strlen(pStr) - 1;

    while (isspace(pStr[lInd])){
        lInd++;
	}

	pStr = pStr + lInd;
     
   return pStr;
}

char * trim(char *pStr){
	return ltrim(rtrim(pStr));		
}



bool hasLinhaAssociada( char * cdContaPrm )
{
    ULOG_START( "hasLinhaAssociada()" );

    struct sqlca sqlca;
    bool retorno;

    EXEC SQL BEGIN DECLARE SECTION;

       int ct;
       char cdConta[42];
       
    EXEC SQL END DECLARE SECTION;
    
    strcpy( cdConta, cdContaPrm );
    
    ULOG( "cdConta [%s]", cdConta );

    EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    EXEC SQL
    select 
        count(1) as qtdlinhas 
    into
       :ct
    from 
        customer.pessoaconta pc , 
        customer.linhaconta lc , 
        customer.conta c 
    where c.idcontasistemaorigem = :cdConta 
    and pc.idconta = c.idconta 
    and pc.idtiporelacionamento = 2 
    and pc.idconta = lc.idconta(+);
                     
    ULOG( "ct [%d]", ct );
    
    retorno = (ct > 0) ? true : false ;
    
    ULOG( "retorno [%d]", retorno );

    ULOG_END( "hasLinhaAssociada()" );

    return retorno;
 
    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode); 
}



bool isLinhaVivo( char * areaCodePrm, char * phoneNumberPrm )
{
    ULOG_START( "isLinhaVivo()" );

    struct sqlca sqlca;
    bool retorno;

    EXEC SQL BEGIN DECLARE SECTION;

       int ct;
       char areaCode[8];
       char phoneNumber[16];
       
    EXEC SQL END DECLARE SECTION;
    
    strcpy( areaCode   , areaCodePrm );
    strcpy( phoneNumber, phoneNumberPrm );
    
    ULOG( "areaCode    [%s]", areaCode );
    ULOG( "phoneNumber [%s]", phoneNumber );

    EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    EXEC SQL
    select 
        count(1) as qtdLinhaVivo
    into
       :ct
	from 
        linha.linhabase lb, 
	    linha.linhatelefonica lt, 
		apoio.arearegistro ar 
    where 
        lb.nrlinha = :phoneNumber
	and ar.cdarearegistro = :areaCode 
	and ar.idarearegistro = lb.idarearegistro 
	and lt.idlinhabase = lb.idlinhabase ;

                
    ULOG( "ct [%d]", ct );
    
    retorno = (ct > 0) ? true : false ;
    
    ULOG( "retorno [%d]", retorno );

    ULOG_END( "isLinhaVivo()" );

    return retorno;
 
    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode); 
}



void getTipoLinhaVivo( char * areaCodePrm, char * phoneNumberPrm, char * tpLinhaPrm )
{
    ULOG_START( "getTipoLinhaVivo()" );

    struct sqlca sqlca;
    bool retorno;

    EXEC SQL BEGIN DECLARE SECTION;

       char areaCode[8];
       char phoneNumber[16];
       
       char tpLinha[64];
       
    EXEC SQL END DECLARE SECTION;
    
    strcpy( areaCode   , areaCodePrm );
    strcpy( phoneNumber, phoneNumberPrm );
    
    ULOG( "areaCode    [%s]", areaCode );
    ULOG( "phoneNumber [%s]", phoneNumber );

    EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    EXEC SQL
    SELECT DISTINCT
        CLASSIFICACAOTIPOLINHA.IDCLASSIFICACAOTIPOLINHA
    INTO
        :tpLinha
    FROM
        LINHA.LINHABASE LINHABASE,
        LINHA.LINHATELEFONICA LINHATELEFONICA,
        CUSTOMER.PESSOALINHA PESSOALINHA,
        CUSTOMER.PESSOADEPARA PESSOADEPARA,
        APOIO.ESTADOLINHA ESTADOLINHA,
        APOIO.TIPOLINHA TIPOLINHA,
        APOIO.CLASSIFICACAOTIPOLINHA CLASSIFICACAOTIPOLINHA,
        APOIO.AREAREGISTRO AREAREGISTRO
    WHERE
        LINHABASE.IDLINHABASE = LINHATELEFONICA.IDLINHABASE
    AND LINHABASE.IDESTADOLINHA = ESTADOLINHA.IDESTADOLINHA
    AND LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
    AND LINHATELEFONICA.IDLINHATELEFONICA = PESSOALINHA.IDLINHATELEFONICA
    AND ESTADOLINHA.INLINHACANCELADA = 0
    AND AREAREGISTRO.CDAREAREGISTRO = :areaCode
    AND LINHABASE.NRLINHA = :phoneNumber
    AND ESTADOLINHA.SGCLASSIFICACAO = 'A'
    AND LINHATELEFONICA.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
    AND TIPOLINHA.IDCLASSIFICACAOTIPOLINHA = CLASSIFICACAOTIPOLINHA.IDCLASSIFICACAOTIPOLINHA
    AND PESSOALINHA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA ;

    trim(tpLinha);
    ULOG( "*** Tipo de Linha [%s]", tpLinha );
    strcpy( tpLinhaPrm, tpLinha );

    ULOG_END( "getTipoLinhaVivo()" );

    return;
 
    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode); 
}



void getTelefonePorConta( char * idContaPrm, XMLGen * xml_g )
{
    ULOG_START( "getTelefonePorConta()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

       char idConta[256];

       char cdarearegistro[5];
       char nrlinha[16];
       char idLinhaSistemaOrigem[42];
       char idlinhatelefonica[42];
       
       long  idLinhaTel_Busca;
       short i_idLinhaTel_Busca = -1;
       
       short i_cdarearegistro  = -1;
       short i_nrlinha         = -1;
       short i_idLinhaSistemaOrigem = -1;
       short i_idlinhatelefonica = -1;
       
    EXEC SQL END DECLARE SECTION;	
    
    memset( cdarearegistro      , 0x0, sizeof(cdarearegistro) );
    memset( nrlinha             , 0x0, sizeof(nrlinha) );
    memset( idLinhaSistemaOrigem, 0x0, sizeof(idLinhaSistemaOrigem) );
    memset( idlinhatelefonica   , 0x0, sizeof(idlinhatelefonica) );
    
    strcpy( idConta, idContaPrm );
    
    ULOG( "idConta [%s]", idConta );

    EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
   
   /* 
    EXEC SQL DECLARE csrSenhaConta CURSOR FOR
    select 
        ar.cdarearegistro, 
        lb.nrlinha, 
        lt.idLinhaSistemaOrigem, 
        lt.idlinhatelefonica
    from 
        linha.linhatelefonica lt, 
		customer.linhaconta lc, 
		customer.conta c, 
		linha.linhabase lb,
		apoio.arearegistro ar
	where 
        lt.idlinhabase=lb.idlinhabase
	and lb.idarearegistro=ar.idarearegistro
	and lt.idlinhatelefonica=lc.idlinhatelefonica
	and lc.idconta = c.idconta 
	and c.idconta = :idConta ;
   */
   
   /* Cursor do LOOP Principal */
   EXEC SQL DECLARE csrIdLinhaTel CURSOR FOR
   select 
      lc.idlinhatelefonica
   from 
      customer.linhaconta lc, 
      customer.conta c 
   where 
      lc.idconta = c.idconta 
   and c.idconta = :idConta ;
   
   /* Cursor de Sub LOOP, secundario */
   EXEC SQL DECLARE csrSenhaConta CURSOR FOR
    select 
        ar.cdarearegistro, 
        lb.nrlinha, 
        lt.idLinhaSistemaOrigem, 
        lt.idlinhatelefonica
    from 
        linha.linhatelefonica lt ,
        linha.linhabase lb,
        apoio.arearegistro ar
    where
       lt.IDLINHATELEFONICA = :idLinhaTel_Busca 
    and lt.idlinhabase=lb.idlinhabase
    and lb.idarearegistro=ar.idarearegistro ;
    
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    
   EXEC SQL OPEN csrIdLinhaTel;
   
   for( ;; ) 
   {
      EXEC SQL FETCH csrIdLinhaTel INTO :idLinhaTel_Busca:i_idLinhaTel_Busca ;

      if ( i_idLinhaTel_Busca == -1 )
      {
         continue;
      }

      EXEC SQL WHENEVER NOT FOUND CONTINUE;
      
    EXEC SQL OPEN csrSenhaConta;
    for( ;; )  
    {
        EXEC SQL FETCH csrSenhaConta INTO
            :cdarearegistro:i_cdarearegistro ,
            :nrlinha:i_nrlinha ,
            :idLinhaSistemaOrigem:i_idLinhaSistemaOrigem ,
            :idlinhatelefonica:i_idlinhatelefonica ;

         if (sqlca.sqlcode == 1403)
         {
            break;
         }
         
        xml_g->createTag( "TelefoneContaVO" );
            xml_g->addItem( "cdAreaRegistro",  trim(cdarearegistro) );
            xml_g->addItem( "nrLinha", trim(nrlinha) );
            xml_g->addItem( "idLinhaSistemaOrigem",  trim(idLinhaSistemaOrigem) );
            xml_g->addItem( "idLinhaTelefonica", trim(idlinhatelefonica) );
        xml_g->closeTag();
    }
    EXEC SQL CLOSE csrSenhaConta;

      EXEC SQL WHENEVER NOT FOUND DO BREAK;

   }
   EXEC SQL CLOSE csrIdLinhaTel;
   
    ULOG_END( "getTelefonePorConta()" );

    return;
 
    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode); 
}



/*
void getServicoAreaRegistro( char * ServicoPrm, XMLGen * xml_g )
{
    ULOG_START( "getServicoAreaRegistro()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

       char Servico[256];

       char dsServicoAtlys[256];
       char inAtivo[3];
       char cdAreaRegistro[5];
       
       short i_dsServicoAtlys  = -1;
       short i_inAtivo         = -1;
       short i_cdAreaRegistro  = -1;
       
    EXEC SQL END DECLARE SECTION;	
    
    memset( dsServicoAtlys , 0x0, sizeof(dsServicoAtlys) );
    memset( inAtivo        , 0x0, sizeof(inAtivo) );
    memset( cdAreaRegistro , 0x0, sizeof(cdAreaRegistro) );
    
    strcpy( Servico, ServicoPrm );
    ULOG( "Servico [%s]", Servico );

    EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    
    EXEC SQL DECLARE csrServicoAreaRegistro CURSOR FOR
    select 
       nvl (dsservicoatlys, ' ') as dsservicoatlys,  
       nvl (inativo, 0) as inativo, 
       b.cdarearegistro
    from 
       apoio.servicoatlys a, 
       apoio.arearegistro b
    where 
       a.idarearegistro = b.idarearegistro 
    and dsservicofo = :Servico ;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL OPEN csrServicoAreaRegistro;
    for( ;; ) 
    {
        EXEC SQL FETCH csrServicoAreaRegistro INTO
                :dsServicoAtlys:i_dsServicoAtlys ,
                :inAtivo:i_inAtivo ,
                :cdAreaRegistro:i_cdAreaRegistro ;

        xml_g->createTag( "ServicoVO" );
            xml_g->addItem( "dsServicoAtlys",  trim(dsServicoAtlys) );
            xml_g->addItem( "inAtivo", trim(inAtivo) );
            xml_g->addItem( "cdAreaRegistro",  trim(cdAreaRegistro) );
        xml_g->closeTag();
    }

    EXEC SQL CLOSE csrServicoAreaRegistro;

    ULOG_END( "getServicoAreaRegistro()" );

    return;
 
    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode); 
}
*/



/*
void getServicoByAreaRegistro( char * servicoPrm, 
			                   char * cdAreaRegistroPrm, 
                               XMLGen * xml_g )
{
    ULOG_START( "getServicoByAreaRegistro()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

       char Servico[256];
       char AreaRegistro[5];
       
       char dsServicoAtlys[256];
       char inAtivo[3];
       char cdAreaRegistro[5];
       
       short i_dsServicoAtlys  = -1;
       short i_inAtivo         = -1;
       short i_cdAreaRegistro  = -1;
       
    EXEC SQL END DECLARE SECTION;	
    
    memset( dsServicoAtlys , 0x0, sizeof(dsServicoAtlys) );
    memset( inAtivo        , 0x0, sizeof(inAtivo) );
    memset( cdAreaRegistro , 0x0, sizeof(cdAreaRegistro) );
    
    strcpy( Servico, ServicoPrm );
    strcpy( AreaRegistro, cdAreaRegistroPrm );

    ULOG( "Servico      [%s]", Servico );
    ULOG( "AreaRegistro [%s]", AreaRegistro );

    EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    
    EXEC SQL DECLARE csrBuscaServico CURSOR FOR
    select 
       nvl (dsservicoatlys, ' ') as dsservicoatlys, 
       nvl (inativo, 0) as inativo, 
       b.cdarearegistro
    from 
       apoio.servicoatlys a, apoio.arearegistro b
    where 
       a.idarearegistro = b.idarearegistro 
    and dsservicofo = :Servico
    and b.cdarearegistro = :AreaRegistro ;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL OPEN csrBuscaServico;
    for( ;; ) 
    {
        EXEC SQL FETCH csrBuscaServico INTO
                :dsServicoAtlys:i_dsServicoAtlys ,
                :inAtivo:i_inAtivo ,
                :cdAreaRegistro:i_cdAreaRegistro ;

        xml_g->createTag( "ServicoVO" );
            xml_g->addItem( "dsServicoAtlys",  trim(dsServicoAtlys) );
            xml_g->addItem( "inAtivo", trim(inAtivo) );
            xml_g->addItem( "cdAreaRegistro",  trim(cdAreaRegistro) );
        xml_g->closeTag();
    }

    EXEC SQL CLOSE csrBuscaServico;

    ULOG_END( "getServicoByAreaRegistro()" );

    return;
 
    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode); 
}
*/



/*
void getServicoLinhaByConta( char * idContaPrm, 
                             char * dsServicoPrm, 
                             XMLGen * xml_g )
{
    ULOG_START( "getServicoLinhaByConta()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

       char idConta[43];
       char dsServico[256];
       
       char cdAreaRegistro[5];
       char nrLinha[16];
       char idServico[43];
       char sgServico[256];
       char nmServico[256];
       char idServicoSistemaorigem[43];
       char cdtiposervicosistemaorig[256];
       char dtVigenciaInicio[16];
       char dtVigenciaFinal[16];
       char dtExpiracao[16];
       char inPlano[3];
       char idLinhaTelefonica[43];
       char idLinhaSistemaOrigem[43];
       char idServLinhaSistOrigem[43];

       short i_cdAreaRegistro = -1;
       short i_nrLinha = -1;
       short i_idServico = -1;
       short i_sgServico = -1;
       short i_nmServico = -1;
       short i_idServicoSistemaorigem = -1;
       short i_cdtiposervicosistemaorig = -1;
       short i_dtVigenciaInicio = -1;
       short i_dtVigenciaFinal = -1;
       short i_dtExpiracao = -1;
       short i_inPlano = -1;
       short i_idLinhaTelefonica = -1;
       short i_idLinhaSistemaOrigem = -1;
       short i_idServLinhaSistOrigem = -1;

    EXEC SQL END DECLARE SECTION;	
    
    memset( dsServicoAtlys , 0x0, sizeof(dsServicoAtlys) );
    memset( inAtivo        , 0x0, sizeof(inAtivo) );
    memset( cdAreaRegistro , 0x0, sizeof(cdAreaRegistro) );
    
    strcpy( idConta  , idContaPrm );
    strcpy( dsServico, dsServicoPrm );

    ULOG( "idConta   [%s]", idConta );
    ULOG( "dsServico [%s]", dsServico );

    EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    
    EXEC SQL DECLARE csrBuscaServico CURSOR FOR
    select  
       c.cdarearegistro, 
       b.nrlinha, 
       e.idservico, 
       e.sgservico, 
       e.nmservico,
       e.idservicosistemaorigem,
       e.cdtiposervicosistemaorig,
       NVL(TO_CHAR(d.dtvigenciainicio, 'dd/mm/yyyy'), ' ') as dtvigenciainicio ,
       NVL(TO_CHAR(d.dtvigenciafinal, 'dd/mm/yyyy'), ' ') as dtvigenciafinal,
       d.dtexpiracao, d.inplano,a.idlinhatelefonica,a.idlinhasistemaorigem,
       d.idservlinhasistorigem
    from 
       customer.linhaconta linhaconta,
       linha.linhatelefonica a,
       linha.linhabase b,
       apoio.arearegistro c,
       linha.planoservicolinha d,
       linha.planoservico e
    where 
       linhaconta.idlinhatelefonica = a.idlinhatelefonica
    and linhaconta.idconta = ?
    and a.idlinhabase = b.idlinhabase
    and b.idarearegistro = c.idarearegistro
    and a.idlinhatelefonica = d.idlinhatelefonica
    and d.idservico = e.idservico
    and a.dtexpiracao is null
    and d.dtexpiracao is null
    and nvl (d.inplano, 0) = 0
    and nvl (d.dtvigenciafinal, sysdate + 1) > sysdate
    and exists (select 1 from APOIO.SERVICOATLYS sa
                   where sa.DSSERVICOFO = ?
                   and sa.DSSERVICOATLYS = e.SGSERVICO
    		          and sa.idarearegistro = b.idarearegistro);

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL OPEN csrBuscaServico;
    for( ;; ) 
    {
        EXEC SQL FETCH csrBuscaServico INTO
                :cdAreaRegistro:i_cdAreaRegistro ,
                :nrLinha:i_nrLinha ,
                :idServico:i_idServico ,
                :sgServico:i_sgServico ,
                :nmServico:i_nmServico ,
                :idServicoSistemaorigem:i_idServicoSistemaorigem ,
                :cdtiposervicosistemaorig:i_cdtiposervicosistemaorig ,
                :dtVigenciaInicio:i_dtVigenciaInicio ,
                :dtVigenciaFinal:i_dtVigenciaFinal ,
                :dtExpiracao:i_dtExpiracao ,
                :inPlano:i_inPlano ,
                :idLinhaTelefonica:i_idLinhaTelefonica ,
                :idLinhaSistemaOrigem:i_idLinhaSistemaOrigem ,
                :idServLinhaSistOrigem:i_idServLinhaSistOrigem ;

        xml_g->createTag( "ServicoVO" );
            xml_g->addItem( "cdAreaRegistro",  trim(cdAreaRegistro) );
            xml_g->addItem( "nrLinha", trim(nrLinha) );
            xml_g->addItem( "idServico",  trim(idServico) );
            xml_g->addItem( "sgServico",  trim(sgServico) );
            xml_g->addItem( "nmServico", trim(nmServico) );
            xml_g->addItem( "idServicoSistemaorigem",  trim(idServicoSistemaorigem) );
            xml_g->addItem( "cdtiposervicoSistema",  trim(dsServicoAtlys) );
            xml_g->addItem( "inAtivo", trim(inAtivo) );
            xml_g->addItem( "cdAreaRegistro",  trim(cdAreaRegistro) );
            xml_g->addItem( "dsServicoAtlys",  trim(dsServicoAtlys) );
            xml_g->addItem( "inAtivo", trim(inAtivo) );
            xml_g->addItem( "cdAreaRegistro",  trim(cdAreaRegistro) );
            xml_g->addItem( "dsServicoAtlys",  trim(dsServicoAtlys) );
            xml_g->addItem( "inAtivo", trim(inAtivo) );
            xml_g->addItem( "cdAreaRegistro",  trim(cdAreaRegistro) );
            xml_g->addItem( "dsServicoAtlys",  trim(dsServicoAtlys) );
            xml_g->addItem( "inAtivo", trim(inAtivo) );
            xml_g->addItem( "cdAreaRegistro",  trim(cdAreaRegistro) );
            xml_g->addItem( "dsServicoAtlys",  trim(dsServicoAtlys) );
            xml_g->addItem( "inAtivo", trim(inAtivo) );
            xml_g->addItem( "cdAreaRegistro",  trim(cdAreaRegistro) );
            xml_g->addItem( "dsServicoAtlys",  trim(dsServicoAtlys) );
            xml_g->addItem( "inAtivo", trim(inAtivo) );
            xml_g->addItem( "cdAreaRegistro",  trim(cdAreaRegistro) );
        xml_g->closeTag();
    }

    EXEC SQL CLOSE csrBuscaServico;

    ULOG_END( "getServicoLinhaByConta()" );

    return;
 
    sqlErrorConstrutor:
        throw TuxBasicOraException(sqlca.sqlcode); 
}
*/