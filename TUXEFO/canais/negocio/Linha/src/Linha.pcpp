#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw.h>
#include "../../negocio/Linha/include/Linha/Linha.hpp"
#include "../../negocio/UtilCanais/include/UtilCanais/UtilCanais.hpp"

  
EXEC SQL INCLUDE SQLCA;


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLinha::CLinha()
{
}

CLinha::~CLinha() 
{	
}

//---------------------------------------------------------------------------
int CLinha::getCdAreaRegistro() 
{
	return this->m_iCdAreaRegistro;
}

//---------------------------------------------------------------------------
int CLinha::getNrLinha() 
{
	return this->m_iNrLinha;
}

//---------------------------------------------------------------------------
void CLinha::setCdAreaRegistro(int value) 
{
	this->m_iCdAreaRegistro = value;
}

//---------------------------------------------------------------------------
void CLinha::setNrLinha(int value) 
{
	this->m_iNrLinha = value;
}


bool CLinha::consultarLinha()
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int  iCdAreaRegistro = 0;
	int  iNrLinha = 0; 		
	int  iLinhaExistente = 0;
	EXEC SQL END DECLARE SECTION;
	
	iCdAreaRegistro = this->getCdAreaRegistro();
	iNrLinha = this->getNrLinha();
	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL
	SELECT 
		COUNT(1)
	INTO
		:iLinhaExistente
	FROM
		LINHA.LINHABASE LINHABASE,
		APOIO.AREAREGISTRO AREAREGISTRO		
	WHERE
		LINHABASE.NRLINHA = :iNrLinha AND
		LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO AND
		AREAREGISTRO.CDAREAREGISTRO = :iCdAreaRegistro;

	if (iLinhaExistente)
		return true;

	else
		return false;
	
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
	

}

void CLinha::insereLstRestrita()
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int  iCdAreaRegistro = 0;
 	int  iNrLinha = 0; 	
	int  iIdLinhaBase = 0;
	int iNrRestrito = 0;
 	EXEC SQL END DECLARE SECTION;
	
	iCdAreaRegistro = this->getCdAreaRegistro();
	iNrLinha	= this->getNrLinha();
	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
	
	EXEC SQL
	SELECT 
		IDLINHABASE
	INTO
		:iIdLinhaBase
	FROM
		LINHA.LINHABASE LINHABASE,
		APOIO.AREAREGISTRO AREAREGISTRO		
	WHERE
		LINHABASE.NRLINHA = :iNrLinha AND
		LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO AND
		AREAREGISTRO.CDAREAREGISTRO = :iCdAreaRegistro;

	if (iIdLinhaBase)
	{
		EXEC SQL
		INSERT INTO
		VOL.LISTARESTRITA(IDLINHABASE, DTULTIMAALTERACAO, IDUSUARIOALTERACAO)
		VALUES(:iIdLinhaBase, SYSDATE, 	1);

	}	

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);

}


bool CLinha::consultarLinhaListaRestrita()
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int  iCdAreaRegistro = 0;
 	int  iNrLinha = 0; 		
	int iNrRestrito = 0;
 	EXEC SQL END DECLARE SECTION;
	
	iCdAreaRegistro = this->getCdAreaRegistro();
	iNrLinha = this->getNrLinha();
	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL
	SELECT 
		COUNT(1)
	INTO
		:iNrRestrito
	FROM
		LINHA.LINHABASE LINHABASE,
		APOIO.AREAREGISTRO AREAREGISTRO,
		VOL.LISTARESTRITA LISTARESTRITA
	WHERE
		LINHABASE.NRLINHA = :iNrLinha AND
		LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO AND
		AREAREGISTRO.CDAREAREGISTRO = :iCdAreaRegistro AND
		LINHABASE.IDLINHABASE = LISTARESTRITA.IDLINHABASE;


	if (iNrRestrito)
		return true;

	else
		return false;

	
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);

}

void CLinha::removeLstRestrita()
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int  iCdAreaRegistro;
 	int  iNrLinha; 	
 	EXEC SQL END DECLARE SECTION;
	
	iCdAreaRegistro = this->getCdAreaRegistro();
	iNrLinha	= this->getNrLinha();
	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL
	DELETE
	FROM
		VOL.LISTARESTRITA
	WHERE
		IDLINHABASE = (SELECT IDLINHABASE FROM LINHA.LINHABASE LB, APOIO.AREAREGISTRO AR WHERE NRLINHA = :iNrLinha AND  AR.IDAREAREGISTRO = LB.IDAREAREGISTRO AND AR.CDAREAREGISTRO = :iCdAreaRegistro);

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);

}




bool CLinha::EnviaSMS(bool bBloqueia, char *cUser)
{
	ULOG_START("CLinha::EnviaSMS()");
	XMLGen oEntrada;
	TuxRemoteService* remoteService;
	TuxMessage* inputMessage;
	char  c_statusCode[10]  = "";
	char  c_statusText[256] = "";
	char cMensagem[80] = "";	
	char cNrLinha[15] ="";

	// criar o XML para enviar SMS

	if (bBloqueia == true)
		strcpy (cMensagem, "Bloqueio de acesso aos canais eletrônicos realizado com sucesso.");
	else
		strcpy (cMensagem, "Desbloqueio de acesso aos canais eletrônicos realizado com sucesso.");
	

	oEntrada.addItem("message", cMensagem);


	int iCdAreaRegistro = this->getCdAreaRegistro();
 	int iNrLinha = this->getNrLinha();

	sprintf(cNrLinha, "%d%d", iCdAreaRegistro, iNrLinha);
	
	oEntrada.addItem("recipient", cNrLinha);

	remoteService = new TuxRemoteService();
	inputMessage = new TuxMessage();
	inputMessage->setUser(cUser);
	inputMessage->setMessageBody(&oEntrada);
	inputMessage->setService("SMSSend");
	// Repassa configuracoes ao manipulador do serviço remoto e invoca o servico.

	remoteService->setServiceName("SMSSend");
	remoteService->setInputMessage(inputMessage);
	
	if(remoteService->remoteCall() != TUXFWRET_OK)		
	{
		delete remoteService;
		delete inputMessage;
		throw new TuxBasicSvcException("00E0010","Erro no serviço SMSSend");
	}

	
	char *pc_statusCode = remoteService->getOutputMessage()->getStatusCode();
	char *pc_statusText = remoteService->getOutputMessage()->getStatusText();

	if(pc_statusCode)
		strcpy(c_statusCode, pc_statusCode);

	if(pc_statusText)
	{
		if(strlen(pc_statusText) >= sizeof(c_statusText))
			strncpy(c_statusText, pc_statusText, sizeof(c_statusText) - 1);
		else
			strcpy(c_statusText, pc_statusText);
	}

	if (strlen(c_statusCode) >= 3 && c_statusCode[2] !='I')
	{
	
		free(pc_statusCode);
		free(pc_statusText);

		throw new TuxBasicSvcException("00E0010","Erro no serviço SMSSend");
	}
		
   
	return true;
}




