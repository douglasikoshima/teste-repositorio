// Lojista.pcpp: implementation of the CLojista class.
//
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
//#include <tuxfw/tuxfw.h>
#include <Lojista/Lojista.hpp>
#include <ctype.h>
 
EXEC SQL INCLUDE SQLCA;


CLojista::CLojista()
{
	this->setIdTerminal(-1);
	this->setCdLojaOperadoraCartao("");
	this->setNrTerminal("");
	this->setNrIpTerminal("");
	this->setIdUFOperadora(-1);
	this->setInSitefAtivoRecarga(0);
	this->setInSitefAtivoPagamento(0);
}

CLojista::~CLojista()
{
	
}


// Operação de Negocio (Interface)
void CLojista::consultarDados()
{

	this->consultarDadosDB();
}

	
// Getters
int CLojista::getIdTerminal() const
{
	return this->m_iIdTerminal;
}

int CLojista::getIdUFOperadora() const
{
	return m_iIdUFOperadora;
}



char *CLojista::getCdLojaOperadoraCartao(char *cCdLojaOperadoraCartao) const
{
	strcpy(cCdLojaOperadoraCartao, this->m_cCdLojaOperadoraCartao);
	return cCdLojaOperadoraCartao;
}

char *CLojista::getNrTerminal(char *cNrTerminal) const
{
	strcpy(cNrTerminal, this->m_cNrTerminal);
	return cNrTerminal;
}

char *CLojista::getNrIpTerminal(char *cNrIpTerminal) const
{
	strcpy(cNrIpTerminal, this->m_cNrIpTerminal);
	return cNrIpTerminal;
}

int CLojista:: getInLiberadoRecarga ()
{
	return m_iLiberadoRecarga;

}

int CLojista:: getInLiberadoPagamento ()
{
	return m_iLiberadoPagamento;

}

int CLojista:: getIdPessoa() 
{
	return m_iIdPessoa;

}


long CLojista:: getIdPessoaDePara() 
{
		
	return this->m_iIdPessoaDePara;

}


char *CLojista::getNmPessoa() 
{
	return this->m_cNmPessoa;
}




// Setters
void CLojista::setIdTerminal(int value)
{
	this->m_iIdTerminal = value;
}

void CLojista::setIdUFOperadora(int value)
{
	m_iIdUFOperadora = value;
}

void CLojista::setCdLojaOperadoraCartao(char *value)
{
	strcpy(m_cCdLojaOperadoraCartao, value);
}

void CLojista::setNrTerminal(char *value)
{
	strcpy(m_cNrTerminal, value);
}

void CLojista::setNrIpTerminal(char *value)
{
	strcpy(m_cNrIpTerminal, value);
}

void CLojista::setSgUF(char *value)
{
	strcpy(m_cSgUF, value);
}

void CLojista::setDsCor(char *value)
{
	strcpy(m_dsCor, value);
}


void CLojista:: setInSitefAtivoRecarga(int value)
{
	m_inSitefAtivoRecarga = value;

}

void CLojista:: setInSitefAtivoPagamento(int value)
{
	m_inSitefAtivoPagamento = value;

}

void CLojista::setIdUF(int value)
{
	m_iIdUF = value;
}



void CLojista::setNmMunicipio(char *value)
{

	strcpy(m_cNmMunicipio, value);

}


void CLojista::setNmLoja (char *value)
{

	strcpy (m_cNmLoja, value);

}

void CLojista:: setNmTerminal (char *value)
{
	strcpy(m_cNmTerminal, value);

}


void CLojista:: setCdSitefSenha (char *value)
{
	
	strcpy(m_cCdSitefSenha, value);

}

void CLojista:: setInLiberadoRecarga (int value)
{
	m_iLiberadoRecarga = value;

}

void CLojista:: setInLiberadoPagamento (int value)
{
	m_iLiberadoPagamento = value;

}

void CLojista::setIdPessoa(int value)
{

	m_iIdPessoa = value;

}


void CLojista::setIdPessoaDePara(long value)
{

	this->m_iIdPessoaDePara = value;

}


void CLojista::setNmPessoa(char *value) 
{
	strcpy( this->m_cNmPessoa, value );
}


char* CLojista::rtrim(char *pStr)
{
	int rInd;

	if (pStr == NULL)
			return NULL;

   rInd = strlen(pStr) - 1;
   while ( isspace(pStr[rInd]) && rInd >= 0){
      rInd--;
   }

   pStr[rInd + 1] = '\0';
   
   return pStr;
}

char* CLojista::ltrim(char *pStr)
{
	int lInd = 0;

	if (pStr == NULL)
			return NULL;

    //rInd = strlen(pStr) - 1;

    while (isspace(pStr[lInd])){
        lInd++;
	}

	pStr = pStr + lInd;
     
   return pStr;
}

char* CLojista::trim(char *pStr){
	return ltrim(rtrim(pStr));		
}



// Métodos de acesso a banco de dados
void CLojista::consultarDadosDB()
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;
	int  iIdTerminal;
	int  iIdUFOperadora;
	int  iIdPessoaDePara;
	char cCdLojaOperadoraCartao[21];
	char cNrTerminal[9];
	char cNrIpTerminal[16];
	char cCdSiteFSenha[11];
	char cSgUF[3];
	char dsCor[255+1];
	int	 inSitefAtivoRecarga;
	int	 inSitefAtivoPagamento;
	EXEC SQL END DECLARE SECTION;

	iIdTerminal = this->getIdTerminal();

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL
	
		SELECT
			NVL(a.nrTerminal, ' ') as nrTerminal,
			NVL(a.idPessoaDePara, 0) as idPessoaDePara,
			NVL(a.idUFOperadora, 0) as idUFOperadora,
			NVL(a.cdLojaOperadoraCartao, ' ') as cdLojaOperadoraCartao,
			NVL(a.nrTerminal, ' ') as nrTerminal,			
			NVL(a.nrIpTerminal, ' ') as nrIpTerminal,
			NVL(a.cdSiteFSenha, ' ') as cdSiteFSenha,
			NVL(c.sgUF, ' ') as sgUF,
			NVL(cor.nmCor,' ') as dsCor,
			INLIBERADORECARGA as inLiberadoRecarga,
			INLIBERADOPAGAMENTO as inLiberadoPagamento
		INTO
			:cNrTerminal,
			:iIdPessoaDePara,
			:iIdUFOperadora,
			:cCdLojaOperadoraCartao,
			:cNrTerminal,
			:cNrIpTerminal,
			:cCdSiteFSenha,
			:cSgUF,
			:dsCor,
			:inSitefAtivoRecarga,
			:inSitefAtivoPagamento
		FROM			
			vol.SiteFTerminal  a,
			customer.UFOperadora  b,
			apoio.UF c,
			apoio.cor cor
		WHERE
			a.idUFOperadora		= b.idUFOperadora
		And	b.idUF				= c.idUF
		And	a.idTerminal = :iIdTerminal
		And     a.idCor = cor.idCor;	
	
	if(sqlca.sqlcode)
	{
		tuxfw_getlogger()->debug("CLojista::consultarDadosDB()1 sqlca.sqlcode = %d",sqlca.sqlcode);
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	this->setNrTerminal(trim(cNrTerminal));
	this->setIdPessoaDePara(iIdPessoaDePara);
	this->setIdUFOperadora(iIdUFOperadora);
	this->setCdLojaOperadoraCartao(trim(cCdLojaOperadoraCartao));
	this->setNrIpTerminal(trim(cNrIpTerminal));
	this->setCdSitefSenha(trim(cCdSiteFSenha));
	this->setSgUF(trim(cSgUF));
	this->setDsCor(trim(dsCor));
	this->setInSitefAtivoRecarga(inSitefAtivoRecarga);
	this->setInSitefAtivoPagamento(inSitefAtivoPagamento);

	return;

	sqlErrorConstrutor:
		tuxfw_getlogger()->debug("CLojista::consultarDadosDB()2 sqlca.sqlcode = %d",sqlca.sqlcode);
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CLojista::consultarTerminaisDB(list<CLojista> &listaLojista, int iIdPessoaDePara)
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	
	int   iIdPessoaDeParaSQL = 0;
	char  cNrTerminal[15]="";
	char  cNrIpTerminal[15]="";	
	int   iIdTerminal = 0;
	EXEC SQL END DECLARE SECTION;	

	CLojista	oLojista;

	iIdPessoaDeParaSQL = iIdPessoaDePara < 0 ? 0 : iIdPessoaDePara;

	
	// garante que a lista esta vazia
	listaLojista.clear();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
	EXEC SQL DECLARE LSTTERMINAIS CURSOR FOR
		
		SELECT
			  nrTerminal,
			  nrIpTerminal,
			  idTerminal			  
		FROM
			  vol.SitefTerminal				 
		WHERE
			  idPessoaDePara	 = :iIdPessoaDeParaSQL;
		
	// Marca ponto de controle de erro


	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	EXEC SQL OPEN LSTTERMINAIS;

	for( ;; ) 
	{
		// varre todos os registros para criar a lista com os servicos

		EXEC SQL FETCH LSTTERMINAIS INTO
			:cNrTerminal,
			:cNrIpTerminal,
			:iIdTerminal;		


		

		oLojista.setNrTerminal(trim(cNrTerminal));
		oLojista.setNrIpTerminal(trim(cNrIpTerminal));
		oLojista.setIdTerminal(iIdTerminal);
		

		listaLojista.push_back(oLojista);
	}

	EXEC SQL CLOSE LSTTERMINAIS;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 
	
}


void CLojista::consultarTerminaisLoja(XMLGen* xml_g, int iIdPessoaDePara)
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	
	int   iIdPessoaDeParaSQL = 0;
	char  cNrTerminal[15]="";
	char  cNrIpTerminal[15]="";	
	int   iIdTerminal = 0;
	EXEC SQL END DECLARE SECTION;	

	
	iIdPessoaDeParaSQL = iIdPessoaDePara < 0 ? 0 : iIdPessoaDePara;

	// garante que a lista esta vazia


	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
	EXEC SQL DECLARE LSTTERMINAISLOJA CURSOR FOR
		
		SELECT
			  nrTerminal,
			  nrIpTerminal,
			  idTerminal			  
		FROM
			  vol.SitefTerminal				 
		WHERE
			  idPessoaDePara	 = :iIdPessoaDeParaSQL;
		
	// Marca ponto de controle de erro


	xml_g->createTag("ListaTerminaisVO");

	xml_g->addProp("xmlns", "voltav.fo.vivo.com.br/vo");


	EXEC SQL WHENEVER NOT FOUND DO BREAK;	
	
	EXEC SQL OPEN LSTTERMINAISLOJA;

	for( ;; ) 
	{
		// varre todos os registros para criar a lista com os servicos

		EXEC SQL FETCH LSTTERMINAISLOJA INTO
			:cNrTerminal,
			:cNrIpTerminal,
			:iIdTerminal;		

		xml_g->createTag( "TerminalVO" );

		
			xml_g->addItem( "nrTerminal",  trim(cNrTerminal));

			xml_g->addItem( "idTerminal",  iIdTerminal);		

			xml_g->addItem( "nrIpTerminal", trim(cNrIpTerminal));

		xml_g->closeTag();


	}

	xml_g->closeTag();


	EXEC SQL CLOSE LSTTERMINAISLOJA;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 
	
}



void  CLojista::consultarListaUF( XMLGen* xml_g )
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	

	char cSgUF[256]="";
	int  iIdUF = 0;
	char cNmUF[256] = "";

	EXEC SQL END DECLARE SECTION;	


	// marca ponto de controle de erro
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;


	EXEC SQL DECLARE LSTUFNMAREAREGISTRO CURSOR FOR
	SELECT 
		IDUF, 
		SGUF, 
		NMUF
	FROM
		APOIO.UF
	WHERE
		IDUF BETWEEN 1 AND 30
	ORDER BY IDUF;
		
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	
	EXEC SQL OPEN LSTUFNMAREAREGISTRO;

	xml_g->createTag("ListaUFVO");

	xml_g->addProp("xmlns", "cliente.fo.vivo.com.br/vo");

	for( ;; ) 
	{
		// varre todos os registros para criar a lista com os servicos

		EXEC SQL FETCH LSTUFNMAREAREGISTRO INTO
			:iIdUF,
			:cSgUF,
			:cNmUF;	

	
		xml_g->createTag("UFVO");
			
			xml_g->addItem( "idUF", iIdUF);				
			xml_g->addItem( "sgUF", trim(cSgUF));
			xml_g->addItem( "nmUF", trim(cNmUF));			

		xml_g->closeTag();

	}


	xml_g->closeTag();



	EXEC SQL CLOSE LSTUFNMAREAREGISTRO;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 

}


void  CLojista::consultarListaMunicipio(XMLGen* xml_g, int iIdUF)
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	

	char cNmMunicipio[256] = "";
	int  iIdUFSQL = 0;
	
	EXEC SQL END DECLARE SECTION;	


	iIdUFSQL	= iIdUF;



	// marca ponto de controle de erro
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
	EXEC SQL WHENEVER NOT FOUND GOTO sqlErrorConstrutor;

	EXEC SQL DECLARE LSTMUNICIPIO CURSOR FOR

	SELECT 
		DISTINCT NMMUNICIPIO
	FROM
		CUSTOMER.PESSOAENDERECO PESSOAENDERECO,
		CUSTOMER.PESSOADEPARA	PESSOADEPARA,
		VOL.SITEFTERMINAL		SITEFTERMINAL,
		CUSTOMER.UFOPERADORA	UFOPERADORA
	WHERE
		SITEFTERMINAL.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA AND
		PESSOADEPARA.IDPESSOA = PESSOAENDERECO.IDPESSOA AND
		SITEFTERMINAL.IDUFOPERADORA = UFOPERADORA.IDUFOPERADORA AND 
		UFOPERADORA.IDUF = :iIdUFSQL AND
		NMMUNICIPIO IS NOT NULL		
	ORDER BY 
		NMMUNICIPIO;
		
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	EXEC SQL OPEN LSTMUNICIPIO;

	xml_g->createTag("ListaMunicipioVO");

	xml_g->addProp("xmlns", "cliente.fo.vivo.com.br/vo");

	for( ;; ) 
	{
		// varre todos os registros para criar a lista com os servicos

		EXEC SQL FETCH LSTMUNICIPIO INTO			
			:cNmMunicipio;		

		xml_g->createTag( "MunicipioVO" );

		xml_g->addProp("xmlns", "admsistemas.fo.vivo.com.br/vo");


		xml_g->addItem( "nmMunicipio", trim(cNmMunicipio));

		xml_g->closeTag();
	}

	EXEC SQL CLOSE LSTMUNICIPIO;


	xml_g->closeTag();


	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 
}



void  CLojista::consultarListaLojas(XMLGen* xml_g, int iIdUF, char *cNmMunicipio)
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	

	char  cNmMunicipioSQL[256] = "";
	int   iIdUFSQL = 0;
	char  cNmLoja[256] = "";
	int	  iIdPessoaDePara = 0;

	
	EXEC SQL END DECLARE SECTION;	


	iIdUFSQL	= iIdUF;

	strcpy (cNmMunicipioSQL, cNmMunicipio);


	// marca ponto de controle de erro
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
	EXEC SQL WHENEVER NOT FOUND GOTO sqlErrorConstrutor;

	EXEC SQL DECLARE LSTLOJASMUNICIP CURSOR FOR

	SELECT 
		DISTINCT PESSOA.NMPESSOA, PESSOADEPARA.IDPESSOADEPARA
	FROM
		CUSTOMER.PESSOAENDERECO PESSOAENDERECO,
		CUSTOMER.PESSOADEPARA   PESSOADEPARA,
		VOL.SITEFTERMINAL		SITEFTERMINAL,
		CUSTOMER.UFOPERADORA	UFOPERADORA,
		CUSTOMER.PESSOA			PESSOA
	WHERE
		SITEFTERMINAL.IDPESSOADEPARA	= PESSOADEPARA.IDPESSOADEPARA AND
		PESSOADEPARA.IDPESSOA			= PESSOAENDERECO.IDPESSOA AND
		SITEFTERMINAL.IDUFOPERADORA		= UFOPERADORA.IDUFOPERADORA AND
		PESSOADEPARA.IDPESSOA			= PESSOA.IDPESSOA AND 
		UFOPERADORA.IDUF				= :iIdUFSQL AND 
		PESSOAENDERECO.NMMUNICIPIO		= :cNmMunicipioSQL
	ORDER BY 
		PESSOA.NMPESSOA;
		
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	EXEC SQL OPEN LSTLOJASMUNICIP;

	xml_g->createTag("ListaLojaVO");

	xml_g->addProp("xmlns", "cliente.fo.vivo.com.br/vo");

	for( ;; ) 
	{
		// varre todos os registros para criar a lista com os servicos

		EXEC SQL FETCH LSTLOJASMUNICIP INTO			
			:cNmLoja,
			:iIdPessoaDePara;		

		xml_g->createTag( "LojaVO" );


			xml_g->addItem( "nmLoja", trim(cNmLoja));

			xml_g->addItem( "idPessoaDePara", iIdPessoaDePara);

		xml_g->closeTag();
		
	}



	xml_g->closeTag();


	EXEC SQL CLOSE LSTLOJASMUNICIP;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 
}



void  CLojista::consultarListaTerminais(XMLGen* xml_g, int iIdUF, int iIdTerminal, int iIdPessoaDePara, char *cNmMunicipio, int iInLiberadoRecarga, int iInLiberadoPagamento, int iNrPagina )
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	

	char  cNmMunicipioSQL[256] = "";
	int   iIdUFSQL = 0;
	int   iIdTerminalSQL = 0;
	int   iIdPessoaDeParaSQL = 0;
	int   iInLiberadoRecargaSQL  = 0;
	int   iInLiberadoPagamentoSQL  = 0;
	char  cNmLoja[256] = "";
	char  cSgUF[15] = "";
	char  cNrIpTerminal[20] = "";
	char  cNrTerminal[10]="";
	char  cCdSenha[10]="";
	char  cCdLojaOperadoraCartao[256]="";
	char  cNmPessoa[256]="";
	int   iTotalLinhas = 0;
	int   iTotalLinhasPaginasPesq = 0;
	int   iInicioLinhaPagina = 0;
	EXEC SQL END DECLARE SECTION;	

	iIdUFSQL	= iIdUF;


	iIdUFSQL = iIdUF < 0 ? 0 : iIdUF;
	iIdTerminalSQL = iIdTerminal < 0 ? 0 : iIdTerminal;
	iIdPessoaDeParaSQL = iIdPessoaDePara < 0 ? 0 :iIdPessoaDePara;
	iInLiberadoRecargaSQL = iInLiberadoRecarga < 0 ? 0 : iInLiberadoRecarga;
	iInLiberadoPagamentoSQL = iInLiberadoPagamento < 0 ? 0 : iInLiberadoPagamento;
	strcpy (cNmMunicipioSQL, cNmMunicipio);
	
	iTotalLinhasPaginasPesq = iNrPagina * 100;
	iInicioLinhaPagina  = iTotalLinhasPaginasPesq - 100;

	xml_g->createTag("ListaTerminaisVO");

		xml_g->addProp("xmlns", "voltav.fo.vivo.com.br/vo");


	// marca ponto de controle de erro
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO  sqlErrorConstrutor;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL
	SELECT 
		COUNT(1)
	INTO
		:iTotalLinhas
	FROM
		VOL.SITEFTERMINAL SITEFTERMINAL,
		CUSTOMER.PESSOADEPARA PESSOADEPARA,
		CUSTOMER.PESSOAENDERECO PESSOAENDERECO,
		CUSTOMER.UFOPERADORA UFOPERADORA,
		APOIO.UF 			 UF,
		CUSTOMER.PESSOA      PESSOA						
	WHERE		
		SITEFTERMINAL.IDPESSOADEPARA  =  PESSOADEPARA.IDPESSOADEPARA						AND
		PESSOADEPARA.IDPESSOA		  =  PESSOAENDERECO.IDPESSOA(+)							AND			 
		SITEFTERMINAL.IDUFOPERADORA   =  UFOPERADORA.IDUFOPERADORA						 	AND
		UFOPERADORA.IDUF			  =  UF.IDUF											AND
		PESSOADEPARA.IDPESSOA         =   PESSOA.IDPESSOA                                   AND 
		(UFOPERADORA.IDUF			  =  :iIdUFSQL			  OR  :iIdUFSQL			  = 0 )	AND
		(SITEFTERMINAL.IDTERMINAL     =  :iIdTerminalSQL      OR  :iIdTerminalSQL	  = 0 )	AND
		(SITEFTERMINAL.IDPESSOADEPARA =  :iIdPessoaDeParaSQL  OR  :iIdPessoaDeParaSQL = 0 ) AND
		(PESSOAENDERECO.NMMUNICIPIO   =  :cNmMunicipio		  OR  :cNmMunicipio   IS NULL )	AND
		(SITEFTERMINAL.INLIBERADORECARGA = :iInLiberadoRecargaSQL OR :iInLiberadoRecargaSQL = 0) AND
		(SITEFTERMINAL.INLIBERADOPAGAMENTO = :iInLiberadoPagamentoSQL OR :iInLiberadoPagamentoSQL = 0);

	
	if (iTotalLinhas == 0)
	{
		xml_g->closeTag();
		return;

	}


	EXEC SQL DECLARE LSTTERMINAISPESQUISA CURSOR FOR

	SELECT 
		IDTERMINAL,
		SGUF, 
		IDPESSOADEPARA, 
		NRIPTERMINAL, 
		INLIBERADORECARGA,
		INLIBERADOPAGAMENTO,
		NRTERMINAL, 
		CDSITEFSENHA,
		NVL(NMMUNICIPIO, '  ') AS NMMUNICIPIO,
		CDLOJAOPERADORACARTAO,
		NMPESSOA
	FROM(
		SELECT 
			IDTERMINAL,
			SGUF, 
			SITEFTERMINAL.IDPESSOADEPARA, 
			NRIPTERMINAL, 
			INLIBERADORECARGA,
			INLIBERADOPAGAMENTO,
			NRTERMINAL, 
			CDSITEFSENHA,
			NVL(NMMUNICIPIO, '  ') AS NMMUNICIPIO,
			CDLOJAOPERADORACARTAO,
			PESSOA.NMPESSOA,
			ROWNUM AS LINHA
		FROM
			VOL.SITEFTERMINAL SITEFTERMINAL,
			CUSTOMER.PESSOADEPARA PESSOADEPARA,
			CUSTOMER.PESSOAENDERECO PESSOAENDERECO,
			CUSTOMER.UFOPERADORA UFOPERADORA,
			APOIO.UF 			 UF,
			CUSTOMER.PESSOA      PESSOA						
		WHERE		
			SITEFTERMINAL.IDPESSOADEPARA  =  PESSOADEPARA.IDPESSOADEPARA						AND
			PESSOADEPARA.IDPESSOA		  =  PESSOAENDERECO.IDPESSOA(+)							AND			 
			SITEFTERMINAL.IDUFOPERADORA   =  UFOPERADORA.IDUFOPERADORA						 	AND
			UFOPERADORA.IDUF			  =  UF.IDUF											AND
			PESSOADEPARA.IDPESSOA         =  PESSOA.IDPESSOA                                    AND 
			(UFOPERADORA.IDUF			  =  :iIdUFSQL			  OR  :iIdUFSQL			  = 0 )	AND
			(SITEFTERMINAL.IDTERMINAL     =  :iIdTerminalSQL      OR  :iIdTerminalSQL	  = 0 )	AND
			(SITEFTERMINAL.IDPESSOADEPARA =  :iIdPessoaDeParaSQL  OR  :iIdPessoaDeParaSQL = 0 ) AND
			(PESSOAENDERECO.NMMUNICIPIO   =  :cNmMunicipio		  OR  :cNmMunicipio   IS NULL )	AND
			(SITEFTERMINAL.INLIBERADORECARGA = :iInLiberadoRecargaSQL OR :iInLiberadoRecargaSQL = 0) AND
			(SITEFTERMINAL.INLIBERADOPAGAMENTO = :iInLiberadoPagamentoSQL OR :iInLiberadoPagamentoSQL = 0) AND
			ROWNUM <= :iTotalLinhasPaginasPesq
	)
	WHERE
		LINHA > :iInicioLinhaPagina;
		  
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	EXEC SQL OPEN LSTTERMINAISPESQUISA;



	
	if (iTotalLinhas > iTotalLinhasPaginasPesq)
		xml_g->addItem("temProximo", "1");
	else
		xml_g->addItem("temProximo", "0");



	for( ;; ) 
	{
		// varre todos os registros para criar a lista com os servicos

		EXEC SQL FETCH LSTTERMINAISPESQUISA INTO			
			:iIdTerminalSQL,
			:cSgUF,
			:iIdPessoaDeParaSQL,
			:cNrIpTerminal,
			:iInLiberadoRecargaSQL,
			:iInLiberadoPagamentoSQL,
			:cNrTerminal,
			:cCdSenha,
			:cNmMunicipioSQL,
			:cCdLojaOperadoraCartao,
			:cNmPessoa;			


		xml_g->createTag( "TerminalVO" );
		
			xml_g->addItem( "idTerminal", iIdTerminalSQL);	

			xml_g->addItem( "sgUF", trim(cSgUF));

			xml_g->addItem( "nmMunicipio", trim(cNmMunicipioSQL));

			xml_g->addItem( "idPessoaDePara", iIdPessoaDeParaSQL);
		
			xml_g->addItem( "nrIpTerminal", trim(cNrIpTerminal));

			xml_g->addItem( "inLiberadoRecarga", iInLiberadoRecargaSQL);

			xml_g->addItem( "inLiberadoPagamento", iInLiberadoPagamentoSQL);

			xml_g->addItem( "nrTerminal", trim(cNrTerminal));

			xml_g->addItem( "cdSitefSenha", trim(cCdSenha));

			xml_g->addItem( "cdLojaOperadoraCartao", trim(cCdLojaOperadoraCartao));

			xml_g->addItem( "nmLoja", trim(cNmPessoa));

		xml_g->closeTag();

	}


	xml_g->closeTag();



	EXEC SQL CLOSE LSTTERMINAISPESQUISA;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 
}

void  CLojista::alterarEndereco(int iIdTerminal, char *cNmMunicipio, char *cNmLocalidade, char *cNmBairro, char *cNmTipoLogradouro, char *cNmTituloLogradouro, char *cNmLogradouro, char *cNrEndereco, char *cDsEnderecoComplemento, char *cNrCep, int iIdUF)
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	

	char  cNmMunicipioSQL[256] = "";
	char  cNmLocalidadeSQL[256] = "";
	char  cNmBairroSQL[256]="";
	int   iIdPessoaSQL = 0;
	char  cNmTipoLogradouroSQL[256]="";
	char  cNmLogradouroSQL[256]="";
	char  cNrEnderecoSQL[256]="";
	int   iIdUFSQL = 0;
	char cDsEnderecoComplementoSQL[256]="";
	char cNrCepSQL[256]="";
	short iIdLojaCadastrada = 0;
	int  iIdPessoaLoja = 0;
	int  iIdTerminalSQL = 0;
	long iIdPessoaEndereco = 0;
	char cNmTituloLogradouroSQL[256]="";
		
	EXEC SQL END DECLARE SECTION;	

	iIdUFSQL	= iIdUF;

	iIdTerminalSQL = iIdTerminal;
	strcpy (cNmMunicipioSQL, cNmMunicipio);

	strcpy (cNmLocalidadeSQL, cNmLocalidade);

	strcpy (cNmBairroSQL, cNmBairro);

	strcpy (cNmTipoLogradouroSQL, cNmTipoLogradouro);

	strcpy (cNmLogradouroSQL, cNmLogradouro);

	strcpy (cNrEnderecoSQL, cNrEndereco); 

	strcpy (cDsEnderecoComplementoSQL, cDsEnderecoComplemento); 

	strcpy (cNrCepSQL, cNrCep);

	strcpy (cNmTituloLogradouroSQL, cNmTituloLogradouro);

	// marca ponto de controle de erro
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO  sqlErrorConstrutor;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;

	EXEC SQL 
	SELECT 
		PESSOAENDERECO.IDPESSOA
	INTO
		:iIdPessoaLoja
	FROM
		CUSTOMER.PESSOAENDERECO	PESSOAENDERECO,
		CUSTOMER.PESSOADEPARA   PESSOADEPARA,
		VOL.SITEFTERMINAL       SITEFTERMINAL
	WHERE
		SITEFTERMINAL.IDTERMINAL	 = :iIdTerminalSQL			   AND
		SITEFTERMINAL.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA AND
		PESSOAENDERECO.IDPESSOA      = PESSOADEPARA.IDPESSOA AND
		ROWNUM = 1;
		

			
				
	if (!iIdPessoaLoja)	
	{

		EXEC SQL SELECT customer.pessoaenderecoSQ.NEXTVAL INTO :iIdPessoaEndereco FROM DUAL;

		EXEC SQL 
		SELECT 
			IDPESSOA 
		INTO 
			:iIdPessoaLoja 
		FROM 
			CUSTOMER.PESSOADEPARA PESSOADEPARA,
			VOL.SITEFTERMINAL SITEFTERMINAL
		WHERE
			PESSOADEPARA.IDPESSOADEPARA = SITEFTERMINAL.IDPESSOADEPARA AND
			SITEFTERMINAL.IDTERMINAL    = :iIdTerminalSQL AND
			ROWNUM = 1;

		EXEC SQL
		INSERT INTO
		   customer.pessoaendereco
		   (idpais, idpessoa,idpessoaendereco, idsistemaorigem,idtipoendereco, iduf,nmbairro,
		   nmlogradouro,nmtipologradouro, nmtitulologradouro, nrendereco,dsenderecocomplemento, nmmunicipio,nrcep)		
		VALUES
		 (0,
		  :iIdPessoaLoja,
		  :iIdPessoaEndereco,
		  7, 
		  2, 
		  :iIdUFSQL,
		  :cNmBairroSQL,
		  :cNmLogradouroSQL,
		  :cNmTipoLogradouroSQL,
		  :cNmTituloLogradouroSQL,
		  :cNrEnderecoSQL,
		  :cDsEnderecoComplementoSQL,
		  :cNmMunicipioSQL,
		  :cNrCepSQL
		  );

	}else if (iIdPessoaLoja > 0)
	{
		

		EXEC SQL
		UPDATE 
			CUSTOMER.PESSOAENDERECO
		SET
			IDUF					= :iIdUFSQL,
			NMBAIRRO				= :cNmBairroSQL,
			NMLOGRADOURO			= :cNmLogradouroSQL,
			NMTIPOLOGRADOURO		= :cNmTipoLogradouroSQL,
			NMTITULOLOGRADOURO		= :cNmTituloLogradouroSQL,
			NRENDERECO				= :cNrEnderecoSQL,
			DSENDERECOCOMPLEMENTO	= :cDsEnderecoComplementoSQL,
			NMMUNICIPIO				= :cNmMunicipioSQL,
			NRCEP					= :cNrCepSQL
		WHERE
			IDPESSOA				= :iIdPessoaLoja;

	}


	this->setIdPessoa(iIdPessoaLoja);
	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 
}


void  CLojista::alterarLoja(int iIdPessoa, char *cNmPessoa)
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	

	int   iIdPessoaSQL		 =  0;
	char  cNmPessoaSQL[255 ] =	"";
	
	EXEC SQL END DECLARE SECTION;	
	
	iIdPessoaSQL = iIdPessoa;
	strcpy (cNmPessoaSQL, cNmPessoa);
	
	// marca ponto de controle de erro
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO  sqlErrorConstrutor;

	
	EXEC SQL
		UPDATE 
			CUSTOMER.PESSOA
		SET
			NMPESSOA		=  TO_CHAR(:cNmPessoaSQL)
		WHERE
			IDPESSOA		 = :iIdPessoaSQL;

	

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 
}


int  CLojista::checaDadosTerminal()	 	 
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	

	long   iIdPessoaDeParaSQL = 0;
	int   iLiberadoRecargaSQL = 0;
	int   iLiberadoPagamentoSQL = 0;
	char  cNrIpTerminalSQL[20]="";
	short iIdTerminalRecargaCad = 0;
	int iIdTerminalRecarga = 0;
	int iIdTerminalSQL = 0;
	short iIdTerminalChec = 0;
	int iIdTerminalAtributos = 0;
	char cNrTerminalSQL[15] = "";

	EXEC SQL END DECLARE SECTION;	
	

	iIdPessoaDeParaSQL = this->getIdPessoaDePara();
	iLiberadoRecargaSQL  = this->getInLiberadoRecarga(); 
	iLiberadoPagamentoSQL  = this->getInLiberadoPagamento(); 
	iIdTerminalSQL = this->getIdTerminal();
	strcpy (cNrIpTerminalSQL, this->getNrIpTerminal(cNrIpTerminalSQL));
	strcpy (cNrTerminalSQL,   this->getNrTerminal(cNrTerminalSQL));
	
	
	// marca ponto de controle de erro
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO  sqlErrorConstrutor;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;



	if ( iLiberadoRecargaSQL == 1)
	{
		

		EXEC SQL
		SELECT  IDTERMINAL
		INTO
			:iIdTerminalRecarga				
		FROM
			VOL.SITEFTERMINAL
		WHERE
			INLIBERADORECARGA	=	1	   				AND
			IDPESSOADEPARA				=  :iIdPessoaDeParaSQL	AND
			(IDTERMINAL					<> :iIdTerminalSQL OR :iIdTerminalSQL = 0 )AND 
			ROWNUM						=	1;
	
		if (iIdTerminalRecarga > 0)
			return ERR_EXISTE_OUTRO_TERMIMNAL_RECARGA;

	}
	else if ( iLiberadoPagamentoSQL == 1)
	{
		

		EXEC SQL
		SELECT  IDTERMINAL
		INTO
			:iIdTerminalRecarga				
		FROM
			VOL.SITEFTERMINAL
		WHERE
			INLIBERADOPAGAMENTO	=	1	   				AND
			IDPESSOADEPARA				=  :iIdPessoaDeParaSQL	AND
			(IDTERMINAL					<> :iIdTerminalSQL OR :iIdTerminalSQL = 0 )AND 
			ROWNUM						=	1;
	
		if (iIdTerminalRecarga > 0)
			return ERR_EXISTE_OUTRO_TERMIMNAL_RECARGA;

	}	


	EXEC SQL
	SELECT 
		IDTERMINAL
	INTO
		:iIdTerminalAtributos
	FROM
		VOL.SITEFTERMINAL
	WHERE
		NRIPTERMINAL	=   TO_CHAR(:cNrIpTerminalSQL)				AND
		(IDTERMINAL		<> :iIdTerminalSQL OR :iIdTerminalSQL = 0 )	AND
		ROWNUM			=	1;
					
		
	if (iIdTerminalAtributos > 0)
		return ERR_IP_EXISTENTE;


	EXEC SQL
	SELECT 
		IDTERMINAL
	INTO
		:iIdTerminalAtributos
	FROM
		VOL.SITEFTERMINAL
	WHERE
		NRTERMINAL		 = :cNrTerminalSQL	  AND
		(IDTERMINAL		<> :iIdTerminalSQL OR :iIdTerminalSQL = 0 )AND
		ROWNUM = 1;

	
	if (iIdTerminalAtributos > 0)
		return ERR_NRTERMINAL_EXISTENTE;


			
	return 0;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 
}

void  CLojista::alterarTerminal(int iIdTerminal, int iIdPessoaDePara, int iIdUFOperadora,  char *cNrTerminal, char *cNrIpTerminal, char *cCdSitefSenha, char *cCdLojaOperadoraCartao, int  iLiberadoRecarga, int  iLiberadoPagamento, int iIdCor)	 	 
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	

	int   iIdPessoaDeParaSQL = 0;
	int   iLiberadoRecargaSQL = 0;
	int   iLiberadoPagamentoSQL = 0;
	char  cCdLojaOperadoraCartaoSQL[15]="";

	char  cNrIpTerminalSQL[16] = "";
	int   iIdCorSQL = 0;
	int   iIdTerminalSQL = 0;
	char cNrTerminalSQL[20] ="";
	char cCdSitefSenhaSQL[10]="";
	int  iIdUFOperadoraSQL = 0;

	EXEC SQL END DECLARE SECTION;	
		

	iIdPessoaDeParaSQL = iIdPessoaDePara;
	iLiberadoRecargaSQL  = iLiberadoRecarga; 
	iLiberadoPagamentoSQL  = iLiberadoPagamento; 
	iIdTerminalSQL  = iIdTerminal;
	iIdCorSQL = iIdCor;
	iIdUFOperadoraSQL = iIdUFOperadora;
	strcpy (cCdLojaOperadoraCartaoSQL, cCdLojaOperadoraCartao);

	strcpy (cNrIpTerminalSQL, cNrIpTerminal);
	strcpy (cNrTerminalSQL, cNrTerminal);

	
	
	strcpy (cCdSitefSenhaSQL, cCdSitefSenha);
	// marca ponto de controle de erro
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO  sqlErrorConstrutor;

	EXEC SQL
	
		UPDATE
			VOL.SITEFTERMINAL
		SET
			NRIPTERMINAL			   = TO_CHAR(:cNrIpTerminalSQL),
			IDCOR					   = :iIdCorSQL,
			CDLOJAOPERADORACARTAO	   = TO_CHAR(:cCdLojaOperadoraCartaoSQL),
			NRTERMINAL				   = TO_CHAR(:cNrTerminalSQL),
			INLIBERADORECARGA = :iLiberadoRecargaSQL,
			INLIBERADOPAGAMENTO = :iLiberadoPagamentoSQL,
			IDUFOPERADORA              = :iIdUFOperadoraSQL			
		WHERE
			IDTERMINAL				   = :iIdTerminalSQL;
		
 
	return;

	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 


}



void  CLojista::incluirTerminal(long iIdPessoaDePara, char *cNrTerminal, char *cNrIpTerminal, char *cCdSitefSenha, char *cCdLojaOperadoraCartao, int  iLiberadoRecarga, int  iLiberadoPagamento, int iIdCor, int iIdUFOperadora)	 	 
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	

	long   iIdPessoaDeParaSQL = 0;
	int   iLiberadoRecargaSQL = 0;
	int   iLiberadoPagamentoSQL = 0;
	char  cCdLojaOperadoraCartaoSQL[15]= "";
	char  cNrTerminalSQL[15] = "";
	char  cNrIpTerminalSQL[16] = "";
	int   iIdUFOperadoraSQL = 0;
	int   iIdCorSQL = 0;
	char  cCdSitefSenhaSQL[10] = "";
	long int   iIdTerminalSQL = 0;
	
	EXEC SQL END DECLARE SECTION;	
	
	
	iIdPessoaDeParaSQL = iIdPessoaDePara;
	iLiberadoRecargaSQL  = iLiberadoRecarga; 
	iLiberadoPagamentoSQL  = iLiberadoPagamento;
	iIdUFOperadoraSQL = iIdUFOperadora;
	iIdCorSQL = iIdCor;


	strcpy (cCdLojaOperadoraCartaoSQL, cCdLojaOperadoraCartao);

	strcpy (cNrIpTerminalSQL, cNrIpTerminal);
	
	strcpy (cNrTerminalSQL, cNrTerminal);

	strcpy (cCdSitefSenhaSQL, cCdSitefSenha);


	// marca ponto de controle de erro
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO  sqlErrorConstrutor;
	
	EXEC SQL
	
	SELECT VOL.SITEFTERMINALSQ.NEXTVAL  INTO :iIdTerminalSQL FROM DUAL;
	

	EXEC SQL
		
	INSERT INTO
		   VOL.SITEFTERMINAL
		   (IDTERMINAL, 
		    NRTERMINAL,
			NRIPTERMINAL, 
			IDPESSOADEPARA, 
			CDLOJAOPERADORACARTAO, 
			IDUFOPERADORA,
			IDCOR,
			CDSITEFSENHA,
			INLIBERADORECARGA,
			INLIBERADOPAGAMENTO)
	VALUES
	(
	 	   :iIdTerminalSQL,
		   TO_CHAR(:cNrTerminalSQL),
		   TO_CHAR(:cNrIpTerminalSQL),
		   :iIdPessoaDeParaSQL,
		   TO_CHAR(:cCdLojaOperadoraCartaoSQL),		 
		   :iIdUFOperadoraSQL,
		   :iIdCorSQL,
	 	   TO_CHAR(:cCdSitefSenhaSQL),
		   :iLiberadoRecargaSQL,
		   :iLiberadoPagamentoSQL
	);

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 
}




void  CLojista::incluirLoja( char *cNmPessoa, char *cNmMunicipio, char *cNmLocalidade, char *cNmBairro, char *cNmTipoLogradouro, char *cNmTituloLogradouro, char *cNmLogradouro, char *cNrEndereco, char *cDsEnderecoComplemento, char *cNrCep, int iIdUF)
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	

	char  cNmMunicipioSQL[256]  = "";
	char  cNmLocalidadeSQL[256] = "";
	char  cNmBairroSQL[256]		= "";
	long int  iIdPessoaSQL			= 0;
	char  cNmTipoLogradouroSQL[256] = "";
	char  cNmLogradouroSQL[256] = "";
	int   iIdUFSQL				= 0;
	char  cDsEnderecoComplementoSQL[256] = "";
	char  cNrCepSQL[256]	=  "";
	short iIdLojaCadastrada = 0;
	int   iIdPessoaLoja = 0;
	char  cNrEnderecoSQL[256] = "";
	long int  iIdPessoaDeParaSQL = 0;
	long int  iIdPessoaEnderecoSQL = 0;
	char  cNmPessoaSQL[256] = "";

	
	EXEC SQL END DECLARE SECTION;	

	iIdUFSQL	= iIdUF;

	

	strcpy (cNmMunicipioSQL, cNmMunicipio);

	strcpy (cNmLocalidadeSQL, cNmLocalidade);

	strcpy (cNmBairroSQL, cNmBairro);
	
	strcpy (cNmTipoLogradouroSQL, cNmTipoLogradouro);

	strcpy (cNmLogradouroSQL, cNmLogradouro);

	strcpy (cNrEnderecoSQL, cNrEndereco); 

	strcpy (cDsEnderecoComplementoSQL, cDsEnderecoComplemento); 

	strcpy (cNrCepSQL, cNrCep);

	strcpy (cNmPessoaSQL, cNmPessoa);

	
	// marca ponto de controle de erro
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO  sqlErrorConstrutor;

	EXEC	SQL SELECT	customer.PessoaSQ.NEXTVAL  			   INTO :iIdPessoaSQL		       FROM dual;	

	EXEC    SQL SELECT	customer.PessoaDeParaSQ.NEXTVAL	  	   INTO :iIdPessoaDeParaSQL 	   FROM dual;	
	
	EXEC    SQL SELECT   customer.pessoaenderecoSQ.NEXTVAL	   INTO	:iIdPessoaEnderecoSQL	   FROM dual;

	


	EXEC SQL
	
	INSERT INTO
		   CUSTOMER.PESSOA
		   (IDPESSOA,
		    IDSISTEMAORIGEM,
			IDPESSOASISTEMAORIGEM, 
			NMPESSOA, 
			INFALECIMENTOINFORMADO,
			IDTIPOPESSOA, 
			IDTIPOCARTEIRA, 
			IDUF, 
			IDPROBINADIMPLENCIA, 
			IDCHURNPROBABILIDADE, 
			DTCADASTRO)
	VALUES(	
		   :iIdPessoaSQL, 
		   7, 
		   :iIdPessoaSQL, 
		   :cNmPessoaSQL, 
		   0, 
		   1, 
		   2, 
  		   :iIdUFSQL,
		   0, 
		   0, 
		   SYSDATE
		);


	

	EXEC SQL

	INSERT INTO
		   customer.pessoaendereco
		   (idpais, idpessoa,idpessoaendereco, idsistemaorigem,idtipoendereco, iduf,nmbairro,
		   nmlogradouro,nmtipologradouro, nrendereco,dsenderecocomplemento, nmmunicipio,nrcep)		
		VALUES
		 (0,
		  :iIdPessoaSQL,
		  :iIdPessoaEnderecoSQL,
		  7, 
		  2, 
		  :iIdUFSQL,
		  :cNmBairroSQL,
		  :cNmLogradouroSQL,
		  :cNmTipoLogradouroSQL,
		  :cNrEnderecoSQL,
		  :cDsEnderecoComplementoSQL,
		  :cNmMunicipioSQL,
		  :cNrCepSQL
		  );

	
	EXEC SQL
	INSERT INTO
		 customer.PessoaDePara
		 (IDPESSOADEPARA, IDPESSOA, IDPESSOAORIGEM, IDUSUARIOALTERACAO)
	VALUES
		(	  :iIdPessoaDeParaSQL, 
			  :iIdPessoaSQL,
			  :iIdPessoaSQL,
			   3
		);




	this->setIdPessoaDePara (iIdPessoaDeParaSQL);
	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 


}



int CLojista::excluirTerminal(int iIdTerminal, int iIdPessoaDePara)	 	 
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	

	int   iIdTerminalSQL = 0;
	int   iIdPessoaDeParaSQL = 0;
	int   iIdPessoaSQL = 0;
	int   iIdPessoaEnderecoSQL = 0; 
	int  iExisteOutroTerminal = 0;
	short	iExisteOutroTerminalLoja = 0;
	int iExisteHistoricoRecarga = 0;
	int iConfiguradoRecarga = 0;
	int iConfiguradoPagamento = 0;
	int iHistoricoPaligatem = 0;
	EXEC SQL END DECLARE SECTION;	
	
	
	iIdTerminalSQL = iIdTerminal;
	iIdPessoaDeParaSQL = iIdPessoaDePara;
	
	// marca ponto de controle de erro
	// Marca ponto de controle de erro
	tuxfw_getlogger()->debug("iIdTerminalSQL = %d\r\n",iIdTerminalSQL);

	

	EXEC SQL WHENEVER SQLERROR GOTO  sqlErrorConstrutor;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
	EXEC SQL

	SELECT 
		IDTERMINAL
	INTO 	
		:iExisteHistoricoRecarga
	FROM
		VOL.SITEFVENDA
	WHERE 
		IDTERMINAL = :iIdTerminalSQL    AND
		ROWNUM = 1;


	if (iExisteHistoricoRecarga > 0)
		return ERR_EXISTE_HISTORICO_ATENDIMENTO;


	EXEC SQL
	SELECT 
		IDTERMINAL
	INTO
		:iConfiguradoRecarga
	FROM
		VOL.SITEFTERMINAL
	WHERE 
		IDTERMINAL = :iIdTerminalSQL AND
		INLIBERADORECARGA = 1;


	if (iConfiguradoRecarga > 0)
		return ERR_TERMINAL_CONFIGURADO_RECARGA;

	EXEC SQL
	SELECT 
		IDTERMINAL
	INTO
		:iConfiguradoPagamento
	FROM
		VOL.SITEFTERMINAL
	WHERE 
		IDTERMINAL = :iIdTerminalSQL AND
		INLIBERADOPAGAMENTO = 1;


	if (iConfiguradoPagamento > 0)
		return ERR_TERMINAL_CONFIGURADO_RECARGA;

		
	EXEC SQL
	SELECT 
		IDTERMINAL
	INTO
		:iHistoricoPaligatem
	FROM
		VOL.ATENDIMENTOTERMINAL
	WHERE
		IDTERMINAL = :iIdTerminalSQL AND
		ROWNUM = 1;


	if (iHistoricoPaligatem)
		return ERR_EXISTE_HISTORICO_ATENDIMENTO;
	
		

	else{

		EXEC SQL

		DELETE FROM VOL.SITEFTERMINAL WHERE IDTERMINAL = :iIdTerminalSQL;

	

		EXEC   SQL	

		SELECT 
			IDTERMINAL
		INTO
			:iIdTerminalSQL:iExisteOutroTerminalLoja
		FROM 
			VOL.SITEFTERMINAL 
		WHERE 
			IDPESSOADEPARA =  :iIdPessoaDeParaSQL AND 
			IDTERMINAL     <> :iIdTerminalSQL AND
			ROWNUM		   =  1;


		if (!iIdTerminalSQL)
		{

			EXEC SQL
			SELECT 
				IDPESSOA
			INTO
				:iIdPessoaSQL
			FROM 
				CUSTOMER.PESSOADEPARA
			WHERE
				IDPESSOADEPARA = :iIdPessoaDeParaSQL;
		

			if (iIdPessoaSQL != 0)
			{
				EXEC SQL
				DELETE  FROM CUSTOMER.PESSOAENDERECO	WHERE IDPESSOA = :iIdPessoaSQL;


	
				EXEC SQL
				DELETE  FROM CUSTOMER.PESSOA	WHERE IDPESSOA = :iIdPessoaSQL;
	

			}

	
		}
	}
 
	return NO_ERROR;

	
	sqlErrorConstrutor:


		if (sqlca.sqlcode == -2292 || sqlca.sqlcode == 2292)		//child record found
			return ERR_EXISTE_HISTORICO_ATENDIMENTO;
			
		throw TuxBasicOraException(sqlca.sqlcode); 


}

void  CLojista::listaDadosLojaTerminal (int iIdTerminal,  XMLGen* xml_g )
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	

	int   iIdTerminalSQL = 0;
	char  cNrTerminalSQL[10] = "";
	char  cNrIpTerminal[20] = "";
	char  cCdLojaOperadoraCartaoSQL[20] = "";
	int   iIdUfOperadora = 0;
	char  cCdSitefSenhaSQL[15] ="";
	int   iIdCorSQL = 0;
	int   iLiberadoRecargaSQL = 0;
	int   iLiberadoPagamentoSQL = 0;
	char  cNmPessoaSQL [256] = "";
	char  cNmMunicipioSQL[256] = "";
	char  cNmBairroSQL[256] = "";
	char  cNmTipoLogradouroSQL[256] = "";
	char  cNmTituloLogradouroSQL[256] = "";
	char  cNmLogradouroSQL [256] = "";
	char  cNrEnderecoSQL[256] = "";
	char  cDsEnderecoComplementoSQL[256] = "";
	char  cNrCepSQL [256] = "";
	int   iIdUFSQL = 0;
	char  cSgUFSQL [256] = "";
	char  cNmUFSQL[256] = "";
	int   iIdPessoaDeParaSQL = 0;

	EXEC SQL END DECLARE SECTION;	
	

	// marca ponto de controle de erro
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO  sqlErrorConstrutor;
	
	EXEC SQL

	SELECT   
		SITEFTERMINAL.IDTERMINAL,
		SITEFTERMINAL.NRTERMINAL,
		SITEFTERMINAL.NRIPTERMINAL,				 
		SITEFTERMINAL.CDLOJAOPERADORACARTAO,
		SITEFTERMINAL.IDUFOPERADORA,
		SITEFTERMINAL.CDSITEFSENHA,
		SITEFTERMINAL.IDCOR,
		SITEFTERMINAL.INLIBERADORECARGA,
		SITEFTERMINAL.INLIBERADOPAGAMENTO,
		SITEFTERMINAL.IDPESSOADEPARA, 
		PESSOA.NMPESSOA,
		NVL(PESSOAENDERECO.NMMUNICIPIO, ' '),
		NVL(PESSOAENDERECO.NMBAIRRO, ' '),
		NVL(PESSOAENDERECO.NMTIPOLOGRADOURO, ' '),
		NVL(PESSOAENDERECO.NMTITULOLOGRADOURO, ' '),
		NVL(PESSOAENDERECO.NMLOGRADOURO, ' '),
		NVL(PESSOAENDERECO.NRENDERECO,' '),
		NVL(PESSOAENDERECO.DSENDERECOCOMPLEMENTO, ' '),
		NVL(PESSOAENDERECO.NRCEP, ' '),
		UFOPERADORA.IDUF,
		UF.SGUF,
		UF.NMUF
	INTO
		:iIdTerminalSQL,
		:cNrTerminalSQL,
		:cNrIpTerminal,
		:cCdLojaOperadoraCartaoSQL,
		:iIdUfOperadora,
		:cCdSitefSenhaSQL,
		:iIdCorSQL,
		:iLiberadoRecargaSQL,
		:iLiberadoPagamentoSQL,
		:iIdPessoaDeParaSQL,
		:cNmPessoaSQL,
		:cNmMunicipioSQL,
		:cNmBairroSQL,
		:cNmTipoLogradouroSQL,
		:cNmTituloLogradouroSQL,
		:cNmLogradouroSQL,
		:cNrEnderecoSQL,
		:cDsEnderecoComplementoSQL,
		:cNrCepSQL,
		:iIdUFSQL, 
		:cSgUFSQL,
		:cNmUFSQL
	FROM	  
		VOL.SITEFTERMINAL	 			SITEFTERMINAL,
		CUSTOMER.PESSOA 			    PESSOA,
		CUSTOMER.PESSOADEPARA 			PESSOADEPARA,
		CUSTOMER.PESSOAENDERECO 		PESSOAENDERECO,
		CUSTOMER.UFOPERADORA 			UFOPERADORA,
		APOIO.UF						UF
	WHERE 	
		SITEFTERMINAL.IDTERMINAL			 =   :iIdTerminal			   		AND
		SITEFTERMINAL.IDPESSOADEPARA 		 =   PESSOADEPARA.IDPESSOADEPARA  	AND
		PESSOADEPARA.IDPESSOA				 =   PESSOA.IDPESSOA				AND
		PESSOA.IDPESSOA			   	       	 =   PESSOAENDERECO.IDPESSOA(+)		AND
		SITEFTERMINAL.IDUFOPERADORA 	     =   UFOPERADORA.IDUFOPERADORA		AND
		UFOPERADORA.IDUF 					 =   UF.IDUF                        AND
		ROWNUM								 =	 1;



	xml_g->createTag("ManterTerminalVO");

	xml_g->addProp("xmlns", "voltav.fo.vivo.com.br/vo");

		xml_g->addItem("idTerminal", iIdTerminalSQL);
		
		xml_g->addItem("nrTerminal", trim(cNrTerminalSQL));
		
			
		xml_g->addItem("nrIpTerminal", trim(cNrIpTerminal));
	

		xml_g->addItem("cdLojaOperadoraCartao", trim(cCdLojaOperadoraCartaoSQL));

		xml_g->addItem("idUfOperadora", iIdUfOperadora);
		xml_g->addItem("cdSitefSenha", trim(cCdSitefSenhaSQL));
		xml_g->addItem("idCor", iIdCorSQL);
		xml_g->addItem("inLiberadoRecarga", iLiberadoRecargaSQL);
		xml_g->addItem("inLiberadoPagamento", iLiberadoPagamentoSQL);
		xml_g->addItem("idPessoaDePara", iIdPessoaDeParaSQL);
		
		xml_g->addItem("nmPessoa", trim(cNmPessoaSQL));

		xml_g->addItem("idPessoaEndereco", 0);
		xml_g->addItem("nmMunicipio", trim(cNmMunicipioSQL));
		xml_g->addItem("nmLocalidade", trim(cNmLogradouroSQL));
		xml_g->addItem("nmBairro", trim(cNmBairroSQL));
		xml_g->addItem("nmTipoLogradouro", trim(cNmTipoLogradouroSQL));
		xml_g->addItem("nmTituloLogradouro", trim(cNmTituloLogradouroSQL));
		xml_g->addItem("nmLogradouro", trim(cNmLogradouroSQL));
		xml_g->addItem("nrEndereco", trim(cNrEnderecoSQL));

		
		xml_g->addItem("dsEnderecoComplemento", trim(cDsEnderecoComplementoSQL));
		xml_g->addItem("nrCep", trim(cNrCepSQL));
		
		xml_g->createTag("UFVO");
		xml_g->addProp("xmlns", "cliente.fo.vivo.com.br/vo");
			xml_g->addItem("idUF", iIdUFSQL);
			xml_g->addItem("sgUF", trim(cSgUFSQL));
			xml_g->addItem("nmUF", trim(cNmUFSQL));
		xml_g->closeTag();
	
	xml_g->closeTag();

	return;

	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 
}


void  CLojista::resetSenhaTerminal (int iIdTerminal )
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	

	int   iIdTerminalSQL = 0;

	char cSenhaPadrao[5] = "";
	EXEC SQL END DECLARE SECTION;	
	

	iIdTerminalSQL = iIdTerminal;

	strcpy (cSenhaPadrao, "0000");

	EXEC SQL WHENEVER SQLERROR GOTO  sqlErrorConstrutor;

	EXEC SQL
	UPDATE 
		VOL.SITEFTERMINAL
	SET 
		CDSITEFSENHA = :cSenhaPadrao
	WHERE
		IDTERMINAL = :iIdTerminalSQL;


	

	return;

	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 



}

void  CLojista::PesquisaNomeLoja(char *cNmPessoa, XMLGen* xml_g)
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	

	int   iIdTerminalSQL = 0;
	char  cNrTerminalSQL[10] = "";
	char  cNrIpTerminalSQL[20] = "";
	char  cCdLojaOperadoraCartaoSQL[20] = "";
	int   iIdUFOperadoraSQL = 0;
	char  cCdSitefSenhaSQL[15] ="";
	int   iIdCorSQL = 0;
	int   iLiberadoRecargaSQL = 0;
	int   iLiberadoPagamentoSQL = 0;
	char  cNmPessoaSQL [256] = "";
	char  cNmMunicipioSQL[256] = "";
	char  cNmBairroSQL[256] = "";
	char  cNmTipoLogradouroSQL[256] = "";
	char  cNmTituloLogradouroSQL[256] = "";
	char  cNmLogradouroSQL [256] = "";
	char  cNrEnderecoSQL[256] = "";
	char  cDsEnderecoComplementoSQL[256] = "";
	char  cNrCepSQL [256] = "";
	int   iIdUFSQL = 0;
	char  cSgUFSQL [256] = "";
	char  cNmUFSQL[256] = "";
	int   iIdPessoaDeParaSQL = 0;
	char  cNmPessoSQL[256] = "";
	char  cNmPessoaLoja[256] = "";
	

	EXEC SQL END DECLARE SECTION;	


	strcpy (cNmPessoSQL, cNmPessoa);



	// marca ponto de controle de erro
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO  sqlErrorConstrutor;
	
	EXEC SQL DECLARE LSTPESQUISALOJA CURSOR FOR

	SELECT   DISTINCT				 
		SITEFTERMINAL.CDLOJAOPERADORACARTAO,
		SITEFTERMINAL.IDUFOPERADORA,	
		SITEFTERMINAL.IDPESSOADEPARA, 
		PESSOA.NMPESSOA,
		NVL(PESSOAENDERECO.NMMUNICIPIO, ' '),
		NVL(PESSOAENDERECO.NMBAIRRO, ' '),
		NVL(PESSOAENDERECO.NMTIPOLOGRADOURO, ' '),
		NVL(PESSOAENDERECO.NMTITULOLOGRADOURO, ' '),
		NVL(PESSOAENDERECO.NMLOGRADOURO, ' '),
		NVL(PESSOAENDERECO.NRENDERECO,' '),
		NVL(PESSOAENDERECO.DSENDERECOCOMPLEMENTO, ' '),
		NVL(PESSOAENDERECO.NRCEP, ' '),
		UFOPERADORA.IDUF,
		UF.SGUF,
		UF.NMUF	
	FROM	  
		VOL.SITEFTERMINAL	 			SITEFTERMINAL,
		CUSTOMER.PESSOA 			    PESSOA,
		CUSTOMER.PESSOADEPARA 			PESSOADEPARA,
		CUSTOMER.PESSOAENDERECO 		PESSOAENDERECO,
		CUSTOMER.UFOPERADORA 			UFOPERADORA,
		APOIO.UF						UF
	WHERE 	
		SITEFTERMINAL.IDPESSOADEPARA 		 =   PESSOADEPARA.IDPESSOADEPARA  	AND
		PESSOADEPARA.IDPESSOA				 =   PESSOA.IDPESSOA				AND
		PESSOA.IDPESSOA			   	       	 =   PESSOAENDERECO.IDPESSOA(+)		AND
		SITEFTERMINAL.IDUFOPERADORA 	     =   UFOPERADORA.IDUFOPERADORA		AND			
		UFOPERADORA.IDUF 					 =   UF.IDUF                        AND
		UPPER(PESSOA.NMPESSOA)				LIKE     TO_CHAR(:cNmPessoSQL);




	xml_g->createTag("ListaLojaVO");

		xml_g->addProp("xmlns", "cliente.fo.vivo.com.br/vo");


	// Marca ponto de controle de erro
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	EXEC SQL OPEN LSTPESQUISALOJA;

	for( ;; ) 
	{
		// varre todos os registros para criar a lista com os servicos

		EXEC SQL FETCH LSTPESQUISALOJA INTO
			:cCdLojaOperadoraCartaoSQL,
			:iIdUFOperadoraSQL,
			:iIdPessoaDeParaSQL,
			:cNmPessoaSQL,
			:cNmMunicipioSQL,
			:cNmBairroSQL,
			:cNmTipoLogradouroSQL,
			:cNmTituloLogradouroSQL,
			:cNmLogradouroSQL,
			:cNrEnderecoSQL,
			:cDsEnderecoComplementoSQL,
			:cNrCepSQL,
			:iIdUFSQL,
			:cSgUFSQL,
			:cNmUFSQL;

	
		xml_g->createTag( "LojaVO" );

		
			xml_g->addItem("cdLojaOperadoraCartao", trim(cCdLojaOperadoraCartaoSQL));
			xml_g->addItem("idUfOperadora", iIdUFOperadoraSQL);

			xml_g->addItem("idPessoaDePara", iIdPessoaDeParaSQL);
			xml_g->addItem("idPessoa", 0);

			xml_g->addItem("nmPessoa",  trim(cNmPessoaSQL));
			xml_g->addItem("nmLoja",  trim(cNmPessoaSQL));
			xml_g->addItem("idPessoaEndereco", 0);
			xml_g->addItem("nmMunicipio", trim(cNmMunicipioSQL));

			xml_g->addItem("nmLocalidade", trim(cNmLogradouroSQL));
			xml_g->addItem("nmBairro",  trim(cNmBairroSQL));
			xml_g->addItem("nmTipoLogradouro", trim(cNmTipoLogradouroSQL));
			xml_g->addItem("nmTituloLogradouro", trim(cNmTituloLogradouroSQL));
			xml_g->addItem("nmLogradouro", trim(cNmLogradouroSQL));
			xml_g->addItem("nrEndereco", trim(cNrEnderecoSQL));
			xml_g->addItem("dsEnderecoComplemento", trim(cDsEnderecoComplementoSQL));

			xml_g->addItem("idUF", iIdUFSQL);
			xml_g->addItem("sgUF", trim(cSgUFSQL));
			xml_g->addItem("nmUF", trim(cNmUFSQL));


		xml_g->closeTag();
		
	}


	xml_g->closeTag();


	EXEC SQL CLOSE LSTPESQUISALOJA;



	return;

	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 
}






void CLojista::consultarOperadora ( XMLGen* xml_g, int iIdUF)
{

	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	
	
	char cOperadora[256] ="";
	int iIdUFOperadora = 0;
	int iIdUFSQL = 0;

	EXEC SQL END DECLARE SECTION;	
		
	iIdUFSQL = iIdUF;


	// marca ponto de controle de erro
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO  sqlErrorConstrutor;
	
	EXEC SQL DECLARE LSTOPERADORA CURSOR FOR

	SELECT  
		GRUPOOPERADORA.NMGRUPOOPERADORA || ' - ' ||  UF.SGUF AS OPERADORA,
		UFOPERADORA.IDUFOPERADORA
	FROM
		CUSTOMER.UFOPERADORA  UFOPERADORA,
		APOIO.UF UF,
		CUSTOMER.OPERADORA OPERADORA,
		CUSTOMER.GRUPOOPERADORA GRUPOOPERADORA
	WHERE 
		UFOPERADORA.IDUF					= UF.IDUF AND
		(UFOPERADORA.IDUF					= :iIdUFSQL OR :iIdUFSQL = 0) AND 
		UFOPERADORA.IDPESSOADEPARAOPERADORA = OPERADORA.IDPESSOADEPARAOPERADORA AND
		OPERADORA.IDGRUPOOPERADORA			= GRUPOOPERADORA.IDGRUPOOPERADORA
	ORDER BY OPERADORA;
	
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	EXEC SQL OPEN LSTOPERADORA;

	
	xml_g->createTag("VOLTAVUFOperadoraVO");

	xml_g->addProp("xmlns", "voltav.fo.vivo.com.br/vo");

	
	for( ;; ) 
	{
		// varre todos os registros para criar a lista com os servicos

		EXEC SQL FETCH LSTOPERADORA INTO
			:cOperadora,
			:iIdUFOperadora;

			
				xml_g->addItem("idOperadora", iIdUFOperadora);
		
				xml_g->addItem("dsOperadora", trim(cOperadora));
	

	}
	
	xml_g->closeTag();


	EXEC SQL CLOSE  LSTOPERADORA;

	
	return;

	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 

}




void CLojista::consultarEnderecoLoja ( XMLGen* xml_g, int iIdPessoaDePara)
{

	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	
	
	int iIdUFOperadora = 0;
	int iIdPessoaDeParaSQL = 0;
	int iIdPessoaEndereco = 0;
	char cNmMunicipio[256]="";
	char cNmBairro[256]="";
	char cNmTipoLogradouro[256]="";
	char cNmTituloLogradouro[256]="";
	char cNmLogradouro[256] = "";
	char cNrEndereco[256] = "";
	char cDsEnderecoComplemento[256] = "";
	char cNrCep[256]= "";
	int  iIdUF = 0;
	char cSgUF[256] ="";
	char cNmUF[256]="";
	char cCdLojaOperadoraCartao[256]="";
	char cNmPessoa[256]="";
	EXEC SQL END DECLARE SECTION;	

	iIdPessoaDeParaSQL = iIdPessoaDePara;

	// marca ponto de controle de erro
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO  sqlErrorConstrutor;
	EXEC SQL WHENEVER NOT FOUND GOTO  sqlErrorConstrutor;
		
	EXEC SQL	
	SELECT   		
		SITEFTERMINAL.IDUFOPERADORA,
		SITEFTERMINAL.IDPESSOADEPARA, 	
		SITEFTERMINAL.CDLOJAOPERADORACARTAO,
		PESSOA.NMPESSOA,		
		NVL(PESSOAENDERECO.NMMUNICIPIO, ' '),
		NVL(PESSOAENDERECO.NMBAIRRO, ' '),
		NVL(PESSOAENDERECO.NMTIPOLOGRADOURO, ' '),
		NVL(PESSOAENDERECO.NMTITULOLOGRADOURO, ' '),
		NVL(PESSOAENDERECO.NMLOGRADOURO, ' '),
		NVL(PESSOAENDERECO.NRENDERECO,' '),
		NVL(PESSOAENDERECO.DSENDERECOCOMPLEMENTO, ' '),
		NVL(PESSOAENDERECO.NRCEP, ' '),
		UFOPERADORA.IDUF,
		UF.SGUF,
		UF.NMUF	
	INTO
		:iIdUFOperadora,
		:iIdPessoaDePara,
		:cCdLojaOperadoraCartao,
		:cNmPessoa,		
		:cNmMunicipio,
		:cNmBairro,
		:cNmTipoLogradouro,
		:cNmTituloLogradouro,
		:cNmLogradouro,
		:cNrEndereco,
		:cDsEnderecoComplemento,
		:cNrCep,
		:iIdUF,
		:cSgUF,
		:cNmUF
	FROM	  
		VOL.SITEFTERMINAL	 			SITEFTERMINAL,		
		CUSTOMER.PESSOADEPARA 			PESSOADEPARA,
		CUSTOMER.PESSOAENDERECO 		PESSOAENDERECO,
		CUSTOMER.UFOPERADORA 			UFOPERADORA,
		APOIO.UF						UF,
		CUSTOMER.PESSOA					PESSOA
	WHERE 	
		SITEFTERMINAL.IDPESSOADEPARA         = :iIdPessoaDeParaSQL				AND
		SITEFTERMINAL.IDPESSOADEPARA 		 =   PESSOADEPARA.IDPESSOADEPARA  	AND		
		PESSOADEPARA.IDPESSOA	   	       	 =   PESSOAENDERECO.IDPESSOA		AND
		PESSOADEPARA.IDPESSOA				 =   PESSOA.IDPESSOA	            AND
		SITEFTERMINAL.IDUFOPERADORA 	     =   UFOPERADORA.IDUFOPERADORA		AND			
		UFOPERADORA.IDUF 					 =   UF.IDUF                        AND
		ROWNUM = 1;                   
	
	
	xml_g->createTag("EnderecoVO");

	xml_g->addProp("xmlns", "cliente.fo.vivo.com.br/vo");

	xml_g->addItem("idUfOperadora", iIdUFOperadora);
			
	xml_g->addItem("nmTipoLogradouro", trim(cNmTipoLogradouro));

	xml_g->addItem("nmTituloLogradouro", trim(cNmTituloLogradouro));
	
	xml_g->addItem("nmLogradouro", trim(cNmLogradouro));

	xml_g->addItem("nmPessoa", trim(cNmPessoa));

	xml_g->addItem("cdLojaOperadoraCartao", trim(cCdLojaOperadoraCartao));

	xml_g->addItem("nmBairro", trim(cNmBairro));
	
	xml_g->addItem("nmMunicipio", trim(cNmMunicipio));		

	xml_g->addItem("nrEndereco", trim(cNrEndereco));

	xml_g->addItem("dsEnderecoComplemento", trim(cDsEnderecoComplemento));

	xml_g->addItem("nrCEP", trim(cNrCep));
	
	xml_g->createTag("UFVO");

		xml_g->addItem("idUF", iIdUF);
		xml_g->addItem("sgUF", trim(cSgUF));
		xml_g->addItem("nmUF", trim(cNmUF));


	xml_g->closeTag();
	
	xml_g->closeTag();
	
	return;

	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 


}
void CLojista:: registrarLog (int iIdUser, char *cNmMunicipio, char *cDsAcao)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;	
	
	char cNmLoginSQL[256] = "";
	char nmGrupo[256]="";
	int  iIdUFOperadoraSQL = 0;
	char cNrTerminalSQL[15] = "";
	char cNrIpTerminalSQL[17] = "";
	char cCdSitefSenhaSQL[10] = "";
	char cCdLojaOperadoraCartaoSQL[20] = "";
	char cNmMunicipioSQL[256] = "";
	char cDsAcaoSQL[15] = "";
	int  iCadastroLog = 0;
	char cGet[256] ="";
	int  iIdUserSQL = 0;
	char cNmLojaSQL[256] ="";
	EXEC SQL END DECLARE SECTION;	


	
	strcpy (cNrIpTerminalSQL, this->getNrIpTerminal(cGet));	
	strcpy (cNrTerminalSQL, this->getNrTerminal(cGet));	
	strcpy (cCdLojaOperadoraCartaoSQL, this->getCdLojaOperadoraCartao(cGet));	
	strcpy (cNmMunicipioSQL, cNmMunicipio);
	strcpy (cDsAcaoSQL, cDsAcao);	
	iIdUFOperadoraSQL = this->getIdUFOperadora();
	iIdUserSQL = iIdUser;
	strcpy (cNmLojaSQL, this->getNmPessoa());



	EXEC SQL WHENEVER SQLERROR  GOTO  sqlErrorConstrutor;
	EXEC SQL WHENEVER NOT FOUND GOTO  sqlErrorConstrutor;
		

	EXEC SQL SELECT VOL.CADASTROTAVLOGSQ.NEXTVAL INTO :iCadastroLog FROM DUAL;
	
	EXEC SQL 
	SELECT 
		NMLOGINUSUARIO 
	INTO
		:cNmLoginSQL	
	FROM 
		ACESSO.USUARIO 
	WHERE 
		IDPESSOAUSUARIO = :iIdUserSQL;


	strcpy (cNmLoginSQL, trim(cNmLoginSQL));

	EXEC SQL
	INSERT INTO VOL.CADASTROTAVLOG
	(
	 IDCADASTROTAVLOG,
	 DTALTERACAO, 
	 NRIPTERMINAL,
	 NMMUNICIPIO, 
	 NRTERMINAL, 
	 DSACAO, 
	 CDLOJAOPERADORACARTAO,
	 NMLOGINUSUARIO,
	 IDUFOPERADORA,
	 NMLOJA	 
	 )
	 VALUES
	 (:iCadastroLog,
	  SYSDATE,
	  :cNrIpTerminalSQL,
	  :cNmMunicipioSQL,
	  :cNrTerminalSQL,
	  :cDsAcaoSQL,
	  :cCdLojaOperadoraCartaoSQL,
	  :cNmLoginSQL,
	  :iIdUFOperadoraSQL,
	  :cNmLojaSQL
	);


	return;
	
	
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
	
	

}



