#include <sys/time.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <iostream.h>
#include <ctype.h>

#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

#ifndef WIN32
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include  <sys/types.h>
#include  <netinet/in.h>
#include <arpa/inet.h>
#endif // AIX

#ifndef WIN32
#include <unistd.h>
#endif

#include "../include/removeProtocoloSms.h"
#include "../../commons/Propriedade/include/MFile.h"
#include "../../commons/Log/include/Log.h"
#include "../../commons/SplitLine.h"

#include <string>
using namespace std;

EXEC SQL INCLUDE SQLCA;


using namespace std;
char szAux[1024 + 1];   // Usado nas linhas de LOG
Log oLog;

int main ( int argc, char *argv[] )
{
    int i;
    int retorno;
    int max;
    int   LimiteMaximo = 0;
    double startTime, endTime;
    char UsedTime[16];
    memset(UsedTime, 0x0, sizeof(UsedTime));
    time_t      rawtime;
    struct tm * timeinfo;
    char        sData[32];
    
    startTime = getRealTime();   // Inicia cronometro de Operacao
    char sProcessoFilho[128];
    char sInstancia[64];

    TParamConf tParamConf;
    char nrMaxInstancias[16];   // Maximo de Instancias removeProtocoloSms_Chld
    char nrMaxIteracoes[16];    // Maximo de Iteracoes na tabela ATENDIMENTO.CONTROLEFILASMS
    
    memset( nrMaxInstancias, 0x0, sizeof(nrMaxInstancias) );
    memset( nrMaxIteracoes , 0x0, sizeof(nrMaxIteracoes) );
    
    oLog.setNivel(2);
    oLog.logDebug(">>> removeProtocoloSms");
    
    if ( argc == 2 )
    {
        sprintf ( nrMaxInstancias, "%s", argv[1] );
        if (atoi(nrMaxInstancias) < 1 || atoi(nrMaxInstancias) > 32 ) // argumento passado com valor invalido, assume
           nrMaxInstancias[0] = 0x0;                 // valor parametrizado no banco
    }

    if ( argc == 3 )
    {
        sprintf ( nrMaxInstancias, "%s", argv[1] );
        if (atoi(nrMaxInstancias) < 1 || atoi(nrMaxInstancias) > 32 ) // argumento passado com valor invalido, assume
           nrMaxInstancias[0] = 0x0;                 // valor parametrizado no banco

           sprintf ( nrMaxIteracoes, "%s", argv[2] );
        if (atoi(nrMaxIteracoes) < 1 || atoi(nrMaxIteracoes) > 500 ) // argumento passado com valor invalido, assume
           nrMaxIteracoes[0] = 0x0;                 // valor parametrizado no banco
    }

    //==========================================================================
    // Parâmetros de configuração
    if(ObtemParamConf(&tParamConf))
    {
        oLog.logError("*** ERRO AO OBTER PARAMETROS DE CONFIGURACAO ***");
        endTime = getRealTime();   // Finaliza Cronometro de Operacao
        ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS.FFFF em UsedTime - Tempo Gasto 
        sprintf( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);
        oLog.logDebug( "<<< removeProtocoloSms" );
        exit(1);
    }

    //==========================================================================
    // Conecta ao banco
    oLog.logDebug("### Conectando com Banco de Dados. ###");
    if (DBConnect(tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst))
    {
        oLog.logError("*** ERRO DE CONEXAO AO BANCO DE DADOS ***");
        endTime = getRealTime();   // Finaliza Cronometro de Operacao
        ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS&&& Vai Executar [.FFFF em UsedTime - Tempo Gasto 
        sprintf( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);
        oLog.logDebug( "<<< removeProtocoloSms" );
        exit(1);
    }
    
    if ( nrMaxIteracoes[0] == 0x0 )   // Nao foi informado por linha de comando a Qtde. de Maxima de Registros
    {
        LimiteMaximo = ObterParamMaxIteracoes();   // Sendo assim, busca parametrizacao no banco
        sprintf (nrMaxIteracoes, "%d", LimiteMaximo );
    }

    if ( nrMaxInstancias[0] == 0x0 )   // Nao foi informado por linha de comando a Qtde. de Maxima de Registros
    {
        LimiteMaximo = ObterParamMaxInstancias();   // Sendo assim, busca parametrizacao no banco
        sprintf (nrMaxInstancias, "%d", LimiteMaximo);
    }

    oLog.logDebug( "*** Configuracao Efetuada com Sucesso ***" );
    sprintf ( szAux, "===> Nro. de Instancias ........... [%s] <===", nrMaxInstancias ); oLog.logDebug(szAux);
    sprintf ( szAux, "===> Nro. de Iteracoes ............ [%s] <===", nrMaxIteracoes ); oLog.logDebug(szAux);
    
/*     time ( &rawtime );
    timeinfo = localtime ( &rawtime );
    strftime( sData, 17, "%Y%m%d-%H%M%S", timeinfo );
 */    max = atoi(nrMaxInstancias);
    for (i=1 ; i <= max ; i++) 
    {
        time ( &rawtime );
        timeinfo = localtime ( &rawtime );
        strftime( sData, 17, "%Y%m%d-%H%M%S", timeinfo );
        sprintf( sInstancia, "Instancia_%02d_%s", i, sData );
        sprintf( sProcessoFilho, "nohup ./removeProtocoloSms_Chld %s 2>&1 >> ../log/%s.log", nrMaxIteracoes, sInstancia );

        //sprintf ( szAux, "===> Instanciando [%s] <===", sProcessoFilho ); oLog.logDebug(szAux);

        retorno = system ( sProcessoFilho );
        if ( retorno < 0 )
        {
            sprintf ( szAux, "*** system: [%s]", strerror(errno) );oLog.logDebug(szAux);
        }
        sleep(3);
    }

    //sprintf ( szAux, "===> Total Instanciado [%02d] <===", i-1 ); oLog.logDebug(szAux);
    
     char bf[128];
    int fd;
    int TotalInstancias;
    memset(bf,0x0,sizeof(bf));
    system( "ps -ef | grep removeProtocoloSms_Chld | wc -l > threads.txt" );
    fd = open("threads.txt",O_RDONLY);
    if (fd < 0) sprintf ( szAux, "===> ERRO [%s] <===", strerror(errno) ); oLog.logDebug(szAux);
    read(fd,bf,127);
    close(fd);
    TotalInstancias = atoi(bf) - 1;
    if ( TotalInstancias < 0 ) TotalInstancias = 0;
    //sprintf ( szAux, "===> bf [%d] <===", TotalInstancias ); oLog.logDebug(szAux); 

    while ( TotalInstancias > 0 )
    {
        oLog.logDebug( "Aguardando Termino de Processos Filho <===" );
        sleep(3);
        memset(bf,0x0,sizeof(bf));
        system( "ps -ef | grep removeProtocoloSms_Chld | wc -l > threads.txt" );
        fd = open("threads.txt",O_RDONLY);
        if (fd < 0) sprintf ( szAux, "===> ERRO [%s] <===", strerror(errno) ); oLog.logDebug(szAux);
        read(fd,bf,127);
        close(fd);
        TotalInstancias = atoi(bf) - 1;
        if ( TotalInstancias < 0 ) TotalInstancias = 0;
        //sprintf ( szAux, "===> bf [%d] <===", TotalInstancias ); oLog.logDebug(szAux); 
    }
    
    AtualizaEstat();   // Atualizando Estatisticas
    
    endTime = getRealTime();   // Finaliza Cronometro de Operacao
    ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS.FFFF em UsedTime - Tempo Gasto 
    sprintf( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);
    oLog.logDebug( "<<< removeProtocoloSms\n" );
    exit(0);
}



/**
 * Returns the real time, in seconds, or -1.0 if an error occurred.
 *
 * Time is measured since an arbitrary and OS-dependent start time.
 * The returned real time is only useful for computing an elapsed time
 * between two calls to this function.
 */
double getRealTime(void)
{
    /* AIX, BSD, Cygwin, HP-UX, Linux, OSX, POSIX, Solaris. ----- */
    struct timeval tm;
    gettimeofday( &tm, NULL );
    return (double)tm.tv_sec + (double)tm.tv_usec / 1000000.0;
}


/*
 *   Retorna Tempo Usado
 *   StartTime - Tempo Inicial
 *   EndTime - Tempo Final
 *   UsedTime - Tempo Gasto
 */
void ElapsedTime(double StartTime, double EndTime, char * UsedTime)
{
    int hora, minuto, segundo;

    char Tempo[16];
    char Segundos[8];
    char Miliseg[4];
    char * Result = NULL;

    sprintf ( Tempo, "%lf.", (EndTime - StartTime) );
    Result = strtok(Tempo,".");
    sprintf(Segundos,"%s", Result);
    //printf("Segundos [%s]\n",Segundos);
    Result = strtok(NULL,".");
    sprintf(Miliseg, "%.4s", Result);
    //printf("Miliseg [%s]\n",Miliseg);

    hora = (atoi(Segundos)/3600);
    minuto = (atoi(Segundos)-(3600*hora))/60;
    segundo = (atoi(Segundos)-(3600*hora)-(minuto*60));
    sprintf( UsedTime, "%02d:%02d:%02d.%s", hora, minuto, segundo, Miliseg );

}



/************************************************************************************************************/
int DBConnect(char *pUsr, char *pPwd, char *pInst)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[64];
    EXEC SQL END DECLARE SECTION;

    // String de conexao
    sprintf(connString, "%s/%s@%s", pUsr, pPwd, pInst);

    // Marca ponto de erro
    EXEC SQL WHENEVER SQLERROR GOTO errConn;

    // Conecta
    EXEC SQL CONNECT :connString;

    return 0;

errConn:
    sprintf(szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    return -1;
}



/************************************************************************************************************/
int DBDisconnect(void)
{
    EXEC SQL WHENEVER SQLERROR GOTO Error;
    EXEC SQL COMMIT WORK RELEASE;
    return 0;

Error:
    oLog.logDebug("*** ERRO AO DESCONECTAR DO BANCO ***");
    sprintf(szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    return -1;
}



/************************************************************************************************************/
int ObterParamMaxIteracoes( void )
{
    EXEC SQL BEGIN DECLARE SECTION;
        int MaxRegs=0;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    EXEC SQL
        SELECT
            TO_NUMBER(NVL(DSVALORPARAMETRO,500))
        INTO
            :MaxRegs
        FROM
            APOIO.PARAMETRO
        WHERE
            CDPARAMETRO = 'NRO_MAX_ITERAC_RMV_FILA_PROTO';

    if ( MaxRegs <= 0 )
    {
        oLog.logDebug("### Parametro 'NRO_MAX_ITERAC_RMV_FILA_PROTO' com valor inválido, assumindo valor default [500]. ###");
        MaxRegs = 500;
    }

    return MaxRegs;

erro:
    oLog.logDebug("*** ERRO AO OBTER VALOR MAXIMO DE ITERACOES A PROCESSAR ***");
    sprintf(szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    oLog.logDebug("*** ASSUMINDO VALOR DEFAULT [500] ***");
    return 500;

naoexiste:
    oLog.logDebug("*** PARAMETRO 'NRO_MAX_ITERAC_RMV_FILA_PROTO' NAO ENCONTRADO. ASSUMINDO DEFAULT [500]. ***");
    return 500;
}



/************************************************************************************************************/
int ObterParamMaxInstancias( void )
{
    EXEC SQL BEGIN DECLARE SECTION;
        int Limite = 5;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro_Instancia;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste_Instancia;

    EXEC SQL
        SELECT
            TO_NUMBER(NVL(DSVALORPARAMETRO,5))
        INTO
            :Limite
        FROM
            APOIO.PARAMETRO
        WHERE
            CDPARAMETRO = 'NRO_MAX_INSTANC_RMV_FILA_PROTO';

    if ( Limite <= 0 )
    {
        oLog.logDebug("### Parametro 'NRO_MAX_INSTANC_RMV_FILA_PROTO' com valor inválido, assumindo valor default [5]. ###");
        Limite = 5;
    }

    return Limite;

erro_Instancia:
    oLog.logDebug("*** ERRO AO OBTER VALOR MAXIMO DE INSTANCIAS A PROCESSAR ***");
    sprintf(szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    oLog.logDebug("*** ASSUMINDO VALOR DEFAULT [5] ***");
    return 5;

naoexiste_Instancia:
    oLog.logDebug("*** PARAMETRO 'NRO_MAX_INSTANC_RMV_FILA_PROTO' NAO ENCONTRADO. ASSUMINDO DEFAULT [5]. ***");
    return 5;
}



/************************************************************************************************************/
int ObtemParamConf(TParamConf *ptParamConf)
{
    MFile mfConfig;
    SplitLine NewLinha;
    char szLinha[101];
    char szDivArq[256];
    char szDivPre[21];

    oLog.logDebug(">>> Obtendo parametros de configuracao...");

    // Zera variáveis
    memset(ptParamConf, 0, sizeof(TParamConf));
    memset(szLinha, 0, sizeof(szLinha));
    memset(szDivArq, 0, sizeof(szDivArq));
    memset(szDivPre, 0, sizeof(szDivPre));

    // Define o arquivo de configuração
    mfConfig.setPath("removeProtocoloSms.cfg");

    // Verificar se conseguiu abrir o arquivo
    if(!mfConfig.abrir())
    {
        oLog.logError("!!! ERRO AO ABRIR ARQUIVO DE CONFIGURACAO !!!");
        return -1;
    }

    // Capturando usuario, senha, path e instance de banco do arquivo
    NewLinha.SetDiv('=');
    while(mfConfig.getLine(szLinha) != 0)
    {
        NewLinha.SetLine(szLinha);
        NewLinha.GetBeforeDiv(szDivPre);
        NewLinha.GetAfterDiv(szDivArq);

        // Verifica qual parâmetro foi encontrado.
        if (!strcmp(szDivPre, "pwd_db"))
        {
            strncpy(ptParamConf->szPws, szDivArq, TAM_BD_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_db"))
        {
            strncpy(ptParamConf->szUsr, szDivArq, TAM_BD_USRNAME);
        }
        else if (!strcmp(szDivPre, "inst_db"))
        {
            strncpy(ptParamConf->szInst, szDivArq, TAM_BD_INST);
        }
        memset(szLinha,  0, sizeof(szLinha));
        memset(szDivPre, 0, sizeof(szDivPre));
        memset(szDivArq, 0, sizeof(szDivArq));
    }

    // Fechando o arquivo de configuracao aberto
    mfConfig.fechar();

    sprintf(szAux, "ptParamConf->szUsr[%s]", ptParamConf->szUsr); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szInst[%s]", ptParamConf->szInst); oLog.logDebug(szAux);

    // Verifica se todos os dados foram recuperados do arquivo de configuração.
    if (strlen(ptParamConf->szInst) == 0)
    {
        oLog.logError("!!! CONFIGURACAO INCOMPLETA !!!");
        return -1;
    }

    oLog.logDebug("### Sucesso na Configuracao ###");
    return 0;
}



int AtualizaEstat( void )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char szProcedure[256];
    EXEC SQL END DECLARE SECTION;

    double startTime, endTime;
    char UsedTime[16];
    memset(UsedTime, 0x0, sizeof(UsedTime));
    startTime = getRealTime();   // Inicia cronometro de Operacao

    struct sqlca sqlca;
    oLog.logDebug("### Atualizando Estatisticas na Tabela ###");

    EXEC SQL WHENEVER SQLERROR goto erro_Estatistica;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    sprintf(szProcedure, "BEGIN ATENDIMENTO.SP_STATS_FILASMSPROTOCOLO; END;");

    EXEC SQL PREPARE CALLPROC FROM :szProcedure;
    EXEC SQL EXECUTE CALLPROC;

    endTime = getRealTime();   // Finaliza Cronometro de Operacao
    ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS.FFFF em UsedTime - Tempo Gasto 
    sprintf( szAux, "### Tempo de execucao nas Estatisticas: %s", UsedTime ); oLog.logDebug(szAux);
    oLog.logDebug("### Estatisticas Atualizadas ###");
    return 0;

erro_Estatistica:
    oLog.logDebug("*** ERRO AO ATUALIZAR ESTATISTICAS DA FILA DE PROTOCOLOS ***");
    sprintf(szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    return -1;
}
