/**
 * @modulo  Batch
 * @usecase Batch
 * @author
 * @version $Revision: 1.1.6.2 $
 * @CVS     $Author: a5114878 $ - $Date: 2016/02/26 14:30:53 $
 **/



#include <sys/time.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <iostream.h>
#include <ctype.h>

#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

#ifndef WIN32
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include  <sys/types.h>
#include  <netinet/in.h>
#include <arpa/inet.h>
#endif // AIX

#define MAX_RETRIES     10

#define LOCK            1
#define UNLOCK          0
#define KILL            2

#ifndef WIN32
#include <unistd.h>
#endif

#include "../include/removeProtocoloSms.h"
#include "../../commons/Propriedade/include/MFile.h"
#include "../../commons/Log/include/Log.h"
#include "../../commons/SplitLine.h"

#include <string>
using namespace std;

EXEC SQL INCLUDE SQLCA;

#define TOKEN_B0 0xB0   // = hexToString("B0", CHARSET_ISO_8859_1); //byte -80, Token °, char 176
#define TOKEN_B1 0xB1   // = hexToString("B1", CHARSET_ISO_8859_1); //byte -79, Token ±, char 177
#define TOKEN_B2 0xB2   // = hexToString("B2", CHARSET_ISO_8859_1); //byte -78, Token ², char 178

//==============================================================================
// Globals
char szAux[1024 + 1];   // Usado nas linhas de LOG
Log oLog;
//==============================================================================
// Run
int main( int argc, char *argv[] )
{
    double startTime, endTime;
    char UsedTime[16];
    memset(UsedTime, 0x0, sizeof(UsedTime));
    startTime = getRealTime();   // Inicia cronometro de Operacao

    TParamConf tParamConf;
    char nrMaxIteracoes[16];
    int  MaxIteracoes = 0;
    
    
    oLog.setNivel(2);
    oLog.logDebug(">>> removeProtocoloSms_Chld");

    memset ( nrMaxIteracoes, 0x0, sizeof(nrMaxIteracoes) ) ;

    if (argc == 2)
    {
        strcpy (nrMaxIteracoes, argv[1]);
    }

    //==========================================================================
    // Parâmetros de configuração
    if(ObtemParamConf(&tParamConf))
    {
        oLog.logError("*** ERRO AO OBTER PARAMETROS DE CONFIGURACAO ***");
        endTime = getRealTime();   // Finaliza Cronometro de Operacao
        ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS.FFFF em UsedTime - Tempo Gasto 
        sprintf( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);
        oLog.logDebug( "<<< removeProtocoloSms_Chld" );
        exit(1);
    }

    //==========================================================================
    // Conecta ao banco
    oLog.logDebug("### Conectando com Banco de Dados ###");
    if (DBConnect(tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst))
    {
        oLog.logError("*** ERRO DE CONEXAO AO BANCO DE DADOS ***");
        endTime = getRealTime();   // Finaliza Cronometro de Operacao
        ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS.FFFF em UsedTime - Tempo Gasto 
        sprintf( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);
        oLog.logDebug( "<<< removeProtocoloSms_Chld" );
        exit(1);
    }
    
    if ( nrMaxIteracoes[0] == 0x0 )   // Nao foi informado por linha de comando a Qtde. de Maxima de Registros
    {
        MaxIteracoes = ObterParamMaxIteracoes();   // Sendo assim, busca parametrizacao no banco
        sprintf (nrMaxIteracoes, "%d", MaxIteracoes);
    }
    
    ProcessaRegistroControle( nrMaxIteracoes );

    
    DBDisconnect();
    
    endTime = getRealTime();   // Finaliza Cronometro de Operacao
    ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS.FFFF em UsedTime - Tempo Gasto 
    sprintf( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);

    oLog.logDebug( "<<< removeProtocoloSms_Chld" );
    exit(0);
    
}



/************************************************************************************************************/
int ObtemParamConf(TParamConf *ptParamConf)
{
    MFile mfConfig;
    SplitLine NewLinha;
    char szLinha[101];
    char szDivArq[256];
    char szDivPre[21];

    oLog.logDebug(">>> Obtendo parametros de configuracao...");

    // Zera variáveis
    memset(ptParamConf, 0, sizeof(TParamConf));
    memset(szLinha, 0, sizeof(szLinha));
    memset(szDivArq, 0, sizeof(szDivArq));
    memset(szDivPre, 0, sizeof(szDivPre));

    // Define o arquivo de configuração
    mfConfig.setPath("removeProtocoloSms.cfg");

    // Verificar se conseguiu abrir o arquivo
    if(!mfConfig.abrir())
    {
        oLog.logError("!!! ERRO AO ABRIR ARQUIVO DE CONFIGURACAO !!!");
        return -1;
    }

    // Capturando usuario, senha, path e instance de banco do arquivo
    NewLinha.SetDiv('=');
    while(mfConfig.getLine(szLinha) != 0)
    {
        NewLinha.SetLine(szLinha);
        NewLinha.GetBeforeDiv(szDivPre);
        NewLinha.GetAfterDiv(szDivArq);

        // Verifica qual parâmetro foi encontrado.
        if (!strcmp(szDivPre, "pwd_db"))
        {
            strncpy(ptParamConf->szPws, szDivArq, TAM_BD_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_db"))
        {
            strncpy(ptParamConf->szUsr, szDivArq, TAM_BD_USRNAME);
        }
        else if (!strcmp(szDivPre, "inst_db"))
        {
            strncpy(ptParamConf->szInst, szDivArq, TAM_BD_INST);
        }
        memset(szLinha,  0, sizeof(szLinha));
        memset(szDivPre, 0, sizeof(szDivPre));
        memset(szDivArq, 0, sizeof(szDivArq));
    }

    // Fechando o arquivo de configuracao aberto
    mfConfig.fechar();

    sprintf(szAux, "ptParamConf->szUsr[%s]", ptParamConf->szUsr); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szInst[%s]", ptParamConf->szInst); oLog.logDebug(szAux);

    // Verifica se todos os dados foram recuperados do arquivo de configuração.
    if (strlen(ptParamConf->szInst) == 0)
    {
        oLog.logError("!!! CONFIGURACAO INCOMPLETA !!!");
        return -1;
    }

    oLog.logDebug("### Sucesso na Configuracao ###");
    return 0;
}



/************************************************************************************************************/
int DBConnect(char *pUsr, char *pPwd, char *pInst)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[64];
    EXEC SQL END DECLARE SECTION;

    // String de conexao
    sprintf(connString, "%s/%s@%s", pUsr, pPwd, pInst);

    // Marca ponto de erro
    EXEC SQL WHENEVER SQLERROR GOTO errConn;

    // Conecta
    EXEC SQL CONNECT :connString;

    return 0;

errConn:
    sprintf(szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    return -1;
}



/************************************************************************************************************/
int DBDisconnect(void)
{
    EXEC SQL WHENEVER SQLERROR GOTO Error;
    EXEC SQL COMMIT WORK RELEASE;
    return 0;

Error:
    oLog.logDebug("*** ERRO AO DESCONECTAR DO BANCO ***");
    sprintf(szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    return -1;
}



/************************************************************************************************************/
int ObterParamMaxIteracoes(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
        int MaxRegs=0;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    EXEC SQL
        SELECT
            TO_NUMBER(NVL(DSVALORPARAMETRO,500))
        INTO
            :MaxRegs
        FROM
            APOIO.PARAMETRO
        WHERE
            CDPARAMETRO = 'NRO_MAX_ITERAC_RMV_FILA_PROTO';

    if ( MaxRegs <= 0 )
    {
        oLog.logDebug("### Parametro 'NRO_MAX_ITERAC_RMV_FILA_PROTO' com valor inválido, assumindo valor default [500]. ###");
        MaxRegs = 500;
    }

    return MaxRegs;

erro:
    oLog.logDebug("*** ERRO AO OBTER VALOR MAXIMO DE REGISTROS A PROCESSAR ***");
    sprintf(szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    oLog.logDebug("*** ASSUMINDO VALOR DEFAULT [10] ***");
    return 500;

naoexiste:
    oLog.logDebug("*** PARAMETRO 'NRO_MAX_ITERAC_RMV_FILA_PROTO' NAO ENCONTRADO. ASSUMINDO DEFAULT [500]. ***");
    return 500;
}



/************************************************************************************************************/
void ObterParamMsgParse(TParamConf *tParamConf)
{
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR varOraDsValorParametro[256];
        short statOraDsValorParametro = -1;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erroParse;
    EXEC SQL WHENEVER NOT FOUND goto naoexisteParse;

    EXEC SQL
        SELECT
            NVL(DSVALORPARAMETRO,'S')
        INTO
            :varOraDsValorParametro:statOraDsValorParametro
        FROM
            APOIO.PARAMETRO
        WHERE
            CDPARAMETRO = 'SMS_PROTO_MSGPARSE';

    CONVIND(varOraDsValorParametro,statOraDsValorParametro);
    SAFE_STRNCPY(tParamConf->szMessageParse,(char*)varOraDsValorParametro.arr);

    return;

erroParse:
    sprintf(szAux,"Erro %d na busca do parametro 'SMS_PROTO_MSGPARSE'. Assumindo 'S'.",sqlca.sqlcode);
    oLog.logDebug(szAux);
    SAFE_STRNCPY(tParamConf->szMessageParse,"S");

naoexisteParse:
    sprintf(szAux,"Parametro 'SMS_PROTO_MSGPARSE' nao encontrado. Assumindo 'S'.");
    oLog.logDebug(szAux);
    SAFE_STRNCPY(tParamConf->szMessageParse,"S");
}



/************************************************************************************************************/
void ObterParamMsgLog(TParamConf *tParamConf)
{
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR varOraDsValorParametro[256];
        short statOraDsValorParametro = -1;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erroLog;
    EXEC SQL WHENEVER NOT FOUND goto naoexisteLog;

    EXEC SQL
        SELECT
            NVL(DSVALORPARAMETRO,'N')
        INTO
            :varOraDsValorParametro:statOraDsValorParametro
        FROM
            APOIO.PARAMETRO
        WHERE
            CDPARAMETRO = 'SMS_PROTO_MSGLOG';

    CONVIND(varOraDsValorParametro,statOraDsValorParametro);
    SAFE_STRNCPY(tParamConf->szMessageLog,(char*)varOraDsValorParametro.arr);

    return;

erroLog:
    sprintf(szAux,"Erro %d na busca do parametro 'SMS_PROTO_MSGLOG'. Assumindo 'N'.",sqlca.sqlcode);
    oLog.logDebug(szAux);
    SAFE_STRNCPY(tParamConf->szMessageLog,"N");

naoexisteLog:
    sprintf(szAux,"Parametro 'SMS_PROTO_MSGLOG' nao encontrado. Assumindo 'N'.");
    oLog.logDebug(szAux);
    SAFE_STRNCPY(tParamConf->szMessageLog,"N");
}



int ProcessaRegistroControle( char * nrMaxIteracoes_PRM )
{
    double startTime, endTime;
    char UsedTime[16];
    memset(UsedTime, 0x0, sizeof(UsedTime));

    startTime = getRealTime();   // Inicia cronometro de Operacao

    EXEC SQL BEGIN DECLARE SECTION;
    
        VARCHAR idCtlFilaSMS[128];
        short i_idCtlFilaSMS = -1;
        VARCHAR tpEnvio[3];
        short i_tpEnvio = -1;
        char * nrMaxIteracoes = nrMaxIteracoes_PRM;
        
    EXEC SQL END DECLARE SECTION;
    
    int MaxIterac = atoi(nrMaxIteracoes_PRM);
    char idControle[128];
    int  iTipoEnvio;

    oLog.logDebug( ">>> ProcessaRegistroControle()" );
    sprintf( szAux, "Nro. Maximo de Iteracoes: [%s] ", nrMaxIteracoes ); oLog.logDebug(szAux);
    struct sqlca sqlca;
    
    memset ( &idCtlFilaSMS, 0x0, sizeof(idCtlFilaSMS) ) ;

    EXEC SQL WHENEVER SQLERROR goto erroCtl;

    EXEC SQL DECLARE cControle CURSOR FOR
    SELECT
       IDCONTROLEFILASMS
    FROM
       ATENDIMENTO.CONTROLEFILASMS
    WHERE
       INPROCESSADO = 3 ;
       
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL OPEN cControle;
    for( int i = 1; i <= MaxIterac; i++ )
    {
        EXEC SQL FETCH cControle
        INTO
            :idCtlFilaSMS:i_idCtlFilaSMS;
            
        CONVIND( idCtlFilaSMS, i_idCtlFilaSMS );

        EXEC SQL WHENEVER NOT FOUND CONTINUE;
        EXEC SQL UPDATE ATENDIMENTO.CONTROLEFILASMS SET INPROCESSADO = 2 WHERE IDCONTROLEFILASMS = :idCtlFilaSMS ;
        EXEC SQL COMMIT;
        
        EXEC SQL
        SELECT TPENVIO 
           INTO :tpEnvio:i_tpEnvio 
        FROM 
           ATENDIMENTO.FILASMSPROTOCOLO 
        WHERE 
           IDCONTROLEFILASMS = :idCtlFilaSMS 
        AND ROWNUM <= 1 ;
        
        if (i_tpEnvio == -1)
        {
            EXEC SQL DELETE FROM ATENDIMENTO.FILASMSPROTOCOLO WHERE IDCONTROLEFILASMS = :idCtlFilaSMS ;
            EXEC SQL DELETE FROM ATENDIMENTO.CONTROLEFILASMS WHERE IDCONTROLEFILASMS = :idCtlFilaSMS ;
            EXEC SQL COMMIT;
            continue;
        }
        
        CONVIND( tpEnvio,i_tpEnvio );
        iTipoEnvio = atoi((char*)&tpEnvio.arr);
        sprintf ( idControle, "%s", (const char*)idCtlFilaSMS.arr );
        
        if ( iTipoEnvio == 1)
        {
            ProcessaRegistroSMS( idControle );   // Processa Registros enviados por SMS
        }
        else
        {
            ProcessaRegistroEmail( idControle );   // Processa Registros enviados por email
        }

        EXEC SQL DELETE FROM ATENDIMENTO.FILASMSPROTOCOLO WHERE IDCONTROLEFILASMS = :idCtlFilaSMS ;
        EXEC SQL DELETE FROM ATENDIMENTO.CONTROLEFILASMS WHERE IDCONTROLEFILASMS = :idCtlFilaSMS ;
        EXEC SQL COMMIT;        
        
    }
    EXEC SQL CLOSE cControle;
    
    
    endTime = getRealTime();   // Finaliza Cronometro de Operacao
    ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS.FFFF em UsedTime - Tempo Gasto 
    
    sprintf( szAux, "### [ProcessaRegistroControle()] Tempo de execucao: %s", UsedTime ); oLog.logDebug(szAux);

    oLog.logDebug( "<<< ProcessaRegistroControle()" );
    return 0;

erroCtl:
    sprintf(szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    oLog.logDebug( "<<< ProcessaRegistroControle()" );
    return -1;
}



int ProcessaRegistroSMS ( char * idControleFilaSMS )
{

    oLog.logDebug( ">>> ProcessaRegistroSMS()" );
    
    double startTime, endTime;
    char UsedTime[16];
    memset(UsedTime, 0x0, sizeof(UsedTime));
    startTime = getRealTime();   // Inicia cronometro de Operacao
    
    TParamConf tParamConf;
    char szDsValorParametro[256];
    char szDsMsg[1001];
    char szDtAtual[20];
    long iIdAtendimentoProtocolo;
    char szIdAtendimentoProtocolo[256];
    char ddd[3];
    char linha[32];
    char dgInicLinha[2];
    char MsgLinhaFixa[256];

    EXEC SQL BEGIN DECLARE SECTION;
        char * idCtlFilaSMS = idControleFilaSMS ;
        int linhas_processadas;

        VARCHAR lstDadoOraIdAtendimentoProtocolo[39];
        VARCHAR lstDadoOraCdAreaRegistro[4];
        VARCHAR lstDadoOraNrLinha[11];
        VARCHAR lstDadoOraDsMensagemEnvio[1001];
        VARCHAR lstDadoOraDsMotivoNaoEnvio[256];
        int lstDadoOraInEnvioSMS;
        int lstDadoOraTpEnvio;
        VARCHAR idUsuarioAlteracao[256];   
        VARCHAR cdOrigem[256];
        VARCHAR idLinhaTelefonica[256];
        short lstStatOraIdAtendimentoProtocolo;
        short lstStatOraCdAreaRegistro;
        short lstStatOraNrLinha;
        short lstStatOraDsMensagemEnvio;
        short lstStatOraDsMotivoNaoEnvio;
        short lstStatOraInEnvioSMS;
        short lstStatOraTpEnvio;
        short i_cdOrigem;
        short i_idLinhaTelefonica;
        VARCHAR DSVALORPARAMETRO[256];
        short iDSVALORPARAMETRO=0;
        VARCHAR DTATUAL[256];
        short i_DTATUAL = -1;
        VARCHAR prmMsgProtMovelPros[256];
        short i_prmMsgProtMovelPros = -1;
        VARCHAR prmMsgProtFixaClie[256];
        short i_prmMsgProtFixaClie = -1;
        VARCHAR prmMsgProtFixaPros[256];
        short i_prmMsgProtFixaPros = -1;
        short i_idUsuarioAlteracao = -1;
        
        VARCHAR lstRowId[256];
        
    EXEC SQL END DECLARE SECTION;

    int ctCommit = 0;

    int  iStatusEnvioSMS;
    char szDsMensagemEnvio[601];
    char szDsListaClassificacao[601] = {0};
    char szidClassificacaoSMS[40];

    
    // Trata mensagem?
    ObterParamMsgParse(&tParamConf);
    //sprintf(szAux,"Tratamento da Mensagem=%s",tParamConf.szMessageParse);oLog.logDebug(szAux);

    //==========================================================================
    // Logar mensagem ?
    ObterParamMsgLog(&tParamConf);
    //sprintf(szAux,"Log da Mensagem=%s",tParamConf.szMessageLog);oLog.logDebug(szAux);

    EXEC SQL WHENEVER SQLERROR GOTO sqlError;
    // a mensagem de envio DSMENSAGEMENVIO somada com o complemento deve conter 140 caracteres.
    // Se a primeira parte for superior a 72, devemos enviar apenas a primeira parte da mensagem.

    EXEC SQL DECLARE cProtocolos CURSOR FOR
    SELECT  
        FILASMSPROTOCOLO.IDATENDIMENTOPROTOCOLO,
        FILASMSPROTOCOLO.CDAREAREGISTRO,
        FILASMSPROTOCOLO.NRLINHA,
        (CASE WHEN (LENGTH(FILASMSPROTOCOLO.DSMENSAGEMENVIO) + 69 <= 140) THEN
        FILASMSPROTOCOLO.DSMENSAGEMENVIO || '. ' || NVL(COMPLEMENTOSMS.DSCOMPLEMENTO,'FALE CONOSCO TAMBEM PELO VIVO.COM.BR/MEUVIVO OU ENVIE SMS PARA 1058') ELSE
        FILASMSPROTOCOLO.DSMENSAGEMENVIO||'.' END)DSMENSAGEMENVIO,
        FILASMSPROTOCOLO.INENVIOSMS,
        FILASMSPROTOCOLO.TPENVIO,
        FILASMSPROTOCOLO.IDUSUARIOALTERACAO ,
        (CASE WHEN FILASMSPROTOCOLO.IDTIPOLINHA<9 THEN 'MOVEL' 
              WHEN FILASMSPROTOCOLO.IDTIPOLINHA>=9 THEN 'FIXO'
              ELSE NULL END)CDORIGEM,
              TO_CHAR(DTENCERRAMENTO,'DD/MM/RRRR')||' AS '||TO_CHAR(DTENCERRAMENTO-1/24,'HH24:MI') AS DTATUAL,
        FILASMSPROTOCOLO.IDTIPOLINHA ,
        FILASMSPROTOCOLO.ROWID AS RID
    FROM
        ATENDIMENTO.FILASMSPROTOCOLO FILASMSPROTOCOLO ,
        ATENDIMENTO.COMPLEMENTOSMS   COMPLEMENTOSMS
    WHERE
        FILASMSPROTOCOLO.CDAREAREGISTRO = COMPLEMENTOSMS.CDAREAREGISTRO(+)
    AND FILASMSPROTOCOLO.IDTIPOLINHA = COMPLEMENTOSMS.IDTIPOLINHA(+)
    AND FILASMSPROTOCOLO.SGTIPOPESSOA = COMPLEMENTOSMS.SGTIPOPESSOA(+)
    AND FILASMSPROTOCOLO.SGUF = COMPLEMENTOSMS.SGUF(+)
    /* AND NVL(COMPLEMENTOSMS.STATUS,1) = 1 */
    AND FILASMSPROTOCOLO.TPENVIO = 1
    AND FILASMSPROTOCOLO.IDCONTROLEFILASMS = :idCtlFilaSMS ;
   

    memset( &lstDadoOraIdAtendimentoProtocolo,0,sizeof(lstDadoOraIdAtendimentoProtocolo) );
    memset( &lstDadoOraCdAreaRegistro,0,sizeof(lstDadoOraCdAreaRegistro) );
    memset( &lstDadoOraNrLinha,0,sizeof(lstDadoOraNrLinha) );
    memset( &lstDadoOraDsMensagemEnvio,0,sizeof(lstDadoOraDsMensagemEnvio) );
    memset( &lstDadoOraDsMotivoNaoEnvio,0,sizeof(lstDadoOraDsMotivoNaoEnvio) );
    memset( &lstDadoOraInEnvioSMS,0,sizeof(lstDadoOraInEnvioSMS) );
    memset( &lstDadoOraTpEnvio,0,sizeof(lstDadoOraTpEnvio) );
    memset( &lstStatOraIdAtendimentoProtocolo,-1,sizeof(lstStatOraIdAtendimentoProtocolo) );
    memset( &lstStatOraCdAreaRegistro,-1,sizeof(lstStatOraCdAreaRegistro) );
    memset( &lstStatOraNrLinha,-1,sizeof(lstStatOraNrLinha) );
    memset( &lstStatOraDsMensagemEnvio,-1,sizeof(lstStatOraDsMensagemEnvio) );
    memset( &lstStatOraDsMotivoNaoEnvio,-1,sizeof(lstStatOraDsMotivoNaoEnvio) );
    memset( &lstStatOraInEnvioSMS,-1,sizeof(lstStatOraInEnvioSMS) );
    memset( &lstStatOraTpEnvio,-1,sizeof(lstStatOraTpEnvio) );
    memset( ddd  , 0x0, sizeof(ddd) );
    memset( linha, 0x0, sizeof(linha) );
    memset( &prmMsgProtMovelPros, 0x0, sizeof(prmMsgProtMovelPros) );
    memset( &prmMsgProtFixaClie,  0x0, sizeof(prmMsgProtFixaClie) );
    memset( &prmMsgProtFixaPros,  0x0, sizeof(prmMsgProtFixaPros) );
    memset( &idUsuarioAlteracao,  0x0, sizeof(idUsuarioAlteracao) );
    
    //==========================================================================
    // Processa

    //oLog.logDebug("Enviando SMS's...");

    //======================================================================
    // Envia os SMS's que tiverem de ser enviados...
    int qtEnviadas = 0;
                linhas_processadas = 0;
    int iQtdContatoZero = 0;
    
    int iqtdlinhasErroTibco = 0;  // INCLUIDO NA ALTERACAO DE PERFORMANCE
    int iqtdlinhasFixo = 0;
    int iqtdlinhasNaoIdent = 0;
    
    i_prmMsgProtMovelPros = -1;
    
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL
    SELECT 
       PARM.DSVALORPARAMETRO
    INTO
       :prmMsgProtMovelPros:i_prmMsgProtMovelPros
    FROM 
       APOIO.PARAMETRO PARM
    WHERE
       PARM.CDPARAMETRO = 'MSG_PROT_MOVEL_PROS' ;

    i_prmMsgProtMovelPros = -1;
    EXEC SQL
    SELECT 
       PARM.DSVALORPARAMETRO
    INTO
       :prmMsgProtFixaClie:i_prmMsgProtFixaClie
    FROM 
       APOIO.PARAMETRO PARM
    WHERE
       PARM.CDPARAMETRO = 'MSG_PROT_FIXA_CLIE' ;
    
    i_prmMsgProtMovelPros = -1;
    EXEC SQL
    SELECT 
       PARM.DSVALORPARAMETRO
    INTO
       :prmMsgProtFixaPros:i_prmMsgProtFixaPros
    FROM 
       APOIO.PARAMETRO PARM
    WHERE
       PARM.CDPARAMETRO = 'MSG_PROT_FIXA_PROS' ;
       

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    
    EXEC SQL OPEN cProtocolos;

    for( ; ; linhas_processadas++ )
    {
        i_idUsuarioAlteracao = i_DTATUAL = iStatusEnvioSMS = i_idLinhaTelefonica = i_cdOrigem = -1;

        memset(&lstDadoOraIdAtendimentoProtocolo,0,sizeof(lstDadoOraIdAtendimentoProtocolo));
        memset(&lstDadoOraCdAreaRegistro,0,sizeof(lstDadoOraCdAreaRegistro));
        memset(&lstDadoOraNrLinha,0,sizeof(lstDadoOraNrLinha));
        memset(&lstDadoOraDsMensagemEnvio,0,sizeof(lstDadoOraDsMensagemEnvio));
        memset(&lstDadoOraDsMotivoNaoEnvio,0,sizeof(lstDadoOraDsMotivoNaoEnvio));
        memset(&lstDadoOraInEnvioSMS,0,sizeof(lstDadoOraInEnvioSMS));
        memset(&lstDadoOraTpEnvio,0,sizeof(lstDadoOraTpEnvio));
        memset(&lstStatOraIdAtendimentoProtocolo,-1,sizeof(lstStatOraIdAtendimentoProtocolo));
        memset(&lstStatOraCdAreaRegistro,-1,sizeof(lstStatOraCdAreaRegistro));
        memset(&lstStatOraNrLinha,-1,sizeof(lstStatOraNrLinha));
        memset(&lstStatOraDsMensagemEnvio,-1,sizeof(lstStatOraDsMensagemEnvio));
        memset(&lstStatOraDsMotivoNaoEnvio,-1,sizeof(lstStatOraDsMotivoNaoEnvio));
        memset(&lstStatOraInEnvioSMS,-1,sizeof(lstStatOraInEnvioSMS));
        memset(&lstStatOraTpEnvio,-1,sizeof(lstStatOraTpEnvio));
        memset( ddd  , 0x0, sizeof(ddd) );
        memset( linha, 0x0, sizeof(linha) );
        memset( &idUsuarioAlteracao, 0x0, sizeof(idUsuarioAlteracao) );
        memset( &lstRowId, 0x0, sizeof(lstRowId) );

        EXEC SQL FETCH cProtocolos
        INTO
            :lstDadoOraIdAtendimentoProtocolo:lstStatOraIdAtendimentoProtocolo,
            :lstDadoOraCdAreaRegistro:lstStatOraCdAreaRegistro,
            :lstDadoOraNrLinha:lstStatOraNrLinha,
            :lstDadoOraDsMensagemEnvio:lstStatOraDsMensagemEnvio,
            :lstDadoOraInEnvioSMS:lstStatOraInEnvioSMS,
            :lstDadoOraTpEnvio:lstStatOraTpEnvio,
            :idUsuarioAlteracao:i_idUsuarioAlteracao ,
            :cdOrigem:i_cdOrigem,
            :DTATUAL:i_DTATUAL,
            :idLinhaTelefonica:i_idLinhaTelefonica ,
            :lstRowId ;

            
        CONVIND( lstDadoOraIdAtendimentoProtocolo,lstStatOraIdAtendimentoProtocolo );
        CONVIND( lstDadoOraCdAreaRegistro,lstStatOraCdAreaRegistro );
        CONVIND( lstDadoOraNrLinha,lstStatOraNrLinha );
        CONVIND( lstDadoOraDsMensagemEnvio,lstStatOraDsMensagemEnvio );
        CONVIND( idUsuarioAlteracao, i_idUsuarioAlteracao );
        CONVIND( cdOrigem,i_cdOrigem );
        CONVIND( DTATUAL, i_DTATUAL );
        CONVIND( idLinhaTelefonica, i_idLinhaTelefonica );
        endOraStr( lstRowId );
        
        // Se existir suspeita de mensagem com lixo, podemos habilitar tratamento
        if ( 'S' == tParamConf.szMessageParse[0] )
        {
            int lenMensagem = strlen((char*)lstDadoOraDsMensagemEnvio.arr);

            char *p = strstr((char*)lstDadoOraDsMensagemEnvio.arr," as ");
            if ( p==0 ) { p = strstr((char*)lstDadoOraDsMensagemEnvio.arr," AS "); }
            int posIni = p - (char*)lstDadoOraDsMensagemEnvio.arr + 12; // 12 = tam de " as hh:mm - ";
            if ( posIni < 0 || posIni > lenMensagem ) { posIni=0; }

            for( int j=posIni;j<lenMensagem;j++ )
            {
                if ( lstDadoOraDsMensagemEnvio.arr[j] < 32 || lstDadoOraDsMensagemEnvio.arr[j] > 125 )
                {
                     lstDadoOraDsMensagemEnvio.arr[j] = ' ';
                }
            }
        } // if ( 'S' == tParamConf.szMessageParse[0] )

        if ( 1 == lstDadoOraInEnvioSMS )
        {
            
            if ( (!strcmp((const char*)cdOrigem.arr, "MOVEL") || i_cdOrigem == -1) && i_idLinhaTelefonica == -1 || !strcmp((const char*)cdOrigem.arr, "FIXO") )
            {
                if ( (!strcmp((const char*)cdOrigem.arr, "MOVEL") || i_cdOrigem == -1) && i_idLinhaTelefonica == -1 && i_prmMsgProtMovelPros != -1 )
                {
                    //oLog.logDebug( "Movel -> Prospect..." );
                    STRCPY_FROM_ORA(szDsValorParametro, prmMsgProtMovelPros );
                    STRCPY_FROM_ORA(szDtAtual, DTATUAL);
                    STRCPY_FROM_ORA(szIdAtendimentoProtocolo,lstDadoOraIdAtendimentoProtocolo);
                    iIdAtendimentoProtocolo = atol(szIdAtendimentoProtocolo);
                    memset(szDsMsg,0,sizeof(szDsMsg));
                    sprintf(szDsMsg, szDsValorParametro, iIdAtendimentoProtocolo, szDtAtual);
                    memset(lstDadoOraDsMensagemEnvio.arr,0,sizeof(lstDadoOraDsMensagemEnvio.arr));
                    STRCPY_TO_ORA(lstDadoOraDsMensagemEnvio, szDsMsg);
                }
                else if ( !strcmp((const char*)cdOrigem.arr, "FIXO") && i_idLinhaTelefonica != -1 && i_prmMsgProtFixaClie != -1 )
                {
                    //oLog.logDebug( "Fixo -> Cliente..." );
                    STRCPY_FROM_ORA(szDsValorParametro, prmMsgProtFixaClie );
                    STRCPY_FROM_ORA(szDtAtual, DTATUAL);
                    STRCPY_FROM_ORA(szIdAtendimentoProtocolo,lstDadoOraIdAtendimentoProtocolo);
                    iIdAtendimentoProtocolo = atol(szIdAtendimentoProtocolo);
                    memset(szDsMsg,0,sizeof(szDsMsg));
                    sprintf(szDsMsg, szDsValorParametro, iIdAtendimentoProtocolo, szDtAtual);
                    memset(lstDadoOraDsMensagemEnvio.arr,0,sizeof(lstDadoOraDsMensagemEnvio.arr));
                    STRCPY_TO_ORA(lstDadoOraDsMensagemEnvio, szDsMsg);
                }
                else
                {
                    if ( i_prmMsgProtFixaPros != -1 )
                    {
                        //oLog.logDebug( "Fixo -> Prospect..." );
                        STRCPY_FROM_ORA(szDsValorParametro, prmMsgProtFixaPros );
                        STRCPY_FROM_ORA(szDtAtual, DTATUAL);
                        STRCPY_FROM_ORA(szIdAtendimentoProtocolo,lstDadoOraIdAtendimentoProtocolo);
                        iIdAtendimentoProtocolo = atol(szIdAtendimentoProtocolo);
                        memset(szDsMsg,0,sizeof(szDsMsg));
                        sprintf(szDsMsg, szDsValorParametro, iIdAtendimentoProtocolo, szDtAtual);
                        memset(lstDadoOraDsMensagemEnvio.arr,0,sizeof(lstDadoOraDsMensagemEnvio.arr));
                        STRCPY_TO_ORA(lstDadoOraDsMensagemEnvio, szDsMsg);
                    }
                }
            }

            sprintf( ddd, "%s",(const char*)lstDadoOraCdAreaRegistro.arr );
            sprintf( linha, "%s",(const char*)lstDadoOraNrLinha.arr );
            
            if ( atoi(ddd) > 0 )
            {
                if ( atoi(linha) > 0 )
                {
                    memset( dgInicLinha, 0x0, sizeof(dgInicLinha) );
                    dgInicLinha[0] = linha[0]; // atribui o primeiro digito da linha para identificacao de movel ou fixo
                    
                    if ( atoi(dgInicLinha) < 5 )  // Considerado Linha de Fixo, nao sera enviado SMS
                    {
                        memset( MsgLinhaFixa, 0x0, sizeof(MsgLinhaFixa) );
                        sprintf( MsgLinhaFixa, "SMS não enviado para linha fixa: (%s) %.4s-%.4s", (const char*)ddd, (const char*)linha, (const char*)&linha[4] );
                        strcpy((char*)lstDadoOraDsMotivoNaoEnvio.arr,
                            MsgLinhaFixa );
                        lstDadoOraDsMotivoNaoEnvio.len =
                            strlen((char*)lstDadoOraDsMotivoNaoEnvio.arr);
                        lstStatOraDsMotivoNaoEnvio = 1;

/*                          sprintf( szAux,">>> SMS NÃO ENVIADO: Linha de Fixo - idAtdProtocolo=[%s] DDD=[%s] linha=[%s] "
                                      ,(const char*)lstDadoOraIdAtendimentoProtocolo.arr
                                      ,(const char*)lstDadoOraCdAreaRegistro.arr
                                      ,(const char*)lstDadoOraNrLinha.arr);
                        oLog.logDebug(szAux);
 */                    }
                    else   // Considerado linha movel, pode enviar SMS
                    {

/*                          sprintf( szAux,"SMS ENVIADO - idAtdProtocolo [%s] DDD [%s] linha [%s] - MSG [%s]"
                                      ,(const char*)lstDadoOraIdAtendimentoProtocolo.arr
                                      ,(const char*)lstDadoOraCdAreaRegistro.arr
                                      ,(const char*)lstDadoOraNrLinha.arr
                                      ,(const char*)lstDadoOraDsMensagemEnvio.arr );
                        oLog.logDebug(szAux); 
 */                    }
                }
                else
                {
                    memset( MsgLinhaFixa, 0x0, sizeof(MsgLinhaFixa) );
                    sprintf( MsgLinhaFixa, "Linha inválida para o envio de SMS: (%s) %.4s-%.4s", (const char*)ddd, (const char*)linha, (const char*)&linha[4] );
                    strcpy( (char*)lstDadoOraDsMotivoNaoEnvio.arr,
                        MsgLinhaFixa );
                    lstDadoOraDsMotivoNaoEnvio.len =
                        strlen((char*)lstDadoOraDsMotivoNaoEnvio.arr);
                    lstStatOraDsMotivoNaoEnvio = 1;

/*                      sprintf( szAux,">>> SMS NÃO ENVIADO - idAtdProtocolo=[%s] DDD=[%s] linha=[%s] "
                                  ,(const char*)lstDadoOraIdAtendimentoProtocolo.arr
                                  ,(const char*)lstDadoOraCdAreaRegistro.arr
                                  ,(const char*)lstDadoOraNrLinha.arr);
                    oLog.logDebug(szAux);
 */                }
            }
            else
            {
                memset( MsgLinhaFixa, 0x0, sizeof(MsgLinhaFixa) );
                sprintf( MsgLinhaFixa, "Linha inválida para o envio de SMS: (%s) %.4s-%.4s", (const char*)ddd, (const char*)linha, (const char*)&linha[4] );
                strcpy( (char*)lstDadoOraDsMotivoNaoEnvio.arr,
                    MsgLinhaFixa );
                lstDadoOraDsMotivoNaoEnvio.len =
                    strlen((char*)lstDadoOraDsMotivoNaoEnvio.arr);
                lstStatOraDsMotivoNaoEnvio = 1;

/*                  sprintf( szAux,"SMS NÃO ENVIADO - idAtdProtocolo=[%s] DDD=[%s] linha=[%s] "
                              ,(const char*)lstDadoOraIdAtendimentoProtocolo.arr
                              ,(const char*)lstDadoOraCdAreaRegistro.arr
                              ,(const char*)lstDadoOraNrLinha.arr);
                oLog.logDebug(szAux);
 */            }

        }
        else
        {
            strcpy((char*)lstDadoOraDsMotivoNaoEnvio.arr,
                "SMS não enviado para este protocolo pois todas folhas "
                                    "de contato foram configuradas com INSMS=0");
            lstDadoOraDsMotivoNaoEnvio.len =
                strlen((char*)lstDadoOraDsMotivoNaoEnvio.arr);
            lstStatOraDsMotivoNaoEnvio = 1;

/*              sprintf( szAux,"SMS NÃO ENVIADO - idAtdProtocolo=[%s] DDD=[%s] linha=[%s] "
                          ,(const char*)lstDadoOraIdAtendimentoProtocolo.arr
                          ,(const char*)lstDadoOraCdAreaRegistro.arr
                          ,(const char*)lstDadoOraNrLinha.arr);
            oLog.logDebug(szAux);
 */
        }

        EXEC SQL 
        INSERT INTO ATENDIMENTO.FILASMSPROTOCOLOHIST
            (
                IDATENDIMENTOPROTOCOLO,
                CDAREAREGISTRO,
                NRLINHA,
                DSMENSAGEMENVIO,
                DSMOTIVONAOENVIO,
                DTULTIMAALTERACAO,
                IDUSUARIOALTERACAO,
                TPENVIO ,
                INENVIOSMS
            )
            VALUES
            (
                :lstDadoOraIdAtendimentoProtocolo:lstStatOraIdAtendimentoProtocolo,
                :lstDadoOraCdAreaRegistro:lstStatOraCdAreaRegistro,
                :lstDadoOraNrLinha:lstStatOraNrLinha,
                :lstDadoOraDsMensagemEnvio:lstStatOraDsMensagemEnvio,
                :lstDadoOraDsMotivoNaoEnvio:lstStatOraDsMotivoNaoEnvio,
                SYSTIMESTAMP,
                :idUsuarioAlteracao:i_idUsuarioAlteracao ,
                :lstDadoOraTpEnvio:lstStatOraTpEnvio ,
                :lstDadoOraInEnvioSMS:lstStatOraInEnvioSMS
            );

            EXEC SQL
            DELETE
                ATENDIMENTO.FILASMSPROTOCOLO
            WHERE
                ROWID = :lstRowId;

                EXEC SQL COMMIT;

    } // for(;;)
    
    EXEC SQL CLOSE cProtocolos;

    EXEC SQL COMMIT;   // Caso alguma pendencia transacional
    
/*     EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL DELETE FROM ATENDIMENTO.CONTROLEFILASMS WHERE IDCONTROLEFILASMS = :idCtlFilaSMS ;
    EXEC SQL COMMIT; */
    
    sprintf(szAux, "===> Removido Lote de Controle [%s] <===", idCtlFilaSMS ); oLog.logDebug(szAux);
    sprintf(szAux, "===> [%d] Registros Removidos <===", linhas_processadas ); oLog.logDebug(szAux);
    
    endTime = getRealTime();   // Finaliza Cronometro de Operacao
    ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS.FFFF em UsedTime - Tempo Gasto 
    
    sprintf( szAux, "### [ProcessaRegistroSMS()] Tempo de execucao: %s", UsedTime ); oLog.logDebug(szAux);

    
    oLog.logDebug("<<< ProcessaRegistroSMS");

    return 0;

    sqlError:
        sprintf(szAux, "Finalizando processo com erro ORACLE (%d-%.256s)",
                    sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);

        endTime = getRealTime();   // Finaliza Cronometro de Operacao
        ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS.FFFF em UsedTime - Tempo Gasto 
        
        sprintf( szAux, "### [ProcessaRegistroSMS()] Tempo de execucao: %s", UsedTime ); oLog.logDebug(szAux);
        oLog.logDebug("<<< ProcessaRegistroSMS");

        return -1;
}



/**
 * Returns the real time, in seconds, or -1.0 if an error occurred.
 *
 * Time is measured since an arbitrary and OS-dependent start time.
 * The returned real time is only useful for computing an elapsed time
 * between two calls to this function.
 */
double getRealTime(void)
{
    /* AIX, BSD, Cygwin, HP-UX, Linux, OSX, POSIX, Solaris. ----- */
    struct timeval tm;
    gettimeofday( &tm, NULL );
    return (double)tm.tv_sec + (double)tm.tv_usec / 1000000.0;
}


/*
 *   Retorna Tempo Usado
 *   StartTime - Tempo Inicial
 *   EndTime - Tempo Final
 *   UsedTime - Tempo Gasto
 */
void ElapsedTime(double StartTime, double EndTime, char * UsedTime)
{
    int hora, minuto, segundo;

    char Tempo[16];
    char Segundos[8];
    char Miliseg[4];
    char * Result = NULL;

    sprintf ( Tempo, "%lf.", (EndTime - StartTime) );
    Result = strtok(Tempo,".");
    sprintf(Segundos,"%s", Result);
    //printf("Segundos [%s]\n",Segundos);
    Result = strtok(NULL,".");
    sprintf(Miliseg, "%.4s", Result);
    //printf("Miliseg [%s]\n",Miliseg);

    hora = (atoi(Segundos)/3600);
    minuto = (atoi(Segundos)-(3600*hora))/60;
    segundo = (atoi(Segundos)-(3600*hora)-(minuto*60));
    sprintf( UsedTime, "%02d:%02d:%02d.%s", hora, minuto, segundo, Miliseg );

}



int ProcessaRegistroEmail( char * idControle )
{
    long regcount=0;
    long enviados=0;
    long erroenvio=0;
    long insmszero=0;
    char szDsValorParametro[256];
    char szDsMsg[2048];
    char szDtAtual[64];
    long iIdAtendimentoProtocolo;
    
    char buffer[256];
    char email[256];
    char idProtocolo[256];
    
    EXEC SQL BEGIN DECLARE SECTION;
        
        char * idCtlFilaSMS = idControle ;
        
        VARCHAR IDATENDIMENTOPROTOCOLO[256];
        short i_IDATENDIMENTOPROTOCOLO;
        VARCHAR CDAREAREGISTRO[3];
        short i_CDAREAREGISTRO;
        VARCHAR NRLINHA[16];
        short i_NRLINHA;
        VARCHAR DSMENSAGEMENVIO[1001];
        short iDSMENSAGEMENVIO=0;
        VARCHAR DTULTIMAALTERACAO[64];
        short i_DTULTIMAALTERACAO;
        VARCHAR IDUSUARIOALTERACAO[256];
        short i_IDUSUARIOALTERACAO;
        VARCHAR IDATENDIMENTOPROTOCOLOFILHO[256];
        short iIDATENDIMENTOPROTOCOLOFILHO=0;
        VARCHAR TPENVIO[3];
        short i_TPENVIO;
        VARCHAR DSEMAIL[256];
        short iDSEMAIL=0;
        VARCHAR RID[256];
        VARCHAR INSMS[8];
        short i_INSMS;
        VARCHAR DSMOTIVONAOENVIO[256];
        short i_DSMOTIVONAOENVIO=-1;
        VARCHAR EMAIL_INVALIDO[256];
        short i_EMAIL_INVALIDO = -1;
        VARCHAR DSVALORPARAMETRO[256];
        short iDSVALORPARAMETRO=0;
        VARCHAR DTATUAL[256];
        short i_DTATUAL;
        
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR GOTO ERRSQL;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    memset( &DSMOTIVONAOENVIO , 0x0, sizeof(DSMOTIVONAOENVIO) );
    EXEC SQL
    SELECT
        'E-mail não enviado para este protocolo pois todas folhas de contato foram configuradas com INSMS=0.'
    INTO
        :DSMOTIVONAOENVIO
    FROM
        DUAL;

    endOraStr( DSMOTIVONAOENVIO );

    memset( &EMAIL_INVALIDO , 0x0, sizeof(EMAIL_INVALIDO) );
    EXEC SQL
    SELECT
        'E-mail inválido.'
    INTO
        :EMAIL_INVALIDO
    FROM
        DUAL;
    endOraStr( EMAIL_INVALIDO );

    EXEC SQL 
    DECLARE cEnviarEmailProtocolo CURSOR FOR
    SELECT 
      FILASMSPROTOCOLO.IDATENDIMENTOPROTOCOLO,
      FILASMSPROTOCOLO.CDAREAREGISTRO,
      FILASMSPROTOCOLO.NRLINHA,
      (
        case when (length(FILASMSPROTOCOLO.DSMENSAGEMENVIO) + 69 <= 140) then
          FILASMSPROTOCOLO.DSMENSAGEMENVIO || '. ' || NVL(COMPLEMENTOSMS.DSCOMPLEMENTO, 'Fale conosco tambem pelo vivo.com.br/meuvivo ou envie SMS para 1058')
        else
          FILASMSPROTOCOLO.DSMENSAGEMENVIO || '.'
        end
      )
      AS DSMENSAGEMENVIO,
      TO_CHAR(FILASMSPROTOCOLO.DTULTIMAALTERACAO,'DD/MM/RRRR HH24:MI:SS.FF') as DTULTIMAALTERACAO,
      FILASMSPROTOCOLO.IDUSUARIOALTERACAO,
      FILASMSPROTOCOLO.IDATENDIMENTOPROTOCOLOFILHO,
      FILASMSPROTOCOLO.TPENVIO,
      FILASMSPROTOCOLO.INENVIOSMS,
      FILASMSPROTOCOLO.DSEMAIL,
      FILASMSPROTOCOLO.ROWID AS RID
    FROM
      ATENDIMENTO.FILASMSPROTOCOLO FILASMSPROTOCOLO,
      ATENDIMENTO.COMPLEMENTOSMS COMPLEMENTOSMS
    WHERE
        FILASMSPROTOCOLO.TPENVIO = 2
    AND FILASMSPROTOCOLO.CDAREAREGISTRO = COMPLEMENTOSMS.CDAREAREGISTRO (+)
    AND FILASMSPROTOCOLO.IDTIPOLINHA = COMPLEMENTOSMS.IDTIPOLINHA (+)
    AND FILASMSPROTOCOLO.SGTIPOPESSOA = COMPLEMENTOSMS.SGTIPOPESSOA (+)
    AND FILASMSPROTOCOLO.SGUF = COMPLEMENTOSMS.SGUF (+)
    /* AND NVL(COMPLEMENTOSMS.STATUS,1) = 1 */
    AND FILASMSPROTOCOLO.IDCONTROLEFILASMS = :idCtlFilaSMS ;

    EXEC SQL OPEN cEnviarEmailProtocolo;

    for ( ;; ) 
    {
        memset( &IDATENDIMENTOPROTOCOLO     , 0x0, sizeof(IDATENDIMENTOPROTOCOLO) );
        memset( &IDATENDIMENTOPROTOCOLOFILHO, 0x0, sizeof(IDATENDIMENTOPROTOCOLOFILHO) );
        memset( &CDAREAREGISTRO             , 0x0, sizeof(CDAREAREGISTRO) );
        memset( &NRLINHA                    , 0x0, sizeof(NRLINHA) );
        memset( &DSMENSAGEMENVIO            , 0x0, sizeof(DSMENSAGEMENVIO) );
        memset( &DTULTIMAALTERACAO          , 0x0, sizeof(DTULTIMAALTERACAO) );
        memset( &DSEMAIL                    , 0x0, sizeof(DSEMAIL) );
        memset( &RID                        , 0x0, sizeof(RID) );
        memset( &IDUSUARIOALTERACAO         , 0x0, sizeof(IDUSUARIOALTERACAO) );
        memset( &TPENVIO                    , 0x0, sizeof(TPENVIO) );
        memset( &INSMS                      , 0x0, sizeof(INSMS) );
        memset( &szDsMsg                    , 0x0, sizeof(szDsMsg));
      
        
        EXEC SQL WHENEVER NOT FOUND DO BREAK;
        EXEC SQL FETCH cEnviarEmailProtocolo
            INTO :IDATENDIMENTOPROTOCOLO:i_IDATENDIMENTOPROTOCOLO,
                 :CDAREAREGISTRO:i_CDAREAREGISTRO,
                 :NRLINHA:i_NRLINHA,
                 :DSMENSAGEMENVIO:iDSMENSAGEMENVIO,
                 :DTULTIMAALTERACAO:i_DTULTIMAALTERACAO,
                 :IDUSUARIOALTERACAO:i_IDUSUARIOALTERACAO,
                 :IDATENDIMENTOPROTOCOLOFILHO:iIDATENDIMENTOPROTOCOLOFILHO,
                 :TPENVIO:i_TPENVIO ,
                 :INSMS:i_INSMS,
                 :DSEMAIL:iDSEMAIL,
                 :RID ;

        regcount++;

        endOraStr( IDUSUARIOALTERACAO );
        endOraStr( IDATENDIMENTOPROTOCOLO );
        endOraStr( IDATENDIMENTOPROTOCOLOFILHO );
        endOraStr( CDAREAREGISTRO );
        endOraStr( NRLINHA );
        endOraStr( DSMENSAGEMENVIO );
        endOraStr( DSEMAIL );
        endOraStr( DTULTIMAALTERACAO );
        endOraStr( TPENVIO );
        endOraStr( INSMS );
        endOraStr( RID );

        sprintf( email, "%s", (char*)DSEMAIL.arr );
        if ( EmailValido(email) )   // Valida se eh um endereco de email valido
        {
            sprintf( buffer, "%s", (char*)INSMS.arr );
            if ( atoi(buffer) == 1 )
            {
                memset( &DSVALORPARAMETRO , 0x0, sizeof(DSVALORPARAMETRO) );
                memset( &DTATUAL          , 0x0, sizeof(DTATUAL) );

                //log() << "Processando registros em ATENDIMENTO.ATENDIMENTOPROTOCOLO..." << endl;
                EXEC SQL WHENEVER NOT FOUND CONTINUE;
                EXEC SQL
                select dsvalorparametro, dtatual
                into   :DSVALORPARAMETRO:iDSVALORPARAMETRO, :DTATUAL
                from
                      (select parm.dsvalorparametro,
                              to_char(ap.dtabertura,'dd/mm/rrrr')||' as '||to_char(ap.dtabertura,'hh24:mi') as dtatual
                       from apoio.parametro parm,
                            atendimento.atendimentoprotocolo ap
                       where ap.idatendimentoprotocolo = :IDATENDIMENTOPROTOCOLO
                       and (((upper(ap.cdorigem) ='MOVEL' or upper(ap.cdorigem) IS NULL) and ap.idlinhatelefonica IS NULL) or (upper(ap.cdorigem) ='FIXO'))
                       and parm.cdparametro = (case
                                            when (upper(ap.cdorigem) ='MOVEL' or upper(ap.cdorigem) IS NULL) and ap.idlinhatelefonica IS NULL THEN 'MSG_PROT_MOVEL_PROS'
                                            when (upper(ap.cdorigem) ='FIXO') and ap.idlinhatelefonica IS NOT NULL THEN 'MSG_PROT_FIXA_CLIE'
                                            else 'MSG_PROT_FIXA_PROS'
                                            end));

                endOraStr( DSVALORPARAMETRO );
                endOraStr( DTATUAL );
                

                if (sqlca.sqlcode == NO_DATA_FOUND)
                {
                    STRCPY_FROM_ORA(szDsMsg, DSMENSAGEMENVIO);
                        //log() << "DSMENSAGEMENVIO= [" << szDsMsg << "]" << endl;
                }
                else
                {
                    STRCPY_FROM_ORA(szDsValorParametro, DSVALORPARAMETRO);
                    STRCPY_FROM_ORA(szDtAtual, DTATUAL);
                    sprintf( buffer, "%s", (char*)IDATENDIMENTOPROTOCOLO.arr );
                    sprintf(szDsMsg, szDsValorParametro, atol(buffer), szDtAtual);
                    //log() << "szDsMsg= [" << szDsMsg << "]" << endl;
                }

/*
                stringstream xml;
                xml << "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>";
                xml << "<msg><msgHdr><user>1</user><service>SMTPSEND</service></msgHdr><msgBody>";
                xml << "<from>" << EMAIL_FROM << "</from>";
                xml << "<to>" << (char*)DSEMAIL.arr << "</to>";
                xml << "<subject>" << EMAIL_SUBJECT << "</subject>";
                xml << "<data>" << szDsMsg << "</data>";
                xml << "</msgBody></msg>";

                char *sendbuf=0;
                char *rcvbuf=0;
                long sendlen=xml.str().size();
                long rcvlen=0;

                if((sendbuf = (char *) tpalloc("STRING", NULL, sendlen+1)) == NULL) {
                    log() << "Error allocating send buffer: tpalloc" << endl;
                    //tpterm();
                    erroenvio++;
                    continue;
                }

                if((rcvbuf = (char *) tpalloc("STRING", NULL, sendlen+1)) == NULL) {
                    log() << "Error allocating receive buffer: tpalloc" << endl;
                    tpfree(sendbuf);
                    //tpterm();
                    erroenvio++;
                    continue;
                }

                //log() << "sendbuf[" << xml.str() << "]" << endl;

                strcpy(sendbuf, xml.str().c_str());

                if(tpcall((char*)EMAIL_SERVICO, (char*)sendbuf, sendlen, (char**)&rcvbuf, &rcvlen, (long)0) == -1)
                {
                    log() << "Tpcall = " << EMAIL_SERVICO << endl;
                    log() << "Tperrno = " << tperrno << endl;
                    log() << "rcvbuf[" << rcvbuf << "]" << endl;
                    tpfree(sendbuf);
                    tpfree(rcvbuf);
                    erroenvio++;
                    continue;
                }

                string retMsg(rcvbuf);
                tpfree(sendbuf);
                tpfree(rcvbuf);

                regmatch_t pmatch[this->nmatch];
                int r = regexec(&this->regex, retMsg.c_str(), (size_t)this->nmatch, pmatch, 0);
                if( !r ) {
                    string statusCode = retMsg.substr(pmatch[1].rm_so, (pmatch[1].rm_eo - pmatch[1].rm_so));
                    string statusText = retMsg.substr(pmatch[2].rm_so, (pmatch[2].rm_eo - pmatch[2].rm_so));

                    if (statusCode.size() > 2 && statusCode[2] == 'I') {
                        log() << "Sucesso: IDATENDIMENTOPROTOCOLO = [" << (char*)IDATENDIMENTOPROTOCOLO.arr << "], statusCode = [" << statusCode << "], statusText = [" << statusText << "]" << endl;
                        enviados++;
                    } else {
                            //  log() << "ERRO: IDATENDIMENTOPROTOCOLO = [" << (char*)IDATENDIMENTOPROTOCOLO.arr << "], statusCode = [" << statusCode << "], statusText = [" << statusText << "]" << endl;
                            log() << "*** ERRO: IDATENDIMENTOPROTOCOLO = [" << (char*)IDATENDIMENTOPROTOCOLO.arr << "], VERIFIQUE E-MAIL ["  << email << "]" << endl;
                        erroenvio++;

                            EXEC SQL SELECT '-11' INTO :INSMS FROM DUAL;
                            endOraStr( INSMS );
                    }
                }
                else if( r == REG_NOMATCH ) {
                    log() << "ERRO: IDATENDIMENTOPROTOCOLO = [" << (char*)IDATENDIMENTOPROTOCOLO.arr << "] - statusCode/statusText nao encontrado!" << endl;
                    log() << "ERRO: rcvbuf[" << retMsg << "]" << endl;
                    erroenvio++;
                    continue;
                }
                else {
                        char msgbuf[256];
                        regerror(r, &regex, msgbuf, sizeof(msgbuf));
                        log() << "ERRO: IDATENDIMENTOPROTOCOLO = [" << (char*)IDATENDIMENTOPROTOCOLO.arr << "], regexec - Regex match failed: " << msgbuf << endl;
                        log() << "ERRO: rcvbuf[" << retMsg << "]" << endl;
                        erroenvio++;
                        continue;
                }
*/                
            }
            else 
            {
                //log() << "Nao enviado: IDATENDIMENTOPROTOCOLO = [" << (char*)IDATENDIMENTOPROTOCOLO.arr << "], INSMS=0" << endl;
                insmszero++;
            }
        }
        else   /*   e-mail invalido   */
        {
//            log() << "*** ERRO: IDATENDIMENTOPROTOCOLO = [" << (char*)IDATENDIMENTOPROTOCOLO.arr << "], EMAIL DESTINO INVALIDO [" << email << "]" << endl;
            erroenvio++;
            EXEC SQL SELECT '-11' INTO :INSMS FROM DUAL;
            endOraStr( INSMS );
        }

HIST:
        EXEC SQL
        INSERT INTO ATENDIMENTO.FILASMSPROTOCOLOHIST 
        (
            IDATENDIMENTOPROTOCOLO,
            CDAREAREGISTRO,
            NRLINHA,
            DSMENSAGEMENVIO,
            DSMOTIVONAOENVIO,
            DTULTIMAALTERACAO,
            IDUSUARIOALTERACAO,
            IDATENDIMENTOPROTOCOLOFILHO,
            TPENVIO,
            DSEMAIL
        ) 
        VALUES 
        (
            :IDATENDIMENTOPROTOCOLO,
            :CDAREAREGISTRO,
            :NRLINHA,
            :DSMENSAGEMENVIO:iDSMENSAGEMENVIO,
            DECODE(:INSMS, 0, :DSMOTIVONAOENVIO, -11, :EMAIL_INVALIDO, NULL),
            TO_TIMESTAMP(:DTULTIMAALTERACAO,'DD/MM/RRRR HH24:MI:SS.FF'),
            :IDUSUARIOALTERACAO,
            :IDATENDIMENTOPROTOCOLOFILHO:iIDATENDIMENTOPROTOCOLOFILHO,
            :TPENVIO,
            :DSEMAIL:iDSEMAIL
        );

        EXEC SQL
        DELETE FROM ATENDIMENTO.FILASMSPROTOCOLO
        WHERE ROWID = :RID;

        EXEC SQL COMMIT;
    }

    EXEC SQL CLOSE cEnviarEmailProtocolo;
    EXEC SQL COMMIT;

/*     EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL DELETE FROM ATENDIMENTO.CONTROLEFILASMS WHERE IDCONTROLEFILASMS = :idCtlFilaSMS ;
    EXEC SQL COMMIT; */

/*     log() << "Selecionado(s) " << regcount << " registro(s) em ATENDIMENTO.FILASMSPROTOCOLO." << endl;

    if (insmszero)
        log() << "Nao enviado(s) " << insmszero << " por INSMS=0." << endl;

    if (enviados)
        log() << "Enviado(s) " << enviados << " via SMTPSEND." << endl;

    if (erroenvio)
        log() << "Nao enviado(s) " << erroenvio << " por erro em SMTPSEND!" << endl;
 */
    return 0;
    ERRSQL:
//        log() << "ERRO ORACLE: sqlcode=" << sqlca.sqlcode << ", sqlerrmc=" << sqlca.sqlerrm.sqlerrmc << endl;
//        log() << "Executando ROLLBACK!" << endl;
        EXEC SQL ROLLBACK;
        return -1;
}



bool EmailValido( char * email )
{
   int i;
   int k;
   int len;
   int len_invalid;
   int isValid;
   char invalidos[50];
   
   sprintf( invalidos, "%s", "\"\';:,<>[]{}/\\+=çÇ&%$#()#!*ãÃáÁéÉíÍóÓúÚàÁôÔêÊ| " );
   
   len = strlen( email );
   len_invalid = strlen(invalidos);
   
   if ( len < 5 )  /* ".com" -> por isso da comparacao menor que 5, um email assim eh invalido */
   {
       return false;
   }
   
   if ( !strcmp( email, "www.") )
   {
       return false;
   }
   
   if ( !strcmp( email, "WWW.") )
   {
       return false;
   }

   for ( isValid = i = 0; i < len; i++ )
   {
      for ( k = 0; k < len_invalid ; k++ )
      {
          if ( email[i] == invalidos[k] )
          {
             return false;
          }
      }
      if ( email[i] == '@' )
      {
          isValid++;
      }

   }
   
   if ( isValid > 0 )
      return true;
   else
      return false;
}
