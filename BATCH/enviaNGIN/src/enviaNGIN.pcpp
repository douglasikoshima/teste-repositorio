#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iostream.h>
#include <unistd.h>
#include <ctype.h>
#include <dirent.h>
//#include <time.h>

//#include <iostream.h>
//#include <sys/types.h>
//#include <unistd.h>

#include <enviaNGIN.h>
//#include <tuxfw.h>

#include <sys/ipc.h>
#include <sys/shm.h>

#include "../../commons/Propriedade/include/MFile.h"
#include "../../commons/Log/include/Log.h"
#include "../../commons/SplitLine.h"
#include "../../commons/Defines.h"

extern errno;

EXEC SQL INCLUDE SQLCA;

char szAux[4096 + 1];
Log oLog;
int iSignalProcessa=1;
char szDataHoraGlobal[19 + 1];
char szErrorOut[255 + 1];
int shmid;
key_t key;
char *shm=0;
bool isConnected = false;
long iErrorNumber=0;
#define SAFE_STRNCPY(dst,src) strncpy(dst,src?src:"",sizeof(dst)-1);dst[sizeof(dst)-1]=0;

#ifdef WIN32
#define MKDIR _mkdir
#define ACCESS _access
#else
#define MKDIR mkdir
#define ACCESS access
#endif


//TDadosDocumento *gptDadosDocumento;
#define MAXDOCS 200
TDadosDocumento gptDadosDocumento[MAXDOCS];
int parentPPID;
static int tempoSleep=0;
bool bOutraInstanciaNoAr=false;

#define CONVIND(O,I) \
{ \
	if (I == -1) { \
		##O.arr[0]=0; \
	} else { \
		##O.arr[##O.len]=0; \
	} \
}

// controle de alocacao de memoria
//int giQtdElementosAlocados;
//int giQtdElementosObtidos;

int main(int argc, char* argv[])
{
    try
    {
        // Acertando o nivel de logs
        oLog.setNivel(2);
        oLog.logDebug(">>>enviaNGIN\n");

        //parentPPID = getppid();
        //sprintf(szAux,"parentPPID=%d\n",parentPPID);
        //oLog.logDebug(szAux);

        char *pArquivoEntrada=NULL;
        char *pPointer;
        char *pszNrLinha=NULL;
        char szAuxNGIN[256 + 1];
        char szFileName[256];
        char szIdLinhaTelefonica[38 + 1];
        char szXmlRender[2000 + 1];
        char szXmlTmp[2000 + 1];

        FILE *pFileIn=0;
        FILE *pFileOut=0;

        int iCountLogradouro=0;
        int iFlagIE=0;
        int iQtdRegistros=0;

        //@cassio TDadosDocumento *ptDadosDocumento=NULL;
        TObtemDadosXml tObtemDadosXml;
        TParamConf tParamConf;

        /* De para de tipo de logradouros para o NGIN */
        char *pszTipoLogNGIN[] = {
            "ACS", "AL", "AV", "BC", "ESTR", "GLR", "JD", "LAD", "LGO", "PAS","PCA",
            "PRA", "PQ", "PTE", "R", "ROD", "TRAV", "TRV", "V", "VD", "VIA", "VL"
        };
        char *pszTipoLogFO[] = {
            "ACESSO", "ALAMEDA", "AVENIDA", "BECO", "ESTRADA", "GALERIA", "JARDIM",
            "LADEIRA", "LARGO", "PASSAGEM", "PRACA", "PRAIA", "PARQUE", "PONTE",
            "RUA", "RODOVIA", "TRAVESSA", "TREVO", "VALE", "VIADUTO", "VIA", "VIELA", NULL
        };

        EXEC SQL BEGIN DECLARE SECTION;
            VARCHAR oszIdFilaSetClientInfo[21];
            int linhas_retornadas = 0;

            VARCHAR varOraIdFilaPreEnvioSetCliInfo[500][39];
            VARCHAR varOraNrTelefone[500][14];
            VARCHAR varOraIdPessoaEndereco[500][39];

            short statOraIdFilaPreEnvioSetCliInfo[500];
            short statOraNrTelefone[500];
            short statOraIdPessoaEndereco[500];
        EXEC SQL END DECLARE SECTION;

        //============================================================================================
        //declare act to deal with action on signal set.
        static struct sigaction act;

        //setting to my function catcher
        act.sa_handler = catcher;       
        act.sa_flags    = 0;

        sigfillset(&(act.sa_mask)); //create full set of signals

        sigaction(SIGHUP , &act, NULL);
        sigaction(SIGIOT , &act, NULL);
        sigaction(SIGEMT , &act, NULL);
        sigaction(SIGFPE , &act, NULL);
        sigaction(SIGBUS , &act, NULL);
        sigaction(SIGSEGV, &act, NULL);
        sigaction(SIGSYS , &act, NULL);
        sigaction(SIGSTOP, &act, NULL);
        sigaction(SIGCHLD, &act, NULL);
        sigaction(SIGKILL, &act, NULL);
        sigaction(SIGINT , &act, NULL);
        sigaction(SIGQUIT, &act, NULL);
        sigaction(SIGTRAP, &act, NULL);
        sigaction(SIGTERM, &act, NULL);
        sigaction(SIGTSTP, &act, NULL);
        //sigaction(SIGALRM, &act, NULL);

        //============================================================================================

        /*ArmaSinal(SIGHUP);
        ArmaSinal(SIGINT);
        ArmaSinal(SIGQUIT);
        ArmaSinal(SIGTRAP);
        ArmaSinal(SIGIOT);
        ArmaSinal(SIGSEGV);
        ArmaSinal(SIGTERM);
        ArmaSinal(SIGTSTP);*/

        /* Obtem a data e hora atual e armazena em variavel global */
        strcpy(szDataHoraGlobal, ObtemDataHora());

        if(ObtemParamConf(&tParamConf))
        {
            sinalizaFinalProcesso();
            oLog.logError("Erro obtendo parametros de configuracao\n");
            fflush(stdout);
            return -1;
        }

        oLog.logDebug("Conectando na BD...");
        if (DBConnect(tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst))
        {
            sinalizaFinalProcesso();
            oLog.logError("Erro conectando no banco de dados\n");
            fflush(stdout);
            return -1;
        }
        oLog.logDebug("Conectado na BD com sucesso...\n");

        const char *argvGlobal = argv[0];
        if ( processoEmExecucaoSN(argvGlobal) == true )
        {
            bOutraInstanciaNoAr = true;
            oLog.logDebug("***** Já existe outra instância deste processo no ar. *****\n");

            char *pForceExecEnviaNGIN = ObtemParametro("FORCE_EXEC_ENVIANGIN");

            if ( toupper(*pForceExecEnviaNGIN) == 'N' )
            {
                DBDisconnect();
                oLog.logDebug("Processamento encerrado.\n");
                oLog.logDebug("<<<enviaNGIN\n");
                fflush(stdout);
                return -1;
            }
        }

        EXEC SQL WHENEVER SQLERROR GOTO sqlError;

        //==================================================================================
        // OS 1093 - Gera lista de outras linhas da pessoa recém cadastrada/alterada

        EXEC SQL WHENEVER NOT FOUND CONTINUE;
 
        bool toAbort=false;

        while (!toAbort)
        {
            char *p = ObtemParametro("TEMPO_WAIT_ENVIANGIN");
            tempoSleep = atoi(p==0?"60":p);
            sprintf(szAux,"tempo sleep(1)=%d\n",tempoSleep); oLog.logDebug(szAux);

            int itMax = 0;
            int arquivosAdicionais=0;

            do
            {
                /* tratamento para interromper o processamento via sinal */
                if(iSignalProcessa == 0)
                {
                    //oLog.logDebug("Tratamento de sinal de termino dentro do loop 0\n");
                    toAbort=true;
                    continue;
                }

                itMax++;

                oLog.logDebug("Verificando se existem arquivos de linhas adicionais de pré-pago...\n");

                EXEC SQL DECLARE curEnviaLegadoPP CURSOR FOR 
                    SELECT
                        IDFILAPREENVIOSETCLIINFO,
                        NRTELEFONE,
                        IDPESSOAENDERECO
                    FROM
                    (
                        SELECT DISTINCT
                            FILAPREENVIOSETCLIINFO.IDFILAPREENVIOSETCLIINFO,
                            AREAREGISTRO.CDAREAREGISTRO||FILAPREENVIOSETCLIINFO.NRLINHA AS NRTELEFONE,
                            FILAPREENVIOSETCLIINFO.IDPESSOAENDERECO
                        FROM
                            CUSTOMER.PESSOALINHA PESSOALINHA,
                            CUSTOMER.PESSOAENDERECO PESSOAENDERECO,
                            CUSTOMER.PESSOADEPARA PESSOADEPARA,
                            INFRA.FILAPREENVIOSETCLIINFO FILAPREENVIOSETCLIINFO,
                            LINHA.LINHATELEFONICA LINHATELEFONICA,
                            LINHA.LINHABASE LINHABASE,
                            APOIO.TIPOLINHA TIPOLINHA,
                            APOIO.AREAREGISTRO AREAREGISTRO
                        WHERE
                            FILAPREENVIOSETCLIINFO.IDPESSOAENDERECO = PESSOAENDERECO.IDPESSOAENDERECO
                        AND PESSOAENDERECO.IDPESSOA = PESSOADEPARA.IDPESSOA
                        AND PESSOADEPARA.IDPESSOADEPARA = PESSOALINHA.IDPESSOADEPARA
                        AND PESSOALINHA.IDTIPORELACIONAMENTO = 2
                        AND PESSOALINHA.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
                        AND LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
                        AND LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
                        AND LINHATELEFONICA.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
                        AND FILAPREENVIOSETCLIINFO.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
                        AND TIPOLINHA.IDCLASSIFICACAOTIPOLINHA = 'PRE'
                        AND NOT EXISTS ( SELECT * 
                                           FROM INFRA.FILAPREENVIOSETCLIINFO FPP 
                                          WHERE FPP.IDAREAREGISTRO = LINHABASE.IDAREAREGISTRO
                                            AND FPP.NRLINHA = LINHABASE.NRLINHA
                                        )
                        --//ORDER BY
                        --//    PESSOADEPARA.IDPESSOADEPARA,PESSOAENDERECO.DTULTIMAALTERACAO
                    )
                    WHERE ROWNUM < 501;

                EXEC SQL OPEN curenviaLegadoPP;

                memset(&varOraIdFilaPreEnvioSetCliInfo,0,sizeof(varOraIdFilaPreEnvioSetCliInfo));
                memset(&varOraNrTelefone,0,sizeof(varOraNrTelefone));
                memset(&varOraIdPessoaEndereco,0,sizeof(varOraIdPessoaEndereco));

                memset(statOraIdFilaPreEnvioSetCliInfo,-1,sizeof(statOraIdFilaPreEnvioSetCliInfo));
                memset(statOraNrTelefone,-1,sizeof(statOraNrTelefone));
                memset(statOraIdPessoaEndereco,-1,sizeof(statOraIdPessoaEndereco));

                EXEC SQL FOR 500 FETCH curenviaLegadoPP INTO 
                        :varOraIdFilaPreEnvioSetCliInfo:statOraIdFilaPreEnvioSetCliInfo,
                        :varOraNrTelefone:statOraNrTelefone,
                        :varOraIdPessoaEndereco:statOraIdPessoaEndereco;

                linhas_retornadas = sqlca.sqlerrd[2];
                sprintf(szAux,"linhas retornadas=%d\n",linhas_retornadas); oLog.logDebug(szAux);

                EXEC SQL CLOSE curenviaLegadoPP;

                if ( linhas_retornadas > 0 )
                {
                    // verifica colisão de nomes
                    int fnct=0;

                    do
                    {
                        if(iSignalProcessa == 0)
                        {
                            //oLog.logDebug("Tratamento de sinal de termino dentro do loop 1\n");
                            toAbort=true;
                            continue;
                        }

                        sprintf(szFileName,"%spre_%s_%03d.txt",tParamConf.szPath,ObtemDataHora(),fnct++);

                    } while ( ACCESS(szFileName,0)==0 );

                    if ( !toAbort )
                    {
                        sprintf(szAux, "Vai processar '%s'...\n", szFileName); oLog.logDebug(szAux);
                        if ( pFileOut = fopen(szFileName,"wt"),!pFileOut )
                        {
                            sprintf(szAux, "Falha '%s' ao abrir arquivo\n",strerror(errno)); oLog.logError(szAux);
                            oLog.logDebug(szAux);
                            fflush(stdout);
                            DBDisconnect();
                            exit(-1);
                        }

                        arquivosAdicionais++;

                        sprintf(szAux, "Gerando dados em '%s'\n", szFileName); oLog.logDebug(szAux);

                        for (int it=0;it<linhas_retornadas;it++)
                        {
                            CONVIND(varOraIdFilaPreEnvioSetCliInfo[it],statOraIdFilaPreEnvioSetCliInfo[it]);
                            CONVIND(varOraNrTelefone[it],statOraNrTelefone[it]);
                            CONVIND(varOraIdPessoaEndereco[it],statOraIdPessoaEndereco[it]);

                            //sprintf(szAux,"%s,%s\n",(char*)varOraNrTelefone[it].arr,(char*)varOraIdPessoaEndereco[it].arr);
                            sprintf(szAux,"%s\n",(char*)varOraNrTelefone[it].arr);
                            fputs(szAux,pFileOut);
                        }

                        EXEC SQL FOR :linhas_retornadas
                        DELETE INFRA.FILAPREENVIOSETCLIINFO
                        WHERE IDFILAPREENVIOSETCLIINFO IN (:varOraIdFilaPreEnvioSetCliInfo);

                        EXEC SQL COMMIT;

                        fclose(pFileOut);
                    } // if ( !toAbort )

                } // if ( linhas_retornadas > 0 )

                if ( 0==linhas_retornadas && !toAbort )
                {
                    sprintf(szAux,"Wait %ds...",tempoSleep);
                    oLog.logDebug(szAux);
                    sleep(tempoSleep);
                }

            } while ( !toAbort );

            /*
            DESATIVADO A PEDIDO TIAGO - 01/02/2010 -- CASSIO

            if ( arquivosAdicionais > 0 && !toAbort )
            {
                sprintf(szAux,"Gerado(s) %d arquivo(s) adicionais de linhas de pré-pago.\n",arquivosAdicionais);
                oLog.logDebug(szAux);
            }

            if ( !toAbort )
            {
                DIR *pDir = OpenDir(tParamConf.szPath);

                while( (pArquivoEntrada = ReadDir(pDir)) != NULL && !toAbort )
                {
                    if(iSignalProcessa == 0)
                    {
                        //oLog.logDebug("Tratamento de sinal de termino dentro do loop 4\n");
                        toAbort=true;
                        continue;
                    }
 
                    if ( pFileIn=abrirArquivo(tParamConf.szPath, pArquivoEntrada),pFileIn==0)
                    {
                        oLog.logDebug("Saindo por erro de I/O.\n");
                        toAbort=true;
                        continue;
                    }

                    iQtdRegistros=0;

                    oLog.logDebug("Gerando XMLs para envio ao NGIN...\n");

                    while( (pszNrLinha = lerArquivo(pFileIn)) != NULL && !toAbort )
                    {
                        if(iSignalProcessa == 0)
                        {
                            //oLog.logDebug("Tratamento de sinal de termino dentro do loop 5\n");
                            toAbort=true;
                            continue;
                        }

                        char szNrTelefone[14];
                        char szIdPessoaEndereco[39];

                        char *p = strstr(pszNrLinha,",");
        
                        if (p)
                        {
                            int x = p-pszNrLinha;

                            memcpy(szNrTelefone,pszNrLinha,x);
                            szNrTelefone[x]=0;

                            strcpy(szIdPessoaEndereco,p+1);
                            //szIdPessoaEndereco[strlen(szIdPessoaEndereco)-1]=0;
                        }
                        else
                        {
                            strcpy(szNrTelefone,pszNrLinha);
                            szIdPessoaEndereco[0] = 0;
                        }

                        if(ObtemIdLinhaTelefonica(szNrTelefone, szIdLinhaTelefonica) == false)
                        {
                            Sumariza(0, 1, NULL, NULL); // Total de registros processados com erro
                            if(geraArquivo(szNrTelefone, "ERROR idLinhaTelefonica nao obtido", tParamConf.szPath, pArquivoEntrada))
                            {
                                oLog.logDebug("Erro no processo de geracao do arquivo de saida");
                                CloseDir(pDir);
                                fflush(stdout);
                                exit(-1);
                            }
                            continue;
                        }

                        if(ObtemDadosXml(szIdLinhaTelefonica,szIdPessoaEndereco,&tObtemDadosXml) == false)
                        {
                            Sumariza(0, 1, NULL, NULL); // Total de registros processados com erro
                            if(geraArquivo(szNrTelefone, "ERROR dados do cliente nao obtidos", tParamConf.szPath, pArquivoEntrada))
                            {
                                oLog.logDebug("Erro no processo de geracao do arquivo de saida");
                                CloseDir(pDir);
                                fflush(stdout);
                                exit(-1);
                            }
                            continue;
                        }

                        sprintf(szXmlRender, 
                            "<msg>"
                            "<ProxyOperacao>setCliente</ProxyOperacao>"
                            "<usuario>FO</usuario>"
                            "<ProxyLinha>%s</ProxyLinha>"
                            "<idCanal>666</idCanal>",
                            szNrTelefone);


                        // esse sprintf cria a primeira parte do xml que serah concatenado
                        if(!memcmp(tObtemDadosXml.szIdTipoPessoa, "2", 1)) // Pessoa Juridica
                        {
                            sprintf(szXmlTmp,
                                "<tipoCliente>%s</tipoCliente>"
                                "<nome>%s</nome>",
                                tObtemDadosXml.szTipoCliente,
                                tObtemDadosXml.szNome);
                        }
                        else // Pessoa Fisica ou nao classificada
                        {
                            sprintf(szXmlTmp,
                                "<tipoCliente>%s</tipoCliente>"
                                "<nome>%s</nome>"
                                "<confidencial>%s</confidencial>"
                                "<dataNascimento>%s</dataNascimento>"
                                "<estadoCivil>%s</estadoCivil>"
                                "<codSexo>%s</codSexo>",
                                tObtemDadosXml.szTipoCliente,
                                tObtemDadosXml.szNome,
                                tObtemDadosXml.szConfidencial,
                                tObtemDadosXml.szDataNascimento,
                                tObtemDadosXml.szEstadoCivil,
                                tObtemDadosXml.szCodSexo);
                        }

                        strcat(szXmlRender, szXmlTmp);

                        sprintf(szAux, "1.szXmlRender[%s]\n", szXmlRender); oLog.logDebug(szAux);
                        // sprintf(szAux, "tObtemDadosXml.szIdTipoPessoa[%s]", tObtemDadosXml.szIdTipoPessoa); oLog.logDebug(szAux);

                        // esse while cria a segunda parte do xml que serah concatenado 
                        //@cassio while((ptDadosDocumento = BuscaDocumentoPorIdPessoa((char *)&tObtemDadosXml.szIdPessoa)) != NULL)
                        int itMax = BuscaDocumentoPorIdPessoa((char*)&tObtemDadosXml.szIdPessoa);

                        for (int it=0;it<itMax;it++)
                        {
                            //sprintf(szAux, " sgTipoDocumento[%s]", gptDadosDocumento[it].szSgTipoDocumento); oLog.logDebug(szAux);
                            //sprintf(szAux, "     nrDocumento[%s]", gptDadosDocumento[it].szNrDocumento); oLog.logDebug(szAux);
                            //sprintf(szAux, "sgOrgaoExpedidor[%s]", gptDadosDocumento[it].szSgOrgaoExpedidor); oLog.logDebug(szAux);

                            if(!memcmp(tObtemDadosXml.szIdTipoPessoa, "1", 1)) // Pessoa Fisica 
                            {
                                if(!strcmp(gptDadosDocumento[it].szSgTipoDocumento, "CPF") ||
                                   !strcmp(gptDadosDocumento[it].szSgTipoDocumento, "FCPF") ||
                                   !strcmp(gptDadosDocumento[it].szSgTipoDocumento, "KLCPF"))
                                {
                                    sprintf(szXmlTmp,
                                        "<CPF>%s</CPF>"
                                        "<tipoCPF>D</tipoCPF>",
                                        gptDadosDocumento[it].szNrDocumento);
                                }
                                else if(!strcmp(gptDadosDocumento[it].szSgTipoDocumento, "RG"))
                                {
                                    sprintf(szXmlTmp,
                                        "<RG>%s</RG>"
                                        "<tipoRG>D</tipoRG>",
                                        gptDadosDocumento[it].szNrDocumento);
                                }
                                else if(!strcmp(gptDadosDocumento[it].szSgTipoDocumento, "PAS"))
                                {
                                    sprintf(szXmlTmp,
                                        "<passaporte>%s</passaporte>"
                                        "<tipoPassaporte>D</tipoPassaporte>",
                                        gptDadosDocumento[it].szNrDocumento);
                                }
                                else
                                {
                                    sprintf(szAux, "PessoaFisica sigla ignorada[%s]", gptDadosDocumento[it].szSgTipoDocumento); oLog.logDebug(szAux);
                                }
                            }
                            else if(!memcmp(tObtemDadosXml.szIdTipoPessoa, "2", 1)) // Pessoa Juridica 
                            {
                                if(!strcmp(gptDadosDocumento[it].szSgTipoDocumento, "CNPJ") ||
                                   !strcmp(gptDadosDocumento[it].szSgTipoDocumento, "OCNPJ") ||
                                   !strcmp(gptDadosDocumento[it].szSgTipoDocumento, "UCNPJ"))
                                {
                                    sprintf(szXmlTmp,
                                        "<CNPJ>%s</CNPJ>",
                                        gptDadosDocumento[it].szNrDocumento);
                                }
                                else if(!strcmp(gptDadosDocumento[it].szSgTipoDocumento, "CNAE"))
                                {
                                    sprintf(szXmlTmp,
                                        "<CNAE>%s</CNAE>",
                                        gptDadosDocumento[it].szNrDocumento);
                                }
                                else if(!strcmp(gptDadosDocumento[it].szSgTipoDocumento, "IE"))
                                {
                                    sprintf(szXmlTmp,
                                        "<IE>%s</IE>",
                                        gptDadosDocumento[it].szNrDocumento);

                                    iFlagIE=1;
                                }
                                else
                                {
                                    sprintf(szAux, "PessoaJuridica sigla ignorada[%s]", gptDadosDocumento[it].szSgTipoDocumento); oLog.logDebug(szAux);
                                }
                            }

                            // sprintf(szAux, "szXmlTmp[%s]", szXmlTmp); oLog.logDebug(szAux);
                            strcat(szXmlRender, szXmlTmp);
                            sprintf(szAux, "2.szXmlRender[%s]", szXmlRender); oLog.logDebug(szAux);
                        } // for (int it=0;it<itMax;it++)

                        // caso nao tenha IE e seja pessoa juridica 
                        if(iFlagIE == 0 && !memcmp(tObtemDadosXml.szIdTipoPessoa, "2", 1)) {
                            strcat(szXmlRender, "<IE>ISENTO</IE>");
                        }

                        iFlagIE=0;

                        sprintf(szAux, "tObtemDadosXml.szNmTipoLogradouro[%s]", tObtemDadosXml.szNmTipoLogradouro); oLog.logDebug(szAux);

                        szAuxNGIN[0]=0;
                        for(iCountLogradouro=0; pszTipoLogFO[iCountLogradouro] != NULL; iCountLogradouro++) {
                            if(!strcasecmp(pszTipoLogFO[iCountLogradouro], tObtemDadosXml.szNmTipoLogradouro)) {
                                strcpy(szAuxNGIN, pszTipoLogNGIN[iCountLogradouro]);
                                break;
                            }
                        }

                        sprintf(szAux, "Logradouro szAuxNGIN[%s]", szAuxNGIN); oLog.logDebug(szAux);
                        sprintf(szXmlTmp, "<logradouro>%s</logradouro>", szAuxNGIN);
                        strcat(szXmlRender, szXmlTmp);

                        // parte referente a endereco 
                        sprintf(szXmlTmp,
                            "<endereco>%s</endereco>"
                            "<complemento>%s</complemento>"
                            "<bairro>%s</bairro>"
                            "<CEP>%s</CEP>"
                            "<cidade>%s</cidade>"
                            "<estado>%s</estado>"
                            "<pais>%s</pais>"
                            "<numero>%s</numero>",
                            tObtemDadosXml.szEndereco,
                            tObtemDadosXml.szDsEnderecoComplemento,
                            tObtemDadosXml.szNmBairro,
                            tObtemDadosXml.szNrCep,
                            tObtemDadosXml.szCidade,
                            tObtemDadosXml.szEstado,
                            tObtemDadosXml.szPais,
                            tObtemDadosXml.szNumero);

                        strcat(szXmlRender, szXmlTmp);
                        // recoloca a ultima tag retirada no inicio do processo
                        strcat(szXmlRender, "</msg>");
                        sprintf(szAux, "3.szXmlRender[%s]", szXmlRender); oLog.logDebug(szAux);

                        if(InsereRegistro(szIdLinhaTelefonica, szXmlRender) == false) {
                            oLog.logDebug("Erro no processo de insercao");
                            Sumariza(0, 1, NULL, NULL); // Total de registros processados com erro
                            if(geraArquivo(szNrTelefone, szErrorOut, tParamConf.szPath, pArquivoEntrada)) {
                                oLog.logDebug("Erro no processo de geracao do arquivo de saida");
                                break;
                            }
                            continue;
                        }

                        //oLog.logDebug("Efetuando commit na BD...");
                        EXEC SQL COMMIT;

                        if(geraArquivo(szNrTelefone, "OK", tParamConf.szPath, pArquivoEntrada)) {
                            oLog.logDebug("Erro no processo de geracao do arquivo de saida");
                            break;
                        }

                        Sumariza(1, 0, NULL, NULL); // processado com sucesso
                        iQtdRegistros++;
                    } //while((pszNrLinha = lerArquivo(tParamConf.szPath, pArquivoEntrada,pFileIn)) != NULL)

                    if(iQtdRegistros == 0)
                    {
                        geraArquivo(NULL, NULL, tParamConf.szPath, pArquivoEntrada); // gera arquivo zerado
                    }
                    else
                    {
                        geraArquivo(NULL, NULL, NULL, NULL); // Fecha Arquivo de Saida
                    }

                    //lerArquivo(NULL, NULL); // Fecha Arquivo de Entrada
                    fecharArquivo(pFileIn);
                    pFileIn=0;

                    // move o arquivo processado para a área de 'processados'
                    moverArquivo(tParamConf.szPath,tParamConf.szPathToGo,pArquivoEntrada);

                    Sumariza(0, 0, tParamConf.szPath, pArquivoEntrada); // Display do sumario
                } // while( (pArquivoEntrada = OpenDir(tParamConf.szPath)) != NULL && !toAbort )
                
                CloseDir(pDir);

                if ( !toAbort )
                {
                    sprintf(szAux, "Wait %ds...",tempoSleep); oLog.logDebug(szAux);
                    //alarm(1);
                    sleep(tempoSleep);
                    //alarm(0);
                }
            } // if ( !toAbort )
            */

        } // while (!toAbort)

        sinalizaFinalProcesso();

        DBDisconnect();

        oLog.logDebug("Processamento encerrado com sucesso...\n");
        oLog.logDebug("<<<enviaNGIN\n");

        fflush(stdout);
        return 0;

        sqlError:
            sprintf(szAux, "Finalizando processo com erro ORACLE (%d)\n", sqlca.sqlcode); oLog.logDebug(szAux);
            fflush(stdout);
            return -1;
    }
    catch (...)
    {
        sinalizaFinalProcesso();
        DBDisconnectError();
        oLog.logDebug("Processamento encerrado com erro...\n");
        oLog.logDebug("<<<enviaNGIN\n");
        fflush(stdout);
        exit(-1);
    }
}

/************************************************************************************************************/
void Sumariza(int iQtdTotalRegReProc, int iQtdTotalRegReProcError, char *pszPatch, char *pszBatchName)
{
    static int _iQtdTotalRegReProc=0;
    static int _iQtdTotalRegReProcError=0;
    static int _iQtdTotalReg=0;
    static char szDataHoraAux[19 + 1];
    static int iFlag=1;

    if( !iQtdTotalRegReProc && !iQtdTotalRegReProcError )
    {
        if( iFlag )
        {
            sprintf(szDataHoraAux, "%.2s/%.2s/%.4s %.2s:%.2s:%.2s",
                                    szDataHoraGlobal+6,
                                    szDataHoraGlobal+4,
                                    szDataHoraGlobal,
                                    szDataHoraGlobal+8,
                                    szDataHoraGlobal+10,
                                    szDataHoraGlobal+12);
            iFlag=0;
        }

        sprintf(szAux, "***************** START  %s **********************\n", szDataHoraAux); oLog.logDebug(szAux);
        sprintf(szAux, "*** Arquivo processado [%s/%s]\n", pszPatch, pszBatchName); oLog.logDebug(szAux);
        sprintf(szAux, "Total de registros processados com erro...........(%06d)\n", _iQtdTotalRegReProcError); oLog.logDebug(szAux);
        sprintf(szAux, "Total de registros processados com sucesso........(%06d)\n", _iQtdTotalRegReProc); oLog.logDebug(szAux);
        sprintf(szAux, "Total de registros processados....................(%06d)\n", _iQtdTotalReg); oLog.logDebug(szAux);
        sprintf(szAux, "********************************************************************\n"); oLog.logDebug(szAux);

        _iQtdTotalRegReProc=_iQtdTotalRegReProcError=_iQtdTotalReg=0;

        return;
    }

    if(iQtdTotalRegReProc)       _iQtdTotalRegReProc++;
    if(iQtdTotalRegReProcError)  _iQtdTotalRegReProcError++;
    _iQtdTotalReg++;
}

/************************************************************************************************************/
char *ObtemDataHora(void)
{
    struct tm *ptTime;
    time_t tTimeNow;
    static char szDataHora[14 + 1];

    time(&tTimeNow);
    ptTime=localtime(&tTimeNow);
    sprintf(szDataHora, "%04d%02d%02d%02d%02d%02d",
                        ptTime->tm_year + 1900,
                        ptTime->tm_mon + 1,
                        ptTime->tm_mday,
                        ptTime->tm_hour,
                        ptTime->tm_min,
                        ptTime->tm_sec );

    return szDataHora;
}

/************************************************************************************************************/
void ArmaSinal(int iSignal) {

    switch (iSignal)
    {
        case SIGTERM:
            sprintf(szAux, "Armando tratamento para SIGTERM(%d)\n", iSignal); oLog.logInformation(szAux);
        break;
        case SIGHUP:
            sprintf(szAux, "Armando tratamento para SIGHUP(%d)\n", iSignal); oLog.logInformation(szAux);
        break;
        case SIGINT:
            sprintf(szAux, "Armando tratamento para SIGINT(%d)\n", iSignal); oLog.logInformation(szAux);
        break;
        case SIGQUIT:
            sprintf(szAux, "Armando tratamento para SIGQUIT(%d)\n", iSignal); oLog.logInformation(szAux);
        break;
        case SIGTRAP:
            sprintf(szAux, "Armando tratamento para SIGTRAP(%d)\n", iSignal); oLog.logInformation(szAux);
        break;
        case SIGKILL:
            sprintf(szAux, "Armando tratamento para SIGKILL(%d)\n", iSignal); oLog.logInformation(szAux);
        break;
        case SIGSEGV:
            sprintf(szAux, "Armando tratamento para SIGSEGV(%d)\n", iSignal); oLog.logInformation(szAux);
        break;
        case SIGSTOP:
            sprintf(szAux, "Armando tratamento para SIGSTOP(%d)\n", iSignal); oLog.logInformation(szAux);
        break;
        case SIGTSTP:
            sprintf(szAux, "Armando tratamento para SIGTSTP(%d)\n", iSignal); oLog.logInformation(szAux);
        break;
        case SIGIOT:
            sprintf(szAux, "Armando tratamento para SIGIOT(%d)\n", iSignal); oLog.logInformation(szAux);
        break;
        default:
            sprintf(szAux, "Armando tratamento para signal(%d)\n", iSignal); oLog.logInformation(szAux);
        break;

    }

    if(signal((iSignal), ProcessaSignal) == SIG_ERR)
    {
        fprintf(stderr, "ERRO ARMANDO SINAL!!!\n");
        sinalizaFinalProcesso();
        fflush(stdout);
        exit(-1);
    }
}

/************************************************************************************************************/
void ProcessaSignal(int iSig)
{
    sprintf(szAux, "signal %d\n", iSig); oLog.logInformation(szAux);

    /* rearma o mesmo sinal lancado */
    ArmaSinal(iSig);

    switch (iSig)
    {
        case SIGTERM:
            oLog.logInformation("*** SIGTERM ***\n");
            iSignalProcessa=0;
        break;
        case SIGHUP:
            oLog.logInformation("*** SIGHUP ***\n");
            iSignalProcessa=0;
        break;
        case SIGINT:
            oLog.logInformation("*** SIGINT ***\n");
            iSignalProcessa=0;
        break;
        case SIGQUIT:
            oLog.logInformation("*** SIGQUIT ***\n");
            iSignalProcessa=0;
        break;
        case SIGTRAP:
            oLog.logInformation("*** SIGTRAP ***\n");
            iSignalProcessa=0;
        break;
        case SIGKILL:
            oLog.logInformation("*** SIGKILL ***\n");
            iSignalProcessa=0;
        break;
        case SIGSEGV:
            oLog.logInformation("*** SIGSEGV ***\n");
            iSignalProcessa=0;
        break;
        case SIGSTOP:
            oLog.logInformation("*** SIGSTOP ***\n");
            iSignalProcessa=0;
        break;
        case SIGTSTP:
            oLog.logInformation("*** SIGTSTP ***\n");
            iSignalProcessa=0;
        break;
        case SIGIOT:
            oLog.logInformation("*** SIGIOT ***\n");
            iSignalProcessa=0;
        break;
    }
}

/************************************************************************************************************/
int ObtemParamConf(TParamConf *ptParamConf)
{
    MFile mfConfig;
    SplitLine NewLinha;
    char szLinha[100 + 1];
    char szDivArq[256];
    char szDivPre[21];

    oLog.logDebug("Obtendo parametros de configuracao...");

    /* Zera variáveis */
    memset(ptParamConf, 0x00, sizeof(TParamConf));
    memset(szLinha, 0x00, sizeof(szLinha));
    memset(szDivArq, 0x00, sizeof(szDivArq));
    memset(szDivPre, 0x00, sizeof(szDivPre));


    /* Define o arquivo de configuração */
    mfConfig.setPath("enviaNGIN.cfg");

    /* Verificar se conseguiu abrir o arquivo */
    if(!mfConfig.abrir()) {
        oLog.logError("Erro abrindo arquivo de configuração!");
        return -1;
    }

    /* Capturando usuario, senha, path e instance de banco do arquivo */
    NewLinha.SetDiv('=');
    while(mfConfig.getLine(szLinha) != 0)
    {
        NewLinha.SetLine(szLinha);
        NewLinha.GetBeforeDiv(szDivPre);
        NewLinha.GetAfterDiv(szDivArq);

        /* Verifica qual parâmetro foi encontrado. */
        if (!strcmp(szDivPre, "pwd_db"))
        {
            strncpy(ptParamConf->szPws, szDivArq, 10);
        }
        else if (!strcmp(szDivPre, "usr_db"))
        {
            strncpy(ptParamConf->szUsr, szDivArq, 10);
        }
        else if (!strcmp(szDivPre, "inst_db"))
        {
            strncpy(ptParamConf->szInst, szDivArq, 20);
        }
        //else if (!strcmp(szDivPre, "pwd_tux"))
        //{
        //    strncpy(ptParamConf->szPwsTux, szDivArq, 10);
        //}
        //else if (!strcmp(szDivPre, "usr_tux"))
        //{
        //    strncpy(ptParamConf->szUsrTux, szDivArq, 10);
        //}
        //else if (!strcmp(szDivPre, "pwd_tux_gen"))
        //{
        //    strncpy(ptParamConf->szPwsTuxGen, szDivArq, 10);
        //}
        //else if (strcmp(szDivPre, "clt_tux")==0)
        //{
        //    strncpy(ptParamConf->szCltTux, szDivArq, 10);
        //}
        else if ( strcmp(szDivPre, "path")==0 )
        {
            strncpy(ptParamConf->szPath, szDivArq, 255);
            if ( ptParamConf->szPath[strlen(ptParamConf->szPath)-1] != '/' )
            {
                strcat(ptParamConf->szPath, "/");
            }
        }
        else if ( strcmp(szDivPre, "path_togo")==0 )
        {
            strncpy(ptParamConf->szPathToGo, szDivArq,255);
            if ( ptParamConf->szPathToGo[strlen(ptParamConf->szPathToGo)-1] != '/' )
            {
                strcat(ptParamConf->szPathToGo, "/");
            }
        }

        memset(szLinha,  0x00, sizeof(szLinha));
        memset(szDivPre, 0x00, sizeof(szDivPre));
        memset(szDivArq, 0x00, sizeof(szDivArq));
    }

    /* Fechando o arquivo de configuracao aberto */
    mfConfig.fechar();

    if ( ptParamConf->szPathToGo[0] == 0 )
    {
        strcpy(ptParamConf->szPathToGo,ptParamConf->szPath);
    }

    if ( strcmp(ptParamConf->szPathToGo,ptParamConf->szPath) )
    {
        if ( ACCESS(ptParamConf->szPathToGo,0) )
        {
            if (MKDIR(ptParamConf->szPathToGo,447) )
            {
                sprintf(szAux, "Erro %s criando diretorio %s", ptParamConf->szPathToGo, strerror(errno)); oLog.logError(szAux);
                sinalizaFinalProcesso();
                fflush(stdout);
                exit(-1);
            }
        }
    }

    //sprintf(szAux, "szPws[%s]", ptParamConf->szPws); oLog.logDebug(szAux);
    sprintf(szAux, "szUsr[%s]", ptParamConf->szUsr); oLog.logDebug(szAux);
    sprintf(szAux, "szInst[%s]", ptParamConf->szInst); oLog.logDebug(szAux);
    //sprintf(szAux, "szPwsTux[%s]", ptParamConf->szPwsTux); oLog.logDebug(szAux);
    //sprintf(szAux, "szUsrTux[%s]", ptParamConf->szUsrTux); oLog.logDebug(szAux);
    //sprintf(szAux, "szPwsTuxGen[%s]", ptParamConf->szPwsTuxGen); oLog.logDebug(szAux);
    //sprintf(szAux, "szCltTux[%s]", ptParamConf->szCltTux); oLog.logDebug(szAux);
    sprintf(szAux, "szPath[%s]", ptParamConf->szPath); oLog.logDebug(szAux);
    sprintf(szAux, "szPathToGo[%s]", ptParamConf->szPathToGo); oLog.logDebug(szAux);

    /* Verifica se todos os dados foram recuperados do arquivo de configuração. */
    if (strlen(ptParamConf->szInst) == 0 ||
        //strlen(ptParamConf->szPwsTux) == 0 ||
       // strlen(ptParamConf->szUsrTux) == 0 ||
       // strlen(ptParamConf->szPwsTuxGen) == 0 ||
        strlen(ptParamConf->szPath) == 0
        //strlen(ptParamConf->szCltTux) == 0
       )
    {
        oLog.logError("Dados incompletos!");
        return -1;
    }


    oLog.logDebug("Parametros de configuracao obtidos com sucesso...");
    return 0;
}

/************************************************************************************************************/
bool InsereRegistro(char *pszIdLinhaTelefonica, char *pszXml)
{
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdLinhaTelefonica[21];
        VARCHAR oszIdFilaSetClientInfo[21];
        VARCHAR oszXml[2000];
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    sprintf(szAux, "Inicio InsereRegistro\n"); oLog.logDebug(szAux);

    EXEC SQL WHENEVER SQLERROR goto erro;

    EXEC SQL SELECT infra.filasetclientinfosq.nextval INTO :oszIdFilaSetClientInfo FROM DUAL;

    STRCPY_TO_ORA(oszIdLinhaTelefonica, pszIdLinhaTelefonica);
    STRCPY_TO_ORA(oszXml, pszXml);

    EXEC SQL
        INSERT INTO infra.filasetclientinfo
        (
            idfilasetclientinfo,
            idlinhatelefonica,
            dttimestamp,
            xml1
        )
        VALUES
        (
            :oszIdFilaSetClientInfo,
            :oszIdLinhaTelefonica,
            SYSDATE,
            :oszXml
        );

    sprintf(szAux, "Finalizando InsereRegistro <OK>\n", sqlca.sqlcode); oLog.logDebug(szAux);
    return true;

    erro:
        sprintf(szAux, "Finalizando InsereRegistro <ERROR>\n"); oLog.logDebug(szAux);
        sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.*s",sqlca.sqlcode, sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
        strcpy(szErrorOut, sqlca.sqlerrm.sqlerrmc); szErrorOut[sqlca.sqlerrm.sqlerrml-1]=0x00;
        return false;
}

/************************************************************************************************************/
bool ObtemDadosXml(char *pszIdLinhaTelefonica,char *idPessoaEndereco,TObtemDadosXml *ptObtemDadosXml)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char* oszIdLinhaTelefonica = pszIdLinhaTelefonica;
        char* oszIdPessoaEndereco = idPessoaEndereco;

        VARCHAR oszIdTipoPessoa[25];
        VARCHAR oszIdPessoa[25];
        VARCHAR oszTipoCliente[1];
        VARCHAR oszNome[255];
        VARCHAR oszConfidencial[1];
        VARCHAR oszDataNascimento[14];
        VARCHAR oszEstadoCivil[1];
        VARCHAR oszCodSexo[1];
        VARCHAR oszNmTipoLogradouro[255];
        VARCHAR oszEndereco[512];
        VARCHAR oszDsEnderecoComplemento[255];
        VARCHAR oszNmBairro[255];
        VARCHAR oszNrCep[255];
        VARCHAR oszCidade[255];
        VARCHAR oszEstado[25];
        VARCHAR oszPais[3];
        VARCHAR oszNumero[255];

        short oiIdTipoPessoa = -1;
        short oiIdPessoa = -1;
        short oiTipoCliente = -1;
        short oiNome = -1;
        short oiConfidencial = -1;
        short oiDataNascimento = -1;
        short oiEstadoCivil = -1;
        short oiCodSexo = -1;
        short oiNmTipoLogradouro = -1;
        short oiEndereco = -1;
        short oiDsEnderecoComplemento = -1;
        short oiNmBairro = -1;
        short oiNrCep = -1;
        short oiCidade = -1;
        short oiEstado = -1;
        short oiPais = -1;
        short oiNumero = -1;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    sprintf(szAux, "Inicio ObtemDadosXml()\n"); oLog.logDebug(szAux);
    sprintf(szAux, "idLinhaTelefonica=[%s]\n", oszIdLinhaTelefonica); oLog.logDebug(szAux);
    sprintf(szAux, " idPessoaEndereco=[%s]\n", oszIdPessoaEndereco); oLog.logDebug(szAux);

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    //STRCPY_TO_ORA(oszIdLinhaTelefonica, pszIdLinhaTelefonica);

    if ( idPessoaEndereco[0] == 0 )
    {
        EXEC SQL
            SELECT
                idtipopessoa,
                idpessoa,
                tipocliente,
                nome,
                confidencial,
                datanascimento,
                estadocivil,
                codsexo
                //nmtipologradouro,
                //endereco,
                //dsenderecocomplemento,
                //nmbairro,
                //nrcep,
                //cidade,
                //estado,
                //pais,
                //numero
            INTO
                :oszIdTipoPessoa:oiIdTipoPessoa,
                :oszIdPessoa:oiIdPessoa,
                :oszTipoCliente:oiTipoCliente,
                :oszNome:oiNome,
                :oszConfidencial:oiConfidencial,
                :oszDataNascimento:oiDataNascimento,
                :oszEstadoCivil:oiEstadoCivil,
                :oszCodSexo:oiCodSexo
                //:oszNmTipoLogradouro:oiNmTipoLogradouro,
                //:oszEndereco:oiEndereco,
                //:oszDsEnderecoComplemento:oiDsEnderecoComplemento,
                //:oszNmBairro:oiNmBairro,
                //:oszNrCep:oiNrCep,
                //:oszCidade:oiCidade,
                //:oszEstado:oiEstado,
                //:oszPais:oiPais,
                //:oszNumero:oiNumero
            FROM
            (
                    SELECT
                        pessoa.idtipopessoa,
                        pessoa.idpessoa,
                        decode(tipopessoa.idtipopessoa, 1, 'P', decode(tipopessoa.idtipopessoa, 2, 'E', '')) as tipoCliente,
                        pessoa.nmpessoa as nome,
                        'N' as confidencial,
                        to_char(nvl(pessoafisica.dtnascimento, ''), 'DD/MM/YYYY') as dataNascimento,
                        decode(pessoafisica.idestadocivil, 1, 'S', decode(pessoafisica.idestadocivil, 2, 'C', decode(pessoafisica.idestadocivil, 4, 'V', decode(pessoafisica.idestadocivil, 5, 'D', '')))) as estadoCivil,
                        decode(pessoafisica.idsexo, 1, 'M', decode(pessoafisica.idsexo, 2, 'F', '')) as codSexo
                        //pessoaendereco.nmtipologradouro as nmtipologradouro,
                        //pessoaendereco.nmtipologradouro || ' ' || pessoaendereco.nmtitulologradouro || ' ' || pessoaendereco.nmlogradouro as endereco,
                        //pessoaendereco.dsenderecocomplemento as dsenderecocomplemento,
                        //pessoaendereco.nmbairro as nmbairro,
                        //pessoaendereco.nrcep as nrcep,
                        //pessoaendereco.nmmunicipio as cidade,
                        //uf.sguf AS estado,
                        //'BRA' as pais,
                        //pessoaendereco.nrendereco as numero
                    FROM
                        customer.pessoa pessoa,
                        customer.pessoadepara pessoadepara,
                        customer.pessoalinhahistorico pessoalinhahistorico,
                        linha.linhatelefonica linhatelefonica,
                        customer.pessoafisica pessoafisica,
                        //customer.pessoaendereco pessoaendereco,
                        apoio.tipopessoa tipopessoa,
                        apoio.estadocivil estadocivil,
                        apoio.sexo sexo,
					    apoio.uf uf
                    WHERE
                        linhatelefonica.idlinhatelefonica = pessoalinhahistorico.idlinhatelefonica
                    AND pessoalinhahistorico.idpessoadepara = pessoadepara.idpessoadepara
                    AND pessoadepara.idpessoa = pessoa.idpessoa
                    //AND pessoa.idpessoa = pessoaendereco.idpessoa
                    AND pessoa.idpessoa = pessoafisica.idpessoa (+)
                    AND pessoafisica.idestadocivil = estadocivil.idestadocivil (+)
                    AND pessoafisica.idsexo = sexo.idsexo (+)
				    //AND uf.iduf=pessoaendereco.iduf
                    AND pessoa.idtipopessoa = tipopessoa.idtipopessoa
                    AND pessoalinhahistorico.idtiporelacionamento = 2
                    AND linhatelefonica.idlinhatelefonica = :oszIdLinhaTelefonica
                    ORDER BY
                        pessoalinhahistorico.dtultimaalteracao DESC
            )
            WHERE ROWNUM <= 1;

        EXEC SQL
            SELECT
                nmtipologradouro,
                endereco,
                dsenderecocomplemento,
                nmbairro,
                nrcep,
                nmmunicipio,
                sguf,
                sgpais,
                numero
            INTO
                :oszNmTipoLogradouro:oiNmTipoLogradouro,
                :oszEndereco:oiEndereco,
                :oszDsEnderecoComplemento:oiDsEnderecoComplemento,
                :oszNmBairro:oiNmBairro,
                :oszNrCep:oiNrCep,
                :oszCidade:oiCidade,
                :oszEstado:oiEstado,
                :oszPais:oiPais,
                :oszNumero:oiNumero
            FROM
            (
                SELECT
                    pessoaendereco.nmtipologradouro,
                    trim(pessoaendereco.nmtipologradouro || ' ' || pessoaendereco.nmtitulologradouro || ' ' || pessoaendereco.nmlogradouro) as endereco,
                    pessoaendereco.dsenderecocomplemento,
                    pessoaendereco.nmbairro,
                    pessoaendereco.nrcep,
                    pessoaendereco.nmmunicipio,
                    uf.sguf,
                    DECODE(pais.sgpais,'BR','BRA',pais.sgpais) AS sgpais,
                    pessoaendereco.nrendereco as numero,
                    contaendereco.idtipoenderecocobranca
                FROM
                    customer.pessoaendereco pessoaendereco,
                    customer.contaendereco contaendereco,
                    apoio.tipoendereco tipoendereco,
                    apoio.pais pais,
                    apoio.uf uf
                WHERE
                    pessoaendereco.idpessoa = :oszIdPessoa
                AND pessoaendereco.idpessoaendereco = contaendereco.idpessoaendereco
                AND NVL(contaendereco.dtexpiracao,SYSDATE) >= SYSDATE
                AND pessoaendereco.idpais = pais.idpais
                AND pessoaendereco.idtipoendereco = tipoendereco.idtipoendereco
                AND pessoaendereco.iduf = uf.iduf
                ORDER BY
                    contaendereco.idtipoenderecocobranca DESC
            )
            WHERE ROWNUM < 2;
    }
    else
    {
        EXEC SQL
            SELECT
                idtipopessoa,
                idpessoa,
                tipocliente,
                nome,
                confidencial,
                datanascimento,
                estadocivil,
                codsexo
                //nmtipologradouro,
                //endereco,
                //dsenderecocomplemento,
                //nmbairro,
                //nrcep,
                //cidade,
                //estado,
                //pais,
                //numero
            INTO
                :oszIdTipoPessoa:oiIdTipoPessoa,
                :oszIdPessoa:oiIdPessoa,
                :oszTipoCliente:oiTipoCliente,
                :oszNome:oiNome,
                :oszConfidencial:oiConfidencial,
                :oszDataNascimento:oiDataNascimento,
                :oszEstadoCivil:oiEstadoCivil,
                :oszCodSexo:oiCodSexo
                //:oszNmTipoLogradouro:oiNmTipoLogradouro,
                //:oszEndereco:oiEndereco,
                //:oszDsEnderecoComplemento:oiDsEnderecoComplemento,
                //:oszNmBairro:oiNmBairro,
                //:oszNrCep:oiNrCep,
                //:oszCidade:oiCidade,
                //:oszEstado:oiEstado,
                //:oszPais:oiPais,
                //:oszNumero:oiNumero
            FROM
            (
                    SELECT
                        pessoa.idtipopessoa,
                        pessoa.idpessoa,
                        decode(tipopessoa.idtipopessoa, 1, 'P', decode(tipopessoa.idtipopessoa, 2, 'E', '')) as tipoCliente,
                        pessoa.nmpessoa as nome,
                        'N' as confidencial,
                        to_char(nvl(pessoafisica.dtnascimento, ''), 'DD/MM/YYYY') as dataNascimento,
                        decode(pessoafisica.idestadocivil, 1, 'S', decode(pessoafisica.idestadocivil, 2, 'C', decode(pessoafisica.idestadocivil, 4, 'V', decode(pessoafisica.idestadocivil, 5, 'D', '')))) as estadoCivil,
                        decode(pessoafisica.idsexo, 1, 'M', decode(pessoafisica.idsexo, 2, 'F', '')) as codSexo
                        //pessoaendereco.nmtipologradouro as nmtipologradouro,
                        //pessoaendereco.nmtipologradouro || ' ' || pessoaendereco.nmtitulologradouro || ' ' || pessoaendereco.nmlogradouro as endereco,
                        //pessoaendereco.dsenderecocomplemento as dsenderecocomplemento,
                        //pessoaendereco.nmbairro as nmbairro,
                        //pessoaendereco.nrcep as nrcep,
                        //pessoaendereco.nmmunicipio as cidade,
                        //uf.sguf AS estado,
                        //'BRA' as pais,
                        //pessoaendereco.nrendereco as numero
                    FROM
                        customer.pessoa pessoa,
                        customer.pessoadepara pessoadepara,
                        customer.pessoalinhahistorico pessoalinhahistorico,
                        linha.linhatelefonica linhatelefonica,
                        customer.pessoafisica pessoafisica,
                        //customer.pessoaendereco pessoaendereco,
                        apoio.tipopessoa tipopessoa,
                        apoio.estadocivil estadocivil,
                        apoio.sexo sexo,
					    apoio.uf uf
                    WHERE
                        linhatelefonica.idlinhatelefonica = pessoalinhahistorico.idlinhatelefonica
                    AND pessoalinhahistorico.idpessoadepara = pessoadepara.idpessoadepara
                    AND pessoadepara.idpessoa = pessoa.idpessoa
                    //AND pessoa.idpessoa = pessoaendereco.idpessoa
                    AND pessoa.idpessoa = pessoafisica.idpessoa (+)
                    AND pessoafisica.idestadocivil = estadocivil.idestadocivil (+)
                    AND pessoafisica.idsexo = sexo.idsexo (+)
				    //AND uf.iduf=pessoaendereco.iduf
                    AND pessoa.idtipopessoa = tipopessoa.idtipopessoa
                    AND pessoalinhahistorico.idtiporelacionamento = 2
                    AND linhatelefonica.idlinhatelefonica = :oszIdLinhaTelefonica
                    ORDER BY
                        pessoalinhahistorico.dtultimaalteracao DESC
            )
            WHERE ROWNUM < 2;

        EXEC SQL
            SELECT
                pessoaendereco.nmtipologradouro,
                trim(pessoaendereco.nmtipologradouro || ' ' || pessoaendereco.nmtitulologradouro || ' ' || pessoaendereco.nmlogradouro) as endereco,
                pessoaendereco.dsenderecocomplemento,
                pessoaendereco.nmbairro,
                pessoaendereco.nrcep,
                pessoaendereco.nmmunicipio,
                uf.sguf,
                'BRA' as pais,
                pessoaendereco.nrendereco as numero
            INTO
                :oszNmTipoLogradouro:oiNmTipoLogradouro,
                :oszEndereco:oiEndereco,
                :oszDsEnderecoComplemento:oiDsEnderecoComplemento,
                :oszNmBairro:oiNmBairro,
                :oszNrCep:oiNrCep,
                :oszCidade:oiCidade,
                :oszEstado:oiEstado,
                :oszPais:oiPais,
                :oszNumero:oiNumero
            FROM
                customer.pessoaendereco pessoaendereco,
				apoio.uf uf
            WHERE
                pessoaendereco.idpessoaendereco = :oszIdPessoaEndereco
			AND uf.iduf=pessoaendereco.iduf;
    }

    memset(ptObtemDadosXml, 0x00, sizeof(TObtemDadosXml));

    if(oiIdTipoPessoa != -1)            { STRCPY_FROM_ORA(ptObtemDadosXml->szIdTipoPessoa, oszIdTipoPessoa); }
    if(oiIdPessoa != -1)                { STRCPY_FROM_ORA(ptObtemDadosXml->szIdPessoa, oszIdPessoa); }
    if(oiTipoCliente != -1)             { STRCPY_FROM_ORA(ptObtemDadosXml->szTipoCliente, oszTipoCliente); }
    if(oiNome != -1)                    { STRCPY_FROM_ORA(ptObtemDadosXml->szNome, oszNome); }
    if(oiConfidencial != -1)            { STRCPY_FROM_ORA(ptObtemDadosXml->szConfidencial, oszConfidencial); }
    if(oiDataNascimento != -1)          { STRCPY_FROM_ORA(ptObtemDadosXml->szDataNascimento, oszDataNascimento); }
    if(oiEstadoCivil != -1)             { STRCPY_FROM_ORA(ptObtemDadosXml->szEstadoCivil, oszEstadoCivil); }
    if(oiCodSexo != -1)                 { STRCPY_FROM_ORA(ptObtemDadosXml->szCodSexo, oszCodSexo); }
    if(oiNmTipoLogradouro != -1)        { STRCPY_FROM_ORA(ptObtemDadosXml->szNmTipoLogradouro, oszNmTipoLogradouro); }
    if(oiEndereco != -1)                { STRCPY_FROM_ORA(ptObtemDadosXml->szEndereco, oszEndereco); }
    if(oiDsEnderecoComplemento != -1)   { STRCPY_FROM_ORA(ptObtemDadosXml->szDsEnderecoComplemento, oszDsEnderecoComplemento); }
    if(oiNmBairro != -1)                { STRCPY_FROM_ORA(ptObtemDadosXml->szNmBairro, oszNmBairro); }
    if(oiNrCep != -1)                   { STRCPY_FROM_ORA(ptObtemDadosXml->szNrCep, oszNrCep); }
    if(oiCidade != -1)                  { STRCPY_FROM_ORA(ptObtemDadosXml->szCidade, oszCidade); }
    if(oiEstado != -1)                  { STRCPY_FROM_ORA(ptObtemDadosXml->szEstado, oszEstado); }
    if(oiPais != -1)                    { STRCPY_FROM_ORA(ptObtemDadosXml->szPais, oszPais); }
    if(oiNumero != -1)                  { STRCPY_FROM_ORA(ptObtemDadosXml->szNumero, oszNumero); }

    //    sprintf(szAux, "ptObtemDadosXml->szIdTipoPessoa[%s]\n", ptObtemDadosXml->szIdTipoPessoa); oLog.logDebug(szAux);
    //    sprintf(szAux, "ptObtemDadosXml->szIdPessoa[%s]\n", ptObtemDadosXml->szIdPessoa); oLog.logDebug(szAux);
    //    sprintf(szAux, "ptObtemDadosXml->szTipoCliente[%s]\n", ptObtemDadosXml->szTipoCliente); oLog.logDebug(szAux);
    //    sprintf(szAux, "ptObtemDadosXml->szNome[%s]\n", ptObtemDadosXml->szNome); oLog.logDebug(szAux);
    //    sprintf(szAux, "ptObtemDadosXml->szConfidencial[%s]\n", ptObtemDadosXml->szConfidencial); oLog.logDebug(szAux);
    //    sprintf(szAux, "ptObtemDadosXml->szDataNascimento[%s]\n", ptObtemDadosXml->szDataNascimento); oLog.logDebug(szAux);
    //    sprintf(szAux, "ptObtemDadosXml->szEstadoCivil[%s]\n", ptObtemDadosXml->szEstadoCivil); oLog.logDebug(szAux);
    //    sprintf(szAux, "ptObtemDadosXml->szCodSexo[%s]\n", ptObtemDadosXml->szCodSexo); oLog.logDebug(szAux);

    sprintf(szAux, "Finalizando ObtemDadosXml()\n"); oLog.logDebug(szAux);
    return true;

    erro:
        sprintf(szAux, "Finalizando ObtemDadosXml com erro\n"); oLog.logDebug(szAux);
        sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
        return false;

    naoexiste:
        sprintf(szAux, "IdLinhaTelefonica nao encontrado[%s]\n", pszIdLinhaTelefonica); oLog.logDebug(szAux);
        return false;
}

/************************************************************************************************************/
bool ObtemIdLinhaTelefonica(char *pszNrLinha, char *pszIdLinhaTelefonica)
{
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdLinhaTelefonica[25];
        VARCHAR oszNrLinha[25];
        VARCHAR oszCdAreaRegistro[25];

        short oiIdLinhaTelefonica = -1;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;
    char szAux[25 + 1];

    sprintf(szAux, "Inicio ObtemIdLinhaTelefonica\n"); oLog.logDebug(szAux);
    sprintf(szAux, "pszNrLinha[%s]\n", pszNrLinha); oLog.logDebug(szAux);

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    memcpy(szAux, pszNrLinha, 2); szAux[2]=0x00;
    STRCPY_TO_ORA(oszNrLinha, pszNrLinha+2);
    STRCPY_TO_ORA(oszCdAreaRegistro, szAux);

    EXEC SQL
        SELECT
            llt.idlinhatelefonica
        INTO
            :oszIdLinhaTelefonica:oiIdLinhaTelefonica
        FROM
            linha.linhabase llb,
            linha.linhatelefonica llt,
            apoio.arearegistro aar
        WHERE
            llb.idarearegistro = aar.idarearegistro
        AND
            llt.idlinhabase = llb.idlinhabase
        AND
            aar.cdarearegistro = :oszCdAreaRegistro
        AND
            llb.nrlinha = :oszNrLinha;


    if(oiIdLinhaTelefonica != -1)          { STRCPY_FROM_ORA(pszIdLinhaTelefonica, oszIdLinhaTelefonica); }
    sprintf(szAux, "Finalizando ObtemIdLinhaTelefonica <OK>,oszIdLinhaTelefonica=[%.*s]\n", oszIdLinhaTelefonica.len, oszIdLinhaTelefonica.arr); oLog.logDebug(szAux);
    return true;

    erro:
        sprintf(szAux, "Finalizando ObtemIdLinhaTelefonica <ERROR>\n"); oLog.logDebug(szAux);
        sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
        return false;

    naoexiste:
        sprintf(szAux, "Finalizando ObtemIdLinhaTelefonica <NOT FOUND>\n"); oLog.logDebug(szAux);
        sprintf(szAux, "NrLinha nao encontrado[%s]\n", pszNrLinha); oLog.logDebug(szAux);
        return false;
}

/************************************************************************************************************/
char *ObtemParametro(char *pCdParametro)
{
    EXEC SQL BEGIN DECLARE SECTION;
        //VARCHAR oszCdParametro[255];
        char *oszCdParametro = pCdParametro;
        VARCHAR oszDsValorParametro[255+1];
    EXEC SQL END DECLARE SECTION;

    static char szDsValorParametro[255 + 1];
    struct sqlca sqlca;


    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    //STRCPY_TO_ORA(oszCdParametro, pCdParametro);

    EXEC SQL 
        SELECT dsvalorparametro
          INTO :oszDsValorParametro
          FROM apoio.parametro
         WHERE parametro.cdparametro = :oszCdParametro;

    STRCPY_FROM_ORA(szDsValorParametro, oszDsValorParametro);

    return szDsValorParametro;

    erro:
        sprintf(szAux, "Finalizando com erro sqlca.sqlcode(%d)\n", sqlca.sqlcode); oLog.logDebug(szAux);
        sinalizaFinalProcesso();
        fflush(stdout);
        exit(-1);

    naoexiste:
        sprintf(szAux, "Chave pesquisada nao encontrada[%s]\n", pCdParametro); oLog.logDebug(szAux);
        return NULL;
}

/************************************************************************************************************/
int DBConnect(char *pUsr, char *pPwd, char *pInst)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[256];
    EXEC SQL END DECLARE SECTION;

    /* String de conexao */
    sprintf(connString, "%s/%s@%s", pUsr, pPwd, pInst);

    /* Marca ponto de erro */
    EXEC SQL WHENEVER SQLERROR GOTO errConn;

    /* Conecta */
    EXEC SQL CONNECT :connString;
    
    isConnected=true;

    return (sqlca.sqlcode);

errConn:
    oLog.logInformation("<<<DBConnect [ERROR]\n");
    return -1;
}

/************************************************************************************************************/
void DBDisconnect(void)
{
    if ( isConnected )
    {
        oLog.logDebug("Desconectando da BD...\n");
        EXEC SQL WHENEVER SQLERROR GOTO Error;
        EXEC SQL COMMIT WORK RELEASE;
        isConnected = false;
    }

    return;

Error:
    sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    return;
}

/************************************************************************************************************/
void DBDisconnectError(void)
{
    if ( isConnected )
    {
        oLog.logDebug("Desconectando da BD com erro...\n");
        EXEC SQL WHENEVER SQLERROR GOTO Error;
        EXEC SQL ROLLBACK WORK RELEASE;
        isConnected = false;
    }

    return;

Error:
    sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    return;
}

/*******************************************************************************************************/
//@cassio TDadosDocumento *BuscaDocumentoPorIdPessoa(char *pszIdPessoa)
int BuscaDocumentoPorIdPessoa(char *pszIdPessoa)
{
    static int iFlag=0;
    //static TDadosDocumento tDadosDocumentoAux;
    //static TDadosDocumento *ptDadosDocumentoAux;
    //static int iCount=0;

    sprintf(szAux, "BuscaDocumentoPorIdPessoa(), pszIdPessoa=[%s]",pszIdPessoa); oLog.logDebug(szAux);

    //if(iFlag == 0) {
        //@cassio controleAlocacao();
    return proCBuscaDocumentoPorIdPessoa(pszIdPessoa);
        //ptDadosDocumentoAux=gptDadosDocumento;
    //    iFlag=1;
    //}

    //    sprintf(szAux, "gptDadosDocumento(%p)ptDadosDocumentoAux(%p)", gptDadosDocumento, ptDadosDocumentoAux); oLog.logDebug(szAux);
    //    sprintf(szAux, "giQtdElementosAlocados(%d)giQtdElementosObtidos(%d)iCount(%d)", giQtdElementosAlocados, giQtdElementosObtidos, iCount); oLog.logDebug(szAux);

    //@cassio if(iCount < giQtdElementosObtidos)
    //@cassio {
    //@cassio     memcpy(&tDadosDocumentoAux, ptDadosDocumentoAux, sizeof(TDadosDocumento));
    //@cassio     iCount++;
    //@cassio     ptDadosDocumentoAux++;
    //@cassio 
    //@cassio     sprintf(szAux, "BuscaDocumentoPorIdPessoa() <NOT NULL>"); oLog.logDebug(szAux);
    //@cassio     return &tDadosDocumentoAux;
    //@cassio }
    //@cassio else
    //@cassio {
    //@cassio     // sprintf(szAux, "Desalocando memoria ->gptDadosDocumento(%p)", gptDadosDocumento); oLog.logDebug(szAux);
    //@cassio     free(gptDadosDocumento);
    //@cassio     gptDadosDocumento=NULL;
    //@cassio     iFlag=0;
    //@cassio     iCount=0;
    //@cassio     giQtdElementosObtidos=0;
    //@cassio 
    //@cassio     sprintf(szAux, "BuscaDocumentoPorIdPessoa() <NULL>"); oLog.logDebug(szAux);
    //@cassio     return NULL;
    //@cassio }
}

/*************************************************************************************/
int proCBuscaDocumentoPorIdPessoa(char *pszIdPessoa)
{
    struct sqlca sqlca;
    int iCount=0;
    //@cassio TDadosDocumento *ptDadosDocumentoAux;

    sprintf(szAux, "proCBuscaDocumentoPorIdPessoa()"); oLog.logDebug(szAux);
    sprintf(szAux, "pszIdPessoa[%s]", pszIdPessoa); oLog.logDebug(szAux);

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszIdPessoa[25];

        VARCHAR oszSgTipoDocumento[256];
        VARCHAR oszNrDocumento[256];
        //VARCHAR oszSgOrgaoExpedidor[255];

        short iSgTipoDocumento;
        short iNrDocumento;
        //short iSgOrgaoExpedidor;
    EXEC SQL END DECLARE SECTION;


    STRCPY_TO_ORA(oszIdPessoa, pszIdPessoa);

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND DO break;

    EXEC SQL DECLARE
        CursorBuscaDocumentoPorIdPessoa CURSOR FOR
            SELECT
                DECODE(TIPODOCUMENTO.SGTIPODOCUMENTO, 'IF', 'IE',
                    DECODE(TIPODOCUMENTO.SGTIPODOCUMENTO, 'IM', 'IE', TIPODOCUMENTO.SGTIPODOCUMENTO)) AS SGTIPODOCUMENTO,
                DOCUMENTO.NRDOCUMENTO
                //@cassio DOCUMENTO.SGORGAOEXPEDIDOR
            FROM
                CUSTOMER.PESSOADOCUMENTO PESSOADOCUMENTO,
                CUSTOMER.DOCUMENTO DOCUMENTO,
                APOIO.TIPODOCUMENTO TIPODOCUMENTO
            WHERE
                DOCUMENTO.IDDOCUMENTO = PESSOADOCUMENTO.IDDOCUMENTO
            AND DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
            AND TIPODOCUMENTO.INVISUALIZA = 1
            AND PESSOADOCUMENTO.IDPESSOA IN (
                                                SELECT
                                                    PESSOADEPARA.IDPESSOAORIGEM
                                                FROM
                                                CUSTOMER.PESSOADEPARA
                                                WHERE
                                                PESSOADEPARA.IDPESSOA = :oszIdPessoa
                                           );

    EXEC SQL OPEN CursorBuscaDocumentoPorIdPessoa;

    memset(&gptDadosDocumento,0,sizeof(gptDadosDocumento));

    //@cassio for(iCount=0, ptDadosDocumentoAux=gptDadosDocumento;;iCount++, ptDadosDocumentoAux++, giQtdElementosObtidos++)
    while(true)
    {
        //@cassio iSgTipoDocumento = iNrDocumento = iSgOrgaoExpedidor = -1;
        iSgTipoDocumento = iNrDocumento = -1;

        EXEC SQL FETCH CursorBuscaDocumentoPorIdPessoa INTO
               :oszSgTipoDocumento:iSgTipoDocumento,
               :oszNrDocumento:iNrDocumento;
               //@cassio :oszSgOrgaoExpedidor:iSgOrgaoExpedidor;

        /* Verifica se precisa realocar espaco */
        //@cassio if(iCount >= giQtdElementosAlocados) {
        //@cassio     giQtdElementosAlocados++;
        //@cassio 
        //@cassio     // sprintf(szAux, "Realocando memoria [%p]", gptDadosDocumento); oLog.logDebug(szAux);
        //@cassio     gptDadosDocumento = (TDadosDocumento *) realloc(gptDadosDocumento, sizeof(TDadosDocumento) * (giQtdElementosAlocados));
        //@cassio     // sprintf(szAux, "Memoria realocada [%p] bloco(%d)", gptDadosDocumento, sizeof(TDadosDocumento) * (giQtdElementosAlocados)); oLog.logDebug(szAux);
        //@cassio 
        //@cassio     /* Atribui o novo endereco obtido e posiciona o ponteiro na posicao do ultimo registro obtido antes da realocacao */
        //@cassio     ptDadosDocumentoAux = gptDadosDocumento+iCount;
        //@cassio }

        /* copia as informacoes obtidas para o ponteiro */
        //@cassio memset(ptDadosDocumentoAux, 0x00, sizeof(TDadosDocumento));

        //@cassio if(iSgTipoDocumento != -1)   { STRCPY_FROM_ORA(ptDadosDocumentoAux->szSgTipoDocumento ,   oszSgTipoDocumento); }
        //@cassio if(iNrDocumento != -1)       { STRCPY_FROM_ORA(ptDadosDocumentoAux->szNrDocumento ,       oszNrDocumento); }
        //@cassio if(iSgOrgaoExpedidor != -1)  { STRCPY_FROM_ORA(ptDadosDocumentoAux->szSgOrgaoExpedidor ,  oszSgOrgaoExpedidor); }
        if ( iCount < MAXDOCS ) 
        {
            if(iSgTipoDocumento != -1)   { STRCPY_FROM_ORA(gptDadosDocumento[iCount].szSgTipoDocumento ,   oszSgTipoDocumento); }
            if(iNrDocumento != -1)       { STRCPY_FROM_ORA(gptDadosDocumento[iCount].szNrDocumento ,       oszNrDocumento); }
        }
        //@cassio if(iSgOrgaoExpedidor != -1)  { STRCPY_FROM_ORA(gptDadosDocumento[iCount].szSgOrgaoExpedidor ,  oszSgOrgaoExpedidor); }

        iCount++;
    }

    EXEC SQL CLOSE CursorBuscaDocumentoPorIdPessoa;

    sprintf(szAux, "proCBuscaDocumentoPorIdPessoa() <FOUND>,%d documentos",iCount); oLog.logDebug(szAux);

    return iCount;

    erro:
        sprintf(szAux, "proCBuscaDocumentoPorIdPessoa() <ERROR>"); oLog.logDebug(szAux);
        sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
        return 0;

    naoexiste:
        sprintf(szAux, "proCBuscaDocumentoPorIdPessoa() <NOT FOUND>"); oLog.logDebug(szAux);
        return 0;
}

/*******************************************************************************************************/
//@cassio void controleAlocacao(void)
//@cassio {
//@cassio     giQtdElementosAlocados=10;
//@cassio     giQtdElementosObtidos=0;
//@cassio 
//@cassio //    sprintf(szAux, "giQtdElementosAlocados(%d)", giQtdElementosAlocados); oLog.logDebug(szAux);
//@cassio //    sprintf(szAux, "sizeof(TDadosDocumento)(%d)", sizeof(TDadosDocumento)); oLog.logDebug(szAux);
//@cassio 
//@cassio     if((gptDadosDocumento = (TDadosDocumento *) malloc((sizeof(TDadosDocumento) * (giQtdElementosAlocados)))) == NULL ) {
//@cassio         sprintf(szAux, "13E0001", "Erro alocando memoria!");
//@cassio         sinalizaFinalProcesso();
//@cassio         exit(-1);
//@cassio     }
//@cassio //    sprintf(szAux, "Memoria alocada gptDadosDocumento (%p)", gptDadosDocumento); oLog.logDebug(szAux);
//@cassio }

/************************************************************************************************************/
DIR *OpenDir(char *pszDiretorio)
{
    static DIR *pDir;

    if( (pDir = opendir(pszDiretorio)) == NULL)
    {
        sprintf(szAux, "Erro abrindo diretorio [%s]. errno(%d) strerror[%s]", pszDiretorio, errno, strerror(errno));
        oLog.logError(szAux);
        sinalizaFinalProcesso();
        fflush(stdout);
        exit(-1);
    }

    return pDir;
}

/************************************************************************************************************/
char *ReadDir(DIR *pDir)
{
    static struct dirent *pDirent;
    static char szArq[512 + 1];

    while( (pDirent = readdir(pDir)) != NULL )
    {
        if( (!memcmp(pDirent->d_name+strlen(pDirent->d_name)-4,".TXT",4)) ||
            (!memcmp(pDirent->d_name+strlen(pDirent->d_name)-4,".txt",4)) )
        {
            strcpy(szArq, pDirent->d_name);
            sprintf(szAux, "Arquivo validado=[%s]", szArq); oLog.logDebug(szAux);

            return szArq;
        }
    }

    return NULL;
}

/************************************************************************************************************/
void CloseDir(DIR *pDir)
{
    closedir(pDir);
}

/************************************************************************************************************/
void moverArquivo(char *pszPathOrigem,char *pszPathDestino,char *pszFileName)
{
    char sComando[1024*2+16];
    char nmArquivoOrigem[1024];
    char nmArquivoDestino[1024];

    strcpy(nmArquivoOrigem, pszPathOrigem);
    //strcat(nmArquivoOrigem, "/");
    strcat(nmArquivoOrigem, pszFileName);

    strcpy(nmArquivoDestino, pszPathDestino);
    //strcat(nmArquivoDestino, "/");
    strcat(nmArquivoDestino, pszFileName);
    strcat(nmArquivoDestino, ".PROCESSADO");

    sprintf(sComando,"/usr/bin/mv -f %s %s", nmArquivoOrigem, nmArquivoDestino);

    oLog.logDebug(" Vai mover o arquivo");
    sprintf(szAux," Arquivo Origem [%s]", nmArquivoOrigem); oLog.logDebug(szAux);
    sprintf(szAux,"Arquivo Destino [%s]", nmArquivoDestino); oLog.logDebug(szAux);
    sprintf(szAux,"        Comando [%s]", sComando); oLog.logDebug(szAux);

    system(sComando);
}

/************************************************************************************************************/
FILE *abrirArquivo(char *pszPath, char *pszFileName)
{
    static FILE *pFileIn;
    static char szNomeArquivo[512 + 1];

    sprintf(szNomeArquivo, "%s/%s", pszPath, pszFileName);
    sprintf(szAux, "Abrindo arquivo[%s]", szNomeArquivo); oLog.logDebug(szAux);
    if((pFileIn = fopen(szNomeArquivo, "r")) == NULL) {
        sprintf(szAux, "Erro lendo arquivo[%s]", szNomeArquivo); oLog.logDebug(szAux);
        return NULL;
    }

    return pFileIn;
}

/************************************************************************************************************/
//char *lerArquivo(char *pszPath, char *pszFileName,FILE *pFileIn)
char *lerArquivo(FILE *pFileIn)
{
    //static FILE *pFileIn=NULL;
    //static char szNomeArquivo[512 + 1];
    static char szStringOut[256];

    //if(pFileIn == NULL) {
    //    sprintf(szNomeArquivo, "%s/%s", pszPath, pszFileName);
    //    sprintf(szAux, "Abrindo arquivo[%s]", szNomeArquivo); oLog.logDebug(szAux);
    //    if((pFileIn = fopen(szNomeArquivo, "r")) == NULL) {
    //        sprintf(szAux, "Erro lendo arquivo[%s]", szNomeArquivo); oLog.logDebug(szAux);
    //        return NULL;
    //    }
    //}

    //if(pszPath != NULL)
    //{
        if(fgets(szStringOut, sizeof(szStringOut), pFileIn) > 0)
        {
            // TrataDadosEntrada(szStringOut);
            szStringOut[strlen(szStringOut) - 1] = 0x00;
            return szStringOut;
        }
    //}
    //else
    //{
    //    sprintf(szAux, "Fechando arquivo de entrada[%s]", szNomeArquivo); oLog.logDebug(szAux);
    //    fclose(pFileIn);
    //    pFileIn=NULL;
    //}

    sprintf(szAux, "erro:%s",strerror(errno)); oLog.logDebug(szAux);

    return NULL;
}

/************************************************************************************************************/
void fecharArquivo(FILE *pFileIn)
{
    //sprintf(szAux, "Fechando arquivo de entrada[%s]", szNomeArquivo); oLog.logDebug(szAux);
    if ( pFileIn ) fclose(pFileIn);
}

/************************************************************************************************************/
void TrataDadosEntrada(char *pszBuffer)
{
    char szTmp[512 + 1];
    char *pTok;
    int iCount;

    strcpy(szTmp, pszBuffer);

    for(iCount=0, pTok = strtok(szTmp, "|"); pTok != NULL && iCount < 5; pTok = strtok(NULL, "|"), iCount++)
        strcpy(pszBuffer, pTok);

    pszBuffer[strlen(pszBuffer) - 1] = 0x00;
}

/************************************************************************************************************/
int geraArquivo(char *pszNrLinha, char *pszStatus, char *pszPath, char *pszFileName)
{
    static char szNomeArquivo[512 + 1];
    static FILE *pFile=NULL;
    static long iCounter=0;
    char szBuffer[512 + 1];

    if(pFile == NULL) {
        sprintf(szNomeArquivo, "%s%s.OUT", pszPath, pszFileName);
        sprintf(szAux, "Criando arquivo[%s]", szNomeArquivo); oLog.logDebug(szAux);
        if((pFile = fopen(szNomeArquivo, "w")) == NULL) {
            sprintf(szAux, "Erro criando arquivo[%s]", szNomeArquivo); oLog.logDebug(szAux);
            return -1;
        }
    }

    if(pszNrLinha != NULL)
    {
        sprintf(szAux, "Gravando linha no arquivo[%s]", szNomeArquivo); oLog.logDebug(szAux);
        sprintf(szBuffer, "%06d - %s - %s\n", ++iCounter, pszNrLinha, pszStatus);
        if(fputs(szBuffer, pFile) <= 0) {
            sprintf(szAux, "Erro gravando linha no arquivo[%s]", szNomeArquivo); oLog.logDebug(szAux);
            return -1;
        }
    }
    else
    {
        sprintf(szAux, "Fechando arquivo de saida[%s]", szNomeArquivo); oLog.logDebug(szAux);
        fclose(pFile);
        pFile=NULL;
        iCounter=0;
    }

    return 0;
}

/************************************************************************************************************/
bool processoEmExecucaoSN(const char *pszFileName)
{
    key = ENVIA_NGIN_KEY;

    if ((shmid = shmget(key, ENVIA_NGIN_SHMZ, 0666)) < 0) {
        if ((shmid = shmget(key, ENVIA_NGIN_SHMZ, IPC_CREAT | 0666)) < 0) {
            cerr<<"shmget";
            fflush(stdout);
            exit(1);
        }
    }

    if ((shm = (char *)shmat(shmid, 0, 0)) == (char *) -1) {
        cerr<<"shmat";
        fflush(stdout);
        exit(1);
    }

    if ( *shm == ENVIA_NGIN_VALUE )
    {
        return true;
    }

    *shm=ENVIA_NGIN_VALUE;

    return false;
}

/************************************************************************************************************/
void sinalizaFinalProcesso()
{
    if ( bOutraInstanciaNoAr == false )
    {
        if ( shm )
        {
            *shm=0; 
            if ( shmdt(shm) == -1 )
            {
                oLog.logDebug("** SHARED BUFFER ERROR - DETACHMENT **\n");
            }
            else
            {
                if ( shmctl(shmid,IPC_RMID,0) < 0 )
                {
                    oLog.logDebug("** SHARED BUFFER ERROR - REMOVE **\n");
                }
                else
                {
                    oLog.logDebug("** SHARED BUFFER FREED **\n");
                }
            }
        }
    }
}

/************************************************************************************************************/
void catcher(int iSig)
{
    signal(iSig, catcher);

    switch (iSig)
    {
        case SIGHUP:
            oLog.logInformation("*** SIGHUP ***\n");
            iSignalProcessa=0;
        break;
        case SIGIOT:
            oLog.logInformation("*** SIGIOT ***\n");
            iSignalProcessa=0;
        break;
        case SIGEMT:
            oLog.logInformation("*** SIGEMT ***\n");
            iSignalProcessa=0;
        break;
        case SIGFPE:
            oLog.logInformation("*** SIGFPE ***\n");
            iSignalProcessa=0;
        break;
        case SIGBUS:
            oLog.logInformation("*** SIGBUS ***\n");
            iSignalProcessa=0;
        break;
        case SIGSEGV:
            oLog.logInformation("*** SIGSEGV ***\n");
            iSignalProcessa=0;
        break;
        case SIGSYS:
            oLog.logInformation("*** SIGSYS ***\n");
            iSignalProcessa=0;
        break;
        case SIGSTOP:
            oLog.logInformation("*** SIGSTOP ***\n");
            iSignalProcessa=0;
        break;
        case SIGCHLD:
            oLog.logInformation("*** SIGCHLD ***\n");
            iSignalProcessa=0;
        break;
        case SIGKILL:
            oLog.logInformation("*** SIGKILL ***\n");
            iSignalProcessa=0;
        break;
        case SIGINT:
            oLog.logInformation("*** SIGINT ***\n");
            iSignalProcessa=0;
        break;
        case SIGQUIT:
            oLog.logInformation("*** SIGQUIT ***\n");
            iSignalProcessa=0;
        break;
        case SIGTRAP:
            oLog.logInformation("*** SIGTRAP ***\n");
            iSignalProcessa=0;
        break;
        case SIGTERM:
            oLog.logInformation("*** SIGTERM ***\n");
            iSignalProcessa=0;
        break;
        case SIGTSTP:
            oLog.logInformation("*** SIGTSTP ***\n");
            iSignalProcessa=0;
        break;
        case SIGTTIN:
            oLog.logInformation("*** SIGTTIN ***\n");
            iSignalProcessa=0;
        break;
        // TESTE CASSIO -->
        case SIGALRM:
            {
                oLog.logInformation("*** @@@ SIGALRM @@@ ***\n");
                alarm(2);
                char *p = ObtemParametro("TEMPO_WAIT_ENVIANGIN");
                int tempoSleepNew = atoi(p==0?"60":p);
                
                sprintf(szAux,"tempo sleep(new)=%d\n",tempoSleepNew); oLog.logDebug(szAux);
                sprintf(szAux,"tempo sleep(old)=%d\n",tempoSleep); oLog.logDebug(szAux);

                if ( tempoSleepNew != tempoSleep )
                {
                    tempoSleep = tempoSleepNew;
                    sprintf(szAux,"tempo sleep (2) =%d\n",tempoSleep); oLog.logDebug(szAux);
                }
            }
        break;
        // <-- TESTE CASSIO
        default:
            sprintf(szAux, "catcher signal(%d)\n", iSig);
            oLog.logInformation(szAux);
            iSignalProcessa=0;
        break;
    }
}
