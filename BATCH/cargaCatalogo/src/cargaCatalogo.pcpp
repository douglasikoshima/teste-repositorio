/*
 * cargaCatalogo.pcpp
 *
 *  Created on: 13/11/2012
 *      Author: Jones Randis
 */


#include <exception>
#include <iostream>
#include <string>
#include <sstream>
#include <fstream>
#include <memory>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cerrno>
using namespace std;

extern "C" {
#include <libgen.h>
#include <dirent.h>
#include <unistd.h>
#include <sqlca.h>
}

#include "cargaCatalogo.h"

int main(int argC, char *argV[])
{
	char* me = basename(argV[0]);

	try
	{
		string configFile = me + string(".cfg");

		CCargaCatalogo::log() << ">>>" << me << endl;
		CCargaCatalogo CC(configFile);
		CC.Run();
		CCargaCatalogo::log() << "<<<" << me << endl;
	}
	catch(exception& e)
	{
		CCargaCatalogo::log() << "Processo finalizado com erro: " << e.what() << endl;
		CCargaCatalogo::log() << "<<<" << me << endl;
		return EXIT_FAILURE;
	}
	catch(...)
	{
		CCargaCatalogo::log() << "Processo finalizado com erro!" << endl;
		CCargaCatalogo::log() << "<<<" << me << endl;
		return EXIT_FAILURE;
	}

	return EXIT_SUCCESS;
}


CCargaCatalogo::CCargaCatalogo(string& configFile) :
	ExceptionConfigFile("Erro ao ler arquivo de configuracao!"),
	ExceptionConfigParam("Parametros incompletos!"),
	ExceptionParamDatabase("Parametro usr_db e/ou pwd_db invalido!"),
	ExceptionParamControlFile("Parametro control_file invalido!"),
	ExceptionPathDir("Erro ao ler diretorio path!"),
	ExceptionControlFile("Erro ao ler arquivo de controle!"),
	ExceptionSqlldrExec("Erro ao executar sqlldr!"),
	ExceptionDatabaseConnect("Erro ao conectar no banco de dados!"),
	ExceptionDatabaseDisonnect("Erro ao desconectar do banco de dados!"),
	ExceptionDatabaseCreateTable("Erro ao criar tabela LOAD.CARGA_CATALOGO_CRM!"),
	ExceptionDatabaseSqlError("Erro ao executar query SQL!"),
	ExceptionIdSistemaOrigem("Nao foi possivel obter IDSISTEMAORIGEM!"),
	ExceptionRenameOut("Erro ao renomear externsao para .out!"),
	connected(false)
{
	GetParamConf(configFile);
}

CCargaCatalogo::~CCargaCatalogo()
{
	DBDisconnect();
}

void CCargaCatalogo::GetParamConf(string& configFile)
{
	log() << "Obtendo parametros de configuracao..." << endl;

	ifstream file(configFile.c_str());
	if (file.fail()) {
		log() << "ERRO ifstream: " << configFile << " - " << strerror(errno) << endl;
		throw ExceptionConfigFile;
	}

	string buff;
	while( file.good() )
	{
		getline(file, buff);

		if (buff.empty() && file.eof())
			break;

		if (!buff.empty() && *buff.rbegin() == '\r')
				buff.resize(buff.size() - 1);

		istringstream line(buff);
		string key, val;
		getline(line, key, '=');
		getline(line, val);

		if (key == "usr_db")
			ParamConf.usr_db = auto_ptr<string> (new string(val));

		if (key == "pwd_db")
			ParamConf.pwd_db = auto_ptr<string> (new string(val));

		if (key == "inst_db")
			ParamConf.inst_db = auto_ptr<string> (new string(val));

		if (key == "path")
			ParamConf.path = auto_ptr<string> (new string(val));

		if (key == "control_file")
			ParamConf.control_file = auto_ptr<string> (new string(val));
	}
	file.close();

	if ( !ParamConf.verify() )
		throw ExceptionConfigParam;

	//if ( ParamConf.usr_db.get()->empty() || ParamConf.pwd_db.get()->empty() )
	//	throw ExceptionParamDatabase;

	if ( ParamConf.control_file.get()->empty() )
		throw ExceptionParamControlFile;

	if ( access(ParamConf.control_file.get()->c_str(), R_OK) ) {
		log() << "ERRO access: " << *ParamConf.control_file << " - " << strerror(errno) << endl;
		throw ExceptionControlFile;
	}

	stringstream conn_str;
	//if ( !ParamConf.usr_db.get()->empty() && !ParamConf.pwd_db.get()->empty() )
		conn_str << *ParamConf.usr_db << "/" << *ParamConf.pwd_db;

	if ( !ParamConf.inst_db.get()->empty() )
		conn_str << "@" << *ParamConf.inst_db; 	// ,setenv("TWO_TASK", ParamConf.inst_db.get()->c_str(), 1);

	this->conn_str = conn_str.str();
}

void CCargaCatalogo::Run()
{
	log() << "Executando..." << endl;

	if ( !OpenDir() )
		return;

	DBConnect();
	DBCreateTable();
	LoadFiles();
}

bool CCargaCatalogo::OpenDir()
{
	DIR* pathdir = opendir(ParamConf.path.get()->c_str());
	if ( !pathdir ) {
		log() << "ERRO opendir: " << *ParamConf.path << " - " << strerror(errno) << endl;
		throw ExceptionPathDir;
	}

	string ext(DATAFILE_EXT);
	std::transform( ext.begin(), ext.end(), ext.begin(), ::toupper );

	struct dirent* pdir;
	while ( (pdir = readdir(pathdir)) ) {
		string ent(pdir->d_name);
		std::transform( ent.begin(), ent.end(), ent.begin(), ::toupper );

		size_t found = ent.rfind(ext);
		if ( found != string::npos && (ent.size() - int(found)) == ext.size() )
			data_files.push_back(*ParamConf.path + string("/") + pdir->d_name);
	}
	closedir( pathdir );

	if ( !data_files.size() ) {
		log() << "Nao ha arquivos *" << DATAFILE_EXT << " para carga em " << *ParamConf.path << endl;
		return false;
	}

	return true;
}

void CCargaCatalogo::DBConnect()
{
	EXEC SQL BEGIN DECLARE SECTION;
	char connString[256];
	EXEC SQL END DECLARE SECTION;

	strncpy(connString, conn_str.c_str(), sizeof(connString));

	log() << "Conectando em " << *ParamConf.usr_db << "@" << *ParamConf.inst_db << endl;

	EXEC SQL WHENEVER SQLERROR GOTO ERRCONN;
	EXEC SQL CONNECT :connString;
	connected = true;

	log() << "Conectado com sucesso!" << endl;

	return;
	ERRCONN:
		log() << "ERRO ORACLE: sqlcode=" << sqlca.sqlcode << ", sqlerrmc=" << sqlca.sqlerrm.sqlerrmc << endl;
		throw ExceptionDatabaseConnect;
}

void CCargaCatalogo::DBDisconnect()
{
	if ( !connected )
		return;

	EXEC SQL WHENEVER SQLERROR GOTO ERRDISCONN;
    EXEC SQL COMMIT WORK RELEASE;
    connected = false;

    return;
    ERRDISCONN:
    	log() << "ERRO ORACLE: sqlcode=" << sqlca.sqlcode << ", sqlerrmc=" << sqlca.sqlerrm.sqlerrmc << endl;
    	throw ExceptionDatabaseDisonnect;
}


void CCargaCatalogo::DBCreateTable()
{
	EXEC SQL BEGIN DECLARE SECTION;
		int table_exists=0;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR GOTO ERRDDL;

	EXEC SQL SELECT COUNT(1) INTO :table_exists FROM ALL_TABLES WHERE UPPER(OWNER) = 'LOAD' AND UPPER(TABLE_NAME) = 'CARGA_CATALOGO_CRM';

	if ( !table_exists )
	{
		log() << "Criando tabela LOAD.CARGA_CATALOGO_CRM..." << endl;
		EXEC SQL CREATE TABLE LOAD.CARGA_CATALOGO_CRM
		(
			CDINTEGRACAO 			VARCHAR2(255) 	NOT NULL,
			CDSISTEMAORIGEM 		VARCHAR2(255) 	NOT NULL,
			NMSISTEMAORIGEM 		VARCHAR2(255) 	NOT NULL,
			NMCOMERCIALSERVICO 		VARCHAR2(255) 	NOT NULL,
			CDTIPOSERVICO 			VARCHAR2(255) 	NOT NULL,
			DSTIPOSERVICO 			VARCHAR2(255) 	NOT NULL,
			CDFAMILIASERVICO 		VARCHAR2(255) 	NOT NULL,
			DSFAMILIASERVICO 		VARCHAR2(255) 	NOT NULL
		);
	}

	return;
	ERRDDL:
		log() << "ERRO ORACLE: sqlcode=" << sqlca.sqlcode << ", sqlerrmc=" << sqlca.sqlerrm.sqlerrmc << endl;
		throw ExceptionDatabaseCreateTable;
}

void CCargaCatalogo::LoadFiles()
{
	EXEC SQL BEGIN DECLARE SECTION;
		int reg_count=0;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR GOTO ERRSQL;

	int retcd;
	string datafile_ext(DATAFILE_EXT);
	string logfile;
	string badfile;
	string outfile;

	for(it_vec_str = data_files.begin(); it_vec_str != data_files.end(); it_vec_str++ )
	{
		// SQLLDR
		stringstream sqlldr;
		sqlldr << "sqlldr ";
		sqlldr << conn_str;
		sqlldr << " CONTROL=" << *ParamConf.control_file;

		// DATA=
		sqlldr << " DATA=" << *it_vec_str;

		// LOG=
		logfile = *it_vec_str;
		logfile.resize(logfile.size() - datafile_ext.size());
		logfile.append(LOGFILE_EXT);
		sqlldr << " LOG=" << logfile;

		// BAD=
		badfile = *it_vec_str;
		badfile.resize(badfile.size() - datafile_ext.size());
		badfile.append(BADFILE_EXT);
		sqlldr << " BAD=" << badfile;

#ifdef OPT_SP_TRUNCCATALOGO
		log() << "Executando LOAD.SP_TRUNCCATALOGO..." << endl;
		EXEC SQL EXECUTE IMMEDIATE 'CALL LOAD.SP_TRUNCCATALOGO()';
#endif

		log() << "Carregando arquivo " << *it_vec_str << endl;

		log() << "Executando SQL*Loader..." << endl;
		retcd = system( sqlldr.str().c_str() );

		if (retcd && (retcd & 127)) {
			log() << "SQL*Loader: morto com sinal " << (retcd & 127) << ", " << (retcd & 128 ? "com" : "sem") << " arquivo de coredump!" << endl;
		} else {
			switch(retcd >> 8) {
			case EX_SUCC:
				log() << "SQL*Loader: executado com sucesso." << endl;
				break;
			case EX_FAIL:
				log() << "SQL*Loader: executado com EX_FAIL, verifique o arquivo de log " << logfile << endl;
				break;
			case EX_WARN:
				log() << "SQL*Loader: executado com EX_WARN, verifique o arquivo de log " << logfile << endl;
				break;
			case EX_FTL:
				log() << "SQL*Loader: executado com erro fatal!" << endl;
				break;
			default:
				log() << "SQL*Loader: codigo de retorno desconhecido!" << endl;
				break;
			}
		}

		EXEC SQL SELECT COUNT(1) INTO :reg_count FROM LOAD.CARGA_CATALOGO_CRM;

		if ( !reg_count ) {
			log() << "Nao ha registros para carga em " << *it_vec_str << endl;
			continue;
		}

		log() << "Arquivo " << *it_vec_str << ": " << reg_count << " registros carregados." << endl;

		DBLoadTable();

		outfile = *it_vec_str;
		outfile.resize(outfile.size() - datafile_ext.size());
		outfile.append(OUTFILE_EXT);

		if (rename(it_vec_str->c_str(), outfile.c_str()))
		{
			log() << "Erro rename: " << outfile << " - " << strerror(errno) <<  endl;
			throw ExceptionRenameOut;
		}
	}

#ifdef OPT_SP_TRUNCCATALOGO
	if (reg_count) {
		log() << "Executando LOAD.SP_TRUNCCATALOGO..." << endl;
		EXEC SQL EXECUTE IMMEDIATE 'CALL LOAD.SP_TRUNCCATALOGO()';
	}
#endif

	return;
	ERRSQL:
		log() << "ERRO ORACLE: sqlcode=" << sqlca.sqlcode << ", sqlerrmc=" << sqlca.sqlerrm.sqlerrmc << endl;
		throw ExceptionDatabaseSqlError;
}

void CCargaCatalogo::DBLoadTable()
{
	EXEC SQL BEGIN DECLARE SECTION;
	struct {
		VARCHAR CDINTEGRACAO[255];
		VARCHAR CDSISTEMAORIGEM[255];
		VARCHAR NMSISTEMAORIGEM[255];
		VARCHAR NMCOMERCIALSERVICO[255];
		VARCHAR CDTIPOSERVICO[255];
		VARCHAR DSTIPOSERVICO[255];
		VARCHAR CDFAMILIASERVICO[255];
		VARCHAR DSFAMILIASERVICO[255];
	} carga_row;
	VARCHAR rowid[255];
	int INPLANO=0;
	VARCHAR IDSISTEMAORIGEM[40];
	VARCHAR IDTIPOLINHA[40];
	int IDUSUARIOALTERACAO=ID_USUARIO_ALTERACAO;
	EXEC SQL END DECLARE SECTION;

    int regc=0;

	EXEC SQL WHENEVER SQLERROR GOTO ERRSQL;

    EXEC SQL DECLARE cCargaCatalogo CURSOR FOR
    	SELECT
    		CDINTEGRACAO,
    		CDSISTEMAORIGEM,
    		NMSISTEMAORIGEM,
    		NMCOMERCIALSERVICO,
    		CDTIPOSERVICO,
    		DSTIPOSERVICO,
    		CDFAMILIASERVICO,
    		DSFAMILIASERVICO
    	FROM
    		LOAD.CARGA_CATALOGO_CRM;


    EXEC SQL OPEN cCargaCatalogo;

    log() << "Processando registros carregados em LOAD.CARGA_CATALOGO_CRM..." << endl;

	// Para cada registro do arquivo
    while(true)
    {
    	EXEC SQL WHENEVER NOT FOUND DO BREAK;
    	EXEC SQL FETCH cCargaCatalogo INTO 	:carga_row;

    	ENDORASTR( carga_row.CDINTEGRACAO );
    	ENDORASTR( carga_row.CDSISTEMAORIGEM );
    	ENDORASTR( carga_row.NMSISTEMAORIGEM );
    	ENDORASTR( carga_row.NMCOMERCIALSERVICO );
    	ENDORASTR( carga_row.CDTIPOSERVICO );
    	ENDORASTR( carga_row.DSTIPOSERVICO );
    	ENDORASTR( carga_row.CDFAMILIASERVICO );
    	ENDORASTR( carga_row.DSFAMILIASERVICO );

    	regc++;

		EXEC SQL WHENEVER NOT FOUND CONTINUE;

		// Obtendo IDSISTEMAORIGEM
		EXEC SQL
			SELECT
				IDSISTEMAORIGEM
			INTO
				:IDSISTEMAORIGEM
			FROM
				APOIO.SISTEMAORIGEM
			WHERE
				SGSISTEMAORIGEM = DECODE(:carga_row.CDSISTEMAORIGEM, 8, 'ATS', 9, 'CSO', :carga_row.CDSISTEMAORIGEM);

		if (sqlca.sqlcode) {
			log() << "ERRO: Nao ha IDSISTEMAORIGEM para CDSISTEMAORIGEM=" << (const char*)carga_row.CDSISTEMAORIGEM.arr << endl;
		    EXEC SQL CLOSE cCargaCatalogo;
			throw ExceptionIdSistemaOrigem;
		}

    	// Verificar se o valor do campo Codigo do Tipo de Serviço e igual a '1' (representa LINHA)
    	if (string((const char*)carga_row.CDTIPOSERVICO.arr) == "1")
    	{
    		// Verificar na tabela APOIO.TIPOLINHA
			EXEC SQL
				SELECT
					ROWID,
					IDTIPOLINHA
				INTO
					:rowid,
					:IDTIPOLINHA
				FROM
					APOIO.TIPOLINHA
				WHERE
					SGTIPOLINHA = :carga_row.CDFAMILIASERVICO;

			if (sqlca.sqlcode) {
				// Caso nao exista, inserir um novo registro

				EXEC SQL
					SELECT
						APOIO.TIPOLINHASQ.NEXTVAL
					INTO
						:IDTIPOLINHA
					FROM
						DUAL;

				EXEC SQL
					INSERT
					INTO APOIO.TIPOLINHA
						(IDTIPOLINHA,
						 SGTIPOLINHA,
						 DSTIPOLINHA,
						 IDCLASSIFICACAOTIPOLINHA,
						 SGTECNOLOGIA,
						 IDUSUARIOALTERACAO,
						 DTULTIMAALTERACAO)
					VALUES
						(:IDTIPOLINHA,
						 :carga_row.CDFAMILIASERVICO,
						 :carga_row.DSFAMILIASERVICO,
						 'OUT',
						 'NC',
						 :IDUSUARIOALTERACAO,
						 SYSDATE);
			} else {
				// Caso exista, atualiza-lo
				EXEC SQL
					UPDATE
						APOIO.TIPOLINHA
					SET
						DSTIPOLINHA = :carga_row.DSFAMILIASERVICO,
						IDUSUARIOALTERACAO = :IDUSUARIOALTERACAO,
						DTULTIMAALTERACAO = SYSDATE
					WHERE
						ROWID = :rowid;
			}

			// Verificar na tabela APOIO.SUBTIPOLINHA
	    	EXEC SQL
	    		SELECT
	    			ROWID
	    		INTO
	    			:rowid
				FROM
					APOIO.SUBTIPOLINHA SUBTIPOLINHA
				WHERE
					SUBTIPOLINHA.IDSISTEMAORIGEM = :IDSISTEMAORIGEM
				AND
					SUBTIPOLINHA.CDSUBTIPOLINHA = :carga_row.CDINTEGRACAO;

	    	if (sqlca.sqlcode) {
	    		// Caso nao exista, inserir um novo registro
	    		EXEC SQL
	    			INSERT
	    			INTO APOIO.SUBTIPOLINHA
	    				(IDSUBTIPOLINHA,
	    				 IDSISTEMAORIGEM,
	    				 CDSUBTIPOLINHA,
	    				 IDTIPOLINHA,
	    				 DSSUBTIPOLINHA,
	    				 IDUSUARIOALTERACAO,
	    				 DTULTIMAALTERACAO)
	    			VALUES
	    				(APOIO.SUBTIPOLINHASQ.NEXTVAL,
	    				 :IDSISTEMAORIGEM,
	    				 :carga_row.CDINTEGRACAO,
	    				 :IDTIPOLINHA,
	    				 :carga_row.NMCOMERCIALSERVICO,
	    				 :IDUSUARIOALTERACAO,
	    				 SYSDATE);
	    	} else {
	    		// Caso exista, atualiza-lo
	    		EXEC SQL
	    			UPDATE
	    				APOIO.SUBTIPOLINHA
	    			SET
	    				IDTIPOLINHA = :IDTIPOLINHA,
	    				DSSUBTIPOLINHA = :carga_row.NMCOMERCIALSERVICO,
	    				IDUSUARIOALTERACAO = :IDUSUARIOALTERACAO,
	    				DTULTIMAALTERACAO = SYSDATE
	    			WHERE
	    				ROWID = :rowid;
	    	}
    	}
    	else
    	{
    		// Verificar na tabela TIPOPLANOSERVICO
			EXEC SQL
				SELECT
					ROWID
				INTO
					:rowid
				FROM
					APOIO.TIPOPLANOSERVICO
				WHERE
					CDTIPOPLANOSERVICO = :carga_row.CDTIPOSERVICO;

			if (sqlca.sqlcode) {
				// Caso nao exista, inserir um novo registro
				EXEC SQL
					INSERT
					INTO APOIO.TIPOPLANOSERVICO
						(CDTIPOPLANOSERVICO,
						 NMTIPOPLANOSERVICO,
						 IDUSUARIOALTERACAO,
						 DTULTIMALTERACAO)
					VALUES
						(:carga_row.CDTIPOSERVICO,
						 :carga_row.DSTIPOSERVICO,
						 :IDUSUARIOALTERACAO,
						 SYSDATE);
			} else {
				// Caso exista, atualizá-lo
				EXEC SQL
					UPDATE
						APOIO.TIPOPLANOSERVICO
					SET
						NMTIPOPLANOSERVICO = :carga_row.DSTIPOSERVICO,
						IDUSUARIOALTERACAO = :IDUSUARIOALTERACAO,
						DTULTIMALTERACAO = SYSDATE
					WHERE
						ROWID = :rowid;
			}

	    	// Verificar na tabela PLANOSERVICO
	    	EXEC SQL
	    		SELECT
	    			ROWID
	    		INTO
	    			:rowid
				FROM
					LINHA.PLANOSERVICO PLANOSERVICO
				WHERE
					PLANOSERVICO.IDSISTEMAORIGEM = :IDSISTEMAORIGEM
				AND
					PLANOSERVICO.SGSERVICO = :carga_row.CDINTEGRACAO;

			// Se valor do Código do Tipo de Serviço igual a 20, INPLANO=1, caso contrário INPLANO=0
			INPLANO = string((const char*)carga_row.CDTIPOSERVICO.arr) == "20" ? 1 : 0;

			if (sqlca.sqlcode) {
				// Caso nao exista, inserir um novo registro
				EXEC SQL
					INSERT
					INTO LINHA.PLANOSERVICO
						(IDSERVICO,
						 SGSERVICO,
						 NMSERVICO,
						 IDSISTEMAORIGEM,
						 TSSINCRONISMO,
						 SQSINCRONISMO,
						 INPLANO,
						 IDSERVICOSISTEMAORIGEM,
						 IDUSUARIOALTERACAO,
						 DTULTIMAALTERACAO,
						 CDTIPOPLANOSERVICO)
					VALUES
						(LINHA.PLANOSERVICOSQ.NEXTVAL,
						 :carga_row.CDINTEGRACAO,
						 :carga_row.NMCOMERCIALSERVICO,
						 :IDSISTEMAORIGEM,
						 TO_NUMBER(TO_CHAR(SYSDATE, 'yyyymmddhh24miss')),
						 1,
						 :INPLANO,
						 :carga_row.CDINTEGRACAO,
						 :IDUSUARIOALTERACAO,
						 SYSDATE,
						 :carga_row.CDTIPOSERVICO);
			} else {
				// Caso exista, atualiza-lo
				EXEC SQL
					UPDATE
						LINHA.PLANOSERVICO
					SET
						NMSERVICO = :carga_row.NMCOMERCIALSERVICO,
						TSSINCRONISMO = TO_NUMBER(TO_CHAR(SYSDATE, 'yyyymmddhh24miss')),
						SQSINCRONISMO = (SQSINCRONISMO + 1),
						IDUSUARIOALTERACAO = :IDUSUARIOALTERACAO,
						DTULTIMAALTERACAO = SYSDATE,
						CDTIPOPLANOSERVICO = :carga_row.CDTIPOSERVICO,
						INPLANO = :INPLANO
					WHERE
						ROWID = :rowid;
			}
    	}

    	if ( !(regc % 100) )
    		log() << regc << " Registros processados." << endl;
    }

    EXEC SQL CLOSE cCargaCatalogo;

    log() << regc << " Registros processados." << endl;
    log() << "Registros processados com sucesso em LOAD.CARGA_CATALOGO_CRM." << endl;

    log() << "Executando COMMIT." << endl;
    EXEC SQL COMMIT WORK;
	return;

	ERRSQL:
		log() << "ERRO ORACLE: sqlcode=" << sqlca.sqlcode << ", sqlerrmc=" << sqlca.sqlerrm.sqlerrmc << endl;
		log() << "Executando ROLLBACK!" << endl;
		EXEC SQL ROLLBACK WORK;
		throw ExceptionDatabaseSqlError;
}


