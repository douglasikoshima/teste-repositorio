
#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
#include<ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifndef WIN32
#include <unistd.h>
#endif

#include "atmi.h"

#include "../include/ativarAparelhoPC.h"
#include "../include/ativarAparelhoSt.h"
#include "../include/ativarAparelhoException.h"

#define TAG_ENCODING "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>"

CAtivarAparelhoPC::CAtivarAparelhoPC()
{
    rcvlen = 1024 * 256;

    tuxedoIniciado = false;

    conectado = false;

    strcpy(xmlHeader,TAG_ENCODING);

    rcvbuftmp = new char[rcvlen+strlen(xmlHeader)+1];

    rcvbuf = (char*)tpalloc("STRING", NULL, rcvlen+1);

    sendbuf = 0;
    pszXmlAux = 0;

    memset( &parametrosCOMSAP, 0x0, sizeof(parametrosCOMSAP) );

}



CAtivarAparelhoPC::~CAtivarAparelhoPC()
{
    if ( sendbuf ) tpfree(sendbuf);
    if ( rcvbuf ) tpfree(rcvbuf);

    delete[] rcvbuftmp;
    delete[] pszXmlAux;

    rcvbuftmp = 0;
    sendbuf = 0;
    rcvbuf = 0;
    pszXmlAux = 0;
}



void CAtivarAparelhoPC::processaBatch()
{
    int qtdeProcessados = 0;

    string xmlToSend;
    struct sqlca sqlca;

    try
    {
        Propriedade prop("ativarAparelho.cfg");

        EXEC SQL BEGIN DECLARE SECTION;
            char szConnStr[512];
            
            VARCHAR idPessoa[64];
            short i_idPessoa = -1;
			VARCHAR idGrupo[64];
			short i_idGrupo = -1;
			VARCHAR nmPessoa[256];
			short i_nmPessoa = -1;
			VARCHAR nrLinha[32];
			short i_nrLinha = -1;
			VARCHAR idSegmentacao[64];
			short i_idSegmentacao = -1;
			VARCHAR idRetencao[64];
			short i_idRetencao = -1;

			VARCHAR nmPessoaEntrega[256];
			short i_nmPessoaEntrega = -1;
			VARCHAR dsDocumentoEntrega[256];
			short i_dsDocumentoEntrega = -1;
			VARCHAR dsEnderecoEntrega[256];
			short i_dsEnderecoEntrega = -1;
			VARCHAR dsBairroEntrega[256];
			short i_dsBairroEntrega = -1;
			VARCHAR dsCidadeEntrega[256];
			short i_dsCidadeEntrega = -1;
			VARCHAR dsCEPEntrega[256];
			short i_dsCEPEntrega = -1;
			VARCHAR dsEstadoEntrega[256];
			short i_dsEstadoEntrega = -1;
			VARCHAR dsPaisEntrega[256];
			short i_dsPaisEntrega = -1;

			VARCHAR nmPessoaCliente[256];
			short i_nmPessoaCliente = -1;
			VARCHAR dsDocumentoCliente[256];
			short i_dsDocumentoCliente = -1;
			VARCHAR dsEnderecoCliente[256];
			short i_dsEnderecoCliente = -1;
			VARCHAR dsBairroCliente[256];
			short i_dsBairroCliente = -1;
			VARCHAR dsCidadeCliente[256];
			short i_dsCidadeCliente = -1;
			VARCHAR dsCEPCliente[256];
			short i_dsCEPCliente = -1;
			VARCHAR dsEstadoCliente[256];
			short i_dsEstadoCliente = -1;
			VARCHAR dsPaisCliente[256];
			short i_dsPaisCliente = -1;

			VARCHAR nmValor[64];
			short i_nmValor = -1;
			VARCHAR nrOrdemVenda[64];
			short i_nrOrdemVenda = -1;
			VARCHAR idTipoPagamento[12];
			short i_idTipoPagamento = -1;
			VARCHAR dtRemessa[32];
			short i_dtRemessa = -1;
			VARCHAR dsObservacao[256];
			short i_dsObservacao = -1;
			VARCHAR nrLinhaRecado[32];
			short i_nrLinhaRecado = -1;
			
			VARCHAR idMatrizAparelho[32];
			short i_idMatrizAparelho = -1;
			VARCHAR idAparelhoCor[32];
			short i_idAparelhoCor = -1;
			
			

        EXEC SQL END DECLARE SECTION;

        char *szPws = prop.getParametro("pwd_db");
        char *szUsr = prop.getParametro("usr_db");
        char *szPath= prop.getParametro("path");
        char *szInst= prop.getParametro("inst_db");

        char *szUsr_tux = prop.getParametro("usr_tux");
        char *szPwd_tux = prop.getParametro("pwd_tux");
        char *szPwd_tux_gen = prop.getParametro("pwd_tux_gen");
        char *szClt_tux = prop.getParametro("clt_tux");

        int vlLog = atoi( prop.getParametro("log") );
        vlLog = vlLog == 0 ? DEBUG : vlLog;

        sprintf(linha,"szPws=%s",szPws); 
        logFile.logInformation(linha); 

        sprintf(linha,"szUsr=%s",szUsr);
        logFile.logInformation(linha);

        sprintf(linha,"szPath=%s",szPath);
        logFile.logInformation(linha);

        sprintf(linha,"szInst=%s",szInst);
        logFile.logInformation(linha); 

        sprintf(linha,"szUsr_tux=%s",szUsr_tux);
        logFile.logInformation(linha); 

        sprintf(linha,"szPwd_tux=%s",szPwd_tux); 
        logFile.logInformation(linha); 

        sprintf(linha,"szPwd_tux_gen=%s",szPwd_tux_gen); 
        logFile.logInformation(linha); 

        sprintf(linha,"szClt_tux=%s",szClt_tux); 
        logFile.logInformation(linha); 

        sprintf(linha,"vlLog=%i",vlLog); 
        logFile.logInformation(linha); 

        // Verifica se todos os dados foram recuperados do arquivo de configuração.
        if (!szPws || !szUsr || !szPath || !szInst || vlLog == 0)
        {
            logFile.logInformation("vai lancar exceçao"); //@cassio
            throw new CAtivarAparelhoException(ERR_BATCH_PARAMETROSINCOMPLETOS);
        }

        logFile.logInformation("vai setar nivel de log"); //@cassio

        logFile.setNivel( vlLog );

        logFile.logInformation("vai conectar ao BD"); //@cassio
        // Conecta no banco de dados
        sprintf(szConnStr, "%s/%s@%s", szUsr, szPws, szInst);
        EXEC SQL CONNECT :szConnStr;

        logFile.logInformation("conectou ao BD"); //@cassio

        if (sqlca.sqlcode)
        {
            sprintf(linha,"Falha na conexão ao BD %d:%s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
            throw new CAtivarAparelhoException(ERR_BATCH_CONEXAO,linha,__FILE__,__LINE__);
        }

        // se der exceção a partir deste ponto então a conexão será tratada
        conectado = true;

        // conexta ao Tuxedo
        iniciarTuxedo(szUsr_tux,szClt_tux,szPwd_tux,szPwd_tux_gen);

        EXEC SQL BEGIN DECLARE SECTION;

        EXEC SQL END DECLARE SECTION;

        EXEC SQL WHENEVER NOT FOUND CONTINUE;

        //==========================================================================
        // Obtém parametros dinâmicos de execução


        //==========================================================================
        // Processa
        //while ( true )
        //{
            /*
            if ( obterProxIdLinhaTelefonica() == false )
            {
                break;
            }
            */

            // Contador do numero de linhas telefônicas processadas
            qtdeProcessados++;

            // Vai tentar obter os dados da linha junto ao Atlys
            try
            {
				EXEC SQL DECLARE CrsAparelhos CURSOR FOR
				SELECT retencaoconsolidada.idpessoadepara, retencaoconsolidada.idgrupo,
				       retencaoconsolidada.nmpessoa, retencaoconsolidada.nrlinha,
				       retencaoconsolidada.idsegmentacao, retencaoconsolidada.idretencao
				  FROM retencao.retencaoconsolidada
				 WHERE retencaoconsolidada.inprocessado = 0
				 AND   ROWNUM < 3;

				EXEC SQL WHENEVER NOT FOUND DO BREAK;
				EXEC SQL OPEN CrsAparelhos;
				for ( ;; )
				{
					EXEC SQL FETCH CrsAparelhos INTO :idPessoa:i_idPessoa ,
						                             :idGrupo:i_idGrupo ,
						                             :nmPessoa:i_nmPessoa ,
						                             :nrLinha:i_nrLinha ,
						                             :idSegmentacao:i_idSegmentacao ,
						                             :idRetencao:i_idRetencao ;

		            qtdeProcessados++;
		            
			        endOraStr( idPessoa );
					strcpy( parametrosCOMSAP.idPessoa, (char *)idPessoa.arr );
					
			        endOraStr( idGrupo );
					strcpy( parametrosCOMSAP.idGrupo, (char *)idGrupo.arr );
			        
			        endOraStr( nmPessoa );
					strcpy( parametrosCOMSAP.nmCliente, (char *)nmPessoa.arr );
			        
			        endOraStr( nrLinha );
					strcpy( parametrosCOMSAP.nrLinha, (char *)nrLinha.arr );
					
			        endOraStr( idSegmentacao );
					strcpy( parametrosCOMSAP.idSegmentacao, (char *)idSegmentacao.arr );

			        endOraStr( idRetencao );
			        
					EXEC SQL WHENEVER NOT FOUND CONTINUE;
					EXEC SQL
					select
					   retencaoaparelho.DSENDERECOENTREGA ,
					   retencaoaparelho.NMPESSOARECEBE ,
					   retencaoaparelho.DSDOCUMENTOTERCEIRO ,
					   retencaoaparelho.VLPRECOREAL ,
					   retencaoaparelho.IDTIPOPAGAMENTOAPARELHO ,
					   retencaoaparelho.idmatrizaparelho ,
					   retencaoaparelho.DTRETIRADA
					into
					   :dsEnderecoEntrega:i_dsEnderecoEntrega ,
					   :nmPessoaEntrega:i_nmPessoaEntrega ,
					   :dsDocumentoEntrega:i_dsDocumentoEntrega ,
					   :nmValor:i_nmValor ,
					   :idTipoPagamento:i_idTipoPagamento ,
					   :idMatrizAparelho:i_idMatrizAparelho ,
					   :dtRemessa:i_dtRemessa
					from
					   retencao.retencaoaparelho retencaoaparelho
					where
					   retencaoaparelho.idretencao = :idRetencao;
   					
   					endOraStr( dsEnderecoEntrega );
   					endOraStr( nmPessoaEntrega );
   					endOraStr( dsDocumentoEntrega );
   					endOraStr( nmValor );
   					endOraStr( nrOrdemVenda );
   					endOraStr( idTipoPagamento );
   					endOraStr( dtRemessa );

					strcpy( parametrosCOMSAP.nmPessoaReceb, (char *)nmPessoaEntrega.arr );
					strcpy( parametrosCOMSAP.nrDocumento, (char *)dsDocumentoEntrega.arr );

					strcpy( parametrosCOMSAP.nmRuaEntrega, (char *)dsEnderecoEntrega.arr );
					strcpy( parametrosCOMSAP.nmBairroEntrega, "Centro" );
					strcpy( parametrosCOMSAP.nmCidadeEntrega, "Sao Paulo" );
					strcpy( parametrosCOMSAP.nrCEPEntrega, "09682-100" );
					strcpy( parametrosCOMSAP.sgEstadoEntrega, "SP" );
					strcpy( parametrosCOMSAP.codPaisEntrega, "1" );

					strcpy( parametrosCOMSAP.nmRuaCliente, (char *)dsEnderecoEntrega.arr );
					strcpy( parametrosCOMSAP.nmBairroCliente, "Centro" );
					strcpy( parametrosCOMSAP.nmCidadeCliente, "Sao Paulo" );
					strcpy( parametrosCOMSAP.nrCEPCliente, "09682-100" );
					strcpy( parametrosCOMSAP.sgEstadoCliente, "SP" );
					strcpy( parametrosCOMSAP.codPaisCliente, "1" );

					strcpy( parametrosCOMSAP.vlPedido, (char *)nmValor.arr );
					strcpy( parametrosCOMSAP.cdPagto, (char *)idTipoPagamento.arr );

					EXEC SQL
					SELECT a.idaparelhocor
					  INTO :idAparelhoCor:i_idAparelhoCor
					  FROM retencao.aparelhocor a, retencao.matrizaparelho b
					 WHERE b.idmatrizaparelho = :idMatrizAparelho
					 AND b.idaparelho = a.idaparelho;
					
			        endOraStr( idAparelhoCor );
					strcpy( parametrosCOMSAP.idAparelho, (char *)idAparelhoCor.arr );
					strcpy( parametrosCOMSAP.cdPagto, (char *)idTipoPagamento.arr );
					strcpy( parametrosCOMSAP.qtdVendida, "1" );
					strcpy( parametrosCOMSAP.dtRemessa, (char *)dtRemessa.arr );
					strcpy( parametrosCOMSAP.vlPedido, (char *)nmValor.arr);
					strcpy( parametrosCOMSAP.cdMeioPagto, (char *)idTipoPagamento.arr );
					strcpy( parametrosCOMSAP.dsObservacao, "Teste Ativação" );
					strcpy( parametrosCOMSAP.nrLinhaRecado, (char *)nrLinha.arr );

					callSAP();
						                             	
				}
				EXEC SQL CLOSE CrsAparelhos;

            }
            catch (...)
            {
                throw;
            }


        //}
        encerrarTuxedo();

        EXEC SQL COMMIT WORK RELEASE;

        conectado = false;
        
        if (sqlca.sqlcode)
        {
            logFile.logError("Erro desconectando no banco de dados! Erro oracle...");
        }

        // Mensagens de finalização
        sprintf(linha,"Foram processados %d aparelhos",qtdeProcessados);
        logFile.logInformation(linha);

        strcpy(linha,"FIM DO PROCESSAMENTO.");
        logFile.logInformation(linha);
	}
    catch (CAtivarAparelhoException * cAtivarAparelhoException )
    {
        sprintf(linha,"Erro %s:%s",
                cAtivarAparelhoException->getCodErr(),cAtivarAparelhoException->getMsgErr());

        if ( conectado )
        {
            conectado = false;
            EXEC SQL COMMIT;
            EXEC SQL COMMIT WORK RELEASE;
            if (sqlca.sqlcode)
            {
                logFile.logError("Falha durante tentativa de desconexão ao banco de dados.");
            }
        }

        encerrarTuxedo();

        throw linha;
    }
    catch (...)
    {
        if ( conectado )
        {
            EXEC SQL COMMIT;
            EXEC SQL COMMIT WORK RELEASE;
            if (sqlca.sqlcode)
            {
                logFile.logError("Falha durante tentativa de desconexão ao banco de dados.");
            }
        }
        throw;
    }
}



/*
void CAtivarAparelhoPC::obterParametrosDinamicos()
{
    logFile.logInformation("> obterParametrosDinamicos()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        char *cdParametro;
        int varOraQtMaxTentativas = parametrosBatch.qtMaxTentativas;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    //
    // Quantidade Máxima de Tentativas
    //
    cdParametro = "RETENCAO_PORTOUT_QTTENTATIVA";

    sprintf(linha, "Vai tentar obter valor do parâmetro %s em APOIO.PARAMETRO",cdParametro);
    logFile.logInformation(linha);

    EXEC SQL
        SELECT
            DSVALORPARAMETRO
        INTO
            :varOraQtMaxTentativas
        FROM
            APOIO.PARAMETRO
        WHERE
            CDPARAMETRO = :cdParametro;

    if ( sqlca.sqlcode )
    {
        sprintf(linha, "%s:Erro Oracle %d-%s.",cdParametro,sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);
        throw new CAtivarAparelhoException(ERR_BATCH_ERRO_ORACLE,linha,__FILE__,__LINE__);
    }

    parametrosBatch.qtMaxTentativas = varOraQtMaxTentativas;

    sprintf(linha, "RETENCAO_PORTOUT_QTTENTATIVA=%d",parametrosBatch.qtMaxTentativas);
    logFile.logInformation(linha);

    logFile.logInformation("< obterParametrosDinamicos()");
}

bool CAtivarAparelhoPC::obterProxIdLinhaTelefonica()
{
    logFile.logInformation("> obterProxIdLinhaTelefonica()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR varOraIdLinhaTelefonica[21];
        VARCHAR varOraIdLinhaSistemaOrigem[21];
        VARCHAR varOraIdRetencao[38];
        short statOraIdLinhaTelefonica=-1;
        short statOraIdLinhaSistemaOrigem=-1;
        short statOraIdRetencao=-1;
        int varOraQtMaxTentativas = parametrosBatch.qtMaxTentativas;
        char *varOraIdRetencaoAnterior = parametrosBatch.idRetencao;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    memset(&varOraIdLinhaTelefonica,0,sizeof(varOraIdLinhaTelefonica));
    memset(&varOraIdLinhaSistemaOrigem,0,sizeof(varOraIdLinhaSistemaOrigem));

    sprintf(linha, "idRetencao (anterior)='%s'",varOraIdRetencaoAnterior);
    logFile.logInformation(linha);

    EXEC SQL
        SELECT
            IDLINHATELEFONICA,
            IDLINHASISTEMAORIGEM,
            IDRETENCAO
        INTO
            :varOraIdLinhaTelefonica:statOraIdLinhaTelefonica,
            :varOraIdLinhaSistemaOrigem:statOraIdLinhaSistemaOrigem,
            :varOraIdRetencao:statOraIdRetencao
        FROM
        (
            SELECT
                ATENDIMENTO.IDLINHATELEFONICA,
                LINHATELEFONICA.IDLINHASISTEMAORIGEM,
                RETENCAOCONSOLIDADA.IDRETENCAO
            FROM
                RETENCAO.RETENCAOCONSOLIDADA RETENCAOCONSOLIDADA,
                ATENDIMENTO.ATENDIMENTO ATENDIMENTO,
                WORKFLOW.AGRUPAMENTOESTADOTPPROC AGRUPAMENTOESTADOTPPROC,
                WORKFLOW.AGRUPAMENTOESTADO AGRUPAMENTOESTADO,
                WORKFLOW.ESTADO ESTADO,
                WORKFLOW.SUBESTADO SUBESTADO,
                LINHA.LINHATELEFONICA LINHATELEFONICA,
                APOIO.TIPOLINHA TIPOLINHA
            WHERE
                RETENCAOCONSOLIDADA.NRPROTOCOLO = ATENDIMENTO.NRPROTOCOLO
            AND ATENDIMENTO.IDAGRUPAMENTOESTADOTPPROC = AGRUPAMENTOESTADOTPPROC.IDAGRUPAMENTOESTADOTPPROC
            AND AGRUPAMENTOESTADOTPPROC.IDAGRUPAMENTOESTADO = AGRUPAMENTOESTADO.IDAGRUPAMENTOESTADO
            AND AGRUPAMENTOESTADO.IDESTADO = ESTADO.IDESTADO
            AND AGRUPAMENTOESTADO.IDSUBESTADO = SUBESTADO.IDSUBESTADO
            --//AND ESTADO.DSESTADO = 'FECHADO'
            --//AND SUBESTADO.DSSUBESTADO = 'PORTOUT NÃO REALIZADO'
            AND ATENDIMENTO.IDTIPOLINHA = TIPOLINHA.IDTIPOLINHA
            AND ATENDIMENTO.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
            AND UPPER(TIPOLINHA.SGTIPOLINHA) LIKE 'POS%'
            AND RETENCAOCONSOLIDADA.INPROCESSADO = 0
            AND RETENCAOCONSOLIDADA.QTTENTATIVA <= :varOraQtMaxTentativas
            AND RETENCAOCONSOLIDADA.IDRETENCAO <> :varOraIdRetencaoAnterior
            ORDER BY
                ATENDIMENTO.DTABERTURA
        )
        WHERE
            ROWNUM < 2;

    if ( sqlca.sqlcode )
    {
        sprintf(linha,"Não encontrou linha a ser processada");
        logFile.logInformation(linha);
        return false;
    }

    CONVIND(varOraIdLinhaTelefonica,statOraIdLinhaTelefonica);
    CONVIND(varOraIdLinhaSistemaOrigem,statOraIdLinhaSistemaOrigem);
    CONVIND(varOraIdRetencao,statOraIdRetencao);

    strcpy(parametrosBatch.idLinhaTelefonica,(char*)varOraIdLinhaTelefonica.arr);
    strcpy(parametrosBatch.idLinhaSistemaOrigem,(char*)varOraIdLinhaSistemaOrigem.arr);
    strcpy(parametrosBatch.idRetencao,(char*)varOraIdRetencao.arr);

    sprintf(linha, "idLinhaTelefonica='%s'",parametrosBatch.idLinhaTelefonica);
    logFile.logInformation(linha);

    sprintf(linha, "idLinhaSistemaOrigem='%s'",parametrosBatch.idLinhaSistemaOrigem);
    logFile.logInformation(linha);

    sprintf(linha, "idRetencao='%s'",parametrosBatch.idRetencao);
    logFile.logInformation(linha);

    logFile.logInformation("< obterProxIdLinhaTelefonica()");

    return true;
}
*/



void CAtivarAparelhoPC::encerrarTuxedo()
{
    logFile.logInformation("> encerrarTuxedo()");

    if ( tuxedoIniciado )
    {
        tpterm();
    }

    tuxedoIniciado = false;

    logFile.logInformation("< encerrarTuxedo()");
}



void CAtivarAparelhoPC::iniciarTuxedo(char*userTux,char*cltTux,char*pwsTux,char*pwsTuxGen)
{
    logFile.logInformation("> iniciarTuxedo(char*userTux,char*cltTux,char*pwsTux,char*pwsTuxGen)");

    TPINIT *tpInitInfo = (TPINIT *)tpalloc("TPINIT", (char *)NULL, TPINITNEED(strlen("vivo") - 1) );

    if( (TPINIT *)NULL == tpInitInfo )
    {
        sprintf(linha,"TPINIT tperrno=%d",tperrno);
        logFile.logError(linha);

        switch(tperrno)
        {
            case TPEINVAL:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEINVAL);  break;
            case TPENOENT:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPENOENT);  break;
            case TPEITYPE:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEITYPE);  break;
            case TPEOTYPE:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEOTYPE);  break;
            case TPETRAN:    throw new CAtivarAparelhoException(ERR_CALLAPI_TPETRAN);   break;
            case TPETIME:    throw new CAtivarAparelhoException(ERR_CALLAPI_TPETIME);   break;
            case TPESVCFAIL: throw new CAtivarAparelhoException(ERR_CALLAPI_TPESVCFAIL);break;
            case TPESVCERR:  throw new CAtivarAparelhoException(ERR_CALLAPI_TPESVCERR); break;
            case TPEBLOCK:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEBLOCK);  break;
            case TPGOTSIG:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPGOTSIG);  break;
            case TPEPROTO:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEPROTO);  break;
            case TPESYSTEM:  throw new CAtivarAparelhoException(ERR_CALLAPI_TPESYSTEM); break;
            case TPEOS:      throw new CAtivarAparelhoException(ERR_CALLAPI_TPEOS);     break;
            default:         throw new CAtivarAparelhoException(ERR_CALLAPI_DEFAULT);   break;
        }
    }

    strcpy(tpInitInfo->usrname, userTux);
    strcpy(tpInitInfo->cltname, cltTux);
    strcpy(tpInitInfo->passwd, pwsTux);
    strcpy((char *)&tpInitInfo->data, pwsTuxGen);

    int ret = tpinit(tpInitInfo);

    if ( ret == -1 )
    {
        sprintf(linha,"TPINIT LOGON tperrno=%d",tperrno);
        logFile.logError(linha);

        switch(tperrno)
        {
            case TPEINVAL:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEINVAL);  break;
            case TPENOENT:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPENOENT);  break;
            case TPEITYPE:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEITYPE);  break;
            case TPEOTYPE:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEOTYPE);  break;
            case TPETRAN:    throw new CAtivarAparelhoException(ERR_CALLAPI_TPETRAN);   break;
            case TPETIME:    throw new CAtivarAparelhoException(ERR_CALLAPI_TPETIME);   break;
            case TPESVCFAIL: throw new CAtivarAparelhoException(ERR_CALLAPI_TPESVCFAIL);break;
            case TPESVCERR:  throw new CAtivarAparelhoException(ERR_CALLAPI_TPESVCERR); break;
            case TPEBLOCK:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEBLOCK);  break;
            case TPGOTSIG:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPGOTSIG);  break;
            case TPEPROTO:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEPROTO);  break;
            case TPESYSTEM:  throw new CAtivarAparelhoException(ERR_CALLAPI_TPESYSTEM); break;
            case TPEOS:      throw new CAtivarAparelhoException(ERR_CALLAPI_TPEOS);     break;
            default:         throw new CAtivarAparelhoException(ERR_CALLAPI_DEFAULT);   break;
        }
    }

    tuxedoIniciado = true;

    logFile.logInformation("< iniciarTuxedo(char*userTux,char*cltTux,char*pwsTux,char*pwsTuxGen)");
}



//void CAtivarAparelhoPC::callSAP( const char* pXmlToSend, long xmlToSendLength )
bool CAtivarAparelhoPC::callSAP()
{
    logFile.logInformation("> callSAP()");

    char errCd[64];
    char msg[1024];
    char errType[64];

    string xmlToSend;
    long xmlToSendLength;
    static long sendbufLengthAnt = 0;
    bool retorno;
	
	errCd[0] = 0x0;	
	msg[0] = 0x0;
	errType[0] = 0x0;
	
    xmlToSend = TAG_ENCODING
	"<msg>"
		"<msgHdr>"
			"<user>1</user>"
			"<service>COMSAP</service>"
		"</msgHdr>"
		"<msgBody>"
			"<xml-fragment>"
				"<inExecutar>0</inExecutar>"
				"<inRetornoOld>0</inRetornoOld>";
	 
	 xmlToSend += "<CLIENTE>";

	     xmlToSend += "<IDPESSOA>";
		 xmlToSend += parametrosCOMSAP.idPessoa;
		 xmlToSend += "</IDPESSOA>";
	     xmlToSend += "<IDGRUPO>";
		 xmlToSend += parametrosCOMSAP.idGrupo;
		 xmlToSend += "</IDGRUPO>";
	     xmlToSend += "<NOME>";
		 xmlToSend += parametrosCOMSAP.nmCliente;
		 xmlToSend += "</NOME>";
	     xmlToSend += "<TELEFONE>";
		 xmlToSend += parametrosCOMSAP.nrLinha;
		 xmlToSend += "</TELEFONE>";
	     xmlToSend += "<TIPO_DOC>";
		 xmlToSend += parametrosCOMSAP.sgDocumento;
		 xmlToSend += "</TIPO_DOC>";
	     xmlToSend += "<DOCUMENTO>";
		 xmlToSend += parametrosCOMSAP.nrDocumento;
		 xmlToSend += "</DOCUMENTO>";
	     xmlToSend += "<IDSEGMENTACAO>";
		 xmlToSend += parametrosCOMSAP.idSegmentacao;
		 xmlToSend += "</IDSEGMENTACAO>";
	 
	 xmlToSend += "</CLIENTE>";
	 xmlToSend += "<ENDERECO>";

	     xmlToSend += "<NOME>";
		 xmlToSend += parametrosCOMSAP.nmPessoaReceb;
		 xmlToSend += "</NOME>";
	     xmlToSend += "<RUA_CLI>";
		 xmlToSend += parametrosCOMSAP.nmRuaCliente;
		 xmlToSend += "</RUA_CLI>";
	     xmlToSend += "<BAIRRO_CLI>";
		 xmlToSend += parametrosCOMSAP.nmBairroCliente;
		 xmlToSend += "</BAIRRO_CLI>";
	     xmlToSend += "<CIDADE_CLI>";
		 xmlToSend += parametrosCOMSAP.nmCidadeCliente;
		 xmlToSend += "</CIDADE_CLI>";
	     xmlToSend += "<CEP_CLI>";
		 xmlToSend += parametrosCOMSAP.nrCEPCliente;
		 xmlToSend += "</CEP_CLI>";
	     xmlToSend += "<ESTADO_CLI>";
		 xmlToSend += parametrosCOMSAP.sgEstadoCliente;
		 xmlToSend += "</ESTADO_CLI>";
	     xmlToSend += "<PAIS_CLI>";
		 xmlToSend += parametrosCOMSAP.codPaisCliente;
		 xmlToSend += "</PAIS_CLI>";
		 
	     xmlToSend += "<RUA_ENT>";
		 xmlToSend += parametrosCOMSAP.nmRuaEntrega;
		 xmlToSend += "</RUA_ENT>";
	     xmlToSend += "<BAIRRO_ENT>";
		 xmlToSend += parametrosCOMSAP.nmBairroEntrega;
		 xmlToSend += "</BAIRRO_ENT>";
	     xmlToSend += "<CIDADE_ENT>";
		 xmlToSend += parametrosCOMSAP.nmCidadeEntrega;
		 xmlToSend += "</CIDADE_ENT>";
	     xmlToSend += "<CEP_ENT>";
		 xmlToSend += parametrosCOMSAP.nrCEPEntrega;
		 xmlToSend += "</CEP_ENT>";
	     xmlToSend += "<ESTADO_ENT>";
		 xmlToSend += parametrosCOMSAP.sgEstadoEntrega;
		 xmlToSend += "</ESTADO_ENT>";
	     xmlToSend += "<PAIS_ENT>";
		 xmlToSend += parametrosCOMSAP.codPaisEntrega;
		 xmlToSend += "</PAIS_ENT>";

	 xmlToSend += "</ENDERECO>";
	 xmlToSend += "<PRODUTO>";

	     xmlToSend += "<IDAPARELHO>";
		 xmlToSend += parametrosCOMSAP.idAparelho;
		 xmlToSend += "</IDAPARELHO>";
	     xmlToSend += "<COND_PGTO>";
		 xmlToSend += parametrosCOMSAP.cdPagto;
		 xmlToSend += "</COND_PGTO>";
		 xmlToSend += "<NUMERO_PEDIDO/>";
	     xmlToSend += "<MATERIAL>";
		 xmlToSend += parametrosCOMSAP.cdMaterial;
		 xmlToSend += "</MATERIAL>";
	     xmlToSend += "<QUANTIDADE>";
		 xmlToSend += parametrosCOMSAP.qtdVendida;
		 xmlToSend += "</QUANTIDADE>";
	     xmlToSend += "<DATA_REMESSA>";
		 xmlToSend += parametrosCOMSAP.dtRemessa;
		 xmlToSend += "</DATA_REMESSA>";
	     xmlToSend += "<VALOR>";
		 xmlToSend += parametrosCOMSAP.vlPedido;
		 xmlToSend += "</VALOR>";
	     xmlToSend += "<MEIOPAGTO>";
		 xmlToSend += parametrosCOMSAP.cdMeioPagto;
		 xmlToSend += "</MEIOPAGTO>";
	     xmlToSend += "<HORA_MANHA_INI/>";
		 xmlToSend += "<HORA_MANHA_FIM/>";
		 xmlToSend += "<HORA_TARDE_INI/>";
		 xmlToSend += "<HORA_TARDE_FIM/>";
		 xmlToSend += "<HORA_TARDE_FIM/>";
	     xmlToSend += "<PONTOS/>";
	     xmlToSend += "<OBSERVACAO>";
		 xmlToSend += parametrosCOMSAP.dsObservacao;
		 xmlToSend += "</OBSERVACAO>";
	     xmlToSend += "<LINHA>";
		 xmlToSend += parametrosCOMSAP.nrLinha;
		 xmlToSend += "</LINHA>";
	 
	 xmlToSend += "</PRODUTO>";
	 
	 xmlToSend += "</xml-fragment>"
			"</msgBody>"
		"</msg>";

	xmlToSendLength = xmlToSend.size();
    if ( xmlToSendLength > sendbufLengthAnt )
    { // se a área a ser enviada é maior que a anterior aloca uma nova
        if ( sendbuf ) tpfree(sendbuf);

        sendbuf = (char*)tpalloc("STRING", NULL, xmlToSendLength+1);

        if( 0 == sendbuf )
        {
            throw new CAtivarAparelhoException(ERR_CALLAPI_BUFFER_TX_NAOALOCA);
            //tpterm();
        }
    }

    if( 0 == rcvbuf )
    {
        throw new CAtivarAparelhoException(ERR_CALLAPI_BUFFER_RX_INVALIDO);
    }

    memcpy(sendbuf,xmlToSend.c_str(),xmlToSendLength);
    *(sendbuf+xmlToSendLength) = 0;

    sprintf(linha,"xml de envio='%s'",sendbuf); //@cassio
    logFile.logInformation(linha); //@cassio

    int ret = tpcall("COMSAP",(char *)sendbuf,xmlToSendLength,(char **)&rcvbuf,&rcvlen,(long)0);

    tpfree(sendbuf);
    sendbuf = 0;

    sprintf(linha,"ret=%d",ret); //@cassio
    logFile.logInformation(linha); //@cassio

    if( ret == -1 )
    {
        sprintf(linha,"tperrno=%d",tperrno); //@cassio
        logFile.logInformation(linha); //@cassio

        switch(tperrno)
        {
            case TPEINVAL:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEINVAL);  break;
            case TPENOENT:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPENOENT);  break;
            case TPEITYPE:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEITYPE);  break;
            case TPEOTYPE:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEOTYPE);  break;
            case TPETRAN:    throw new CAtivarAparelhoException(ERR_CALLAPI_TPETRAN);   break;
            case TPETIME:    throw new CAtivarAparelhoException(ERR_CALLAPI_TPETIME);   break;
            case TPESVCFAIL: throw new CAtivarAparelhoException(ERR_CALLAPI_TPESVCFAIL);break;
            case TPESVCERR:  throw new CAtivarAparelhoException(ERR_CALLAPI_TPESVCERR); break;
            case TPEBLOCK:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEBLOCK);  break;
            case TPGOTSIG:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPGOTSIG);  break;
            case TPEPROTO:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEPROTO);  break;
            case TPESYSTEM:  throw new CAtivarAparelhoException(ERR_CALLAPI_TPESYSTEM); break;
            case TPEOS:      throw new CAtivarAparelhoException(ERR_CALLAPI_TPEOS);     break;
            default:         throw new CAtivarAparelhoException(ERR_CALLAPI_DEFAULT);   break;
        }
    }

    sprintf(linha,"xml de retorno='%.2000s'",rcvbuf); //@cassio
    logFile.logInformation(linha); //@cassio
	
	retorno = buscarAvisoErro( errCd, msg );
    
    logFile.logInformation("< callSAP()");
    
    return retorno;
}



/*
void CAtivarAparelhoPC::callAcessoATLYS(const char *pXmlToSend,long xmlToSendLength)
{
    logFile.logInformation("> callAcessoATLYS(const char *pXmlToSend,long xmlToSendLength)");

    static long sendbufLengthAnt = 0;

    if ( xmlToSendLength > sendbufLengthAnt )
    { // se a área a ser enviada é maior que a anterior aloca uma nova
        if ( sendbuf ) tpfree(sendbuf);

        sendbuf = (char*)tpalloc("STRING", NULL, xmlToSendLength+1);

        if( 0 == sendbuf )
        {
            throw new CAtivarAparelhoException(ERR_CALLAPI_BUFFER_TX_NAOALOCA);
            //tpterm();
        }
    }

    if( 0 == rcvbuf )
    {
        throw new CAtivarAparelhoException(ERR_CALLAPI_BUFFER_RX_INVALIDO);
    }

    memcpy(sendbuf,pXmlToSend,xmlToSendLength);
    *(sendbuf+xmlToSendLength) = 0;

    sprintf(linha,"xml de envio='%s'",sendbuf); //@cassio
    logFile.logInformation(linha); //@cassio

    int ret = tpcall("AcessoATLYS",(char *)sendbuf,xmlToSendLength,(char **)&rcvbuf,&rcvlen,(long)0);

    tpfree(sendbuf);
    sendbuf = 0;

    sprintf(linha,"ret=%d",ret); //@cassio
    logFile.logInformation(linha); //@cassio

    if( ret == -1 )
    {
        sprintf(linha,"tperrno=%d",tperrno); //@cassio
        logFile.logInformation(linha); //@cassio

        switch(tperrno)
        {
            case TPEINVAL:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEINVAL);  break;
            case TPENOENT:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPENOENT);  break;
            case TPEITYPE:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEITYPE);  break;
            case TPEOTYPE:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEOTYPE);  break;
            case TPETRAN:    throw new CAtivarAparelhoException(ERR_CALLAPI_TPETRAN);   break;
            case TPETIME:    throw new CAtivarAparelhoException(ERR_CALLAPI_TPETIME);   break;
            case TPESVCFAIL: throw new CAtivarAparelhoException(ERR_CALLAPI_TPESVCFAIL);break;
            case TPESVCERR:  throw new CAtivarAparelhoException(ERR_CALLAPI_TPESVCERR); break;
            case TPEBLOCK:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEBLOCK);  break;
            case TPGOTSIG:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPGOTSIG);  break;
            case TPEPROTO:   throw new CAtivarAparelhoException(ERR_CALLAPI_TPEPROTO);  break;
            case TPESYSTEM:  throw new CAtivarAparelhoException(ERR_CALLAPI_TPESYSTEM); break;
            case TPEOS:      throw new CAtivarAparelhoException(ERR_CALLAPI_TPEOS);     break;
            default:         throw new CAtivarAparelhoException(ERR_CALLAPI_DEFAULT);   break;
        }
    }

    sprintf(linha,"xml de retorno='%.2000s'",rcvbuf); //@cassio
    logFile.logInformation(linha); //@cassio

    char *valorTag = ObterValorTag(rcvbuf,"fault errCd");

    if ( valorTag )
    {
        sprintf(linha,"erro='%.2000s'",valorTag); //@cassio
        logFile.logInformation(linha); //@cassio
    }
    else
    {
        logFile.logInformation("tag não encontrada!!"); //@cassio
    }


    logFile.logInformation("< callAcessoATLYS(const char *pXmlToSend,long xmlToSendLength)");
}

void CAtivarAparelhoPC::buscarBasicoNumero()
{
    logFile.logInformation("> buscarBasicoNumero()");

    sprintf(linha,"Vai buscar 'BASICO NUMÈRO' para idLinhaSistemaOrigem=%s ...",parametrosBatch.idLinhaSistemaOrigem);
    logFile.logInformation(linha);

    char *valorTag = ObterValorTag(rcvbuf,"basicSvcId");

    if ( valorTag )
    {
        strcpy(basicSvcId,valorTag);
    }
    else
    {
        sprintf(linha,"'BASICO NUMÈRO' não encontrado para idLinhaSistemaOrigem=%s",parametrosBatch.idLinhaSistemaOrigem);
        throw new CAtivarAparelhoException(ERR_BATCH_CONEXAO,linha,__FILE__,__LINE__);
    }

    logFile.logInformation("< buscarBasicoNumero()");
}



void CAtivarAparelhoPC::obterServicosMembro(const char *idServicoSistemaOrigem,Collection *colServicosMembro)
{
    logFile.logInformation("> obterServicosMembro(const char *idServicoSistemaOrigem,Collection *colServicosMembro)");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        const char *pOraIdServicoSistemaOrigem = idServicoSistemaOrigem;

        struct
        {
            VARCHAR idServicoSistemaOrigem[256];
            VARCHAR cdTipoServicoSistemaOrig[21];
        } dadosOraCursorPlanoServico;

        struct
        {
            short idServicoSistemaOrigem;
            short cdTipoServicoSistemaOrig;
        } statusOraCursorPlanoServico;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    sprintf(linha,"Vai obter serviços membro para idServicoSistemaOrigem='%s'",pOraIdServicoSistemaOrigem);
    logFile.logInformation(linha);

    EXEC SQL DECLARE cursorPlanoServico CURSOR FOR
        SELECT
            PLANOSERVICO.IDSERVICOSISTEMAORIGEM,
            PLANOSERVICO.CDTIPOSERVICOSISTEMAORIG
        FROM
            LINHA.PLANOSERVICO PLANOSERVICO
        WHERE
            PLANOSERVICO.IDSERVICO IN
                (
                    SELECT PACOTE.IDSERVICO
                    FROM LINHA.PLANOSERVICO PLANOSERVICOPAI,
                         LINHA.PACOTE PACOTE
                    WHERE PLANOSERVICOPAI.IDSERVICO = PACOTE.IDSERVICOPAI
                    AND NVL(PLANOSERVICOPAI.DTEXPIRACAO,SYSDATE)>= SYSDATE
                    AND PLANOSERVICOPAI.IDSERVICOSISTEMAORIGEM = :pOraIdServicoSistemaOrigem
                );

    while ( true )
    {
        memset(&dadosOraCursorPlanoServico,0,sizeof(dadosOraCursorPlanoServico));
        memset(&statusOraCursorPlanoServico,-1,sizeof(statusOraCursorPlanoServico));

        EXEC SQL
            FETCH cursorPlanoServico
            INTO :dadosOraCursorPlanoServico:statusOraCursorPlanoServico;

        if ( sqlca.sqlcode ) { break; }

        CONVIND(dadosOraCursorPlanoServico.idServicoSistemaOrigem,statusOraCursorPlanoServico.idServicoSistemaOrigem);
        CONVIND(dadosOraCursorPlanoServico.cdTipoServicoSistemaOrig,statusOraCursorPlanoServico.cdTipoServicoSistemaOrig);

        PlanoServico *planoServico = new PlanoServico;

        if ( planoServico )
        { 
            strcpy(planoServico->idServicoSistemaOrigem,(char*)dadosOraCursorPlanoServico.idServicoSistemaOrigem.arr);
            strcpy(planoServico->cdTipoServicoSistemaOrig,(char*)dadosOraCursorPlanoServico.cdTipoServicoSistemaOrig.arr);

            colServicosMembro->AddItem(planoServico);
        }
    }

    EXEC SQL CLOSE cursorPlanoServico;

    logFile.logInformation("< obterServicosMembro(const char *idServicoSistemaOrigem,Collection *colServicosMembro)");
}
*/



char *CAtivarAparelhoPC::ObterValorTag(const char *pXml, const char *pTag)
{
    logFile.logInformation("> ObterValorTag(const char *pXml, const char *pTag)");

    static char szValue[512];
    static int tamXmlAnterior = 0;
    char *pTok;
    int iFlag=0;

    // copia string a ser analisada para buffer local (strtok altera o ponteiro de entrada)
    int tamXml = strlen(pXml);

    if ( tamXml > tamXmlAnterior )
    { // se novo xml a ser analisado for maior que o anterior aloca nova área de trabalho.
        delete[] pszXmlAux;
        pszXmlAux = new char [tamXml+1];
    }

    tamXmlAnterior = tamXml;

    memcpy(pszXmlAux,pXml,tamXml);
    *(pszXmlAux+tamXml) = 0;

    for(pTok = strtok(pszXmlAux, "<>"); pTok != NULL; pTok = strtok(NULL, "<>"))
    {
        if(iFlag)
        {
            strcpy(szValue,pTok);
            iFlag=0;

            logFile.logInformation("< ObterValorTag(const char *pXml, const char *pTag)");
            return szValue;
        }

        if( !strcmp(pTag,pTok) )
        {
            iFlag=1;
        }
    }

    logFile.logInformation("< ObterValorTag(const char *pXml, const char *pTag)");

    return NULL;
}



bool CAtivarAparelhoPC::buscarAvisoErro( char *errCd, char *msg )
{
    logFile.logInformation("\n> buscarAvisoErro(char *errCd,char *msg )"); //@cassio debug

    if ( 0==rcvbuf )
    {
        throw new CAtivarAparelhoException(ERR_BATCH_CONVER_TXT_NIL);
    }

    bool retorno = false;
    const char* str = rcvbuf;
    const char *_errCd = 0;
    const char *_msg = 0;
    const char *_errType = 0;

    TiXmlDocument doc;
    doc.Parse( str );
    TiXmlHandle docH( &doc );

    double dVal = 0.0;
    TiXmlElement* ele=0;
    TiXmlNode *node=0;

    node = doc.RootElement();

    if ( node )
    {
        TiXmlElement* child2 = docH.FirstChild( "msg" ).FirstChild( "msgHdr" ).ToElement();

        if ( child2 )
        {
            child2 = child2->NextSiblingElement(); // <msgBody>
            if ( child2 )
            {
                TiXmlNode *xmlNode = child2->FirstChild("tns:RetencaoRetornoSAPVO");

                if ( xmlNode )
                {
                    docH = xmlNode;
                    child2 = docH.FirstChild( "codErro" ).ToElement();

                    if ( child2 )
                    {
                        _errCd = child2->GetText();
                        strcpy(errCd,_errCd);
                        sprintf(linha,"\ncodErro='%s'\n",errCd); //@cassio
                        logFile.logInformation(linha); //@cassio
                    }

                    child2 = docH.FirstChild( "descErro" ).ToElement();

                    if ( child2 )
                    {
                        _msg = child2->GetText();
                        strcpy(msg,_msg);
                        sprintf(linha,"\ndescErro='%s'\n",msg); //@cassio
                        logFile.logInformation(linha); //@cassio
                    }
                        
                }
            }
        }
    }


    if ( 0== _errCd ) { retorno= true; }
    if ( 0==*_errCd ) { retorno= true; }

    logFile.logInformation("< buscarAvisoErro(char *errCd,char *msg )"); //@cassio debug

    return retorno;
}
