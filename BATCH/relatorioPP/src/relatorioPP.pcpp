
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <iostream.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <ctype.h>

#include "../include/relatorioPP.h"
#include "../../commons/Propriedade/include/MFile.h"
#include "../../commons/Log/include/Log.h"
#include "../../commons/SplitLine.h"

EXEC SQL INCLUDE SQLCA;

char szAux[1024];
char szTemp[1024];
char szTempTrace[1024];
Log oLog;
int iSignalProcessa=1;

#define TAM_BUFFER 2048

#define CONVIND(O,I) \
{\
    if (I == -1) { \
        ##O.arr[0]=0; \
    } else { \
        ##O.arr[##O.len]=0; \
    } \
}

#ifdef WIN32
#define MKDIR _mkdir
#define ACCESS _access
#else
#define MKDIR mkdir
#define ACCESS access
#endif

void NomeRelatorio( char * sNmRelatorio );

int main(void)
{
    TParamConf tParamConf;
    int retorno = 0;
    char sNmRelatorio[256];
	
    oLog.setNivel(2);
    oLog.logDebug(">>>relatorioPP");

#ifndef WIN32
    ArmaSinal(SIGTERM);
#endif

    // parametros de configuração
    if(ObtemParamConf(&tParamConf))
    {
        oLog.logError("Erro obtendo parametros de configuracao");
        oLog.logDebug("<<<relatorioPP");
        return -1;
    }

    oLog.logDebug("Conectando na BD...");
    if (DBConnect(tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst))
    {
        oLog.logError("Erro conectando no banco de dados");
        oLog.logDebug("<<<relatorioPP");
        return -1;
    }
    oLog.logDebug("Conectado na BD com sucesso...");

    sNmRelatorio[0] = 0x0;
    NomeRelatorio( sNmRelatorio );
    if( sNmRelatorio[0] == NULL )
    {
        oLog.logDebug( "*** NAO OBTEVE NOME DO RELATORIO, VERIFIQUE TABELA DE PARAMETRIZACAO ***" );
        oLog.logDebug( "<<<relatorioGestor" );
        return -1;
    }
	
	sprintf(szTempTrace, "Inicio do processamento de geração do relatorioPP..."); oLog.logDebug(szTempTrace);
	gerarArquivoRelatorioPP(tParamConf);
	sprintf(szTempTrace, "Fim do processamento de geração do relatorioPP..."); oLog.logDebug(szTempTrace);
    DBDisconnect();

    if ( 0 == retorno )
    {
        oLog.logDebug("Processamento encerrado com sucesso...");
    }
    else
    {
        oLog.logDebug("Processamento encerrado com ERRO!");
    }

    oLog.logDebug("<<<relatorioPP");

    return retorno;

    sqlError:
        sprintf(szTempTrace, "Finalizando processo com erro ORACLE (%d)", sqlca.sqlcode); oLog.logDebug(szTempTrace);
        return -1;
}

/************************************************************************************************************/
void ObterData(int iDiasAnteriores, char *pszData)
{
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR strOraDataProcessamento[12];
        short ostrOraDataProcessamento = -1;
		short ostrDiasAnteriores = iDiasAnteriores;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
    EXEC SQL 
        SELECT
           TO_CHAR(SYSDATE -:ostrDiasAnteriores,'YYYYMMDD')
        INTO
            :strOraDataProcessamento:ostrOraDataProcessamento
        FROM
            DUAL;

    CONVIND( strOraDataProcessamento,ostrOraDataProcessamento );

	sprintf( pszData,"%s", (char*)strOraDataProcessamento.arr );
	pszData[8] = '\0';
	
    return;
}

void ObterHora(char *pszData)
{
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR strOraDataProcessamento[12];
        short ostrOraDataProcessamento = -1;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
    EXEC SQL 
        SELECT
           TO_CHAR(SYSDATE,'HH24MISS')
        INTO
            :strOraDataProcessamento:ostrOraDataProcessamento
        FROM
            DUAL;

    CONVIND( strOraDataProcessamento,ostrOraDataProcessamento );

	sprintf( pszData,"%s", (char*)strOraDataProcessamento.arr );
	pszData[6] = '\0';
    return;
}

/************************************************************************************************************/
int gerarArquivoRelatorioPP(TParamConf &tParamConf)
{
    long lQtdRegistros=0;
	int retorno = 0;
	char szNomeArquivo[_MAX_PATH+9];
	char szRegistro[TAM_BUFFER+1];
	char szHeader[256]; memset(szHeader,'\0',sizeof(szHeader));
	char szTrailer[256];memset(szTrailer,'\0',sizeof(szTrailer));
	
	char szData[256];	memset(szData,'\0',sizeof(szData));
	char szHora[256];	memset(szHora,'\0',sizeof(szHora));
	// gerar arquivo OUT OK para a data de ontem.
	ObterData(0,szData);
	ObterHora(szHora);
	
    sprintf( szNomeArquivo,"%s/SAC_SPT_CAD_VIVONET_%s_%s.txt",tParamConf.szPath,szData,szHora);
    FILE *pFile=0;
    if( !(pFile = fopen(szNomeArquivo, "w")))
    {
        sprintf(szTempTrace, "Erro criando arquivo[%s]", szNomeArquivo); oLog.logDebug(szTempTrace);
        return -1;
    }	
	sprintf(szTempTrace, "Arquivo[%s] criado com sucesso.", szNomeArquivo); oLog.logDebug(szTempTrace);
	
	
	EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oszLinha[512];
        short ostLinha;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR GOTO sqlError;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    // declara cursor para busca dos xml´s a serem reprocessados
    sprintf(szTempTrace, "Declarando cursor CursorRelatorioPP..."); oLog.logDebug(szTempTrace);

    EXEC SQL DECLARE CursorRelatorioPP CURSOR FOR 

        SELECT /*+parallel (p) parallel (lc) parallel (doc) parallel(pedoc) parallel (ps) parallel(psl) parallel(pdp)*/
           RPAD(SUBSTR(UF.SGUF,0,2),2,' ')||CHR(9)|| -- UF DA OPERADORA
           RPAD(SUBSTR(TO_CHAR(AR.CDAREAREGISTRO),0,2),2,' ')||RPAD(SUBSTR(TO_CHAR(LB.NRLINHA),0,9),9,' ')||CHR(9)||-- NUMERO DA LINHA
           (CASE 
               WHEN ( EL.IDESTADOLINHA = 2) THEN '2' -- LINHA STATUS DESTIVADA
               --WHEN ( ) THEN '3' -- TITULAR CLASSIFICADO COMO UNO e CI
               WHEN ( P.IDTIPOPESSOA = 2) THEN '4' -- TITULAR DA LINHA CLASSIFICADO COMO PESSOA JURIDICA
               --WHEN ( ) THEN '5' -- LINHA NAO TEM REGISTRO DE ATIVACAO NO ATLYS
               --WHEN ( ) THEN '6' -- CLIENTE COM CPF INVALIDO
               ELSE '1' -- CLIENTE ELEGIVEL. 
            END)||CHR(9)||--ELEGIVEL 
           TO_CHAR(DECODE(LT.IDTIPOLINHA,1,1,DECODE(LT.IDTIPOLINHA,5,1,DECODE(LT.IDTIPOLINHA,2,2,DECODE(LT.IDTIPOLINHA,6,2,DECODE(LT.IDTIPOLINHA,4,3,DECODE(LT.IDTIPOLINHA,7,3,0)))))))||CHR(9)|| -- IDENTIFICADOR TIPO LINHA
           RPAD(LTRIM(SUBSTR(C.CDCONTA,0,20),0),20,' ')||CHR(9)|| -- NUMERO DA CONTA
           TO_CHAR(DECODE(DOC.IDTIPODOCUMENTO,1,1,DECODE(DOC.IDTIPODOCUMENTO,9,2,DECODE(DOC.IDTIPODOCUMENTO,2,3,4))))||CHR(9)|| -- TIPO DE DOCUMENTO
           RPAD(LTRIM(SUBSTR(DOC.NRDOCUMENTO,0,20),0),20,' ')||CHR(9)|| -- NUMERO DO DOCUMENTO
           RPAD(LTRIM(SUBSTR(TO_CHAR(P.IDPESSOASISTEMAORIGEM),0,15),0),15,' ')||CHR(9)|| -- CUST_ID
           (CASE 
               WHEN ( EL.INLINHACANCELADA = 1) THEN '0' -- CANCELADA
               WHEN ( EL.INLINHACANCELADA = 0) AND  ( EL.DSESTADOLINHA LIKE '%SUSPENS%')THEN  '2'
               ELSE '1'
            END)||CHR(9)|| -- STATUS DA LINHA
           RPAD(SUBSTR(DECODE(TO_CHAR(LT.DTHABILITACAO,'YYYYMMDD'),null,' ',TO_CHAR(LT.DTHABILITACAO,'YYYYMMDD')) ,0,8),8,' ')||CHR(9)|| -- DATA DA ATIVACAO
           RPAD(SUBSTR(DECODE(TO_CHAR(LT.DTEXPIRACAO,'YYYYMMDD'),null, ' ',TO_CHAR(LT.DTEXPIRACAO,'YYYYMMDD')),0,8),8,' ')||CHR(9)|| -- DATA DA DESATIVACAO
       
           RPAD(LTRIM(SUBSTR(TO_CHAR(LT.IDLINHASISTEMAORIGEM),0,20),0),20,' ')||CHR(9)|| -- IDENTIFICADOR DA LINHA
       
           RPAD(TRANSLATE(SUBSTR(TRIM(PS.SGSERVICO),0,20),'ÀÁÂÃÄÅÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝàáâãäåçèéêëìíîïñòóôõöùúûüýÿ','AAAAAACEEEEIIIINOOOOOUUUUYaaaaaaceeeeiiiinooooouuuuyy'),20,' ')||CHR(9)|| -- CODIGO DO PLANO
           RPAD(TRANSLATE(SUBSTR(P.NMPESSOA,0,80),'ÀÁÂÃÄÅÇÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝàáâãäåçèéêëìíîïñòóôõöùúûüýÿ','AAAAAACEEEEIIIINOOOOOUUUUYaaaaaaceeeeiiiinooooouuuuyy'),80,' ')||CHR(9)|| -- NOME DO USUARIO DA LINHA
       (CASE 
           WHEN ( LT.IDTIPOLINHA <= 2 OR  LT.IDTIPOLINHA = 4 ) THEN 'C'
           WHEN ( LT.IDTIPOLINHA >= 5 AND  LT.IDTIPOLINHA <= 7 ) THEN 'G'
           ELSE ' '
        END) --TECNOLOGIA ???????????
        FROM    
            LINHA.LINHABASE LB,
            APOIO.AREAREGISTRO AR,
            CUSTOMER.UFOPERADORA UO,
            APOIO.UF UF,
            LINHA.LINHATELEFONICA LT,    
            CUSTOMER.LINHACONTA LC,
            CUSTOMER.CONTA C,         
            CUSTOMER.PESSOACONTA PC,
            CUSTOMER.PESSOADEPARA PDP,
            CUSTOMER.PESSOADOCUMENTO PDOC,
            CUSTOMER.DOCUMENTO DOC,
            CUSTOMER.PESSOA P,
            LINHA.PLANOSERVICO PS,
            LINHA.PLANOSERVICOLINHA PSL,      
            APOIO.ESTADOLINHA EL,
            CUSTOMER.PROGRAMAPONTOS PP
        WHERE 
            LB.IDAREAREGISTRO = AR.IDAREAREGISTRO    
        AND       
            LB.IDLINHABASE = LT.IDLINHABASE 
        AND
            LT.IDLINHATELEFONICA = LC.IDLINHATELEFONICA
        AND
            UO.IDUF = UF.IDUF     
        and 
            uo.IDUFOPERADORA=ar.IDUFOPERADORA    
        AND
            LC.IDCONTA = C.IDCONTA 
        AND
            C.IDCONTA = PC.IDCONTA 
        AND
            PC.IDPESSOADEPARA = PDP.IDPESSOADEPARA 
        AND
            PDP.IDPESSOA = PDOC.IDPESSOA 
        AND 
            PC.IDTIPORELACIONAMENTO=2
        AND
            PDOC.IDDOCUMENTO = DOC.IDDOCUMENTO 
        AND
            PDP.IDPESSOA = P.IDPESSOA 
        AND
            LT.IDLINHATELEFONICA = PSL.IDLINHATELEFONICA 
        AND
            PSL.IDSERVICO = PS.IDSERVICO 
        AND 
            LB.IDESTADOLINHA = EL.IDESTADOLINHA 
        AND
            (EL.INLINHACANCELADA = 0 OR 
            EL.INLINHACANCELADA = 1 AND LB.DTESTADOLINHA > (SYSDATE - 180)) 
        AND
            PP.NRDOCUMENTO = DOC.NRDOCUMENTO 
        AND
            PP.TPOPERACAO = '1'
        and 
            PSL.INPLANO=1
        AND 
            (PSL.DTEXPIRACAO IS NULL OR PSL.DTEXPIRACAO>(SYSDATE))
        and 
            (PSL.dtvigenciafinal IS NULL OR PSL.dtvigenciafinal >= SYSDATE);
   
    EXEC SQL OPEN CursorRelatorioPP;
    oLog.logDebug("Cursor CursorRelatorioPP aberto com sucesso.");


	// GRAVANDO HEADER
	sprintf(szHeader, "H\tVIVONET   \tSACSPTCAD\t%8s\t%6s\n",szData,szHora); 
	if(retorno = gravarRegistro(pFile,szHeader),retorno)
	{
		oLog.logDebug("Erro de gravação do Header");
		return -1;
	}	
	
	
    for ( ;; )
    {
        /* tratamento para interromper o processamento via sinal (complemento da saida acima) */
        if(iSignalProcessa == 0)
        {
            oLog.logDebug("2.Tratamento de sinal de termino dentro do loop recebeu interrupção");
            break;
        }

        ostLinha = -1;

        EXEC SQL
            FETCH
                CursorRelatorioPP
            INTO
                :oszLinha:ostLinha;

        ++lQtdRegistros;

        CONVIND(oszLinha,ostLinha);

        sprintf( szRegistro,"%.*s\n", oszLinha.len, (char*)oszLinha.arr );
        if(retorno = gravarRegistro(pFile,szRegistro),retorno)
        {
            oLog.logDebug("Erro de gravação (1)");
            break;
        }


    }// for ( ;; )

	// GRAVANDO TRAILER
	//sprintf(szTrailer, "T\t%10.0d\n",lQtdRegistros);  ##wak - alterado por solicitação do Daniel Morais - VIVO
	sprintf(szTrailer, "T%10.0d\n",lQtdRegistros); 
	if(retorno = gravarRegistro(pFile,szTrailer),retorno)
	{
		oLog.logDebug("Erro de gravação do Trailer.");
		return -1;
	}	

    sprintf(szTempTrace,"Gerou %d registro(s)",lQtdRegistros);oLog.logDebug(szTempTrace);

	fclose(pFile);

    // finaliza
    oLog.logDebug("Fechando cursor CursorRelatorioPP...");
    EXEC SQL CLOSE CursorRelatorioPP;
	oLog.logDebug("Cursor CursorRelatorioPP fechado.");
	return 0;
	
    sqlError:
        sprintf(szTempTrace, "Finalizando processo com erro ORACLE (%d)", sqlca.sqlcode); oLog.logDebug(szTempTrace);
        return -1;	
}

/************************************************************************************************************/
int gravarRegistro(FILE *pFile,char *pszRegistro)
{
    char szPog[1000];
 
    if( pszRegistro )
    {
        if(fputs(pszRegistro, pFile) <= 0)
        {
            return -1;
        }
    }

    return 0;
}

/************************************************************************************************************/
#ifndef WIN32
void ArmaSinal(int iSignal)
{
    sprintf(szTempTrace, "Armando tratamento para Signal(%d)", iSignal); oLog.logInformation(szTempTrace);

    if(signal((iSignal), ProcessaSignal) == SIG_ERR)
	{
        fprintf(stderr, "ERRO ARMANDO SINAL!!!\n");
        exit(-1);
    }
}
/************************************************************************************************************/
void ProcessaSignal(int iSig)
{
    oLog.logInformation(">>>ProcessaSignal");
    sprintf(szTempTrace, "iSig(%d)", iSig); oLog.logInformation(szTempTrace);

    /* rearma o mesmo sinal lancado */
    ArmaSinal(iSig);

    if(iSig == SIGTERM)
	{
        oLog.logInformation("Finalizando processamento via sinal....");
        iSignalProcessa=0;
    }

    oLog.logInformation(">>>ProcessaSignal");
}
#endif

/************************************************************************************************************/
int ObtemParamConf(TParamConf *ptParamConf)
{
    MFile mfConfig;
    SplitLine NewLinha;
    char szLinha[100 + 1];
    char szDivArq[256];
    char szDivPre[21];

    oLog.logDebug("Obtendo parametros de configuracao...");

    /* Zera variáveis */
    memset(ptParamConf, 0x00, sizeof(TParamConf));
    memset(szLinha, 0x00, sizeof(szLinha));
    memset(szDivArq, 0x00, sizeof(szDivArq));
    memset(szDivPre, 0x00, sizeof(szDivPre));


    /* Define o arquivo de configuração */
    mfConfig.setPath("relatorioPP.cfg");

    /* Verificar se conseguiu abrir o arquivo */
    if(!mfConfig.abrir())
	{
        oLog.logError("Erro abrindo arquivo de configuração!");
        return -1;
    }

    /* Capturando usuario, senha, path e instance de banco do arquivo */
    NewLinha.SetDiv('=');
    while(mfConfig.getLine(szLinha) != 0)
    {
        NewLinha.SetLine(szLinha);
        NewLinha.GetBeforeDiv(szDivPre);
        NewLinha.GetAfterDiv(szDivArq);

        /* Verifica qual parâmetro foi encontrado. */
        if (!strcmp(szDivPre, "pwd_db"))
        {
            strncpy(ptParamConf->szPws, szDivArq, TAM_BD_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_db"))
        {
            strncpy(ptParamConf->szUsr, szDivArq, TAM_BD_USRNAME);
        }
        else if (!strcmp(szDivPre, "inst_db"))
        {
            strncpy(ptParamConf->szInst, szDivArq, TAM_BD_INST);
        }
        else if (!strcmp(szDivPre, "pwd_tux"))
        {
            strncpy(ptParamConf->szPwsTux, szDivArq, TAM_TX_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_tux"))
        {
            strncpy(ptParamConf->szUsrTux, szDivArq, TAM_TX_USRNAME);
        }
        else if (!strcmp(szDivPre, "pwd_tux_gen"))
        {
            strncpy(ptParamConf->szPwsTuxGen, szDivArq, TAM_TX_GEN);
        }
        else if (!strcmp(szDivPre, "clt_tux"))
        {
            strncpy(ptParamConf->szCltTux, szDivArq, TAM_TX_CLT);
        }
        else if (!strcmp(szDivPre, "path"))
        {
            strncpy(ptParamConf->szPath, szDivArq, _MAX_PATH);
        }
		
        memset(szLinha,  0x00, sizeof(szLinha));
        memset(szDivPre, 0x00, sizeof(szDivPre));
        memset(szDivArq, 0x00, sizeof(szDivArq));
    }

    /* Fechando o arquivo de configuracao aberto */
    mfConfig.fechar();

    sprintf(szTempTrace, "ptParamConf->szPws[%s]", ptParamConf->szPws); oLog.logDebug(szTempTrace);
    sprintf(szTempTrace, "ptParamConf->szUsr[%s]", ptParamConf->szUsr); oLog.logDebug(szTempTrace);
    sprintf(szTempTrace, "ptParamConf->szInst[%s]", ptParamConf->szInst); oLog.logDebug(szTempTrace);
    sprintf(szTempTrace, "ptParamConf->szPwsTux[%s]", ptParamConf->szPwsTux); oLog.logDebug(szTempTrace);
    sprintf(szTempTrace, "ptParamConf->szUsrTux[%s]", ptParamConf->szUsrTux); oLog.logDebug(szTempTrace);
    sprintf(szTempTrace, "ptParamConf->szPwsTuxGen[%s]", ptParamConf->szPwsTuxGen); oLog.logDebug(szTempTrace);
    sprintf(szTempTrace, "ptParamConf->szCltTux[%s]", ptParamConf->szCltTux); oLog.logDebug(szTempTrace);
    sprintf(szTempTrace, "ptParamConf->szPath[%s]", ptParamConf->szPath); oLog.logDebug(szTempTrace);

    /* Verifica se todos os dados foram recuperados do arquivo de configuração. */
    if (strlen(ptParamConf->szInst) == 0 ||
        strlen(ptParamConf->szPwsTux) == 0 ||
        strlen(ptParamConf->szUsrTux) == 0 ||
        strlen(ptParamConf->szPwsTuxGen) == 0 ||
        strlen(ptParamConf->szCltTux) == 0 ||
        strlen(ptParamConf->szPath) == 0)
    {
        oLog.logError("Dados incompletos!");
        return -1;
    }


    oLog.logDebug("Parametros de configuracao obtidos com sucesso...");
    return 0;
}


/************************************************************************************************************/
int DBConnect(char *pUsr, char *pPwd, char *pInst)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[256];
    EXEC SQL END DECLARE SECTION;

    oLog.logInformation(">>>DBConnect");

    /* String de conexao */
    sprintf(connString, "%s/%s@%s", pUsr, pPwd, pInst);

    /* Marca ponto de erro */
    EXEC SQL WHENEVER SQLERROR GOTO errConn;

    /* Conecta */
    EXEC SQL CONNECT :connString;

    oLog.logInformation("<<<DBConnect");

    return (sqlca.sqlcode);

errConn:
    oLog.logInformation("<<<DBConnect [ERROR]");
    return -1;
}

/************************************************************************************************************/
void DBDisconnect(void)
{
    oLog.logInformation(">>>DBDisconnect");

    EXEC SQL WHENEVER SQLERROR GOTO DBDisconnectError;
    EXEC SQL COMMIT WORK RELEASE;

    oLog.logInformation("<<<DBDisconnect");
    return;

DBDisconnectError:
    sprintf(szTempTrace, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szTempTrace);
}

void NomeRelatorio( char * sNmRelatorio )
{
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR oraNmRelatorio[256];
        short   i_oraNmRelatorio = -1;
    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL WHENEVER SQLERROR GOTO sqlErrorNomeRelatorio;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
    SELECT
       DSVALORPARAMETRO
    INTO
       :oraNmRelatorio:i_oraNmRelatorio
    FROM
       APOIO.PARAMETRO
    WHERE
       CDPARAMETRO = 'RELATDVOL';   // Constante para busca no banco do nome do relatorio a ser gerado
    
    CONVIND( oraNmRelatorio, i_oraNmRelatorio );
    
    if ( i_oraNmRelatorio != -1 )
    {
        sprintf( sNmRelatorio,"%.*s", oraNmRelatorio.len,(char*)oraNmRelatorio.arr );
    }
    
    return;
    
sqlErrorNomeRelatorio:
    sNmRelatorio[0] = 0x0;
}
