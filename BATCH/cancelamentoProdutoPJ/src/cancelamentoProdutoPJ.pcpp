/**
 * @modulo  Batch
 * @usecase Batch
 * @author
 * @version $Revision: 1.1.2.9 $
 * @CVS     $Author: a5114878 $ - $Date: 2016/11/01 20:13:17 $
 **/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <iostream.h>
#include <ctype.h>

#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <dirent.h>

#ifndef WIN32
#include <unistd.h>
#endif

#include "../include/cancelamentoProdutoPJ.h"
#include "../../commons/Propriedade/include/MFile.h"
#include "../../commons/Log/include/Log.h"
#include "../../commons/SplitLine.h"

#include <string>
using namespace std;

EXEC SQL INCLUDE SQLCA;

//==============================================================================
// Globais
char szAux[1024 + 1];
Log oLog;

//==============================================================================
// Run
int main(int argc, char* argv[])
{
    time_t start_t, end_t;
    int diff_t;
    int hour,min,sec; 
    TParamConf tParamConf;
    
    time(&start_t);

    oLog.setNivel(2);
    oLog.logDebug(">>> CancelAutomaticoPJ");

    //==========================================================================
    // Parâmetros de configuração
    memset( &tParamConf, 0x0, sizeof(tParamConf) );
    if(ObtemParamConf(&tParamConf))
    {
        oLog.logError("Erro obtendo parametros de configuracao");
        exit( EXIT_FAILURE );
    }

    //==========================================================================
    // Conecta ao banco
    //oLog.logDebug("Conectando na BD...");
    if (DBConnect(tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst))
    {
        oLog.logError("Erro conectando no banco de dados");
        exit( EXIT_FAILURE );
    }
    
    CancelMovel();
    CancelFixa();

    ExpurgoRelatorio( "../data" );
    
    DBDisconnect();

    oLog.logDebug("===> Processamento encerrado com sucesso <===");
    
    time(&end_t);
    diff_t = difftime(end_t, start_t);
    hour = diff_t / 3600; 
    diff_t = diff_t % 3600; 
    min = diff_t / 60; 
    diff_t = diff_t % 60; 
    sec = diff_t; 
    
    sprintf( szAux, "---> Tempo total de execucao: %02d:%02d:%02d", hour, min, sec ); oLog.logDebug(szAux);
    
    oLog.logDebug("<<< CancelAutomaticoPJ");

    exit( EXIT_SUCCESS );
}



/************************************************************************************************************/
int ObtemParamConf(TParamConf *ptParamConf)
{
    MFile mfConfig;
    SplitLine NewLinha;
    char szLinha[101];
    char szDivArq[256];
    char szDivPre[21];

    oLog.logDebug("Obtendo parametros de configuracao...");

    // Zera variáveis
    memset(szLinha, 0, sizeof(szLinha));
    memset(szDivArq, 0, sizeof(szDivArq));
    memset(szDivPre, 0, sizeof(szDivPre));

    // Define o arquivo de configuração
    mfConfig.setPath("cancelamentoProdutoPJ.cfg");

    // Verificar se conseguiu abrir o arquivo
    if(!mfConfig.abrir())
    {
        oLog.logError("Erro abrindo arquivo de configuração!");
        return -1;
    }

    // Capturando usuario, senha, path e instance de banco do arquivo
    NewLinha.SetDiv('=');
    while(mfConfig.getLine(szLinha) != 0)
    {
        NewLinha.SetLine(szLinha);
        NewLinha.GetBeforeDiv(szDivPre);
        NewLinha.GetAfterDiv(szDivArq);

        // Verifica qual parâmetro foi encontrado.
        if (!strcmp(szDivPre, "pwd_db"))
        {
            strncpy(ptParamConf->szPws, szDivArq, TAM_BD_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_db"))
        {
            strncpy(ptParamConf->szUsr, szDivArq, TAM_BD_USRNAME);
        }
        else if (!strcmp(szDivPre, "inst_db"))
        {
            strncpy(ptParamConf->szInst, szDivArq, TAM_BD_INST);
        }

        memset(szLinha,  0, sizeof(szLinha));
        memset(szDivPre, 0, sizeof(szDivPre));
        memset(szDivArq, 0, sizeof(szDivArq));
    }

    // Fechando o arquivo de configuracao aberto
    mfConfig.fechar();

    sprintf(szAux, "ptParamConf->szUsr[%s]", ptParamConf->szUsr); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szInst[%s]", ptParamConf->szInst); oLog.logDebug(szAux);

    // Verifica se todos os dados foram recuperados do arquivo de configuração.
    if (strlen(ptParamConf->szInst) == 0 )
    {
        oLog.logError("Dados incompletos!");
        return -1;
    }

    //oLog.logDebug("Parametros de configuracao obtidos com sucesso...");
    return 0;
}

/************************************************************************************************************/
int DBConnect(char *pUsr, char *pPwd, char *pInst)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[256];
    EXEC SQL END DECLARE SECTION;

    // String de conexao
    sprintf(connString, "%s/%s@%s", pUsr, pPwd, pInst);
    
    sprintf(szAux, "Connect [%s]", connString ); oLog.logDebug(szAux);

    // Marca ponto de erro
    EXEC SQL WHENEVER SQLERROR GOTO errConn;

    // Conecta
    EXEC SQL CONNECT :connString;

    return (sqlca.sqlcode);

errConn:
    oLog.logInformation("<<<DBConnect [ERROR]");
    return -1;
}

/************************************************************************************************************/
void DBDisconnect(void)
{
    EXEC SQL WHENEVER SQLERROR GOTO Error;
    EXEC SQL COMMIT WORK RELEASE;
    return;

Error:
    sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    return;
}



void CancelMovel( void )
{
    time_t start_t, end_t;
    
    int diff_t;
    int hour,min,sec; 
    int ctLinhas = 0;
    
    time(&start_t);

    FILE *fpOut;
    char sNomeArqSaida[256];

    EXEC SQL BEGIN DECLARE SECTION;

        VARCHAR sRegistro[256];
        VARCHAR sHrArq[16];
        VARCHAR nmClassificaProdCancel[101];
        VARCHAR dtPesquisa[11];

        short   i_sRegistro = -1;
        short   i_sHrArq = -1;
        short   i_nmClassificaProdCancel = -1;
        short   i_dtPesquisa = -1;
        
    EXEC SQL END DECLARE SECTION;
    
    memset( &sHrArq     , 0x0, sizeof(sHrArq) );
    memset( &nmClassificaProdCancel, 0x0, sizeof(nmClassificaProdCancel) );
    memset( &dtPesquisa , 0x0, sizeof(dtPesquisa) );
    memset( sNomeArqSaida , 0x0, sizeof(sNomeArqSaida) );
    
    oLog.logDebug(">>> CancelMovel");

    EXEC SQL WHENEVER SQLERROR GOTO SqlError_CancelMovel;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    
    EXEC SQL
    SELECT dsprodutocancelado
    INTO :nmClassificaProdCancel:i_nmClassificaProdCancel 
      FROM apoio.produtocancelado
     WHERE sgprodutocancelado = 'FIXO_VOZ';
     
    CONVIND( nmClassificaProdCancel, i_nmClassificaProdCancel );
    
    EXEC SQL
    SELECT TRUNC (SYSDATE - 1)
    INTO :dtPesquisa:i_dtPesquisa
      FROM DUAL;
    
    CONVIND( dtPesquisa, i_dtPesquisa );
    
    EXEC SQL DECLARE curCancelMovel CURSOR FOR
    SELECT 
           CANCELAUTOMATICO.NMORIGEMCANCELAMENTO || ';' || 
           CANCELAUTOMATICO.NRPROTOCOLO || ';' || 
           CANCELAUTOMATICO.SGTIPOPESSOA || ';' || 
           CANCELAUTOMATICO.NRDOCUMENTO || ';' || 
           PRODUTOCANCELADO.SGPRODUTOCANCELADO || ';' || 
           CANCELAUTOMATICO.INTIPOREGISTRO || ';' || 
           CANCELAUTOMATICO.CDAREAREGISTRO || ';' || 
           CANCELAUTOMATICO.NRLINHA || ';' || 
           CANCELAUTOMATICO.CDASSINATURA || ';' ||
           CANCELAUTOMATICO.NMPESSOA || ';' || 
           CANCELAUTOMATICO.NRTELEFONEORIGEM || ';' || 
           CANCELAUTOMATICO.NRTELEFONECONTATO || ';' || 
           CANCELAUTOMATICO.DSMOTIVO || ';' || 
           TO_CHAR(CANCELAUTOMATICO.DTCANCELAMENTO,'DD/MM/RRRR HH24:MI:SS') AS REGISTRO 
      FROM ATENDIMENTO.CANCELAUTOMATICO CANCELAUTOMATICO 
         , APOIO.PRODUTOCANCELADO PRODUTOCANCELADO
     WHERE CANCELAUTOMATICO.IDPRODUTOCANCELADO = PRODUTOCANCELADO.IDPRODUTOCANCELADO
       AND TRUNC(CANCELAUTOMATICO.DTCANCELAMENTO) >= TRUNC(SYSDATE-1)
       AND CANCELAUTOMATICO.SGTIPOPESSOA = 'PJ'
       AND PRODUTOCANCELADO.SGPRODUTOCANCELADO = 'MVL_VOZ' ;

              
    EXEC SQL
    SELECT TO_CHAR(SYSDATE,'RRRRMMDD') INTO :sHrArq:i_sHrArq FROM DUAL;
    CONVIND( sHrArq, i_sHrArq );

    sprintf( sNomeArqSaida, "../data/PJ_CNC_MOVEL_%s.csv",(char*)sHrArq.arr    );
    oLog.logDebug(sNomeArqSaida);

    if( (fpOut = fopen( sNomeArqSaida, "w" )) == NULL)
    {
        sprintf(szAux, "@@@ ERRO ABRINDO ARQUIVO [%s]. errno(%d) strerror[%s]", sNomeArqSaida, errno, strerror(errno)); oLog.logError(szAux);
        exit( EXIT_FAILURE );
    }
    
    
    fprintf( fpOut, "%s", "nomeCanal;protocolo;tipoCliente;numeroDocumento;nomeProduto;tipoProduto;codigoAreaRegistro;numeroLinha;" );
    fprintf( fpOut, "%s\n", "codigoAssinatura;nomeCliente;numeroTelefoneOrigem;numeroTelefoneContato;motivoCancelamento;dataCancelamento" );

    EXEC SQL OPEN curCancelMovel;
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    for ( ;; )
    {
        memset( &sRegistro, 0x0, sizeof(sRegistro) );
        EXEC SQL FETCH curCancelMovel 
             INTO :sRegistro:i_sRegistro ;
                  
        CONVIND( sRegistro, i_sRegistro );
        fprintf( fpOut, "%s\n", (char*)sRegistro.arr );
        ctLinhas++;
    }
    EXEC SQL CLOSE curCancelMovel;
    fclose( fpOut );

    sprintf( szAux,    "======================== Sintese do Relatorio ========================\n" ); oLog.logDebug(szAux);
    if ( ctLinhas > 0 )
    {
        if ( ctLinhas > 1 )
        {
           sprintf(szAux, "*** [%d] Registros gravados em [%s] ***\n", ctLinhas, &sNomeArqSaida[8] ); oLog.logDebug(szAux);
        }
        else
        {
           sprintf(szAux, "*** [%d] Registro gravado em [%s] ***\n", ctLinhas, &sNomeArqSaida[8] ); oLog.logDebug(szAux);
        }
    }
    else
    {
        sprintf(szAux, "### !!! Nenhum registro encontrado para o produto [%s], data de pesquisa [%s] ###", 
                      (char*)nmClassificaProdCancel.arr, (char*)dtPesquisa.arr ); oLog.logDebug(szAux);
    }
    sprintf( szAux,    "======================================================================\n" ); oLog.logDebug(szAux);
    
    time(&end_t);
    diff_t = difftime(end_t, start_t);
    hour = diff_t / 3600; 
    diff_t = diff_t % 3600; 
    min = diff_t / 60; 
    diff_t = diff_t % 60; 
    sec = diff_t; 
    
    sprintf( szAux, "---> Tempo de Geracao Relatorio de Cancelamento Movel: %02d:%02d:%02d", hour, min, sec ); oLog.logDebug(szAux);

    oLog.logDebug("<<< CancelMovel");
    return;

SqlError_CancelMovel:
    sprintf(szAux, "####### ERRO ORACLE [%d] MSG: [%s] #######\n", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc ); oLog.logDebug(szAux
);
    DBDisconnect();
    oLog.logDebug("!!! PROCESSAMENTO ABORTADO ###");
    exit( EXIT_FAILURE );

}



void CancelFixa( void )
{
    time_t start_t, end_t;
    
    int diff_t;
    int hour,min,sec; 
    int ctLinhas = 0;
    
    time(&start_t);

    FILE *fpOut;
    char sNomeArqSaida[256];

    EXEC SQL BEGIN DECLARE SECTION;

        VARCHAR sRegistro[256];
        VARCHAR sHrArq[16];
        VARCHAR nmClassificaProdCancel[101];
        VARCHAR dtPesquisa[11];

        short   i_sRegistro = -1;
        short   i_sHrArq = -1;
        short   i_nmClassificaProdCancel = -1;
        short   i_dtPesquisa = -1;
        
    EXEC SQL END DECLARE SECTION;
    
    memset( &sHrArq     , 0x0, sizeof(sHrArq) );
    memset( &nmClassificaProdCancel, 0x0, sizeof(nmClassificaProdCancel) );
    memset( &dtPesquisa , 0x0, sizeof(dtPesquisa) );
    memset( sNomeArqSaida , 0x0, sizeof(sNomeArqSaida) );
    
    oLog.logDebug(">>> CancelFixa");

    EXEC SQL WHENEVER SQLERROR GOTO SqlError_CancelFixa;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    
    EXEC SQL
    SELECT dsprodutocancelado
    INTO :nmClassificaProdCancel:i_nmClassificaProdCancel 
      FROM apoio.produtocancelado
     WHERE sgprodutocancelado = 'FIXO_VOZ';
     
    CONVIND( nmClassificaProdCancel, i_nmClassificaProdCancel );
    
    EXEC SQL
    SELECT TRUNC (SYSDATE - 1)
    INTO :dtPesquisa:i_dtPesquisa
      FROM DUAL;
    
    CONVIND( dtPesquisa, i_dtPesquisa );
    
    EXEC SQL DECLARE curCancelFixa CURSOR FOR
    SELECT 
           CANCELAUTOMATICO.NMORIGEMCANCELAMENTO || ';' || 
           CANCELAUTOMATICO.NRPROTOCOLO || ';' || 
           CANCELAUTOMATICO.SGTIPOPESSOA || ';' || 
           CANCELAUTOMATICO.NRDOCUMENTO || ';' || 
           PRODUTOCANCELADO.SGPRODUTOCANCELADO || ';' || 
           CANCELAUTOMATICO.INTIPOREGISTRO || ';' || 
           CANCELAUTOMATICO.CDAREAREGISTRO || ';' || 
           CANCELAUTOMATICO.NRLINHA || ';' || 
           CANCELAUTOMATICO.CDASSINATURA || ';' ||
           CANCELAUTOMATICO.NMPESSOA || ';' || 
           CANCELAUTOMATICO.NRTELEFONEORIGEM || ';' || 
           CANCELAUTOMATICO.NRTELEFONECONTATO || ';' || 
           CANCELAUTOMATICO.DSMOTIVO || ';' || 
           TO_CHAR(CANCELAUTOMATICO.DTCANCELAMENTO,'DD/MM/RRRR HH24:MI:SS') AS REGISTRO 
      FROM ATENDIMENTO.CANCELAUTOMATICO CANCELAUTOMATICO 
         , APOIO.PRODUTOCANCELADO PRODUTOCANCELADO
     WHERE CANCELAUTOMATICO.IDPRODUTOCANCELADO = PRODUTOCANCELADO.IDPRODUTOCANCELADO
       AND TRUNC(CANCELAUTOMATICO.DTCANCELAMENTO) >= TRUNC(SYSDATE-1)
       AND CANCELAUTOMATICO.SGTIPOPESSOA = 'PJ'
       AND PRODUTOCANCELADO.SGPRODUTOCANCELADO = 'FIXO_VOZ' ;

              
    EXEC SQL
    SELECT TO_CHAR(SYSDATE,'RRRRMMDD') INTO :sHrArq:i_sHrArq FROM DUAL;
    CONVIND( sHrArq, i_sHrArq );

    sprintf( sNomeArqSaida, "../data/PJ_RACO_FIXA_%s.csv",(char*)sHrArq.arr    );
    oLog.logDebug(sNomeArqSaida);

    if( (fpOut = fopen( sNomeArqSaida, "w" )) == NULL)
    {
        sprintf(szAux, "@@@ ERRO ABRINDO ARQUIVO [%s]. errno(%d) strerror[%s]", sNomeArqSaida, errno, strerror(errno)); oLog.logError(szAux);
        exit( EXIT_FAILURE );
    }
    
    fprintf( fpOut, "%s", "nomeCanal;protocolo;tipoCliente;numeroDocumento;nomeProduto;tipoProduto;codigoAreaRegistro;numeroLinha;" );
    fprintf( fpOut, "%s\n", "codigoAssinatura;nomeCliente;numeroTelefoneOrigem;numeroTelefoneContato;motivoCancelamento;dataCancelamento" );

    EXEC SQL OPEN curCancelFixa;
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    for ( ;; )
    {
        memset( &sRegistro, 0x0, sizeof(sRegistro) );
        EXEC SQL FETCH curCancelFixa 
             INTO :sRegistro:i_sRegistro ;
                  
        CONVIND( sRegistro, i_sRegistro );
        fprintf( fpOut, "%s\n", (char*)sRegistro.arr );
        ctLinhas++;
    }
    EXEC SQL CLOSE curCancelFixa;
    fclose( fpOut );

    sprintf( szAux,    "======================== Sintese do Relatorio ========================\n" ); oLog.logDebug(szAux);
    if ( ctLinhas > 0 )
    {
        if ( ctLinhas > 1 )
        {
           sprintf(szAux, "*** [%d] Registros gravados em [%s] ***\n", ctLinhas, &sNomeArqSaida[8] ); oLog.logDebug(szAux);
        }
        else
        {
           sprintf(szAux, "*** [%d] Registro gravado em [%s] ***\n", ctLinhas, &sNomeArqSaida[8] ); oLog.logDebug(szAux);
        }
    }
    else
    {
        sprintf(szAux, "### !!! Nenhum registro encontrado para o produto [%s], data de pesquisa [%s] ###", 
                      (char*)nmClassificaProdCancel.arr, (char*)dtPesquisa.arr ); oLog.logDebug(szAux);
    }
    sprintf( szAux,    "======================================================================\n" ); oLog.logDebug(szAux);
    
    time(&end_t);
    diff_t = difftime(end_t, start_t);
    hour = diff_t / 3600; 
    diff_t = diff_t % 3600; 
    min = diff_t / 60; 
    diff_t = diff_t % 60; 
    sec = diff_t; 
    
    sprintf( szAux, "---> Tempo de Geracao Relatorio de Cancelamento Fixa: %02d:%02d:%02d", hour, min, sec ); oLog.logDebug(szAux);
    

    oLog.logDebug("<<< CancelFixa");
    
    return;

SqlError_CancelFixa:
    sprintf(szAux, "####### ERRO ORACLE [%d] MSG: [%s] #######\n", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc ); oLog.logDebug(szAux
);
    DBDisconnect();
    oLog.logDebug("!!! PROCESSAMENTO ABORTADO ###");
    exit( EXIT_FAILURE );

}



void ExpurgoRelatorio( char * sDiretorio )
{
    EXEC SQL BEGIN DECLARE SECTION;

        int DiaSemana;
        VARCHAR   dtLimite[10];
        short     i_dtLimite = -1;
        int       iDiasHistorico;
        VARCHAR   oraDiasHist[5];
        short     i_oraDiasHist = -1;
        
    EXEC SQL END DECLARE SECTION;
    
    size_t pos;
    int DataLimite;
    int DataArquivo;
    char buffer[10];
    char bfTmp[16];
    char sArquivoRemover[256];
    DIR *dirp;
    struct dirent *dp;

    memset( &oraDiasHist, 0x0, sizeof(oraDiasHist) );
    
    EXEC SQL WHENEVER SQLERROR GOTO SqlError_ExpurgoRelat;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    
    memset( &dtLimite, 0x0, sizeof(dtLimite) );
    memset( buffer   , 0x0, sizeof(buffer) );
    
    oLog.logDebug ( "*** Analisando Relatorios que podem ser removidos ***" );
    
    EXEC SQL
    SELECT DSVALORPARAMETRO INTO :oraDiasHist:i_oraDiasHist FROM APOIO.PARAMETRO WHERE CDPARAMETRO = 'DIAS_EXP_REL_CANCELAUTOM' ;
    if ( i_oraDiasHist != -1 )
    {
        CONVIND( oraDiasHist, i_oraDiasHist );
        iDiasHistorico = atoi( (char*)oraDiasHist.arr );
    }
    else
    {
        iDiasHistorico = 15;
    }

    EXEC SQL 
    SELECT TO_CHAR( TRUNC( SYSDATE - :iDiasHistorico ),'RRRRMMDD' ) INTO :dtLimite:i_dtLimite FROM DUAL;
    
    CONVIND( dtLimite,i_dtLimite );
    DataLimite = atoi((char*)&dtLimite.arr);
    sprintf( szAux, "DataLimite [%d]", DataLimite ); oLog.logDebug(szAux);
    
    dirp = opendir( sDiretorio );
    while( dp = readdir(dirp) )
    {
        memset ( bfTmp, 0x0, sizeof(bfTmp) );
        //sprintf( szAux, "Leu [%s]", (char*)&dp->d_name ); oLog.logDebug(szAux);
        pos = dp->d_namlen - 12;
        if ( pos > 0 )
           sprintf (bfTmp, "%s", (char*)&dp->d_name[pos] );
        else
           continue;
        
        if ( !memcmp(&bfTmp[9], "csv", 3) ) // Identifica que eh arquivo relatorio
        {
            bfTmp[8] = 0x0;
            
            //sprintf( buffer,"%.8s", (char*)&dp->d_name[13] );

            //sprintf( szAux, "Data Arquivo [%s]", bfTmp ); oLog.logDebug(szAux);
    
            DataArquivo = atoi(bfTmp);
            if ( DataArquivo < DataLimite )  // Verifica se arquivo deve ser removido
            {
                sprintf( sArquivoRemover, "%s/%s", sDiretorio, (char*)&dp->d_name );
                sprintf( szAux, "Removendo Arquivo: [%s]", sArquivoRemover ); oLog.logDebug(szAux);
                unlink( sArquivoRemover );
            }
        }
    }
    closedir(dirp);
    return;

SqlError_ExpurgoRelat:
    sprintf(szAux, "####### ERRO ORACLE [%d] MSG: [%s] #######\n", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc ); oLog.logDebug(szAux);
    DBDisconnect();
    oLog.logDebug("!!! PROCESSAMENTO ABORTADO ###");
    exit( EXIT_FAILURE );    
}
