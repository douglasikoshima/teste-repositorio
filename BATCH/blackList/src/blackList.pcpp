/**
 * @modulo  Batch
 * @usecase Batch
 * @author
 * @version $Revision: 1.1.2.2.2.39.18.135.6.5.4.1.4.1.14.1.2.1.2.1 $
 * @CVS     $Author: a5114878 $ - $Date: 2015/12/14 23:37:43 $
 **/

// CRM.SQA_VIVO360 - Defect #9350 - 125693 - CallCenter - O sistema não apresenta o nome do usuário na seção Protocolos enviados
// Agora eh gravado no historico o usuario que inseriu na fila de envio
// 30-06-2015 - Marcelo Nunes


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <iostream.h>
#include <ctype.h>

#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

#define MAX_RETRIES     10

#define LOCK            1
#define UNLOCK          0
#define KILL            2

#ifndef WIN32
#include <unistd.h>
#endif

#include <libxml/xpath.h>
#include <libxml/tree.h>
#include <libxml/parser.h>
#include <libxml/debugXML.h>
#include <libxml/xmlmemory.h>
#include <libxml/tree.h>
#include <libxml/parser.h>
#include <libxml/uri.h>
#include <libxml/entities.h>
#include <libxml/valid.h>
#include <libxml/xmlerror.h>
#include <libxml/parserInternals.h>
#include <libxml/globals.h>
#include <libxml/xpathInternals.h>

#include <tibems/tibems.h>

#include "../include/blackList.h"

#include "../../commons/Propriedade/include/MFile.h"
#include "../../commons/Log/include/Log.h"
#include "../../commons/SplitLine.h"

#include <string>
using namespace std;

EXEC SQL INCLUDE SQLCA;

#define CONVIND(O,I) \
{\
    if (I == -1) { \
        ##O.arr[0]=0; \
    } else { \
        ##O.arr[##O.len]=0; \
    } \
}

//==============================================================================
// Globais
char szAux[1024 + 1];
Log oLog;
int iSignalProcessa = 1;

//==============================================================================
// Protótipos
int ObterParamMaxRegistros(int LimMax);
int Process(char *pszFileName, int iFlagLock);
void UnLockSemaphore(int semid);
void LockSemaphore(int semid);
int InitSemaphore(key_t key, int nsems);

//==============================================================================
// Run
int main(int argc, char* argv[])
{
    time_t start_tib, end_tib;
    time_t start_ins, end_ins;
    time_t start_del, end_del;
    
    time_t start_t, end_t;
    int diff_t;
    int hour,min,sec; 
    
    time(&start_t);
    
    TParamConf tParamConf;

    char szDsValorParametro[256];
    char szDsMsg[1001];
    char szDtAtual[20];
    long iIdAtendimentoProtocolo;
    char szIdAtendimentoProtocolo[255];
    char ddd[3];
    char linha[32];
    char dgInicLinha[2];
    char MsgLinhaFixa[256];

    EXEC SQL BEGIN DECLARE SECTION;
        const int MAX_REGS = 100000;

        int maxRegs;
        int linhas_retornadas;
        int linhas_processadas;
        const char *pOraQuery;
        int inOrdenacao = 0;
        short i_inOrdenacao = -1;

        VARCHAR lstDadoOraIdAtendimentoProtocolo[39];
        VARCHAR lstDadoOraCdAreaRegistro[4];
        VARCHAR lstDadoOraNrLinha[11];
        VARCHAR lstDadoOraDsMensagemEnvio[1001];
        VARCHAR lstDadoOraDsMotivoNaoEnvio[256];
        int lstDadoOraInEnvioSMS;
        int lstDadoOraTpEnvio;
        
        // CRM.SQA_VIVO360 - Defect #9350 - 125693 - CallCenter - O sistema não apresenta o nome do usuário na seção Protocolos enviados
        // Agora eh gravado no historico o usuario que inseriu na fila de envio
        // 30-06-2015 - Marcelo Nunes
        VARCHAR idUsuarioAlteracao[256];   
        
        VARCHAR cdOrigem[256];
        VARCHAR idLinhaTelefonica[256];
        
        VARCHAR lstRowId[256];

        short lstStatOraIdAtendimentoProtocolo;
        short lstStatOraCdAreaRegistro;
        short lstStatOraNrLinha;
        short lstStatOraDsMensagemEnvio;
        short lstStatOraDsMotivoNaoEnvio;
        short lstStatOraInEnvioSMS;
        short lstStatOraTpEnvio;
        
        short i_cdOrigem;
        short i_idLinhaTelefonica;
        
        VARCHAR DSVALORPARAMETRO[256];
        short iDSVALORPARAMETRO=0;
        
        VARCHAR DTATUAL[256];
        short i_DTATUAL = -1;
        
        VARCHAR prmMsgProtMovelPros[256];
        short i_prmMsgProtMovelPros = -1;
        
        VARCHAR prmMsgProtFixaClie[256];
        short i_prmMsgProtFixaClie = -1;
        
        VARCHAR prmMsgProtFixaPros[256];
        short i_prmMsgProtFixaPros = -1;

        // CRM.SQA_VIVO360 - Defect #9350 - 125693 - CallCenter - O sistema não apresenta o nome do usuário na seção Protocolos enviados
        // Agora eh gravado no historico o usuario que inseriu na fila de envio
        // 30-06-2015 - Marcelo Nunes
        short i_idUsuarioAlteracao = -1;
        
    EXEC SQL END DECLARE SECTION;

    int ctCommit = 0;

    int iStatusEnvioSMS;

    tibemsSSLParams sslParams = NULL;
    tibemsQueueConnection queueConnection = NULL;
    tibemsQueue queue = NULL;
    tibemsQueueSession queueSession = NULL;
    tibemsQueueSender queueSender = NULL;
    tibems_status status = TIBEMS_OK;

    char szDsMensagemEnvio[601];
    char szDsListaClassificacao[601] = {0};
    char szidClassificacaoSMS[40];

    oLog.setNivel(2);

    oLog.logDebug(">>>blackList");

    ArmaSinal(SIGTERM);

    //==========================================================================
    // Parâmetros de configuração
    if(ObtemParamConf(&tParamConf))
    {
        oLog.logError("Erro obtendo parametros de configuracao");
        //return -1;
        exit(1);
    }


    //==========================================================================
    // Conecta ao banco
    oLog.logDebug("Conectando na BD...");
    if (DBConnect(tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst))
    {
        oLog.logError("Erro conectando no banco de dados");
        //Process(argv[0], UNLOCK);
        oLog.logDebug("UNLOck executado");
        //return -1;
        exit(1);
    }
    oLog.logDebug("Conectado na BD com sucesso...");

    //==========================================================================
    // Lock
    oLog.logDebug("Vai locar fila de processamento...");
    int iRet = Process(argv[0],LOCK);
    if(iRet)
    {
        oLog.logInformation("Saida por TIMEOUT");
        //return -1;
        exit(1);
    }
    oLog.logDebug("Locou fila de processamento");


    //==========================================================================
    // Limite máximo de registros
    sprintf(szAux,"Limite maximo permitido=%d",MAX_REGS);oLog.logDebug(szAux);
    maxRegs = ObterParamMaxRegistros(MAX_REGS);
    sprintf(szAux,"Limite parametrizado=%d",maxRegs);oLog.logDebug(szAux);
    
    //==========================================================================
    // Trata mensagem?
    ObterParamMsgParse(&tParamConf);
    sprintf(szAux,"Tratamento da Mensagem=%s",tParamConf.szMessageParse);oLog.logDebug(szAux);

    //==========================================================================
    // Logar mensagem ?
    ObterParamMsgLog(&tParamConf);
    sprintf(szAux,"Log da Mensagem=%s",tParamConf.szMessageLog);oLog.logDebug(szAux);

    EXEC SQL WHENEVER SQLERROR GOTO sqlError;
    // a mensagem de envio DSMENSAGEMENVIO somada com o complemento deve conter 140 caracteres.
    // Se a primeira parte for superior a 72, devemos enviar apenas a primeira parte da mensagem.


    EXEC SQL DECLARE curBlackList CURSOR FOR
    SELECT  
        IDATENDIMENTOPROTOCOLO,
        CDAREAREGISTRO,
        NRLINHA,
        DSMENSAGEMENVIO,
        INENVIOSMS,
        TPENVIO, 
        IDUSUARIOALTERACAO ,
        CDORIGEM,
        DTATUAL,
        idtipolinha , --idlinhatelefonica
        RID
    FROM
    (
        SELECT  /*+ INDEX_DESC(FILASMSPROTOCOLO) */
            FILASMSPROTOCOLO.IDATENDIMENTOPROTOCOLO,
            FILASMSPROTOCOLO.CDAREAREGISTRO,
            FILASMSPROTOCOLO.NRLINHA,
            (case when (length(FILASMSPROTOCOLO.DSMENSAGEMENVIO) + 69 <= 140) then
            FILASMSPROTOCOLO.DSMENSAGEMENVIO || '. ' || NVL(COMPLEMENTOSMS.DSCOMPLEMENTO,'Fale conosco tambem pelo vivo.com.br/meuvivo ou envie SMS para 1058') else
            FILASMSPROTOCOLO.DSMENSAGEMENVIO||'.' end)dsmensagemenvio,
            FILASMSPROTOCOLO.INENVIOSMS,
            FILASMSPROTOCOLO.TPENVIO,
            FILASMSPROTOCOLO.IDUSUARIOALTERACAO ,
            FILASMSPROTOCOLO.ROWID AS RID,
        --INICIO POGMASTER
            (CASE WHEN FILASMSPROTOCOLO.IDTIPOLINHA<9 THEN 'MOVEL' 
                  WHEN FILASMSPROTOCOLO.IDTIPOLINHA>=9 THEN 'FIXO'
                  ELSE NULL END)CDORIGEM,
                 to_char(DTENCERRAMENTO,'dd/mm/rrrr')||' as '||to_char(DTENCERRAMENTO-1/24,'hh24:mi') as dtatual,
                 FILASMSPROTOCOLO.IDTIPOLINHA
        --FIM POGMASTER
        FROM
            ATENDIMENTO.FILASMSPROTOCOLO FILASMSPROTOCOLO ,
            ATENDIMENTO.COMPLEMENTOSMS   COMPLEMENTOSMS
        WHERE
            FILASMSPROTOCOLO.DTENCERRAMENTO < SYSTIMESTAMP
        AND FILASMSPROTOCOLO.CDAREAREGISTRO = COMPLEMENTOSMS.CDAREAREGISTRO(+)
        AND FILASMSPROTOCOLO.IDTIPOLINHA = COMPLEMENTOSMS.IDTIPOLINHA(+)
        AND FILASMSPROTOCOLO.SGTIPOPESSOA = COMPLEMENTOSMS.SGTIPOPESSOA(+)
        AND FILASMSPROTOCOLO.SGUF = COMPLEMENTOSMS.SGUF(+)
        AND NVL(COMPLEMENTOSMS.STATUS,1) = 1
        AND FILASMSPROTOCOLO.TPENVIO = 1
        AND ROWNUM <= :maxRegs
    );
   

    memset(&lstDadoOraIdAtendimentoProtocolo,0,sizeof(lstDadoOraIdAtendimentoProtocolo));
    memset(&lstDadoOraCdAreaRegistro,0,sizeof(lstDadoOraCdAreaRegistro));
    memset(&lstDadoOraNrLinha,0,sizeof(lstDadoOraNrLinha));
    memset(&lstDadoOraDsMensagemEnvio,0,sizeof(lstDadoOraDsMensagemEnvio));
    memset(&lstDadoOraDsMotivoNaoEnvio,0,sizeof(lstDadoOraDsMotivoNaoEnvio));
    memset(&lstDadoOraInEnvioSMS,0,sizeof(lstDadoOraInEnvioSMS));
    memset(&lstDadoOraTpEnvio,0,sizeof(lstDadoOraTpEnvio));
    memset(&lstRowId,0,sizeof(lstRowId));

    memset(&lstStatOraIdAtendimentoProtocolo,-1,sizeof(lstStatOraIdAtendimentoProtocolo));
    memset(&lstStatOraCdAreaRegistro,-1,sizeof(lstStatOraCdAreaRegistro));
    memset(&lstStatOraNrLinha,-1,sizeof(lstStatOraNrLinha));
    memset(&lstStatOraDsMensagemEnvio,-1,sizeof(lstStatOraDsMensagemEnvio));
    memset(&lstStatOraDsMotivoNaoEnvio,-1,sizeof(lstStatOraDsMotivoNaoEnvio));
    memset(&lstStatOraInEnvioSMS,-1,sizeof(lstStatOraInEnvioSMS));
    memset(&lstStatOraTpEnvio,-1,sizeof(lstStatOraTpEnvio));
    
    memset( ddd  , 0x0, sizeof(ddd) );
    memset( linha, 0x0, sizeof(linha) );
    
    memset( &prmMsgProtMovelPros, 0x0, sizeof(prmMsgProtMovelPros) );
    memset( &prmMsgProtFixaClie,  0x0, sizeof(prmMsgProtFixaClie) );
    memset( &prmMsgProtFixaPros,  0x0, sizeof(prmMsgProtFixaPros) );

    memset( &idUsuarioAlteracao,  0x0, sizeof(idUsuarioAlteracao) );
    


    //==========================================================================
    // Processa

        // Conecta com fila Tibco
        oLog.logDebug("Iniciando conexao JMS...");

        const char *queueName = tParamConf.szQueueName;     // VIVO.FO.SMS.SEND
        const char *serverUrl = tParamConf.szServerUrl;     // astorga.telespcelular.com.br
        const char *userName = tParamConf.szUserName;       // admin
        const char *password = tParamConf.szPassword;       // 71b60
        const char *pk_password = tParamConf.szPk_password; // teste

        sprintf(szAux, "  queueName=%s", queueName); oLog.logDebug(szAux);
        sprintf(szAux, "  serverUrl=%s", serverUrl); oLog.logDebug(szAux);
        //sprintf(szAux, "   userName=%s", userName); oLog.logDebug(szAux);
        //sprintf(szAux, "   password=%s", password); oLog.logDebug(szAux);
        //sprintf(szAux, "pk_password=%s", pk_password); oLog.logDebug(szAux);

        // Create the connection, use ssl if specified
        if(sslParams)
        {
            status = tibemsQueueConnection_CreateSSL(&queueConnection, serverUrl, NULL, userName, password, sslParams, pk_password);
        }
        else
        {
            status = tibemsQueueConnection_Create(&queueConnection, serverUrl, NULL, userName, password);
        }

        if (status != TIBEMS_OK)
        {
            oLog.logDebug("Falha de conexão à fila Tibco...");
            oLog.logDebug("Liberando fila...");
            Process(argv[0], UNLOCK);
            oLog.logDebug("Desconectando da BD...");
            DBDisconnect();
            Fail("Error creating tibemsQueueConnection", status);
                            exit(1);
        }

        // create the queue session
        status = tibemsQueue_Create(&queue, queueName);
        if (status != TIBEMS_OK)
        {
            oLog.logDebug("Falha de conexão à fila Tibco...");

            oLog.logDebug("Liberando fila...");
            Process(argv[0], UNLOCK);

            oLog.logDebug("Desconectando da BD...");
            DBDisconnect();


            Fail("Error tibemsQueue_Create", status);
                            exit(1);
        }

        // create the queue session
        status = tibemsQueueConnection_CreateQueueSession(queueConnection, &queueSession, TIBEMS_FALSE, TIBEMS_AUTO_ACKNOWLEDGE);
        if (status != TIBEMS_OK)
        {
            oLog.logDebug("Falha de conexão à fila Tibco...");

                            oLog.logDebug("Liberando fila...");
            Process(argv[0], UNLOCK);

                            oLog.logDebug("Desconectando da BD...");
            DBDisconnect();



            Fail("Error tibemsQueueConnection_CreateQueueSession", status);
                            exit(1);
        }

        // create the queue sender
        status = tibemsQueueSession_CreateSender(queueSession, &queueSender, queue);
        if (status != TIBEMS_OK)
        {
            oLog.logDebug("Falha de conexão à fila Tibco...");

            oLog.logDebug("Liberando fila...");
            Process(argv[0], UNLOCK);

            oLog.logDebug("Desconectando da BD...");
            DBDisconnect();

            Fail("Error tibemsQueueSession_CreateSender", status);
                            exit(1);
        }

        oLog.logDebug("Iniciando conexao JMS OK...");
        oLog.logDebug("Enviando SMS's...");

        //======================================================================
        // Envia os SMS's que tiverem de ser enviados...
        int qtEnviadas = 0;
                    linhas_processadas = 0;
        int iQtdContatoZero = 0;
        
        int iqtdlinhasErroTibco = 0;  // INCLUIDO NA ALTERACAO DE PERFORMANCE
        int iqtdlinhasFixo = 0;
        int iqtdlinhasNaoIdent = 0;
        //for( int i = 0; i < linhas_retornadas; i++, linhas_processadas++ )
        
        i_prmMsgProtMovelPros = -1;
        exec sql
        select 
           parm.dsvalorparametro
        into
           :prmMsgProtMovelPros:i_prmMsgProtMovelPros
        from 
           apoio.parametro parm
        where
           PARM.CDPARAMETRO = 'MSG_PROT_MOVEL_PROS' ;

        i_prmMsgProtMovelPros = -1;
        exec sql
        select 
           parm.dsvalorparametro
        into
           :prmMsgProtFixaClie:i_prmMsgProtFixaClie
        from 
           apoio.parametro parm
        where
           PARM.CDPARAMETRO = 'MSG_PROT_FIXA_CLIE' ;
        
        i_prmMsgProtMovelPros = -1;
        exec sql
        select 
           parm.dsvalorparametro
        into
           :prmMsgProtFixaPros:i_prmMsgProtFixaPros
        from 
           apoio.parametro parm
        where
           PARM.CDPARAMETRO = 'MSG_PROT_FIXA_PROS' ;
           

        EXEC SQL WHENEVER NOT FOUND DO BREAK;
        
        EXEC SQL OPEN curBlackList;

        for( ; ; linhas_processadas++ )
        {
            //sprintf(szAux, "linhas_processadas[%d] executando...",linhas_processadas); oLog.logDebug(szAux);
            
        i_idUsuarioAlteracao = i_DTATUAL = iStatusEnvioSMS = i_idLinhaTelefonica = i_cdOrigem = -1;

            memset(&lstDadoOraIdAtendimentoProtocolo,0,sizeof(lstDadoOraIdAtendimentoProtocolo));
            memset(&lstDadoOraCdAreaRegistro,0,sizeof(lstDadoOraCdAreaRegistro));
            memset(&lstDadoOraNrLinha,0,sizeof(lstDadoOraNrLinha));
            memset(&lstDadoOraDsMensagemEnvio,0,sizeof(lstDadoOraDsMensagemEnvio));
            memset(&lstDadoOraDsMotivoNaoEnvio,0,sizeof(lstDadoOraDsMotivoNaoEnvio));
            memset(&lstDadoOraInEnvioSMS,0,sizeof(lstDadoOraInEnvioSMS));
            memset(&lstDadoOraTpEnvio,0,sizeof(lstDadoOraTpEnvio));
            memset(&lstRowId,0,sizeof(lstRowId));

            memset(&lstStatOraIdAtendimentoProtocolo,-1,sizeof(lstStatOraIdAtendimentoProtocolo));
            memset(&lstStatOraCdAreaRegistro,-1,sizeof(lstStatOraCdAreaRegistro));
            memset(&lstStatOraNrLinha,-1,sizeof(lstStatOraNrLinha));
            memset(&lstStatOraDsMensagemEnvio,-1,sizeof(lstStatOraDsMensagemEnvio));
            memset(&lstStatOraDsMotivoNaoEnvio,-1,sizeof(lstStatOraDsMotivoNaoEnvio));
            memset(&lstStatOraInEnvioSMS,-1,sizeof(lstStatOraInEnvioSMS));
            memset(&lstStatOraTpEnvio,-1,sizeof(lstStatOraTpEnvio));
            
            memset( ddd  , 0x0, sizeof(ddd) );
            memset( linha, 0x0, sizeof(linha) );

        memset( &idUsuarioAlteracao, 0x0, sizeof(idUsuarioAlteracao) );

            if(iSignalProcessa == 0)
            {
                oLog.logDebug("3.Tratamento de sinal de termino dentro do loop");
                break;
            }

            EXEC SQL FETCH curBlackList
            INTO
                :lstDadoOraIdAtendimentoProtocolo:lstStatOraIdAtendimentoProtocolo,
                :lstDadoOraCdAreaRegistro:lstStatOraCdAreaRegistro,
                :lstDadoOraNrLinha:lstStatOraNrLinha,
                :lstDadoOraDsMensagemEnvio:lstStatOraDsMensagemEnvio,
                :lstDadoOraInEnvioSMS:lstStatOraInEnvioSMS,
                :lstDadoOraTpEnvio:lstStatOraTpEnvio,
            :idUsuarioAlteracao:i_idUsuarioAlteracao ,
                :cdOrigem:i_cdOrigem,
                :DTATUAL:i_DTATUAL,
                :idLinhaTelefonica:i_idLinhaTelefonica,
                :lstRowId;

            CONVIND( lstDadoOraIdAtendimentoProtocolo,lstStatOraIdAtendimentoProtocolo );
            CONVIND( lstDadoOraCdAreaRegistro,lstStatOraCdAreaRegistro );
            CONVIND( lstDadoOraNrLinha,lstStatOraNrLinha );
            CONVIND( lstDadoOraDsMensagemEnvio,lstStatOraDsMensagemEnvio );
        CONVIND( idUsuarioAlteracao, i_idUsuarioAlteracao );

       /* EXEC SQL

	    IDATENDIMENTOPROTOCOLO,
       CDAREAREGISTRO,
       NRLINHA,
       DSMENSAGEMENVIO,
       INENVIOSMS,
       TPENVIO, 
       CDORIGEM,
       dtatual,
       idtipolinha, --idlinhatelefonica
       RID
        SELECT
            UPPER(CDORIGEM) as CDORIGEM,
            to_char(dtabertura,'dd/mm/rrrr')||' as '||to_char(dtabertura,'hh24:mi') as dtatual,
            IDLINHATELEFONICA
        INTO
            :cdOrigem:i_cdOrigem,
            :DTATUAL:i_DTATUAL,
            :idLinhaTelefonica:i_idLinhaTelefonica
        FROM
           ATENDIMENTO.ATENDIMENTOPROTOCOLO
        WHERE
           IDATENDIMENTOPROTOCOLO = :lstDadoOraIdAtendimentoProtocolo ;
		*/
            CONVIND( cdOrigem,i_cdOrigem );
            CONVIND( DTATUAL, i_DTATUAL );
            CONVIND( idLinhaTelefonica, i_idLinhaTelefonica );

            // Se existir suspeita de mensagem com lixo, podemos habilitar tratamento
            if ( 'S' == tParamConf.szMessageParse[0] )
            {
                int lenMensagem = strlen((char*)lstDadoOraDsMensagemEnvio.arr);

                char *p = strstr((char*)lstDadoOraDsMensagemEnvio.arr," as ");
                if ( p==0 ) { p = strstr((char*)lstDadoOraDsMensagemEnvio.arr," AS "); }
                int posIni = p - (char*)lstDadoOraDsMensagemEnvio.arr + 12; // 12 = tam de " as hh:mm - ";
                if ( posIni < 0 || posIni > lenMensagem ) { posIni=0; }

                for( int j=posIni;j<lenMensagem;j++ )
                {
                    if ( lstDadoOraDsMensagemEnvio.arr[j] < 32 || lstDadoOraDsMensagemEnvio.arr[j] > 125 )
                    {
                         lstDadoOraDsMensagemEnvio.arr[j] = ' ';
                    }
                }
            } // if ( 'S' == tParamConf.szMessageParse[0] )

            if ( 1 == lstDadoOraInEnvioSMS )
            {
                //oLog.logDebug( "Tratando MSG para Prospect / Fixo..." );
                
                //sprintf(szAux, "*** CDORIGEM                    [%s]",(const char*)cdOrigem.arr); oLog.logDebug(szAux);
                //sprintf(szAux, "*** Indicator CDORIGEM          [%d]",i_cdOrigem); oLog.logDebug(szAux);
                //sprintf(szAux, "*** Indicator idLinhaTelefonica [%d]",i_idLinhaTelefonica); oLog.logDebug(szAux);
                
                if ( (!strcmp((const char*)cdOrigem.arr, "MOVEL") || i_cdOrigem == -1) && i_idLinhaTelefonica == -1 || !strcmp((const char*)cdOrigem.arr, "FIXO") )
                {
                    if ( (!strcmp((const char*)cdOrigem.arr, "MOVEL") || i_cdOrigem == -1) && i_idLinhaTelefonica == -1 && i_prmMsgProtMovelPros != -1 )
                    {
                        //oLog.logDebug( "Movel -> Prospect..." );
                        STRCPY_FROM_ORA(szDsValorParametro, prmMsgProtMovelPros );
                        STRCPY_FROM_ORA(szDtAtual, DTATUAL);
                        STRCPY_FROM_ORA(szIdAtendimentoProtocolo,lstDadoOraIdAtendimentoProtocolo);
                        iIdAtendimentoProtocolo = atol(szIdAtendimentoProtocolo);
                        memset(szDsMsg,0,sizeof(szDsMsg));
                        sprintf(szDsMsg, szDsValorParametro, iIdAtendimentoProtocolo, szDtAtual);
                        memset(lstDadoOraDsMensagemEnvio.arr,0,sizeof(lstDadoOraDsMensagemEnvio.arr));
                        STRCPY_TO_ORA(lstDadoOraDsMensagemEnvio, szDsMsg);
                    }
                    else if ( !strcmp((const char*)cdOrigem.arr, "FIXO") && i_idLinhaTelefonica != -1 && i_prmMsgProtFixaClie != -1 )
                    {
                        //oLog.logDebug( "Fixo -> Cliente..." );
                        STRCPY_FROM_ORA(szDsValorParametro, prmMsgProtFixaClie );
                        STRCPY_FROM_ORA(szDtAtual, DTATUAL);
                        STRCPY_FROM_ORA(szIdAtendimentoProtocolo,lstDadoOraIdAtendimentoProtocolo);
                        iIdAtendimentoProtocolo = atol(szIdAtendimentoProtocolo);
                        memset(szDsMsg,0,sizeof(szDsMsg));
                        sprintf(szDsMsg, szDsValorParametro, iIdAtendimentoProtocolo, szDtAtual);
                        memset(lstDadoOraDsMensagemEnvio.arr,0,sizeof(lstDadoOraDsMensagemEnvio.arr));
                        STRCPY_TO_ORA(lstDadoOraDsMensagemEnvio, szDsMsg);
                    }
                    else
                    {
                        if ( i_prmMsgProtFixaPros != -1 )
                        {
                            //oLog.logDebug( "Fixo -> Prospect..." );
                            STRCPY_FROM_ORA(szDsValorParametro, prmMsgProtFixaPros );
                            STRCPY_FROM_ORA(szDtAtual, DTATUAL);
                            STRCPY_FROM_ORA(szIdAtendimentoProtocolo,lstDadoOraIdAtendimentoProtocolo);
                            iIdAtendimentoProtocolo = atol(szIdAtendimentoProtocolo);
                            memset(szDsMsg,0,sizeof(szDsMsg));
                            sprintf(szDsMsg, szDsValorParametro, iIdAtendimentoProtocolo, szDtAtual);
                            memset(lstDadoOraDsMensagemEnvio.arr,0,sizeof(lstDadoOraDsMensagemEnvio.arr));
                            STRCPY_TO_ORA(lstDadoOraDsMensagemEnvio, szDsMsg);
                        }
                    }
                }

                sprintf( ddd, "%s",(const char*)lstDadoOraCdAreaRegistro.arr );
                sprintf( linha, "%s",(const char*)lstDadoOraNrLinha.arr );
                
                if ( atoi(ddd) > 0 )
                {
                    if ( atoi(linha) > 0 )
                    {
                        memset( dgInicLinha, 0x0, sizeof(dgInicLinha) );
                        dgInicLinha[0] = linha[0]; // atribui o primeiro digito da linha para identificacao de movel ou fixo
                        
                        if ( atoi(dgInicLinha) < 5 )  // Considerado Linha de Fixo, nao sera enviado SMS
                        {
                            memset( MsgLinhaFixa, 0x0, sizeof(MsgLinhaFixa) );
                            sprintf( MsgLinhaFixa, "SMS não enviado para linha fixa: (%s) %.4s-%.4s", (const char*)ddd, (const char*)linha, (const char*)&linha[4] );
                            strcpy((char*)lstDadoOraDsMotivoNaoEnvio.arr,
                                MsgLinhaFixa );
                            lstDadoOraDsMotivoNaoEnvio.len =
                                strlen((char*)lstDadoOraDsMotivoNaoEnvio.arr);
                            lstStatOraDsMotivoNaoEnvio = 1;

                            sprintf( szAux,">>> SMS NÃO ENVIADO: Linha de Fixo - idAtdProtocolo=[%s] DDD=[%s] linha=[%s] "
                                          ,(const char*)lstDadoOraIdAtendimentoProtocolo.arr
                                          ,(const char*)lstDadoOraCdAreaRegistro.arr
                                          ,(const char*)lstDadoOraNrLinha.arr);
                            //oLog.logDebug(szAux);
                            iqtdlinhasErroTibco++;
                            iqtdlinhasFixo++;
                        }
                        else   // Considerado linha movel, pode enviar SMS
                        {
                            time(&start_tib);
                            
                            iStatusEnvioSMS = 0;
                            iStatusEnvioSMS = EnviarMensagemTibco((const char*)lstDadoOraIdAtendimentoProtocolo.arr
                                               ,(const char*)lstDadoOraCdAreaRegistro.arr
                                               ,(const char*)lstDadoOraNrLinha.arr
                                               ,(const char*)lstDadoOraDsMensagemEnvio.arr
                                               ,tParamConf.szQueueName
                                               ,argv[0]
                                               ,queueSender
                                               ,tParamConf.szMessageLog
                                               );
                            
                            time(&end_tib);
                            
                            diff_t = difftime(end_tib, start_tib);
                            //sprintf(szAux, "Tempo de execucao ENVIO TIBCO: %f segundos",diff_t); oLog.logDebug(szAux);

                            if ( iStatusEnvioSMS < 0 )
                            {
                                iqtdlinhasErroTibco++;
                            }
                            if ( iStatusEnvioSMS == 1 )
                            {
                                qtEnviadas++;
                            }

                            sprintf( szAux,"SMS ENVIADO - idAtdProtocolo [%s] DDD [%s] linha [%s] - MSG [%s]"
                                          ,(const char*)lstDadoOraIdAtendimentoProtocolo.arr
                                          ,(const char*)lstDadoOraCdAreaRegistro.arr
                                          ,(const char*)lstDadoOraNrLinha.arr
                                          ,(const char*)lstDadoOraDsMensagemEnvio.arr );
                            //oLog.logDebug(szAux);
                        }
                    }
                    else
                    {
                        memset( MsgLinhaFixa, 0x0, sizeof(MsgLinhaFixa) );
                        sprintf( MsgLinhaFixa, "Linha inválida para o envio de SMS: (%s) %.4s-%.4s", (const char*)ddd, (const char*)linha, (const char*)&linha[4] );
                        strcpy( (char*)lstDadoOraDsMotivoNaoEnvio.arr,
                            MsgLinhaFixa );
                        lstDadoOraDsMotivoNaoEnvio.len =
                            strlen((char*)lstDadoOraDsMotivoNaoEnvio.arr);
                        lstStatOraDsMotivoNaoEnvio = 1;

                        sprintf( szAux,">>> SMS NÃO ENVIADO - idAtdProtocolo=[%s] DDD=[%s] linha=[%s] "
                                      ,(const char*)lstDadoOraIdAtendimentoProtocolo.arr
                                      ,(const char*)lstDadoOraCdAreaRegistro.arr
                                      ,(const char*)lstDadoOraNrLinha.arr);
                        //oLog.logDebug(szAux);
                        iqtdlinhasErroTibco++;
                        iqtdlinhasNaoIdent++;
                    }
                }
                else
                {
                    memset( MsgLinhaFixa, 0x0, sizeof(MsgLinhaFixa) );
                    sprintf( MsgLinhaFixa, "Linha inválida para o envio de SMS: (%s) %.4s-%.4s", (const char*)ddd, (const char*)linha, (const char*)&linha[4] );
                    strcpy( (char*)lstDadoOraDsMotivoNaoEnvio.arr,
                        MsgLinhaFixa );
                    lstDadoOraDsMotivoNaoEnvio.len =
                        strlen((char*)lstDadoOraDsMotivoNaoEnvio.arr);
                    lstStatOraDsMotivoNaoEnvio = 1;

                    sprintf( szAux,"SMS NÃO ENVIADO - idAtdProtocolo=[%s] DDD=[%s] linha=[%s] "
                                  ,(const char*)lstDadoOraIdAtendimentoProtocolo.arr
                                  ,(const char*)lstDadoOraCdAreaRegistro.arr
                                  ,(const char*)lstDadoOraNrLinha.arr);
                    //oLog.logDebug(szAux);
                    iqtdlinhasErroTibco++;
                    iqtdlinhasNaoIdent++;
                }

                sprintf( szAux,"MSG ENVIADA [%s]"
                                   ,(const char*)lstDadoOraDsMensagemEnvio.arr );
                //oLog.logDebug(szAux);					
            }
            else
            {
                strcpy((char*)lstDadoOraDsMotivoNaoEnvio.arr,
                    "SMS não enviado para este protocolo pois todas folhas "
                                        "de contato foram configuradas com INSMS=0");
                lstDadoOraDsMotivoNaoEnvio.len =
                    strlen((char*)lstDadoOraDsMotivoNaoEnvio.arr);
                lstStatOraDsMotivoNaoEnvio = 1;

                sprintf( szAux,"SMS NÃO ENVIADO - idAtdProtocolo=[%s] DDD=[%s] linha=[%s] "
                              ,(const char*)lstDadoOraIdAtendimentoProtocolo.arr
                              ,(const char*)lstDadoOraCdAreaRegistro.arr
                              ,(const char*)lstDadoOraNrLinha.arr);
                //oLog.logDebug(szAux);
                iqtdlinhasErroTibco++;
                iQtdContatoZero++;
            }

            time(&start_ins);
         EXEC SQL 
        INSERT /*+ append */ INTO ATENDIMENTO.FILASMSPROTOCOLOHIST
            (
                IDATENDIMENTOPROTOCOLO,
                CDAREAREGISTRO,
                NRLINHA,
                DSMENSAGEMENVIO,
                DSMOTIVONAOENVIO,
                DTULTIMAALTERACAO,
                IDUSUARIOALTERACAO,
                TPENVIO ,
                INENVIOSMS
            )
            VALUES
            (
                :lstDadoOraIdAtendimentoProtocolo:lstStatOraIdAtendimentoProtocolo,
                :lstDadoOraCdAreaRegistro:lstStatOraCdAreaRegistro,
                :lstDadoOraNrLinha:lstStatOraNrLinha,
                :lstDadoOraDsMensagemEnvio:lstStatOraDsMensagemEnvio,
                :lstDadoOraDsMotivoNaoEnvio:lstStatOraDsMotivoNaoEnvio,
                SYSTIMESTAMP,
            :idUsuarioAlteracao:i_idUsuarioAlteracao ,
                :lstDadoOraTpEnvio:lstStatOraTpEnvio ,
                :lstDadoOraInEnvioSMS:lstStatOraInEnvioSMS
            );

            time(&end_ins);
            diff_t = difftime(end_ins, start_ins);
            //sprintf(szAux, "Tempo de execucao INSERT: %f segundos",diff_t); oLog.logDebug(szAux);

            time(&start_del);

            EXEC SQL
		//update ATENDIMENTO.FILASMSPROTOCOLO
		//set TPENVIO=-1
		//where  ROWID = :lstRowId; 	

            DELETE
                ATENDIMENTO.FILASMSPROTOCOLO
            WHERE
                ROWID = :lstRowId;

            time(&end_del);
            diff_t = difftime(end_del, start_del);
            //sprintf(szAux, "Tempo de execucao DELETE: %f segundos",diff_t); oLog.logDebug(szAux);

            if ( ctCommit > 999 )
            {
                EXEC SQL COMMIT;
                //EXEC SQL COMMIT WORK;
		sprintf(szAux, "Tempo de execucao DELETE: %f segundos",diff_t); oLog.logDebug(szAux);
               
               ctCommit = 0;
            }
            else
            {
               ctCommit++;
            }


        } // for(;;)

        EXEC SQL CLOSE curBlackList;

        sprintf(szAux, "Qtd de linhas processadas [%d]",linhas_processadas); oLog.logDebug(szAux);
        sprintf(szAux, "Qtd de linhas enviadas [%d]",qtEnviadas); oLog.logDebug(szAux);
        sprintf(szAux, "Qtd de linhas não processadas [%d]",iqtdlinhasErroTibco); oLog.logDebug(szAux);
        sprintf(szAux, "Qtd de protocolos abertos por contato ajustado para NÃO envio de SMS [%d]",iQtdContatoZero); oLog.logDebug(szAux);
        sprintf(szAux, "Qtd de linhas de fixo [%d]",iqtdlinhasFixo); oLog.logDebug(szAux);
        sprintf(szAux, "Qtd de linhas com DDD = 0 e Telefone = 0 [%d]",iqtdlinhasNaoIdent); oLog.logDebug(szAux);
        
        
        oLog.logDebug("Fim do procedimento de envio de SMS...");
        EXEC SQL COMMIT;


        //======================================================================
        // Desconecta da fila Tibco
        oLog.logDebug("Fechando conexao JMS...");

        // destroy the queue
        status = tibemsQueue_Destroy(queue);
        if (status != TIBEMS_OK)
        {
            sprintf( szAux,"Error tibemsQueue_Destroy=[%d]",status );
            oLog.logDebug(szAux);
        }
        else
        {
            // close the connection
            status = tibemsConnection_Close(queueConnection);
            if (status != TIBEMS_OK)
            {
                sprintf( szAux,"Error tibemsConnection_Close=[%d]",status );
                oLog.logDebug(szAux);
            }
            else
            {
                // destroy the ssl params
                tibemsSSLParams_Destroy(sslParams);
                oLog.logDebug("Fechando conexao JMS OK...");
            }
        }


        
    //sprintf(szAux, "Quantidade de linhas processadas %d",linhas_processadas); oLog.logDebug(szAux);


    oLog.logDebug("Liberando fila...");
    Process(argv[0], UNLOCK);

    oLog.logDebug("Desconectando da BD...");
    DBDisconnect();

    oLog.logDebug("Processamento encerrado");
    
    time(&end_t);
    diff_t = difftime(end_t, start_t);
    hour = diff_t / 3600; 
    diff_t = diff_t % 3600; 
    min = diff_t / 60; 
    diff_t = diff_t % 60; 
    sec = diff_t; 
    
    sprintf( szAux, "Tempo de execucao: %02d:%02d:%02d", hour, min, sec ); oLog.logDebug(szAux);
    
    oLog.logDebug("<<<blackList");

    //return 0;
    exit(0);

    sqlError:
        oLog.logDebug("Liberando fila por erro...");
        Process(argv[0], UNLOCK);

        sprintf(szAux, "Finalizando processo com erro ORACLE (%d-%.256s)",
                    sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);

        EXEC SQL ROLLBACK;

        oLog.logDebug("Vai tentar desconectar da BD...");
        DBDisconnect();
        
        time(&end_t);
        diff_t = difftime(end_t, start_t);
        sprintf(szAux, "Tempo de execucao: %f segundos",diff_t); oLog.logDebug(szAux);


        //return -1;
        exit(1);
}

/************************************************************************************************************/
// void ConectarTibco(tibemsSSLParams *sslParams,tibemsQueueConnection *queueConnection
//                   ,tibemsQueue &queue,tibemsQueueSender *queueSender,TParamConf *tParamConf
//                   ,char *argVZero)
// {
//     oLog.logDebug("Iniciando conexao JMS...");
//
//     //char *serverUrl = NULL;
//
//     tibems_status status = TIBEMS_OK;
//     tibemsQueueSession queueSession = NULL;
//
//     char *serverUrl = tParamConf->szServerUrl;     // astorga.telespcelular.com.br
//     char *userName = tParamConf->szUserName;       // admin
//     char *password = tParamConf->szPassword;       // 71b60
//     char *pk_password = tParamConf->szPk_password; // teste
//
//     //queueName = tParamConf->szQueueName;     // VIVO.FO.SMS.SEND
//
//     sprintf(szAux, "  queueName=%s", tParamConf->szQueueName); oLog.logDebug(szAux);
//     sprintf(szAux, "  serverUrl=%s", serverUrl); oLog.logDebug(szAux);
//     //sprintf(szAux, "   userName=%s", userName); oLog.logDebug(szAux);
//     //sprintf(szAux, "   password=%s", password); oLog.logDebug(szAux);
//     //sprintf(szAux, "pk_password=%s", pk_password); oLog.logDebug(szAux);
//
//     // Create the connection, use ssl if specified
//     if(sslParams)
//     {
//         status = tibemsQueueConnection_CreateSSL(*queueConnection, serverUrl, NULL, userName, password, *sslParams, pk_password);
//     }
//     else
//     {
//         status = tibemsQueueConnection_Create(*queueConnection, serverUrl, NULL, userName, password);
//     }
//
//     if (status != TIBEMS_OK)
//     {
//         oLog.logDebug("Falha de conexão à fila Tibco...");
//         oLog.logDebug("Desconectando da BD...");
//         DBDisconnect();
//
//         oLog.logDebug("Liberando fila...");
//         Process(argVZero, UNLOCK);
//
//         Fail("Error creating tibemsQueueConnection", status);
//     }
//
//     // create the queue session
//     status = tibemsQueue_Create(queue, tParamConf->szQueueName);
//     if (status != TIBEMS_OK)
//     {
//         oLog.logDebug("Falha de conexão à fila Tibco...");
//         oLog.logDebug("Desconectando da BD...");
//         DBDisconnect();
//
//         oLog.logDebug("Liberando fila...");
//         Process(argVZero, UNLOCK);
//
//         Fail("Error creating tibemsQueueConnection", status);
//     }
//
//     // create the queue session
//     status = tibemsQueueConnection_CreateQueueSession(*queueConnection,&queueSession,TIBEMS_FALSE,TIBEMS_AUTO_ACKNOWLEDGE);
//     if (status != TIBEMS_OK)
//     {
//         oLog.logDebug("Falha de conexão à fila Tibco...");
//         oLog.logDebug("Desconectando da BD...");
//         DBDisconnect();
//
//         oLog.logDebug("Liberando fila...");
//         Process(argVZero, UNLOCK);
//
//         Fail("Error creating tibemsQueueConnection", status);
//     }
//
//     // create the queue sender
//     status = tibemsQueueSession_CreateSender(queueSession, queueSender, queue);
//     if (status != TIBEMS_OK)
//     {
//         oLog.logDebug("Falha de conexão à fila Tibco...");
//         oLog.logDebug("Desconectando da BD...");
//         DBDisconnect();
//
//         oLog.logDebug("Liberando fila...");
//         Process(argVZero, UNLOCK);
//
//         Fail("Error creating tibemsQueueConnection", status);
//     }
//
//     oLog.logDebug("Iniciando conexao JMS OK...");
// }

/************************************************************************************************************/
// void DesconectarTibco(tibemsSSLParams &sslParams,tibemsQueueConnection &queueConnection,tibemsQueue &queue)
// {
//     oLog.logDebug("Fechando conexao JMS...");
//
//     tibems_status status = TIBEMS_OK;
//
//     // destroy the queue
//     status = tibemsQueue_Destroy(queue);
//     if (status != TIBEMS_OK)
//     {
//         sprintf( szAux,"Error creating tibemsQueueConnection=[%d]",status );
//         oLog.logDebug(szAux);
//     }
//     else
//     {
//         // close the connection
//         status = tibemsConnection_Close(queueConnection);
//         if (status != TIBEMS_OK)
//         {
//             sprintf( szAux,"Error creating tibemsQueueConnection=[%d]",status );
//             oLog.logDebug(szAux);
//         }
//         else
//         {
//             // destroy the ssl params
//             tibemsSSLParams_Destroy(sslParams);
//             oLog.logDebug("Fechando conexao JMS OK...");
//         }
//     }
// }

/************************************************************************************************************/
int EnviarMensagemTibco(const char *idAtendimentoProtocolo,const char *cdAreaRegistro
                        ,const char *nrLinha,const char *dsMensagemEnvio
                        ,const char *queueName,char *argVZero
                        ,tibemsQueueSender &queueSender
                        ,const char *pSzMessageLog)
{
    tibemsTextMsg msg;
    char szMsg[2001];

    sprintf(szMsg,
    "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>"
    "<msg>"
        "<msgHdr>"
            "<service>SMSSend</service>"
            "<user>1</user>"
            "<topic>%s</topic>"
            "<timeout>30</timeout>"
        "</msgHdr>"
        "<msgBody>"
            "<sms>"
                "<codigoInterno>%s</codigoInterno>"
                "<origem>2001</origem>"
                "<destino>%s%s</destino>"
                "<mensagem>%s</mensagem>"
            "</sms>"
        "</msgBody>"
    "</msg>",queueName
            ,idAtendimentoProtocolo
            ,cdAreaRegistro,nrLinha
            ,dsMensagemEnvio);

    // se é parar loggar a mensagem de envio ...
    if ( 'S' == *pSzMessageLog )
    {
        sprintf(szAux,"Vai enfileirar MSG=%s,TAMMSG=%d",szMsg,strlen(szMsg));
        oLog.logDebug(szAux);
    }

        // create the text message
        tibems_status status = tibemsTextMsg_Create(&msg);
        if (status != TIBEMS_OK)
    {
        oLog.logDebug("Falha de envio à fila Tibco...");

//        oLog.logDebug("Liberando fila...");
//        Process(argVZero, UNLOCK);
//
//              oLog.logDebug("Desconectando da BD...");
//        DBDisconnect();

        Fail("Error tibemsTextMsg_Create", status);
                return -1;
    }

        // set the message text
        status = tibemsTextMsg_SetText(msg, szMsg);
        if (status != TIBEMS_OK)
    {
        oLog.logDebug("Falha de envio à fila Tibco...");

//        oLog.logDebug("Liberando fila...");
//        Process(argVZero, UNLOCK);
//
//        oLog.logDebug("Desconectando da BD...");
//        DBDisconnect();

        Fail("Error tibemsTextMsg_SetText", status);
                return -2;
    }

        // send the message
        status = tibemsQueueSender_Send(queueSender, msg);
        if (status != TIBEMS_OK)
    {
        oLog.logDebug("Falha de envio à fila Tibco...");
//        oLog.logDebug("Liberando fila...");
//        Process(argVZero, UNLOCK);
//
//        oLog.logDebug("Desconectando da BD...");
//        DBDisconnect();

        Fail("Error tibemsQueueSender_Send", status);
                return -3;
    }

        // destroy the message
        status = tibemsMsg_Destroy(msg);
        if (status != TIBEMS_OK)
    {
        oLog.logDebug("Falha de envio à fila Tibco...");
//        oLog.logDebug("Liberando fila...");
//        Process(argVZero, UNLOCK);
//
//        oLog.logDebug("Desconectando da BD...");
//        DBDisconnect();

        Fail("Error tibemsMsg_Destroy", status);
                return -4;
    }

        return 1;
}



/************************************************************************************************************/
void ArmaSinal(int iSignal)
{
    sprintf(szAux, "Armando tratamento para Signal(%d)", iSignal); oLog.logInformation(szAux);

    if(signal((iSignal), ProcessaSinal) == SIG_ERR)
    {
        fprintf(stderr, "ERRO ARMANDO SINAL!!!");
        exit(-1);
    }
}



/************************************************************************************************************/
void ProcessaSinal(int iSig)
{
    sprintf(szAux, "iSig(%d)", iSig); oLog.logInformation(szAux);

    // rearma o mesmo sinal lançado
    ArmaSinal(iSig);

    if(iSig == SIGTERM)
    {
        oLog.logInformation("Finalizando processamento via sinal....");
        iSignalProcessa=0;
    }
}



/************************************************************************************************************/
int ObtemParamConf(TParamConf *ptParamConf)
{
    MFile mfConfig;
    SplitLine NewLinha;
    char szLinha[101];
    char szDivArq[256];
    char szDivPre[21];

    oLog.logDebug("Obtendo parametros de configuracao...");

    // Zera variáveis
    memset(ptParamConf, 0, sizeof(TParamConf));
    memset(szLinha, 0, sizeof(szLinha));
    memset(szDivArq, 0, sizeof(szDivArq));
    memset(szDivPre, 0, sizeof(szDivPre));

    // Define o arquivo de configuração
    mfConfig.setPath("blackList.cfg");

    // Verificar se conseguiu abrir o arquivo
    if(!mfConfig.abrir())
    {
        oLog.logError("Erro abrindo arquivo de configuração!");
        return -1;
    }

    // Capturando usuario, senha, path e instance de banco do arquivo
    NewLinha.SetDiv('=');
    while(mfConfig.getLine(szLinha) != 0)
    {
        NewLinha.SetLine(szLinha);
        NewLinha.GetBeforeDiv(szDivPre);
        NewLinha.GetAfterDiv(szDivArq);

        // Verifica qual parâmetro foi encontrado.
        if (!strcmp(szDivPre, "pwd_db"))
        {
            strncpy(ptParamConf->szPws, szDivArq, TAM_BD_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_db"))
        {
            strncpy(ptParamConf->szUsr, szDivArq, TAM_BD_USRNAME);
        }
        else if (!strcmp(szDivPre, "inst_db"))
        {
            strncpy(ptParamConf->szInst, szDivArq, TAM_BD_INST);
        }
        else if (!strcmp(szDivPre, "pwd_tux"))
        {
            strncpy(ptParamConf->szPwsTux, szDivArq, TAM_TX_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_tux"))
        {
            strncpy(ptParamConf->szUsrTux, szDivArq, TAM_TX_USRNAME);
        }
        else if (!strcmp(szDivPre, "pwd_tux_gen"))
        {
            strncpy(ptParamConf->szPwsTuxGen, szDivArq, TAM_TX_GEN);
        }
        else if (strcmp(szDivPre, "clt_tux")==0)
        {
            strncpy(ptParamConf->szCltTux, szDivArq, TAM_TX_CLT);
        }
        else if (strcmp(szDivPre, "QueueName")==0)
        {
            strncpy(ptParamConf->szQueueName, szDivArq, TAM_SZ_QUEUE_NAME);
        }
        else if (strcmp(szDivPre, "ServerUrl")==0)
        {
            strncpy(ptParamConf->szServerUrl, szDivArq, TAM_SZ_SERVER_URL);
        }
        else if (strcmp(szDivPre, "UserName")==0)
        {
            strncpy(ptParamConf->szUserName, szDivArq, TAM_SZ_USERNAME);
        }
        else if (strcmp(szDivPre, "Password")==0)
        {
            strncpy(ptParamConf->szPassword, szDivArq, TAM_SZ_PASSWORD);
        }
        else if (strcmp(szDivPre, "Pk_password")==0)
        {
            strncpy(ptParamConf->szPk_password, szDivArq, TAM_SZ_PKPASSWD);
        }

        memset(szLinha,  0, sizeof(szLinha));
        memset(szDivPre, 0, sizeof(szDivPre));
        memset(szDivArq, 0, sizeof(szDivArq));
    }

    // Fechando o arquivo de configuracao aberto
    mfConfig.fechar();

    //sprintf(szAux, "ptParamConf->szPws[%s]", ptParamConf->szPws); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szUsr[%s]", ptParamConf->szUsr); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szInst[%s]", ptParamConf->szInst); oLog.logDebug(szAux);
    //sprintf(szAux, "ptParamConf->szPwsTux[%s]", ptParamConf->szPwsTux); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szUsrTux[%s]", ptParamConf->szUsrTux); oLog.logDebug(szAux);
    //sprintf(szAux, "ptParamConf->szPwsTuxGen[%s]", ptParamConf->szPwsTuxGen); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szCltTux[%s]", ptParamConf->szCltTux); oLog.logDebug(szAux);

    sprintf(szAux, "ptParamConf->szQueueName[%s]", ptParamConf->szQueueName); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szServerUrl[%s]", ptParamConf->szServerUrl); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szUserName[%s]", ptParamConf->szUserName); oLog.logDebug(szAux);
    //sprintf(szAux, "ptParamConf->szPassword[%s]", ptParamConf->szPassword); oLog.logDebug(szAux);
    //sprintf(szAux, "ptParamConf->szPk_password[%s]", ptParamConf->szPk_password); oLog.logDebug(szAux);

    // Verifica se todos os dados foram recuperados do arquivo de configuração.
    if (strlen(ptParamConf->szInst) == 0 ||
        strlen(ptParamConf->szPwsTux) == 0 ||
        strlen(ptParamConf->szUsrTux) == 0 ||
        strlen(ptParamConf->szPwsTuxGen) == 0 ||
        strlen(ptParamConf->szCltTux) == 0 ||
        strlen(ptParamConf->szQueueName) == 0 ||
        strlen(ptParamConf->szServerUrl) == 0 ||
        strlen(ptParamConf->szUserName) == 0  ||
        strlen(ptParamConf->szPassword) == 0)
    {
        oLog.logError("Dados incompletos!");
        return -1;
    }

    oLog.logDebug("Parametros de configuracao obtidos com sucesso...");
    return 0;
}



/************************************************************************************************************/
int DBConnect(char *pUsr, char *pPwd, char *pInst)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[256];
    EXEC SQL END DECLARE SECTION;

    // String de conexao
    sprintf(connString, "%s/%s@%s", pUsr, pPwd, pInst);

    // Marca ponto de erro
    EXEC SQL WHENEVER SQLERROR GOTO errConn;

    // Conecta
    EXEC SQL CONNECT :connString;

    return (sqlca.sqlcode);

errConn:
    oLog.logInformation("<<<DBConnect [ERROR]");
    return -1;
}



/************************************************************************************************************/
void DBDisconnect(void)
{
    EXEC SQL WHENEVER SQLERROR GOTO Error;
    EXEC SQL COMMIT WORK RELEASE;
    return;

Error:
    sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    return;
}



/************************************************************************************************************/
void Fail(const char* message, tibems_status s)
{
    const char* msg = tibemsStatus_GetText(s);
    printf("ERROR: %s\n",message);
    printf("\tSTATUS: %d %s\n",s,msg?msg:"(Undefined Error)");
    //exit(1);
}



/************************************************************************************************************/
int ObterParamMaxRegistros(int LimMax)
{
    EXEC SQL BEGIN DECLARE SECTION;
        int MaxRegs=0;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    EXEC SQL
        SELECT
            TO_NUMBER(NVL(DSVALORPARAMETRO,2000))
        INTO
            :MaxRegs
        FROM
            APOIO.PARAMETRO
        WHERE
            CDPARAMETRO = 'SMS_PROTO_NRO_MAXREGS';

    /*
    if ( MaxRegs > LimMax )
    {
        sprintf(szAux,"Valor solicitado de %d é maior que o limite máximo. Assumindo limite máximo.",MaxRegs);
        oLog.logDebug(szAux);
        MaxRegs = LimMax;
    }
    */

    if ( MaxRegs < 0 )
    {
        oLog.logDebug("Parametro 'SMS_PROTO_NRO_MAXREGS' com valor inválido, assumindo default.");
        MaxRegs = 2000;
    }

    return MaxRegs;

erro:
    sprintf(szAux,"maxRegsPrm default=%d,errcode=%d",2000,sqlca.sqlcode); oLog.logDebug(szAux);
    return 2000;

naoexiste:
    sprintf(szAux,"Parametro 'SMS_PROTO_NRO_MAXREGS' nao encontrado. Assumindo %d",2000); oLog.logDebug(szAux);
    return 2000;
}



/************************************************************************************************************/
void ObterParamMsgParse(TParamConf *tParamConf)
{
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR varOraDsValorParametro[256];
        short statOraDsValorParametro = -1;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erroParse;
    EXEC SQL WHENEVER NOT FOUND goto naoexisteParse;

    EXEC SQL
        SELECT
            NVL(DSVALORPARAMETRO,'S')
        INTO
            :varOraDsValorParametro:statOraDsValorParametro
        FROM
            APOIO.PARAMETRO
        WHERE
            CDPARAMETRO = 'SMS_PROTO_MSGPARSE';

    CONVIND(varOraDsValorParametro,statOraDsValorParametro);
    SAFE_STRNCPY(tParamConf->szMessageParse,(char*)varOraDsValorParametro.arr);

    return;

erroParse:
    sprintf(szAux,"Erro %d na busca do parametro 'SMS_PROTO_MSGPARSE'. Assumindo 'S'.",sqlca.sqlcode);
    oLog.logDebug(szAux);
    SAFE_STRNCPY(tParamConf->szMessageParse,"S");

naoexisteParse:
    sprintf(szAux,"Parametro 'SMS_PROTO_MSGPARSE' nao encontrado. Assumindo 'S'.");
    oLog.logDebug(szAux);
    SAFE_STRNCPY(tParamConf->szMessageParse,"S");
}



/************************************************************************************************************/
void ObterParamMsgLog(TParamConf *tParamConf)
{
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR varOraDsValorParametro[256];
        short statOraDsValorParametro = -1;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erroLog;
    EXEC SQL WHENEVER NOT FOUND goto naoexisteLog;

    EXEC SQL
        SELECT
            NVL(DSVALORPARAMETRO,'N')
        INTO
            :varOraDsValorParametro:statOraDsValorParametro
        FROM
            APOIO.PARAMETRO
        WHERE
            CDPARAMETRO = 'SMS_PROTO_MSGLOG';

    CONVIND(varOraDsValorParametro,statOraDsValorParametro);
    SAFE_STRNCPY(tParamConf->szMessageLog,(char*)varOraDsValorParametro.arr);

    return;

erroLog:
    sprintf(szAux,"Erro %d na busca do parametro 'SMS_PROTO_MSGLOG'. Assumindo 'N'.",sqlca.sqlcode);
    oLog.logDebug(szAux);
    SAFE_STRNCPY(tParamConf->szMessageLog,"N");

naoexisteLog:
    sprintf(szAux,"Parametro 'SMS_PROTO_MSGLOG' nao encontrado. Assumindo 'N'.");
    oLog.logDebug(szAux);
    SAFE_STRNCPY(tParamConf->szMessageLog,"N");
}

/********************************************************************************************/
/*
int Process(char *pszFileName, int iFlagLock)
{
    static int semid;
    time_t tStart, tEnd;
    double tDiff;
    key_t key;

    if(iFlagLock == UNLOCK)
    {
        UnLockSemaphore(semid);
    }
    else if(iFlagLock == LOCK)
    {

        if((key = ftok(pszFileName, 'a')) == (key_t) -1)
        {
            perror("IPC error: ftok");
            exit(-1);
        }

        if((semid = InitSemaphore(key, 1)) == -1)
        {
            perror("InitSemaphore");
            exit(-1);
        }

        time(&tStart);
        LockSemaphore(semid);
        time(&tEnd);

        tDiff = difftime(tEnd, tStart);

        // tempo limite para espera de processamento
        if(tDiff > (double)0)
            return -1;
    }
    else if(iFlagLock == KILL)
    {
        semctl(semid, 0, IPC_RMID); // deleta o semaforo
    }
    else
    {
        exit(-1);
    }

    return 0;
}*/

// nova versão da função process. Foi retirada a funcionalidade de semáforo e utilizado uma lógica
// baseada em atualizações no DB.
int Process(char *psKeyDB, int iFlagLock)
{
    sprintf(szAux," Process() Iniciada com psKeyDB[%s] e iFlagLock[%d]." , psKeyDB , iFlagLock);
    oLog.logDebug(szAux);

    EXEC SQL BEGIN DECLARE SECTION;
        char cDBKey[1024];
        VARCHAR varOraDsValorParametro[1024];
        short statOraDsValorParametro = -1;
                int iBlackListIndCount;
                char cBlackListIndCount[1024];

    EXEC SQL END DECLARE SECTION;

    // String de conexao
    sprintf(cDBKey, "%sIndCount", psKeyDB);
        sprintf(szAux,"Chave[%s] de busca em APOIO.PARAMETRO" , cDBKey); oLog.logDebug(szAux);

    EXEC SQL WHENEVER SQLERROR goto erroLog;
    EXEC SQL WHENEVER NOT FOUND continue;

        switch(iFlagLock )
        {
                case UNLOCK:
                //case KILL:
                {
                        sprintf(szAux," UNLOCK processando..." );oLog.logDebug(szAux);
                        // UPDATE AO DB = 0
                        EXEC SQL UPDATE APOIO.PARAMETRO SET DSVALORPARAMETRO = '0' WHERE CDPARAMETRO = :cDBKey;
                        EXEC SQL COMMIT;
                        break;
                }
                case LOCK:
                {
                        sprintf(szAux," LOCK processando..." );oLog.logDebug(szAux);
                  // CONSULTA BLACKLISTINDCOUNT.
                        EXEC SQL
                        SELECT
                                NVL(DSVALORPARAMETRO,'0')
                        INTO
                                :varOraDsValorParametro:statOraDsValorParametro
                        FROM
                                APOIO.PARAMETRO
                        WHERE
                                CDPARAMETRO = :cDBKey;

                        CONVIND(varOraDsValorParametro,statOraDsValorParametro);
                        iBlackListIndCount =  atoi((char*)varOraDsValorParametro.arr);
                        sprintf(szAux,"Indicador[%d]", iBlackListIndCount );oLog.logDebug(szAux);

                   if( statOraDsValorParametro == -1)
                   {
                                sprintf(szAux,"Indicador nao encontrado." );oLog.logDebug(szAux);
                                 //INSERT BLACKLISTINDCOUNT
                                EXEC SQL INSERT INTO APOIO.PARAMETRO (IDPARAMETRO, CDPARAMETRO, DSPARAMETRO, DSVALORPARAMETRO, IDUSUARIOALTERACAO, DTULTIMAALTERACAO) VALUES (PARAMETROSQ.NEXTVAL, :cDBKey, :cDBKey, '1',1, SYSDATE);
                                EXEC SQL COMMIT;
                                //ENTRA NORMAL
                   }
                   else
                   {
                         if ( ( iBlackListIndCount == 0 ) ||  ( iBlackListIndCount >= 10 ) )
                                {
                                        sprintf(szAux,"Indicador sera alterado para 1." );oLog.logDebug(szAux);
                                        iBlackListIndCount = 1;
                                        memset(cBlackListIndCount,0,sizeof(cBlackListIndCount));
                                        sprintf(cBlackListIndCount,"%d",iBlackListIndCount);
                                        EXEC SQL 
                                        UPDATE 
                                           APOIO.PARAMETRO 
                                        SET 
                                           DSVALORPARAMETRO = :cBlackListIndCount , 
                                           DTULTIMAALTERACAO = SYSDATE 
                                        WHERE 
                                           CDPARAMETRO = :cDBKey;
                                        EXEC SQL COMMIT;
                                    //ENTRA NORMAL
                                }
                        else
                                {
                                        sprintf(szAux,"Indicador[%d] sera incrementado para [%d].", iBlackListIndCount, iBlackListIndCount + 1 );oLog.logDebug(szAux);                               
                                        iBlackListIndCount++;
                                        memset(cBlackListIndCount,0,sizeof(cBlackListIndCount));
                                        sprintf(cBlackListIndCount,"%d",iBlackListIndCount);
                                        EXEC SQL 
                                        UPDATE 
                                           APOIO.PARAMETRO 
                                        SET 
                                           DSVALORPARAMETRO = :cBlackListIndCount , 
                                           DTULTIMAALTERACAO = SYSDATE 
                                        WHERE 
                                           CDPARAMETRO = :cDBKey;
                                        EXEC SQL COMMIT;
                                        //SAI FORA
                                        sprintf(szAux,"Acesso negado." );oLog.logDebug(szAux);
                                        return -1;
                                }
                   }
                   break;
                }
                default:
                {
                        sprintf(szAux," iFlagLock desconhecido." );oLog.logDebug(szAux);
                        exit(-1);
                        break;
                }

        }
        sprintf(szAux,"Acesso concedido." );oLog.logDebug(szAux);
    return 0;

erroLog:
    sprintf(szAux,"Erro %d no processo de semaforo via DB.",sqlca.sqlcode);
    oLog.logDebug(szAux);
        return -1;

naoexisteLog:
    sprintf(szAux,"Erro no processo de semaforo via DB...");
    oLog.logDebug(szAux);
        return -1;

}

/********************************************************************************************/
void UnLockSemaphore(int semid)
{
    struct sembuf sb;

    sb.sem_num = 0;
    sb.sem_op = 1; // free resource
    sb.sem_flg = SEM_UNDO;

    if (semop(semid, &sb, 1) == -1)
    {
        perror("semop");
        exit(1);
    }
}

/********************************************************************************************/
void LockSemaphore(int semid)
{
    struct sembuf sb;

    sb.sem_num = 0;
    sb.sem_op = -1;  // set to allocate resource
    sb.sem_flg = SEM_UNDO;

    if (semop(semid, &sb, 1) == -1)
    {
        perror("semop");
        exit(1);
    }
}

/********************************************************************************************/
/*
** InitSemaphore() -- more-than-inspired by W. Richard Stevens' UNIX Network
** Programming 2nd edition, volume 2, lockvsem.c, page 295.
*/
int InitSemaphore(key_t key, int nsems)
{
    union semun
    {
        int val;
        struct semid_ds *buf;
        ushort *array;
    } arg;

    struct semid_ds buf;
    struct sembuf sb;
    int semid;

    semid = semget(key, nsems, IPC_CREAT | IPC_EXCL | 0666);
    if (semid >= 0)
    { // we got it first
        sb.sem_op = 1;
        sb.sem_flg = 0;
        arg.val = 1;

        for(sb.sem_num = 0; sb.sem_num < nsems; sb.sem_num++)
        {
            // do a semop() to "free" the semaphores.
            // this sets the sem_otime field, as needed below.
            if (semop(semid, &sb, 1) == -1)
            {
                int e = errno;
                semctl(semid, 0, IPC_RMID); // clean up
                errno = e;
                return -1; // error, check errno
            }
        }
    }
    else if (errno == EEXIST)
    {
        int ready = 0;

        semid = semget(key, nsems, 0); // get the id
        if (semid < 0)
            return semid; // error, check errno

        // wait for other process to initialize the semaphore:
        arg.buf = &buf;

        for(int i = 0; i < MAX_RETRIES && !ready; i++)
        {
            semctl(semid, nsems-1, IPC_STAT, arg);

            if (arg.buf->sem_otime != 0)
            {
                ready = 1;
            }
            else
            {
                sleep(1);
            }
        }
        if(!ready)
        {
            errno = ETIME;
            return -1;
        }
    }
    else
    {
        return semid; // error, check errno
    }

    return semid;
}
