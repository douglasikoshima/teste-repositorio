#include <sys/time.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <iostream.h>
#include <ctype.h>

#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

#ifndef WIN32
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include  <sys/types.h>
#include  <netinet/in.h>
#include <arpa/inet.h>
#endif // AIX

#ifndef WIN32
#include <unistd.h>
#endif

#include "../../commons/Propriedade/include/MFile.h"
#include "../../commons/Log/include/Log.h"
#include "../../commons/SplitLine.h"
#include "../include/sittelMonitor.h"

#include <string>
using namespace std;

EXEC SQL INCLUDE SQLCA;

int getNrMaxInstances( void );
int ConsolidaInformacoes ( char * sCodReq_Prm );
void ErroOracle ( struct sqlca * sqlca );

//==============================================================================
// Globals
char szAux[1024 + 1];   // Usado nas linhas de LOG
Log oLog;
//==============================================================================
// Run
int main( int argc, char *argv[] )
{
    time_t      rawtime;
    struct tm * timeinfo;
    char sData[32] = {0};
    char sInstancia[64] = {0};
    char sProcessoSaida[256] = {0};
    char sCodReq[128] = {0};
    double startTime, endTime;
    char UsedTime[16] = {0};
    startTime = getRealTime();   // Inicia cronometro de Operacao

    TParamConf tParamConf;
    
    oLog.setNivel(2);
    oLog.logDebug(">>> sittelMonitor");

    if ( argc < 2 )
    {
        oLog.logDebug("*** FALTA ARGUMENTOS DE EXECUCAO ***");
        sprintf( szAux, "Uso %s [CODREQ]\n", argv[0] ); oLog.logDebug(szAux);
        endTime = getRealTime();   // Finaliza Cronometro de Operacao
        ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS.FFFF em UsedTime - Tempo Gasto 
        sprintf( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);
        oLog.logDebug("<<< sittelMonitor");
        exit(1);
    }
    
    strcpy( sCodReq, argv[1] );
    sprintf( szAux, "### Processando Requisicao [%s] ###", sCodReq ); oLog.logDebug(szAux);

    //==========================================================================
    // Parâmetros de configuração
    if (ObtemParamConf(&tParamConf))
    {
        oLog.logError ("*** ERRO AO OBTER PARAMETROS DE CONFIGURACAO ***");
        endTime = getRealTime();   // Finaliza Cronometro de Operacao
        ElapsedTime (startTime, endTime, UsedTime);   // Retorna HH:MM:SS.FFFF em UsedTime - Tempo Gasto 
        sprintf ( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);
        oLog.logDebug ( "<<< sittelMonitor" );
        exit (1);
    }

    //==========================================================================
    // Conecta ao banco
    oLog.logDebug("### Conectando com Banco de Dados. ###");
    if (DBConnect(tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst))
    {
        oLog.logError ("*** ERRO DE CONEXAO AO BANCO DE DADOS ***");
        endTime = getRealTime();   // Finaliza Cronometro de Operacao
        ElapsedTime (startTime, endTime, UsedTime);   // Retorna HH:MM:SS&&& Vai Executar [.FFFF em UsedTime - Tempo Gasto 
        sprintf ( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);
        oLog.logDebug ( "<<< sittelMonitor" );
        exit(1);
    }
    
    ConsolidaInformacoes( sCodReq );  // Abre Consultas filhos para consolidado
    
    DBDisconnect();
    
    time ( &rawtime );
    timeinfo = localtime ( &rawtime );
    strftime( sData, 17, "%Y%m%d-%H%M%S", timeinfo );
    sprintf( sInstancia, "sittelSaida_%s", sData );
    sprintf( sProcessoSaida, "nohup ./sittelSaida %s 2>&1 >> ../log/%s.log &", sCodReq, sInstancia );
    if ( system (sProcessoSaida) < 0 )
    {
        sprintf ( szAux, "*** system: [%s]", strerror(errno) );oLog.logDebug(szAux);
    }
    
    endTime = getRealTime();   // Finaliza Cronometro de Operacao
    ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS.FFFF em UsedTime - Tempo Gasto 
    sprintf( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);

    oLog.logDebug( "<<< sittelMonitor" );
    exit (0);
    
}



/************************************************************************************************************/
int ObtemParamConf(TParamConf *ptParamConf)
{
    MFile mfConfig;
    SplitLine NewLinha;
    char szLinha[101];
    char szDivArq[256];
    char szDivPre[21];

    oLog.logDebug(">>> Obtendo parametros de configuracao...");

    // Zera variáveis
    memset(ptParamConf, 0, sizeof(TParamConf));
    memset(szLinha, 0, sizeof(szLinha));
    memset(szDivArq, 0, sizeof(szDivArq));
    memset(szDivPre, 0, sizeof(szDivPre));

    // Define o arquivo de configuração
    mfConfig.setPath("sittel.cfg");

    // Verificar se conseguiu abrir o arquivo
    if(!mfConfig.abrir())
    {
        oLog.logError("!!! ERRO AO ABRIR ARQUIVO DE CONFIGURACAO !!!");
        return -1;
    }

    // Capturando usuario, senha, path e instance de banco do arquivo
    NewLinha.SetDiv('=');
    while(mfConfig.getLine(szLinha) != 0)
    {
        NewLinha.SetLine(szLinha);
        NewLinha.GetBeforeDiv(szDivPre);
        NewLinha.GetAfterDiv(szDivArq);

        // Verifica qual parâmetro foi encontrado.
        if (!strcmp(szDivPre, "pwd_db"))
        {
            strncpy(ptParamConf->szPws, szDivArq, TAM_BD_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_db"))
        {
            strncpy(ptParamConf->szUsr, szDivArq, TAM_BD_USRNAME);
        }
        else if (!strcmp(szDivPre, "inst_db"))
        {
            strncpy(ptParamConf->szInst, szDivArq, TAM_BD_INST);
        }

        memset(szLinha,  0, sizeof(szLinha));
        memset(szDivPre, 0, sizeof(szDivPre));
        memset(szDivArq, 0, sizeof(szDivArq));
    }

    // Fechando o arquivo de configuracao aberto
    mfConfig.fechar();

    sprintf(szAux, "ptParamConf->szUsr[%s]", ptParamConf->szUsr); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szInst[%s]", ptParamConf->szInst); oLog.logDebug(szAux);

    // Verifica se todos os dados foram recuperados do arquivo de configuração.
    if (strlen(ptParamConf->szInst) == 0)
    {
        oLog.logError("!!! CONFIGURACAO INCOMPLETA !!!");
        return -1;
    }

    oLog.logDebug("### Sucesso na Configuracao ###");
    return 0;
}



/************************************************************************************************************/
int DBConnect(char *pUsr, char *pPwd, char *pInst)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[64];
    EXEC SQL END DECLARE SECTION;

    // String de conexao
    sprintf(connString, "%s/%s@%s", pUsr, pPwd, pInst);

    // Marca ponto de erro
    EXEC SQL WHENEVER SQLERROR GOTO errConn;

    // Conecta
    EXEC SQL CONNECT :connString;

    return 0;

errConn:
    sprintf(szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    return -1;
}



/************************************************************************************************************/
int DBDisconnect(void)
{
    EXEC SQL WHENEVER SQLERROR GOTO Error;
    EXEC SQL COMMIT WORK RELEASE;
    return 0;

Error:
    oLog.logDebug("*** ERRO AO DESCONECTAR DO BANCO ***");
    sprintf(szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    return -1;
}



int getNrMaxInstances ( void )
{
    EXEC SQL BEGIN DECLARE SECTION;
        int MaxInstances = 0;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR DO ErroOracle( &sqlca );
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        SELECT
            TO_NUMBER(NVL(DSVALORPARAMETRO,20))
        INTO
            :MaxInstances
        FROM
            APOIO.PARAMETRO
        WHERE
            CDPARAMETRO = 'MAX_SITTEL_INSTANCES';

    if ( MaxInstances <= 0 )
    {
        oLog.logDebug("### Parametro 'MAX_SITTEL_INSTANCES' com valor invalido, assumindo valor default [20]. ###");
        MaxInstances = 20;
    }

    return MaxInstances;

}



/**
 * Returns the real time, in seconds, or -1.0 if an error occurred.
 *
 * Time is measured since an arbitrary and OS-dependent start time.
 * The returned real time is only useful for computing an elapsed time
 * between two calls to this function.
 */
double getRealTime(void)
{
    /* AIX, BSD, Cygwin, HP-UX, Linux, OSX, POSIX, Solaris. ----- */
    struct timeval tm;
    gettimeofday( &tm, NULL );
    return (double)tm.tv_sec + (double)tm.tv_usec / 1000000.0;
}



/*
 *   Retorna Tempo Usado
 *   StartTime - Tempo Inicial
 *   EndTime - Tempo Final
 *   UsedTime - Tempo Gasto
 */
void ElapsedTime(double StartTime, double EndTime, char * UsedTime)
{
    int hora, minuto, segundo;

    char Tempo[16];
    char Segundos[8];
    char Miliseg[8];
    char * Result = NULL;

    sprintf ( Tempo, "%lf.", (EndTime - StartTime) );
    Result = strtok(Tempo,".");
    sprintf(Segundos,"%s", Result);
    //printf("Segundos [%s]\n",Segundos);
    Result = strtok(NULL,".");
    sprintf(Miliseg, "%.4s", Result);
    //printf("Miliseg [%s]\n",Miliseg);

    hora = (atoi(Segundos)/3600);
    minuto = (atoi(Segundos)-(3600*hora))/60;
    segundo = (atoi(Segundos)-(3600*hora)-(minuto*60));
    sprintf( UsedTime, "%02d:%02d:%02d.%s", hora, minuto, segundo, Miliseg );

}



int ConsolidaInformacoes( char* sCodReq_Prm )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char* sCodReq = sCodReq_Prm;
        VARCHAR sFragmento[32];
        short i_sFragmento;
        VARCHAR sPid[64];
        short i_sPid;
        int Instanciados = 0;
    EXEC SQL END DECLARE SECTION;
    
    oLog.logDebug( ">>> ConsolidaInformacoes()" );

    time_t      rawtime;
    struct tm * timeinfo;
    
    bool Informe = false;
    int iPid;
    int nrMaxInstances;
    char sFrag[32] = {0};
    char pid[32] = {0};
    char sData[32] = {0};
    char sInstancia[256] = {0};
    char sProcessoFilho[256] = {0};
    int retorno;
    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR DO ErroOracle( &sqlca );

    EXEC SQL DECLARE cRequisicao CURSOR FOR
    SELECT DISTINCT 
       NRFRAGMENTO 
    FROM 
       CUSTOMER.REQSITTEL 
    WHERE CODREQ = :sCodReq;

    EXEC SQL OPEN cRequisicao;
    for( ;; )   // LOOP PARA PROCESSAR FRAGMENTOS
    {
        nrMaxInstances = getNrMaxInstances();
        sprintf ( szAux, "*** Nro. Maximo de Instancias permitido: [%d]", nrMaxInstances );oLog.logDebug(szAux);

        memset( &sFragmento, 0x0, sizeof(sFragmento) );
        EXEC SQL FETCH cRequisicao
        INTO :sFragmento:i_sFragmento;
        
        if ( sFragmento.arr[0] == 0x0 )
            break;
        CONVIND( sFragmento, i_sFragmento );
        strcpy ( sFrag, (char*)sFragmento. arr );

        for ( ;; )   // LOOP DE CONTROLE DE INSTANCIAS FILHOS
        {
            EXEC SQL
            SELECT count(IDPROCESSO)
             INTO :Instanciados
              FROM customer.sittelprc
             WHERE codreq = :sCodReq AND inestado = 'P';

            if ( Instanciados >= nrMaxInstances )
            {
                sprintf ( szAux, "*** Nro. Maximo de Threads foi atingido: [%d] ***", Instanciados ); oLog.logDebug(szAux);
                oLog.logDebug( "*** Aguardando liberacao de recurso ***" );
                sleep(2);   // Aguarda termino de 1 instancia
                continue;
            }

            time ( &rawtime );
            timeinfo = localtime ( &rawtime );
            strftime( sData, 17, "%Y%m%d-%H%M%S", timeinfo );
            sprintf( sInstancia, "sittelChld_%02d_%s", Instanciados+1, sData );
            sprintf( sProcessoFilho, "nohup ./sittelChld %s %s 2>&1 >> ../log/%s.log &", sCodReq_Prm, sFrag, sInstancia );
sprintf ( szAux, "===> Instanciando [%s] <===", sProcessoFilho ); oLog.logDebug(szAux);
            retorno = system ( sProcessoFilho );
            if ( retorno < 0 )
            {
                sprintf ( szAux, "*** system: [%s]", strerror(errno) );oLog.logDebug(szAux);
            }
            sleep(1);
            break;
        }

    }
    EXEC SQL CLOSE cRequisicao;

    for ( ;; )   // AGUARDA ATE QUE TODAS AS CONSULTAS SEJAM CONCLUIDAS
    {
        EXEC SQL
        SELECT 
           count (1)
        INTO 
           :Instanciados
        FROM 
           customer.sittelprc
        WHERE 
           codreq = :sCodReq AND inestado = 'P';

        if ( Instanciados > 0 )
        {
            sleep (5);
            if ( Informe == false )
            {
                oLog.logDebug ("### Aguardando Consolidacao das Informacoes ###");
                Informe = true;
            }
            continue;
        }
        else
            break;   // Todos os processos filhos finalizaram
    }
    oLog.logDebug ("+++ Consolidacao Finalizada +++");
    
    oLog.logDebug ( "<<< ConsolidaInformacoes()" );
    return 0;

}



void ErroOracle ( struct sqlca * sqlca )
{
    sprintf( szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca->sqlcode, sqlca->sqlerrm.sqlerrmc ); oLog.logDebug(szAux);
    exit( 1 );
}
