#include <sys/time.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <iostream.h>
#include <ctype.h>
#include <string>
#include <iostream>

#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <netdb.h>

#ifndef WIN32
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include  <sys/types.h>
#include  <netinet/in.h>
#include <arpa/inet.h>
#endif // AIX

#ifndef WIN32
#include <unistd.h>
#endif

#include "../../commons/Propriedade/include/MFile.h"
#include "../../commons/Log/include/Log.h"
#include "../../commons/SplitLine.h"
#include "../include/sittelMonitor.h"

#include <string>
using namespace std;

EXEC SQL INCLUDE SQLCA;

//---  Prototypes ---
int ArquivoAssinante ( char * sIdFila, std::string& MsgTry );
int ArquivoAssinanteTerminal ( char * sIdFila_Prm, std::string& MsgTry );
int ArquivoInstalacao ( char * sIdFila_Prm, std::string& MsgTry );
void ErroOracle ( struct sqlca * sqlca );
bool getHostName ( string& hostname );
bool getIpAddress ( string& ipaddr );
int ObtemTpSolicitacao ( char * idFilaProcessum_Prm );
int GetURI ( char* sURI );
string GetStdoutFromCommand(char* cmd);
int ValidaUF( char* sUF_Prm );
int ValidaCEP( char* sCep_Prm );
char * alltrim( char * pszString );
char * ltrim( char * pszString );
char * rtrim( char * pszString );
bool ValidaNumerico( char * bf );
void RetiraHifen( char * pszString );
void TrataMsgPrc( std::string& msg, std::string& MsgNroExec );
int ValidaExecucao( char * idFilaProcessum_Prm, std::string& MsgTry );

//==============================================================================
// Globals
char szAux[1024 + 1];   // Usado nas linhas de LOG
Log oLog;
//==============================================================================
// Run
int main( int argc, char *argv[] )
{
    char sIdFilaProcessum[128] = {0};
    double startTime, endTime;
    char UsedTime[16] = {0};
    int TpArquivo;
    std::string MsgTry;
    
    startTime = getRealTime();   // Inicia cronometro de Operacao

    TParamConf tParamConf;
    
    oLog.setNivel(2);
    oLog.logDebug(">>> sittelSaida");

    if ( argc < 2 )
    {
        oLog.logDebug("*** FALTA ARGUMENTOS DE EXECUCAO ***");
        sprintf( szAux, "Uso %s [idFilaProcessum]\n", argv[0] ); oLog.logDebug(szAux);
        endTime = getRealTime();   // Finaliza Cronometro de Operacao
        ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS.FFFF em UsedTime - Tempo Gasto 
        sprintf( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);
        oLog.logDebug( "<<< sittelSaida" );
        exit ( 1 );
    }
    strcpy( sIdFilaProcessum, argv[1] );
    sprintf( szAux, "*** Processando idFilaProcessum [%s]", sIdFilaProcessum ); oLog.logDebug(szAux);

    //==========================================================================
    // Parâmetros de configuração
    if ( ObtemParamConf(&tParamConf) )
    {
        oLog.logError("*** ERRO AO OBTER PARAMETROS DE CONFIGURACAO ***");
        endTime = getRealTime();   // Finaliza Cronometro de Operacao
        ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS.FFFF em UsedTime - Tempo Gasto 
        sprintf( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);
        oLog.logDebug( "<<< sittelSaida" );
        exit(1);
    }

    //==========================================================================
    // Conecta ao banco
    oLog.logDebug("### Conectando com Banco de Dados. ###");
    if ( DBConnect(tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst) )
    {
        oLog.logError("*** ERRO DE CONEXAO AO BANCO DE DADOS ***");
        endTime = getRealTime();   // Finaliza Cronometro de Operacao
        ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS&&& Vai Executar [.FFFF em UsedTime - Tempo Gasto 
        sprintf( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);
        oLog.logDebug( "<<< sittelSaida" );
        exit(1);
    }
    
    if ( ValidaExecucao( sIdFilaProcessum, MsgTry ) != 0 )
    {
        sprintf( szAux, "*** Nro. de Tentativas Excedido para idFilaProcessum: %s", sIdFilaProcessum ); oLog.logDebug(szAux);
        endTime = getRealTime();   // Finaliza Cronometro de Operacao
        ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS&&& Vai Executar [.FFFF em UsedTime - Tempo Gasto 
        sprintf( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);
        oLog.logDebug( "<<< sittelSaida" );
        exit(1);
    }
    
    TpArquivo = ObtemTpSolicitacao( sIdFilaProcessum );
    switch (TpArquivo)
    {
        case 1: ArquivoAssinante( sIdFilaProcessum, MsgTry );
                break;

        case 2: ArquivoAssinanteTerminal( sIdFilaProcessum, MsgTry );
                break;

        case 3: ArquivoInstalacao( sIdFilaProcessum, MsgTry );
                break;
    }
    
    DBDisconnect();
    
    endTime = getRealTime();   // Finaliza Cronometro de Operacao
    ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS.FFFF em UsedTime - Tempo Gasto 
    sprintf( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);

    oLog.logDebug( "<<< sittelSaida" );
    exit ( 0 );
    
}



/************************************************************************************************************/
int ObtemParamConf( TParamConf * ptParamConf )
{
    MFile mfConfig;
    SplitLine NewLinha;
    char szLinha[101];
    char szDivArq[256];
    char szDivPre[21];

    oLog.logDebug(">>> Obtendo parametros de configuracao...");

    // Zera variáveis
    memset(ptParamConf, 0, sizeof(TParamConf));
    memset(szLinha, 0, sizeof(szLinha));
    memset(szDivArq, 0, sizeof(szDivArq));
    memset(szDivPre, 0, sizeof(szDivPre));

    // Define o arquivo de configuração
    mfConfig.setPath("sittel.cfg");

    // Verificar se conseguiu abrir o arquivo
    if(!mfConfig.abrir())
    {
        oLog.logError("!!! ERRO AO ABRIR ARQUIVO DE CONFIGURACAO !!!");
        return -1;
    }

    // Capturando usuario, senha, path e instance de banco do arquivo
    NewLinha.SetDiv('=');
    while(mfConfig.getLine(szLinha) != 0)
    {
        NewLinha.SetLine(szLinha);
        NewLinha.GetBeforeDiv(szDivPre);
        NewLinha.GetAfterDiv(szDivArq);

        // Verifica qual parâmetro foi encontrado.
        if (!strcmp(szDivPre, "pwd_db"))
        {
            strncpy(ptParamConf->szPws, szDivArq, TAM_BD_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_db"))
        {
            strncpy(ptParamConf->szUsr, szDivArq, TAM_BD_USRNAME);
        }
        else if (!strcmp(szDivPre, "inst_db"))
        {
            strncpy(ptParamConf->szInst, szDivArq, TAM_BD_INST);
        }

        memset(szLinha,  0, sizeof(szLinha));
        memset(szDivPre, 0, sizeof(szDivPre));
        memset(szDivArq, 0, sizeof(szDivArq));
    }

    // Fechando o arquivo de configuracao aberto
    mfConfig.fechar();

    sprintf(szAux, "ptParamConf->szUsr[%s]", ptParamConf->szUsr); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szInst[%s]", ptParamConf->szInst); oLog.logDebug(szAux);

    // Verifica se todos os dados foram recuperados do arquivo de configuração.
    if (strlen(ptParamConf->szInst) == 0)
    {
        oLog.logError("!!! CONFIGURACAO INCOMPLETA !!!");
        return -1;
    }

    oLog.logDebug("### Sucesso na Configuracao ###");
    return 0;
}



/************************************************************************************************************/
int DBConnect(char *pUsr, char *pPwd, char *pInst)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[64];
    EXEC SQL END DECLARE SECTION;

    // String de conexao
    sprintf(connString, "%s/%s@%s", pUsr, pPwd, pInst);

    // Marca ponto de erro
    EXEC SQL WHENEVER SQLERROR DO ErroOracle( &sqlca );

    // Conecta
    EXEC SQL CONNECT :connString;

    return 0;
}



/************************************************************************************************************/
int DBDisconnect(void)
{
    EXEC SQL WHENEVER SQLERROR DO ErroOracle( &sqlca );
    EXEC SQL COMMIT WORK RELEASE;
    return 0;
}



/**
 * Returns the real time, in seconds, or -1.0 if an error occurred.
 *
 * Time is measured since an arbitrary and OS-dependent start time.
 * The returned real time is only useful for computing an elapsed time
 * between two calls to this function.
 */
double getRealTime(void)
{
    /* AIX, BSD, Cygwin, HP-UX, Linux, OSX, POSIX, Solaris. ----- */
    struct timeval tm;
    gettimeofday( &tm, NULL );
    return (double)tm.tv_sec + (double)tm.tv_usec / 1000000.0;
}



/*
 *   Retorna Tempo Usado
 *   StartTime - Tempo Inicial
 *   EndTime - Tempo Final
 *   UsedTime - Tempo Gasto
 */
void ElapsedTime(double StartTime, double EndTime, char * UsedTime)
{
    int hora, minuto, segundo;

    char Tempo[16];
    char Segundos[8];
    char Miliseg[5];
    char * Result = NULL;

    sprintf ( Tempo, "%lf.", (EndTime - StartTime) );
    Result = strtok(Tempo,".");
    sprintf(Segundos,"%s", Result);
    //printf("Segundos [%s]\n",Segundos);
    Result = strtok(NULL,".");
    sprintf(Miliseg, "%.4s", Result);
    //printf("Miliseg [%s]\n",Miliseg);

    hora = (atoi(Segundos)/3600);
    minuto = (atoi(Segundos)-(3600*hora))/60;
    segundo = (atoi(Segundos)-(3600*hora)-(minuto*60));
    sprintf( UsedTime, "%02d:%02d:%02d.%s", hora, minuto, segundo, Miliseg );

}



int ArquivoAssinante( char * sIdFila_Prm, std::string& MsgTry )
{
    oLog.logDebug( ">>> ArquivoAssinante()" );

    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;
       VARCHAR nrSolicitacao[32];
       short i_nrSolicitacao = -1;
       VARCHAR vDetalhe[4000];
       short i_vDetalhe;
       VARCHAR CodigoOrdem[64];
       short i_CodigoOrdem = -1;
       VARCHAR CodigoRequisicao[64];
       short i_CodigoRequisicao = -1;
       char * sIdFila = sIdFila_Prm;
       char cdErro[256];
       char dsErro[256];

       VARCHAR nrcpfcnpj[20];
       VARCHAR nrdocumento[256];
       VARCHAR nmassinante[256];
       VARCHAR tpassinante[3];
       short i_nrcpfcnpj = -1;
       short i_nrdocumento = -1;
       short i_nmassinante = -1;
       short i_tpassinante = -1;
    EXEC SQL END DECLARE SECTION;
    
    time_t      rawtime;
    struct tm * timeinfo;
    char bf[1024] = {0};
    char v_cpfcnpj[15] = {0};
    char sData[32] = {0};
    char NomeArquivo[128] = {0};
    char NomeArquivo_Old[128] = {0};
    char NomeArquivo_New[128] = {0};
    string v_Cabec;
    string v_Rodape;
    char Cmd[128] = {0};
    char sCmdPost[128] = {0};
    char sURI[256] = {0};
    string sEnderecoIP;
    string sCodigoSessao;
    string xml;
    
    
    v_Cabec = "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n";
    v_Cabec += "<ass:assinantes xmlns:ass=\"http://asspaweb.pgr.mpf.gov.br/sittel/schemas/assinante\">\n";
    v_Rodape = "</ass:assinantes>\n";

    memset ( &nrSolicitacao, 0x0, sizeof(nrSolicitacao) );
    memset ( &CodigoOrdem, 0x0, sizeof(CodigoOrdem) );
    memset ( &CodigoRequisicao, 0x0, sizeof(CodigoRequisicao) );
    
    EXEC SQL WHENEVER SQLERROR DO ErroOracle( &sqlca );
    EXEC SQL
    SELECT 
       NUMEROSOLICITACAO ,
       CODIGOORDEM ,
       CODIGOREQUISICAO 
    INTO 
       :nrSolicitacao:i_nrSolicitacao ,
       :CodigoOrdem:i_CodigoOrdem ,
       :CodigoRequisicao:i_CodigoRequisicao
    FROM 
       CUSTOMER.FILAPROCESSUM
    WHERE 
       IDFILAPROCESSUM = :sIdFila ;
    
    CONVIND ( nrSolicitacao, i_nrSolicitacao );
 
    time ( &rawtime );
    timeinfo = localtime ( &rawtime );
    strftime( sData, 17, "%Y%m%d_%H%M%S", timeinfo );

    sprintf ( NomeArquivo, "../data/ASSINANTE_%s_VIVONET_%s.xml", (char*)nrSolicitacao.arr, sData );
    FILE * fp;
    if ( (fp = fopen ( NomeArquivo, "w" )) == NULL )
    {
        sprintf ( szAux, "%%% ERROR fopen: [%s] - file [%s]", strerror(errno), NomeArquivo );oLog.logDebug(szAux);
        return -1;
    }
    
    fprintf (fp, "%s", v_Cabec.c_str() );
    
    EXEC SQL DECLARE cAssinante CURSOR FOR
    SELECT DISTINCT
       D.NRCPFCNPJ ,
       D.NRDOCUMENTO ,
       UTL_I18N.ESCAPE_REFERENCE(D.NMASSINANTE) ,
       D.TPASSINANTE 
    FROM
        CUSTOMER.SITTELRESULTADO D
    WHERE
        CODREQ = :sIdFila 
    AND D.DTINICIOINSTALACAO IS NOT NULL
    AND D.TPASSINANTE IS NOT NULL
    Group by D.NRCPFCNPJ, D.NRDOCUMENTO, D.NMASSINANTE, D.TPASSINANTE ;

    EXEC SQL OPEN cAssinante;
    for( ;; )   
    {

        memset ( v_cpfcnpj, 0x0, sizeof(v_cpfcnpj) );
        memset( &nrcpfcnpj, 0x0, sizeof(nrcpfcnpj) );
        memset( &nrdocumento, 0x0, sizeof(nrdocumento) );
        memset( &nmassinante, 0x0, sizeof(nmassinante) );
        memset( &tpassinante, 0x0, sizeof(tpassinante) );
        i_nrcpfcnpj = -1;
        i_nrdocumento = -1;
        i_nmassinante = -1;
        i_tpassinante = -1;
        
        EXEC SQL FETCH cAssinante
        INTO :nrcpfcnpj:i_nrcpfcnpj ,
             :nrdocumento:i_nrdocumento ,
             :nmassinante:i_nmassinante ,
             :tpassinante:i_tpassinante ;
        
        
        if ( nrcpfcnpj.arr[0] == 0x0 )
            break;

        CONVIND( nrcpfcnpj, i_nrcpfcnpj );
        CONVIND( nrdocumento, i_nrdocumento );
        CONVIND( nmassinante, i_nmassinante );
        CONVIND( tpassinante, i_tpassinante );
        
        sprintf ( bf, "%c<assinante>%c", 0x09, 0x0A );
        xml = bf;

        sprintf ( v_cpfcnpj, "%s", (char *)nrcpfcnpj.arr );
        RetiraHifen ( v_cpfcnpj );
        alltrim ( v_cpfcnpj );
        
        if ( tpassinante.arr[0] == '1' )   // CPF
        {
            if ( strlen(v_cpfcnpj) != 11 )
                continue;
        }
        else
        {
            if ( tpassinante.arr[0] == '2' )   // CNPJ
            {
                if ( strlen(v_cpfcnpj) != 14 )
                    continue;
            }
        }
        
        sprintf ( bf, "%c%c<cpfCnpj>%s</cpfCnpj>%c", 0x09, 0x09, v_cpfcnpj, 0x0A );
        xml += bf;

        if ( nrdocumento.arr[0] != 0x0 )
        {
            sprintf ( bf, "%c%c<documento>%s</documento>%c", 0x09, 0x09, (char*)nrdocumento.arr, 0x0A );
            xml += bf;
        }

        sprintf ( bf, "%c%c<nome>%s</nome>%c", 0x09, 0x09, (char*)nmassinante.arr, 0x0A );
        xml += bf;

        sprintf ( bf, "%c%c<tipo>%s</tipo>%c", 0x09, 0x09, (char*)tpassinante.arr, 0x0A );
        xml += bf;

        sprintf ( bf, "%c</assinante>%c", 0x09, 0x0A );
        xml += bf;

        fprintf (fp, "%s", xml.c_str() );
    }
    EXEC SQL CLOSE cAssinante;
    
    fprintf (fp, "%s", v_Rodape.c_str() );
    fclose ( fp );

    sprintf ( Cmd, "gzip %s", NomeArquivo );
    if ( system ( Cmd ) < 0 )
    {
        sprintf ( szAux, "@@@ ERROR system(): [%s]", strerror(errno) );oLog.logDebug(szAux);
        return -1;
    }

    sprintf ( NomeArquivo_Old, "%s.gz", NomeArquivo );
    strcpy ( NomeArquivo_New, NomeArquivo_Old );
    int pos = strlen (NomeArquivo_New) - 7;
    NomeArquivo_New[pos] = 0x0;
    strcat ( NomeArquivo_New,".zip" );
    if ( rename ( NomeArquivo_Old, NomeArquivo_New ) < 0 )
    {
        sprintf ( szAux, "@@@ ERRO rename: [%s]", strerror(errno) );oLog.logDebug(szAux);
        return -1;
    }
    
    GetURI ( sURI );   // endPoint
    sCodigoSessao = sIdFila_Prm ;   // codigoSessao
    getIpAddress( sEnderecoIP );   // enderecoIP

    sprintf ( szAux, "*** sURI             [%s]", sURI ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** sCodigoSessao    [%s]", sCodigoSessao.c_str() ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** sEnderecoIP      [%s]", sEnderecoIP.c_str() ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** CodigoOrdem      [%s]", (char*)CodigoOrdem.arr ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** CodigoRequisicao [%s]", (char*)CodigoRequisicao.arr ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** nrSolicitacao    [%s]", (char*)nrSolicitacao.arr ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** Arquivo Gerado   [%s]", NomeArquivo_New ); oLog.logDebug(szAux);

    sprintf ( sCmdPost, "nohup java RequestRequisicaoJudicial %s %s %s %s %s %s %s %s %s %s ", 
                         sURI, sCodigoSessao.c_str(), sEnderecoIP.c_str(), (char*)CodigoOrdem.arr,
                         (char*)CodigoRequisicao.arr, (char*)nrSolicitacao.arr, "ASSINANTE", 
                         (char*)&NomeArquivo_New[8], "0", "Sucesso" );
    
    
    sprintf ( szAux, "*** Post: [%s]", sCmdPost ); oLog.logDebug(szAux);

    string retorno = GetStdoutFromCommand( sCmdPost );
    sprintf ( szAux, "retorno: [%s]", retorno.c_str() );oLog.logDebug(szAux);

    size_t found;
    string strTmp;
    string strStatus;
    
    // STATUS
    found = retorno.find("<ns0:status>");
    sprintf ( szAux, "%ld", found );
    // NAO HOUVE RETORNO DO SERVIDOR SITTEL, DEIXANDO DISPONIVEL PARA A PROXIMA EXECUCAO
    if ( !strcmp(szAux, "-1") )   
    {
        strcpy ( szAux, "*** NÃO HOUVE RESPOSTA AO INFORMAR DISPONILIBILIDADE DO ARQUIVO ASSINANTE ***" ); oLog.logDebug(szAux);

        MsgTry += "*** NÃO HOUVE RESPOSTA AO INFORMAR DISPONILIBILIDADE DO ARQUIVO ASSINANTE ***";
        sprintf( dsErro, "%s", MsgTry.c_str() );
        
        EXEC SQL
        UPDATE CUSTOMER.FILAPROCESSUM
        set INPROCESSADO = 0,
            CDERRO = 77,
            DTFIMPROCESSAMENTO = sysdate ,
            DSERRO = :dsErro
        Where
           IDFILAPROCESSUM = :sIdFila ;

        EXEC SQL COMMIT;

        oLog.logDebug( "<<< ArquivoAssinante()" );
           
        return 0;
    }

    strTmp = retorno.substr (found+12);
    strStatus = strTmp.substr(0,strTmp.find("</ns0:status>"));
    
    // CODIGO DO ERRO
    found = retorno.find("<ns0:codigoErro>");
    strTmp = retorno.substr (found+16);
    string strCodigoErro = strTmp.substr(0,strTmp.find("</ns0:codigoErro>"));

    found = retorno.find("<ns0:descricaoErro>");
    strTmp = retorno.substr (found+19);
    string strDescricaoErro = strTmp.substr(0,strTmp.find("</ns0:descricaoErro>"));

    // DESCRICAO DO ERRO
    sprintf ( szAux, "*** status: [%s]", strStatus.c_str() );oLog.logDebug(szAux);
    sprintf ( szAux, "*** codigoErro: [%s]", strCodigoErro.c_str() );oLog.logDebug(szAux);
    sprintf ( szAux, "*** descricaoErro: [%s]", strDescricaoErro.c_str() );oLog.logDebug(szAux);

    if (!strStatus.compare("OK"))
    {
        //oLog.logDebug("--- Retorno OK ---\n");
        MsgTry += "Sucesso - response.status[OK]";
        sprintf( dsErro, "%s", MsgTry.c_str() );

        EXEC SQL
        UPDATE CUSTOMER.FILAPROCESSUM
        set INPROCESSADO = 1,
            DTFIMPROCESSAMENTO = sysdate ,
            CDERRO = 0,
            DSERRO = :dsErro
        Where
           IDFILAPROCESSUM = :sIdFila ;
    }
    else if (!strStatus.compare("ERRO"))
    {
        
        if (!strCodigoErro.compare("415"))
        {
            strcpy(cdErro, strCodigoErro.c_str());
            found = strDescricaoErro.find(": Nenhuma");
            strTmp = strDescricaoErro.substr (found);
            strDescricaoErro = "415 - Erro de validação";
            strDescricaoErro += strTmp;
            strcpy(dsErro, strDescricaoErro.c_str());
            
            MsgTry += dsErro;
            sprintf( dsErro, "%s", MsgTry.c_str() );
            EXEC SQL
            UPDATE CUSTOMER.FILAPROCESSUM
            set INPROCESSADO = 1,
                DTFIMPROCESSAMENTO = sysdate ,
                CDERRO = :cdErro,
                DSERRO = :dsErro
            Where
               IDFILAPROCESSUM = :sIdFila ;
        }
        else if (!strCodigoErro.compare("416"))
        {
            strcpy(cdErro, strCodigoErro.c_str());
            found = strDescricaoErro.find(": Nenhuma");
            strTmp = strDescricaoErro.substr (found);
            strDescricaoErro = "416 - Erro de validação";
            strDescricaoErro += strTmp;
            strcpy(dsErro, strDescricaoErro.c_str());
            
            MsgTry += dsErro;
            sprintf( dsErro, "%s", MsgTry.c_str() );
            EXEC SQL
            UPDATE CUSTOMER.FILAPROCESSUM
            set INPROCESSADO = 1,
                DTFIMPROCESSAMENTO = sysdate ,
                CDERRO = :cdErro,
                DSERRO = :dsErro
            Where
               IDFILAPROCESSUM = :sIdFila ;
        }
        else
        {
            strcpy(cdErro, strCodigoErro.c_str());
            strcpy(dsErro, strDescricaoErro.c_str());
            
            MsgTry += dsErro;
            sprintf( dsErro, "%s", MsgTry.c_str() );
            EXEC SQL
            UPDATE CUSTOMER.FILAPROCESSUM
            set INPROCESSADO = 0,
                DTFIMPROCESSAMENTO = sysdate ,
                CDERRO = :cdErro,
                DSERRO = :dsErro
            Where
               IDFILAPROCESSUM = :sIdFila ;
        }
    }
    
    EXEC SQL COMMIT;

    oLog.logDebug( "<<< ArquivoAssinante()" );

    return 0;
}



int ArquivoAssinanteTerminal ( char * sIdFila_Prm, std::string& MsgTry )
{
    oLog.logDebug( ">>> ArquivoAssinanteTerminal()" );

    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;
       VARCHAR nrSolicitacao[32];
       short i_nrSolicitacao = -1;
       VARCHAR vDetalhe[4000];
       short i_vDetalhe;
       VARCHAR CodigoOrdem[64];
       short i_CodigoOrdem = -1;
       VARCHAR CodigoRequisicao[64];
       short i_CodigoRequisicao = -1;
       char * sIdFila = sIdFila_Prm;
       char cdErro[256];
       char dsErro[256];

       VARCHAR tpAssinante[2];
       VARCHAR nrcpfcnpj[20];
       VARCHAR nrdocumento[256];
       VARCHAR tpterminal[20];
       VARCHAR nrterminal[256];
       VARCHAR dtinicioinstalacao[16];
       VARCHAR dtfiminstalacao[16];
       short i_tpAssinante = -1;
       short i_nrcpfcnpj = -1;
       short i_nrdocumento = -1;
       short i_tpterminal = -1;
       short i_nrterminal = -1;
       short i_dtinicioinstalacao = -1;
       short i_dtfiminstalacao = -1;
       
    EXEC SQL END DECLARE SECTION;
    
    time_t      rawtime;
    struct tm* timeinfo;
    char bf[1024] = {0};
    char v_cpfcnpj[15];
    char sData[32];
    char NomeArquivo[128] = {0};
    char NomeArquivo_Old[128] = {0};
    char NomeArquivo_New[128] = {0};
    string v_Cabec;
    string v_Rodape;
    char Cmd[128] = {0};
    char sCmdPost[128] = {0};
    char sURI[256] = {0};
    string sEnderecoIP;
    string sCodigoSessao;
    string xml;
    
    v_Cabec = "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n";
    v_Cabec += "<ass:assinantesTerminais xmlns:ass=\"http://asspaweb.pgr.mpf.gov.br/sittel/schemas/assinante-terminal\">\n";
    v_Rodape = "</ass:assinantesTerminais>";

    memset ( &nrSolicitacao, 0x0, sizeof(nrSolicitacao) );
    memset ( &CodigoOrdem, 0x0, sizeof(CodigoOrdem) );
    memset ( &CodigoRequisicao, 0x0, sizeof(CodigoRequisicao) );
    
    EXEC SQL WHENEVER SQLERROR DO ErroOracle( &sqlca );
    EXEC SQL
    SELECT 
       NUMEROSOLICITACAO ,
       CODIGOORDEM ,
       CODIGOREQUISICAO 
    INTO 
       :nrSolicitacao:i_nrSolicitacao ,
       :CodigoOrdem:i_CodigoOrdem ,
       :CodigoRequisicao:i_CodigoRequisicao
    FROM 
       CUSTOMER.FILAPROCESSUM
    WHERE 
       IDFILAPROCESSUM = :sIdFila ;
    
    CONVIND ( nrSolicitacao, i_nrSolicitacao );
    CONVIND ( CodigoOrdem, i_CodigoOrdem );
    CONVIND ( CodigoRequisicao, i_CodigoRequisicao );

    time ( &rawtime );
    timeinfo = localtime ( &rawtime );
    strftime( sData, 17, "%Y%m%d_%H%M%S", timeinfo );

    sprintf ( NomeArquivo, "../data/ASSINANTE-TERMINAL_%s_VIVONET_%s.xml", (char*)nrSolicitacao.arr, sData );
    FILE* fp;
    if ( (fp = fopen ( NomeArquivo, "w" )) == NULL )
    {
        sprintf ( szAux, "%%% ERROR fopen: [%s] - file [%s]", strerror(errno), NomeArquivo );oLog.logDebug(szAux);
        return -1;
    }
    
    fprintf (fp, "%s", v_Cabec.c_str() );
    
    EXEC SQL DECLARE cAssinanteTerminal CURSOR FOR
    SELECT DISTINCT
       D.TPASSINANTE ,
       D.NRCPFCNPJ ,
       D.NRDOCUMENTO ,
       D.TPTERMINAL ,
       NVL(D.NRTERMINAL,0) ,
       TO_CHAR(D.DTINICIOINSTALACAO,'DDMMYYYY') ,
       TO_CHAR(D.DTFIMINSTALACAO,'DDMMYYYY') 
    FROM
        CUSTOMER.SITTELRESULTADO D
    WHERE
        CODREQ = :sIdFila 
    AND D.TPASSINANTE IS NOT NULL
    AND D.DTINICIOINSTALACAO IS NOT NULL ;

    EXEC SQL OPEN cAssinanteTerminal;
    for( ;; )   
    {
        memset( &tpAssinante, 0x0, sizeof(tpAssinante) );
        memset( &nrcpfcnpj, 0x0, sizeof(nrcpfcnpj) );
        memset( &nrdocumento, 0x0, sizeof(nrdocumento) );
        memset( &tpterminal, 0x0, sizeof(tpterminal) );
        memset( &nrterminal, 0x0, sizeof(nrterminal) );
        memset( &dtinicioinstalacao, 0x0, sizeof(dtinicioinstalacao) );
        memset( &dtfiminstalacao, 0x0, sizeof(dtfiminstalacao) );
        i_tpAssinante = -1;
        i_nrcpfcnpj = -1;
        i_nrdocumento = -1;
        i_tpterminal = -1;
        i_nrterminal = -1;
        i_dtinicioinstalacao = -1;
        i_dtfiminstalacao = -1;
        
        memset ( v_cpfcnpj, 0x0, sizeof(v_cpfcnpj) );
        
        EXEC SQL FETCH cAssinanteTerminal
        INTO :tpAssinante:i_tpAssinante ,
             :nrcpfcnpj:i_nrcpfcnpj ,
             :nrdocumento:i_nrdocumento ,
             :tpterminal:i_tpterminal ,
             :nrterminal:i_nrterminal ,
             :dtinicioinstalacao:i_dtinicioinstalacao ,
             :dtfiminstalacao:i_dtfiminstalacao ;
             
        if ( nrcpfcnpj.arr[0] == 0x0 )
            break;
        
        CONVIND( tpAssinante, i_tpAssinante );
        CONVIND( nrcpfcnpj, i_nrcpfcnpj );
        CONVIND( nrdocumento, i_nrdocumento );
        CONVIND( tpterminal, i_tpterminal );
        CONVIND( nrterminal, i_nrterminal );
        CONVIND( dtinicioinstalacao, i_dtinicioinstalacao );
        CONVIND( dtfiminstalacao, i_dtfiminstalacao );
        
        sprintf ( v_cpfcnpj, "%s", (char *)nrcpfcnpj.arr );
        RetiraHifen ( v_cpfcnpj );
        alltrim ( v_cpfcnpj );
        
        if ( tpAssinante.arr[0] == '1' )   // CPF
        {
            if ( strlen(v_cpfcnpj) != 11 )
                continue;
        }
        else
        {
            if ( tpAssinante.arr[0] == '2' )   // CNPJ
            {
                if ( strlen(v_cpfcnpj) != 14 )
                    continue;
            }
        }
        
        sprintf ( bf, "%c<assinanteTerminal>%c", 0x09, 0x0A );
        xml = bf;

        sprintf ( bf, "%c%c<cpfCnpj>%s</cpfCnpj>%c", 0x09, 0x09, v_cpfcnpj, 0x0A );
        xml += bf;

        if ( nrdocumento.arr[0] != 0x0 )
        {
            sprintf ( bf, "%c%c<documento>%s</documento>%c", 0x09, 0x09, (char*)nrdocumento.arr, 0x0A );
            xml += bf;
        }

        sprintf ( bf, "%c%c<tipo>%s</tipo>%c", 0x09, 0x09, (char*)tpterminal.arr, 0x0A );
        xml += bf;

        sprintf ( bf, "%c%c<numero>%s</numero>%c", 0x09, 0x09, (char*)nrterminal.arr, 0x0A );
        xml += bf;

        sprintf ( bf, "%c%c<dataInicio>%s</dataInicio>%c", 0x09, 0x09, (char*)dtinicioinstalacao.arr, 0x0A );
        xml += bf;

        if ( dtfiminstalacao.arr[0] != 0x0 )
        {
            sprintf ( bf, "%c%c<dataFim>%s</dataFim>%c", 0x09, 0x09, (char*)dtfiminstalacao.arr, 0x0A );
            xml += bf;
        }

        sprintf ( bf, "%c</assinanteTerminal>%c", 0x09, 0x0A );
        xml += bf;

        fprintf (fp, "%s", xml.c_str() );
    }
    EXEC SQL CLOSE cAssinanteTerminal;
    
    fprintf (fp, "%s", v_Rodape.c_str() );
    fclose ( fp );

    sprintf ( Cmd, "gzip %s", NomeArquivo );
    if ( system ( Cmd ) < 0 )
    {
        sprintf ( szAux, "@@@ ERROR system(): [%s]", strerror(errno) );oLog.logDebug(szAux);
        return -1;
    }
    
    sprintf ( NomeArquivo_Old, "%s.gz", NomeArquivo );
    strcpy ( NomeArquivo_New, NomeArquivo_Old );
    int pos = strlen (NomeArquivo_New) - 7;
    NomeArquivo_New[pos] = 0x0;
    strcat ( NomeArquivo_New,".zip" );
    if ( rename ( NomeArquivo_Old, NomeArquivo_New ) < 0 )
    {
        sprintf ( szAux, "@@@ ERRO rename: [%s]", strerror(errno) );oLog.logDebug(szAux);
        return -1;
    }
    
    GetURI ( sURI );   // endPoint
    sCodigoSessao = sIdFila_Prm ;   // codigoSessao
    getIpAddress( sEnderecoIP );   // enderecoIP
    
    sprintf ( szAux, "*** sURI             [%s]", sURI ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** sCodigoSessao    [%s]", sCodigoSessao.c_str() ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** sEnderecoIP      [%s]", sEnderecoIP.c_str() ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** CodigoOrdem      [%s]", (char*)CodigoOrdem.arr ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** CodigoRequisicao [%s]", (char*)CodigoRequisicao.arr ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** nrSolicitacao    [%s]", (char*)nrSolicitacao.arr ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** Arquivo Gerado   [%s]", NomeArquivo_New ); oLog.logDebug(szAux);

    sprintf ( sCmdPost, "nohup java RequestRequisicaoJudicial %s %s %s %s %s %s %s %s %s %s", 
                         sURI, sCodigoSessao.c_str(), sEnderecoIP.c_str(), (char*)CodigoOrdem.arr,
                         (char*)CodigoRequisicao.arr, (char*)nrSolicitacao.arr, "ASSINANTE-TERMINAL", 
                         (char*)&NomeArquivo_New[8], "0", "Sucesso" );
    
    
    sprintf ( szAux, "*** Post: [%s]", sCmdPost ); oLog.logDebug(szAux);

    string retorno = GetStdoutFromCommand( sCmdPost );
    sprintf ( szAux, "retorno: [%s]", retorno.c_str() );oLog.logDebug(szAux);

    size_t found;
    string strTmp;
    string strStatus;
    
    // STATUS
    found = retorno.find("<ns0:status>");
    // NAO HOUVE RETORNO DO SERVIDOR SITTEL, DEIXANDO DISPONIVEL PARA A PROXIMA EXECUCAO
    sprintf ( szAux, "%ld", found );
    if ( !strcmp(szAux,"-1") )   
    {
        strcpy ( szAux, "*** NÃO HOUVE RESPOSTA AO INFORMAR DISPONILIBILIDADE DO ARQUIVO ASSINANTE TERMINAL ***" ); oLog.logDebug(szAux);

        MsgTry += "*** NÃO HOUVE RESPOSTA AO INFORMAR DISPONILIBILIDADE DO ARQUIVO ASSINANTE TERMINAL ***";
        sprintf( dsErro, "%s", MsgTry.c_str() );
        
        EXEC SQL
        UPDATE CUSTOMER.FILAPROCESSUM
        set INPROCESSADO = 0,
            DTFIMPROCESSAMENTO = sysdate ,
            CDERRO = 77,
            DSERRO = :dsErro
        Where
           IDFILAPROCESSUM = :sIdFila ;

        EXEC SQL COMMIT;

        oLog.logDebug( "<<< ArquivoAssinanteTerminal()" );
           
        return 0;
    }

    strTmp = retorno.substr (found+12);
    strStatus = strTmp.substr(0,strTmp.find("</ns0:status>"));
    
    // CODIGO DO ERRO
    found = retorno.find("<ns0:codigoErro>");
    strTmp = retorno.substr (found+16);
    string strCodigoErro = strTmp.substr(0,strTmp.find("</ns0:codigoErro>"));

    found = retorno.find("<ns0:descricaoErro>");
    strTmp = retorno.substr (found+19);
    string strDescricaoErro = strTmp.substr(0,strTmp.find("</ns0:descricaoErro>"));

    // DESCRICAO DO ERRO
    sprintf ( szAux, "*** status: [%s]", strStatus.c_str() );oLog.logDebug(szAux);
    sprintf ( szAux, "*** codigoErro: [%s]", strCodigoErro.c_str() );oLog.logDebug(szAux);
    sprintf ( szAux, "*** descricaoErro: [%s]", strDescricaoErro.c_str() );oLog.logDebug(szAux);

    if (!strStatus.compare("OK"))
    {
        MsgTry += "Sucesso - response.status[OK]";
        sprintf( dsErro, "%s", MsgTry.c_str() );

        EXEC SQL
        UPDATE CUSTOMER.FILAPROCESSUM
        set INPROCESSADO = 1,
            DTFIMPROCESSAMENTO = sysdate ,
            CDERRO = 0,
            DSERRO = :dsErro
        Where
           IDFILAPROCESSUM = :sIdFila ;
    }
    else if (!strStatus.compare("ERRO"))
    {
        
        if (!strCodigoErro.compare("415"))
        {
            strcpy(cdErro, strCodigoErro.c_str());
            found = strDescricaoErro.find(": Nenhuma");
            strTmp = strDescricaoErro.substr (found);
            strDescricaoErro = "415 - Erro de validação";
            strDescricaoErro += strTmp;
            strcpy(dsErro, strDescricaoErro.c_str());
            
            MsgTry += dsErro;
            sprintf( dsErro, "%s", MsgTry.c_str() );
            
            EXEC SQL
            UPDATE CUSTOMER.FILAPROCESSUM
            set INPROCESSADO = 1,
                DTFIMPROCESSAMENTO = sysdate ,
                CDERRO = :cdErro,
                DSERRO = :dsErro
            Where
               IDFILAPROCESSUM = :sIdFila ;
        }
        else
        {
            strcpy(cdErro, strCodigoErro.c_str());
            strcpy(dsErro, strDescricaoErro.c_str());
            
            MsgTry += dsErro;
            sprintf( dsErro, "%s", MsgTry.c_str() );

            EXEC SQL
            UPDATE CUSTOMER.FILAPROCESSUM
            set INPROCESSADO = 0,
                DTFIMPROCESSAMENTO = sysdate ,
                CDERRO = :cdErro,
                DSERRO = :dsErro
            Where
               IDFILAPROCESSUM = :sIdFila ;
        }
    }

    
    EXEC SQL COMMIT;

    oLog.logDebug( "<<< ArquivoAssinanteTerminal()" );

    return 0;
}



int ArquivoInstalacao ( char * sIdFila_Prm, std::string& MsgTry )
{
    oLog.logDebug( ">>> ArquivoInstalacao()" );

    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;
       VARCHAR nrSolicitacao[32];
       short i_nrSolicitacao = -1;
       VARCHAR vDetalhe[4000];
       short i_vDetalhe;
       VARCHAR CodigoOrdem[64];
       short i_CodigoOrdem = -1;
       VARCHAR CodigoRequisicao[64];
       short i_CodigoRequisicao = -1;
       char * sIdFila = sIdFila_Prm;
       char cdErro[256];
       char dsErro[256];
       
       VARCHAR nrterminal[256];
       VARCHAR tpassinante[16];
       VARCHAR nmendereco[256];
       VARCHAR nmbairro[256];
       VARCHAR nmmunicipio[256];
       VARCHAR uf[16];
       VARCHAR nmcep[32];
       VARCHAR dtinicioinstalacao[16];
       VARCHAR dtfiminstalacao[16];
       short i_nrterminal = -1;
       short i_tpassinante = -1;
       short i_nmendereco = -1;
       short i_nmbairro = -1;
       short i_nmmunicipio = -1;
       short i_uf = -1;
       short i_nmcep = -1;
       short i_dtinicioinstalacao = -1;
       short i_dtfiminstalacao = -1;
       
    EXEC SQL END DECLARE SECTION;
    
    time_t      rawtime;
    struct tm * timeinfo;
    char v_cep[10] = {0};
    char v_uf[15] ={0};
    char bf[1024] = {0};
    char sData[32] = {0};
    char NomeArquivo[128] = {0};
    char NomeArquivo_Old[128] = {0};
    char NomeArquivo_New[128] = {0};
    string v_Cabec;
    string v_Rodape;
    char Cmd[128] = {0};
    char sCmdPost[128] = {0};
    char sURI[256] = {0};
    string sEnderecoIP;
    string sCodigoSessao;
    string xml;
    
    memset ( NomeArquivo_New, 0x0, sizeof(NomeArquivo_New) );
    v_Cabec = "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n";
    v_Cabec += "<ins:instalacoes xmlns:ins=\"http://asspaweb.pgr.mpf.gov.br/sittel/schemas/instalacoes\">\n";
    v_Rodape = "</ins:instalacoes>";

    memset ( &nrSolicitacao, 0x0, sizeof(nrSolicitacao) );
    memset ( &CodigoOrdem, 0x0, sizeof(CodigoOrdem) );
    memset ( &CodigoRequisicao, 0x0, sizeof(CodigoRequisicao) );
    
    EXEC SQL WHENEVER SQLERROR DO ErroOracle( &sqlca );
    EXEC SQL
    SELECT 
       NUMEROSOLICITACAO ,
       CODIGOORDEM ,
       CODIGOREQUISICAO 
    INTO 
       :nrSolicitacao:i_nrSolicitacao ,
       :CodigoOrdem:i_CodigoOrdem ,
       :CodigoRequisicao:i_CodigoRequisicao
    FROM 
       CUSTOMER.FILAPROCESSUM
    WHERE 
       IDFILAPROCESSUM = :sIdFila ;
    
    CONVIND ( nrSolicitacao, i_nrSolicitacao );
    CONVIND ( CodigoOrdem, i_CodigoOrdem );
    CONVIND ( CodigoRequisicao, i_CodigoRequisicao );
 
    time ( &rawtime );
    timeinfo = localtime ( &rawtime );
    strftime( sData, 17, "%Y%m%d_%H%M%S", timeinfo );

    sprintf ( NomeArquivo, "../data/INSTALACAO_%s_VIVONET_%s.xml", (char*)nrSolicitacao.arr, sData );
    
    FILE * fp;
    if ( (fp = fopen ( NomeArquivo, "w" )) == NULL )
    {
        sprintf ( szAux, "%%% ERROR fopen: [%s] - file [%s]", strerror(errno), NomeArquivo );oLog.logDebug(szAux);
        return -1;
    }
    
    fprintf (fp, "%s", v_Cabec.c_str() );
    
    
    EXEC SQL DECLARE cInstalacao CURSOR FOR
    SELECT DISTINCT
        NVL(D.NRTERMINAL,'0') ,
        D.TPASSINANTE ,
        UTL_I18N.ESCAPE_REFERENCE(NVL(D.NMENDERECO,'INDISPONÍVEL')) ,
        UTL_I18N.ESCAPE_REFERENCE(NVL(D.NMBAIRRO,'INDISPONÍVEL')) ,
        UTL_I18N.ESCAPE_REFERENCE(NVL(D.NMMUNICIPIO,'INDISPONÍVEL')) ,
        NVL(D.NMUF,'INDISPONÍVEL') , 
        D.NMCEP ,
        TO_CHAR(D.DTINICIOINSTALACAO,'DDMMYYYY') ,
        TO_CHAR(D.DTFIMINSTALACAO,'DDMMYYYY') 
    FROM
        CUSTOMER.SITTELRESULTADO D
    WHERE
        CODREQ = :sIdFila 
    AND D.DTINICIOINSTALACAO IS NOT NULL
    AND D.TPASSINANTE IS NOT NULL ;

    EXEC SQL OPEN cInstalacao;
    for( ;; )   
    {

        memset ( v_uf, 0x0, sizeof(v_uf) );
        memset ( &nrterminal, 0x0, sizeof(nrterminal) );
        memset ( &tpassinante, 0x0, sizeof(tpassinante) );
        memset ( &nmendereco, 0x0, sizeof(nmendereco) );
        memset ( &nmbairro, 0x0, sizeof(nmbairro) );
        memset ( &nmmunicipio, 0x0, sizeof(nmmunicipio) );
        memset ( &uf, 0x0, sizeof(uf) );
        memset ( &nmcep, 0x0, sizeof(nmcep) );
        memset ( &dtinicioinstalacao, 0x0, sizeof(dtinicioinstalacao) );
        memset ( &dtfiminstalacao, 0x0, sizeof(dtfiminstalacao) );
        i_nrterminal = -1;
        i_tpassinante = -1;
        i_nmendereco = -1;
        i_nmbairro = -1;
        i_nmmunicipio = -1;
        i_uf = -1;
        i_nmcep = -1;
        i_dtinicioinstalacao = -1;
        i_dtfiminstalacao = -1;        
        
        EXEC SQL FETCH cInstalacao
        INTO :nrterminal:i_nrterminal ,
             :tpassinante:i_tpassinante ,
             :nmendereco:i_nmendereco ,
             :nmbairro:i_nmbairro ,
             :nmmunicipio:i_nmmunicipio ,
             :uf:i_uf ,
             :nmcep:i_nmcep ,
             :dtinicioinstalacao:i_dtinicioinstalacao ,
             :dtfiminstalacao:i_dtfiminstalacao ;
             
        if ( nrterminal.arr[0] == 0x0 )
            break;
        
        CONVIND( nrterminal, i_nrterminal );
        CONVIND( tpassinante, i_tpassinante );
        CONVIND( nmendereco, i_nmendereco );
        CONVIND( nmbairro, i_nmbairro );
        CONVIND( nmmunicipio, i_nmmunicipio );
        CONVIND( uf, i_uf );
        CONVIND( nmcep, i_nmcep );
        CONVIND( dtinicioinstalacao, i_dtinicioinstalacao );
        CONVIND( dtfiminstalacao, i_dtfiminstalacao );
        
        sprintf ( bf, "%c<instalacao>%c", 0x09, 0x0A );
        xml = bf;
        
        sprintf ( bf, "%c%c<numeroTerminal>%s</numeroTerminal>%c", 0x09, 0x09, (char*)nrterminal.arr, 0x0A );
        xml += bf;

        sprintf ( bf, "%c%c<tipoEndereco>%s</tipoEndereco>%c", 0x09, 0x09, (char*)tpassinante.arr, 0x0A );
        xml += bf;
        
        sprintf ( bf, "%c%c<endereco>%s</endereco>%c", 0x09, 0x09, (char*)nmendereco.arr, 0x0A );
        xml += bf;

        sprintf ( bf, "%c%c<bairro>%s</bairro>%c", 0x09, 0x09, (char*)nmbairro.arr, 0x0A );
        xml += bf;

        sprintf ( bf, "%c%c<municipio>%s</municipio>%c", 0x09, 0x09, (char*)nmmunicipio.arr, 0x0A );
        xml += bf;

        sprintf ( v_uf, "%s", (char*)uf.arr );

        if ( ValidaUF( v_uf ) < 0 )  // Registro com UF invalida
            strcpy( v_uf, "INDISPONÍVEL" );

        sprintf ( bf, "%c%c<uf>%s</uf>%c", 0x09, 0x09, v_uf, 0x0A );
        xml += bf;

        sprintf ( v_cep, "%s", (char *)nmcep.arr );
        alltrim( v_cep );
        if ( strlen(v_cep) < 8 || strlen(v_cep) > 9 )   // CEP invalido
            strcpy( v_cep, "99999999" );
        else
        {
            if ( ValidaCEP( v_cep ) < 0 )   // CEP invalido
                strcpy( v_cep, "99999999" );
        }
        sprintf ( bf, "%c%c<cep>%s</cep>%c", 0x09, 0x09, v_cep, 0x0A );
        xml += bf;

        sprintf ( bf, "%c%c<dataInicio>%s</dataInicio>%c", 0x09, 0x09, (char*)dtinicioinstalacao.arr, 0x0A );
        xml += bf;

        if ( dtfiminstalacao.arr[0] != 0x0 )
        {
            sprintf ( bf, "%c%c<dataFim>%s</dataFim>%c", 0x09, 0x09, (char*)dtfiminstalacao.arr, 0x0A );
            xml += bf;
        }

        sprintf ( bf, "%c</instalacao>%c", 0x09, 0x0A );
        xml += bf;
        
        fprintf (fp, "%s", xml.c_str() );
    }
    EXEC SQL CLOSE cInstalacao;
    
    fprintf (fp, "%s", v_Rodape.c_str() );
    fclose ( fp );
    
    sprintf ( Cmd, "gzip %s", NomeArquivo );
    if ( system ( Cmd ) < 0 )
    {
        sprintf ( szAux, "@@@ ERROR system(): [%s]", strerror(errno) );oLog.logDebug(szAux);
        return -1;
    }

    sprintf ( NomeArquivo_Old, "%s.gz", NomeArquivo );
    strcpy ( NomeArquivo_New, NomeArquivo_Old );
    int pos = strlen (NomeArquivo_New) - 7;
    NomeArquivo_New[pos] = 0x0;
    strcat ( NomeArquivo_New,".zip" );
    if ( rename ( NomeArquivo_Old, NomeArquivo_New ) < 0 )
    {
        sprintf ( szAux, "@@@ ERRO rename: [%s] -> [%s]", NomeArquivo, strerror(errno) );oLog.logDebug(szAux);
        return -1;
    }
    
    GetURI ( sURI );   // endPoint
    sCodigoSessao = sIdFila_Prm ;   // codigoSessao
    getIpAddress( sEnderecoIP );   // enderecoIP

    sprintf ( szAux, "*** sURI             [%s]", sURI ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** sCodigoSessao    [%s]", sCodigoSessao.c_str() ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** sEnderecoIP      [%s]", sEnderecoIP.c_str() ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** CodigoOrdem      [%s]", (char*)CodigoOrdem.arr ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** CodigoRequisicao [%s]", (char*)CodigoRequisicao.arr ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** nrSolicitacao    [%s]", (char*)nrSolicitacao.arr ); oLog.logDebug(szAux);
    sprintf ( szAux, "*** Arquivo Gerado   [%s]", NomeArquivo_New ); oLog.logDebug(szAux);

    sprintf ( sCmdPost, "nohup java RequestRequisicaoJudicial %s %s %s %s %s %s %s %s %s %s", 
                         sURI, sCodigoSessao.c_str(), sEnderecoIP.c_str(), (char*)CodigoOrdem.arr,
                         (char*)CodigoRequisicao.arr, (char*)nrSolicitacao.arr, "INSTALACAO", 
                         (char*)&NomeArquivo_New[8], "0", "Sucesso");
    
    
    sprintf ( szAux, "*** Post: [%s]", sCmdPost ); oLog.logDebug(szAux);

    string retorno = GetStdoutFromCommand( sCmdPost );
    sprintf ( szAux, "retorno: [%s]", retorno.c_str() );oLog.logDebug(szAux);
    
/*
    retorno =
"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>"
"<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">"
"  <soapenv:Header/>"
"  <env:Body xmlns:S=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:env=\"http://schemas.xmlsoap.org/soap/envelope/\">"
"    <enc:EncaminharResultadoProcessamentoResponse xmlns:enc=\"http://www.vivo.com.br/SN/EncaminharResultadoProcessamento\">"
"      <ns0:status>ERRO</ns0:status>"
"      <ns0:codigoErro>415</ns0:codigoErro>"
"      <ns0:descricaoErro>415 - Erro de validação: Nenhuma solicitacao pendente foi encontrada para receber resultado. NumeroSolicitacao: 85801 CodigoOrdem: 233 CodigoRequisicao: 806</ns0:descricaoErro>"
"    </enc:EncaminharResultadoProcessamentoResponse>"
"  </env:Body>"
"</soapenv:Envelope>" ;
*/
    
    size_t found;
    string strTmp;
    string strStatus;
    
    // STATUS
    found = retorno.find("<ns0:status>");
    // NAO HOUVE RETORNO DO SERVIDOR SITTEL, DEIXANDO DISPONIVEL PARA A PROXIMA EXECUCAO
    sprintf ( szAux, "%ld", found );
    if ( !strcmp(szAux,"-1") )   
    {
        strcpy ( szAux, "*** NÃO HOUVE RESPOSTA AO INFORMAR DISPONILIBILIDADE DO ARQUIVO INSTALAÇÃO ***" ); oLog.logDebug(szAux);

        MsgTry += "*** NÃO HOUVE RESPOSTA AO INFORMAR DISPONILIBILIDADE DO ARQUIVO INSTALAÇÃO ***";
        sprintf( dsErro, "%s", MsgTry.c_str() );
        
        EXEC SQL
        UPDATE CUSTOMER.FILAPROCESSUM
        set INPROCESSADO = 0,
            DTFIMPROCESSAMENTO = sysdate ,
            CDERRO = 77,
            DSERRO = :dsErro
        Where
           IDFILAPROCESSUM = :sIdFila ;

        EXEC SQL COMMIT;

        oLog.logDebug( "<<< ArquivoInstalacao()" );
           
        return 0;
    }
    
    strTmp = retorno.substr (found+12);
    strStatus = strTmp.substr(0,strTmp.find("</ns0:status>"));
    
    // CODIGO DO ERRO
    found = retorno.find("<ns0:codigoErro>");
    strTmp = retorno.substr (found+16);
    string strCodigoErro = strTmp.substr(0,strTmp.find("</ns0:codigoErro>"));

    found = retorno.find("<ns0:descricaoErro>");
    strTmp = retorno.substr (found+19);
    string strDescricaoErro = strTmp.substr(0,strTmp.find("</ns0:descricaoErro>"));

    // DESCRICAO DO ERRO
    sprintf ( szAux, "*** status: [%s]", strStatus.c_str() );oLog.logDebug(szAux);
    sprintf ( szAux, "*** codigoErro: [%s]", strCodigoErro.c_str() );oLog.logDebug(szAux);
    sprintf ( szAux, "*** descricaoErro: [%s]", strDescricaoErro.c_str() );oLog.logDebug(szAux);


    if (!strStatus.compare("OK"))
    {
        MsgTry += "Sucesso - response.status[OK]";
        sprintf( dsErro, "%s", MsgTry.c_str() );
        
        EXEC SQL
        UPDATE CUSTOMER.FILAPROCESSUM
        set INPROCESSADO = 1,
            DTFIMPROCESSAMENTO = sysdate ,
            CDERRO = 0,
            DSERRO = :dsErro
        Where
           IDFILAPROCESSUM = :sIdFila ;
    }
    else if (!strStatus.compare("ERRO"))
    {
        
        if (!strCodigoErro.compare("415"))
        {
            strcpy(cdErro, strCodigoErro.c_str());
            
            found = strDescricaoErro.find(": Nenhuma");
            strTmp = strDescricaoErro.substr (found);
            strDescricaoErro = "415 - Erro de validação";
            strDescricaoErro += strTmp;
            strcpy(dsErro, strDescricaoErro.c_str());
            
            MsgTry += dsErro;
            sprintf( dsErro, "%s", MsgTry.c_str() );
            
            EXEC SQL
            UPDATE CUSTOMER.FILAPROCESSUM
            set INPROCESSADO = 1,
                DTFIMPROCESSAMENTO = sysdate ,
                CDERRO = :cdErro,
                DSERRO = :dsErro
            Where
               IDFILAPROCESSUM = :sIdFila ;
        }
        else
        {
            strcpy(cdErro, strCodigoErro.c_str());
            strcpy(dsErro, strDescricaoErro.c_str());
            
            MsgTry += dsErro;
            sprintf( dsErro, "%s", MsgTry.c_str() );
            EXEC SQL
            UPDATE CUSTOMER.FILAPROCESSUM
            set INPROCESSADO = 0,
                DTFIMPROCESSAMENTO = sysdate ,
                CDERRO = :cdErro,
                DSERRO = :dsErro
            Where
               IDFILAPROCESSUM = :sIdFila ;
        }
    }

    
    EXEC SQL COMMIT;

    oLog.logDebug( "<<< ArquivoInstalacao()" );

    return 0;
}



void ErroOracle ( struct sqlca * sqlca )
{
    sprintf( szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca->sqlcode, sqlca->sqlerrm.sqlerrmc ); oLog.logDebug(szAux);
    exit( 1 );
}



bool getHostName(std::string& hostname)
{
	char buff[256+1]={0};

	if (gethostname(buff, sizeof(buff)) == -1) {
		hostname.clear();
        sprintf ( szAux, "@@@ ERROR -> getHostName(): [%s]", strerror(errno) );oLog.logDebug(szAux);
		return false;
	}

	hostname = buff;
	return true;
}



bool getIpAddress(std::string& ipaddr)
{
	std::string hostname;
	getHostName(hostname);

	struct hostent* host = gethostbyname(hostname.c_str());
    if ( !host ) {
        ipaddr.clear();
        sprintf ( szAux, "@@@ ERROR -> gethostbyname(): [%s]", strerror(errno) );oLog.logDebug(szAux);
        return false;
    }

    char* addr = inet_ntoa( *((struct in_addr *)host->h_addr) );
    if (!addr) 
    {
        ipaddr.clear();
        sprintf ( szAux, "@@@ ERROR -> inet_ntoa(): [%s]", strerror(errno) );oLog.logDebug(szAux);
        return false;
    }

	ipaddr = addr;
	return true;
}



int ObtemTpSolicitacao( char * idFilaProcessum_Prm )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char* idFilaProcessum = idFilaProcessum_Prm;
        int TpSolicitacao;
        short i_TpSolicitacao = -1;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR DO ErroOracle( &sqlca );
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
    SELECT tiposolicitacao
      INTO :TpSolicitacao:i_TpSolicitacao
      FROM customer.filaprocessum
     WHERE idfilaprocessum = :idFilaProcessum;

    return TpSolicitacao;

}




int GetURI ( char* sURI )
{
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR vlURI[256];
        short i_vlURI = -1;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR DO ErroOracle( &sqlca );
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    memset ( &vlURI, 0x0, sizeof(vlURI) );
    EXEC SQL
    SELECT dsvalorparametro
      INTO :vlURI:i_vlURI
      FROM apoio.parametro
     WHERE cdparametro = 'PROCESSUM_URI_ENCAMINHAR_RESULTADO_PROCESSAMENTO' ;
    
    CONVIND ( vlURI, i_vlURI );
    strcpy ( sURI, (char*)vlURI.arr );

    return 0;

}



string GetStdoutFromCommand(char* cmd_prm) 
{
    string cmd = cmd_prm;
    string data;
    FILE * stream;
    const int max_buffer = 256;
    char buffer[max_buffer];
    cmd.append(" 2>&1");

    stream = popen(cmd.c_str(), "r");
    if (stream) 
    {
        while (!feof(stream))
           if (fgets(buffer, max_buffer, stream) != NULL) data.append(buffer);
        pclose(stream);
    }
    return data;
}



int ValidaUF( char* sUF_Prm )
{
    char sUF_Cmp[28][15];
    int i;
    
    strcpy( sUF_Cmp[0], "AC" ); strcpy( sUF_Cmp[1], "AL" ); strcpy( sUF_Cmp[2], "AM" );
    strcpy( sUF_Cmp[3], "AP" ); strcpy( sUF_Cmp[4], "BA" ); strcpy( sUF_Cmp[5], "CE" );
    strcpy( sUF_Cmp[6], "DF" ); strcpy( sUF_Cmp[7], "ES" ); strcpy( sUF_Cmp[8], "GO" );
    strcpy( sUF_Cmp[9], "MA" ); strcpy( sUF_Cmp[10], "MG" ); strcpy( sUF_Cmp[11], "MS" );
    strcpy( sUF_Cmp[12], "MT" ); strcpy( sUF_Cmp[13], "PA" ); strcpy( sUF_Cmp[14], "PB" );
    strcpy( sUF_Cmp[15], "PR" ); strcpy( sUF_Cmp[16], "PE" ); strcpy( sUF_Cmp[17], "PI" );
    strcpy( sUF_Cmp[18], "RJ" ); strcpy( sUF_Cmp[19], "RN" ); strcpy( sUF_Cmp[20], "RO" );
    strcpy( sUF_Cmp[21], "RR" ); strcpy( sUF_Cmp[22], "RS" ); strcpy( sUF_Cmp[23], "SC" );
    strcpy( sUF_Cmp[24], "SE" ); strcpy( sUF_Cmp[25], "SP" ); strcpy( sUF_Cmp[26], "TO" );
    strcpy( sUF_Cmp[27], "INDISPONÍVEL" );
    
    for ( i=0; i < 28; i++ )
    {
        if ( strcmp( sUF_Prm, sUF_Cmp[i] ) == 0 )
        {
            return 0;
        }
    }
    
    return -1;
}



int ValidaCEP( char* sCep_Prm )
{

    RetiraHifen( sCep_Prm );

    if ( ValidaNumerico( sCep_Prm ) == false )
        return -1;
    
    if ( strlen(sCep_Prm) != 8 )
        return -1;
    
    return 0;
}



bool ValidaNumerico( char * bf )
{
    int i;
    int tambf;
    alltrim( bf );
    tambf = strlen( bf );
    for ( i=0;i<tambf;i++)
    {
        if ( !isdigit(bf[i]) )
           return false;
    }
    return true;

}



char * alltrim( char * pszString )
{
    ltrim(pszString);
    rtrim(pszString);
    return pszString;
}



char * ltrim( char * pszString )
{
    unsigned int iPos;
    unsigned int iLen;
    char *pszTmp, *pszAlocado;

    iLen=strlen(pszString);

    pszAlocado = (char *)malloc(strlen(pszString) + 1);
    memset( pszAlocado, 0x0, sizeof(pszAlocado) );
    
    strcpy( pszAlocado, pszString );

    pszTmp = pszAlocado;
    

    for(iPos=0; iPos < iLen; iPos++)
        if(pszString[iPos] == 0x20)
            pszTmp++;
        else
            break;

    strcpy(pszString, pszTmp);
    
    free(pszAlocado);
    return pszString;
}



char * rtrim( char * pszString )
{
    int iPos;

    for(iPos=strlen(pszString)-1; iPos >= 0; iPos--)
        if(pszString[iPos] == 0x20)
            pszString[iPos] = 0x00;
        else
            break;
    return pszString;
}



void RetiraHifen( char * pszString )
{
    unsigned int iPosOrigem, iPosDestino;
    unsigned int iLen;
    char *pszTmp;

    iLen=strlen(pszString);

    pszTmp = (char *)malloc(iLen + 1);

    memset(pszTmp, 0x00, iLen + 1);

    for(iPosOrigem=iPosDestino=0; iPosOrigem<iLen; iPosOrigem++)
        if(pszString[iPosOrigem] == 0x2d)
            continue;
        else
            pszTmp[iPosDestino++] = pszString[iPosOrigem];

    strcpy(pszString, pszTmp);

    free(pszTmp);
}




int ValidaExecucao( char * idFilaProcessum_Prm, std::string& MsgTry )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char* idFilaProcessum = idFilaProcessum_Prm;
        VARCHAR dsErro[256];
        short i_dsErro = -1;
        VARCHAR nrMaxTentativa[5];
        short i_nrMaxTentativa = -1;
        char  MsgStatus[256];
    EXEC SQL END DECLARE SECTION;
    
    int nrMaxExec;
    char bf[16];
    int  tentativa_atual;
    std::string MsgNroExec;
    std::string msgTmp;

    struct sqlca sqlca;
    memset( &dsErro, 0x0, sizeof(dsErro) );
    memset( MsgStatus, 0x0, sizeof(MsgStatus) );

    EXEC SQL WHENEVER SQLERROR DO ErroOracle( &sqlca );
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
    select parametro.dsvalorparametro 
    into  :nrMaxTentativa:i_nrMaxTentativa
    from apoio.parametro parametro 
    where parametro.cdParametro = 'QTDE_TENTATIVAS_REPROC_SITTEL';
    CONVIND( nrMaxTentativa, i_nrMaxTentativa );
    nrMaxExec = atoi( (char*)nrMaxTentativa.arr );
    
    sprintf ( szAux, "*** nrMaxExec [%d]", nrMaxExec );oLog.logDebug(szAux);

    EXEC SQL
    SELECT dsErro
      INTO :dsErro:i_dsErro
      FROM customer.filaprocessum
     WHERE idfilaprocessum = :idFilaProcessum;
    
    CONVIND( dsErro, i_dsErro );
    
    sprintf ( szAux, "*** dsErro [%s]", (char*)dsErro.arr );oLog.logDebug(szAux);
    
    msgTmp = (char*)dsErro.arr;

    /*
     * Identifica da coluna dsErro, a ultima tentativa que foi executada
     */
    sprintf( bf, "%.12s", dsErro.arr );
    sprintf( bf, "%s", (char*)&bf[10] );
    tentativa_atual = atoi(bf);
    sprintf ( szAux, "*** Tentativa Atual [%d]", tentativa_atual );oLog.logDebug(szAux);
    tentativa_atual++;
    MsgNroExec = "Tentativa ";
    sprintf( bf,"%d", tentativa_atual );
    MsgNroExec += bf;
    MsgNroExec += " - ";
    MsgTry = MsgNroExec;

    if ( tentativa_atual > nrMaxExec )
    {
        TrataMsgPrc( msgTmp, MsgNroExec );

        strcpy( MsgStatus, msgTmp.c_str() );
        EXEC SQL
        UPDATE CUSTOMER.FILAPROCESSUM
        set INPROCESSADO = 1,
            DTFIMPROCESSAMENTO = sysdate ,
            CDERRO = '7',
            DSERRO = :MsgStatus
        Where
           IDFILAPROCESSUM = :idFilaProcessum ;
        
        EXEC SQL COMMIT;
        return 1;
    }
    
    return 0;

}




void TrataMsgPrc( std::string& msg, std::string& MsgNroExec )
{
    std::string msgTmp;
    std::size_t npos;

    msgTmp = msg;
    
    if ( !msgTmp.compare(0,10,"Tentativa ") )
    {
        npos = msgTmp.find_first_of("-");
        msgTmp = msgTmp.substr(npos+2);
    }

    msgTmp = MsgNroExec + msgTmp;
    msg = msgTmp;
    //sprintf( szAux, "msgTmp [%s]\n", msgTmp.c_str() ); oLog.logDebug(szAux);
}
