#include "../include/AtendimentoAnatel.hpp"

extern errno;

EXEC SQL INCLUDE SQLCA;

AtendimentoAnatel::AtendimentoAnatel() {
	log.setNivel(2);
	log.logDebug("inicializando o AtendimentoAnatel");
	memset(this->szTempTrace,0,sizeof(szTempTrace));
	this->historico = NULL;
	memset(idAnatelSistemaOrigem,0,sizeof(idAnatelSistemaOrigem));
	memset(idAnatelGrupoAbertura,0,sizeof(idAnatelGrupoAbertura));
	memset(idAnatelResponsavelAbertura,0,sizeof(idAnatelResponsavelAbertura));
	memset(idAnatelObservacao,0,sizeof(idAnatelObservacao));
	memset(idAnatelTipoOperacao,0,sizeof(idAnatelTipoOperacao));
	memset(idAnatelProcedencia,0,sizeof(idAnatelProcedencia));
	memset(idAnatelCanal,0,sizeof(idAnatelCanal));
	memset(idAnatelUsuario,0,sizeof(idAnatelUsuario));
}

AtendimentoAnatel::~AtendimentoAnatel() {
	log.logDebug("finalizando o AtendimentoAnatel");
}

int AtendimentoAnatel::selectAtendimentoAnatel( list<Atendimento> &atendimentos, char *nmArquivo) {
	log.logDebug("inicio ler informação de atendimento anatel");
	
	EXEC SQL BEGIN DECLARE SECTION;		
		
		char *cNmArquivo = nmArquivo;
		
		VARCHAR idAtendimentoAnatel[53];
		VARCHAR nrSolicitacao[53];
		VARCHAR dsTipoAtendimentoAnatel[256];
		VARCHAR dsServico[256];
		VARCHAR dsModalidade[256];
		VARCHAR dsMotivo[256];
		VARCHAR dsSubMotivo[256];
		VARCHAR dsCategoria[256];
		VARCHAR dsSubCategoria[256];
		VARCHAR nrTelefoneProblema[256];
		VARCHAR idAtendimentoAnatelArquivo[256];
		VARCHAR nrCpfCnpjAssinante[256];
		VARCHAR nmAssinante[256];

		short i_idAtendimentoAnatel = 0;
		short i_nrSolicitacao = 0;
		short i_dsTipoAtendimentoAnatel = 0;
		short i_dsServico = 0;
		short i_dsModalidade = 0;
		short i_dsMotivo = 0;
		short i_dsSubMotivo = 0;
		short i_dsCategoria = 0;
		short i_dsSubCategoria = 0;
		short i_nrTelefoneProblema = 0;
		short i_idAtendimentoAnatelArquivo = 0;
		short i_nrCpfCnpjAssinante = 0;
		short i_nmAssinante = 0;
		
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;
	
	memset(&idAtendimentoAnatel,0,sizeof(idAtendimentoAnatel));
	memset(&nrSolicitacao,0,sizeof(nrSolicitacao));
	memset(&dsTipoAtendimentoAnatel,0,sizeof(dsTipoAtendimentoAnatel));
	memset(&dsServico,0,sizeof(dsServico));
	memset(&dsModalidade,0,sizeof(dsModalidade));
	memset(&dsMotivo,0,sizeof(dsMotivo));	
	memset(&dsSubMotivo,0,sizeof(dsSubMotivo));
	memset(&dsCategoria,0,sizeof(dsCategoria));
	memset(&dsSubCategoria,0,sizeof(dsSubCategoria));
	memset(&nrTelefoneProblema,0,sizeof(nrTelefoneProblema));
	memset(&idAtendimentoAnatelArquivo,0,sizeof(idAtendimentoAnatelArquivo));
	memset(&nrCpfCnpjAssinante,0,sizeof(nrCpfCnpjAssinante));
	memset(&nmAssinante,0,sizeof(nmAssinante));
	
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
	
	EXEC SQL DECLARE CURSOR_ATENDIMENTO CURSOR FOR
	
		SELECT b.idatendimentoanatel, b.nrsolicitacao, b.dstipoatendimentoanatel,
			   b.dsservico, b.dsmodalidade, b.dsmotivo, b.dssubmotivo, b.dscategoria,
			   b.dssubcategoria, b.nrtelefoneproblema, a.idatendimentoanatelarquivo,
			   b.nrcpfcnpjassinante, b.nmassinante
		  FROM atendimento.atendimentoanatelarquivo a,
			   atendimento.atendimentoanatel b
		 WHERE a.idatendimentoanatelarquivo = b.idatendimentoanatelarquivo
		   AND a.nmarquivo = :cNmArquivo
		   AND b.idatendimento is null;
		   
	EXEC SQL WHENEVER NOT FOUND DO break;
	
	EXEC SQL OPEN CURSOR_ATENDIMENTO;

	for( ;; ) 
	{
		// varre todos os registros 
		EXEC SQL FETCH CURSOR_ATENDIMENTO INTO
		:idAtendimentoAnatel:i_idAtendimentoAnatel,
		:nrSolicitacao:i_nrSolicitacao,
		:dsTipoAtendimentoAnatel:i_dsTipoAtendimentoAnatel,
		:dsServico:i_dsServico,
		:dsModalidade:i_dsModalidade,
		:dsMotivo:i_dsMotivo,
		:dsSubMotivo:i_dsSubMotivo,
		:dsCategoria:i_dsCategoria,
		:dsSubCategoria:i_dsSubCategoria,
		:nrTelefoneProblema:i_nrTelefoneProblema,
		:idAtendimentoAnatelArquivo:i_idAtendimentoAnatelArquivo,
		:nrCpfCnpjAssinante:i_nrCpfCnpjAssinante,
		:nmAssinante:i_nmAssinante;
		
		Atendimento atendimento;
		atendimento.setIdAtendimentoAnatel( (char*) idAtendimentoAnatel.arr);
		atendimento.setNrSolicitacao( (char*) nrSolicitacao.arr);
		atendimento.setDsTipoAtendimentoAnatel( (char*) dsTipoAtendimentoAnatel.arr);
		atendimento.setDsServico( (char*) dsServico.arr);
		atendimento.setDsModalidade( (char*) dsModalidade.arr);
		atendimento.setDsMotivo( (char*) dsMotivo.arr);
		atendimento.setDsSubMotivo( (char*) dsSubMotivo.arr);
		atendimento.setDsCategoria( (char*) dsCategoria.arr);
		atendimento.setDsSubCategoria( (char*) dsSubCategoria.arr);
		atendimento.setNrTelefoneProblema( (char*) nrTelefoneProblema.arr);
		atendimento.setIdAtendimentoAnatelArquivo( (char*) idAtendimentoAnatelArquivo.arr);
		atendimento.setNrCpfCnpjAssinante( (char*) nrCpfCnpjAssinante.arr);
		atendimento.setNmAssinante( (char*) nmAssinante.arr);
		
		atendimentos.push_back(atendimento);
	}
	
	EXEC SQL CLOSE CURSOR_ATENDIMENTO;
	
	return 1;
	
sqlError:		
		string sRegistroError;
		sRegistroError = "Erro no processamento do registro: ";
		log.logDebug((char *)sRegistroError.data());
		
	    sprintf(this->szTempTrace, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s\n",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); 
		log.logDebug(this->szTempTrace);	
        return 0;		
}

int AtendimentoAnatel::inserirAtendimentoArquivo(TiXmlNode *header, char *idAtendimentoAnatelArquivo, char *nmArquivo) {
	log.logDebug("inicio inserir atendimento anatel arquivo");
			
	EXEC SQL BEGIN DECLARE SECTION;		
		
		const char *data = xmlReader.getNodeValue(header,"data");
		char *cNmArquivo = nmArquivo;
		const char *cdPrestadora = xmlReader.getNodeValue(header,"codPrestadora");
		const char *nmPrestadora = xmlReader.getNodeValue(header,"nomePrestadora");		

		VARCHAR cIdAtendimentoAnatelArquivo[53];
		short i_cIdAtendimentoAnatelArquivo = 0;
		char *sequence;
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;
	
	// inicializar	
	memset(&cIdAtendimentoAnatelArquivo,0,sizeof(cIdAtendimentoAnatelArquivo));
	
	char *dataHeader = (char*) xmlReader.getNodeValue(header,"data");
	char *horaHeader = (char*) xmlReader.getNodeValue(header,"horario");
	
	string dataHora = dataHeader;
	dataHora += " ";
	dataHora += horaHeader;
	
	data = ( const char*) dataHora.c_str();
	
	log.log("data = [%s]", (char*) data);
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
	
	// recuperar sequence
	EXEC SQL
		SELECT atendimento.atendimentoanatelarquivosq.nextval
		  INTO :cIdAtendimentoAnatelArquivo:i_cIdAtendimentoAnatelArquivo
		  FROM dual;
		  
	// copiar para idAtendimentoAnatel
	sprintf(idAtendimentoAnatelArquivo, "%s", (char*) cIdAtendimentoAnatelArquivo.arr);	
	sequence = idAtendimentoAnatelArquivo;
		  
	// inserir anatel arquivo
	EXEC SQL		
	INSERT INTO atendimento.atendimentoanatelarquivo
				(idatendimentoanatelarquivo, nmarquivo,
				 dtenvio, cdprestadora, nmprestadora, idusuarioalteracao, dtultimaalteracao, flstatus
				)
		 VALUES (:sequence, :cNmArquivo,
				 TO_DATE (:data, 'DD/MM/YYYY HH24:MI:SS'), :cdPrestadora, :nmPrestadora , 1, SYSDATE, 0
				);
				
	// atualizar tabela de upload de arquivo
	EXEC SQL
		UPDATE infra.arquivofuncionalidade
		   SET idatendimentoanatelarquivo = :sequence
		 WHERE nmarquivo = :cNmArquivo;
		  	
	
	EXEC SQL COMMIT;	
	
	return 1;
	
	log.logDebug("fim inserir atendimento anatel arquivo");

sqlError:
		EXEC SQL ROLLBACK;
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
		
        return 0;		
	
	log.logDebug("fim inserir atendimento anatel arquivo");
}

int AtendimentoAnatel::inserirAtendimento(TiXmlNode *node, char *idAtendimentoAnatel, char *pIdAtendimentoAnatelArquivo) {
	log.logDebug("inicio inserir atendimento anatel");
	
	TiXmlNode *dadosCliente = node->FirstChild("dadosCliente");
	TiXmlNode *diagnostico = node->FirstChild("diagnostico");
	
	EXEC SQL BEGIN DECLARE SECTION;
		const char *idtSolicitacao = xmlReader.getNodeValue(node,"idtSolicitacao");
		const char *nrProtocolo = xmlReader.getNodeValue(node,"idProtocolo");
		const char *telefoneProblema = xmlReader.getNodeValue(node,"telefoneProblema");
		const char *cpfCnpjAssinante = xmlReader.getNodeValue(node,"cpfCnpjAssinante");
		const char *nomeAssinante = xmlReader.getNodeValue(node,"nomeAssinante");
		const char *dataRegistro = xmlReader.getNodeValue(node,"dataRegistro");
		const char *acao = xmlReader.getNodeValue(node,"acao");
		const char *codigoSituacao = xmlReader.getNodeValue(node,"codigoSituacao");
		const char *nomeSituacao = xmlReader.getNodeValue(node,"nomeSituacao");
		const char *codViaResposta = xmlReader.getNodeValue(node,"codViaResposta");
		const char *viaResposta = xmlReader.getNodeValue(node,"viaResposta");
		const char *descDiagnostico = xmlReader.getNodeValue(node,"descDiagnostico");
		const char *observacaoUsuario = xmlReader.getNodeValue(node,"observacaoUsuario");
		const char *qtdReiteracao = xmlReader.getNodeValue(node,"qtdReiteracao");
		const char *qtdReabertura = xmlReader.getNodeValue(node,"qtdReabertura");
		const char *qtdArquivosAnexo = xmlReader.getNodeValue(node,"qtdArquivosAnexo");		
		const char *nome = xmlReader.getNodeValue(dadosCliente,"nome");
		const char *cpfCnpj = xmlReader.getNodeValue(dadosCliente,"cpfCnpj");
		const char *telefone = xmlReader.getNodeValue(dadosCliente,"telefone");
		const char *endereco = xmlReader.getNodeValue(dadosCliente,"endereco");
		const char *bairro = xmlReader.getNodeValue(dadosCliente,"bairro");
		const char *cidade = xmlReader.getNodeValue(dadosCliente,"cidade");
		const char *estado = xmlReader.getNodeValue(dadosCliente,"estado");
		const char *cep = xmlReader.getNodeValue(dadosCliente,"cep");
		const char *email = xmlReader.getNodeValue(dadosCliente,"email");
		
		const char *dsTipoAtendimentoAnatel = xmlReader.getNodeValue(diagnostico, "tipoAtendimento");
		const char *dsServico = xmlReader.getNodeValue(diagnostico, "servico");
		const char *dsModalidade = xmlReader.getNodeValue(diagnostico, "modalidade");
		const char *dsMotivo = xmlReader.getNodeValue(diagnostico, "motivo");
		const char *dsSubMotivo = xmlReader.getNodeValue(diagnostico, "submotivo");
		const char *dsCategoria = xmlReader.getNodeValue(diagnostico, "categoria");
		const char *dsSubCategoria = xmlReader.getNodeValue(diagnostico, "subcategoria");			

		char *idAtendimentoAnatelArquivo = pIdAtendimentoAnatelArquivo;
		
		char cIdAtendimentoAnatel[53];		
		short i_cIdAtendimentoAnatel = 0;		
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;
	
	// inicializar
	memset(cIdAtendimentoAnatel,0,sizeof(cIdAtendimentoAnatel));	
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
	
	// recuperar sequence
	EXEC SQL
		SELECT atendimento.atendimentoanatelsq.nextval
		  INTO :cIdAtendimentoAnatel:i_cIdAtendimentoAnatel
		  FROM dual;
		  
	// copiar para idAtendimentoAnatel
	sprintf(idAtendimentoAnatel, "%s", cIdAtendimentoAnatel);
	
	// inserir atendimento anatel	
	EXEC SQL 
	INSERT INTO atendimento.atendimentoanatel
				(idatendimentoanatel, nrsolicitacao, idatendimentoanatelarquivo,
				 dstipoatendimentoanatel, dsservico, dsmodalidade, dsmotivo,
			     dssubmotivo, dscategoria, dssubcategoria, nmacao,
				 nrtelefoneproblema, nrcpfcnpjassinante, nmassinante,
				 dtregistro, cdsituacao, dssituacao, cdviaresposta, dsviaresposta,
				 dsdiagnostico, obsusuario, qtreiteracao,
				 qtreabertura, qtarquivosanexo, nmusuario, nrcpfcnpjusuario,
				 nrtelefoneusuario, dsenderecousuario, dsbairrousuario,
				 dscidadeusuario, sgufusuario, nrcepusuario, dsemail,
				 idusuarioalteracao, dtultimaalteracao, nrprotocolo
				)
		 VALUES (:cIdAtendimentoAnatel, :idtSolicitacao, :idAtendimentoAnatelArquivo,
			     :dsTipoAtendimentoAnatel, :dsServico, :dsModalidade, :dsMotivo,
			     :dsSubMotivo, :dsCategoria, :dsSubCategoria, :acao,
				 :telefoneProblema, :cpfCnpjAssinante, :nomeAssinante,
				 TO_DATE (:dataRegistro, 'DD/MM/YYYY HH24:MI:SS'),
				 :codigoSituacao, :nomeSituacao, :codViaResposta, :viaResposta,
				 :descDiagnostico, :observacaoUsuario, :qtdReiteracao,
				 :qtdReabertura, :qtdArquivosAnexo, :nome, :cpfCnpj,
				 :telefone, :endereco, :bairro,
				 :cidade, :estado, :cep, :email,
				 1, sysdate, :nrProtocolo
				);
	
	EXEC SQL COMMIT;	
	
	return 1;
	
	log.logDebug("fim inserir atendimento anatel");

sqlError:

		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
		this->gravarLog("erro oracle ao inserir em atendimentoanatel", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc, 0);
		
        return 0;		
	
	log.logDebug("fim inserir atendimento anatel");
}

int AtendimentoAnatel::inserirDadoComplementar(char *pIdAtendimentoAnatel, TiXmlNode *node) {
	log.logDebug("inicio inserir dados complementares de atendimento anatel");
	
	EXEC SQL BEGIN DECLARE SECTION;
		const char *nrTipoDados = xmlReader.getNodeValue(node,"idtTipoDado");
		const char *dsDados = xmlReader.getNodeValue(node,"descDado");
		const char *nomeTipoDado = xmlReader.getNodeValue(node,"nomeTipoDado");
		char *idAtendimentoAnatel = pIdAtendimentoAnatel;
		
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;	
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
		  
	// inserir anatel arquivo
	EXEC SQL		
	INSERT INTO atendimento.atendimentoanateldados
				(idatendimentoanatel, nrtipodados, dsdados, nmtipodados,
				 idusuarioalteracao, dtultimaalteracao
				)
		 VALUES (:idAtendimentoAnatel, :nrTipoDados, :dsDados, :nomeTipoDado,
				 1, SYSDATE
				);
	
	EXEC SQL COMMIT;	
	
	return 1;
	
	log.logDebug("fim inserir dados complementares de atendimento anatel");

sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
		this->gravarLog("erro oracle ao inserir em atendimentoanateldados", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,1);
				
        return 0;		
	
	log.logDebug("fim inserir dados complementares de atendimento anatel");
}

int AtendimentoAnatel::inserirHistorico(char *pIdAtendimentoAnatel, TiXmlNode *node) {
	log.logDebug("inicio inserir historico de atendimento anatel");
	
	EXEC SQL BEGIN DECLARE SECTION;
		const char *dsDetalhamento = xmlReader.getNodeValue(node,"detalhamento");
		const char *dsEvento = xmlReader.getNodeValue(node,"evento");
		const char *data = NULL;
		char *idAtendimentoAnatel = pIdAtendimentoAnatel;
		
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;	
	
	char *dataHistorico = (char*) xmlReader.getNodeValue(node,"data");
	char *horaHistorico = (char*) xmlReader.getNodeValue(node,"hora");
	
	string dataHora = dataHistorico;
	dataHora += " ";
	dataHora += horaHistorico;
	
	data = ( const char*) dataHora.c_str();
	
	log.log("data = [%s]", (char*) data);
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
		  
	// inserir historico anatel
	EXEC SQL		
	INSERT INTO atendimento.atendimentoanatelhistorico
				(idatendimentoanatel, dsdetalhamento, dsevento, dthistorico
				)
		 VALUES (:idAtendimentoAnatel, :dsDetalhamento, :dsEvento, TO_DATE (:data, 'DD/MM/YYYY HH24:MI:SS')
				);
	
	EXEC SQL COMMIT;	
	
	return 1;
	
	log.logDebug("fim inserir historico de atendimento anatel");

sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
		this->gravarLog("erro oracle ao inserir em atendimentoanatelhistorico", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,1);
        return 0;		
	
	log.logDebug("fim inserir historico de atendimento anatel");
}

int AtendimentoAnatel::inserirAnexo(char *pIdAtendimentoAnatel, char *pDsAnexo) {
	log.logDebug("inicio inserir anexo de atendimento anatel");
	
	EXEC SQL BEGIN DECLARE SECTION;
		char *idAtendimentoAnatel = pIdAtendimentoAnatel;
		char *dsAnexo = pDsAnexo;		
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;	
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
		  
	// inserir anexo com inanexoanatel igual a 1
	EXEC SQL		
	INSERT INTO atendimento.atendimentoanatelanexo
				(idatendimentoanatel, dsanexo, inanexoanatel, inatividade,
				 dtultimaatualizacao
				)
		 VALUES (:idAtendimentoAnatel, :dsAnexo, 1, 0,
				 sysdate
				);
	
	EXEC SQL COMMIT;	
	
	return 1;
	
	log.logDebug("fim inserir anexo de atendimento anatel");

sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
		this->gravarLog("erro oracle ao inserir em atendimentoanatelanexo", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,1);
        return 0;		
	
	log.logDebug("fim inserir anexo de atendimento anatel");
}

int AtendimentoAnatel::inserirAtividade(TiXmlNode *node, char *pIdAtendimentoAnatelAtividade, char *pIdAtendimentoAnatel) {
	log.logDebug("inicio inserir atividade de atendimento anatel");
	
	EXEC SQL BEGIN DECLARE SECTION;
		const char *nrAtividade = xmlReader.getNodeValue(node,"numAtividade");
		const char *sgSolicitante = xmlReader.getNodeValue(node,"siglaSolicitante");
		const char *orgaoSolicitante = xmlReader.getNodeValue(node,"orgaoSolicitante");
		const char *usuarioSolicitante = xmlReader.getNodeValue(node,"usuarioSolicitante");
		const char *descricao = xmlReader.getNodeValue(node,"descricao");
		const char *dtEstimada = xmlReader.getNodeValue(node,"dataEstimada");
		const char *dtInicial = xmlReader.getNodeValue(node,"dataInicial");
		
		char *idAtendimentoAnatel = pIdAtendimentoAnatel;
		
		char idAtendimentoAnatelAtividade[53];
		short i_idAtendimentoAnatelAtividade = 0;
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;	
	
	// inicializar variável
	memset(idAtendimentoAnatelAtividade, 0, sizeof(idAtendimentoAnatelAtividade));
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
	
	EXEC SQL 
		SELECT atendimento.atdanatelatividadesq.nextval
		  INTO :idAtendimentoAnatelAtividade:i_idAtendimentoAnatelAtividade
		  FROM dual;
	
	// copiar para pametro de entrada
	sprintf(pIdAtendimentoAnatelAtividade, "%s", idAtendimentoAnatelAtividade);
		  
	// inserir atividade
	EXEC SQL		
	INSERT INTO atendimento.atendimentoanatelatividade
				(idatendimentoanatelatv, idatendimentoanatel , nratividade, sgsolicitante,
				 orgaosolicitante, usuariosolicitante, descricao,
				 dtestimada, dtinicial, idusuarioalteracao,
				 dtultimaatualizacao
				)
		 VALUES (:idAtendimentoAnatelAtividade, :idAtendimentoAnatel, :nrAtividade, :sgSolicitante,
				 :orgaoSolicitante, :usuarioSolicitante, :descricao,
				 TO_DATE(:dtEstimada,'DD/MM/YYYY'), TO_DATE(:dtInicial,'DD/MM/YYYY'), 1,
				 sysdate
				);
	
	EXEC SQL COMMIT;	
	
	return 1;
	
	log.logDebug("fim inserir atividade de atendimento anatel");

sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
		this->gravarLog("erro oracle ao inserir em atendimentoanatelatividade", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,1);	
        return 0;		
	
	log.logDebug("fim inserir atividade de atendimento anatel");
}

int AtendimentoAnatel::inserirAtividadeAnexo(char *pIdAtendimentoAnatelAtividade, char *pDsAnexo) {
	log.logDebug("inicio inserir atividade anexo de atendimento anatel");
	
	EXEC SQL BEGIN DECLARE SECTION;
		char *idAtendimentoAnatelAtividade = pIdAtendimentoAnatelAtividade;
		char *dsAnexo = pDsAnexo;
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;	
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
		  
	// inserir anexo da atividade
	EXEC SQL		
	INSERT INTO atendimento.atendimentoanatelatvanexo
				(idatendimentoanatelatv, dsanexo, 
				 idusuarioalteracao, dtultimaatualizacao
				)
		 VALUES (:idAtendimentoAnatelAtividade, :dsAnexo,
				1, sysdate
				);
	
	EXEC SQL COMMIT;	
	
	return 1;
	
	log.logDebug("fim inserir atividade anexo de atendimento anatel");

sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
		this->gravarLog("erro oracle ao inserir em atendimentoanatelatvanexo", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,1);	
        return 0;		
	
	log.logDebug("fim inserir atividade anexo de atendimento anatel");
}

int AtendimentoAnatel::atualizarAtendimento(char *pIdAtendimentoAnatel, char *pIdAtendimento) {
	log.logDebug("inicio atualizar tabela de atendimentoanatel com idatendimento");
	
	EXEC SQL BEGIN DECLARE SECTION;
		char *idAtendimento = pIdAtendimento;
		char *idAtendimentoAnatel =  pIdAtendimentoAnatel;
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;	
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
		  
	// atualizar o idatendimento
	EXEC SQL		
		update atendimento.atendimentoanatel
		   set idatendimento = :idAtendimento
	     where idatendimentoanatel = :idAtendimentoAnatel;
	EXEC SQL	 
		 update atendimento.atendimento
		    set idatendimentoanatel = :idAtendimentoAnatel
		  where idatendimento = :idAtendimento;
	EXEC SQL	  
		 update atendimento.atendimentopriorizacao
		    set idatendimentoanatel = :idAtendimentoAnatel
		  where idatendimento = :idAtendimento;
	
	EXEC SQL COMMIT;	
	
	return 1;
	
	log.logDebug("fim atualizar tabela de atendimentoanatel com idatendimento");

sqlError:
		string sRegistroError;
		sRegistroError = "Erro no processamento do registro: ";
		log.logDebug((char *)sRegistroError.data());
		EXEC SQL ROLLBACK;
	    sprintf(this->szTempTrace, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s\n",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); 
		log.logDebug(this->szTempTrace);	
        return 0;		
	
	log.logDebug("fim atualizar tabela de atendimentoanatel com idatendimento");
}

int AtendimentoAnatel::verificaSolicitacaoDuplicada(TiXmlNode *node) {
	log.logDebug("inicio verificar se existe a solicitação");
	
	EXEC SQL BEGIN DECLARE SECTION;
		VARCHAR count[256];
		short i_count = 0;
		const char *idtSolicitacao = xmlReader.getNodeValue(node,"idtSolicitacao");
		const char *dataRegistro = xmlReader.getNodeValue(node,"dataRegistro");
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;	
	
	memset(&count,0,sizeof(count));
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
	EXEC SQL
		 SELECT COUNT (1) as count
		   INTO :count:i_count
		   FROM atendimento.atendimentoanatel
		  WHERE nrsolicitacao = :idtSolicitacao
		    AND dtRegistro = to_date(:dataRegistro, 'DD/MM/YYYY HH24:MI:SS');
		 
		 log.logDebug((char*) count.arr);
		 
		 if (strcmp((char*)count.arr,"0") == 0) {
			log.logDebug("não achou a solicitacao");
			return 0;
		 } 
	
	log.logDebug("fim verificar se existe a solicitação");
	return 1;
sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);	
		this->gravarLog("registro duplicado em atendimento.atendimentoanatel", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc,1);		
        return 0;	
}

int AtendimentoAnatel::relatorioSolicitacaoRejeitada(char *idAtendimentoAnatelArquivo) {
	log.logDebug("inicio contabilizar solicitação rejeitada");
	
	EXEC SQL BEGIN DECLARE SECTION;
		char *pidAtendimentoAnatelArquivo = idAtendimentoAnatelArquivo;
		char *idAtendimento;
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;	
	
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
	 EXEC SQL
		UPDATE atendimento.atendimentoanatelarquivo
		   SET atendimentoanatelarquivo.qtrejeitado =
										(SELECT (TO_NUMBER(NVL (a.qtrejeitado, 0)) + 1)
										   FROM atendimento.atendimentoanatelarquivo a
										  WHERE a.idatendimentoanatelarquivo = :pidAtendimentoAnatelArquivo)
		 WHERE atendimentoanatelarquivo.idatendimentoanatelarquivo = :pidAtendimentoAnatelArquivo;
	  
	  EXEC SQL COMMIT;	
		
	
	log.logDebug("fim contabilizar solicitação rejeitada");
	return 1;
sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);				
        return 0;	
}

int AtendimentoAnatel::relatorioTotalRegistros(char *idAtendimentoAnatelArquivo) {
	log.logDebug("inicio contabilizar total de registros");
	
	EXEC SQL BEGIN DECLARE SECTION;
		char *pidAtendimentoAnatelArquivo = idAtendimentoAnatelArquivo;		
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;		
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;	   
	 EXEC SQL
		UPDATE atendimento.atendimentoanatelarquivo
		   SET atendimentoanatelarquivo.qttotalregistros=
										(SELECT (TO_NUMBER(NVL (a.qttotalregistros, 0)) + 1)
										   FROM atendimento.atendimentoanatelarquivo a
										  WHERE a.idatendimentoanatelarquivo = :pidAtendimentoAnatelArquivo)
		 WHERE atendimentoanatelarquivo.idatendimentoanatelarquivo = :pidAtendimentoAnatelArquivo;
	  
	  EXEC SQL COMMIT;	
		
	
	log.logDebug("fim contabilizar total de registros");
	return 1;
sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);			
        return 0;	
}

int AtendimentoAnatel::relatorioProtocoloCliente(char *idAtendimentoAnatelArquivo) {
	log.logDebug("inicio contabilizar total de protocolos abertos por cliente");
	
	EXEC SQL BEGIN DECLARE SECTION;
		char *pidAtendimentoAnatelArquivo = idAtendimentoAnatelArquivo;		
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;		
	
	log.log("idAtendimentoAnatelArquivo = %s", idAtendimentoAnatelArquivo);
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;	   
	 EXEC SQL
		UPDATE atendimento.atendimentoanatelarquivo
		   SET atendimentoanatelarquivo.qtprotocolocliente=
										(SELECT (TO_NUMBER(NVL (a.qtprotocolocliente, 0)) + 1)
										   FROM atendimento.atendimentoanatelarquivo a
										  WHERE a.idatendimentoanatelarquivo = :pidAtendimentoAnatelArquivo)
		 WHERE atendimentoanatelarquivo.idatendimentoanatelarquivo = :pidAtendimentoAnatelArquivo;
	  
	  EXEC SQL COMMIT;	
		
	
	log.logDebug("fim contabilizar total de protocolos abertos por cliente");
	return 1;
sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);			
        return 0;	
}

int AtendimentoAnatel::relatorioProtocoloNaoCliente(char *idAtendimentoAnatelArquivo) {
	log.logDebug("inicio contabilizar total de protocolos abertos por não cliente");
	
	EXEC SQL BEGIN DECLARE SECTION;
		char *pidAtendimentoAnatelArquivo = idAtendimentoAnatelArquivo;		
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;		
	
	log.log("idAtendimentoAnatelArquivo = %s", idAtendimentoAnatelArquivo);
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;	   
	 EXEC SQL
		UPDATE atendimento.atendimentoanatelarquivo
		   SET atendimentoanatelarquivo.qtprotocolonaocliente=
										(SELECT (TO_NUMBER(NVL (a.qtprotocolonaocliente, 0)) + 1)
										   FROM atendimento.atendimentoanatelarquivo a
										  WHERE a.idatendimentoanatelarquivo = :pidAtendimentoAnatelArquivo)
		 WHERE atendimentoanatelarquivo.idatendimentoanatelarquivo = :pidAtendimentoAnatelArquivo;
	  
	  EXEC SQL COMMIT;	
		
	
	log.logDebug("fim contabilizar total de protocolos abertos por não cliente");
	return 1;
sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);			
        return 0;	
}

int AtendimentoAnatel::relatorioContatoGenerico(char *idAtendimentoAnatelArquivo) {
	log.logDebug("inicio contabilizar contatos genericos");
	
	EXEC SQL BEGIN DECLARE SECTION;
		char *pidAtendimentoAnatelArquivo = idAtendimentoAnatelArquivo;		
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;		
	
	log.log("idAtendimentoAnatelArquivo = %s", idAtendimentoAnatelArquivo);
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;	   
	 EXEC SQL
		UPDATE atendimento.atendimentoanatelarquivo
		   SET atendimentoanatelarquivo.qtcontatogenerico=
										(SELECT (TO_NUMBER(NVL (a.qtcontatogenerico, 0)) + 1)
										   FROM atendimento.atendimentoanatelarquivo a
										  WHERE a.idatendimentoanatelarquivo = :pidAtendimentoAnatelArquivo)
		 WHERE atendimentoanatelarquivo.idatendimentoanatelarquivo = :pidAtendimentoAnatelArquivo;
	  
	  EXEC SQL COMMIT;	
		
	
	log.logDebug("fim contabilizar contatos genericos");
	return 1;
sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);			
        return 0;	
}


int AtendimentoAnatel::atualizarArquivoLog(char *nome, char *idAtendimentoAnatelArquivo) {
	log.logDebug("inicio atualizar arquivo de log de histórico na tabela atendimentoanatelarquivo");
	
	EXEC SQL BEGIN DECLARE SECTION;
		char *pidAtendimentoAnatelArquivo = idAtendimentoAnatelArquivo;		
		char *dsArquivoLog = nome;
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;		
	
	log.log("idAtendimentoAnatelArquivo = %s, nome = %s", idAtendimentoAnatelArquivo, nome);
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;	   
	 EXEC SQL
		UPDATE atendimento.atendimentoanatelarquivo
		   SET atendimentoanatelarquivo.dsarquivolog = :dsArquivoLog
		 WHERE atendimentoanatelarquivo.idatendimentoanatelarquivo = :pidAtendimentoAnatelArquivo;
	  
	  EXEC SQL COMMIT;	
		
	
	log.logDebug("fim atualizar arquivo de log de histórico na tabela atendimentoanatelarquivo");
	return 1;
sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);			
        return 0;	
}

int AtendimentoAnatel::atualizarStatusArquivo(char *nome, int status) {
	log.logDebug("inicio atualizar status de processamento de carga do arquivo");
	
	EXEC SQL BEGIN DECLARE SECTION;
		char *pnome = nome;		
		int flStatus = status;
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;		
	
	log.log("nome = %s, status = %d", nome, status);
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;	   
	 EXEC SQL
		UPDATE atendimento.atendimentoanatelarquivo
		   SET atendimentoanatelarquivo.flstatus = :flStatus
		 WHERE atendimentoanatelarquivo.nmarquivo = :pnome
		   AND rownum = 1;
	  
	  EXEC SQL COMMIT;	
		
	
	log.logDebug("fim atualizar status de processamento de carga do arquivo");
	return 1;
sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);			
        return 0;	
}

int AtendimentoAnatel::relatorioContatoNovo(char *idAtendimentoAnatelArquivo) {
	log.logDebug("inicio contabilizar contatos novos");
	
	EXEC SQL BEGIN DECLARE SECTION;
		char *pidAtendimentoAnatelArquivo = idAtendimentoAnatelArquivo;		
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;		
	
	log.log("idAtendimentoAnatelArquivo = %s", idAtendimentoAnatelArquivo);
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;	   
	 EXEC SQL
		UPDATE atendimento.atendimentoanatelarquivo
		   SET atendimentoanatelarquivo.qtcontatonovo=
										(SELECT (TO_NUMBER(NVL (a.qtcontatonovo, 0)) + 1)
										   FROM atendimento.atendimentoanatelarquivo a
										  WHERE a.idatendimentoanatelarquivo = :pidAtendimentoAnatelArquivo)
		 WHERE atendimentoanatelarquivo.idatendimentoanatelarquivo = :pidAtendimentoAnatelArquivo;
	  
	  EXEC SQL COMMIT;	
		
	
	log.logDebug("fim contabilizar contatos novos");
	return 1;
sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);			
        return 0;	
}
int AtendimentoAnatel::getContatoFuncionalidade(char *funcionalidade, char *pidContato) {
	log.logDebug("inicio recuperar um idContato da contatofuncionalidade");
	
	EXEC SQL BEGIN DECLARE SECTION;		
		char* cdFuncionalidade = funcionalidade;
		
		VARCHAR idContato[256];
		short i_idContato = 0;
		
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;	
		
	log.log("cdFuncionalidade = %s", cdFuncionalidade);
	
	memset(&idContato,0,sizeof(idContato));
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
	EXEC SQL
		SELECT idcontato
		  INTO :idContato:i_idContato
		  FROM contatoadm.contatofuncionalidade
		 WHERE cdfuncionalidade = :cdFuncionalidade;
		 
		 if (strlen((char*)idContato.arr) == 0) {
			log.logDebug("parametro não encontrado");		
			return 0;
		 } else {			
			strcpy(pidContato, (char*) idContato.arr);
			log.log("parametro encontrado valor = [%s]", pidContato);
		 }
	
	return 1;
sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);		
        return 0;
}

char* AtendimentoAnatel::getParametro(char *parametro) {
	log.logDebug("inicio verificar se documento existe");
	
	EXEC SQL BEGIN DECLARE SECTION;		
		char* cdParametro = parametro;
		
		VARCHAR pdsValorParametro[256];
		short i_pdsValorParametro = 0;
		
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;	
		
	log.log("cdParametro = %s", cdParametro);
	
	memset(&pdsValorParametro,0,sizeof(pdsValorParametro));
	memset(this->dsValorParametro,0,sizeof(this->dsValorParametro));
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
	EXEC SQL
		SELECT dsvalorparametro
		  INTO :pdsValorParametro:i_pdsValorParametro
		  FROM apoio.parametro
		 WHERE cdparametro = :cdParametro;	 
		 
		 if (strlen((char*)pdsValorParametro.arr) == 0) {
			log.logDebug("parametro não encontrado");			
		 } else {			
			strcpy(this->dsValorParametro, (char*) pdsValorParametro.arr);
			log.log("parametro encontrado valor = [%s]", this->dsValorParametro);
		 }
	
	return this->dsValorParametro;
sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);		
        return this->dsValorParametro;	
}

int AtendimentoAnatel::verificaDocumentoExistente(Atendimento &atendimento, char *pidPessoa) {
	log.logDebug("inicio verificar se documento existe");
	
	EXEC SQL BEGIN DECLARE SECTION;		
		char* nrDocumento = atendimento.getNrCpfCnpjAssinante();
		char* nmNome = atendimento.getNmAssinante();
		
		VARCHAR idPessoa[256];
		short i_idPessoa = 0;
		
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;	
	
	log.log("nrDocumento = %s", nrDocumento);
	log.log("nmNome = %s", nmNome);
	
	memset(&idPessoa,0,sizeof(idPessoa));
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
	EXEC SQL
		SELECT p.idpessoa
		  INTO :idPessoa:i_idPessoa
		  FROM customer.documento d, customer.pessoa p, customer.pessoadocumento pd
		 WHERE d.nrdocumento = :nrDocumento
		   AND pd.idpessoa = p.idpessoa
		   AND pd.iddocumento = d.iddocumento
		   AND p.nmpessoa = :nmNome;		 
		 
		 if (strlen((char*)idPessoa.arr) == 0) {
			log.logDebug("cliente não encontrado");
			return 0;
		 } else {
			log.logDebug("cliente encontrado");
			strcpy(pidPessoa, (char*) idPessoa.arr);
		 }
	
	return 1;
sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);			
        return 0;	
}

int AtendimentoAnatel::verificaLinhaExistente(char *nrLinha, char *ddd, char *pidLinhaTelefonica, 
									char *pidTipoLinha, char *pidPessoa, char *psgTipoPessoa, 
									char *pidConta, char *pidPessoadepara) {
	log.logDebug("inicio verificar se existe a linha");
	
	EXEC SQL BEGIN DECLARE SECTION;
		char *pDdd = ddd;
		char *pNrLinha = nrLinha;
		
		VARCHAR idLinhaTelefonica[256];
		VARCHAR idTipoLinha[256];
		VARCHAR idPessoa[256];
		VARCHAR sgTipoPessoa[256];
		VARCHAR idConta[256];
		VARCHAR idPessoadepara[256];
		
		short i_idLinhaTelefonica = 0;
		short i_idTipoLinha = 0;
		short i_idPessoa = 0;
		short i_sgTipoPessoa = 0;
		short i_idConta = 0;
		short i_idPessoadepara = 0;
		
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;	
	
	memset(&idLinhaTelefonica,0,sizeof(idLinhaTelefonica));
	memset(&idTipoLinha,0,sizeof(idTipoLinha));
	memset(&idPessoa,0,sizeof(idPessoa));
	memset(&sgTipoPessoa,0,sizeof(sgTipoPessoa));
	memset(&idConta,0,sizeof(idConta));
	memset(&idPessoadepara,0,sizeof(idPessoadepara));
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
	EXEC SQL
		SELECT lt.idlinhatelefonica, pdp.idpessoa, lt.idtipolinha, 
				tp.SGTIPOPESSOA, lc.IDCONTA, pdp.idpessoadepara
		  INTO :idLinhaTelefonica:i_idLinhaTelefonica,
			   :idPessoa:i_idPessoa,
			   :idTipoLinha:i_idTipoLinha,
			   :sgTipoPessoa:i_sgTipoPessoa,
			   :idConta:i_idConta,
			   :idPessoadepara:i_idPessoadepara
		  FROM linha.linhabase lb,
			   linha.linhatelefonica lt,
			   apoio.arearegistro ar,
			   customer.pessoalinha pl,
			   customer.pessoadepara pdp,
			   customer.pessoa p,
			   apoio.tipopessoa tp,
			   customer.linhaconta lc,
			   customer.pessoaconta pc
		 WHERE lb.nrlinha = :pNrLinha
		   AND ar.cdarearegistro = :pDdd
		   AND lb.idarearegistro = ar.idarearegistro
		   AND lt.idlinhabase = lb.idlinhabase
		   AND pl.idlinhatelefonica = lt.idlinhatelefonica
		   AND pl.idpessoadepara = pdp.idpessoadepara
		   AND pl.idtiporelacionamento = 2
		   AND pdp.idpessoa = p.idpessoa
		   AND p.idtipopessoa = tp.idtipopessoa
		   AND lt.IDLINHATELEFONICA = lc.IDLINHATELEFONICA
		   AND pc.IDPESSOADEPARA = pdp.IDPESSOADEPARA
		   AND ROWNUM = 1;		   
		 
		 log.log("idLinhaTelefonica = %s, idPessoa = %s, idTipoLinha = %s, sgTipoPessoa = %s, idConta = %s, idPessoadepara = %s",
				(char*) idLinhaTelefonica.arr, (char*) idPessoa.arr, (char*) idTipoLinha.arr, 
				(char*) sgTipoPessoa.arr, (char*) idConta.arr, (char*) idPessoadepara.arr);
		 
		 if (strlen((char*)idLinhaTelefonica.arr) == 0) {
			log.logDebug("cliente não encontrado");
			return 0;
		 } else {
			log.logDebug("cliente encontrado");
			strcpy(pidLinhaTelefonica, (char*) idLinhaTelefonica.arr);
			strcpy(pidTipoLinha, (char*) idTipoLinha.arr);
			strcpy(pidPessoa, (char*) idPessoa.arr);
			strcpy(psgTipoPessoa, (char*) sgTipoPessoa.arr);
			strcpy(pidConta, (char*) idConta.arr);
			strcpy(pidPessoadepara, (char*) idPessoadepara.arr);
		 }
	
	return 1;
sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);			
        return 0;	
}

int AtendimentoAnatel::getUFOperadora(char *pidLinhaTelefonica, char *pidPessoa, char *idUfOperadora) {
	log.logDebug("inicio recuperar informação de idufoperadora");
	
	EXEC SQL BEGIN DECLARE SECTION;		
		char *idLinhaTelefonica = pidLinhaTelefonica;
		char *idPessoa = pidPessoa;
		
		VARCHAR operadora[256];
		short i_operadora = 0;
		
	EXEC SQL END DECLARE SECTION;
	struct sqlca sqlca;	
	
	memset(&operadora, 0, sizeof(operadora));
	log.log("idLinhaTelefonica = %s", idLinhaTelefonica);
	log.log("idPessoa = %s", idPessoa);
	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
	if (strlen(idLinhaTelefonica) > 0) {
		EXEC SQL
		SELECT ar.idufoperadora
		  INTO :operadora:i_operadora
		  FROM linha.linhabase lb, linha.linhatelefonica lt, apoio.arearegistro ar
		 WHERE lb.idlinhabase = lt.idlinhabase
		   AND lb.idarearegistro = ar.idarearegistro
		   AND lt.idlinhatelefonica = :idLinhaTelefonica;
	} else {
		EXEC SQL
		SELECT ufo.idufoperadora
		  INTO :operadora:i_operadora
		  FROM customer.pessoa p, 
		       customer.ufoperadora ufo
		 WHERE p.iduf = ufo.iduf 
		   AND p.idpessoa = :idPessoa;
	}
 
	if (strlen((char*) operadora.arr) > 0) {
		log.log("operadora = %s", (char*) operadora.arr);
		strcpy(idUfOperadora, (char*) operadora.arr);
	}
	
	return 1;
sqlError:
		log.log( "ERRO ORACLE : sqlcode = [%d],sqlerrmc = [%.70s]",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc);			
        return 0;	
}

void AtendimentoAnatel::setHistorico(Historico *historico) {
	log.logInformation("inicio settar historico");
	this->historico = historico;
}

Historico* AtendimentoAnatel::getHistorico() {
	log.logInformation("inicio recuperar historico");
	return this->historico;
}

void AtendimentoAnatel::setIdtSolicitacao(char *idtSolicitacao) {
	if (idtSolicitacao != NULL) {
		strcpy(this->idtSolicitacao, idtSolicitacao);
	}
}

void AtendimentoAnatel::setDataRegistro(char *dataRegistro) {
	if (dataRegistro != NULL) {
		strcpy(this->dataRegistro, dataRegistro);
	}
}

void AtendimentoAnatel::setTelefoneProblema(char *telefoneProblema) {
	if (telefoneProblema != NULL) {
		strcpy(this->telefoneProblema, telefoneProblema);
	}
}

char* AtendimentoAnatel::getIdtSolicitacao() {
	return this->idtSolicitacao;
}

char* AtendimentoAnatel::getDataRegistro() {
	return this->dataRegistro;
}

char* AtendimentoAnatel::getTelefoneProblema() {
	return this->telefoneProblema;
}

void AtendimentoAnatel::gravarLog(char *mensagem, long sqlcode, char *sqlerrmc, int inGravado) {
	log.logInformation("inicio gravar log de histórico");
	if (sqlerrmc != NULL) {
	    int size = strlen(sqlerrmc);
		for (int i = 0; i < size; i++) {
			if (sqlerrmc[i] == '\n') {
				sqlerrmc[i] = '\0';
			}
		}
	}
	if (this->historico != NULL) {
		this->historico->appendText("%s|%s|%s|%d|%s[%d][%.70s]", idtSolicitacao, 
				dataRegistro, telefoneProblema, inGravado, mensagem,sqlcode,sqlerrmc);
	}
	log.logInformation("final gravar log de histórico");
}

void AtendimentoAnatel::gravarLog(char *mensagem, Atendimento &atendimento) {
	log.logInformation("inicio gravar log de histórico ");
	if (this->historico != NULL) {
		this->historico->appendText("%s|%s|%s|%d|%s", atendimento.getNrSolicitacao(),"", atendimento.getNrTelefoneProblema(), 1, mensagem);
	}
	log.logInformation("final gravar log de histórico");
}

char* AtendimentoAnatel::getIdAnatelSistemaOrigem() {
	return this->idAnatelSistemaOrigem;
}

char* AtendimentoAnatel::getIdAnatelGrupoAbertura() {
	return this->idAnatelGrupoAbertura;
}

char* AtendimentoAnatel::getIdAnatelResponsavelAbertura() {
	return this->idAnatelResponsavelAbertura;
}

char* AtendimentoAnatel::getIdAnatelObservacao() {
	return this->idAnatelObservacao;
}

char* AtendimentoAnatel::getIdAnatelTipoOperacao() {
	return this->idAnatelTipoOperacao;
}

char* AtendimentoAnatel::getIdAnatelProcedencia() {
	return this->idAnatelProcedencia;
}

char* AtendimentoAnatel::getIdAnatelCanal() {
	return this->idAnatelCanal;
}

char* AtendimentoAnatel::getIdAnatelUsuario() {
	return this->idAnatelUsuario;
}

void AtendimentoAnatel::setIdAnatelSistemaOrigem(char *idAnatelSistemaOrigem) {
	if (idAnatelSistemaOrigem != NULL) {
		strcpy(this->idAnatelSistemaOrigem, idAnatelSistemaOrigem);
	}
}

void AtendimentoAnatel::setIdAnatelGrupoAbertura(char *idAnatelGrupoAbertura) {
	if (idAnatelGrupoAbertura != NULL) {
		strcpy(this->idAnatelGrupoAbertura, idAnatelGrupoAbertura);
	}
}

void AtendimentoAnatel::setIdAnatelResponsavelAbertura(char *idAnatelResponsavelAbertura) {
	if (idAnatelResponsavelAbertura != NULL) {
		strcpy(this->idAnatelResponsavelAbertura, idAnatelResponsavelAbertura);
	}
}
void AtendimentoAnatel::setIdAnatelObservacao(char *idAnatelObservacao) {
	if (idAnatelObservacao != NULL) {
		strcpy(this->idAnatelObservacao, idAnatelObservacao);
	}
}

void AtendimentoAnatel::setIdAnatelTipoOperacao(char *idAnatelTipoOperacao) {
	if (idAnatelTipoOperacao != NULL) {
		strcpy(this->idAnatelTipoOperacao, idAnatelTipoOperacao);
	}
}

void AtendimentoAnatel::setIdAnatelProcedencia(char *idAnatelProcedencia) {
	if (idAnatelProcedencia != NULL) {
		strcpy(this->idAnatelProcedencia, idAnatelProcedencia);
	}
}

void AtendimentoAnatel::setIdAnatelCanal(char *idAnatelCanal) {
	if (idAnatelCanal != NULL) {
		strcpy(this->idAnatelCanal, idAnatelCanal);
	}
}

void AtendimentoAnatel::setIdAnatelUsuario(char *idAnatelUsuario) {
	if (idAnatelUsuario != NULL) {
		strcpy(this->idAnatelUsuario, idAnatelUsuario);
	}
}

int AtendimentoAnatel::connect(char *user, char *password, char *sid) {
	log.logInformation("inicio conectar ao oracle");
	int retorno = 0;
	EXEC SQL BEGIN DECLARE SECTION;
        char connString[256];
    EXEC SQL END DECLARE SECTION;
	
	// montar string de conexão
	sprintf(connString, "%s/%s@%s", user, password, sid);
	
	// tratar erro
	EXEC SQL WHENEVER SQLERROR GOTO errConn;
	
	// conectar no banco
	EXEC SQL CONNECT :connString;
	retorno = sqlca.sqlcode;
	
	log.logDebug("fim conectar ao oracle");
	return retorno;
	
errConn:
    log.logInformation("erro ao conectar no oracle");
	return -1;
}

void AtendimentoAnatel::disconnect(void)
{
    log.logInformation("inicio desconectar no oracle");

    EXEC SQL WHENEVER SQLERROR GOTO DBDisconnectError;
    EXEC SQL COMMIT WORK RELEASE;

    log.logInformation("desconectado com sucesso.");
    return;

DBDisconnectError:
    sprintf(szTempTrace, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); 
	log.logDebug(szTempTrace);
}