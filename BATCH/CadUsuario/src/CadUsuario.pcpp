

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <ctype.h>
#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>

#include <tuxfw.h>
#include <sys/shm.h>

#include <CadUsuario.h>

#include "../../commons/Propriedade/include/MFile.h"
#include "../../commons/Log/include/Log.h"
#include "../../commons/SplitLine.h"
#include "../../commons/Defines.h"

extern errno;

#include <string>
#include <list>
#include <iterator>
using namespace std;
typedef list<long> ListGrupo;
typedef list<long> ListPerfil;
typedef list<long> ListOperadora;


EXEC SQL INCLUDE SQLCA;

#define SAFE_STRNCPY(dst,src) strncpy(dst,src?src:"",sizeof(dst)-1);dst[sizeof(dst)-1]=0;

#define CONVIND(O,I) \
{\
    if (I == -1) { \
        ##O.arr[0]=0; \
    } else { \
        ##O.arr[##O.len]=0; \
    } \
}

#define MSG_NOME_VAZIO             "*** Nome do Usuario vazio ***"
#define MSG_UF_VAZIO               "*** UF do Usuario vazio ***"
#define MSG_UF_INVALID             "*** UF Nao encontrado na base ***"
#define MSG_PAISCPF_VAZIO          "*** PAIS do CPF vazio ***"
#define MSG_PAISCPF_INVALID        "*** PAIS do CPF nao encontrado no banco ***"
#define MSG_EMAIL_VAZIO            "*** E-Mail do Usuario vazio ***"
#define MSG_EMAIL_INVALID          "*** E-Mail invalido ***"
#define MSG_LOGIN_VAZIO            "*** LOGIN do Usuario vazio ***"
#define MSG_LOGIN_TAM_INVALID      "*** LOGIN deve ter no minimo 6 e no maximo 9 caracteres ***"
#define MSG_LOGIN_INVALID          "*** LOGIN ja existe na base ***"
#define MSG_REGIONAL_VAZIO         "*** REGIONAL do Usuario vazio ***"
#define MSG_REGIONAL_INVALID       "*** REGIONAL do Usuario nao encontrado no banco ***"
#define MSG_HIERARQUIA_VAZIO       "*** HIERARQUIA do Usuario vazio ***"
#define MSG_HIERARQUIA_INVALID     "*** HIERARQUIA do Usuario nao encontrado no banco ***"
#define MSG_CARGO_VAZIO            "*** CARGO do Usuario vazio ***"
#define MSG_CARGO_INVALID          "*** CARGO do Usuario nao encontrado no banco ***"
#define MSG_ORGANIZACAO_VAZIO      "*** ORGANIZACAO do Usuario vazio ***"
#define MSG_ORGANIZACAO_INVALID    "*** ORGANIZACAO do Usuario nao encontrado no banco ***"
#define MSG_DEPARTAMENTO_VAZIO     "*** DEPARTAMENTO do Usuario vazio ***"
#define MSG_DEPARTAMENTO_INVALID   "*** DEPARTAMENTO do Usuario nao encontrado no banco ***"
#define MSG_PERFIL_VAZIO           "*** PERFIL do usuario vazio ***"
#define MSG_PERFIL_INVALID         "*** PERFIL do usuario nao encontrado no banco ***"
#define MSG_FORNECEDOR_INVALID     "*** FORNECEDOR do usuario nao encontrado no banco ***"
#define MSG_SITE_INVALID           "*** SITE do usuario nao encontrado no banco ***"
#define MSG_LOGINSUP_VAZIO         "*** LOGIN SUPERIOR IMEDIATO do usuario vazio ***"
#define MSG_LOGINSUP_INVALID       "*** LOGIN SUPERIOR IMEDIATO nao encontrado no banco ***"
#define MSG_LOGINSUP_TAM_INVALID   "*** LOGIN SUPERIOR IMEDIATO deve ter no minimo 6 e no maximo 9 caracteres ***"
#define MSG_CPF_VAZIO              "*** CPF do usuario vazio ***"
#define MSG_CPF_INVALID            "*** CPF do usuario ja existe na base ***"
#define MSG_UFCPF_VAZIO            "*** UF - CPF do usuario vazio ***"
#define MSG_UFCPF_INVALID          "*** UF - CPF do usuario nao encontrado no banco ***"
#define MSG_GRUPO_INVALID          "*** GRUPO para associacao nao encontrado na base ***"
#define MSG_PERFILASSOC_INVALID    "*** PERFIL para associacao nao encontrado na base ***"
#define MSG_OPERADORA_INVALID      "*** OPERADORA para associacao nao encontrado na base ***"
#define MSG_REG_INVALID            "*** Registro em formato invalido ***"


#define LEN_NOME          255
#define LEN_EOS             1
#define LEN_NOME_PRIMEIRO LEN_NOME
#define LEN_NOME_MEIO     LEN_NOME
#define LEN_NOME_FIM      LEN_NOME
typedef struct {
    char szNomeCompleto[LEN_NOME + LEN_EOS];
    char szNomePrimeiro[LEN_NOME_PRIMEIRO + LEN_EOS];
    char szNomeMeio[LEN_NOME_MEIO + LEN_EOS];
    char szNomeFim[LEN_NOME_FIM + LEN_EOS];
} TDesmembraNome;


char szAux[256000 + 1];
Log oLog;
long iErrorNumber=0;

//==============================================================================
// Protótipos
void TrataRegistro( char * registro );
void TrataBuffer( char * registro );
int ProcessaRegistro( ofstream & output, char * registroPrm, long * LinhasLidas, long * LinhasRejeitadas );
bool ValidaUF( char * buffer, char * idUFPrm );
bool ValidaPais( char * buffer, char * idPaisPrm );
bool ValidaEMail( char * bf );
int ValidaLogin( char * buffer );
int ValidaLoginSup( char * buffer );
bool ValidaRegional( char * buffer, char * idUFOperadrm );
bool ValidaHierarquia( char * buffer, char * idNivelPrm, char * idNivelPaiPrm );
bool ValidaCargo( char * buffer, char * idNivelPrm, char * idCargoPrm );
bool ValidaOrganizacao( char * buffer, char * idOrganizacaoPaiPrm, char * idOrganizacaoPrm, char * idTipoOrganizacaoPrm );
bool ValidaDepartamento( char * buffer, char * idOrganizacaoPrm,char * idDeptoPrm );
bool ValidaPerfil( char * buffer, char * idPerfilPrm );
bool ValidaFornecedor( char * buffer, char * idFornecedorPrm );
bool ValidaSite( char * buffer, char * idSitePrm );
bool ValidaCPF( char * buffer );
bool ValidaGrupo( char * buffer, list<long> &listaGrupos );
bool ValidaPerfilAssoc( char * buffer, list<long> &listaPerfil );
bool ValidaRegionalAssoc( char * buffer, list<long> &listaRegional );
bool ValidaDtEnvio( char * buffer );
bool ValidaNota( char * bf );
bool ValidaNumerico( char * bf );
char * alltrim( char * pszString );
char * ltrim( char * pszString );
char * rtrim( char * pszString );
void findFileType( char *path, string &arquivo, char *type );
void RemoveHistoricoArq( char *path, int DataLimite );
void RetiraMultiplosEspacos( char * pszString );
void NormalizaNome( char * pszString );
void DesmembraNome( TDesmembraNome * ptDesmembraNome );

int main(int argc, char* argv[])
{

	long LinhasLidas;
    long LinhasRejeitadas;
    time_t      rawtime;
	struct tm * timeinfo;
	char        buffer[81];
	char        sArqPrc[512];
	char        sArqTMP[512];
    string      arquivoTXT;
	string      arquivoERR;
	string      arquivoTMP;
	string      registro;
	TParamConf  tParamConf;
	
    EXEC SQL BEGIN DECLARE SECTION;
        
		VARCHAR dataLimite[16];
		short   i_dataLimite = -1;
		VARCHAR qtdDias[4];
		short   i_qtdDias = -1;
		
    EXEC SQL END DECLARE SECTION;

    // Acertando o nivel de logs
    oLog.setNivel(2);
    oLog.logDebug(">>> CadUsuario\n");

    if(ObtemParamConf(&tParamConf)) {
        oLog.logError("Erro obtendo parametros de configuracao\n");
        return -1;
    }

    //==========================================================================
    // Conecta
    oLog.logDebug("Conectando na BD...");
    /* Conecta no banco de dados */
    if (DBConnect(tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst)) {
        oLog.logError("Erro conectando no banco de dados\n");
        return -1;
    }
    oLog.logDebug("Conectado na BD com sucesso...\n");

    ifstream infile;
    ofstream outfile;

    findFileType( "../data", arquivoTXT, ".txt");
    if ( strlen(arquivoTXT.c_str()) < 8 )
    {
        if ( !memcmp(arquivoTXT.c_str(),"../data",7) )
        {
            arquivoTXT = "";
        }
    }

    sprintf( sArqPrc, "%s", arquivoTXT.c_str() );
    sprintf( sArqPrc, "%.*serr", strlen(sArqPrc)-3,sArqPrc );
    arquivoERR = sArqPrc;

    sprintf( sArqTMP, "%s", arquivoTXT.c_str() );
    sprintf( sArqTMP, "%.*sTMP", strlen(sArqPrc)-3,sArqPrc );
    arquivoTMP = sArqTMP;
    
    rename( arquivoTXT.c_str() , sArqTMP );

    //infile.open ( arquivoTXT.c_str() );
    infile.open ( arquivoTMP.c_str() );
    outfile.open ( arquivoERR.c_str() );
    //sprintf(szAux, "Lendo arquivo [%s]\n", arquivoTXT.c_str() ); oLog.logDebug(szAux);
    sprintf(szAux, "Lendo arquivo [%s]\n", arquivoTMP.c_str() ); oLog.logDebug(szAux);
    LinhasLidas = LinhasRejeitadas = 0;
    if ( infile.is_open() )
    {
        while( !infile.eof() ) // To get you all the lines.
        {
            getline( infile, registro ); // Saves the line in registro.
            if ( registro.length() > 1 )
            {
               ProcessaRegistro( outfile,(char*)registro.c_str(), & LinhasLidas, & LinhasRejeitadas );
            }
        }
        infile.close();
    }
    sprintf(szAux, ">>> Total de Linhas Lidas......[%ld]\n", LinhasLidas ); oLog.logDebug(szAux);
    sprintf(szAux, ">>> Total de Linhas Rejeitadas.[%ld]\n", LinhasRejeitadas ); oLog.logDebug(szAux);
    sprintf(szAux, ">>> Total de Linhas Validas....[%ld]\n", LinhasLidas - LinhasRejeitadas ); oLog.logDebug(szAux);
    
    long tamArqErro = (long)outfile.tellp();
    outfile.close();

    time ( &rawtime );
    timeinfo = localtime ( &rawtime );

    memset( buffer, 0x0, sizeof(buffer) );
    strftime ( buffer,80,"_%Y%m%d_%H%M%S.prc", timeinfo );
    /*
    sprintf( sArqPrc, "%s", arquivoTXT.c_str() );
    sprintf( sArqPrc, "%.*s%s", strlen(sArqPrc)-4,sArqPrc,buffer );
    rename( arquivoTXT.c_str() , sArqPrc );
    */

    sprintf( sArqPrc, "%s", arquivoTMP.c_str() );
    sprintf( sArqPrc, "%.*s%s", strlen(sArqPrc)-4,sArqPrc,buffer );
    rename( arquivoTMP.c_str() , sArqPrc );

    if ( tamArqErro > 0)   /* Arquivo de Registros Invalidos Existe? */
    {
        memset( buffer, 0x0, sizeof(buffer) );
        strftime ( buffer,80,"_%Y%m%d_%H%M%S.err", timeinfo );

        sprintf( sArqPrc, "%s", arquivoERR.c_str() );
        sprintf( sArqPrc, "%.*s%s", strlen(sArqPrc)-4,sArqPrc,buffer );

        rename( arquivoERR.c_str() , sArqPrc );
    }
    else
    {
        unlink ( arquivoERR.c_str() );   /* Arquivo de Registros Invalidos com tamanho ZERO */
        //nmArquivo[0] = 0x0;
    }

    EXEC SQL COMMIT WORK RELEASE;

    /*   Obtem a qtde de dias do historico de arquivos processados   */
    //EXEC SQL
    //SELECT DSVALORPARAMETRO INTO :qtdDias:i_qtdDias FROM APOIO.PARAMETRO WHERE CDPARAMETRO = 'QTD_DIAS_EXPURGO_NOTAS_URA';
    //CONVIND( qtdDias,i_qtdDias );
    //sprintf( szAux, "*** Qtde limite de dias [%s]\n", (char*)qtdDias.arr ); oLog.logDebug(szAux);

    //EXEC SQL 
    //SELECT TO_CHAR(TRUNC(SYSDATE - :qtdDias ),'YYYYMMDD') INTO :dataLimite:i_dataLimite FROM DUAL;
    //CONVIND( dataLimite,i_dataLimite );

    //RemoveHistoricoArq( "../data", atoi((char*)dataLimite.arr) );

    oLog.logDebug("Desconectando da BD...\n");
    DBDisconnect();

    oLog.logDebug("Processamento encerrado com sucesso...\n");
    oLog.logDebug("<<< CadUsuario\n");

    return 0;

    sqlError:
        sprintf(szAux, "Finalizando processo com erro ORACLE (%d)\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return -1;

    /* Tratamento de erro de processamento */
    finalizaProcess:
        oLog.logDebug("Finalizando processo...\n");

        oLog.logDebug("Desconectando da BD...\n");
        DBDisconnect();

        oLog.logDebug("<<< CadUsuario\n");
        return -1;
}



/************************************************************************************************************/
int ObtemParamConf(TParamConf *ptParamConf)
{
    MFile mfConfig;
    SplitLine NewLinha;
    char szLinha[81];
    char szDivArq[256];
    char szDivPre[21];

    //oLog.logDebug("Obtendo parametros de configuracao...\n");

    /* Zera variáveis */
    memset(ptParamConf, 0x00, sizeof(TParamConf));
    memset(szLinha, 0x00, sizeof(szLinha));
    memset(szDivArq, 0x00, sizeof(szDivArq));
    memset(szDivPre, 0x00, sizeof(szDivPre));


    /* Define o arquivo de configuração */
    mfConfig.setPath("CadUsuario.cfg");

    /* Verificar se conseguiu abrir o arquivo */
    if(!mfConfig.abrir()) {
        oLog.logError("Erro abrindo arquivo de configuração!\n");
        return -1;
    }

    /* Capturando usuario, senha, path e instance de banco do arquivo */
    NewLinha.SetDiv('=');
    while(mfConfig.getLine(szLinha) != 0)
    {
        NewLinha.SetLine(szLinha);
        NewLinha.GetBeforeDiv(szDivPre);
        NewLinha.GetAfterDiv(szDivArq);

        /* Verifica qual parâmetro foi encontrado. */
        if (!strcmp(szDivPre, "pwd_db"))
        {
            strncpy(ptParamConf->szPws, szDivArq, 10);
        }
        else if (!strcmp(szDivPre, "usr_db"))
        {
            strncpy(ptParamConf->szUsr, szDivArq, 10);
        }
        else if (!strcmp(szDivPre, "inst_db"))
        {
            strncpy(ptParamConf->szInst, szDivArq, 20);
        }
        else if (!strcmp(szDivPre, "pwd_tux"))
        {
            strncpy(ptParamConf->szPwsTux, szDivArq, 10);
        }
        else if (!strcmp(szDivPre, "usr_tux"))
        {
            strncpy(ptParamConf->szUsrTux, szDivArq, 10);
        }
        else if (!strcmp(szDivPre, "pwd_tux_gen"))
        {
            strncpy(ptParamConf->szPwsTuxGen, szDivArq, 10);
        }
        else if (strcmp(szDivPre, "clt_tux")==0)
        {
            strncpy(ptParamConf->szCltTux, szDivArq, 10);
        }

        memset(szLinha,  0x00, sizeof(szLinha));
        memset(szDivPre, 0x00, sizeof(szDivPre));
        memset(szDivArq, 0x00, sizeof(szDivArq));
    }

    /* Fechando o arquivo de configuracao aberto */
    mfConfig.fechar();

    //sprintf(szAux, "ptParamConf->szPws[%s]\n", ptParamConf->szPws); oLog.logInformation(szAux);
    //sprintf(szAux, "ptParamConf->szUsr[%s]\n", ptParamConf->szUsr); oLog.logInformation(szAux);
    //sprintf(szAux, "ptParamConf->szInst[%s]\n", ptParamConf->szInst); oLog.logInformation(szAux);
    //sprintf(szAux, "ptParamConf->szPwsTux[%s]\n", ptParamConf->szPwsTux); oLog.logInformation(szAux);
    //sprintf(szAux, "ptParamConf->szUsrTux[%s]\n", ptParamConf->szUsrTux); oLog.logInformation(szAux);
    //sprintf(szAux, "ptParamConf->szPwsTuxGen[%s]\n", ptParamConf->szPwsTuxGen); oLog.logInformation(szAux);
    //sprintf(szAux, "ptParamConf->szCltTux[%s]\n", ptParamConf->szCltTux); oLog.logInformation(szAux);

    /* Verifica se todos os dados foram recuperados do arquivo de configuração. */
    if (strlen(ptParamConf->szInst) == 0 ||
        strlen(ptParamConf->szPwsTux) == 0 ||
        strlen(ptParamConf->szUsrTux) == 0 ||
        strlen(ptParamConf->szPwsTuxGen) == 0 ||
        strlen(ptParamConf->szCltTux) == 0 )
    {
        oLog.logError("Dados incompletos!\n");
        return -1;
    }


    //oLog.logDebug("Parametros de configuracao obtidos com sucesso...\n");
    return 0;
}



/************************************************************************************************************/
int DBConnect(char *pUsr, char *pPwd, char *pInst)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[256];
    EXEC SQL END DECLARE SECTION;

    //oLog.logInformation(">>>DBConnect\n");

    /* String de conexao */
    sprintf(connString, "%s/%s@%s", pUsr, pPwd, pInst);

    /* Marca ponto de erro */
    EXEC SQL WHENEVER SQLERROR GOTO errConn;

    /* Conecta */
    EXEC SQL CONNECT :connString;

    //oLog.logInformation("<<<DBConnect\n");

    return (sqlca.sqlcode);
    
errConn:
    sprintf(szAux, "sqlca.sqlcode [%d]\n", sqlca.sqlcode ); oLog.logDebug(szAux);
    oLog.logInformation("<<<DBConnect [ERROR]\n");
    return -1;
}




/************************************************************************************************************/
void DBDisconnect(void)
{
    //oLog.logInformation(">>>DBDisconnect\n");

    EXEC SQL WHENEVER SQLERROR GOTO Error;
    //EXEC SQL COMMIT WORK RELEASE;

    //oLog.logInformation("<<<DBDisconnect\n");
    return;

Error:
    sprintf(szAux, "Erro! sqlca.sqlcode = %i\n", sqlca.sqlcode); oLog.logError(szAux);
    return;
}



/************************************************************************************************************/
char *ObtemParametro(char *pCdParametro)
{
    EXEC SQL BEGIN DECLARE SECTION;
        //VARCHAR oszCdParametro[255];
        char *oszCdParametro = pCdParametro;
        VARCHAR oszDsValorParametro[255+1];
    EXEC SQL END DECLARE SECTION;

    static char szDsValorParametro[255 + 1];
    struct sqlca sqlca;


    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    //STRCPY_TO_ORA(oszCdParametro, pCdParametro);

    EXEC SQL 
        SELECT dsvalorparametro
          INTO :oszDsValorParametro
          FROM apoio.parametro
         WHERE parametro.cdparametro = :oszCdParametro;

    STRCPY_FROM_ORA(szDsValorParametro, oszDsValorParametro);

    return szDsValorParametro;

    erro:
        sprintf(szAux, "Finalizando com erro sqlca.sqlcode(%d)\n", sqlca.sqlcode); oLog.logDebug(szAux);
        exit(-1);

    naoexiste:
        sprintf(szAux, "Chave pesquisada nao encontrada[%s]\n", pCdParametro); oLog.logDebug(szAux);
        return NULL;
}



void TrataRegistro( char * registro )
{
    int i,t;
    char str_bkp[4096];
    for( t=i=0; i < strlen(registro); i++ )
    {
        if( registro[i]=='|' )
            t++;
        else
            t=0;
        if( t > 1 )
        {
            strcpy( str_bkp, registro );
            str_bkp[i-1] = 0x0;
            strcat( str_bkp, "|vazio|" );
            i++;
            strcat( str_bkp, (char*)&registro[i] );
            i = t = 0;
            strcpy( registro, str_bkp );
        }
    }
}



void TrataBuffer( char * registro )
{
    int i,t;
    char str_bkp[4096];
    for( t=i=0; i < strlen(registro); i++ )
    {
        if( registro[i]==';' )
            t++;
        else
            t=0;
        if( t > 1 )
        {
            strcpy( str_bkp, registro );
            str_bkp[i-1] = 0x0;
            strcat( str_bkp, ";vazio;" );
            i++;
            strcat( str_bkp, (char*)&registro[i] );
            i = t = 0;
            strcpy( registro, str_bkp );
        }
    }
}



int ProcessaRegistro( ofstream & output, char * registroPrm, long * LinhasLidas, long * LinhasRejeitadas )
{
    TDesmembraNome tDesmembraNome;
    ListGrupo pGrupos;
    ListGrupo pPerfilAssoc;
    ListGrupo pOperadoraAssoc;
    list<long>::iterator itCampos;

    bool   erroRegistro = false;
    char   buffer[2048];
    string token;
    string registro;
    string stmt;
    
    
    EXEC SQL BEGIN DECLARE SECTION;

        char * query;
        int    idx = 0;
        int    idx2 = 0;
        char * v_str;
        VARCHAR v_show[2048];
        short   i_v_show = -1;
        
        char sNome[256];
        char sNomePrimeiro[256];
        char sNomeMeio[256];
        char sNomeFim[256];
        char sUF[3];
        char sEMail[256];
        char sLogin[256];
        char idUFOperadora[256];
        char idNivelHierarquia[256];
        char idNivelPaiHierarquia[256];
        char idCargo[256];
        char idOrganizacaoPai[256];
        char idOrganizacao[256];
        char idTipoOrganizacao[256];
        char idDepto[256];
        char idPerfilAtd[256];
        char idFornecedor[256];
        char idSite[256];
        char sLoginSup[256];
        char sCPF[32];
        char sUFCPF[3];
        char sPerfil[2560];
        char sOperadora[2560];
        
        char idUF[256];
        char idPais[256];
        
        int     idTipoCarteira;
        short i_idTipoCarteira = -1;
        int     idSistemaOrigem;
        short i_idSistemaOrigem = -1;
        int     idTipoPessoa;
        short i_idTipoPessoa = -1;
        long    idPessoa;
        long    idPessoaDePara;
        long    idDocumento;
        VARCHAR idDocumentoSistemaOrigem[256];
        short i_idDocumentoSistemaOrigem = -1;
        long    idPessoaDocumento;
        int     idStatusAtual;
        short   sStatus = -1;
        long    idUsuarioChefe;

        long idGrupo;
        long idRole;
        long idUFOperAssoc;
        
    EXEC SQL END DECLARE SECTION;

    memset( sNome               , 0x0, sizeof(sNome) );
    memset( sNomePrimeiro       , 0x0, sizeof(sNomePrimeiro) );
    memset( sNomeMeio           , 0x0, sizeof(sNomeMeio) );
    memset( sNomeFim            , 0x0, sizeof(sNomeFim) );
    memset( sUF                 , 0x0, sizeof(sUF) );
    memset( sEMail              , 0x0, sizeof(sEMail) );
    memset( sLogin              , 0x0, sizeof(sLogin) );
    memset( idUFOperadora       , 0x0, sizeof(idUFOperadora) );
    memset( idNivelHierarquia   , 0x0, sizeof(idNivelHierarquia) );
    memset( idNivelPaiHierarquia, 0x0, sizeof(idNivelPaiHierarquia) );
    memset( idCargo             , 0x0, sizeof(idCargo) );
    memset( idOrganizacaoPai    , 0x0, sizeof(idOrganizacaoPai) );
    memset( idOrganizacao       , 0x0, sizeof(idOrganizacao) );
    memset( idTipoOrganizacao   , 0x0, sizeof(idTipoOrganizacao) );
    memset( idDepto             , 0x0, sizeof(idDepto) );
    memset( idPerfilAtd         , 0x0, sizeof(idPerfilAtd) );
    memset( idFornecedor        , 0x0, sizeof(idFornecedor) );
    memset( idSite              , 0x0, sizeof(idSite) );
    memset( sLoginSup           , 0x0, sizeof(sLoginSup) );
    memset( sCPF                , 0x0, sizeof(sCPF) );
    memset( sUFCPF              , 0x0, sizeof(sUFCPF) );
    memset( sPerfil             , 0x0, sizeof(sPerfil) );
    memset( sOperadora          , 0x0, sizeof(sOperadora) );
    memset( idUF                , 0x0, sizeof(idUF) );
    memset( idPais              , 0x0, sizeof(idPais) );

    registro = registroPrm;
    *LinhasLidas = *LinhasLidas + 1;

    istringstream iss( registro );
    int l;

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    
    char delims[] = "|";
    char *result = NULL;
    sprintf(szAux, "Registro lido [%s]\n", registroPrm ); oLog.logInformation(szAux);
    TrataRegistro( registroPrm );
    v_str = registroPrm;
    for( idx=0; idx<19; idx++ )
    {
        idx2 = idx+1;
        if ( idx == 0 )
        {
            exec sql
            select substr( :v_str, 1, (instr(:v_str,'|',1,1)-1) ) into :v_show:i_v_show from dual;
        }
        else if ( idx < 18 && idx > 0 )
        {
            exec sql
            select substr( :v_str, instr(:v_str,'|',1,:idx)+1, instr(:v_str,'|',1,:idx2)-(instr(:v_str,'|',1,:idx)+1) ) into :v_show:i_v_show from dual;
        }
        else
        {
            exec sql
            select substr( :v_str, instr(:v_str,'|',1,:idx)+1 ) into :v_show:i_v_show from dual;
        }
        
        CONVIND( v_show, i_v_show );
        result = (char*)v_show.arr ;
        
        switch( idx )
        {
            case  0 :  /*   Coluna NOME   */
                       strcpy( buffer, result );
                       sprintf(szAux, "NOME [%s]\n", buffer ); oLog.logInformation(szAux);
                       // CASO O NOME ESTEJA VAZIO
                       if ( !strcmp( buffer, "vazio" ) )
                       {
                            output << registro.c_str() << endl ;
                            output << MSG_NOME_VAZIO << endl ;
                            sprintf(szAux, "DESCARTE 1\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                            *LinhasRejeitadas = *LinhasRejeitadas + 1;
                       }
                       else if ( strlen(buffer) < 1 )
                       {
                            output << registro.c_str() << endl ;
                            output << MSG_NOME_VAZIO << endl ;
                            sprintf(szAux, "DESCARTE 1\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                            *LinhasRejeitadas = *LinhasRejeitadas + 1;
                       }
                       else
                       {
                            strcpy( sNome, buffer );
                       }
                       break;

            case  1  :     /*   Coluna UF   */
                       strcpy( buffer, result );
                       sprintf(szAux, "UF [%s]\n", buffer ); oLog.logInformation(szAux);
                       // CASO UF ESTEJA VAZIO
                       /*
                       if ( !strcmp( buffer, "vazio" ) )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_UF_VAZIO << endl ;
                            sprintf(szAux, "DESCARTE 2\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       */
                       if ( !strcmp( buffer, "vazio" ) )
                       {
                            strcpy(idUF,"61");
                       }
                       else if ( ValidaUF( buffer, idUF ) == false )
                       {
                             if ( erroRegistro == false )
                             {
                                 output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                             }
                             output << MSG_UF_INVALID << endl ;
                            sprintf(szAux, "DESCARTE 3\n", buffer ); oLog.logInformation(szAux);
                             erroRegistro = true;
                       }
                       break;

            case  2  :  /*   Coluna EMAIL   */
                       strcpy( buffer, result );
                       sprintf(szAux, "EMAIL [%s]\n", buffer ); oLog.logInformation(szAux);
                       if ( !strcmp( buffer, "vazio" ) )
                       {
                            sEMail[0] = 0x0;
                            /*
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_EMAIL_VAZIO << endl ;
                            sprintf(szAux, "DESCARTE 4\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                            */
                       }
                       else if ( ValidaEMail( buffer ) == false )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_EMAIL_INVALID << endl ;
                            sprintf(szAux, "DESCARTE 5\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       else
                       {
                            strcpy( sEMail, buffer );
                       }
                       break;

            case   3 :     /*   Coluna LOGINFRONTOFFICE   */
                       strcpy( buffer, result );
                       sprintf(szAux, "LOGINFRONTOFFICE [%s]\n", buffer ); oLog.logInformation(szAux);
                       if ( !strcmp( buffer, "vazio" ) )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_LOGIN_VAZIO << endl ;
                            sprintf(szAux, "DESCARTE 6\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       else if ( ValidaLogin( buffer ) == 1 )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_LOGIN_TAM_INVALID << endl ;
                            sprintf(szAux, "DESCARTE 7\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       else if ( ValidaLogin( buffer ) == 2 )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_LOGIN_INVALID << endl ;
                            sprintf(szAux, "DESCARTE 7\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       else if ( ValidaLogin( buffer ) == 0 )
                       {
                            strcpy( sLogin, buffer );
                       }
                       break;

            case   4 :     /*   Coluna REGIONAL   */
                       strcpy( buffer, result );
                       sprintf(szAux, "REGIONAL [%s]\n", buffer ); oLog.logInformation(szAux);
                       if ( !strcmp( buffer, "vazio" ) )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_REGIONAL_VAZIO << endl ;
                            sprintf(szAux, "DESCARTE 8\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       else if ( ValidaRegional( buffer, idUFOperadora ) == false )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_REGIONAL_INVALID << endl ;
                            sprintf(szAux, "DESCARTE 9\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       break;

            case   5 :     /*   Coluna HIERARQUIAFUNCIONAL   */
                       strcpy( buffer, result );
                       sprintf(szAux, "HIERARQUIAFUNCIONAL [%s]\n", buffer ); oLog.logInformation(szAux);
                       if ( !strcmp( buffer, "vazio" ) )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_HIERARQUIA_VAZIO << endl ;
                            sprintf(szAux, "DESCARTE 10\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       else if ( ValidaHierarquia( buffer, idNivelHierarquia, idNivelPaiHierarquia ) == false )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_HIERARQUIA_INVALID << endl ;
                            sprintf(szAux, "DESCARTE 11\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       break;

            case   6 :     /*   Coluna CARGO   */
                       strcpy( buffer, result );
                       sprintf(szAux, "CARGO [%s]\n", buffer ); oLog.logInformation(szAux);
                       if ( !strcmp( buffer, "vazio" ) )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_CARGO_VAZIO << endl ;
                            sprintf(szAux, "DESCARTE 12\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       else if ( ValidaCargo( buffer, idNivelHierarquia, idCargo ) == false )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_CARGO_INVALID << endl ;
                            sprintf(szAux, "DESCARTE 13\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       break;

            case   7 :     /*   Coluna ORGANIZACAO   */
                       strcpy( buffer, result );
                       sprintf(szAux, "ORGANIZACAO [%s]\n", buffer ); oLog.logInformation(szAux);
                       if ( !strcmp( buffer, "vazio" ) )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_ORGANIZACAO_VAZIO << endl ;
                            sprintf(szAux, "DESCARTE 14\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       else if ( ValidaOrganizacao( buffer, idOrganizacaoPai, idOrganizacao, idTipoOrganizacao ) == false )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_ORGANIZACAO_INVALID << endl ;
                            sprintf(szAux, "DESCARTE 15\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       break;

            case   8 :     /*   Coluna DEPARTAMENTO   */
                       strcpy( buffer, result );
                       sprintf(szAux, "DEPARTAMENTO [%s]\n", buffer ); oLog.logInformation(szAux);
                       if ( !strcmp( buffer, "vazio" ) )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_DEPARTAMENTO_VAZIO << endl ;
                            sprintf(szAux, "DESCARTE 16\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       else if ( ValidaDepartamento( buffer, idOrganizacao, idDepto ) == false )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_DEPARTAMENTO_INVALID << endl ;
                            sprintf(szAux, "DESCARTE 17\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       break;

            case   9 :     /*   Coluna PERFILATENDIMENTO   */
                       strcpy( buffer, result );
                       sprintf(szAux, "PERFILATENDIMENTO [%s]\n", buffer ); oLog.logInformation(szAux);
                       if ( !strcmp( buffer, "vazio" ) )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_PERFIL_VAZIO << endl ;
                            sprintf(szAux, "DESCARTE 18\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       else if ( ValidaPerfil( buffer, idPerfilAtd ) == false )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_PERFIL_INVALID << endl ;
                            sprintf(szAux, "DESCARTE 19\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       break;

            case  10 :     /*   Coluna FORNECEDOR   */
                       strcpy( buffer, result );
                       sprintf(szAux, "FORNECEDOR [%s]\n", buffer ); oLog.logInformation(szAux);
                       if ( strcmp( buffer, "vazio" ) )
                       {
                           if ( ValidaFornecedor( buffer, idFornecedor ) == false )
                           {
                                if ( erroRegistro == false )
                                {
                                    output << registro.c_str() << endl ;
                                    *LinhasRejeitadas = *LinhasRejeitadas + 1;
                                }
                                output << MSG_FORNECEDOR_INVALID << endl ;
                                sprintf(szAux, "DESCARTE 20\n", buffer ); oLog.logInformation(szAux);
                                erroRegistro = true;
                           }
                       }
                       break;

            case  11 :     /*   Coluna SITE   */
                       strcpy( buffer, result );
                       sprintf(szAux, "SITE [%s]\n", buffer ); oLog.logInformation(szAux);
                       if ( strcmp( buffer, "vazio" ) )
                       {
                           if ( ValidaSite( buffer, idSite ) == false )
                           {
                                if ( erroRegistro == false )
                                {
                                    output << registro.c_str() << endl ;
                                    *LinhasRejeitadas = *LinhasRejeitadas + 1;
                                }
                                output << MSG_SITE_INVALID << endl ;
                                sprintf(szAux, "DESCARTE 21\n", buffer ); oLog.logInformation(szAux);
                                erroRegistro = true;
                           }
                       }
                       break;

            case  12 :     /*   Coluna LOGINSUPERIORIMEDIATO   */
                       strcpy( buffer, result );
                       sprintf(szAux, "LOGINSUPERIORIMEDIATO [%s]\n", buffer ); oLog.logInformation(szAux);
                       if ( !strcmp( buffer, "vazio" ) )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_LOGINSUP_VAZIO << endl ;
                            sprintf(szAux, "DESCARTE 22\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       else if ( ValidaLoginSup( buffer ) == 1 )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_LOGINSUP_TAM_INVALID << endl ;
                            sprintf(szAux, "DESCARTE 23\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       else if ( ValidaLoginSup( buffer ) == 2 )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_LOGINSUP_INVALID << endl ;
                            sprintf(szAux, "DESCARTE 23\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       else if ( ValidaLoginSup( buffer ) == 0 )
                       {
                            strcpy( sLoginSup, buffer );
                       }
                       break;

            case  13 :     /*   Coluna CPF   */
                       strcpy( buffer, result );
                       sprintf(szAux, "CPF [%s]\n", buffer ); oLog.logInformation(szAux);
                       if ( !strcmp( buffer, "vazio" ) )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_CPF_VAZIO << endl ;
                            sprintf(szAux, "DESCARTE 24\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       else if ( ValidaCPF( buffer ) == false )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_CPF_INVALID << endl ;
                            sprintf(szAux, "DESCARTE 25\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       else
                       {
                            strcpy( sCPF, buffer );
                       }
                       break;

            case  14 : /*   Coluna UFCPF   */
                       strcpy( buffer, result );
                       sprintf(szAux, "UFCPF [%s]\n", buffer ); oLog.logInformation(szAux);
                       /*if ( !strcmp( buffer, "vazio" ) )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_UFCPF_VAZIO << endl ;
                            sprintf(szAux, "DESCARTE 26\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       */
                       if ( !strcmp( buffer, "vazio" ) )
                       {
                            strcpy( idUF, "61" );
                       }
                       else if ( ValidaUF( buffer, idUF ) == false )
                       {
                            if ( erroRegistro == false )
                            {
                                 output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_UFCPF_INVALID << endl ;
                            sprintf(szAux, "DESCARTE 27\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       break;

            case  15 : /*   Coluna PAISCPF   */
                       strcpy( buffer, result );
                       sprintf(szAux, "PAISCPF [%s]\n", buffer ); oLog.logInformation(szAux);
                       if ( !strcmp( buffer, "vazio" ) )
                       {
                            if ( erroRegistro == false )
                            {
                                output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_PAISCPF_VAZIO << endl ;
                            sprintf(szAux, "DESCARTE 28\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       else if ( ValidaPais( buffer, idPais ) == false )
                       {
                            if ( erroRegistro == false )
                            {
                                 output << registro.c_str() << endl ;
                                *LinhasRejeitadas = *LinhasRejeitadas + 1;
                            }
                            output << MSG_PAISCPF_INVALID << endl ;
                            sprintf(szAux, "DESCARTE 29\n", buffer ); oLog.logInformation(szAux);
                            erroRegistro = true;
                       }
                       break;

            case  16 : /*   Coluna GRUPO   */
                       strcpy( buffer, result );
                       sprintf(szAux, "GRUPO [%s]\n", buffer ); oLog.logInformation(szAux);
                       pGrupos.clear();
                       if ( ValidaGrupo( buffer, pGrupos ) == false )
                       {
                            if ( pGrupos.empty() && strcmp( buffer, "vazio" ) )
                            {
                                if ( erroRegistro == false )
                                {
                                    output << registro.c_str() << endl ;
                                    *LinhasRejeitadas = *LinhasRejeitadas + 1;
                                }
                                output << MSG_GRUPO_INVALID << endl ;
                                sprintf(szAux, "DESCARTE 30\n", buffer ); oLog.logInformation(szAux);
                                erroRegistro = true;
                            }
                       }
                       break;

            case  17 :     /*   Coluna PERFIL   */
                       strcpy( buffer, result );
                       sprintf(szAux, "PERFIL [%s]\n", buffer ); oLog.logInformation(szAux);
                       pPerfilAssoc.clear();
                       if ( ValidaPerfilAssoc( buffer, pPerfilAssoc ) == false )
                       {
                            if ( pPerfilAssoc.empty() && strcmp( buffer, "vazio" ) )
                            {
                                if ( erroRegistro == false )
                                {
                                    output << registro.c_str() << endl ;
                                    *LinhasRejeitadas = *LinhasRejeitadas + 1;
                                }
                                output << MSG_PERFILASSOC_INVALID << endl ;
                                sprintf(szAux, "DESCARTE 31\n", buffer ); oLog.logInformation(szAux);
                                erroRegistro = true;
                            }
                       }
                       break;

            case  18 :     /*   Coluna OPERADORA   */
                       strcpy( buffer, result );
                       pOperadoraAssoc.clear();
                       for ( l=0;l<strlen(buffer);l++)
                       {
                           if ( buffer[l] == 0x0a ) 
                              buffer[l] = 0x0;
                           if ( buffer[l] == 0x0d ) 
                              buffer[l] = 0x0;
                       }
                       sprintf(szAux, "OPERADORA [%s]\n", buffer ); oLog.logInformation(szAux);
                       if ( ValidaRegionalAssoc( buffer, pOperadoraAssoc ) == false )
                       {
                            if ( pOperadoraAssoc.empty() && strcmp( buffer, "vazio" ) )
                            {
                                if ( erroRegistro == false )
                                {
                                    output << registro.c_str() << endl ;
                                    *LinhasRejeitadas = *LinhasRejeitadas + 1;
                                }
                                output << MSG_OPERADORA_INVALID << endl ;
                                sprintf(szAux, "DESCARTE 32\n", buffer ); oLog.logInformation(szAux);
                                erroRegistro = true;
                            }
                       }
                       break;

        }

    }

    if ( idx < 19 )
    {
        output << registro.c_str() << endl ;
        output << MSG_REG_INVALID << endl ;
        return -1;
    }
	
    if ( erroRegistro == true)
    {
        sprintf(szAux, ">>> Registro descartado [%s]\n", (char*)registro.c_str() ); oLog.logInformation(szAux);
        return -1;
    }
	
    EXEC SQL WHENEVER SQLERROR goto erroGravacao;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	
    sqlca.sqlcode = 0;
	//Recupera o id de sistema origem
	EXEC SQL
    SELECT
        SISTEMAORIGEM.IDSISTEMAORIGEM 
    INTO
        :idSistemaOrigem:i_idSistemaOrigem
    FROM
        APOIO.SISTEMAORIGEM SISTEMAORIGEM
    WHERE
        SISTEMAORIGEM.SGSISTEMAORIGEM = 'CACS';
    
    sprintf(szAux, ">>> Passou 1\n" ); oLog.logInformation(szAux);
	
    sqlca.sqlcode = 0;
    //Recupera o id de tipo de pessoa
    EXEC SQL
    SELECT 
        TIPOPESSOA.IDTIPOPESSOA
    INTO
        :idTipoPessoa:i_idTipoPessoa
    FROM
        APOIO.TIPOPESSOA TIPOPESSOA
    WHERE
        TIPOPESSOA.SGTIPOPESSOA = 'PF';
	
    sprintf(szAux, ">>> Passou 2\n" ); oLog.logInformation(szAux);

    sqlca.sqlcode = 0;
    EXEC SQL
    SELECT
        CUSTOMER.PESSOASQ.NEXTVAL
    INTO
        :idPessoa
    FROM DUAL;
            


    sprintf(szAux, ">>> Passou 3\n" ); oLog.logInformation(szAux);

    sqlca.sqlcode = 0;
    EXEC SQL
    SELECT
        IDTIPOCARTEIRA
    INTO
        :idTipoCarteira:i_idTipoCarteira
    FROM
        APOIO.TIPOCARTEIRA
    WHERE
        UPPER(SGTIPOCARTEIRA) = 'NC'
    AND
        ROWNUM <= 1;


    sprintf(szAux, ">>> Passou 4\n" ); oLog.logInformation(szAux);

    memset( &tDesmembraNome, 0x00, sizeof(TDesmembraNome) );
    strcpy( tDesmembraNome.szNomeCompleto, sNome );
    DesmembraNome(&tDesmembraNome);
    
    //Insere a pessoa
    sqlca.sqlcode = 0;
    EXEC SQL
    INSERT INTO CUSTOMER.PESSOA
    ( 
        IDPESSOA
       ,IDSISTEMAORIGEM
       ,NMPESSOA
       ,NMNOME
       ,NMNOMEMEIO
       ,NMSOBRENOME
       ,DTCADASTRO
       ,INFALECIMENTOINFORMADO
       ,IDTIPOPESSOA
       ,IDTIPOCARTEIRA
       ,IDUF
       ,IDPROBINADIMPLENCIA
       ,IDCHURNPROBABILIDADE
       ,IDPESSOASISTEMAORIGEM
       ,IDUSUARIOALTERACAO
       ,DTULTIMAALTERACAO
    )
    VALUES
    ( 
        :idPessoa
       ,:idSistemaOrigem
       ,:sNome
       ,:sNomePrimeiro
       ,:sNomeMeio
       ,:sNomeFim
       ,SYSDATE //DTCADASTRO
       ,0 //INFALECIMENTOINFORMADO
       ,:idTipoPessoa
       ,:idTipoCarteira //IDTIPOCARTEIRA
       ,TO_NUMBER(:idUF)
       ,0 //IDPROBINADIMPLENCIA
       ,0 //IDCHURNPROBABILIDADE
       ,:idPessoa
       ,11
       ,SYSDATE
    );

    sprintf(szAux, ">>> Passou 5\n" ); oLog.logInformation(szAux);

    sqlca.sqlcode = 0;
    EXEC SQL
    SELECT
        CUSTOMER.PESSOADEPARASQ.NEXTVAL
    INTO
        :idPessoaDePara
    FROM DUAL;


    sprintf(szAux, ">>> Passou 6\n" ); oLog.logInformation(szAux);

    sqlca.sqlcode = 0;
    //Insere em PessoaDePara
    EXEC SQL
    INSERT INTO 
        CUSTOMER.PESSOADEPARA
    ( 
        IDPESSOADEPARA
       ,IDPESSOA
       ,IDPESSOAORIGEM
       ,IDUSUARIOALTERACAO
       ,DTULTIMAALTERACAO
    )
    VALUES
    ( 
        :idPessoaDePara
       ,:idPessoa
       ,:idPessoa
       ,11
       ,SYSDATE
    );

    sprintf(szAux, ">>> Passou 7\n" ); oLog.logInformation(szAux);

    EXEC SQL
    SELECT CUSTOMER.DOCUMENTOSQ.NEXTVAL
      INTO :idDocumento
      FROM DUAL;

    sprintf(szAux, ">>> idDocumento [%ld]\n",idDocumento ); oLog.logInformation(szAux);
    sprintf(szAux, ">>> sCPF        [%s]\n" ,sCPF ); oLog.logInformation(szAux);
    sprintf(szAux, ">>> idUF        [%s]\n" ,idUF ); oLog.logInformation(szAux);
    sprintf(szAux, ">>> idPais      [%s]\n" ,idPais ); oLog.logInformation(szAux);

    sqlca.sqlcode = 0;
    
    //Insere um documento
    EXEC SQL
    INSERT INTO CUSTOMER.DOCUMENTO
    (
       IDDOCUMENTO
      ,NRDOCUMENTO
      ,IDPAIS
      ,IDUF
      ,IDTIPODOCUMENTO
      ,IDUSUARIOALTERACAO
      ,DTULTIMAALTERACAO
    )
    VALUES
    (
       :idDocumento
      ,TO_CHAR(:sCPF)
      ,TO_NUMBER(:idPais)
      ,TO_NUMBER(:idUF)
      ,TO_NUMBER(1)
      ,TO_NUMBER(11)
      ,SYSDATE
    );

    sprintf(szAux, ">>> Passou 8\n" ); oLog.logInformation(szAux);

    sqlca.sqlcode = 0;
    //Recupera o id do sistemas origem, no caso, Front Office
    EXEC SQL
    SELECT
        SISTEMAORIGEM.IDSISTEMAORIGEM
    INTO
        :idSistemaOrigem:i_idSistemaOrigem
    FROM
        APOIO.SISTEMAORIGEM SISTEMAORIGEM
    WHERE
        UPPER(SISTEMAORIGEM.SGSISTEMAORIGEM) = 'FO';

    sprintf(szAux, ">>> Passou 9\n" ); oLog.logInformation(szAux);

    sqlca.sqlcode = 0;
    //Definicao da VIVO:
    //	gravar a sigla de tipo de documento em idDocumentoSistemaOrigem em pessoadocumento
    EXEC SQL
    SELECT
        SGTIPODOCUMENTO
    INTO
        :idDocumentoSistemaOrigem:i_idDocumentoSistemaOrigem
    FROM
        CUSTOMER.DOCUMENTO DOCUMENTO,
        APOIO.TIPODOCUMENTO TIPODOCUMENTO
    WHERE
        DOCUMENTO.IDTIPODOCUMENTO = TIPODOCUMENTO.IDTIPODOCUMENTO
    AND
        DOCUMENTO.IDDOCUMENTO = :idDocumento;

    CONVIND( idDocumentoSistemaOrigem, i_idDocumentoSistemaOrigem );
    sprintf(szAux, ">>> Passou 10\n" ); oLog.logInformation(szAux);

    sqlca.sqlcode = 0;
    //Recupera uma UD unica
    EXEC SQL
    SELECT CUSTOMER.PESSOADOCUMENTOSQ.NEXTVAL
      INTO :idPessoaDocumento
      FROM DUAL;

    sprintf(szAux, ">>> Passou 11\n" ); oLog.logInformation(szAux);

    sqlca.sqlcode = 0;
    //Insere um documento
    EXEC SQL
    INSERT INTO CUSTOMER.PESSOADOCUMENTO
    (
       IDPESSOADOCUMENTO
      ,IDPESSOA
      ,IDDOCUMENTO
      ,IDSISTEMAORIGEM
      ,IDDOCUMENTOSISTEMAORIGEM
      ,IDUSUARIOALTERACAO
      ,DTULTIMAALTERACAO
    )
    VALUES
    (
       :idPessoaDocumento
      ,:idPessoa
      ,:idDocumento
      ,:idSistemaOrigem
      ,:idDocumentoSistemaOrigem
      ,11
      ,SYSDATE
    );

    sprintf(szAux, ">>> Passou 12\n" ); oLog.logInformation(szAux);

    sqlca.sqlcode = 0;
    EXEC SQL
    SELECT
        IDSTATUSUSUARIO
    INTO
        :idStatusAtual:sStatus
    FROM
        APOIO.STATUSUSUARIO
    WHERE
        UPPER(SGSTATUSUSUARIO) = 'ATIVO';


    sprintf(szAux, ">>> Passou 13\n" ); oLog.logInformation(szAux);

    sqlca.sqlcode = 0;
    //Insere usuario
    EXEC SQL 
    INSERT INTO ACESSO.USUARIO 
    (
         IDPESSOAUSUARIO
        ,NMLOGINUSUARIO
        ,INREINICIALIZASENHA
        ,INPRONTOATENDER
        ,INATRIBUICAOPROCESSOS
        ,IDSTATUSUSUARIO
        ,DTSTATUSUSUARIO
        ,INDISPONIVELWF
        ,IDUSUARIOALTERACAO
        ,DTULTIMAALTERACAO
        ,DSEMAIL
        ,IDAREAREGISTRO
        ,SGSENHAUSUARIO
        ,INCONSULTOR
        ,IDUFOPERADORA
        ,IDPERFILCONSULTORATD
        ,IDFORNECEDORCONSULTORATD
        ,IDSITECONSULTORATD 
        ,NMNOME
        ,NMNOMEMEIO
        ,NMULTIMONOME
    )
    VALUES
    (
         :idPessoa
        ,:sLogin
        ,1
        ,0
        ,0
        ,:idStatusAtual
        ,SYSDATE
        ,0
        ,11
        ,SYSDATE
        ,:sEMail
        ,0
        ,:sLogin
        ,'0'
        ,:idUFOperadora
        ,:idPerfilAtd
        ,:idFornecedor
        ,:idSite
        ,:sNomePrimeiro
        ,:sNomeMeio
        ,:sNomeFim
    );

    sprintf(szAux, ">>> Passou 14\n" ); oLog.logInformation(szAux);

    sqlca.sqlcode = 0;
    EXEC SQL
    SELECT 
        USUARIO.IDPESSOAUSUARIO
    INTO
        :idUsuarioChefe
    FROM
        ACESSO.USUARIO USUARIO
    WHERE
        UPPER(TRIM(USUARIO.NMLOGINUSUARIO)) = UPPER(TRIM(:sLoginSup));
			
	
    sprintf(szAux, ">>> Passou 15\n" ); oLog.logInformation(szAux);

    sqlca.sqlcode = 0;
    //Se existe um login de chefe, entao tenta apagar alguma relacao ja existente
    EXEC SQL
    DELETE
        ACESSO.USUARIOHIERARQUIA
    WHERE
        IDPESSOAUSUARIO = :idPessoa;
		
    sqlca.sqlcode=0;

    sprintf(szAux, ">>> Passou 16\n" ); oLog.logInformation(szAux);

    //Insere a relacao que indica o login do chefe
    EXEC SQL
    INSERT INTO ACESSO.USUARIOHIERARQUIA 
    (
       IDPESSOAUSUARIO
      ,IDPESSOAUSUARIOCHEFE
      ,IDUSUARIOALTERACAO
      ,DTULTIMAALTERACAO
    )
    VALUES
    (
       :idPessoa
      ,:idUsuarioChefe
      ,11
      ,SYSDATE
    );

   EXEC SQL
   INSERT INTO ACESSO.USUARIOCARGO
     (IDUSUARIOCARGO,
      IDCARGO,
      IDPESSOAUSUARIO,
      IDUSUARIOALTERACAO,
      DTULTIMAALTERACAO)
   VALUES
     ( ACESSO.USUARIOCARGOSQ.NEXTVAL
      ,:idCargo
      ,:idPessoa
      ,11
      ,SYSDATE);

/*
      EXEC SQL INSERT INTO organograma.hierarquiadeptopessoa
                  ( idhierarquiadeptopessoa
                  , idnivelcargo
                  , idpessoa
                  , idorganizacaodepartamento
                  , idusuarioalteracao
                  , dtultimaalteracao )
           VALUES ( organograma.hierarquiadeptopessoasq.nextval
                  , :idNivelHierarquia
                  , :idPessoa
                  , :idOrganizacao
                  , 11
                  , SYSDATE );
*/

   sprintf(szAux, ">>> Passou 17\n" ); oLog.logInformation(szAux);

    for ( itCampos=pGrupos.begin();itCampos!=pGrupos.end();itCampos++ )
    {
        idGrupo = *itCampos;
        
        sqlca.sqlcode = 0;
        //Realiza o insert
        EXEC SQL 
        INSERT INTO ACESSO.USUARIOGRUPO
        (
            IDUSUARIOGRUPO,
            IDPESSOAUSUARIO,
            IDGRUPO,
            IDUSUARIOALTERACAO,
            DTULTIMAALTERACAO,
            INSUPERVISOR
        )
        VALUES
        (
            ACESSO.USUARIOGRUPOSQ.NEXTVAL ,
            :idPessoa ,
            :idGrupo ,
            11 ,
            SYSDATE ,
            0
        );
    }

    sprintf(szAux, ">>> Passou 18\n" ); oLog.logInformation(szAux);

    // Associacao de Perfil
    sqlca.sqlcode = 0;
    EXEC SQL 
    DELETE FROM acesso.UsuarioRole 
    WHERE idPessoaUsuario = :idPessoa ;

    sprintf(szAux, ">>> Passou 19\n" ); oLog.logInformation(szAux);

    for ( itCampos=pPerfilAssoc.begin();itCampos!=pPerfilAssoc.end();itCampos++ )
    {
        idRole = *itCampos;

        sqlca.sqlcode = 0;
        EXEC SQL 
        INSERT INTO ACESSO.USUARIOROLE 
        ( 
            IDUSUARIOROLE, 
            IDPESSOAUSUARIO, 
            IDROLE, 
            IDUSUARIOALTERACAO, 
            DTULTIMAALTERACAO 
        )
        VALUES
        ( 
            ACESSO.USUARIOROLESQ.nextval , 
            :idPessoa , 
            :idRole, 
            11 , 
            SYSDATE 
        );
    }

    sprintf(szAux, ">>> Passou 20\n" ); oLog.logInformation(szAux);

    sqlca.sqlcode = 0;
    EXEC SQL 
    DELETE FROM acesso.UsuarioUFOperadora 
    WHERE idPessoaUsuario = :idPessoa ;

    sprintf(szAux, ">>> Passou 21\n" ); oLog.logInformation(szAux);

    for ( itCampos=pOperadoraAssoc.begin();itCampos!=pOperadoraAssoc.end();itCampos++ )
    {
        idUFOperAssoc = *itCampos;

        sqlca.sqlcode = 0;
        EXEC SQL 
        INSERT INTO ACESSO.USUARIOUFOPERADORA 
        ( 
            IDUSUARIOUFOPERADORA, 
            IDPESSOAUSUARIO, 
            IDUFOPERADORA, 
            IDUSUARIOALTERACAO, 
            DTULTIMAALTERACAO 
        )
        VALUES
        ( 
            acesso.UsuarioUFOperadorasq.nextval , 
            :idPessoa , 
            :idUFOperAssoc , 
            11 , 
            SYSDATE 
        );
    }

	
	sqlca.sqlcode = 0;

    EXEC SQL COMMIT;
	
	return 0;

    erroGravacao:
        sprintf(szAux, "*** ERRO ORACLE sqlca.sqlcode[%d] sqlca.sqlerrmc [%s]\n", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc ); oLog.logDebug(szAux);
        EXEC SQL ROLLBACK;
        return -1 ;
}



bool ValidaDtEnvio( char * buffer )
{
	EXEC SQL BEGIN DECLARE SECTION;
		char * pQuery;
		VARCHAR dtEnvio[64];
		short i_dtEnvio = -1;
    EXEC SQL END DECLARE SECTION;

	if (strlen(buffer) != 19)
	   return false;
	   
	string query;
	memset( &dtEnvio, 0x0, sizeof(dtEnvio) );
   
    query = "select to_date('";
	query += buffer;
    query += "','dd/mm/yyyy hh24:mi:ss') from dual";
	pQuery = (char*)query.c_str();
	
	sprintf(szAux, "QUERY Validacao de Data [%s]\n", pQuery ); oLog.logInformation(szAux);

    EXEC SQL WHENEVER SQLERROR goto erroValData;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL PREPARE S1 FROM :pQuery; 
	EXEC SQL DECLARE VERIFICADATA CURSOR FOR S1;
	EXEC SQL OPEN VERIFICADATA;
	EXEC SQL FETCH VERIFICADATA INTO :dtEnvio:i_dtEnvio;
	EXEC SQL CLOSE VERIFICADATA;
	
	CONVIND( dtEnvio,i_dtEnvio );
	//sprintf(szAux, "dtEnvio [%s]\n", (char*)dtEnvio.arr ); oLog.logInformation(szAux);
	
	return true;
	
    erroValData:
        sprintf(szAux, "*** DATA INVALIDA ERRO sqlca.sqlcode[%d]\n", sqlca.sqlcode); oLog.logDebug(szAux);
		return false;
}



bool ValidaUF( char * buffer, char * idUFPrm )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char * pUF = buffer;
        VARCHAR idUF[256];
        short i_idUF = -1;
    EXEC SQL END DECLARE SECTION;
    
    memset( &idUF, 0x0, sizeof(idUF) );

    EXEC SQL WHENEVER SQLERROR goto erroValUF;
    
    EXEC SQL
    SELECT IDUF INTO :idUF:i_idUF FROM APOIO.UF UF WHERE TRIM(UPPER(UF.NMUF)) = TRIM(UPPER(:pUF));
    
    CONVIND( idUF, i_idUF );
    sprintf(szAux, "*** Retornou idUF [%s]\n", (char*)idUF.arr ); oLog.logInformation(szAux);

    if ( idUF.len > 1 )
    {
        strcpy( idUFPrm,(char*)idUF.arr );
        return true;
    }
    else
    {
        return false;
    }

    erroValUF:
        sprintf(szAux, "*** ERRO sqlca.sqlcode[%d]\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return false;
}



bool ValidaPais( char * buffer, char * idPaisPrm )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char * pPais = buffer;
        VARCHAR idPais[256];
        short i_idPais = -1;
    EXEC SQL END DECLARE SECTION;
    
    memset( &idPais, 0x0, sizeof(idPais) );

    EXEC SQL WHENEVER SQLERROR goto erroValPais;
    
    EXEC SQL
    SELECT PAIS.IDPAIS INTO :idPais:i_idPais FROM APOIO.PAIS PAIS WHERE PAIS.INPREENCHELISTA = 1 AND TRIM(UPPER(PAIS.NMPAIS)) = TRIM(UPPER(:pPais)) AND ROWNUM < 2;
    
    CONVIND( idPais, i_idPais );
    sprintf(szAux, "*** Retornou idPais [%s]\n", (char*)idPais.arr ); oLog.logInformation(szAux);

    if ( idPais.len > 0 )
    {
        strcpy( idPaisPrm,(char*)idPais.arr );
        return true;
    }
    else
    {
        return false;
    }

    erroValPais:
        sprintf(szAux, "*** ERRO sqlca.sqlcode[%d]\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return false;
}



int ValidaLogin( char * buffer )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char * pLogin = buffer;
        int ct;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR goto erroValidaLogin;
    
    if ( strlen(pLogin) < 6 || strlen(pLogin) > 9 )
    {
        sprintf(szAux, "!!! ERRO: login deve ter no minimo 6 e no maximo 9 caracteres\n" ); oLog.logDebug(szAux);
        return 1;
    }
    
    EXEC SQL
    select count(1) into :ct from acesso.usuario where TRIM(upper(nmloginusuario)) = TRIM(upper(:pLogin));
    
    if ( ct > 0 )
    {
        return 2;
    }

    return 0;

    erroValidaLogin:
        sprintf(szAux, "*** ERRO sqlca.sqlcode[%d]\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return -1;
}



int ValidaLoginSup( char * buffer )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char * pLogin = buffer;
        int ct;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR goto erroValidaLogin;
    
    if ( strlen(pLogin) < 6 || strlen(pLogin) > 9 )
    {
        sprintf(szAux, "!!! ERRO: login do superior deve ter no minimo 6 e no maximo 9 caracteres\n" ); oLog.logDebug(szAux);
        return 1;
    }

    EXEC SQL
    select count(1) into :ct from acesso.usuario where TRIM(upper(nmloginusuario)) = TRIM(upper(:pLogin));
    
    if ( ct == 0 )
    {
        return 2;
    }

    return 0;

    erroValidaLogin:
        sprintf(szAux, "*** ERRO sqlca.sqlcode[%d]\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return -1;
}



bool ValidaRegional( char * buffer, char * idUFOperadrm )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char * pUF = buffer;
        VARCHAR idUFOperad[256];
        short i_idUFOperad = -1;
    EXEC SQL END DECLARE SECTION;
    
    memset( &idUFOperad, 0x0, sizeof(idUFOperad) );

    EXEC SQL WHENEVER SQLERROR goto erroValRegional;
    
    EXEC SQL
    SELECT
       TMP.IDUFOPERADORA
    INTO
       :idUFOperad:i_idUFOperad
    FROM
    (
                SELECT 
                    UFOPERADORA.IDUFOPERADORA AS IDUFOPERADORA ,
                    UF.SGUF|| ' - '||PESSOA.NMPESSOA AS NMUFOPERADORA
                FROM 
                    CUSTOMER.UFOPERADORA UFOPERADORA,
                    CUSTOMER.OPERADORA OPERADORA,
                    CUSTOMER.PESSOA PESSOA,
                    APOIO.UF UF,
                    CUSTOMER.PESSOADEPARA PESSOADEPARA
                WHERE 
                    UFOPERADORA.IDUF = UF.IDUF
                    AND UFOPERADORA.IDPESSOADEPARAOPERADORA = OPERADORA.IDPESSOADEPARAOPERADORA
                    AND PESSOA.IDPESSOA = PESSOADEPARA.IDPESSOA
                    AND PESSOADEPARA.IDPESSOADEPARA = OPERADORA.IDPESSOADEPARAOPERADORA 
     ) TMP
     WHERE
        TRIM(UPPER(TMP.NMUFOPERADORA)) = TRIM(UPPER(:pUF)) ;               
                
    CONVIND( idUFOperad, i_idUFOperad );
    
    sprintf(szAux, "*** Retornou idUFOperad [%s]\n", (char*)idUFOperad.arr ); oLog.logInformation(szAux);

    strcpy( idUFOperadrm,(char*)idUFOperad.arr );
    if ( strlen(idUFOperadrm) > 0 )
    {
        sprintf(szAux, "*** Encontrou idUFOperadrm\n" ); oLog.logInformation(szAux);
        return true;
    }
    else
    {
        sprintf(szAux, "*** Nao encontrou idUFOperadrm\n" ); oLog.logInformation(szAux);
        return false;
    }

    erroValRegional:
        sprintf(szAux, "*** ERRO sqlca.sqlcode[%d]\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return false;
}



bool ValidaHierarquia( char * buffer, char * idNivelPrm, char * idNivelPaiPrm )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char * pNivel = buffer;
        VARCHAR idNivel[256];
        short i_idNivel = -1;
        VARCHAR idNivelPai[256];
        short i_idNivelPai = -1;
    EXEC SQL END DECLARE SECTION;
    
    memset( &idNivel   , 0x0, sizeof(idNivel) );
    memset( &idNivelPai, 0x0, sizeof(idNivelPai) );

    EXEC SQL WHENEVER SQLERROR goto erroValHierarquia;
    
    EXEC SQL
     SELECT nivel.idnivel
          , nivelhierarquia.idnivelpai
     INTO :idNivel:i_idNivel ,
          :idNivelPai:i_idNivelPai
       FROM organograma.nivel nivel
          , organograma.nivelhierarquia nivelhierarquia
      WHERE nivelhierarquia.idnivel = nivel.idnivel
      AND TRIM(UPPER(nivel.dsnivel)) = TRIM(UPPER(:pNivel)) ;
          
    CONVIND( idNivel   , i_idNivel );
    CONVIND( idNivelPai, i_idNivelPai );
    sprintf(szAux, "*** Retornou idNivel    [%s]\n", (char*)idNivel.arr ); oLog.logInformation(szAux);
    sprintf(szAux, "*** Retornou idNivelPai [%s]\n", (char*)idNivelPai.arr ); oLog.logInformation(szAux);

    if ( idNivel.len > 1 )
    {
        strcpy( idNivelPrm   ,(char*)idNivel.arr );
        strcpy( idNivelPaiPrm,(char*)idNivelPai.arr );
        return true;
    }
    else
    {
        return false;
    }

    erroValHierarquia:
        sprintf(szAux, "*** ERRO sqlca.sqlcode[%d]\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return false;
}



bool ValidaCargo( char * buffer, char * idNivelPrm, char * idCargoPrm )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char * pCargo = buffer;
        char * idNivel = idNivelPrm;
        VARCHAR idCargo[256];
        short i_idCargo = -1;
    EXEC SQL END DECLARE SECTION;
    
    memset( &idCargo, 0x0, sizeof(idCargo) );

    EXEC SQL WHENEVER SQLERROR goto erroValCargo;
    
    EXEC SQL
     SELECT cargo.idcargo
     INTO :idCargo:i_idCargo
       FROM acesso.cargo cargo
          , organograma.nivelcargo nivelcargo
      WHERE cargo.idcargo = nivelcargo.IDCARGO
        AND nivelcargo.IDNIVEL = :idNivel
        AND TRIM(UPPER(cargo.nmcargo)) = TRIM(UPPER(:pCargo)) ;
          
    CONVIND( idCargo, i_idCargo );
    sprintf(szAux, "*** Retornou idCargo [%s]\n", (char*)idCargo.arr ); oLog.logInformation(szAux);

    if ( idCargo.len > 1 )
    {
        strcpy( idCargoPrm,(char*)idCargo.arr );
        return true;
    }
    else
    {
        return false;
    }

    erroValCargo:
        sprintf(szAux, "*** ERRO sqlca.sqlcode[%d]\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return false;
}



bool ValidaOrganizacao( char * buffer, char * idOrganizacaoPaiPrm, char * idOrganizacaoPrm, char * idTipoOrganizacaoPrm )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char * pOrganiz = buffer;
        
        VARCHAR idOrganizacaoPai[256];
        short i_idOrganizacaoPai = -1;
        VARCHAR idOrganizacao[256];
        short i_idOrganizacao = -1;
        VARCHAR idTipoOrganizacao[256];
        short i_idTipoOrganizacao = -1;
    EXEC SQL END DECLARE SECTION;
    
    memset( &idOrganizacaoPai, 0x0, sizeof(idOrganizacaoPai) );
    memset( &idOrganizacao, 0x0, sizeof(idOrganizacao) );
    memset( &idTipoOrganizacao, 0x0, sizeof(idTipoOrganizacao) );

    EXEC SQL WHENEVER SQLERROR goto erroValOrganizacao;
    
    EXEC SQL
     SELECT TO_CHAR( organizacaohierarquia.idorganizacaopai )
          , TO_CHAR( organizacao.idorganizacao      )
          , TO_CHAR( organizacao.idtipoorganizacao  )
     INTO
        :idOrganizacaoPai:i_idOrganizacaoPai ,
        :idOrganizacao:i_idOrganizacao ,
        :idTipoOrganizacao:i_idTipoOrganizacao
       FROM organograma.organizacao      organizacao
          , organograma.tipoorganizacao  tipo
          , organograma.organizacaohierarquia organizacaohierarquia
      WHERE organizacao.idtipoorganizacao = tipo.idtipoorganizacao
        AND organizacaohierarquia.idorganizacao = organizacao.idorganizacao
        AND UPPER(TRIM(tipo.dstipoorganizacao)) = UPPER(TRIM( :pOrganiz )) 
        AND ROWNUM < 2;
                
    CONVIND( idOrganizacaoPai, i_idOrganizacaoPai );
    CONVIND( idOrganizacao, i_idOrganizacao );
    CONVIND( idTipoOrganizacao, i_idTipoOrganizacao );

    sprintf(szAux, "*** Retornou idOrganizacaoPai  [%s]\n", (char*)idOrganizacaoPai.arr ); oLog.logInformation(szAux);
    sprintf(szAux, "*** Retornou idOrganizacao     [%s]\n", (char*)idOrganizacao.arr ); oLog.logInformation(szAux);
    sprintf(szAux, "*** Retornou idTipoOrganizacao [%s]\n", (char*)idTipoOrganizacao.arr ); oLog.logInformation(szAux);

    if ( idOrganizacao.len > 1 )
    {
        strcpy( idOrganizacaoPaiPrm,(char*)idOrganizacaoPai.arr );
        strcpy( idOrganizacaoPrm,(char*)idOrganizacao.arr );
        strcpy( idTipoOrganizacaoPrm,(char*)idTipoOrganizacao.arr );
        return true;
    }
    else
    {
        return false;
    }

    erroValOrganizacao:
        sprintf(szAux, "*** ERRO sqlca.sqlcode[%d]\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return false;
}



bool ValidaDepartamento( char * buffer, char * idOrganizacaoPrm,char * idDeptoPrm )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char * pDepto = buffer;
        char * pidOrganizacao = idOrganizacaoPrm;
        
        VARCHAR idDepto[256];
        short i_idDepto = -1;
    EXEC SQL END DECLARE SECTION;
    
    memset( &idDepto, 0x0, sizeof(idDepto) );

    EXEC SQL WHENEVER SQLERROR goto erroValDepto;
    
    EXEC SQL
    SELECT departamento.iddepartamento
    INTO :idDepto:i_idDepto
      FROM organograma.departamento departamento
         , organograma.organizacaodepartamento organizacaodepartamento
     WHERE departamento.iddepartamento = organizacaodepartamento.iddepartamento
       AND organizacaodepartamento.idorganizacao = :pidOrganizacao
       AND UPPER(trim( departamento.nmdepartamento )) = UPPER(trim( :pDepto )) ;
                
    CONVIND( idDepto, i_idDepto );

    sprintf(szAux, "*** Retornou idDepto [%s]\n", (char*)idDepto.arr ); oLog.logInformation(szAux);

    if ( idDepto.len > 1 )
    {
        strcpy( idDeptoPrm,(char*)idDepto.arr );
        return true;
    }
    else
    {
        return false;
    }

    erroValDepto:
        sprintf(szAux, "*** ERRO sqlca.sqlcode[%d]\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return false;
}



bool ValidaPerfil( char * buffer, char * idPerfilPrm )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char * pPerfil = buffer;
        
        VARCHAR idPerfil[256];
        short i_idPerfil = -1;
    EXEC SQL END DECLARE SECTION;
    
    memset( &idPerfil, 0x0, sizeof(idPerfil) );

    EXEC SQL WHENEVER SQLERROR goto erroValPerfil;
    
    EXEC SQL
    SELECT
        idPerfilConsultorAtd
    INTO :idPerfil:i_idPerfil
    FROM
        APOIO.PERFILCONSULTORATD
    WHERE
       UPPER(TRIM(dsPerfilConsultorAtd)) = UPPER(trim( :pPerfil )) ;
                
    CONVIND( idPerfil, i_idPerfil );

    sprintf(szAux, "*** Retornou idPerfil [%s]\n", (char*)idPerfil.arr ); oLog.logInformation(szAux);

    if ( idPerfil.len > 1 )
    {
        strcpy( idPerfilPrm,(char*)idPerfil.arr );
        return true;
    }
    else
    {
        return false;
    }

    erroValPerfil:
        sprintf(szAux, "*** ERRO sqlca.sqlcode[%d]\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return false;
}



bool ValidaFornecedor( char * buffer, char * idFornecedorPrm )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char * pFornecedor = buffer;
        
        VARCHAR idFornecedor[256];
        short i_idFornecedor = -1;
    EXEC SQL END DECLARE SECTION;
    
    memset( &idFornecedor, 0x0, sizeof(idFornecedor) );

    EXEC SQL WHENEVER SQLERROR goto erroValFornecedor;
    
    EXEC SQL
    SELECT
        idFornecedorConsultorAtd
    INTO :idFornecedor:i_idFornecedor
    FROM
        APOIO.FORNECEDORCONSULTORATD
    WHERE
       UPPER(TRIM(dsFornecedorConsultorAtd)) = UPPER(TRIM( :pFornecedor )) ;

    CONVIND( idFornecedor, i_idFornecedor );

    sprintf(szAux, "*** Retornou idFornecedor [%s]\n", (char*)idFornecedor.arr ); oLog.logInformation(szAux);

    if ( idFornecedor.len > 1 )
    {
        strcpy( idFornecedorPrm,(char*)idFornecedor.arr );
        return true;
    }
    else
    {
        return false;
    }

    erroValFornecedor:
        sprintf(szAux, "*** ERRO sqlca.sqlcode[%d]\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return false;
}



bool ValidaSite( char * buffer, char * idSitePrm )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char * pSite = buffer;
        
        VARCHAR idSite[256];
        short i_idSite = -1;
    EXEC SQL END DECLARE SECTION;
    
    memset( &idSite, 0x0, sizeof(idSite) );

    EXEC SQL WHENEVER SQLERROR goto erroValSite;
    
    EXEC SQL
    SELECT
        idSiteConsultorAtd
    INTO :idSite:i_idSite
    FROM
        APOIO.SITECONSULTORATD
    WHERE
        UPPER(TRIM(dsSiteConsultorAtd)) = UPPER(TRIM ( :pSite )) ;

    CONVIND( idSite, i_idSite );

    sprintf(szAux, "*** Retornou idSite [%s]\n", (char*)idSite.arr ); oLog.logInformation(szAux);

    if ( idSite.len > 0 )
    {
        strcpy( idSitePrm,(char*)idSite.arr );
        return true;
    }
    else
    {
        return false;
    }

    erroValSite:
        sprintf(szAux, "*** ERRO sqlca.sqlcode[%d]\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return false;
}



bool ValidaCPF( char * buffer )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char * pCPF = buffer;
        int ctCPF;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR goto erroValCPF;
    
    EXEC SQL
    select 
       count (pessoa.idpessoa)
    into
       :ctCPF
    from
       acesso.usuario                      usuario ,
       customer.pessoa                   pessoa ,
       customer.documento             documento ,
       customer.pessoadocumento   pd
    where
       PD.IDPESSOA = USUARIO.IDPESSOAUSUARIO
    and DOCUMENTO.IDDOCUMENTO = PD.IDDOCUMENTO
    and PD.IDPESSOA = PESSOA.IDPESSOA
    and DOCUMENTO.IDTIPODOCUMENTO IN ( 1, 3, 25, 27, 28 )
    and DOCUMENTO.NRDOCUMENTO = :pCPF ;

    sprintf(szAux, "*** Retornou ctCPF [%d]\n", ctCPF ); oLog.logInformation(szAux);

    if ( ctCPF == 0 )
    {
        return true;
    }
    else
    {
        return false;
    }

    erroValCPF:
        sprintf(szAux, "*** ERRO sqlca.sqlcode[%d]\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return false;
}



bool ValidaGrupo( char * buffer, list<long> &listaGrupos )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char nmGrupo[200][256];
        VARCHAR   idGrupo[200][256];
        short   i_idGrupo[200];
    EXEC SQL END DECLARE SECTION;
    
    TrataBuffer( buffer );

    char delims[] = ";";
    char *result = NULL;
    sprintf(szAux, "buffer [%s]\n", buffer ); oLog.logInformation(szAux);
    
    int idx;
    for ( idx=0; idx < 200; idx++ )
    {
        memset( &idGrupo[idx], 0x0, 256 );
        i_idGrupo[idx] = -1;
    }
    
    idx = 0;
    result = strtok( buffer, delims );
    while( result != NULL ) 
    {
        if ( !strcmp(result,"vazio") )
           continue;
        if ( idx > 199 ) 
           break;
        strcpy( nmGrupo[idx], result );
        idx++;
        result = strtok( NULL, delims );
    }
    
    bool flgGrupo = false;
    
    EXEC SQL WHENEVER SQLERROR goto erroValGrupo;
    
    for ( idx=0; idx < 200; idx++ )
    {
        sprintf(szAux, "nmGrupo[%d] = [%s]\n", idx, nmGrupo[idx] ); oLog.logInformation(szAux);
        if ( nmGrupo[idx][0] != 0x0 )
        {
            EXEC SQL
            select 
               idGrupo
            into
               :idGrupo[idx]:i_idGrupo[idx]
            from 
               acesso.grupo 
            where 
               dtexclusao is null 
            and upper(trim(nmgrupo)) = upper(trim(:nmGrupo[idx])) ;
            
            if ( i_idGrupo[idx] < 0 )
            {
                continue;
            }
            else
            {
                CONVIND( idGrupo[idx], i_idGrupo[idx] );
                sprintf(szAux, "*** Retornou idGrupo [%s]\n", (char*)idGrupo[idx].arr ); oLog.logInformation(szAux);
                listaGrupos.push_back( atol((char*)idGrupo[idx].arr) );
                flgGrupo = true;
            }
        }
        else
           break;
    }
    
    return flgGrupo;

    erroValGrupo:
        sprintf(szAux, "*** ERRO sqlca.sqlcode[%d]\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return false;
}



bool ValidaPerfilAssoc( char * buffer, list<long> &listaPerfil )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char nmPerfil[200][256];
        VARCHAR   idPerfil[200][256];
        short   i_idPerfil[200];
    EXEC SQL END DECLARE SECTION;
    
    TrataBuffer( buffer );

    char delims[] = ";";
    char *result = NULL;
    sprintf(szAux, "buffer [%s]\n", buffer ); oLog.logInformation(szAux);
    
    int idx;
    for ( idx=0; idx < 200; idx++ )
    {
        memset( &idPerfil[idx], 0x0, 256 );
        i_idPerfil[idx] = -1;
    }
    
    idx = 0;
    result = strtok( buffer, delims );
    while( result != NULL ) 
    {
        if ( !strcmp(result,"vazio") )
           continue;
        if ( idx > 199 ) 
           break;
        strcpy( nmPerfil[idx], result );
        idx++;
        result = strtok( NULL, delims );
    }
    
    bool flgPerfil = false;
    
    EXEC SQL WHENEVER SQLERROR goto erroValPerfilAssoc;
    
    for ( idx=0; idx < 200; idx++ )
    {
        sprintf(szAux, "nmPerfil[%d] = [%s]\n", idx, nmPerfil[idx] ); oLog.logInformation(szAux);
        if ( nmPerfil[idx][0] != 0x0 )
        {
            EXEC SQL
            SELECT 
                IDROLE 
            INTO 
               :idPerfil[idx]:i_idPerfil[idx]
            FROM 
                ACESSO.ROLE 
            WHERE
                UPPER(TRIM(NMROLE)) = UPPER(TRIM(:nmPerfil[idx])) ;
               
            if ( i_idPerfil[idx] < 0 )
            {
                continue;
            }
            else
            {
                CONVIND( idPerfil[idx], i_idPerfil[idx] );
                sprintf(szAux, "*** Retornou idRole [%s]\n", (char*)idPerfil[idx].arr ); oLog.logInformation(szAux);
                listaPerfil.push_back( atol((char*)idPerfil[idx].arr) );
                flgPerfil = true;
            }
        }
        else
           break;
    }
    
    return flgPerfil;

    erroValPerfilAssoc:
        sprintf(szAux, "*** ERRO sqlca.sqlcode[%d]\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return false;
}



bool ValidaRegionalAssoc( char * buffer, list<long> &listaRegional )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char nmRegional[200][256];
        VARCHAR   idUFOperadora[200][256];
        short   i_idUFOperadora[200];
    EXEC SQL END DECLARE SECTION;
    
    TrataBuffer( buffer );

    char delims[] = ";";
    char *result = NULL;
    sprintf(szAux, "buffer [%s]\n", buffer ); oLog.logInformation(szAux);
    
    int idx;
    for ( idx=0; idx < 200; idx++ )
    {
        memset( &idUFOperadora[idx], 0x0, 256 );
        i_idUFOperadora[idx] = -1;
    }
    
    idx = 0;
    result = strtok( buffer, delims );
    while( result != NULL ) 
    {
        if ( !strcmp(result,"vazio") )
           continue;
        if ( idx > 199 ) 
           break;
        strcpy( nmRegional[idx], result );
        idx++;
        result = strtok( NULL, delims );
    }
    
    bool flgPerfil = false;
    
    EXEC SQL WHENEVER SQLERROR goto erroValRegionalAssoc;
    
    for ( idx=0; idx < 200; idx++ )
    {
        sprintf(szAux, "nmRegional[%d] = [%s]\n", idx, nmRegional[idx] ); oLog.logInformation(szAux);
        if ( nmRegional[idx][0] != 0x0 )
        {
            EXEC SQL
            SELECT
               TMP.IDUFOPERADORA
            INTO
               :idUFOperadora[idx]:i_idUFOperadora[idx]
            FROM
            (
                /*
                SELECT 
                    UFOPERADORA.IDUFOPERADORA AS IDUFOPERADORA ,
                    UF.SGUF|| ' - '||PESSOA.NMPESSOA AS NMUFOPERADORA
                FROM 
                    CUSTOMER.UFOPERADORA UFOPERADORA,
                    CUSTOMER.OPERADORA OPERADORA,
                    CUSTOMER.PESSOA PESSOA,
                    APOIO.UF UF,
                    CUSTOMER.PESSOADEPARA PESSOADEPARA
                WHERE 
                    UFOPERADORA.IDUF = UF.IDUF
                    AND UFOPERADORA.IDPESSOADEPARAOPERADORA = OPERADORA.IDPESSOADEPARAOPERADORA
                    AND PESSOA.IDPESSOA = PESSOADEPARA.IDPESSOA
                    AND PESSOADEPARA.IDPESSOADEPARA = OPERADORA.IDPESSOADEPARAOPERADORA 
                */

                SELECT 
                    UFOPERADORA.IDUFOPERADORA, 
                    UF.SGUF || ' - ' ||GRUPOOPERADORA.NMGRUPOOPERADORA AS NMUFOPERADORA
                FROM 
                    CUSTOMER.UFOPERADORA UFOPERADORA,
                    CUSTOMER.OPERADORA OPERADORA,
                    CUSTOMER.GRUPOOPERADORA GRUPOOPERADORA,
                    APOIO.UF UF
                WHERE
                     UFOPERADORA.IDPESSOADEPARAOPERADORA=OPERADORA.IDPESSOADEPARAOPERADORA
                AND 
                    OPERADORA.IDGRUPOOPERADORA=GRUPOOPERADORA.IDGRUPOOPERADORA
                AND
                    UFOPERADORA.IDUF=UF.IDUF
                    
                    
             ) TMP
             WHERE
                UPPER(TRIM(TMP.NMUFOPERADORA)) = UPPER(TRIM(:nmRegional[idx])) ;               

            if ( i_idUFOperadora[idx] < 0 )
            {
                continue;
            }
            else
            {
                CONVIND( idUFOperadora[idx], i_idUFOperadora[idx] );
                sprintf(szAux, "*** Retornou idUFOperadora [%s]\n", (char*)idUFOperadora[idx].arr ); oLog.logInformation(szAux);
                listaRegional.push_back( atol((char*)idUFOperadora[idx].arr) );
                flgPerfil = true;
            }
        }
        else
           break;
    }
    
    return flgPerfil;

    erroValRegionalAssoc:
        sprintf(szAux, "*** ERRO sqlca.sqlcode[%d]\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return false;
}



bool ValidaEMail( char * bf )
{
    int i;
    int tambf;
    int chk = 0;
    alltrim( bf );
    tambf = strlen( bf );
    for ( i=0;i<tambf;i++)
    {
        if ( bf[i] == '@' )
           chk++;
        if ( bf[i] == '.' )
           chk++;
        if ( chk > 1 )
           return true;
    }
    return false;

}



bool ValidaNumerico( char * bf )
{
	int i;
	int tambf;
	alltrim( bf );
	tambf = strlen( bf );
	for ( i=0;i<tambf;i++)
	{
		if ( !isdigit(bf[i]) )
		   return false;
	}
	return true;
	
}



bool ValidaNota( char * bf )
{
	int i;
	int tambf;
	alltrim( bf );
	tambf = strlen( bf );
	for ( i=0;i<tambf;i++)
	{
		if ( !isdigit(bf[i]) )
		   return false;
	}
	if ( atoi(bf) < 0 ) return false;
	if ( atoi(bf) > 10 ) return false;
	
	return true;
	
}



char * alltrim( char * pszString )
{
    ltrim(pszString);
    rtrim(pszString);
    return pszString;
}

char * ltrim( char * pszString )
{
    unsigned int iPos;
    unsigned int iLen;
    char *pszTmp, *pszAlocado;

    iLen=strlen(pszString);

    pszAlocado = (char *)malloc(iLen + 1);
    
    strcpy(pszAlocado, pszString);

    pszTmp=pszAlocado;
    

    for(iPos=0; iPos < iLen; iPos++)
        if(pszString[iPos] == 0x20)
            pszTmp++;
        else
            break;

    strcpy(pszString, pszTmp);
    
    free(pszAlocado);
    return pszString;
}



char * rtrim( char * pszString )
{
    int iPos;

    for(iPos=strlen(pszString)-1; iPos >= 0; iPos--)
        if(pszString[iPos] == 0x20)
            pszString[iPos] = 0x00;
        else
            break;
    return pszString;
}



void findFileType( char *path, string &arquivo, char *type)
{
    DIR *dirp;
    struct dirent *dp;
    char nameLog[1024];
	char nmArquivo[512];
	char exten[5];

    // inicializando nameLog
    memset(nameLog,0,sizeof(nameLog));

    // copiando o path
    arquivo = path;

    // vai abrir o diretório
    if ((dirp = opendir(path)) == NULL) {
        oLog.logError("Erro ao abrir diretório");
        return;
    }

    do {
        if ((dp = readdir(dirp)) != NULL) {
            sprintf(nameLog,"encontrado: %s size = %d\n", dp->d_name, sizeof(dp->d_name));     
			strcpy( nmArquivo, dp->d_name );
			sprintf( exten, "%s", (char*)&nmArquivo[strlen(dp->d_name)-4] );
             if((!memcmp(exten,type,4))) {
                arquivo += "/";
                arquivo += dp->d_name;
                closedir(dirp);
                return;
             }
        }
    } while (dp != NULL);

    closedir(dirp);
}



void RemoveHistoricoArq( char *path, int DataLimite )
{
    DIR *dirp;
    struct dirent *dp;
    char nameLog[1024];
	char nmArquivo[512];
	char Data_Arquivo[16];

    // inicializando nameLog
    memset(nameLog,0,sizeof(nameLog));

    if ((dirp = opendir(path)) == NULL) {
        oLog.logError("Erro ao abrir diretório");
        return;
    }

    do 
	{
        if ((dp = readdir(dirp)) != NULL) 
		{
		    if ( strlen(dp->d_name) < 9 )
			{
			   continue;
			}
			//sprintf( nameLog, "))) Encontrou arquivo [%s]\n", dp->d_name ); oLog.logDebug(nameLog);
			
			sprintf( Data_Arquivo, "%.*s", 8, (char*)&dp->d_name[strlen(dp->d_name)-19] );
			//sprintf( nameLog, "@@@ Data do arquivo [%s]\n", Data_Arquivo ); oLog.logDebug(nameLog);
			//sprintf( nameLog, "@@@ Data limite do arquivo [%d]\n", DataLimite ); oLog.logDebug(nameLog);
			
			if ( DataLimite > atoi(Data_Arquivo) )
			{
				//sprintf( nameLog, "))) Removendo arquivo [%s]\n", dp->d_name ); oLog.logDebug(nameLog);
				unlink( dp->d_name );
			}
        }
    } while (dp != NULL);

    closedir(dirp);
}



void RetiraMultiplosEspacos( char * pszString )
{
    register unsigned int iPosOrigem, iPosDestino;
    unsigned int iLen;
    char *pszTmp;

    iLen=strlen(pszString);

    if((pszTmp = (char *)malloc(iLen + LEN_EOS)) == NULL)
        throw "CSafePointer::RetiraMultiplosEspacos():Falha na alocação de memória";

    memset(pszTmp, 0x00, iLen + LEN_EOS);

    for(iPosOrigem=iPosDestino=0; iPosOrigem<iLen; iPosOrigem++)
        if(pszString[iPosOrigem] == 0x20 && pszString[iPosOrigem + 1] == 0x20)
            continue;
        else
            pszTmp[iPosDestino++] = pszString[iPosOrigem];

    strcpy(pszString, pszTmp);

    free(pszTmp);
}



void NormalizaNome( char * pszString )
{
    alltrim( pszString );
    RetiraMultiplosEspacos( pszString );
}



void DesmembraNome( TDesmembraNome * ptDesmembraNome )
{
    struct TNomeAux {
        char szParteDoNome[LEN_NOME + LEN_EOS];
        struct TNomeAux *ptNomeNext;
    } *ptNomeAux=NULL, *ptNomeAtual=NULL, *ptNomeNovo=NULL;
    char szAux[LEN_NOME + LEN_EOS], *pszAux;

    strcpy(szAux, ptDesmembraNome->szNomeCompleto);

    NormalizaNome(szAux);

    ptDesmembraNome->szNomePrimeiro[0] = ptDesmembraNome->szNomeMeio[0] = ptDesmembraNome->szNomeFim[0] = 0x00;


    for(pszAux = strtok(szAux, " "); pszAux != NULL; pszAux = strtok(NULL, " "))
    {
        /* Aloca memoria para o fragmento da parte do nome */
        if((ptNomeNovo = (struct TNomeAux *)malloc(sizeof(struct TNomeAux))) == NULL)
        throw "CSafePointer::DesmembraNome():Falha na alocação de memória";

        /* Processo da lista encadeada */
        if(ptNomeAux == NULL)
            ptNomeAux = ptNomeNovo;
        else
        {
            ptNomeAtual = ptNomeAux;
            while(ptNomeAtual->ptNomeNext != NULL)
                ptNomeAtual=ptNomeAtual->ptNomeNext;

            ptNomeAtual->ptNomeNext = ptNomeNovo;
        }

        /* Copia a parte desmembrada do nome */
        strcpy(ptNomeNovo->szParteDoNome, pszAux);
        ptNomeNovo->ptNomeNext=NULL;

        ptNomeAtual=ptNomeNovo;
    }

    /* Copia o PrimeiroNome */
    ptNomeAtual = ptNomeAux;
    if(ptNomeAtual != NULL)
    {
        strcpy(ptDesmembraNome->szNomePrimeiro, ptNomeAtual->szParteDoNome);
        ptNomeAtual = ptNomeAtual->ptNomeNext;
    }

    /* Copia o(s) Nome(s) do Meio */
    while(ptNomeAtual != NULL && ptNomeAtual->ptNomeNext != NULL)
    {
        strcat(ptDesmembraNome->szNomeMeio, ptNomeAtual->szParteDoNome);

        ptNomeAtual = ptNomeAtual->ptNomeNext;

        if(ptNomeAtual->ptNomeNext != NULL)
            strcat(ptDesmembraNome->szNomeMeio, " ");
    }

    /* Copia o UltimoNome */
    if(ptNomeAtual != NULL)
        strcpy(ptDesmembraNome->szNomeFim, ptNomeAtual->szParteDoNome);

    /* Desaloca memoria da lista encadeada */
    ptNomeAtual = ptNomeAux;
    while(ptNomeAtual != NULL)
    {
        ptNomeAtual = ptNomeAux->ptNomeNext;
        free(ptNomeAux);
        ptNomeAux = ptNomeAtual;
    }
}
