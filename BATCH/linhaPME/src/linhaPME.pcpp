
#include "../include/linhaPME.h"

#include "../../commons/Propriedade/include/MFile.h"
#include "../../commons/Log/include/Log.h"
#include "../../commons/SplitLine.h"

extern int    DBConnect(char *pUsr, char *pPwd, char *pInst);
extern void   DBDisconnect(void);
extern int    ObtemParamConf(TParamConf *ptParamConf);
extern void   moverArquivo( const char *pszNomeArquivoOrigem, const char *pszNomeArquivoDestino );
extern void   BuscaArquivoProcessar( char * nmArquivoProc );
extern void   ToStr( char * bf );
extern void   t_start( void );
extern void   t_stop( void );
extern double t_getrtime( void );
extern void   termination_handler( int signum );
extern void   LimpaHistorico( void );

#define strToOra(vchar,bstr)   vchar.len = strlen(bstr);strncpy((char *)vchar.arr,bstr,vchar.len);vchar.arr[vchar.len] = 0

EXEC SQL INCLUDE SQLCA;

Log oLog;


int main ( int argc, char *argv[] )
{
    t_start();
    
    struct tm tim;
    time_t now;
    double seg;
    char   bf[32];
    int    retorno = 0;
    char   nmArquivoProc[256];
    char   pattern[256];
    char   cmdLoader[256];
    char   szBuffer[1024];
    char   nmOrigem[256];
    char   nmDestino[256];
    char   nmDescarte[256];
    char   szAux[512];
    bool   flagProcessou = false;

    TParamConf tParamConf;
    FILE * fp;
	FILE *pini;
    long size = 0;

    memset( nmArquivoProc , 0x0, sizeof(nmArquivoProc) );
    memset( pattern       , 0x0, sizeof(pattern) );
    memset( cmdLoader     , 0x0, sizeof(cmdLoader) );
    memset( nmOrigem      , 0x0, sizeof(nmOrigem) );
    memset( nmDestino     , 0x0, sizeof(nmDestino) );
    memset( nmDescarte    , 0x0, sizeof(nmDescarte) );

    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR szNomeArquivoFull[101];
        VARCHAR szNomeArquivo[101];
        VARCHAR szNomeArquivoBad[101];
        VARCHAR szDsStatus[50];
        char    szlinha[50];
        char    szlinhaSeg[15];
        char    szUsrHostLogin[32];
        char    szTrunc[256];
        VARCHAR szLoader[200];
        int     qtRegistrosProc=0;
        int     qtRegistrosCarr=0;
        int     qtRegistrosDisc=0;	
        int     icounter=0;

        //controle de chamadas
        int  iCtrLoader=0;
        int  iCtrWc=0;
        short i_szLoader = -1;
    EXEC SQL END DECLARE SECTION;

    memset( szTrunc       , 0x0, sizeof(szTrunc) );
    memset( szUsrHostLogin, 0x0, sizeof(szUsrHostLogin) );
    memset( &szNomeArquivoFull, 0x0, sizeof(szNomeArquivoFull) );
    memset( &szNomeArquivo, 0x0, sizeof(szNomeArquivo) );
    memset( &szNomeArquivoBad, 0x0, sizeof(szNomeArquivoBad) );
    memset( &szDsStatus, 0x0, sizeof(szDsStatus) );
    
    oLog.setNivel(2);
    oLog.logDebug(">>>linhaPME");
    
    if ( argv[1][0] == 0x0 )
    {
        oLog.logError("*** ERRO NA CHAMADA DO BATCH");
        oLog.logError("*** VERIFIQUE CHAMADA DO SCRIPT executa.sh");
        oLog.logDebug("<<<linhaPME");
        return -1;
    }
    strcpy( szUsrHostLogin, argv[1] );

    signal( SIGTERM, termination_handler );
    signal( SIGSTOP, termination_handler );
    signal( SIGQUIT, termination_handler );
    signal( SIGKILL, termination_handler );
    
    // parametros de configuração
    if ( ObtemParamConf( &tParamConf ) )
    {
        oLog.logError("Erro obtendo parametros de configuracao");
        oLog.logDebug("<<<linhaPME");
        return -1;
    }

    oLog.logDebug("Conectando na BD...");
    if (DBConnect(tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst))
    {
        oLog.logError("Erro conectando no banco de dados");
        oLog.logDebug("<<<linhaPME");
        return -1;
    }
    oLog.logDebug("Conectado na BD com sucesso...");
    
    EXEC SQL WHENEVER SQLERROR GOTO sqlError;

    EXEC SQL 
    DECLARE crsLinhaPME CURSOR FOR
    SELECT 
       NMARQUIVO,
       SUBSTR(NMARQUIVO,1,INSTR(NMARQUIVO,'.',1)-1),
       NMARQUIVO
    FROM 
       INFRA.ARQUIVOFUNCIONALIDADE Tbl
    WHERE 
       INCONTROLEPROCESSAMENTO=1
    AND 
       SGFUNCIONALIDADE='SOLAP';

    /*   Montando string SQL*Loader  */
    EXEC SQL
    SELECT 
       dsvalorparametro
    INTO 
       :szLoader:i_szLoader
    FROM 
       apoio.parametro 
    WHERE 
       cdparametro = :szUsrHostLogin;

    if ( i_szLoader != 0 )
    {
        oLog.logDebug( "*** ERRO: Tabela Apoio.Parametro deve ser configurada" );
        DBDisconnect();
        return -1;
    }
    endOraStr( szLoader );

    LimpaHistorico();
    /*
    BuscaArquivoProcessar( nmArquivoProc );
    if ( nmArquivoProc[0] == 0x0 )
    {
        oLog.logDebug( "--- Nao foram encontrados arquivos a processar" );
        t_stop();
        seg = t_getrtime();
        sprintf( bf,"Tempo de processamento: %.2f segundos",seg );
        oLog.logDebug( bf );
        oLog.logDebug( "<<<linhaPME" );
        return 0;
    }
    */

    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL open crsLinhaPME;
    while( true )
    {
        EXEC SQL FETCH crsLinhaPME INTO :szNomeArquivoFull,
                                         :szNomeArquivo,
                                         :szNomeArquivoBad;

        endOraStr(szNomeArquivoFull);
        endOraStr(szNomeArquivo);
        //marcando o arquivo
        sprintf(szAux,"Procesando Arquivo:%s",(char*)szNomeArquivoFull.arr); oLog.logDebug(szAux);
        EXEC SQL
            UPDATE INFRA.ARQUIVOFUNCIONALIDADE
            SET INCONTROLEPROCESSAMENTO=2,
                DTPROCESSAMENTO=SYSDATE
            WHERE NMARQUIVO=:szNomeArquivoFull;

        /*   Chama Procedure para TRUNCATE da tabela   */
        strcpy(szTrunc,"call linha.sp_trunclinhapme()");
        oLog.logDebug( szTrunc );
        EXEC SQL EXECUTE IMMEDIATE :szTrunc;
        
        /*
        sprintf( pattern, "%.19s", nmArquivoProc );
        oLog.logDebug( "Tratando arquivo:" );
        oLog.logDebug( pattern );
        */

        strcpy( pattern, (char*)szNomeArquivo.arr );
        oLog.logDebug( "Tratando arquivo:" );
        oLog.logDebug( pattern );

        sprintf( nmOrigem, "../data/%s.txt", pattern );
        sprintf( nmDestino, "../data/%s_PROCESSADO.txt", pattern );
        sprintf( nmDescarte, "../data/%s_DESCARTE.bad", pattern );
        moverArquivo ( nmOrigem, nmDestino );
        fp = fopen( nmDestino, "r" );
        fseek ( fp, 0, SEEK_END );
        size = ftell ( fp );
        fclose ( fp );
        if ( size > 0 )
        {
            strToOra( szNomeArquivoBad,nmDescarte );
            oLog.logDebug("Executando...");
            sprintf( cmdLoader, "%s data=%s bad=%s", (char*)szLoader.arr, nmDestino, nmDescarte );
            oLog.logDebug( cmdLoader );

            iCtrLoader = system( cmdLoader );
            if ( iCtrLoader < 0 )
            {
                oLog.logDebug(strerror(errno));
            }
            else
            {
                flagProcessou = true;
                //calculando estatisticas
                strcpy(szAux,"cat ../bin/load_linhaPME.log|grep \"Total logical records r\">relat.log");
                oLog.logDebug(szAux);
                system(szAux);
                pini=fopen("relat.log","r");
                while(!feof(pini))
                {
                    fgets(szlinha,42,pini);
                    sprintf(szlinhaSeg,"%.10s",&szlinha[31]);
                    icounter++;
                    if (icounter==1) 
                    {
                        qtRegistrosProc=atoi(szlinhaSeg);
                    }
                    else 
                    {
                        qtRegistrosDisc=atoi(szlinhaSeg);
                    }
                
                }
                fclose (pini);
                sprintf(szAux,"qtRegistrosProc:%d qtRegistrosDisc:%d",qtRegistrosProc,qtRegistrosDisc);
                oLog.logDebug(szAux);

                //finalizando processamento
                /*
                if(qtRegistrosDisc>0)//-1 nao segue regra...
                        {
                            EXEC SQL
                                SELECT SUBSTR(NMARQUIVO,1,INSTR(NMARQUIVO,'.',1)-1)||'.bad'
                            into	:szNomeArquivoBad
                            from INFRA.ARQUIVOFUNCIONALIDADE
                            WHERE NMARQUIVO=:szNomeArquivoFull;
                        }
                        endOraStr(szNomeArquivoBad);
                */
                
                EXEC SQL
                UPDATE INFRA.ARQUIVOFUNCIONALIDADE
                    SET INCONTROLEPROCESSAMENTO=3,
                        QTREGISTROSPROCESSADOS=:qtRegistrosProc,
                        QTREGISTROSDESCARTADOS=:qtRegistrosDisc,
                        DTPROCESSAMENTO=SYSDATE,
                        DSERROPROCESSAMENTO=:szDsStatus,
                        nmarquivo=:szNomeArquivoBad
                    WHERE NMARQUIVO=:szNomeArquivoFull;

            }
        }
        else
        {
            oLog.logDebug ( "--- Arquivo sem registros" );
        }
        

        now = time(NULL);
        tim = *(localtime(&now));
        strcpy( nmOrigem, "../bin/load_linhaPME.log" );
        strftime(nmDestino,40,"../log/SQLLDR_%Y%m%d_%H%M%S.log",&tim);

        moverArquivo ( nmOrigem, nmDestino );
    
    }

    // finaliza
    oLog.logDebug( "Fechando conexao com o banco" );
    DBDisconnect();
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    if ( flagProcessou == false )
    {
            oLog.logDebug ( "--- Nao existem arquivos a processar ---" );
    }

    if ( 0 == iCtrLoader )
    {
        oLog.logDebug("Processamento encerrado com sucesso...");
    }
    else
    {
        oLog.logDebug("Processamento encerrado com ERRO!");
    }

    t_stop();
    seg = t_getrtime();
    sprintf( bf,"Tempo de processamento: %.2f segundos",seg );
    oLog.logDebug(bf);

    oLog.logDebug("<<<linhaPME");

    return iCtrLoader;

    sqlError:
        sprintf(szBuffer, "*** ERRO: Processo FINALIZADO com erro ORACLE (%d)", sqlca.sqlcode); oLog.logDebug(szBuffer);
        return -1;
}



/************************************************************************************************************/
void moverArquivo ( const char *pszNomeArquivoOrigem, const char *pszNomeArquivoDestino )
{
    char szAux[1024];

    link( pszNomeArquivoOrigem, pszNomeArquivoDestino );
    unlink( pszNomeArquivoOrigem );

    oLog.logDebug(" Renomeando arquivo");
    sprintf(szAux," Origem [%s]", pszNomeArquivoOrigem); oLog.logDebug(szAux);
    sprintf(szAux," Destino [%s]", pszNomeArquivoDestino); oLog.logDebug(szAux);
}



/************************************************************************************************************/
int ObtemParamConf( TParamConf * ptParamConf )
{
    MFile mfConfig;
    SplitLine NewLinha;
    char szLinha[100 + 1];
    char szDivArq[256];
    char szDivPre[21];
    char szAux[1024];

    oLog.logDebug("Obtendo parametros de configuracao...");

    memset( ptParamConf, 0x00, sizeof(TParamConf) );
    memset( szLinha    , 0x00, sizeof(szLinha) );
    memset( szDivArq   , 0x00, sizeof(szDivArq) );
    memset( szDivPre   , 0x00, sizeof(szDivPre) );


    /* Define o arquivo de configuração */
    mfConfig.setPath("linhaPME.cfg");

    if( !mfConfig.abrir() )
    {
        oLog.logError("Erro abrindo arquivo de configuração!");
        return -1;
    }

    /* Capturando usuario, senha, path e instance de banco do arquivo */
    NewLinha.SetDiv( '=' );
    while( mfConfig.getLine(szLinha) )
    {
        NewLinha.SetLine(szLinha);
        NewLinha.GetBeforeDiv(szDivPre);
        NewLinha.GetAfterDiv(szDivArq);

        /* Verifica qual parâmetro foi encontrado. */
        if (!strcmp(szDivPre, "pwd_db"))
        {
            strncpy(ptParamConf->szPws, szDivArq, TAM_BD_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_db"))
        {
            strncpy(ptParamConf->szUsr, szDivArq, TAM_BD_USRNAME);
        }
        else if (!strcmp(szDivPre, "inst_db"))
        {
            strncpy(ptParamConf->szInst, szDivArq, TAM_BD_INST);
        }
        else if (!strcmp(szDivPre, "pwd_tux"))
        {
            strncpy(ptParamConf->szPwsTux, szDivArq, TAM_TX_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_tux"))
        {
            strncpy(ptParamConf->szUsrTux, szDivArq, TAM_TX_USRNAME);
        }
        else if (!strcmp(szDivPre, "pwd_tux_gen"))
        {
            strncpy(ptParamConf->szPwsTuxGen, szDivArq, TAM_TX_GEN);
        }
        else if (!strcmp(szDivPre, "clt_tux"))
        {
            strncpy(ptParamConf->szCltTux, szDivArq, TAM_TX_CLT);
        }
        else if (!strcmp(szDivPre, "path"))
        {
            strncpy(ptParamConf->szPath, szDivArq, _MAX_PATH);
        }
        else if (!strcmp(szDivPre, "path_togo"))
        {
            strncpy(ptParamConf->szPathToGo, szDivArq, _MAX_PATH);
        }

        memset(szLinha,  0x00, sizeof(szLinha));
        memset(szDivPre, 0x00, sizeof(szDivPre));
        memset(szDivArq, 0x00, sizeof(szDivArq));
    }

    /* Fechando o arquivo de configuracao aberto */
    mfConfig.fechar();

    ToStr( ptParamConf->szPws );
    sprintf(szAux, "ptParamConf->szPws[%s]", ptParamConf->szPws); oLog.logDebug(szAux);
    ToStr( ptParamConf->szUsr );
    sprintf(szAux, "ptParamConf->szUsr[%s]", ptParamConf->szUsr); oLog.logDebug(szAux);
    ToStr( ptParamConf->szInst );
    sprintf(szAux, "ptParamConf->szInst[%s]", ptParamConf->szInst); oLog.logDebug(szAux);
    ToStr( ptParamConf->szPwsTux );
    sprintf(szAux, "ptParamConf->szPwsTux[%s]", ptParamConf->szPwsTux); oLog.logDebug(szAux);
    ToStr( ptParamConf->szUsrTux );
    sprintf(szAux, "ptParamConf->szUsrTux[%s]", ptParamConf->szUsrTux); oLog.logDebug(szAux);
    ToStr( ptParamConf->szPwsTuxGen );
    sprintf(szAux, "ptParamConf->szPwsTuxGen[%s]", ptParamConf->szPwsTuxGen); oLog.logDebug(szAux);
    ToStr( ptParamConf->szCltTux );
    sprintf(szAux, "ptParamConf->szCltTux[%s]", ptParamConf->szCltTux); oLog.logDebug(szAux);
    ToStr( ptParamConf->szPath );
    sprintf(szAux, "ptParamConf->szPath[%s]", ptParamConf->szPath); oLog.logDebug(szAux);
    ToStr( ptParamConf->szPathToGo );
    sprintf(szAux, "ptParamConf->szPathToGo[%s]", ptParamConf->szPathToGo); oLog.logDebug(szAux);

    /* Verifica se todos os dados foram recuperados do arquivo de configuração. */
    if (strlen(ptParamConf->szInst) == 0 ||
        strlen(ptParamConf->szPwsTux) == 0 ||
        strlen(ptParamConf->szUsrTux) == 0 ||
        strlen(ptParamConf->szPwsTuxGen) == 0 ||
        strlen(ptParamConf->szPath) == 0 ||
        //strlen(ptParamConf->szPathToGo) == 0 ||
        strlen(ptParamConf->szCltTux) == 0)
    {
        oLog.logError("Dados incompletos!");
        return -1;
    }

    oLog.logDebug("Parametros de configuracao obtidos com sucesso...");
    return 0;
}



/************************************************************************************************************/
int DBConnect(char *pUsr, char *pPwd, char *pInst)
{
    char szAux[1024];
    
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[256];
    EXEC SQL END DECLARE SECTION;

    oLog.logInformation(">>>DBConnect");

    /* String de conexao */
    sprintf(connString, "%s/%s@%s", pUsr, pPwd, pInst);
    oLog.logInformation(connString);

    EXEC SQL WHENEVER SQLERROR GOTO errConn;

    EXEC SQL CONNECT :connString;

    oLog.logInformation("<<<DBConnect");

    return (sqlca.sqlcode);

errConn:
    //oLog.logInformation("<<<DBConnect [ERROR]");
    sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    return -1;
}



/************************************************************************************************************/
void DBDisconnect( void )
{
    char szAux[1024];
    
    oLog.logInformation(">>>DBDisconnect");

    EXEC SQL WHENEVER SQLERROR GOTO DBDisconnectError;
    EXEC SQL COMMIT WORK RELEASE;

    oLog.logInformation("<<<DBDisconnect");
    return;

DBDisconnectError:
    sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
}



void BuscaArquivoProcessar( char *nmArquivoProc )
{
    oLog.logInformation( ">>> BuscaArquivoProcessar()" );

    FILE *fp;
    char sRegistro[32];
    int len = 23;  // o tamanho do nome do arquivo a processar eh de 23 pos URA_YYYYMMDD_HHMISS.txt

    memset( sRegistro, 0x0, sizeof(sRegistro) );
    chdir( "../data" );
    system( "ls -car PME_*.txt > ../bin/lista.dir" );
    chdir( "../bin" );

    fp = fopen( "./lista.dir", "r" );
    if ( fp == NULL )
    {
        oLog.logInformation( "*** NAO CONSEGUIU GERAR LISTA DE ARQUIVOS A PROCESSAR" );
        oLog.logDebug(strerror(errno));
        oLog.logInformation( "<<< BuscaArquivoProcessar()" );
        return;
    }
    while( fgets( sRegistro, sizeof(sRegistro), fp ) )
    {
        ToStr( sRegistro );
        if ( strlen(sRegistro) == len && !memcmp(sRegistro, "PME_", 4) && !memcmp(&sRegistro[20], "txt", 3) ) 
        {
            strcpy( nmArquivoProc,sRegistro );
            fclose(fp);
            unlink( "./lista.dir" );
            return;
        }
        memset( sRegistro, 0x0, sizeof(sRegistro) );
    }
    fclose( fp );
    unlink( "./lista.dir" );
    
    oLog.logInformation( "<<< BuscaArquivoProcessar()" );
}



void ToStr( char * bf )
{
    char *p = bf;
    while ( *p )
    {
        if ( *p == 0x0d || *p == 0x0a )
        {
           *p = 0x0;
            break;
        }
        p++;
    }
}



void t_start( void )
{
   if ( (time_start = times(&tms_start)) == -1 )
        oLog.logDebug( strerror(errno) );
}



void t_stop( void )
{
   if ( (time_stop = times(&tms_stop)) == -1 )
        oLog.logDebug( strerror(errno) );
}



double t_getrtime( void )
{
    
    seconds = (double) (time_stop - time_start) / (double) TICKS;

    return ( seconds );
}



void termination_handler( int signum )
{
    double seg;
    char   bf[64];
    
    char buffer[512];
    oLog.logDebug( "*** TERMINANDO PROCESSAMENTO ***" );
    sprintf( buffer,"--- Recebeu signal %d", signum );
    oLog.logDebug( buffer );
    oLog.logDebug( "*** Fechando conexao com o banco de dados ***" );
    DBDisconnect();
    oLog.logDebug( "--- Processamento encerrado por solicitação do S.O." );

    t_stop();
    seg = t_getrtime();
    sprintf( bf,"Tempo de processamento: %.2f segundos",seg );
    oLog.logDebug(bf);

    oLog.logDebug("<<<linhaPME");
}



void LimpaHistorico( void )
{
    DIR *dirp = NULL;
    struct stat     statbuf;
    struct dirent *dp;
    struct tm     *tm;
    char sDataArquivo[16];

    int len = 23;  // o tamanho do nome do arquivo a processar eh de 23 pos PME_YYYYMMDD_HHMISS.txt

    EXEC SQL BEGIN DECLARE SECTION;
        char    szDataLimite[16];
    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    
    memset( szDataLimite, 0x0, sizeof(szDataLimite) );
    EXEC SQL
    select to_char(trunc(sysdate-7),'YYYYMMDD') into :szDataLimite from dual;

    chdir( "../data" );
    dirp = opendir( "./" );
    while( dp = readdir(dirp) )
    {
        if ( !memcmp(dp->d_name, "PME_", 4) ) 
        {
            sprintf( sDataArquivo, "%.8s", &dp->d_name[4] );
            if ( atoi(sDataArquivo) < atoi(szDataLimite) )
            {
                unlink(dp->d_name);
            }
        }
    }
    closedir(dirp);
    chdir( "../bin" );

}
