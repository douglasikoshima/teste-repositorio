/**
 * @modulo  Batch
 * @usecase Batch
 * @author
 * @version $Revision: 1.1.6.3 $
 * @CVS     $Author: jones $ - $Date: 2013/07/26 20:39:00 $
 **/

#include <iostream>
#include <vector>
#include <map>
#include <string>
#include <sstream>
#include <fstream>

#include "../include/importFileDadosAjato.h"
#include "../../commons/Log/include/Log.h"

/*Old Libs from C*/
#include <stdlib.h>
#include <sys/sem.h>
#include <unistd.h>

using namespace std;

EXEC SQL INCLUDE SQLCA;

#define MAX_RETRIES 			10

#define endOraStr(varstr)      	varstr.arr[varstr.len]= '\0'
#define oraToStr(bstr,vchar)   	if(!bstr) strncpy(bstr,vchar.arr,vchar.len)
#define strToOra(vchar,bstr)   	vchar.len = strlen(bstr);strncpy((char *)vchar.arr,bstr,vchar.len);vchar.arr[vchar.len] = 0
#define strconv(buffer,fonte)  	sprintf(buffer,"%d",fonte)

void UnLockSemaphore(int semid);
void LockSemaphore(int semid);
int InitSemaphore(key_t key, int nsems);
char* convertStringToCharPointer(string str);
vector<string> listFiles(string dir, string ext);
int listBadFiles(string errDir);
int obterParameters();
int DBConnect();
int DBDisconnect();

//Globais
Log oLog;
//TParamConf tParamConf;
map<string,string> tParamConf;
stringstream strAux;

int main(int argc, char* argv[])
{
    oLog.setNivel(2); //Nivel 2 = Debug

    oLog.logDebug(">>>importFileDadosAjato");


    oLog.logDebug("Obtendo Parametros...");
	if(obterParameters() == -1)
	{
		oLog.logError("Erro obtendo parametros de configuracao!");
		return -1;
	}
	oLog.logDebug("Parametros Obtidos...");

	oLog.logDebug("Conectando na BD...");
	if (DBConnect() == -1)
	{
		oLog.logError("Erro conectando no banco de dados!");
		return -1;
	}
	oLog.logDebug("Conectado na BD com sucesso...");

	oLog.logDebug("Inicio da carga...\n");

    vector<string> filesTxt = listFiles(tParamConf["path"], "txt");
    vector<string>::iterator it = filesTxt.begin();
    if(filesTxt.size() == 0)
	{
		oLog.logDebug("Não há arquivos a serem processados!");
	}
	while(it != filesTxt.end())
	{
		string file = *it;

		strAux.str("");strAux << "Exetutando arquivo " << file; oLog.logDebug(convertStringToCharPointer(strAux.str()));

		stringstream command;
		command.str("");command << "sqlldr " << tParamConf["usr_db"] << "/" << tParamConf["pwd_db"] << "@" << tParamConf["inst_db"] << " DATA=" << tParamConf["path"] << file << " CONTROL=./control.ctl ERRORS=999999999";
		system(convertStringToCharPointer(command.str()));

		if(listBadFiles(tParamConf["path_err"]))
		{
			command.str("");command << "cd " << tParamConf["path_err"] << " ; mv dadosRejeitados.bad " << file.substr(0, file.find(".")) << ".bad ; cd -";
			system(convertStringToCharPointer(command.str()));

			oLog.logDebug("Erro na montagem dos dados!");

			command.str("");command << "cd " << tParamConf["path"] << " ; mv " << file << " " << file.substr(0, file.find(".")) << ".err ; cd -";
			system(convertStringToCharPointer(command.str()));
		}
		else
		{
			oLog.logDebug("Dados salvos com Sucesso!");

			command.str("");command << "cd " << tParamConf["path"] << " ; mv " << file << " " << file.substr(0, file.find(".")) << ".prc ; cd -";
			system(convertStringToCharPointer(command.str()));
		}

		it++;
	}

	oLog.logDebug("Desconectando da BD...");
	DBDisconnect();

	oLog.logDebug("Processamento encerrado");
    oLog.logDebug("<<<importFileDadosAjato");

    return 0;

    sqlError:
		strAux.str("");strAux << "MAIN > Finalizando processo com erro ORACLE (" << sqlca.sqlcode << "-" << sqlca.sqlerrm.sqlerrmc; oLog.logDebug(convertStringToCharPointer(strAux.str()));
        return -1;
}

/********************************************************************************************/
vector<string> listFiles(string dir, string ext)
{
	oLog.logDebug(">>>listFiles");

	string file;
	string data;
	stringstream command;
	vector<string> files;

	command.str("");command << "cd " << dir << " ; ls SIA_DADOSAJATO_??????????????." << ext << " > files.tmp";
	system(convertStringToCharPointer(command.str()));

	file = dir + "files.tmp";
	ifstream infile;
	infile.open(convertStringToCharPointer(file));
	if(infile)
	{
		while(true)
		{
			infile >> data;
			if(infile.eof()){
				break;
			}
			else{
				unsigned found = data.rfind("." + dir);
				if(found != string::npos)
				{
					files.push_back(data);
				}
			}
		}
	}
	else
	{
		oLog.logDebug("Erro na verificação de Arquivos!");
	}
	infile.close();

	command.str("");command << "rm " << file << " ; cd -";
	system(convertStringToCharPointer(command.str()));

	oLog.logDebug("<<<listFiles");

	return files;
}

/********************************************************************************************/
int listBadFiles(string errDir)
{
	oLog.logDebug(">>>listBadFiles");

	string file;
	string data;
	stringstream command;

	bool ret;

	file = errDir + "dadosRejeitados.bad";
	ifstream infile;
	infile.open(convertStringToCharPointer(file));
	if(infile)
	{
		ret = 1;
	}
	else
	{
		ret = 0;
	}
	infile.close();

	oLog.logDebug("<<<listBadFiles");

	return ret;
}

/********************************************************************************************/
int obterParameters()
{
	string data;

	ifstream infile("importFileDadosAjato.cfg");
	if(infile)
	{
		while(true)
		{
			if(infile.eof()) break;

			infile >> data;
			string key = data.substr(0, data.find("="));
			string val = data.substr(data.find("=") + 1, data.size());
			tParamConf.insert(pair<string,string>(key,val));
		}
	}
	else
	{
		oLog.logDebug("Erro na verificação de Arquivos!");
		return -1;
	}
	infile.close();

	map<string,string>::iterator it = tParamConf.begin();
	for(it = tParamConf.begin(); it != tParamConf.end(); ++it)
	{
		strAux.str("");strAux << "tParamConf[" << it->first << "] = " << it->second; oLog.logDebug(convertStringToCharPointer(strAux.str()));
	}

	return 0;
}

/********************************************************************************************/
int DBConnect()
{
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[256];
    EXEC SQL END DECLARE SECTION;

    // String de conexao
    stringstream conn;
    conn.str("");conn << tParamConf["usr_db"] << "/" << tParamConf["pwd_db"] << "@" << tParamConf["inst_db"];
    strcpy(connString, convertStringToCharPointer(conn.str()));

    // Marca ponto de erro
    EXEC SQL WHENEVER SQLERROR GOTO errConn;

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    // Conecta
    EXEC SQL CONNECT :connString;

    return (sqlca.sqlcode);

	errConn:
		oLog.logInformation("<<<DBConnect [ERROR]");
		return -1;
}

/************************************************************************************************************/
int DBDisconnect()
{
    EXEC SQL WHENEVER SQLERROR GOTO Error;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL COMMIT WORK RELEASE;

    return 0;

	Error:
		strAux.str("");strAux << "ERRO ORACLE -> sqlcode = " << sqlca.sqlcode << ", sqlerrmc = " << sqlca.sqlerrm.sqlerrmc; oLog.logDebug(convertStringToCharPointer(strAux.str()));
		return -1;
}

/************************************************************************************************************/
void UnLockSemaphore(int semid)
{
    struct sembuf sb;

    sb.sem_num = 0;
    sb.sem_op = 1; // free resource
    sb.sem_flg = SEM_UNDO;

    if (semop(semid, &sb, 1) == -1)
    {
        perror("semop");
        exit(1);
    }
}

/********************************************************************************************/
void LockSemaphore(int semid)
{
    struct sembuf sb;

    sb.sem_num = 0;
    sb.sem_op = -1;  // set to allocate resource
    sb.sem_flg = SEM_UNDO;

    if (semop(semid, &sb, 1) == -1)
    {
        perror("semop");
        exit(1);
    }
}

/********************************************************************************************/
int InitSemaphore(key_t key, int nsems)
{
    union semun
    {
        int val;
        struct semid_ds *buf;
        ushort *array;
    } arg;

    struct semid_ds buf;
    struct sembuf sb;
    int semid;

    semid = semget(key, nsems, IPC_CREAT | IPC_EXCL | 0666);
    if (semid >= 0)
    { // we got it first
        sb.sem_op = 1;
        sb.sem_flg = 0;
        arg.val = 1;

        for(sb.sem_num = 0; sb.sem_num < nsems; sb.sem_num++)
        {
            // do a semop() to "free" the semaphores.
            // this sets the sem_otime field, as needed below.
            if (semop(semid, &sb, 1) == -1)
            {
                int e = errno;
                semctl(semid, 0, IPC_RMID); // clean up
                errno = e;
                return -1; // error, check errno
            }
        }
    }
    else if (errno == EEXIST)
    {
        int ready = 0;

        semid = semget(key, nsems, 0); // get the id
        if (semid < 0)
            return semid; // error, check errno

        // wait for other process to initialize the semaphore:
        arg.buf = &buf;

        for(int i = 0; i < MAX_RETRIES && !ready; i++)
        {
            semctl(semid, nsems-1, IPC_STAT, arg);

            if (arg.buf->sem_otime != 0)
            {
                ready = 1;
            }
            else
            {
                sleep(1);
            }
        }
        if(!ready)
        {
            errno = ETIME;
            return -1;
        }
    }
    else
    {
        return semid; // error, check errno
    }

    return semid;
}

/********************************************************************************************/
char* convertStringToCharPointer(string str)
{
	/*
	char *c = new char[str.length() + 1];
	strcpy(c, str.c_str());
	return c;
	*/

	return const_cast<char*>(str.c_str());
}
