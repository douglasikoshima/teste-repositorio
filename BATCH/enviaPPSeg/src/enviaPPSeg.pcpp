
#include <stdio.h>
#define _POSIX_SOURCE
#include <stdlib.h>
#include <string.h>
#include <iostream.h>
#include <ctype.h>
#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <unistd.h>
#include <string>

#include <tuxfw.h>

#include <enviaPPSeg.h>

#include "../../commons/Propriedade/include/MFile.h"
#include "../../commons/Log/include/Log.h"
#include "../../commons/SplitLine.h"
#include "../../commons/Defines.h"

extern errno;

EXEC SQL INCLUDE SQLCA;

#define MAX_RETRIES     10
#define LOCK            1
#define UNLOCK          0
#define KILL            2
#define SAFE_STRNCPY(dst,src) strncpy(dst,src?src:"",sizeof(dst)-1);dst[sizeof(dst)-1]=0;

#define CONVIND(O,I) \
{\
    if (I == -1) { \
        ##O.arr[0]=0; \
    } else { \
        ##O.arr[##O.len]=0; \
    } \
}

char szAux[4096 + 1];
Log oLog;
long iErrorNumber=0;

char * replacechar(char * a);

using namespace std;

int main(int argc, char* argv[])
{
    string sAmbiente;
    char * pAmbiente;
    int WaitProc = 0;
    int MaxProc = 0;

    time_t start_t, end_t;

    int diff_t;
    int hour,min,sec; 
    int ctLinhas = 0;
    int iLidos = 0;
    
    time(&start_t);

    char *pPointer;
    char szRetMsg[2000 + 1];
    char szStatusCode[255 + 1];
    char szStatusText[255 + 1];
    char szXml[4000 + 1];
    char szXmlTmp[4000 + 1];
    char szProc[4000+1];
    int iQtdEnviosOK = 0;
    int iQtdEnviosNOK = 0;
    int iRetSendXML;

    TParamConf tParamConf;

    char buf[256];

    EXEC SQL BEGIN DECLARE SECTION;

        int  rows_proc=0;
        short   i_rows_proc = -1;
                
        VARCHAR  WaitProcTxd[3];
        short    i_WaitProcTxd;
        VARCHAR  MaxProcTxd[3];
        short    i_MaxProcTxd;
        char srv1[21];
        char srv2[21];
        VARCHAR  srv1_txd[21];
        VARCHAR  srv2_txd[21];
        short    i_srv1_txd;
        short    i_srv2_txd;

        VARCHAR  dtAtualizacao[32];
        VARCHAR  idPessoaDePara[256]; 
        VARCHAR  nrDocumento[256];
        VARCHAR  sgSegmento[256];

        short    i_dtAtualizacao;
        short    i_idPessoaDePara; 
        short    i_nrDocumento;
        short    i_sgSegmento;
        
    EXEC SQL END DECLARE SECTION;

    memset(srv1,0x0,sizeof(srv1));
    memset(srv2,0x0,sizeof(srv2));


    // Acertando o nivel de logs
    oLog.setNivel(2);
    oLog.logDebug(">>>enviaPPSeg\n");

    if(ObtemParamConf(&tParamConf)) {
        oLog.logError("Erro obtendo parametros de configuracao\n");
        exit(1);
    }

    //==========================================================================
    // Conecta
    oLog.logDebug("Conectando na BD...");
    /* Conecta no banco de dados */
    if (DBConnect(tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst)) {
        oLog.logError("Erro conectando no banco de dados\n");
        exit(1);
    }
    oLog.logDebug("Conectado na BD com sucesso...\n");

    // Direciona por qual maquina Tuxedo comecar o processamento
    strcpy( srv1, tParamConf.szSrv1Txd );
    strcpy( srv2, tParamConf.szSrv2Txd );

    EXEC SQL 
    SELECT dsvalorparametro
      INTO :srv1_txd:i_srv1_txd
      FROM APOIO.PARAMETRO
     WHERE cdparametro = :srv1;

    CONVIND( srv1_txd, i_srv1_txd );

    EXEC SQL 
    SELECT dsvalorparametro
      INTO :srv2_txd:i_srv2_txd
      FROM APOIO.PARAMETRO
     WHERE cdparametro = :srv2;

    CONVIND( srv2_txd, i_srv2_txd );

    sprintf(szAux, ">>> Servidor Tuxedo 1 [%s] >>>\n", (char*)srv1_txd.arr ); oLog.logDebug(szAux);
    sprintf(szAux, ">>> Servidor Tuxedo 2 [%s] >>>\n", (char*)srv2_txd.arr ); oLog.logDebug(szAux);

    bool bServer1 = true;
    setenv("WSNADDR",(char*)srv1_txd.arr,1);

    
    oLog.logDebug("Inicializando TUXEDO...\n");
    /* Inicializa o TUXEDO */
    if(TUXinit(&tParamConf)) {
        oLog.logError("Erro inicializando TUXEDO\n");
        exit(1);
    }
    oLog.logDebug("Inicializado com sucesso...\n");

    //==========================================================================
    // Processa
    EXEC SQL WHENEVER SQLERROR GOTO sqlError;

    
    EXEC SQL 
    SELECT dsvalorparametro
      INTO :rows_proc:i_rows_proc
      FROM apoio.parametro
     WHERE cdparametro = 'REGISTROS_PROC_ENVIAPPSEG';

    EXEC SQL DECLARE CRTEMPLINHA CURSOR FOR
    SELECT
        A.DTULTIMAALTERACAO ,  
        A.IDPESSOADEPARA ,
        A.NRDOCUMENTO
    FROM
    (
        SELECT 
            TO_CHAR(MAX(DTULTIMAALTERACAO),'DD/MM/RRRR HH24:MI:SS')  as DTULTIMAALTERACAO ,  
            IDPESSOADEPARA,
            NRDOCUMENTO
        FROM 
            CUSTOMER.PROGRAMAPONTOSEG
        GROUP BY DTULTIMAALTERACAO , IDPESSOADEPARA , NRDOCUMENTO 
    ) A
    WHERE 
        ROWNUM <= :rows_proc;

    sprintf(szAux, "*** Lendo Fila de Segmentacao para o Programa de Relacionamento ***" ); oLog.logDebug(szAux);

    EXEC SQL OPEN CRTEMPLINHA;
    for ( ;; )
    {
    
        EXEC SQL 
        SELECT dsvalorparametro
          INTO :MaxProcTxd:i_MaxProcTxd
          FROM APOIO.PARAMETRO
         WHERE cdparametro = 'MAX_REQ_TXD';

        CONVIND( MaxProcTxd,i_MaxProcTxd );

        MaxProc = atoi( (char*)MaxProcTxd.arr );

        if ( i_MaxProcTxd == -1 )
        {
            MaxProc = 20;   // Nro. Maximo de Requisicoes simultaneas
        }
        sprintf(szAux, ">>> Nro. de Requisicoes simultaneas [%d] >>>\n", MaxProc ); oLog.logDebug(szAux);
    
        EXEC SQL 
        SELECT dsvalorparametro
          INTO :WaitProcTxd:i_WaitProcTxd
          FROM apoio.parametro
        WHERE cdparametro = 'WAIT_PROC_TXD';

        CONVIND( WaitProcTxd, i_WaitProcTxd );

        WaitProc = atoi( (char*)WaitProcTxd.arr );

        if ( i_WaitProcTxd == -1 )
        {
            WaitProc = 3;   // Tempo em Segundos, para espera no processamento das requisicoes
        }
        sprintf(szAux, "}}} Tempo de Sleep [%d] {{{\n", WaitProc ); oLog.logDebug(szAux);

        //sprintf(szAux, "*** Passou 1 ***" ); oLog.logDebug(szAux);

        memset( &dtAtualizacao , 0x0, sizeof( dtAtualizacao ) );
        memset( &idPessoaDePara, 0x0, sizeof( idPessoaDePara ) );
        memset( &nrDocumento   , 0x0, sizeof( nrDocumento ) );
        memset( &sgSegmento    , 0x0, sizeof( sgSegmento ) );

        //sprintf(szAux, "*** Passou 2 ***" ); oLog.logDebug(szAux);

        EXEC SQL FETCH CRTEMPLINHA 
        INTO :dtAtualizacao:i_dtAtualizacao ,
             :idPessoaDePara:i_idPessoaDePara ,       
             :nrDocumento:i_nrDocumento ;   
            
        //sprintf(szAux, "*** Passou 3 ***" ); oLog.logDebug(szAux);

        if( sqlca.sqlcode == 1403 )
            break;
                
        CONVIND( dtAtualizacao , i_dtAtualizacao );
        CONVIND( idPessoaDePara, i_idPessoaDePara );
        CONVIND( nrDocumento   , i_nrDocumento );
        
        //sprintf(szAux, "*** Passou 4 ***" ); oLog.logDebug(szAux);
        i_sgSegmento = -1;
        EXEC SQL
        SELECT
           SEGMENTACAOCONSOLIDADA.IDSEGMETNACAOCLIENTE
        INTO
           :sgSegmento:i_sgSegmento
        FROM
           CUSTOMER.SEGMENTACAOCONSOLIDADA   SEGMENTACAOCONSOLIDADA
        WHERE
           SEGMENTACAOCONSOLIDADA.NRDOCUMENTO = :nrDocumento ;

        CONVIND( sgSegmento, i_sgSegmento );

        //sprintf(szAux, "*** Passou 5 ***" ); oLog.logDebug(szAux);
        // formata o XML para envio 
        memset(szXml, 0x00, sizeof(szXml));
        strcpy(szXml, "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>");
        strcat(szXml, "<msg><msgHdr><user>1</user><service>INTERCADPPSEG</service></msgHdr><msgBody>");
        strcpy( szProc,"<PROCEDURE>");
            strcat( szProc,"PONTOS.CADASTRO.ATUALIZASEGMENTO(");
            sprintf( szXmlTmp,"'%s',", nrDocumento.arr); strcat( szProc, szXmlTmp);
            if ( i_sgSegmento != -1 )
            {
                sprintf( szXmlTmp,"'%s',", sgSegmento.arr); strcat( szProc, szXmlTmp);
            }
            else
            {
                sprintf( szXmlTmp,"NULL," ); strcat( szProc, szXmlTmp);
            }
        sprintf( szXmlTmp,"%s,", ":O_CDERRO"); strcat( szProc, szXmlTmp);
        sprintf( szXmlTmp,"%s);", ":O_DSERRO"); strcat( szProc, szXmlTmp);
        strcat( szProc, "</PROCEDURE>");
        strcat( szXml, szProc );
            sprintf( szXmlTmp,"<idPessoaDePara>%s</idPessoaDePara>", (char*)idPessoaDePara.arr );
            strcat( szXml, szXmlTmp);
        strcat(szXml, "</msgBody></msg>");
        replacechar(szXml);
        
        //sprintf(szAux, "*** Passou 6 ***" ); oLog.logDebug(szAux);

        sprintf(szAux, "szXml[%s]", szXml); oLog.logDebug(szAux);

        memset(szRetMsg, 0x00, sizeof(szRetMsg));

        sprintf(szAux, "*** Enviando XML de Requisicao ***" ); oLog.logDebug(szAux);

        iLidos++;
        if ( iLidos > MaxProc )  
        {
            sleep( WaitProc );
            tpterm();   // Fechando Tuxedo

            if ( bServer1 == true )
            {
               setenv("WSNADDR",(char*)srv2_txd.arr,1);
               bServer1 = false;
            }
            else
            {
               setenv("WSNADDR",(char*)srv1_txd.arr,1);
               bServer1 = true;
            }

            iLidos = 0;
            oLog.logDebug("Inicializando TUXEDO CFG_2...\n");
            if(TUXinit(&tParamConf)) {
                oLog.logError("Erro inicializando TUXEDO CFG_2\n");
                exit(1);
            }
            oLog.logDebug("Inicializado CFG_2 com sucesso...\n");
        }

        iRetSendXML = sendXML( szXml,szRetMsg );
        if ( iErrorNumber != 0 )
        {
            sprintf(szAux, "*** Processou com ERRO ***" ); oLog.logDebug(szAux);

            sprintf(szAux, "iRetSendXML(%d)iErrorNumber(%d)szRetMsg[%s]\n", iRetSendXML, iErrorNumber, szRetMsg); oLog.logDebug(szAux);
            iQtdEnviosNOK++;
        }
        else
        {
            sprintf(szAux, "*** Processou OK ***" ); oLog.logDebug(szAux);
            iQtdEnviosOK++;
        }

    }// for(;;)

    //sprintf(szAux, "Foram executadas (%d) envios com ERRO.\n", iQtdEnviosNOK); oLog.logDebug(szAux);
    //sprintf(szAux, "Foram executadas (%d) envios com SUCESSO.\n", iQtdEnviosOK); oLog.logDebug(szAux);

    //oLog.logDebug("Fechando cursor...");
    EXEC SQL CLOSE CRTEMPLINHA;


    oLog.logDebug("Desconectando da BD...\n");
    DBDisconnect();

    oLog.logDebug("Finalizando conexao TUXEDO...\n");
    tpterm(); 

    oLog.logDebug("Processamento encerrado com sucesso...\n");

    time(&end_t);
    diff_t = difftime(end_t, start_t);
    hour = diff_t / 3600; 
    diff_t = diff_t % 3600; 
    min = diff_t / 60; 
    diff_t = diff_t % 60; 
    sec = diff_t; 
    
    sprintf( szAux, "---> Tempo total de execucao: %02d:%02d:%02d", hour, min, sec ); oLog.logDebug(szAux);

    oLog.logDebug("<<<enviaPPSeg\n");

    exit(0);

    sqlError:
        sprintf(szAux, "Finalizando processo com erro ORACLE (%d)\n", sqlca.sqlcode); oLog.logDebug(szAux);
        exit(1);

    /* Tratamento de erro de processamento */
    finalizaProcess:
        oLog.logDebug("Finalizando processo...\n");
        oLog.logDebug("Fechando cursor...\n");
        EXEC SQL CLOSE CRTEMPLINHA;

        oLog.logDebug("Desconectando da BD...\n");
        DBDisconnect();
        oLog.logDebug("Finalizando conexao TUXEDO...\n");
        tpterm(); 

        oLog.logDebug("<<<enviaPPSeg\n");
        exit(1);
}



/************************************************************************************************************/
int TUXinit(TParamConf *ptParamConf)
{
    TPINIT *tpInitInfo;
    int i;

    oLog.logInformation(">>>TUXinit\n");

    if((tpInitInfo = (TPINIT *)tpalloc("TPINIT", (char *)NULL, TPINITNEED(strlen(VIVO_GENERIC_PASSWORD) - 1) )) == (TPINIT *)NULL)
    return tperrno;

    strcpy(tpInitInfo->usrname, ptParamConf->szUsrTux);
    strcpy(tpInitInfo->cltname, ptParamConf->szCltTux);
    strcpy(tpInitInfo->passwd, ptParamConf->szPwsTux);
    strcpy((char *)&tpInitInfo->data, ptParamConf->szPwsTuxGen);

    i = tpinit(tpInitInfo);
    sprintf(szAux, "TPINIT: %i, TPERRNO: %i\n", i, tperrno); oLog.logDebug(szAux);

    oLog.logInformation("<<<TUXinit\n");

//    printf("TUX_USRNAME[%s]\n", TUX_USRNAME);
//    printf("TUX_CLTNAME[%s]\n", TUX_CLTNAME);
//    printf("VIVO_APP_PASSWORD[%s]\n", VIVO_APP_PASSWORD);
//    printf("VIVO_GENERIC_PASSWORD[%s]\n", VIVO_GENERIC_PASSWORD);

    if (i == -1)
        return 1;
    else  
        return 0;
}



/************************************************************************************************************/
int sendXML( char * pXmlSaida, char * pRetMsg ) 
{
    char *sendbuf, *rcvbuf;
    long sendlen, rcvlen;

    sendlen = strlen(pXmlSaida);

    // sprintf(szAux, "Tamanho da msg = (%d)\n", sendlen); oLog.logInformation(szAux);

    //sprintf(szAux, "*** Passo 10 ***" ); oLog.logDebug(szAux);

    if((sendbuf = (char *) tpalloc("STRING", NULL, sendlen+1)) == NULL) 
    {
        oLog.logError("Error allocating send buffer\n");
        tpterm();

        return -1;
    }

    //sprintf(szAux, "*** Passo 11 ***" ); oLog.logDebug(szAux);
    if((rcvbuf = (char *) tpalloc("STRING", NULL, sendlen+1)) == NULL) 
    {
        oLog.logError("Error allocating receive buffer\n");
        tpfree(sendbuf);
        tpterm();

        return -1;
    }

    strcpy(sendbuf, pXmlSaida);

    //sprintf(szAux, "*** Passo 12 ***" ); oLog.logDebug(szAux);
    if(tpacall("INTERCADPPSEG", (char *)sendbuf, sendlen, TPNOTRAN|TPNOREPLY ) == -1) 
    {
        sprintf(szAux, "Tperrno = %d\n", tperrno); oLog.logError(szAux);
        sprintf(szAux, "rcvbuf [%s]\n", rcvbuf); oLog.logError(szAux);

        iErrorNumber=tperrno;
        strcpy(pRetMsg, rcvbuf);

        tpfree(sendbuf);
        tpfree(rcvbuf);

        return 1;
    }

    iErrorNumber=0;
    strcpy(pRetMsg, rcvbuf);

    tpfree(sendbuf);
    tpfree(rcvbuf);

    return 0;
}




/************************************************************************************************************/
int ObtemParamConf(TParamConf *ptParamConf)
{
    MFile mfConfig;
    SplitLine NewLinha;
    char szLinha[81];
    char szDivArq[256];
    char szDivPre[21];

    oLog.logDebug("Obtendo parametros de configuracao...\n");

    /* Zera variáveis */
    memset(ptParamConf, 0x00, sizeof(TParamConf));
    memset(szLinha, 0x00, sizeof(szLinha));
    memset(szDivArq, 0x00, sizeof(szDivArq));
    memset(szDivPre, 0x00, sizeof(szDivPre));


    /* Define o arquivo de configuração */
    mfConfig.setPath("enviaPPSeg.cfg");

    /* Verificar se conseguiu abrir o arquivo */
    if(!mfConfig.abrir()) {
        oLog.logError("Erro abrindo arquivo de configuração!\n");
        return -1;
    }

    /* Capturando usuario, senha, path e instance de banco do arquivo */
    NewLinha.SetDiv('=');
    while(mfConfig.getLine(szLinha) != 0)
    {
        NewLinha.SetLine(szLinha);
        NewLinha.GetBeforeDiv(szDivPre);
        NewLinha.GetAfterDiv(szDivArq);

        /* Verifica qual parâmetro foi encontrado. */
        if (!strcmp(szDivPre, "pwd_db"))
        {
            strncpy(ptParamConf->szPws, szDivArq, 10);
        }
        else if (!strcmp(szDivPre, "usr_db"))
        {
            strncpy(ptParamConf->szUsr, szDivArq, 10);
        }
        else if (!strcmp(szDivPre, "inst_db"))
        {
            strncpy(ptParamConf->szInst, szDivArq, 20);
        }
        else if (!strcmp(szDivPre, "pwd_tux"))
        {
            strncpy(ptParamConf->szPwsTux, szDivArq, 10);
        }
        else if (!strcmp(szDivPre, "usr_tux"))
        {
            strncpy(ptParamConf->szUsrTux, szDivArq, 10);
        }
        else if (!strcmp(szDivPre, "pwd_tux_gen"))
        {
            strncpy(ptParamConf->szPwsTuxGen, szDivArq, 10);
        }
        else if (strcmp(szDivPre, "clt_tux")==0)
        {
            strncpy(ptParamConf->szCltTux, szDivArq, 10);
        }
        else if (strcmp(szDivPre, "srv1_tux")==0)
        {
            strcpy( ptParamConf->szSrv1Txd, szDivArq );
        }
        else if (strcmp(szDivPre, "srv2_tux")==0)
        {
            strcpy( ptParamConf->szSrv2Txd, szDivArq );
        }

        memset(szLinha,  0x00, sizeof(szLinha));
        memset(szDivPre, 0x00, sizeof(szDivPre));
        memset(szDivArq, 0x00, sizeof(szDivArq));
    }

    /* Fechando o arquivo de configuracao aberto */
    mfConfig.fechar();

    //sprintf(szAux, "ptParamConf->szPws[%s]\n", ptParamConf->szPws); oLog.logInformation(szAux);
    sprintf(szAux, "ptParamConf->szUsr[%s]\n", ptParamConf->szUsr); oLog.logInformation(szAux);
    sprintf(szAux, "ptParamConf->szInst[%s]\n", ptParamConf->szInst); oLog.logInformation(szAux);
    //sprintf(szAux, "ptParamConf->szPwsTux[%s]\n", ptParamConf->szPwsTux); oLog.logInformation(szAux);
    sprintf(szAux, "ptParamConf->szUsrTux[%s]\n", ptParamConf->szUsrTux); oLog.logInformation(szAux);
    //sprintf(szAux, "ptParamConf->szPwsTuxGen[%s]\n", ptParamConf->szPwsTuxGen); oLog.logInformation(szAux);
    sprintf(szAux, "ptParamConf->szCltTux[%s]\n", ptParamConf->szCltTux); oLog.logInformation(szAux);

    /* Verifica se todos os dados foram recuperados do arquivo de configuração. */
    if (strlen(ptParamConf->szInst) == 0 ||
        strlen(ptParamConf->szPwsTux) == 0 ||
        strlen(ptParamConf->szUsrTux) == 0 ||
        strlen(ptParamConf->szPwsTuxGen) == 0 ||
        strlen(ptParamConf->szCltTux) == 0 )
    {
        oLog.logError("Dados incompletos!\n");
        return -1;
    }


    oLog.logDebug("Parametros de configuracao obtidos com sucesso...\n");
    return 0;
}



/************************************************************************************************************/
int DBConnect(char *pUsr, char *pPwd, char *pInst)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[256];
    EXEC SQL END DECLARE SECTION;

    //oLog.logInformation(">>>DBConnect\n");

    /* String de conexao */
    sprintf(connString, "%s/%s@%s", pUsr, pPwd, pInst);

    /* Marca ponto de erro */
    EXEC SQL WHENEVER SQLERROR GOTO errConn;

    /* Conecta */
    EXEC SQL CONNECT :connString;

    //oLog.logInformation("<<<DBConnect\n");

    return (sqlca.sqlcode);
    
errConn:
    sprintf(szAux, "####### ERRO ORACLE [%d] MSG: [%s] #######\n", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc ); oLog.logDebug(szAux);
    return -1;
}




/************************************************************************************************************/
void DBDisconnect(void)
{
    //oLog.logInformation(">>>DBDisconnect\n");

    EXEC SQL WHENEVER SQLERROR GOTO Error;
    // EXEC SQL COMMIT WORK RELEASE;

    //oLog.logInformation("<<<DBDisconnect\n");
    return;

Error:
    sprintf(szAux, "Erro! sqlca.sqlcode = %i\n", sqlca.sqlcode); oLog.logError(szAux);
    return;
}



/************************************************************************************************************/
char *ObtemParametro(char *pCdParametro)
{
    EXEC SQL BEGIN DECLARE SECTION;
        //VARCHAR oszCdParametro[255];
        char *oszCdParametro = pCdParametro;
        VARCHAR oszDsValorParametro[255+1];
    EXEC SQL END DECLARE SECTION;

    static char szDsValorParametro[255 + 1];
    struct sqlca sqlca;


    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    //STRCPY_TO_ORA(oszCdParametro, pCdParametro);

    EXEC SQL 
        SELECT dsvalorparametro
          INTO :oszDsValorParametro
          FROM apoio.parametro
         WHERE parametro.cdparametro = :oszCdParametro;

    STRCPY_FROM_ORA(szDsValorParametro, oszDsValorParametro);

    return szDsValorParametro;

    erro:
        sprintf(szAux, "Finalizando com erro sqlca.sqlcode(%d)\n", sqlca.sqlcode); oLog.logDebug(szAux);
        exit(-1);

    naoexiste:
        sprintf(szAux, "Chave pesquisada nao encontrada[%s]\n", pCdParametro); oLog.logDebug(szAux);
        return NULL;
}

char * replacechar(char * a)
{
    while(*a!='\0')
    {
        if(*a=='&')
        *a=' ';
        a++;
    }
    
    sprintf(szAux, " replacechar() RETORNO (%s) ....\n",  a); oLog.logDebug(szAux);
    
    return a;
}
