#include <sys/time.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <iostream.h>
#include <ctype.h>

#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

#ifndef WIN32
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include  <sys/types.h>
#include  <netinet/in.h>
#include <arpa/inet.h>
#endif // AIX

#ifndef WIN32
#include <unistd.h>
#endif

#include "../include/enviaProtocoloSms.h"
#include "../../commons/Propriedade/include/MFile.h"
#include "../../commons/Log/include/Log.h"
#include "../../commons/SplitLine.h"

#include <string>
using namespace std;

EXEC SQL INCLUDE SQLCA;


using namespace std;
char szAux[1024 + 1];   // Usado nas linhas de LOG
Log oLog;

int main ( int argc, char *argv[] )
{
    time_t      rawtime;
    struct tm * timeinfo;
    char        sData[32];

    int iParticao;
    int retorno;
    int max;
    int i;
    int  Lim_Max = 0;
    double startTime, endTime;
    char UsedTime[16];
    memset(UsedTime, 0x0, sizeof(UsedTime));
    startTime = getRealTime();   // Inicia cronometro de Operacao
    char sProcessoFilho[128];
    char sInstancia[64];
    char nrMaxRegs[16];         // Maximo de Registros a Processar
    char nrMaxInstancias[16];   // Maximo de Instancias removeProtocoloSms_Chld
    char sHost[32];
    char sPorta[16];    
    char sParticao[8];

    TParamConf tParamConf;
    memset( nrMaxInstancias, 0x0, sizeof(nrMaxInstancias) );
    memset( nrMaxRegs , 0x0, sizeof(nrMaxRegs) );
    memset( sParticao , 0x0, sizeof(sParticao) );

    
    
    oLog.setNivel(2);
    oLog.logDebug(">>> enviaProtocoloSms");
    
    if (argc < 3)
    {
        oLog.logDebug("*** FALTA ARGUMENTOS DE EXECUCAO ***");
        sprintf( szAux, "Uso %s [host] [porta] <NrMaximoRegistros> <NrMaximoInstancias>\n", argv[0] ); oLog.logDebug(szAux);
        endTime = getRealTime();   // Finaliza Cronometro de Operacao
        ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS.FFFF em UsedTime - Tempo Gasto 
        sprintf( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);
        oLog.logDebug("<<< enviaProtocoloSms");
        exit(1);
    }
    if (argc == 3)   // Foi passado Host da Torpedeira e Porta de acesso
    {
        strcpy (sHost, argv[1]);
        strcpy (sPorta, argv[2]);
    }
    if (argc == 4)   // foi passado argumento com Nro. Maximo de Registros a ler
    {
        strcpy (sHost, argv[1]);
        strcpy (sPorta, argv[2]);
        strcpy (nrMaxRegs, argv[3]);
        if (atoi(nrMaxRegs) < 1 || atoi(nrMaxRegs) > 500000 ) // argumento passado com valor invalido, assume
            nrMaxRegs[0] = 0x0;                               // valor parametrizado no banco
    }
    if (argc == 5)   // foi passado argumento com Nro. Maximo de Registros a ler
    {
        strcpy (sHost, argv[1]);
        strcpy (sPorta, argv[2]);
        strcpy (nrMaxRegs, argv[3]);
        if (atoi(nrMaxRegs) < 1 || atoi(nrMaxRegs) > 100000 ) // argumento passado com valor invalido, assume
            nrMaxRegs[0] = 0x0;                               // valor parametrizado no banco
        sprintf ( nrMaxInstancias, "%s", argv[4] );
        if (atoi(nrMaxInstancias) < 1 || atoi(nrMaxInstancias) > 10 ) // argumento passado com valor invalido, assume
            nrMaxInstancias[0] = 0x0;      // valor parametrizado no banco
    }

    //==========================================================================
    // Parâmetros de configuração
     if(ObtemParamConf(&tParamConf))
    {
        oLog.logError("*** ERRO AO OBTER PARAMETROS DE CONFIGURACAO ***");
        endTime = getRealTime();   // Finaliza Cronometro de Operacao
        ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS.FFFF em UsedTime - Tempo Gasto 
        sprintf( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);
        oLog.logDebug( "<<< enviaProtocoloSms" );
        exit(1);
    } 

    //==========================================================================
    // Conecta ao banco
    oLog.logDebug("### Conectando com Banco de Dados ###");
    if (DBConnect(tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst))
    {
        oLog.logError("*** ERRO DE CONEXAO AO BANCO DE DADOS ***");
        endTime = getRealTime();   // Finaliza Cronometro de Operacao
        ElapsedTime(startTime, endTime, UsedTime);   // Retorna HH:MM:SS&&& Vai Executar [.FFFF em UsedTime - Tempo Gasto 
        sprintf( szAux, "### Tempo Total de execucao: %s", UsedTime ); oLog.logDebug(szAux);
        oLog.logDebug( "<<< enviaProtocoloSms" );
        exit(1);
    } 
    
    if ( nrMaxRegs[0] == 0x0 )   // Nao foi informado por linha de comando a Qtde. de Maxima de Registros
    {
        Lim_Max = ObterParamMaxRegistros();   // Sendo assim, busca parametrizacao no banco
        sprintf (nrMaxRegs, "%d", Lim_Max);
    }
    
    if ( nrMaxInstancias[0] == 0x0 )   // Nao foi informado por linha de comando a Qtde. de Maxima de Instancias
    {
        Lim_Max = ObterParamMaxInstancia();   // Sendo assim, busca parametrizacao no banco
        sprintf (nrMaxInstancias, "%d", Lim_Max);
    }

    iParticao = ObterParamMaxParticao(); 

    oLog.logDebug( "*** Configuracao Efetuada com Sucesso ***" );
    sprintf ( szAux, "===> Nro. de Instancias ........... [%s] <===", nrMaxInstancias ); oLog.logDebug(szAux);
    sprintf ( szAux, "===> Nro. Maximo de Registros a Ler [%s] <===", nrMaxRegs ); oLog.logDebug(szAux);
    sprintf ( szAux, "===> Torpedeira ................... [%s] <===", sHost ); oLog.logDebug(szAux);
    sprintf ( szAux, "===> Porta ........................ [%s] <===", sPorta ); oLog.logDebug(szAux);
    

    max = atoi(nrMaxInstancias);
    
    time ( &rawtime );
    timeinfo = localtime ( &rawtime );
    strftime( sData, 17, "%Y%m%d-%H%M%S", timeinfo );
    for ( i=1; i <= max; i++ ) 
    {
        iParticao++;
        if ( iParticao > 64 )
            iParticao = 1;
        sprintf( sInstancia, "Instancia_%02d_%s", i, sData );
        sprintf( sParticao, "P%d", iParticao );
        sprintf( sProcessoFilho, "nohup ./enviaProtocoloSms_Chld %s %s %s %s 2>&1 >> ../log/%s.log &", sHost, sPorta, sParticao, nrMaxRegs, sInstancia );
        //sprintf ( szAux, "=> Instanciando [%s] <=", sProcessoFilho ); oLog.logDebug(szAux);
        retorno = system ( sProcessoFilho );
        if ( retorno < 0 )
        {
            sprintf ( szAux, "*** system: [%s]\n", strerror(errno) );oLog.logDebug(szAux);
        }
    }
    
    AtualizaParticao( sParticao );
    
    sprintf ( szAux, "===> Total Instanciado [%02d] <===", i-1 ); oLog.logDebug(szAux);
    oLog.logDebug( "<<< enviaProtocoloSms\n" );
    
    exit(0) ;
}



/**
 * Returns the real time, in seconds, or -1.0 if an error occurred.
 *
 * Time is measured since an arbitrary and OS-dependent start time.
 * The returned real time is only useful for computing an elapsed time
 * between two calls to this function.
 */
double getRealTime(void)
{
    /* AIX, BSD, Cygwin, HP-UX, Linux, OSX, POSIX, Solaris. ----- */
    struct timeval tm;
    gettimeofday( &tm, NULL );
    return (double)tm.tv_sec + (double)tm.tv_usec / 1000000.0;
}


/*
 *   Retorna Tempo Usado
 *   StartTime - Tempo Inicial
 *   EndTime - Tempo Final
 *   UsedTime - Tempo Gasto
 */
void ElapsedTime(double StartTime, double EndTime, char * UsedTime)
{
    int hora, minuto, segundo;

    char Tempo[16];
    char Segundos[8];
    char Miliseg[4];
    char * Result = NULL;

    sprintf ( Tempo, "%lf.", (EndTime - StartTime) );
    Result = strtok(Tempo,".");
    sprintf(Segundos,"%s", Result);
    //printf("Segundos [%s]\n",Segundos);
    Result = strtok(NULL,".");
    sprintf(Miliseg, "%.4s", Result);
    //printf("Miliseg [%s]\n",Miliseg);

    hora = (atoi(Segundos)/3600);
    minuto = (atoi(Segundos)-(3600*hora))/60;
    segundo = (atoi(Segundos)-(3600*hora)-(minuto*60));
    sprintf( UsedTime, "%02d:%02d:%02d.%s", hora, minuto, segundo, Miliseg );

}



/************************************************************************************************************/
int DBConnect(char *pUsr, char *pPwd, char *pInst)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[64];
    EXEC SQL END DECLARE SECTION;

    // String de conexao
    sprintf(connString, "%s/%s@%s", pUsr, pPwd, pInst);

    // Marca ponto de erro
    EXEC SQL WHENEVER SQLERROR GOTO errConn;

    // Conecta
    EXEC SQL CONNECT :connString;

    return 0;

errConn:
    sprintf(szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    return -1;
}



/************************************************************************************************************/
int DBDisconnect(void)
{
    EXEC SQL WHENEVER SQLERROR GOTO Error;
    EXEC SQL COMMIT WORK RELEASE;
    return 0;

Error:
    oLog.logDebug("*** ERRO AO DESCONECTAR DO BANCO ***");
    sprintf(szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    return -1;
}



/*
 *
 *  Obtem Nro. Maximo Para Reserva de Protocolos a Enviar
 *  Marcelo Nunes   - Desligue Tibco   -   Fev/2016
 *
 */
int ObterParamMaxRegistros(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
        int MaxRegs=0;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    EXEC SQL
        SELECT
            TO_NUMBER(NVL(DSVALORPARAMETRO,10000))
        INTO
            :MaxRegs
        FROM
            APOIO.PARAMETRO
        WHERE
            CDPARAMETRO = 'NR_MAX_PROTOCOLO';

    if ( MaxRegs <= 0 )
    {
        oLog.logDebug("### Parametro 'NR_MAX_PROTOCOLO' com valor inválido, assumindo valor default [10000]. ###");
        MaxRegs = 10000;
    }

    return MaxRegs;

erro:
    oLog.logDebug("*** ERRO AO OBTER VALOR MAXIMO DE REGISTROS A PROCESSAR ***");
    sprintf(szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    oLog.logDebug("*** ASSUMINDO VALOR DEFAULT [10000] ***");
    return 10000;

naoexiste:
    oLog.logDebug("*** PARAMETRO 'NR_MAX_PROTOCOLO' NAO ENCONTRADO. ASSUMINDO DEFAULT [10000]. ***");
    return 10000;
}



/*
 *
 *  Obtem Nro. Maximo de Instancias que podem executar em Paralelo
 *  Obs.: A Torpedeira Fenix aceita no Maximo 10 Conexoes Simultaneas
 *
 *  Marcelo Nunes   - Desligue Tibco   -   Fev/2016
 *
 */
int ObterParamMaxInstancia(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
        int Lim_Max=0;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    EXEC SQL
        SELECT
            TO_NUMBER(NVL(DSVALORPARAMETRO,5))
        INTO
            :Lim_Max
        FROM
            APOIO.PARAMETRO
        WHERE
            CDPARAMETRO = 'QTD_INSTANCIAS';

    if ( Lim_Max <= 0 )
    {
        oLog.logDebug("### Parametro 'NR_MAX_PROTOCOLO' com valor inválido, assumindo valor default [5]. ###");
        Lim_Max = 5;
    }

    return Lim_Max;

erro:
    oLog.logDebug("*** ERRO AO OBTER VALOR MAXIMO DE REGISTROS A PROCESSAR ***");
    sprintf(szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    oLog.logDebug("*** ASSUMINDO VALOR DEFAULT [5] ***");
    return 5;

naoexiste:
    oLog.logDebug("*** PARAMETRO 'NR_MAX_PROTOCOLO' NAO ENCONTRADO. ASSUMINDO DEFAULT [5]. ***");
    return 5;
}



/************************************************************************************************************/
int ObtemParamConf(TParamConf *ptParamConf)
{
    MFile mfConfig;
    SplitLine NewLinha;
    char szLinha[101];
    char szDivArq[256];
    char szDivPre[21];

    oLog.logDebug(">>> Obtendo parametros de configuracao...");

    // Zera variáveis
    memset(ptParamConf, 0, sizeof(TParamConf));
    memset(szLinha, 0, sizeof(szLinha));
    memset(szDivArq, 0, sizeof(szDivArq));
    memset(szDivPre, 0, sizeof(szDivPre));

    // Define o arquivo de configuração
    mfConfig.setPath("enviaProtocoloSms.cfg");

    // Verificar se conseguiu abrir o arquivo
    if(!mfConfig.abrir())
    {
        oLog.logError("!!! ERRO AO ABRIR ARQUIVO DE CONFIGURACAO !!!");
        return -1;
    }

    // Capturando usuario, senha, path e instance de banco do arquivo
    NewLinha.SetDiv('=');
    while(mfConfig.getLine(szLinha) != 0)
    {
        NewLinha.SetLine(szLinha);
        NewLinha.GetBeforeDiv(szDivPre);
        NewLinha.GetAfterDiv(szDivArq);

        // Verifica qual parâmetro foi encontrado.
        if (!strcmp(szDivPre, "pwd_db"))
        {
            strncpy(ptParamConf->szPws, szDivArq, TAM_BD_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_db"))
        {
            strncpy(ptParamConf->szUsr, szDivArq, TAM_BD_USRNAME);
        }
        else if (!strcmp(szDivPre, "inst_db"))
        {
            strncpy(ptParamConf->szInst, szDivArq, TAM_BD_INST);
        }
        memset(szLinha,  0, sizeof(szLinha));
        memset(szDivPre, 0, sizeof(szDivPre));
        memset(szDivArq, 0, sizeof(szDivArq));
    }

    // Fechando o arquivo de configuracao aberto
    mfConfig.fechar();

    sprintf(szAux, "ptParamConf->szUsr[%s]", ptParamConf->szUsr); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szInst[%s]", ptParamConf->szInst); oLog.logDebug(szAux);

    // Verifica se todos os dados foram recuperados do arquivo de configuração.
    if (strlen(ptParamConf->szInst) == 0)
    {
        oLog.logError("!!! CONFIGURACAO INCOMPLETA !!!");
        return -1;
    }

    oLog.logDebug("### Sucesso na Configuracao ###");
    return 0;
}



/*
 *
 *  Obtem Nro. Maximo Para Reserva de Protocolos a Enviar
 *  Marcelo Nunes   - Desligue Tibco   -   Marco/2016
 *
 */
int ObterParamMaxParticao( void )
{
    EXEC SQL BEGIN DECLARE SECTION;
        int MaxRegs=0;
    EXEC SQL END DECLARE SECTION;

    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexistePart;

    EXEC SQL
        SELECT
            TO_NUMBER(NVL(DSVALORPARAMETRO,1))
        INTO
            :MaxRegs
        FROM
            APOIO.PARAMETRO
        WHERE
            CDPARAMETRO = 'NRO_PARTIC_SMS';

    if ( MaxRegs <= 0 )
    {
        oLog.logDebug("### Parametro 'NRO_PARTIC_SMS' com valor inválido, assumindo valor default [1]. ###");
        MaxRegs = 1;
    }

    return MaxRegs;

erro:
    oLog.logDebug("*** ERRO AO OBTER VALOR DA PARTICAO A PROCESSAR ***");
    sprintf(szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    oLog.logDebug("*** ASSUMINDO VALOR DEFAULT [1] ***");
    return 1;

naoexistePart:
    oLog.logDebug("*** PARAMETRO 'NRO_PARTIC_SMS' NAO ENCONTRADO. ASSUMINDO DEFAULT [1]. ***");
    return 1;
}



/*
 *
 *  Obtem Nro. Maximo de Instancias que podem executar em Paralelo
 *  Obs.: A Torpedeira Fenix aceita no Maximo 10 Conexoes Simultaneas
 *
 *  Marcelo Nunes   - Desligue Tibco   -   Fev/2016
 *
 */
void AtualizaParticao( char * sParticaoPrm )
{
    EXEC SQL BEGIN DECLARE SECTION;
        char sParticao[8];
    EXEC SQL END DECLARE SECTION;

    sprintf( sParticao, "%s", (char*)&sParticaoPrm[1] );
    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR goto erroParticao;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
    UPDATE apoio.parametro
    SET dsvalorparametro = :sParticao
    WHERE cdparametro = 'NRO_PARTIC_SMS';
    
    EXEC SQL COMMIT;

    return;

erroParticao:
    oLog.logDebug("*** ERRO AO ATUALIZAR APOIO.PARAMETRO COM PARTICAO PROCESSADA ***");
    sprintf(szAux, "!!! ERRO ORACLE: [%d] - [%s]", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
    return;

}
