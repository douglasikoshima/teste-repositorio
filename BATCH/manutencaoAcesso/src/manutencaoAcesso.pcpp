/**
 * @modulo  Batch
 * @usecase Batch
 * @author
 * @version $Revision: 1.1.4.4 $
 * @CVS     $Author: a5125996 $ - $Date: 2013/04/12 13:06:21 $
 **/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <extension.h>
#include <dirent.h>
#include <iostream.h>
#include <ctype.h>
#include <fcntl.h>

#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

#define MAX_RETRIES     10

#ifndef WIN32
#include <unistd.h>
#endif

#include <libxml/xpath.h>
#include <libxml/tree.h>
#include <libxml/parser.h>
#include <libxml/debugXML.h>
#include <libxml/xmlmemory.h>
#include <libxml/tree.h>
#include <libxml/parser.h>
#include <libxml/uri.h>
#include <libxml/entities.h>
#include <libxml/valid.h>
#include <libxml/xmlerror.h>
#include <libxml/parserInternals.h>
#include <libxml/globals.h>
#include <libxml/xpathInternals.h> 

#include <tibems/tibems.h>

#include "../include/manutencaoAcesso.h"

#include "../../commons/Propriedade/include/MFile.h"
#include "../../commons/Log/include/Log.h"
#include "../../commons/SplitLine.h"

#include <string>
using namespace std;

EXEC SQL INCLUDE SQLCA;

#define CONVIND(O,I) \
{\
    if (I == -1) { \
        ##O.arr[0]=0; \
    } else { \
        ##O.arr[##O.len]=0; \
    } \
}

#define endOraStr(varstr)      varstr.arr[varstr.len]= '\0'
#define oraToStr(bstr,vchar)   if(!bstr) strncpy(bstr,vchar.arr,vchar.len)
#define strToOra(vchar,bstr)   vchar.len = strlen(bstr);strncpy((char *)vchar.arr,bstr,vchar.len);vchar.arr[vchar.len] = 0
#define strconv(buffer,fonte)  sprintf(buffer,"%d",fonte)

//==============================================================================
// Globais
char szAux[1024 + 1];
Log oLog;
int iSignalProcessa = 1;
TParamConf tParamConf;
char nomeArquivoRegistros[255];
char siglaBanco[255];

//==============================================================================
// Prot?tipos
void UnLockSemaphore(int semid);
void LockSemaphore(int semid);
int InitSemaphore(key_t key, int nsems);

int OpenDir(char *pszDiretorio,char*pfile);
int checkBadError(char *pszDiretorio);
void mudarProcesso(int cdprocesso);
void apagarLogErr();
int registraErro(int sqacesso, char *dserro);
int finalizaArquivo(char *path, int qtdErros, int qtdTotal);

//==============================================================================
// Run
int main(int argc, char* argv[])
{
    EXEC SQL BEGIN DECLARE SECTION;

        char path[255];
        
        int sqAcesso;
        
        VARCHAR szOperacao[1];
        short   i_Operacao;
        
        VARCHAR szLogin[30];
        short   i_Login;
        
        VARCHAR szNMAcesso[255];
        short   i_NMAcesso;
        
        VARCHAR szCDIdent[1];
        short   i_CDIdent;
        
        int i_IDGrupo;
        int i_IDRole;
        int i_IDPessoaUsuario;
        
        int count=0;
        int qtAcess;

    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL WHENEVER SQLERROR GOTO sqlError;

    oLog.setNivel(2); //Nivel 2 = Debug

    oLog.logDebug(">>>manutencaoAcesso");

    ArmaSinal(SIGTERM);

    //==========================================================================
    // Par?metros de configura??o
    if(ObtemParamConf(&tParamConf))
    {
        oLog.logError("Erro obtendo parametros de configuracao");
        return -1;
    }

    //==========================================================================
    // Conecta ao banco
    oLog.logDebug("Conectando na BD...");
    if (DBConnect(tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst))
    {
        oLog.logError("Erro conectando no banco de dados");
        return -1;
    }
    oLog.logDebug("Conectado na BD com sucesso...");
	
    strcpy(path, tParamConf.szPath);

    int countErro;

    while(OpenDir(path, nomeArquivoRegistros) != 0)
    {    
    	countErro = 0;

        sprintf(szAux,"Exetutando arquivo nome %s...", nomeArquivoRegistros); oLog.logDebug(szAux);
        
        oLog.logDebug("Inicio da carga...");
        
    	oLog.logDebug("Vai executar TRUNCATE");
    	EXEC SQL EXECUTE IMMEDIATE CALL LOAD.SP_TRUNCTMPACESSO() ;
    	oLog.logDebug("Executou TRUNCATE");

        char sComando[1024];
        char arquivoDat[1024];
        
        strcpy(arquivoDat, path);
        strcat(arquivoDat, nomeArquivoRegistros);
        
        sprintf(sComando,"sqlldr %s/%s@%s DATA=\\\"%s\\\" CONTROL=./control.ctl ERRORS=999999999", tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst, arquivoDat);
        sprintf(szAux,"Comando [%s] exetutando...", sComando); oLog.logDebug(szAux);
        system(sComando);
        
        oLog.logDebug("Verificando Erros Iniciais");
        if(checkBadError("../error/") < 0)
        {
            oLog.logDebug("Arquivo .BAD encontrado!!!");
            mudarProcesso(2);
            registraErro(-1, "ERRO LAYOUT");
        }
        else
        {
            int errorFound = 0;
            
            EXEC SQL WHENEVER NOT FOUND DO BREAK;
            
            EXEC SQL
            DECLARE acesso CURSOR FOR
                SELECT  SQACESSO,
                        OPERACAO, 
                        LOGIN, 
                        NMACESSO, 
                        CDIDENT 
                FROM LOAD.TMP_ACESSO
                ORDER BY SQACESSO ASC;
            
            EXEC SQL OPEN acesso;
            
            count = 0;
            
            for(;;)
            {
                count++;
                
                sqAcesso = 0;
                memset(&szOperacao, 0x0, sizeof(szOperacao));
                i_Operacao = -1;
                memset(&szLogin, 0x0, sizeof(szLogin));
                i_Login = -1;
                memset(&szNMAcesso, 0x0, sizeof(szNMAcesso));
                i_NMAcesso = -1;
                memset(&szCDIdent, 0x0, sizeof(szCDIdent));
                i_CDIdent = -1;
                
                i_IDPessoaUsuario = -1;
                i_IDGrupo = -1;
                i_IDRole = -1;
                
                qtAcess = 0;
                
                EXEC SQL
                FETCH acesso INTO :sqAcesso, :szOperacao:i_Operacao, :szLogin:i_Login, :szNMAcesso:i_NMAcesso, :szCDIdent:i_CDIdent;
                
                EXEC SQL WHENEVER NOT FOUND CONTINUE;
                
                if(i_Login == -1)
                {
                    break;
                }
                
                oLog.logDebug("Validacao dos Dados Recebidos>>>");
                
                CONVIND(szOperacao, i_Operacao);
                CONVIND(szLogin, i_Login);
                CONVIND(szNMAcesso, i_NMAcesso);
                CONVIND(szCDIdent, i_CDIdent);
                
                sprintf(szAux, "Linha Atual [OPERACAO = %s, LOGIN= %s, NMACESSO = %s, CDIDENT = %s]", (char *) szOperacao.arr, (char *) szLogin.arr, (char *) szNMAcesso.arr, (char *) szCDIdent.arr); oLog.logDebug(szAux);
                
                errorFound = 0;
                
                if(!strcmp((char *) szOperacao.arr, "A") && !strcmp((char *) szOperacao.arr, "R") && !strcmp((char *) szOperacao.arr, "L"))
                {
                    errorFound = 1;
                    registraErro(sqAcesso, "OPERACAO INVALIDA");
                }
                else
                {
                    if(!strcmp((char *) szCDIdent.arr, "G") && !strcmp((char *) szCDIdent.arr, "P"))
                    {
                        errorFound = 1;
                        registraErro(sqAcesso, "IDENTIFICACAO INVALIDA");
                    }
                    else
                    {
                        EXEC SQL
                        SELECT  IDPESSOAUSUARIO
                        INTO    :i_IDPessoaUsuario
                        FROM    ACESSO.USUARIO
                        WHERE   UPPER(NMLOGINUSUARIO) = TRIM(:szLogin)
                        AND     ROWNUM < 2;
                        
                        if(i_IDPessoaUsuario == -1)
                        {
                            errorFound = 1;
                            registraErro(sqAcesso, "LOGIN NAO ENCONTRADO");
                        }
                        else if(i_IDPessoaUsuario >= 0 && strcmp((char *) szOperacao.arr, "L") != 0)
                        {
                            if(strcmp((char *) szCDIdent.arr, "G") == 0)
                            {
                            	oLog.logDebug("Iniciar busca por GRUPO");
                            	
                                EXEC SQL
                                SELECT  IDGRUPO
                                INTO    :i_IDGrupo
                                FROM    ACESSO.GRUPO
                                WHERE   UPPER(NMGRUPO) = TRIM(:szNMAcesso);
                                
                                if(i_IDGrupo == -1)
                                {
                                    errorFound = 1;
                                    registraErro(sqAcesso, "GRUPO NAO ENCONTRADO");
                                }
                                else
                                {
                                    EXEC SQL
                                    SELECT  COUNT(1)
                                    INTO    :qtAcess
                                    FROM    ACESSO.USUARIOGRUPO
                                    WHERE   IDPESSOAUSUARIO = :i_IDPessoaUsuario
                                    AND     IDGRUPO         = :i_IDGrupo; 
                                    
                                    if(strcmp((char *) szOperacao.arr, "A") == 0 && qtAcess > 0)
                                    {
                                        errorFound = 1;
                                        registraErro(sqAcesso, "GRUPO JA RELACIONADO");
                                    }
                                    if(strcmp((char *) szOperacao.arr, "R") == 0 && qtAcess == 0)
                                    {
                                        errorFound = 1;
                                        registraErro(sqAcesso, "GRUPO JA REVOGADO");
                                    }
                                }
                            }
                            else if(strcmp((char *) szCDIdent.arr, "P") == 0)
                            {
                            	oLog.logDebug("Iniciar busca por PERFIL");
                            	
                                EXEC SQL
                                SELECT  IDROLE
                                INTO    :i_IDRole
                                FROM    ACESSO.ROLE
                                WHERE   UPPER(NMROLE) = TRIM(:szNMAcesso);
                                
                                if(i_IDRole == -1)
                                {
                                    errorFound = 1;
                                    registraErro(sqAcesso, "PERFIL NAO ENCONTRADO");
                                }
                                else
                                {
                                    EXEC SQL
                                    SELECT  COUNT(1)
                                    INTO    :qtAcess
                                    FROM    ACESSO.USUARIOROLE
                                    WHERE   IDPESSOAUSUARIO = :i_IDPessoaUsuario
                                    AND     IDROLE          = :i_IDRole; 
                                    
                                    if(strcmp((char *) szOperacao.arr, "A") == 0 && qtAcess > 0)
                                    {
                                        errorFound = 1;
                                        registraErro(sqAcesso, "PERFIL JA RELACIONADO");
                                    }
                                    if(strcmp((char *) szOperacao.arr, "R") == 0 && qtAcess == 0)
                                    {
                                        errorFound = 1;
                                        registraErro(sqAcesso, "PERFIL JA REVOGADO");
                                    }
                                }
                            }
                        }
                    }
                }
                
                oLog.logDebug("<<<Validacao dos Dados Recebidos Concluída");
                
                oLog.logDebug("Execucao dos Processos>>>");
                
                if(errorFound == 1)
                {
                    mudarProcesso(3);
                }
                else
                {
                    if(strcmp((char *) szCDIdent.arr, "G") == 0)
                    {
                        if(strcmp((char *) szOperacao.arr, "A") == 0)
                        {
                            EXEC SQL
                            INSERT INTO ACESSO.USUARIOGRUPO VALUES
                            (
                                ACESSO.USUARIOGRUPOSQ.NEXTVAL,
                                :i_IDPessoaUsuario,
                                :i_IDGrupo,
                                1,
                                SYSDATE,
                                0
                            );
                            EXEC SQL COMMIT;
                        }
                        else if(strcmp((char *) szOperacao.arr, "R") == 0)
                        {
                            EXEC SQL 
                            DELETE FROM ACESSO.USUARIOGRUPO
                            WHERE  IDPESSOAUSUARIO = :i_IDPessoaUsuario
                            AND    IDGRUPO         = :i_IDGrupo;
                            EXEC SQL COMMIT;
                        }
                        else if(strcmp((char *) szOperacao.arr, "L") == 0)
                        {
                            EXEC SQL
                            DELETE FROM ACESSO.USUARIOGRUPO
                            WHERE  IDPESSOAUSUARIO = :i_IDPessoaUsuario;
                            EXEC SQL COMMIT;
                        }
                    }
                    else if(strcmp((char *) szCDIdent.arr, "P") == 0)
                    {
                        if(strcmp((char *) szOperacao.arr, "A") == 0)
                        {
                            EXEC SQL
                            INSERT INTO ACESSO.USUARIOROLE VALUES
                            (
                                ACESSO.USUARIOGRUPOSQ.NEXTVAL,
                                :i_IDPessoaUsuario,
                                :i_IDRole,
                                1,
                                SYSDATE
                            );
                            EXEC SQL COMMIT;
                        }
                        else if(strcmp((char *) szOperacao.arr, "R") == 0)
                        {
                            EXEC SQL 
                            DELETE FROM ACESSO.USUARIOROLE
                            WHERE  IDPESSOAUSUARIO = :i_IDPessoaUsuario
                            AND    IDROLE          = :i_IDRole;
                            EXEC SQL COMMIT;
                        }
                        else if(strcmp((char *) szOperacao.arr, "L") == 0)
                        {
                            EXEC SQL
                            DELETE FROM ACESSO.USUARIOROLE
                            WHERE  IDPESSOAUSUARIO = :i_IDPessoaUsuario;
                            EXEC SQL COMMIT;
                        }
                    }
                    
                }
                
                oLog.logDebug("<<<Execucao dos Processos");
                
                EXEC SQL WHENEVER NOT FOUND DO BREAK;
            }
            
            EXEC SQL CLOSE acesso;
            
            EXEC SQL WHENEVER NOT FOUND CONTINUE;
            
            strcpy(tParamConf.szPath, path);
            countErro = registraErro(0, "FINALIZA ERROS");

            if(countErro == 0)
            {
            	mudarProcesso(4);
            }
        }

        	char nmarq[256]={0};
        	strcat(nmarq, tParamConf.szPath);
        	strcat(nmarq, nomeArquivoRegistros);
            finalizaArquivo(nmarq, countErro, (count - 1));
        }
    /*********************************************************************************/
        
    apagarLogErr();

    oLog.logDebug("Desconectando da BD...");
    DBDisconnect();

    oLog.logDebug("Processamento encerrado");
    oLog.logDebug("<<<manutencaoAcesso");

    return 0;

    sqlError:
        sprintf(szAux, "MAIN > Finalizando processo com erro ORACLE (%d-%.256s)", sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);

        EXEC SQL ROLLBACK;

    	char nmarq[256]={0};
    	strcat(nmarq, tParamConf.szPath);
    	strcat(nmarq, nomeArquivoRegistros);
        finalizaArquivo(nmarq, countErro, (count - 1));

        oLog.logDebug("Vai tentar desconectar da BD...");
        DBDisconnect();

        return -1;
}

/************************************************************************************************************/
void mudarProcesso(int cdprocesso)
{
    oLog.logDebug("Mudar Processo>>>");
    
    EXEC SQL BEGIN DECLARE SECTION;
        
        VARCHAR szFileName[255];
        int i_StatusCarga;

    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL WHENEVER SQLERROR GOTO errProcess;
    
    strToOra(szFileName, nomeArquivoRegistros);
    i_StatusCarga = cdprocesso;
    
    sprintf(szAux, "Alterando STATUS_CARGA para [%d] onde NOME_ARQUIVO = [%s]", i_StatusCarga, (char *) szFileName.arr);oLog.logDebug(szAux);
    
    EXEC SQL
    UPDATE ACESSO.MANUTENCAOLOGINACESSO
    SET    STATUS_CARGA = :i_StatusCarga
    WHERE  UPPER(TRIM(NOME_ARQUIVO)) = UPPER(TRIM(:szFileName));
    EXEC SQL COMMIT;
    
    oLog.logDebug("<<<Mudar Processo");
    
    return;
    
    errProcess:
        oLog.logDebug("Excecao ao alterar dados do Processo!");
        sprintf(szAux, "MUDARPROCESSO > ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
        oLog.logDebug("<<<Mudar Processo");
        
        EXEC SQL ROLLBACK;
}

/************************************************************************************************************/
void apagarLogErr()
{
    EXEC SQL BEGIN DECLARE SECTION;

        int i_TempoManutencaoLoginAcesso;
        int i_IdManutencaoLA;
        VARCHAR szFileErrName[255];
        short   i_FileErrName;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR GOTO sqlApagaLogErr;

    i_TempoManutencaoLoginAcesso = 0;
    i_IdManutencaoLA = 0;
    memset(&szFileErrName, 0x0, sizeof(szFileErrName));
    i_FileErrName = -1;

    EXEC SQL
    SELECT  DSVALORPARAMETRO
    INTO    :i_TempoManutencaoLoginAcesso
    FROM    APOIO.PARAMETRO
    WHERE   CDPARAMETRO = 'TEMPO_MANUT_LOGIN_ACESSO';

    sprintf(szAux, "Quantidade de Dias para se apagar erros antigos [%d]...", i_TempoManutencaoLoginAcesso);oLog.logDebug(szAux);

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    EXEC SQL
    DECLARE logError CURSOR FOR
            SELECT  IDMANUTENCAOLA,
                    ARQUIVO_ERR
            FROM    ACESSO.MANUTENCAOLOGINACESSO
            WHERE   DATA_PROC < SYSDATE - :i_TempoManutencaoLoginAcesso
            AND     ARQUIVO_ERR IS NOT NULL
            ORDER BY IDMANUTENCAOLA ASC;

    EXEC SQL OPEN logError;

    for(;;)
    {
        EXEC SQL
        FETCH logError INTO :i_IdManutencaoLA, :szFileErrName:i_FileErrName;

        EXEC SQL WHENEVER NOT FOUND CONTINUE;

        if(i_FileErrName > -1)
        {
            EXEC SQL
            UPDATE      ACESSO.MANUTENCAOLOGINACESSO
            SET         ARQUIVO_ERR     = '<EXPIRADO>'
            WHERE       IDMANUTENCAOLA  = :i_IdManutencaoLA;
            EXEC SQL COMMIT;

            sprintf(szAux, "rm \"%s\"", (char *) szFileErrName.arr);oLog.logDebug(szAux);
            system(szAux);
        }

        EXEC SQL WHENEVER NOT FOUND CONTINUE;
    }

    EXEC SQL CLOSE logError;

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    oLog.logDebug("<<<apagarLogError");

    return;

    sqlApagaLogErr:
        oLog.logDebug("Excecao ao alterar dados do Processo!");
        sprintf(szAux, "APAGARLOGERR > ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
        oLog.logDebug("<<<apagarLogError");

        EXEC SQL ROLLBACK;
}

/************************************************************************************************************/
void ArmaSinal(int iSignal)
{
    sprintf(szAux, "Armando tratamento para Signal(%d)", iSignal); oLog.logInformation(szAux);

    if(signal((iSignal), ProcessaSinal) == SIG_ERR)
    {
        fprintf(stderr, "ERRO ARMANDO SINAL!!!");
        exit(-1);
    }
}

/************************************************************************************************************/
void ProcessaSinal(int iSig)
{
    sprintf(szAux, "iSig(%d)", iSig); oLog.logInformation(szAux);
    
    EXEC SQL BEGIN DECLARE SECTION;
        
        int iCtrl = 0;

    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL WHENEVER SQLERROR GOTO errSig;
    
    iCtrl = iSig;
    
    EXEC SQL
    UPDATE APOIO.PARAMETRO
    SET DSVALORPARAMETRO = :iCtrl
    WHERE CDPARAMETRO = 'INPROCESSACARGABANCOSPR';

    EXEC SQL COMMIT;

    // rearma o mesmo sinal lan?ado
    ArmaSinal(iSig);

    if(iSig == SIGTERM)
    {
        oLog.logInformation("Finalizando processamento via sinal....");
        iSignalProcessa = 0;
    }
    
    errSig:
        
        oLog.logDebug("PROCESSASINAL > Excecao ao salvar dados do Sinal!");
        sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
        
}

/************************************************************************************************************/
int ObtemParamConf(TParamConf *ptParamConf)
{
    MFile mfConfig;
    SplitLine NewLinha;
    char szLinha[101];
    char szDivArq[256];
    char szDivPre[21];

    oLog.logDebug("Obtendo parametros de configuracao...");

    // Zera vari?veis
    memset(ptParamConf, 0, sizeof(TParamConf));
    memset(szLinha, 0, sizeof(szLinha));
    memset(szDivArq, 0, sizeof(szDivArq));
    memset(szDivPre, 0, sizeof(szDivPre));

    // Define o arquivo de configura??o
    mfConfig.setPath("manutencaoAcesso.cfg");

    // Verificar se conseguiu abrir o arquivo
    if(!mfConfig.abrir())
    {
        oLog.logError("Erro abrindo arquivo de configuracao!");
        return -1;
    }

    // Capturando usuario, senha, path e instance de banco do arquivo
    NewLinha.SetDiv('=');
    while(mfConfig.getLine(szLinha) != 0)
    {
        NewLinha.SetLine(szLinha);
        NewLinha.GetBeforeDiv(szDivPre);
        NewLinha.GetAfterDiv(szDivArq);

        // Verifica qual par?metro foi encontrado.
        if (!strcmp(szDivPre, "pwd_db"))
        {
            strncpy(ptParamConf->szPws, szDivArq, TAM_BD_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_db"))
        {
            strncpy(ptParamConf->szUsr, szDivArq, TAM_BD_USRNAME);
        }
        else if (!strcmp(szDivPre, "inst_db"))
        {
            strncpy(ptParamConf->szInst, szDivArq, TAM_BD_INST);
        }
        else if (!strcmp(szDivPre, "pwd_tux"))
        {
            strncpy(ptParamConf->szPwsTux, szDivArq, TAM_TX_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_tux"))
        {
            strncpy(ptParamConf->szUsrTux, szDivArq, TAM_TX_USRNAME);
        }
        else if (!strcmp(szDivPre, "pwd_tux_gen"))
        {
            strncpy(ptParamConf->szPwsTuxGen, szDivArq, TAM_TX_GEN);
        }
        else if (strcmp(szDivPre, "clt_tux")==0)
        {
            strncpy(ptParamConf->szCltTux, szDivArq, TAM_TX_CLT);
        }
        else if (strcmp(szDivPre, "QueueName")==0)
        {
            strncpy(ptParamConf->szQueueName, szDivArq, TAM_SZ_QUEUE_NAME);
        }
        else if (strcmp(szDivPre, "ServerUrl")==0)
        {
            strncpy(ptParamConf->szServerUrl, szDivArq, TAM_SZ_SERVER_URL);
        }
        else if (strcmp(szDivPre, "UserName")==0)
        {
            strncpy(ptParamConf->szUserName, szDivArq, TAM_SZ_USERNAME);
        }
        else if (strcmp(szDivPre, "Password")==0)
        {
            strncpy(ptParamConf->szPassword, szDivArq, TAM_SZ_PASSWORD);
        }
        else if (strcmp(szDivPre, "Pk_password")==0)
        {
            strncpy(ptParamConf->szPk_password, szDivArq, TAM_SZ_PKPASSWD);
        }
        else if(strcmp(szDivPre, "path")==0)
        {
            strncpy(ptParamConf->szPath, szDivArq, TAM_SZ_PATH);
        }

        memset(szLinha,  0, sizeof(szLinha));
        memset(szDivPre, 0, sizeof(szDivPre));
        memset(szDivArq, 0, sizeof(szDivArq));
    }

    // Fechando o arquivo de configuracao aberto
    mfConfig.fechar();

    //sprintf(szAux, "ptParamConf->szPws[%s]", ptParamConf->szPws); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szUsr[%s]", ptParamConf->szUsr); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szInst[%s]", ptParamConf->szInst); oLog.logDebug(szAux);
    //sprintf(szAux, "ptParamConf->szPwsTux[%s]", ptParamConf->szPwsTux); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szUsrTux[%s]", ptParamConf->szUsrTux); oLog.logDebug(szAux);
    //sprintf(szAux, "ptParamConf->szPwsTuxGen[%s]", ptParamConf->szPwsTuxGen); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szCltTux[%s]", ptParamConf->szCltTux); oLog.logDebug(szAux);

    sprintf(szAux, "ptParamConf->szQueueName[%s]", ptParamConf->szQueueName); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szServerUrl[%s]", ptParamConf->szServerUrl); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szUserName[%s]", ptParamConf->szUserName); oLog.logDebug(szAux);
    //sprintf(szAux, "ptParamConf->szPassword[%s]", ptParamConf->szPassword); oLog.logDebug(szAux);
    //sprintf(szAux, "ptParamConf->szPk_password[%s]", ptParamConf->szPk_password); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szPath[%s]", ptParamConf->szPath); oLog.logDebug(szAux);

    // Verifica se todos os dados foram recuperados do arquivo de configura??o.
    if (strlen(ptParamConf->szInst) == 0 ||
        strlen(ptParamConf->szPwsTux) == 0 ||
        strlen(ptParamConf->szUsrTux) == 0 ||
        strlen(ptParamConf->szPwsTuxGen) == 0 ||
        strlen(ptParamConf->szCltTux) == 0 ||
        strlen(ptParamConf->szQueueName) == 0 ||
        strlen(ptParamConf->szServerUrl) == 0 ||
        strlen(ptParamConf->szUserName) == 0 ||
        strlen(ptParamConf->szPassword) == 0 ||
        strlen(ptParamConf->szPath) == 0)
    {
        oLog.logError("Dados incompletos!");
        return -1;
    }

    oLog.logDebug("Parametros de configuracao obtidos com sucesso...");
    return 0;
}

/************************************************************************************************************/
int DBConnect(char *pUsr, char *pPwd, char *pInst)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[256];
    EXEC SQL END DECLARE SECTION;

    // String de conexao
    sprintf(connString, "%s/%s@%s", pUsr, pPwd, pInst);

    // Marca ponto de erro
    EXEC SQL WHENEVER SQLERROR GOTO errConn;

    // Conecta
    EXEC SQL CONNECT :connString;

    return (sqlca.sqlcode);

	errConn:
		oLog.logInformation("<<<DBConnect [ERROR]");
		return -1;
}

/************************************************************************************************************/
void DBDisconnect(void)
{
    EXEC SQL WHENEVER SQLERROR GOTO Error;

    EXEC SQL COMMIT WORK RELEASE;
    return;

	Error:
		sprintf(szAux, "DBDISCONNECT > ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
		return;
}

/************************************************************************************************************/
void UnLockSemaphore(int semid)
{
    struct sembuf sb;

    sb.sem_num = 0;
    sb.sem_op = 1; // free resource
    sb.sem_flg = SEM_UNDO;

    if (semop(semid, &sb, 1) == -1)
    {
        perror("semop");
        exit(1);
    }
}

/********************************************************************************************/
void LockSemaphore(int semid)
{
    struct sembuf sb;

    sb.sem_num = 0;
    sb.sem_op = -1;  // set to allocate resource
    sb.sem_flg = SEM_UNDO;

    if (semop(semid, &sb, 1) == -1)
    {
        perror("semop");
        exit(1);
    }
}

/********************************************************************************************/
/*
** InitSemaphore() -- more-than-inspired by W. Richard Stevens' UNIX Network
** Programming 2nd edition, volume 2, lockvsem.c, page 295.
*/
int InitSemaphore(key_t key, int nsems)
{
    union semun
    {
        int val;
        struct semid_ds *buf;
        ushort *array;
    } arg;

    struct semid_ds buf;
    struct sembuf sb;
    int semid;

    semid = semget(key, nsems, IPC_CREAT | IPC_EXCL | 0666);
    if (semid >= 0)
    { // we got it first
        sb.sem_op = 1;
        sb.sem_flg = 0;
        arg.val = 1;

        for(sb.sem_num = 0; sb.sem_num < nsems; sb.sem_num++)
        {
            // do a semop() to "free" the semaphores.
            // this sets the sem_otime field, as needed below.
            if (semop(semid, &sb, 1) == -1)
            {
                int e = errno;
                semctl(semid, 0, IPC_RMID); // clean up
                errno = e;
                return -1; // error, check errno
            }
        }
    }
    else if (errno == EEXIST)
    {
        int ready = 0;

        semid = semget(key, nsems, 0); // get the id
        if (semid < 0)
            return semid; // error, check errno

        // wait for other process to initialize the semaphore:
        arg.buf = &buf;

        for(int i = 0; i < MAX_RETRIES && !ready; i++)
        {
            semctl(semid, nsems-1, IPC_STAT, arg);

            if (arg.buf->sem_otime != 0)
            {
                ready = 1;
            }
            else
            {
                sleep(1);
            }
        }
        if(!ready)
        {
            errno = ETIME;
            return -1;
        }
    }
    else
    {
        return semid; // error, check errno
    }

    return semid;
}

int OpenDir(char *pszDiretorio,char*pfile)
{
    static DIR *pDir;
    static struct dirent *pDirent;
    static char szArq[512 + 1];
    static int iFlag=1;

    char szAux[1024];

    oLog.logDebug(">>> OpenDir");
    sprintf(szAux, "pszDiretorio[%s]", pszDiretorio); oLog.logDebug(szAux);

    if(iFlag == 1)
    {
        /* Abre diretorio e verifica sucesso */
        if( (pDir = opendir(pszDiretorio)) == NULL)
        {
            sprintf(szAux, "Erro abrindo diretorio [%s]. errno(%d) strerror[%s]", pszDiretorio, errno, strerror(errno)); oLog.logError(szAux);
            exit(-1);
        }

        iFlag=0;
    }

    /* Efetua a leitura dos nomes dos arquivos do diretorio */
    while((pDirent = readdir(pDir)) != NULL )
    {
        sprintf(szAux, "Arquivo obtido[%s]", pDirent->d_name); oLog.logDebug(szAux);

        /* valida arquivo */
        if((!stricmp(pDirent->d_name+strlen(pDirent->d_name)-4, ".txt")))
        {
            /* Monta path + nome do arquivo a ser processado */
            strcpy(szArq, pDirent->d_name);
            sprintf(szAux, "Arquivo validado [%s]", szArq); oLog.logDebug(szAux);
            oLog.logDebug("<<< OpenDir <NOT NULL>");
            strcpy(pfile,szArq);
            return 1;
        }
    }

    closedir(pDir);
    iFlag=1;
    oLog.logDebug("<<< OpenDir <NULL>");
    return 0;
}

int checkBadError(char *pszDiretorio)
{
    static DIR *pDir;
    static struct dirent *pDirent;
    static char szArq[512 + 1];
    static int iFlag=1;

    char szAux[1024];

    oLog.logDebug(">>> checkBadError>> Open Error Dir");
    sprintf(szAux, "pszDiretorio[%s]", pszDiretorio); oLog.logDebug(szAux);

    if(iFlag == 1)
    {
        /* Abre diretorio e verifica sucesso */
        pDir = opendir(pszDiretorio);
        if(pDir == NULL)
        {
            sprintf(szAux, "Erro abrindo diretorio [%s]. errno(%d) strerror[%s]", pszDiretorio, errno, strerror(errno)); oLog.logError(szAux);
            return -1;
        }

        iFlag=0;
    }

    /* Efetua a leitura dos nomes dos arquivos do diretorio */
    while((pDirent = readdir(pDir)) != NULL )
    {
        sprintf(szAux, "Arquivo Erro obtido[%s]", pDirent->d_name); oLog.logDebug(szAux);

        /* valida arquivo */
        if((!memcmp(pDirent->d_name+strlen(pDirent->d_name)-4, ".bad", 4)))
        {
            oLog.logDebug("<<< Open Error Dir <NOT NULL>");
            return -1;
        }
    }

    closedir(pDir);
    iFlag = 1;
    oLog.logDebug("<<< Open Error Dir <NULL>");
    return 0;
}

int registraErro(int sqacesso, char *dserro)
{
    oLog.logDebug("RegistraErro>>>");
	oLog.logDebug(dserro);
    
    EXEC SQL BEGIN DECLARE SECTION;
    
        int i_SQAcesso;
        VARCHAR szDataRejeicao[255];

        VARCHAR szDSErro[255];
        VARCHAR szDadosAcesso[1024 + 1];
        short   i_DadosAcesso;
        
        VARCHAR szFileName[255];
        VARCHAR szFileErr[255];
        
        int i;
        int count;

    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL WHENEVER SQLERROR GOTO RegErr;
    
    char errorMsg[255];
    
    memset(errorMsg, 0x0, sizeof(errorMsg));
    memset(&szDSErro, 0x0, sizeof(szDSErro));
    memset(&szFileName, 0x0, sizeof(szFileName));
    memset(&szFileErr, 0x0, sizeof(szFileErr));
    memset(&szDataRejeicao, 0x0, sizeof(szDataRejeicao));
    i_SQAcesso = -1;
    
    i_SQAcesso = sqacesso;

    if(i_SQAcesso == -1)
    {
    	EXEC SQL
        SELECT TO_CHAR(SYSDATE, 'YYYYMMDD_HH24MISS')
        INTO :szDataRejeicao
        FROM DUAL;
    	
    	/**********************************************************************************/
    	char arquivoErr[255];
        memset(arquivoErr, 0x0, sizeof(arquivoErr));
        strcat(arquivoErr, "../error/");
        strncat(arquivoErr, nomeArquivoRegistros, strlen(nomeArquivoRegistros) - 4);
        strcat(arquivoErr, "_");
        strcat(arquivoErr, (char *) szDataRejeicao.arr);
        strcat(arquivoErr, ".err");
        sprintf(szAux, "Caminho do arquivo de Erro de Layout = %s", arquivoErr); oLog.logDebug(szAux);
        sprintf(szAux, "mv \"%s\" \"%s\"", "../error/acessosRejeitados.bad", arquivoErr); oLog.logDebug(szAux);
        system(szAux);
        
        strToOra(szFileErr, arquivoErr);
        strToOra(szFileName, nomeArquivoRegistros);
        
        sprintf(szAux, "Dados a serem atualizados! ARQUIVO_ERR = [%s] onde NOME_ARQUIVO = [%s]", (char *) szFileErr.arr, (char *) szFileName.arr); oLog.logDebug(szAux);
        
        EXEC SQL
        UPDATE 	ACESSO.MANUTENCAOLOGINACESSO
        SET		ARQUIVO_ERR = :szFileErr
        WHERE  	UPPER(TRIM(NOME_ARQUIVO)) = UPPER(TRIM(:szFileName));
        EXEC SQL COMMIT;
        
        sprintf(szAux, "rm \"%s\"", "../error/acessosRejeitados.bad"); oLog.logDebug(szAux);
        system(szAux);
    }
    else if(i_SQAcesso == 0)
    {
    	EXEC SQL
        SELECT TO_CHAR(SYSDATE, 'YYYYMMDD_HH24MISS')
        INTO :szDataRejeicao
        FROM DUAL;

    	char arquivoErr[255];
        memset(arquivoErr, 0x0, sizeof(arquivoErr));
        strcat(arquivoErr, "../error/");
        strncat(arquivoErr, nomeArquivoRegistros, strlen(nomeArquivoRegistros) - 4);
        strcat(arquivoErr, "_");
        strcat(arquivoErr, (char *) szDataRejeicao.arr);
        strcat(arquivoErr, ".err");
        sprintf(szAux, "Caminho do arquivo de Erro = %s", arquivoErr); oLog.logDebug(szAux);

    	FILE *pFile;
        pFile = fopen(arquivoErr, "w");

        if (pFile != NULL)
        {
            count = 0;

            EXEC SQL
            SELECT  COUNT(1)
            INTO    :count
            FROM    LOAD.TMP_ACESSO
            WHERE   LOG_ERRO IS NOT NULL;

            sprintf(szAux, "Quantidade de linhas com Erro [%d]\n", count); oLog.logDebug(szAux);

            if(count > 0)
            {
                strToOra(szFileErr, arquivoErr);
                strToOra(szFileName, nomeArquivoRegistros);

                sprintf(szAux, "Dados a serem atualizados! ARQUIVO_ERR = [%s] onde NOME_ARQUIVO = [%s]\n", (char *) szFileErr.arr, (char *) szFileName.arr); oLog.logDebug(szAux);

                EXEC SQL
                UPDATE  ACESSO.MANUTENCAOLOGINACESSO
                SET     ARQUIVO_ERR = :szFileErr
                WHERE   UPPER(TRIM(NOME_ARQUIVO)) = UPPER(TRIM(:szFileName));
                EXEC SQL COMMIT;
            }

            for(i = 1; i <= count; i++)
            {
                sprintf(szAux, "Iteracao i = [%d]\n", i); oLog.logDebug(szAux);
                memset(&szDadosAcesso, 0x0, sizeof(szDadosAcesso));
                i_DadosAcesso = -1;

                EXEC SQL
                SELECT  SQACESSO || '|' ||
                        OPERACAO || '|' ||
                        LOGIN    || '|' ||
                        NMACESSO || '|' ||
                        CDIDENT  || '|' ||
                        LOG_ERRO
                INTO    :szDadosAcesso:i_DadosAcesso
                FROM
                (
                    SELECT AC.*, ROWNUM RN
                    FROM LOAD.TMP_ACESSO AC
                    WHERE   LOG_ERRO IS NOT NULL
                )
                WHERE RN = :i;

                sprintf(szAux, "Mensagem de Erro à ser salvo [%s] [%d]\n", (char *) szDadosAcesso.arr, i_DadosAcesso); oLog.logDebug(szAux);
                if(i_DadosAcesso > -1)
                {
                    sprintf(errorMsg, "%s\r\n", (char *) szDadosAcesso.arr);

                    fputs(errorMsg,pFile);

                    sprintf(szAux, "Erro escrito em Arquivo!\n"); oLog.logDebug(szAux);
                }
                else
                {
                    sprintf(szAux, "Erro ao selecionar linha!\n"); oLog.logDebug(szAux);
                    return -1;
                }
            }
            fclose(pFile);
            return count;
        }
        else
        {
          sprintf(szAux, "Erro ao criar *FILE!\n"); oLog.logDebug(szAux);
          return -1;
        }
    }
    else if(i_SQAcesso > 0)
    {
        strToOra(szDSErro, dserro);

        sprintf(szAux, "Variaveis p/ inserir [LOG_ERRO = %s]", (char*)szDSErro.arr); oLog.logDebug(szAux);

        EXEC SQL
        UPDATE LOAD.TMP_ACESSO
        SET    LOG_ERRO = :szDSErro
        WHERE  SQACESSO = :i_SQAcesso;
        EXEC SQL COMMIT;
    }
    
    /***********************************************************************************/

    oLog.logDebug("<<<RegistraErro");
    return 0;
    
    RegErr:
        sprintf(szAux, "Erro na montagem de arquivo de erro!"); oLog.logDebug(szAux);
        sprintf(szAux, "REGISTRA ERRO > Finalizando processo com erro ORACLE (%d-%.256s)\n", sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
        oLog.logDebug("<<<RegistraErro");
        
        EXEC SQL ROLLBACK;
        
        return -1;
}

int finalizaArquivo(char *filepath, int qtdErros, int qtdTotal)
{ 
    oLog.logDebug("finalizaArquivo>>>");
    
    EXEC SQL BEGIN DECLARE SECTION;
    
        VARCHAR szDataRejeicao[255];
        
        int countErr;
        int countT;
        VARCHAR szFileName[255];

    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL WHENEVER SQLERROR GOTO FinalErr;
    
    memset(&szDataRejeicao, 0x0, sizeof(szDataRejeicao));
    memset(&szFileName, 0x0, sizeof(szFileName));
    
    EXEC SQL
    SELECT TO_CHAR(SYSDATE, 'YYYYMMDD_HH24MISS')
    INTO :szDataRejeicao
    FROM DUAL;
    
    countErr = qtdErros;
    countT = qtdTotal;
    strToOra(szFileName, nomeArquivoRegistros);
    
    sprintf(szAux, "Dados a serem atualizados! DATA_PROC = [%s], QTDE_REGISTROS_ERRO = [%d] e QTDE_REGISTROS = [%d] onde NOME_ARQUIVO = [%s]", (char *) szDataRejeicao.arr, countErr, countT, (char *) szFileName.arr);oLog.logDebug(szAux);
    
    EXEC SQL
    UPDATE      ACESSO.MANUTENCAOLOGINACESSO
    SET		DATA_PROC   		= TO_DATE(:szDataRejeicao, 'YYYYMMDD_HH24MISS'),
                QTDE_REGISTROS_ERRO	= :countErr,
                QTDE_REGISTROS		= :countT
    WHERE  UPPER(TRIM(NOME_ARQUIVO)) = UPPER(TRIM(:szFileName));
    EXEC SQL COMMIT;
    
    /**********************************************************************/
    char path[255];
    memset(path, 0x0, sizeof(path));
    sprintf(szAux, "Arquivo Original = [%s]", filepath); oLog.logDebug(szAux);
    strncat(path, filepath, strlen(filepath) - 4);
    strcat(path, "_");
    strcat(path, (char *) szDataRejeicao.arr);
    strcat(path, ".prc");
    sprintf(szAux, "Arquivo Modificado = [%s]", path); oLog.logDebug(szAux);
    sprintf(szAux, "mv \"%s\" \"%s\"", filepath, path); oLog.logDebug(szAux);
    system(szAux);
    /**********************************************************************/
    
    oLog.logDebug("<<<finalizaArquivo");
    
    return 0;
    
    FinalErr:
        sprintf(szAux, "Erro na finalizacao do processo!"); oLog.logDebug(szAux);
        sprintf(szAux, "FINALIZAARQUIVO > Finalizando processo com erro ORACLE (%d-%.256s)\n", sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
        oLog.logDebug("<<<finalizaArquivo");
        
        EXEC SQL ROLLBACK;
        
        return -1;
}
