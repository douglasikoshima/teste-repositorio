/**
 * 
 * @modulo  Batch
 * @usecase Batch
 * @author  Cassio
 * @version $Revision: 1.1.2.4.14.2 $
 * @CVS     $Author: a5116174 $ - $Date: 2011/12/30 13:30:35 $
 **/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <iostream.h>
#ifndef WIN32
#include <unistd.h>
#endif
#include <ctype.h>

#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>


#include "../include/protocoloNaoSincronizado.h"

#include "../../commons/Propriedade/include/MFile.h"
#include "../../commons/Log/include/Log.h"
#include "../../commons/SplitLine.h"

EXEC SQL INCLUDE SQLCA;

/************************************************************************************************************/
char szAux[512];
Log oLog;
int iSignalProcessa=1;

#define MAX_RETRIES     10

#define LOCK            1
#define UNLOCK          0
#define KILL            2

#define TIPO_ABER_PROT_CONTA            "1"
#define TIPO_ABER_PROT_LINHA            "2"
#define TIPO_ABER_PROT_LINHA_CLIENTE    "3"
#define TIPO_ABER_PROT_PESSOA           "4"

#define CONVIND(O,I) \
{\
    if (I == -1) { \
        ##O.arr[0]=0; \
    } else { \
        ##O.arr[##O.len]=0; \
    } \
}


/************************************************************************************************************/
// Protótipos
int Process(char *pszFileName, int iFlagLock);
void UnLockSemaphore(int semid);
void LockSemaphore(int semid);
int InitSemaphore(key_t key, int nsems);

/************************************************************************************************************/
int main(int argc, char* argv[])
{
    TParamConf tParamConf;

    int retorno = 0;

    EXEC SQL BEGIN DECLARE SECTION;

        VARCHAR dadoOraIdAtendimentoProtocolo[39];
        short statOraIdAtendimentoProtocolo;

        VARCHAR lstDadoOraIdAtendimento[500][39];
        short lstStatOraIdAtendimento[500];

        VARCHAR dadoOraIdPessoaLinhaHistorico[39];
        short statOraIdPessoaLinhaHistorico;

        struct DadosOraProcesso
        {
            VARCHAR idPessoaDePara[39];
            VARCHAR idLinhaTelefonica[39];
            VARCHAR idTipoLinha[39];
            VARCHAR idEstadoLinha[39];
            VARCHAR idUfOperadora[39];
            VARCHAR cdConta[101];
            VARCHAR cdDigitoConta[256];
            VARCHAR cdAreaRegistro[9];
        } dadoOraProcesso;

        struct StatOraProcesso
        {
            short idPessoaDePara;
            short idLinhaTelefonica;
            short idTipoLinha;
            short idEstadoLinha;
            short idUfOperadora;
            short cdConta;
            short cdDigitoConta;
            short cdAreaRegistro;
        } statOraProcesso;

        char *varOraIdTipoAberturaProtocolo;
        int varOraCount;
    EXEC SQL END DECLARE SECTION;

    oLog.setNivel(2);

#ifndef WIN32
    ArmaSinal(SIGTERM);
#endif

    //==========================================================================
    // Lock"a"
    oLog.logDebug("Vai locar fila de processamento...\n");
    int iRet = Process(argv[0],LOCK);

    if(iRet)
    {
    	oLog.logInformation("Saida por TIMEOUT\n");
        return -1;
    }
    oLog.logDebug("Locou fila de processamento\n");

    //==========================================================================
    // parametros de configuração
    if(ObtemParamConf(&tParamConf))
    {
        return -1;
    }

    //==========================================================================
    // Conecta
    if (DBConnect(tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst))
    {
        oLog.logError("Erro conectando no banco de dados");
        Process(argv[0], UNLOCK);
        oLog.logDebug("unlock executado\n");
        return -1;
    }

    //==========================================================================
    // Carga do cursor
    EXEC SQL WHENEVER SQLERROR GOTO sqlError;

    int qtTtProtocolos = 0;
    int qtTtProcessada = 0;

    oLog.logDebug("Carregando dados para fetch...");

    while(1)
    {
	
		EXEC SQL WHENEVER NOT FOUND DO BREAK;
		
		EXEC SQL DECLARE curProt CURSOR FOR
			SELECT /*+ INDEX (ATENDIMENTOPROTOCOLO ATENDIMENTOPROTOCOLOIE6)*/
				IDATENDIMENTOPROTOCOLO
			FROM
				ATENDIMENTO.ATENDIMENTOPROTOCOLO
			WHERE
				INSINCRONIZADO = 0
				AND ROWNUM < 10000;

		EXEC SQL OPEN curProt;

    

		//==========================================================================
		// Processa
		oLog.logDebug("Processando...");

		while(1)
		{
		
			EXEC SQL WHENEVER NOT FOUND DO BREAK;
			// tratamento para interromper o processamento via sinal
			if(iSignalProcessa == 0)
			{
				oLog.logDebug("Tratamento de sinal de termino dentro do loop recebeu interrupção");
				break;
			}
			
			//sprintf(szAux,"dadoOraIdAtendimentoProtocolo[%s]",dadoOraIdAtendimentoProtocolo.arr);oLog.logDebug(szAux);
			
			EXEC SQL FETCH curProt INTO :dadoOraIdAtendimentoProtocolo:statOraIdAtendimentoProtocolo;

			qtTtProtocolos++;

			if ( (qtTtProtocolos % 5000)==0 )
			{ // avisa que esta vivo...
				sprintf(szAux,"Foram processados %d registros até o momento",qtTtProtocolos);oLog.logDebug(szAux);
			}

			memset(&dadoOraProcesso,0,sizeof(dadoOraProcesso));
			memset(&statOraProcesso,-1,sizeof(statOraProcesso));

			EXEC SQL WHENEVER NOT FOUND CONTINUE;

			EXEC SQL
				SELECT
					PESSOALINHA.IDPESSOADEPARA,
					LINHATELEFONICA.IDLINHATELEFONICA,
					LINHATELEFONICA.IDTIPOLINHA,
					LINHABASE.IDESTADOLINHA,
					AREAREGISTRO.IDUFOPERADORA,
					CONTA.CDCONTA,
					CONTA.CDDIGITOCONTA,
					AREAREGISTRO.CDAREAREGISTRO
				INTO
					:dadoOraProcesso:statOraProcesso
				FROM
					ATENDIMENTO.ATENDIMENTOPROTOCOLO ATENDIMENTOPROTOCOLO,
					LINHA.LINHABASE LINHABASE,
					LINHA.LINHATELEFONICA LINHATELEFONICA,
					CUSTOMER.LINHACONTA LINHACONTA,
					CUSTOMER.PESSOALINHA PESSOALINHA,
					CUSTOMER.CONTA CONTA,
					APOIO.ESTADOLINHA ESTADOLINHA,
					APOIO.AREAREGISTRO AREAREGISTRO
				WHERE
					ATENDIMENTOPROTOCOLO.IDATENDIMENTOPROTOCOLO = 
										:dadoOraIdAtendimentoProtocolo
				AND ATENDIMENTOPROTOCOLO.CDAREAREGISTRO = AREAREGISTRO.CDAREAREGISTRO
				AND ATENDIMENTOPROTOCOLO.NRTELEFONE = LINHABASE.NRLINHA
				AND AREAREGISTRO.IDAREAREGISTRO = LINHABASE.IDAREAREGISTRO
				AND LINHABASE.IDLINHABASE = LINHATELEFONICA.IDLINHABASE
				AND NVL(LINHATELEFONICA.DTEXPIRACAO,SYSDATE+1) > SYSDATE
				AND LINHABASE.IDESTADOLINHA = ESTADOLINHA.IDESTADOLINHA
				AND NVL(ESTADOLINHA.INLINHACANCELADA,0) = 0
				AND LINHATELEFONICA.IDLINHATELEFONICA = PESSOALINHA.IDLINHATELEFONICA
				AND PESSOALINHA.IDTIPORELACIONAMENTO = 2
				AND LINHATELEFONICA.IDLINHATELEFONICA = LINHACONTA.IDLINHATELEFONICA (+)
				AND LINHACONTA.IDTIPORELACIONAMENTO (+)= 2
				AND NVL(LINHACONTA.DTEXPIRACAO,SYSDATE+1) > SYSDATE
				AND LINHACONTA.IDCONTA = CONTA.IDCONTA (+);

			if ( sqlca.sqlcode )
			{
				continue; // dados não encontrados ainda
			}

			qtTtProcessada++;

			memset(&dadoOraIdPessoaLinhaHistorico,0,sizeof(dadoOraIdPessoaLinhaHistorico));
			statOraIdPessoaLinhaHistorico = -1;

			EXEC SQL
				SELECT
					IDPESSOALINHAHISTORICO
				INTO
					:dadoOraIdPessoaLinhaHistorico:statOraIdPessoaLinhaHistorico
				FROM
				(
					SELECT
						PESSOALINHAHISTORICO.IDPESSOALINHAHISTORICO,PESSOALINHAHISTORICO.DTULTIMAALTERACAO
					FROM
						CUSTOMER.PESSOALINHAHISTORICO PESSOALINHAHISTORICO,
						ATENDIMENTO.ATENDIMENTOPROTOCOLO ATENDIMENTOPROTOCOLO
					WHERE
						ATENDIMENTOPROTOCOLO.IDATENDIMENTOPROTOCOLO = 
											:dadoOraIdAtendimentoProtocolo
					AND PESSOALINHAHISTORICO.IDPESSOADEPARA = :dadoOraProcesso.idPessoaDePara
					AND PESSOALINHAHISTORICO.IDTIPORELACIONAMENTO = 2
					AND PESSOALINHAHISTORICO.NRLINHA = ATENDIMENTOPROTOCOLO.NRTELEFONE
					AND PESSOALINHAHISTORICO.CDAREAREGISTRO = ATENDIMENTOPROTOCOLO.CDAREAREGISTRO
					ORDER BY 
						PESSOALINHAHISTORICO.DTULTIMAALTERACAO DESC,PESSOALINHAHISTORICO.IDPESSOALINHAHISTORICO DESC
				)
				WHERE ROWNUM < 2;

			//sprintf(szAux,"        IDPESSOADEPARA = %d:'%s'",statOraProcesso.idPessoaDePara,dadoOraProcesso.idPessoaDePara.arr);oLog.logDebug(szAux);
			//sprintf(szAux,"     IDLINHATELEFONICA = %d:'%s'",statOraProcesso.idLinhaTelefonica,dadoOraProcesso.idLinhaTelefonica.arr);oLog.logDebug(szAux);
			//sprintf(szAux,"           IDTIPOLINHA = %d:'%s'",statOraProcesso.idTipoLinha,dadoOraProcesso.idTipoLinha.arr);oLog.logDebug(szAux);
			//sprintf(szAux,"         IDESTADOLINHA = %d:'%s'",statOraProcesso.idEstadoLinha,dadoOraProcesso.idEstadoLinha.arr);oLog.logDebug(szAux);
			//sprintf(szAux,"         IDUFOPERADORA = %d:'%s'",statOraProcesso.idUfOperadora,dadoOraProcesso.idUfOperadora.arr);oLog.logDebug(szAux);
			//sprintf(szAux,"               CDCONTA = %d:'%s'",statOraProcesso.cdConta,dadoOraProcesso.cdConta.arr);oLog.logDebug(szAux);
			//sprintf(szAux,"        CDAREAREGISTRO = %d:'%s'",statOraProcesso.cdAreaRegistro,dadoOraProcesso.cdAreaRegistro.arr);oLog.logDebug(szAux);
			//sprintf(szAux,"IDPESSOALINHAHISTORICO = %d:'%s'",statOraIdPessoaLinhaHistorico,dadoOraIdPessoaLinhaHistorico.arr),oLog.logDebug(szAux);

			if ( statOraProcesso.idLinhaTelefonica >= 0 )
			{
				varOraIdTipoAberturaProtocolo = TIPO_ABER_PROT_LINHA_CLIENTE;
			}
			else if ( statOraProcesso.idPessoaDePara >= 0 )
			{
				varOraIdTipoAberturaProtocolo = TIPO_ABER_PROT_PESSOA;
			}
			else if ( statOraProcesso.cdConta >= 0 )
			{
				varOraIdTipoAberturaProtocolo = TIPO_ABER_PROT_CONTA;
			}
			else
			{
				varOraIdTipoAberturaProtocolo = TIPO_ABER_PROT_LINHA;
			}
			//
			// Atualiza protocolo que esta com o dado não sincronizado
			//
			EXEC SQL
				UPDATE ATENDIMENTO.ATENDIMENTOPROTOCOLO SET
					IDLINHATELEFONICA = :dadoOraProcesso.idLinhaTelefonica:statOraProcesso.idLinhaTelefonica,
					IDPESSOADEPARA = :dadoOraProcesso.idPessoaDePara:statOraProcesso.idPessoaDePara,
					CDCONTA = :dadoOraProcesso.cdConta:statOraProcesso.cdConta,
					IDTIPOABERTURAPROTOCOLO = :varOraIdTipoAberturaProtocolo,
					INSINCRONIZADO = 1, //:dadoOraProcesso.inCancelada, //2=LINHA ESTAVA CANCELADA
					DTULTIMAALTERACAO = SYSDATE,
					IDUSUARIOALTERACAO = -99
				WHERE
					IDATENDIMENTOPROTOCOLO = :dadoOraIdAtendimentoProtocolo;

			// Atendimentos sob o protocolo
			memset(&lstDadoOraIdAtendimento,0,sizeof(lstDadoOraIdAtendimento));
			memset(&lstStatOraIdAtendimento,-1,sizeof(lstStatOraIdAtendimento));

			EXEC SQL DECLARE curProcessos CURSOR FOR
				SELECT
					IDATENDIMENTO
				FROM
					ATENDIMENTO.ATENDIMENTO
				WHERE
					IDATENDIMENTOPROTOCOLO = :dadoOraIdAtendimentoProtocolo
				AND ROWNUM <= 10;

			EXEC SQL OPEN curProcessos;

			EXEC SQL FOR 10 FETCH curProcessos INTO 
				:lstDadoOraIdAtendimento:lstStatOraIdAtendimento;

			int processosRetornados = sqlca.sqlerrd[2];

			EXEC SQL CLOSE curProcessos;

			for (int it2=0;it2<processosRetornados;it2++)
			{
				//
				// Atualiza processo com o dado sincronizado
				//
				EXEC SQL
					UPDATE ATENDIMENTO.ATENDIMENTO SET
						IDLINHATELEFONICA = :dadoOraProcesso.idLinhaTelefonica:statOraProcesso.idLinhaTelefonica,
						IDTIPOLINHA = :dadoOraProcesso.idTipoLinha:statOraProcesso.idTipoLinha,
						IDUFOPERADORA = :dadoOraProcesso.idUfOperadora:statOraProcesso.idUfOperadora,
						CDAREAREGISTRO = :dadoOraProcesso.cdAreaRegistro:statOraProcesso.cdAreaRegistro,
						IDESTADOLINHA = :dadoOraProcesso.idEstadoLinha:statOraProcesso.idEstadoLinha,
						IDPESSOALINHAHISTORICO = :dadoOraIdPessoaLinhaHistorico:statOraIdPessoaLinhaHistorico,
						DTULTIMAALTERACAO = SYSDATE,
						IDUSUARIOALTERACAO = -99 // indicativo de processado por batch
					WHERE
						IDATENDIMENTO = :lstDadoOraIdAtendimento[it2];

				EXEC SQL
					UPDATE ATENDIMENTO.ATENDIMENTOPRIORIZACAO SET
						IDLINHATELEFONICA = :dadoOraProcesso.idLinhaTelefonica:statOraProcesso.idLinhaTelefonica,
						IDTIPOLINHA = :dadoOraProcesso.idTipoLinha:statOraProcesso.idTipoLinha,
						IDUFOPERADORA = :dadoOraProcesso.idUfOperadora:statOraProcesso.idUfOperadora,
						CDAREAREGISTRO = :dadoOraProcesso.cdAreaRegistro:statOraProcesso.cdAreaRegistro,
						IDESTADOLINHA = :dadoOraProcesso.idEstadoLinha:statOraProcesso.idEstadoLinha,
						IDPESSOALINHAHISTORICO = :dadoOraIdPessoaLinhaHistorico:statOraIdPessoaLinhaHistorico,
						DTULTIMAALTERACAO = SYSDATE,
						IDUSUARIOALTERACAO = 1
					WHERE
						IDATENDIMENTO = :lstDadoOraIdAtendimento[it2];

				if ( statOraProcesso.idPessoaDePara >= 0 )
				{
					EXEC SQL
						SELECT
							COUNT(1)
						INTO
							:varOraCount
						FROM
							ATENDIMENTO.ATENDIMENTOPESSOA
						WHERE
							IDATENDIMENTO = :lstDadoOraIdAtendimento[it2]
						AND ROWNUM < 2 ;

					if ( 0==varOraCount )
					{
						EXEC SQL
							INSERT INTO ATENDIMENTO.ATENDIMENTOPESSOA
								(IDATENDIMENTOPESSOA,IDATENDIMENTO,IDPESSOADEPARA
								,INRESPONSAVELABERTURA,IDTIPORELACIONAMENTO
								,IDUSUARIOALTERACAO,DTULTIMAALTERACAO)
							VALUES
								(
									ATENDIMENTO.ATENDIMENTOPESSOASQ.NEXTVAL,
									:lstDadoOraIdAtendimento[it2],
									:dadoOraProcesso.idPessoaDePara,
									2, // INRESPONSAVELABERTURA
									2, // IDTIPORELACIONAMENTO
									-99, // IDUSUARIOALTERACAO
									SYSDATE // DTULTIMAALTERACAO
								);
					}
				} // if ( statOraProcesso.idPessoaDePara >= 0 )

				if ( statOraProcesso.cdConta >= 0 )
				{
					EXEC SQL
						SELECT
							COUNT(1)
						INTO
							:varOraCount
						FROM
							ATENDIMENTO.ATENDIMENTOCONTA
						WHERE
							IDATENDIMENTO = :lstDadoOraIdAtendimento[it2]
						AND ROWNUM < 2 ;

					if ( 0==varOraCount )
					{
						EXEC SQL
							INSERT INTO ATENDIMENTO.ATENDIMENTOCONTA
								(IDATENDIMENTO,CDCONTA,CDDIGITOCONTA,IDUSUARIOALTERACAO,DTULTIMAALTERACAO)
							VALUES
								(
									:lstDadoOraIdAtendimento[it2],
									:dadoOraProcesso.cdConta:statOraProcesso.cdConta,
									DECODE(:statOraProcesso.cdDigitoConta,-1,'0',:dadoOraProcesso.cdDigitoConta),
									-99, // IDUSUARIOALTERACAO
									SYSDATE // DTULTIMAALTERACAO
								);
					}

				} // if ( statOraProcesso.cdConta >= 0 )

			} // for (it2=0;it2<processosRetornados;it2++)

			EXEC SQL COMMIT;

		} //while (1) interno

		EXEC SQL CLOSE curProt;
	
		sprintf(szAux,"Temporariamente lidos %d protocolos(s)",qtTtProtocolos);oLog.logDebug(szAux);
		sprintf(szAux,"Temporariamente processados %d protocolos(s)",qtTtProcessada);oLog.logDebug(szAux);	
	
	}  //while (1) externo

    Process(argv[0], UNLOCK);

    DBDisconnect();

    sprintf(szAux,"Foram lidos %d protocolos(s)",qtTtProtocolos);oLog.logDebug(szAux);
    sprintf(szAux,"Foram processados %d protocolos(s)",qtTtProcessada);oLog.logDebug(szAux);

    oLog.logDebug("Processamento encerrado com sucesso...");

    return retorno;

    sqlError:
        sprintf(szAux,"ERRO ORACLE [%s]",sqlca.sqlerrm.sqlerrmc);oLog.logDebug(szAux);
    	EXEC SQL ROLLBACK;
        DBDisconnect();
        Process(argv[0], UNLOCK);
        return -1;
}

/************************************************************************************************************/
#ifndef WIN32
void ArmaSinal(int iSignal)
{
    sprintf(szAux, "Armando tratamento para Signal(%d)", iSignal); oLog.logInformation(szAux);

    if(signal((iSignal), ProcessaSignal) == SIG_ERR)
	{
        fprintf(stderr, "ERRO ARMANDO SINAL!!!\n");
        exit(-1);
    }
}
/************************************************************************************************************/
void ProcessaSignal(int iSig)
{
    oLog.logInformation(">>>ProcessaSignal");
    sprintf(szAux, "iSig(%d)", iSig); oLog.logInformation(szAux);

    /* rearma o mesmo sinal lancado */
    ArmaSinal(iSig);

    if(iSig == SIGTERM)
	{
        oLog.logInformation("Finalizando processamento via sinal....");
        iSignalProcessa=0;
    }

    oLog.logInformation(">>>ProcessaSignal");
}
#endif

/************************************************************************************************************/
int ObtemParamConf(TParamConf *ptParamConf)
{
    MFile mfConfig;
    SplitLine NewLinha;
    char szLinha[100 + 1];
    char szDivArq[256];
    char szDivPre[21];

    oLog.logDebug("Obtendo parametros de configuracao...");

    /* Zera variáveis */
    memset(ptParamConf, 0x00, sizeof(TParamConf));
    memset(szLinha, 0x00, sizeof(szLinha));
    memset(szDivArq, 0x00, sizeof(szDivArq));
    memset(szDivPre, 0x00, sizeof(szDivPre));


    /* Define o arquivo de configuração */
    mfConfig.setPath("protocoloNaoSincronizado.cfg");

    /* Verificar se conseguiu abrir o arquivo */
    if(!mfConfig.abrir())
	{
        oLog.logError("Erro abrindo arquivo de configuração!");
        return -1;
    }

    /* Capturando usuario, senha, path e instance de banco do arquivo */
    NewLinha.SetDiv('=');
    while(mfConfig.getLine(szLinha) != 0)
    {
        NewLinha.SetLine(szLinha);
        NewLinha.GetBeforeDiv(szDivPre);
        NewLinha.GetAfterDiv(szDivArq);

        /* Verifica qual parâmetro foi encontrado. */
        if (!strcmp(szDivPre, "pwd_db"))
        {
            strncpy(ptParamConf->szPws, szDivArq, TAM_BD_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_db"))
        {
            strncpy(ptParamConf->szUsr, szDivArq, TAM_BD_USRNAME);
        }
        else if (!strcmp(szDivPre, "inst_db"))
        {
            strncpy(ptParamConf->szInst, szDivArq, TAM_BD_INST);
        }
        else if (!strcmp(szDivPre, "pwd_tux"))
        {
            strncpy(ptParamConf->szPwsTux, szDivArq, TAM_TX_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_tux"))
        {
            strncpy(ptParamConf->szUsrTux, szDivArq, TAM_TX_USRNAME);
        }
        else if (!strcmp(szDivPre, "pwd_tux_gen"))
        {
            strncpy(ptParamConf->szPwsTuxGen, szDivArq, TAM_TX_GEN);
        }
        else if (!strcmp(szDivPre, "clt_tux"))
        {
            strncpy(ptParamConf->szCltTux, szDivArq, TAM_TX_CLT);
        }
        else if (!strcmp(szDivPre, "path"))
        {
            strncpy(ptParamConf->szPath, szDivArq, _MAX_PATH);
        }
        else if (!strcmp(szDivPre, "path_togo"))
        {
            strncpy(ptParamConf->szPathToGo, szDivArq, _MAX_PATH);
        }

        memset(szLinha,  0x00, sizeof(szLinha));
        memset(szDivPre, 0x00, sizeof(szDivPre));
        memset(szDivArq, 0x00, sizeof(szDivArq));
    }

    /* Fechando o arquivo de configuracao aberto */
    mfConfig.fechar();

    //sprintf(szAux, "ptParamConf->szPws[%s]", ptParamConf->szPws); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szUsr[%s]", ptParamConf->szUsr); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szInst[%s]", ptParamConf->szInst); oLog.logDebug(szAux);
    //sprintf(szAux, "ptParamConf->szPwsTux[%s]", ptParamConf->szPwsTux); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szUsrTux[%s]", ptParamConf->szUsrTux); oLog.logDebug(szAux);
    //sprintf(szAux, "ptParamConf->szPwsTuxGen[%s]", ptParamConf->szPwsTuxGen); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szCltTux[%s]", ptParamConf->szCltTux); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szPath[%s]", ptParamConf->szPath); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szPathToGo[%s]", ptParamConf->szPathToGo); oLog.logDebug(szAux);

    oLog.logDebug("Parametros de configuracao obtidos com sucesso...");
    return 0;
}

/************************************************************************************************************/
int DBConnect(char *pUsr, char *pPwd, char *pInst)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[256];
    EXEC SQL END DECLARE SECTION;

    sprintf(connString, "%s/%s@%s", pUsr, pPwd, pInst);

    EXEC SQL WHENEVER SQLERROR GOTO errConn;

    oLog.logDebug("Conectando na BD...");

    EXEC SQL CONNECT :connString;

    oLog.logDebug("Conectou na BD");

    return (sqlca.sqlcode);

errConn:
    oLog.logInformation("<<<DBConnect [ERROR]");
    return -1;
}

/************************************************************************************************************/
void DBDisconnect(void)
{
    EXEC SQL WHENEVER SQLERROR GOTO DBDisconnectError;
    EXEC SQL COMMIT WORK RELEASE;
    oLog.logDebug("Desconectou da BD com sucesso");
    return;

DBDisconnectError:
    sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
}

/********************************************************************************************/
int Process(char *pszFileName, int iFlagLock)
{
    static int semid;
    time_t tStart, tEnd;
    double tDiff;
    key_t key;

    if(iFlagLock == UNLOCK)
    {
        UnLockSemaphore(semid);
    }
    else if(iFlagLock == LOCK)
    {

        if((key = ftok(pszFileName, 'a')) == (key_t) -1)
        {
            perror("IPC error: ftok");
            exit(-1);
        }

        if((semid = InitSemaphore(key, 1)) == -1)
        {
            perror("InitSemaphore");
            exit(-1);
        }

        time(&tStart);
        LockSemaphore(semid);
        time(&tEnd);

        tDiff = difftime(tEnd, tStart);

        /* tempo limite para espera de processamento */
        if(tDiff > (double)0)
            return -1;
    }
    else if(iFlagLock == KILL)
    {
        semctl(semid, 0, IPC_RMID); /* deleta o semaforo */
    }
    else
    {
        exit(-1);
    }

    return 0;
}

/********************************************************************************************/
void UnLockSemaphore(int semid)
{
    struct sembuf sb;

    sb.sem_num = 0;
    sb.sem_op = 1; /* free resource */
    sb.sem_flg = SEM_UNDO;

    if (semop(semid, &sb, 1) == -1)
    {
        perror("semop");
        exit(1);
    }
}

/********************************************************************************************/
void LockSemaphore(int semid)
{
    struct sembuf sb;

    sb.sem_num = 0;
    sb.sem_op = -1;  /* set to allocate resource */
    sb.sem_flg = SEM_UNDO;

    if (semop(semid, &sb, 1) == -1)
    {
        perror("semop");
        exit(1);
    }
}

/********************************************************************************************/
/*
** InitSemaphore() -- more-than-inspired by W. Richard Stevens' UNIX Network
** Programming 2nd edition, volume 2, lockvsem.c, page 295.
*/
int InitSemaphore(key_t key, int nsems)
{
    union semun
    {
        int val;
        struct semid_ds *buf;
        ushort *array;
    } arg;

    struct semid_ds buf;
    struct sembuf sb;
    int semid;

    semid = semget(key, nsems, IPC_CREAT | IPC_EXCL | 0666);
    if (semid >= 0)
    { /* we got it first */
        sb.sem_op = 1;
        sb.sem_flg = 0;
        arg.val = 1;

        for(sb.sem_num = 0; sb.sem_num < nsems; sb.sem_num++)
        {
            /* do a semop() to "free" the semaphores. */
            /* this sets the sem_otime field, as needed below. */
            if (semop(semid, &sb, 1) == -1)
            {
                int e = errno;
                semctl(semid, 0, IPC_RMID); /* clean up */
                errno = e;
                return -1; /* error, check errno */
            }
        }
    }
    else if (errno == EEXIST)
    {
        int ready = 0;

        semid = semget(key, nsems, 0); /* get the id */
        if (semid < 0)
            return semid; /* error, check errno */

        /* wait for other process to initialize the semaphore: */
        arg.buf = &buf;

        for(int i = 0; i < MAX_RETRIES && !ready; i++)
        {
            semctl(semid, nsems-1, IPC_STAT, arg);

            if (arg.buf->sem_otime != 0)
            {
                ready = 1;
            }
            else
            {
                sleep(1);
            }
        }
        if(!ready)
        {
            errno = ETIME;
            return -1;
        }
    }
    else
    {
        return semid; /* error, check errno */
    }

    return semid;
}
