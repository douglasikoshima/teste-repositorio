#include <stdio.h>
#include "../../commons/Propriedade/include/Propriedade.h"
#include "../../commons/Log/include/Log.h"

EXEC SQL INCLUDE SQLCA;
#define STRLENNULL( y ) ( y == NULL ? 0 : strlen( y )  )
#define OK   0;
#define NOK -1;

#ifdef WIN32
	#define AS_ARQUIVO_CFG "D:\\Comum\\BATCH\\atualizaStatus\\Debug\\atualizaStatus.cfg"
#else
	#define AS_ARQUIVO_CFG "atualizaStatus.cfg"
#endif

/* Prototipos */
int DBConnect(char* pzcUser, char* pzcPass, char* pzcHost);

int main(char** argv, int argc) {
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		struct
		{
			VARCHAR stIdCorr[21+1];
			VARCHAR stIdProxStatus[21+1];
			VARCHAR stIdHist[21+1];
			VARCHAR stIdUsu[21+1];
		}stDados;
		struct
		{
			short iIdCorr;
			short iIdProxStatus;
			short iIdHist;
			short iIdUsu;
		}stIndicator;
	EXEC SQL END DECLARE SECTION;
	char* szPws;
	char* szUsr;
	char* szPath;
	char* szInst;
	int  vlLog = 1;/* Ainda nao esta sendo utilizado */
	
	memset( &stDados, 0, sizeof( stDados ) );
	memset( &sqlca, 0, sizeof( sqlca ) );

	/* Classe para gerar log */
	Log oLog;
	char cLinha[2048];

	/* Recupera os dados de conecao atravez do arquivo atualizaStatus.cfg */
	Propriedade prop( AS_ARQUIVO_CFG );

	szPws = prop.getParametro("pwd");
	szUsr = prop.getParametro("usr");
	szPath= prop.getParametro("pth");
	szInst= prop.getParametro("inst");
	vlLog = atoi( prop.getParametro("log") );

	//Acertando o nivel de  logs
	oLog.setNivel( vlLog );

	/* Verifica se todos os dados foram recuperados do arquivo de configuração. */
	if( STRLENNULL(szInst) <= 0 )
	{
		oLog.logError("inst esta nulo\n");
		return NOK;
	}

	/* Conecta no banco de dados */
	if(DBConnect( szUsr, szPws, szInst ) ) 
	{
		sprintf(cLinha, "Erro ORACLE: sqlca.sqlcode = %i \nsqlca.sqlerrm.sqlerrmc = %s\n", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc );
		oLog.logError(cLinha);
		sprintf(cLinha, "Erro ao tentar conectar com banco de dados:\nUsuario:%s\nSenha:%s\nInstancia:%s\n",szUsr , szPws, szInst);
		oLog.logError(cLinha);
		return NOK;
	}
	oLog.logError("Conectado com sucesso ao ORACLE");

	/* Marca ponto de controle de erro */
	EXEC SQL WHENEVER SQLERROR GOTO sqlErr;

	/* Declara e abre o cursor com as correspondencias */
	EXEC SQL 
	DECLARE 
		correspondencias CURSOR FOR
	SELECT
		CORR.IDCORRESPONDENCIADEVOLVIDA AS ID,
		HIST.IDPESSOAUSUARIO,
		STAT.IDPROXIMOSTATUS
	FROM
		CORRESPONDENCIA.HISTORICOSTATUSATUALB00 HISTATU,
		CORRESPONDENCIA.CORRESPONDENCIADEVOLVIDAB00 CORR,
		CORRESPONDENCIA.HISTORICOSTATUSB00 HIST,
		APOIO.STATUSCORRESPONDENCIAB00 STAT
	WHERE
		CORR.IDCORRESPONDENCIADEVOLVIDA = HISTATU.IDCORRESPONDENCIADEVOLVIDA 
	AND
		HISTATU.IDHISTORIOSTATUS = HIST.IDHISTORIOSTATUS 
	AND
		HIST.IDSTATUSCORRESPONDENCIA = STAT.IDSTATUSCORRESPONDENCIA 
	AND
		STAT.IDPROXIMOSTATUS IS NOT NULL 
	AND
		STAT.QTDIASVALIDO IS NOT NULL 
	AND
		SYSDATE > HIST.DTSTATUS + STAT.QTDIASVALIDO;

	/* Abre o CURSOR */
	EXEC SQL OPEN correspondencias;
		
	EXEC SQL WHENEVER NOT FOUND DO break;
	for (;;) {
		EXEC SQL FETCH correspondencias 
		INTO
			:stDados.stIdCorr       :stIndicator.iIdCorr,
			:stDados.stIdUsu        :stIndicator.iIdUsu,
			:stDados.stIdProxStatus :stIndicator.iIdProxStatus;

		/* Insere o novo status */
		EXEC SQL 
		SELECT 
			CORRESPONDENCIA.HISTORICOSTATUSSQ.NEXTVAL 
		INTO 
			:stDados.stIdHist :stIndicator.iIdHist
		FROM DUAL;
		

		EXEC SQL 
		INSERT INTO CORRESPONDENCIA.HISTORICOSTATUSG00
		(
			IDHISTORIOSTATUS,
		 	IDPESSOAUSUARIO,
		 	IDCORRESPONDENCIADEVOLVIDA,
		 	IDSTATUSCORRESPONDENCIA,
		 	DTALTERACAO,
		 	DTSTATUS,
		 	IDUSUARIOALTERACAO,
		 	DTULTIMAALTERACAO
		)
		VALUES
		(
			:stDados.stIdHist,
		 	:stDados.stIdUsu,
		 	:stDados.stIdCorr,
		 	:stDados.stIdProxStatus,
		 	SYSDATE,
		 	SYSDATE,
		 	0,
		 	SYSDATE
		);

		/* Atualiza o status da correspondencia */
		EXEC SQL 
		UPDATE 
			CORRESPONDENCIA.HISTORICOSTATUSATUALG00
		SET
			IDHISTORIOSTATUS = :stDados.stIdHist,
		 	IDUSUARIOALTERACAO = 0,
		 	DTULTIMAALTERACAO = SYSDATE
		WHERE
		 	IDCORRESPONDENCIADEVOLVIDA = :stDados.stIdCorr;
	}
	/* Fecha o CURSOR */
	EXEC SQL CLOSE correspondencias;

	/* Executa COMMIT */
	EXEC SQL COMMIT WORK RELEASE;

	sprintf(cLinha, "Sucesso (COMMIT): sqlca.sqlcode = %i \nsqlca.sqlerrm.sqlerrmc = %s\n", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc );
	oLog.logError(cLinha);
	return OK;

/* Tratamento de erro */
sqlErr:
	EXEC SQL ROLLBACK RELEASE;
	sprintf(cLinha, "Erro (ROLLBACK): sqlca.sqlcode = %i \nsqlca.sqlerrm.sqlerrmc = %s\n", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc );
	oLog.logError(cLinha);
	return NOK;
}

int DBConnect(char* pzcUser, char* pzcPass, char* pzcHost) 
{

	EXEC SQL BEGIN DECLARE SECTION;
		char connString[256];
	EXEC SQL END DECLARE SECTION;

	/* String de conexao */
	sprintf(connString, "%s/%s@%s", pzcUser, pzcPass, pzcHost );

	/* Marca ponto de erro */
	EXEC SQL WHENEVER SQLERROR GOTO errConn;

	/* Conecta */
	EXEC SQL CONNECT :connString;

	return sqlca.sqlcode;
	
	/* Retorna erro */
	errConn:
	return NOK;
}
