/**
 * @modulo  Batch
 * @usecase Batch
 * @author
 * @version $Revision: 1.1.6.17.6.1.46.2 $
 * @CVS     $Author: a5113943 $ - $Date: 2017/01/04 19:22:32 $
 **/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <iostream.h>
#include <ctype.h>
#include <fcntl.h>
#include <strings.h>

#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

#define MAX_RETRIES     10

#ifndef WIN32
#include <unistd.h>
#endif

#include <libxml/xpath.h>
#include <libxml/tree.h>
#include <libxml/parser.h>
#include <libxml/debugXML.h>
#include <libxml/xmlmemory.h>
#include <libxml/tree.h>
#include <libxml/parser.h>
#include <libxml/uri.h>
#include <libxml/entities.h>
#include <libxml/valid.h>
#include <libxml/xmlerror.h>
#include <libxml/parserInternals.h>
#include <libxml/globals.h>
#include <libxml/xpathInternals.h> 

#include <tibems/tibems.h>

#include "../include/cargaBancosPR.h"

#include "../../commons/Propriedade/include/MFile.h"
#include "../../commons/Log/include/Log.h"
#include "../../commons/SplitLine.h"

#include <string>
using namespace std;

EXEC SQL INCLUDE SQLCA;

#define CONVIND(O,I) \
{\
    if (I == -1) { \
        ##O.arr[0]=0; \
    } else { \
        ##O.arr[##O.len]=0; \
    } \
}

#define endOraStr(varstr)      varstr.arr[varstr.len]= '\0'
#define oraToStr(bstr,vchar)   if(!bstr) strncpy(bstr,vchar.arr,vchar.len)
#define strToOra(vchar,bstr)   vchar.len = strlen(bstr);strncpy((char *)vchar.arr,bstr,vchar.len);vchar.arr[vchar.len] = 0
#define strconv(buffer,fonte)  sprintf(buffer,"%d",fonte)

//==============================================================================
// Globais
char szAux[1024 + 1];
Log oLog;
int iSignalProcessa = 1;
int iFlagErrorFile = 0;
TParamConf tParamConf;
char nomeArquivoRegistros[255];
char siglaBanco[255];

//==============================================================================
// Prot?tipos
void UnLockSemaphore(int semid);
void LockSemaphore(int semid);
int InitSemaphore(key_t key, int nsems);

int verifyHeader(char *szSequenciaArquivo);
int verifyTrailler(char *szSequenciaArquivo, int *qtRegistro);
int verifyMovimento(char *szSequenciaArquivo, int *qtRegistro);

int OpenDir(char *pszDiretorio,char*pfile);
int checkBadError(char *pszDiretorio);
int registraErro(char *szPathArquivo, int cdErro, char *dsErro, char *szSequenciaArquivo);
int finalizaArquivo(char *szPathArquivo, int qtRegistros);

//==============================================================================
// Run
int main(int argc, char* argv[])
{   
    //Atualiza dados executados para pasta envidados
    system("mv  ../temp/*.* ../enviados");
    
    int errorFound = -1;

    EXEC SQL BEGIN DECLARE SECTION;
    
        char path[255];
        
        char szDataMovimento[255 + 1];
        
        short i_FechMov = 0;
        
        short i_SQMovimento = -1;
        VARCHAR szSQMovimento[10];
        
        short i_NrDocumento = -1;
        VARCHAR szNrDocumento[12];

	int v_ct;
        
        short i_IdLinhaTelefonica = -1;
        VARCHAR szIdLinhaTelefonica[255 + 1];
        
        int *qtRegistro;
        
        int szCDErro = 1000;
        char szDSErro[255 + 1];
        char szDataRejeicao[9];
        
	//pog master
	VARCHAR szIdPessoadePara[255];
	varchar szIdLinha[255];

        int qtSeq = 0;
        int qtMov = 0;
        int qtMov2 = 0;
        int dtValida = 0;
        
        int i = 1;
        
        VARCHAR VI_OPERACAO[255];
        short i_NRLinha = -1;
        VARCHAR VI_NRLINHA[255];
        VARCHAR VI_NMUSUARIOATUALIZACAO[255];
        VARCHAR VI_NRLINHASOLICITANTE[255];
        VARCHAR VI_NRLINHACONTATO[255]; 
        int VO_CDERRO;
        VARCHAR VO_DSERRO[255];
        VARCHAR VO_DSCLASSIFICACAOLINHA[255];
		VARCHAR VO_DTADESAO[255];

    EXEC SQL END DECLARE SECTION;

    oLog.setNivel(2); //Nivel 2 = Debug

    oLog.logDebug(">>>cargaBancosPR");

    ArmaSinal(SIGTERM);
	//incluir variavel na apoio.parametro
	//por conta do processamento em paralelo
        //Lembrar de incluir commit;

    //==========================================================================
    // Par?metros de configura??o
    if(ObtemParamConf(&tParamConf))
    {
        oLog.logError("Erro obtendo parametros de configuracao");
        exit(1);
    }

    //==========================================================================
    // Conecta ao banco
    oLog.logDebug("Conectando na BD...");
    if (DBConnect(tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst))
    {
        oLog.logError("Erro conectando no banco de dados");
        exit(1);
    }
    oLog.logDebug("Conectado na BD com sucesso...");
    
    oLog.logDebug("Inicio da carga...\n");
    
    strcpy(path, tParamConf.szPath);

    while((iFlagErrorFile = OpenDir(path, nomeArquivoRegistros)) != 0){
        
        if(iFlagErrorFile == 2)
        {
            oLog.logDebug("Erro em arquivo...");
            iFlagErrorFile = 0;
            continue;
        }
        
        sprintf(szAux,"Exetutando arquivo nome %s...", nomeArquivoRegistros); oLog.logDebug(szAux);
            
        oLog.logDebug("Inicio da carga...\n");
        
        char sComando[1024];

        char arquivoDat[1024];
        
        strcpy(arquivoDat, path);
        strcat(arquivoDat, nomeArquivoRegistros);
        
        sprintf(sComando,"sqlldr %s/%s@%s DATA=%s CONTROL=./control.ctl ERRORS=999999999", tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst, arquivoDat);
        sprintf(szAux,"Comando [%s] exetutando...", sComando); oLog.logDebug(szAux);
        system(sComando);
        
        oLog.logDebug("Verificando Erros Iniciais");
        if(checkBadError("../error/") < 0)
        {
            oLog.logDebug("Erro na montagem dos dados.\n");
            strcpy(szDSErro, "Erro na montagem dos dados.");

            char epath[256]={0};
            strcat(epath, tParamConf.szPath);
            strcat(epath, nomeArquivoRegistros);

            registraErro(epath, 1009, szDSErro, "       ");
            errorFound = -1;
        }
        else
        {
            /****************************** Validações do Arquivo ****************************************/
            int qtR = 0;
            char szSequenciaArquivo[8];

            qtRegistro = &qtR;

            oLog.logDebug("Validacoes do Arquivo>>>");

            errorFound = verifyHeader(szSequenciaArquivo);
            sprintf(szAux,"Resultado da verificacao do Header [%d]", errorFound); oLog.logDebug(szAux);

            if(errorFound == 0)
            {
                errorFound = verifyTrailler(szSequenciaArquivo, qtRegistro);
                sprintf(szAux,"Resultado da verificacao do Trailler [%d]", errorFound); oLog.logDebug(szAux);

                if(errorFound == 0)
                            {
                    errorFound = verifyMovimento(szSequenciaArquivo, qtRegistro);
                    sprintf(szAux,"Resultado da verificacao do Movimento [%d]", errorFound); oLog.logDebug(szAux);
                }
            }
            oLog.logDebug("<<<Validacoes do Arquivo");
        }
        
        /********************************************************************************************************/
        /****************************** Validações do Arquivo Concluídas ****************************************/
        /********************************************************************************************************/
        
        bool linhaArquivo = false;
        
        if(errorFound == 0){
            
            EXEC SQL WHENEVER NOT FOUND DO BREAK;
            
            EXEC SQL
            DECLARE mov CURSOR FOR
               SELECT SQMOVIMENTO, NRDOCUMENTO, TRIM(NRLINHA)
               FROM LOAD.TMP_MOVIMENTO
               ORDER BY SEQUENCE_MOV;
            
            EXEC SQL OPEN mov;
            
            for(;;)
            {
                memset(&szSQMovimento, 0x0, sizeof(szSQMovimento));
                i_SQMovimento = -1;
                memset(&szNrDocumento, 0x0, sizeof(szNrDocumento));
                i_NrDocumento = -1;
                memset(&VI_NRLINHA, 0x0, sizeof(VI_NRLINHA));
                i_NRLinha = -1;
                
                EXEC SQL
                FETCH mov INTO :szSQMovimento:i_SQMovimento, :szNrDocumento:i_NrDocumento, :VI_NRLINHA:i_NRLinha;
                
                EXEC SQL WHENEVER NOT FOUND CONTINUE;

                oLog.logDebug("Validacoes dos Dados Recebidos>>>");
                
                CONVIND(szSQMovimento, i_SQMovimento);
                CONVIND(szNrDocumento, i_NrDocumento);
                CONVIND(VI_NRLINHA, i_NRLinha);
                
                sprintf(szAux, "Linha Atual [SQMOVIMENTO = %s, NRDOCUMENTO = %s, NRLINHA = %s]", (char *) szSQMovimento.arr, (char *) szNrDocumento.arr, (char *) VI_NRLINHA.arr); oLog.logDebug(szAux);
                	
                /*--############################### PARA CONSULTAR O CPF #################################--*/
                qtMov = 0;
                
                EXEC SQL 
                SELECT COUNT(1) 
                INTO :qtMov
                FROM CUSTOMER.DOCUMENTO d,
                     customer.pessoadocumento pd,
                     customer.pessoa p
                WHERE d.NRDOCUMENTO = :szNrDocumento
                and   pd.iddocumento=d.iddocumento
                and   pd.idpessoa=p.idpessoa;

                sprintf(szAux, "Numero de Documentos [%d]", qtMov); oLog.logDebug(szAux);
                
                if(qtMov == 0)
		{
                    EXEC SQL
                    UPDATE LOAD.TMP_MOVIMENTO 
                        SET RETORNO = '03' ,
                        DTINCLUSAO = TO_CHAR(SYSDATE,'YYYYMMDD') 
                    WHERE SQMOVIMENTO = :szSQMovimento;
                    EXEC SQL COMMIT;
                }
                else
                {
                    /********************************Validar a Relação Linha - CPF**********************************/

                    v_ct = 1;
                    
                    if(VI_NRLINHA.len <= 0)
                    {
                        sprintf(szAux, "VI_NRLINHA.len [%d]", VI_NRLINHA.len); oLog.logDebug(szAux); 

                        linhaArquivo = false;

                        EXEC SQL
                        SELECT  AR.CDAREAREGISTRO||LB.NRLINHA 
                        INTO 	:VI_NRLINHA:i_NRLinha
                        FROM 	CUSTOMER.DOCUMENTO D, 
                                CUSTOMER.PESSOADOCUMENTO PD, 
                                CUSTOMER.PESSOADEPARA PDP, 
                                CUSTOMER.PESSOALINHA PL, 
                                LINHA.LINHATELEFONICA LT, 
                                LINHA.LINHABASE LB,
                                APOIO.AREAREGISTRO AR
                        WHERE D.NRDOCUMENTO      = :szNrDocumento
                        AND   LB.IDAREAREGISTRO=AR.IDAREAREGISTRO
                        AND D.IDDOCUMENTO        = PD.IDDOCUMENTO
                        AND PD.IDPESSOA          = PDP.IDPESSOA
                        AND PL.IDTIPORELACIONAMENTO=2
                        AND PDP.IDPESSOADEPARA   = PL.IDPESSOADEPARA
                        AND PL.IDLINHATELEFONICA = LT.IDLINHATELEFONICA
                        AND LT.IDLINHABASE       = LB.IDLINHABASE
                        AND (LT.IDTIPOLINHA IN (1, 4, 5, 7) OR LT.IDSUBTIPOLINHA IN (50,200))
                        AND (LT.DTEXPIRACAO IS NULL OR LT.DTEXPIRACAO > SYSDATE)
                        and rownum <= 1;

                        sprintf(szAux, "Linha referente ao documento [%s] [%s]", (char *) szNrDocumento.arr, (char *) VI_NRLINHA.arr); oLog.logDebug(szAux);
                    }
                    else
                    {
                        sprintf(szAux, "Linha referente a sequencia movimento [%s] [%s]", (char *) szSQMovimento.arr, (char *) VI_NRLINHA.arr); oLog.logDebug(szAux);

                        linhaArquivo = true;

                        memset(&szIdLinha, 0x0, sizeof(szIdLinha));
                        memset(&szIdPessoadePara, 0x0, sizeof(szIdPessoadePara));
                        
                        EXEC SQL
                        SELECT pl.idlinhatelefonica, 
                               pl.idpessoadepara
                          INTO :szIdLinha, 
                               :szIdPessoadePara
                          FROM customer.pessoalinha pl,
                                   linha.linhatelefonica lt,
                                   linha.linhabase lb,
                                   apoio.arearegistro ar
                         WHERE pl.idlinhatelefonica = lt.idlinhatelefonica
                           AND pl.idtiporelacionamento = 2                                --cliente
                           AND lt.idlinhabase = lb.idlinhabase
                           AND lb.idarearegistro = ar.idarearegistro
                           AND lb.nrlinha = SUBSTR (TRIM(:VI_NRLINHA), 3, LENGTH (TRIM(:VI_NRLINHA)))
                           AND ar.cdarearegistro = SUBSTR (TRIM(:VI_NRLINHA), 1, 2);

                        sprintf(szAux, "IDPESSOADEPARA = [%s]", (char *) szIdPessoadePara.arr); oLog.logDebug(szAux);

                        EXEC SQL  
                        SELECT count(nrdocumento)
                                       INTO :v_ct
                        FROM customer.documento d,
                                        customer.pessoadocumento pd,
                                        customer.pessoadepara pdp
                        WHERE d.iddocumento = pd.iddocumento
                                AND pd.idpessoa = pdp.idpessoa
                                AND pdp.idpessoadepara =  :szIdPessoadePara
                                AND d.nrdocumento = LPAD (:szNrDocumento, 11, '0')
                                AND ROWNUM <= 1;

                       sprintf(szAux, "Documento(s) pertence(s) a Linha [%s] [%d]", (char *) VI_NRLINHA.arr, v_ct); oLog.logDebug(szAux);	
                    }
                    
                    if (!v_ct)
                    {		
                        EXEC SQL
                        UPDATE LOAD.TMP_MOVIMENTO SET RETORNO = '02',
                                   DTINCLUSAO = TO_CHAR(SYSDATE,'YYYYMMDD') 
                                   WHERE SQMOVIMENTO = :szSQMovimento;
                        EXEC SQL COMMIT;
                    }
                    else
                    {
                        /*--########################### PARA OBTER AS LINHAS DO CPF ##############################--*/

                        i_IdLinhaTelefonica = 0;
                        
                        EXEC SQL
                        SELECT count(1)
                        INTO :i_IdLinhaTelefonica
                        FROM CUSTOMER.DOCUMENTO D, 
                             CUSTOMER.PESSOADOCUMENTO PD, 
                             CUSTOMER.PESSOADEPARA PDP, 
                             CUSTOMER.PESSOALINHA PL, 
                             LINHA.LINHATELEFONICA LT
                        WHERE D.NRDOCUMENTO      = :szNrDocumento
                        AND D.IDDOCUMENTO        = PD.IDDOCUMENTO
                        AND PD.IDPESSOA          = PDP.IDPESSOA
                        AND PDP.IDPESSOADEPARA   = PL.IDPESSOADEPARA
                        AND PL.IDLINHATELEFONICA = LT.IDLINHATELEFONICA
                        AND (LT.IDTIPOLINHA IN (1, 4, 5, 7) OR LT.IDSUBTIPOLINHA IN (50,200))
                        AND (LT.DTEXPIRACAO IS NULL OR LT.DTEXPIRACAO > SYSDATE)
                        AND LT.IDLINHABASE IS NOT NULL;

                        sprintf(szAux, "IdLinhaTelfonica com este Documento [%d]", i_IdLinhaTelefonica); oLog.logDebug(szAux);

                        if(i_IdLinhaTelefonica == 0)
                        {
                            EXEC SQL
                            UPDATE LOAD.TMP_MOVIMENTO 
                                SET RETORNO = '05' ,
                                DTINCLUSAO = TO_CHAR(SYSDATE,'YYYYMMDD') 
                            WHERE SQMOVIMENTO = :szSQMovimento;
                            EXEC SQL COMMIT;
                        }
                        else
                        {
                            /*--######################## PARA IDENTIFICAR O DESCADASTRO ##########################--*/
                            qtMov = 0;
                            
                            EXEC SQL 
                            SELECT COUNT(1) 
                            INTO :qtMov
                            FROM CUSTOMER.PROGRAMARELACIONAMENTOPOS
                            WHERE NRDOCUMENTO = :szNrDocumento
                            AND DTEXCLUSAO IS NOT NULL;

                            if(qtMov > 0 )
                            {
                                EXEC SQL
                                UPDATE LOAD.TMP_MOVIMENTO 
                                    SET RETORNO = '07',
                                    DTINCLUSAO = TO_CHAR(SYSDATE,'YYYYMMDD') 
                                WHERE SQMOVIMENTO = :szSQMovimento;
                                EXEC SQL COMMIT;
                            }
                            else
                            {
                                /*--######################## PARA IDENTIFICAR O NÃO-DESCADASTRO ##########################--*/
                                EXEC SQL 
                                SELECT COUNT(1) 
                                INTO :qtMov
                                FROM CUSTOMER.PROGRAMARELACIONAMENTOPOS
                                WHERE NRDOCUMENTO = :szNrDocumento
                                AND DTEXCLUSAO IS NULL;

                                sprintf(szAux, "Numero de Clientes no Programa de Relacionamentos com este Documento [%d]", qtMov); oLog.logDebug(szAux);

                                if(qtMov > 0 )
                                {
                                   if(linhaArquivo)
                                   {
                                        EXEC SQL
                                        UPDATE LOAD.TMP_MOVIMENTO SET RETORNO = '01' ,
                                            DTINCLUSAO = TO_CHAR(SYSDATE,'YYYYMMDD') 
                                        WHERE SQMOVIMENTO = :szSQMovimento;
                                        EXEC SQL COMMIT;
                                    }
                                    else
                                    {
                                        EXEC SQL
                                        UPDATE LOAD.TMP_MOVIMENTO SET RETORNO = '02' ,
                                            DTINCLUSAO = TO_CHAR(SYSDATE,'YYYYMMDD') 
                                        WHERE SQMOVIMENTO = :szSQMovimento;
                                        EXEC SQL COMMIT;
                                    }
                                }
                                else
                                {
                                    memcpy(&VI_NRLINHASOLICITANTE, (char *) &VI_NRLINHA, sizeof(VI_NRLINHASOLICITANTE));
                                    strToOra(VI_OPERACAO, "INCLUIR");
                                    strToOra(VI_NMUSUARIOATUALIZACAO, "666");

                                    EXEC SQL 
                                    CALL SOA_OW.PRC_MANTERPROGRELACIONAMENTO (  :VI_OPERACAO, 
                                                                                :szNrDocumento, 
                                                                                :VI_NRLINHA, 
                                                                                :VI_NMUSUARIOATUALIZACAO, 
                                                                                :VI_NRLINHASOLICITANTE, 
                                                                                :VI_NRLINHACONTATO, 
																				1, 
                                                                                :VO_CDERRO, 
                                                                                :VO_DSERRO, 
                                                                                :VO_DSCLASSIFICACAOLINHA,
																				:VO_DTADESAO
																				);

                                    sprintf(szAux, "CALL SOA_OW.PRC_MANTERPROGRELACIONAMENTO(%d, %s, %s)", VO_CDERRO, (char *) VO_DSERRO.arr, (char *) VO_DTADESAO.arr); oLog.logDebug(szAux);

                                    if (!VO_CDERRO)
                                    {
                                        if(linhaArquivo)
                                        {
                                            EXEC SQL
                                            UPDATE LOAD.TMP_MOVIMENTO SET RETORNO = '01' ,
                                                DTINCLUSAO = TO_CHAR(SYSDATE,'YYYYMMDD') 
                                            WHERE SQMOVIMENTO = :szSQMovimento;
                                            EXEC SQL COMMIT;
                                        }
                                        else
                                        {
                                            EXEC SQL
                                            UPDATE LOAD.TMP_MOVIMENTO SET RETORNO = '02' ,
                                                DTINCLUSAO = TO_CHAR(SYSDATE,'YYYYMMDD') 
                                            WHERE SQMOVIMENTO = :szSQMovimento;
                                            EXEC SQL COMMIT;
                                        }
                                    }
                                    else
                                    {
                                        EXEC SQL
                                        UPDATE LOAD.TMP_MOVIMENTO SET RETORNO = '99' ,
                                            DTINCLUSAO = TO_CHAR(SYSDATE,'YYYYMMDD') 
                                        WHERE SQMOVIMENTO = :szSQMovimento;
                                        EXEC SQL COMMIT;
                                    }	   
                                }
                            }
                        }
                    }
                }
                        
                EXEC SQL WHENEVER NOT FOUND DO BREAK;
                
                /*--######################### PARA CONSULTAR SE DOCUMENTO PERTENCE AO CLIENTE #############################--*/
 
                oLog.logDebug("<<<Validacoes dos Dados Recebidos");
            }
            
            EXEC SQL
            CLOSE mov;

            /*--#########################  #############################--*/

            strcpy(tParamConf.szPath, path);

            char apath[256]={0};
            strcat(apath, tParamConf.szPath);
            strcat(apath, nomeArquivoRegistros);

            finalizaArquivo(apath, *qtRegistro);
        }
    }
    /*********************************************************************************/
        
    oLog.logDebug("Desconectando da BD...");
    DBDisconnect();

    oLog.logDebug("Processamento encerrado");
    oLog.logDebug("<<<cargaBancosPR");

    exit(0);

    sqlError:
        sprintf(szAux, "Finalizando processo com erro ORACLE (%d-%.256s)", sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);

        EXEC SQL ROLLBACK;

        oLog.logDebug("Vai tentar desconectar da BD...");
        DBDisconnect();

        exit(1);
}

/************************************************************************************************************/
int verifyHeader(char *sqArquivo){
    
    oLog.logDebug("Verificação do Header>>>");
    int errorFound = 0;
    
    EXEC SQL BEGIN DECLARE SECTION;

        short i_SequenciaArquivo = -1;
        short i_DataHeader = -1;
        VARCHAR szSequenciaArquivo[9];
        VARCHAR szSiglaBanco[5];
        VARCHAR szDataHeader[255 + 1];
        
        VARCHAR nmArquivo[255];

        char szDSErro[255 + 1];
        
        int qtSeq = 0;

    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL WHENEVER SQLERROR GOTO errHeader;
    
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    

    bzero(&szSequenciaArquivo, sizeof(szSequenciaArquivo));
    bzero(&szSiglaBanco, sizeof(szSiglaBanco));
    bzero(&szDataHeader, sizeof(szDataHeader));

    /****************************** Header existe? ****************************************/
    EXEC SQL
    SELECT SQARQUIVO, DTMOVIMENTO
    INTO :szSequenciaArquivo:i_SequenciaArquivo, :szDataHeader:i_DataHeader
    FROM LOAD.TMP_HEADER
    where rownum < 2
    order by DTMOVIMENTO desc;
    
    CONVIND(szSequenciaArquivo, i_SequenciaArquivo);
    CONVIND(szDataHeader, i_DataHeader);
    
    strcpy(sqArquivo, (char *) szSequenciaArquivo.arr);

    sprintf(szAux, "Sequencia Header e Data Header [%07s, %s]", (char *) szSequenciaArquivo.arr, (char *) szDataHeader.arr); oLog.logDebug(szAux);
    
    if(i_SequenciaArquivo < 0 && i_DataHeader < 0){
        oLog.logDebug("Arquivo sem Header.\n");
        strcpy(sqArquivo, "<noseq>");
        strcpy(szDSErro, "Arquivo sem Header.");

        char epath[256]={0};
        strcat(epath, tParamConf.szPath);
        strcat(epath, nomeArquivoRegistros);

        registraErro(epath, 1001, szDSErro, sqArquivo);
        return -1;
    }
    
    /****************************** Header com Sequência já processada? ****************************************/
    strToOra(szSiglaBanco, siglaBanco);
    
    sprintf(szAux, "Sigla do Banco Adiquirido [%s]", (char *) szSiglaBanco.arr); oLog.logDebug(szAux);
    
    EXEC SQL
    SELECT COUNT(1)
    INTO :qtSeq
    FROM CUSTOMER.ARQUIVOSCARGABANCOSPR
    WHERE SQARQUIVO = :szSequenciaArquivo
    AND   SG_BANCO  = :szSiglaBanco;
    
    sprintf(szAux, "Numero de sequencias recuperadas iguais a do CUSTOMER [%d]", qtSeq); oLog.logDebug(szAux);

    if(qtSeq > 0){
        oLog.logDebug("Sequencia ja Processada.\n");
        strcpy(szDSErro, "Sequencia ja Processada.");

        char epath[256]={0};
        strcat(epath, tParamConf.szPath);
        strcat(epath, nomeArquivoRegistros);

        registraErro(epath, 1004, szDSErro, sqArquivo);
        return -1;
    }

    /****************************** Header com data Valida? ****************************************/
    
    EXEC SQL 
    SELECT COUNT(1)
    INTO :i_DataHeader
    FROM LOAD.TMP_HEADER
    WHERE SQARQUIVO = :szSequenciaArquivo
    AND TO_NUMBER(TO_CHAR(DTMOVIMENTO, 'YYYYMMDD')) <= TO_NUMBER(TO_CHAR(SYSDATE, 'YYYYMMDD'))
    AND TO_NUMBER(TO_CHAR(DTMOVIMENTO, 'YYYYMMDD')) > TO_NUMBER('20120901');
    
    sprintf(szAux, "Numero de datas validas [%d]", i_DataHeader); oLog.logDebug(szAux);

    if(i_DataHeader == 0){
        oLog.logDebug("Data no Header invalida.\n");
        strcpy(szDSErro, "Data no Header invalida.");

        char epath[256]={0};
        strcat(epath, tParamConf.szPath);
        strcat(epath, nomeArquivoRegistros);

        registraErro(epath, 1005, szDSErro, sqArquivo);
        return -1;
    }
    
    /*Continuando Processo*/
    strToOra(nmArquivo, nomeArquivoRegistros);
    sprintf(szAux, "Continuando Processo... [%s]", (char *) nmArquivo.arr); oLog.logDebug(szAux);
    EXEC SQL
    UPDATE CUSTOMER.CONTROLECARGASPR
    SET    SQARQUIVO = :szSequenciaArquivo
    WHERE  NMARQUIVO = :nmArquivo;
    EXEC SQL COMMIT;
    /*Continuando Processo*/
    
    oLog.logDebug("<<<Verificação do Header");
    return 0;
    
    errHeader:
    
        oLog.logDebug("Excecao ao salvar dados em banco!");
        sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
        oLog.logDebug("<<<Verificação do Header");
        return -1;
}

/************************************************************************************************************/
int verifyTrailler(char *szSequenciaArquivo, int *qtRegistro){
    
    oLog.logDebug("Verificação do Trailler>>>");
    EXEC SQL BEGIN DECLARE SECTION;

        short i_QTRegistro = -1;
        VARCHAR szQTRegistro[15];

        char szDSErro[255 + 1];
        
        int qtSeq = 0;

    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL WHENEVER SQLERROR GOTO errTrailler;
    
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    
    /****************************** Trailler existe?****************************************/      
    EXEC SQL
    SELECT QTREGISTRO
    INTO :szQTRegistro:i_QTRegistro
    FROM LOAD.TMP_TRAILLER;

    CONVIND(szQTRegistro, i_QTRegistro);
    
    sprintf(szAux, "Numero de registros do Trailler [%s]", (char *) szQTRegistro.arr); oLog.logDebug(szAux);

    if(i_QTRegistro < 0){
        oLog.logDebug("Arquivo sem Trailler.\n");
        strcpy(szDSErro, "Arquivo sem Trailler.");

        char epath[256]={0};
        strcat(epath, tParamConf.szPath);
        strcat(epath, nomeArquivoRegistros);

        registraErro(epath, 1002, szDSErro, szSequenciaArquivo);
        
        oLog.logDebug("<<<Verificação do Trailler");
        return -1;
    }else{
        *qtRegistro = atoi((char *) szQTRegistro.arr);
        oLog.logDebug("<<<Verificação do Trailler");
        return 0;
    }
    
    errTrailler:
    
        oLog.logDebug("Excecao ao salvar dados em banco!");
        sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
        oLog.logDebug("<<<Verificação do Trailler");
        return -1;
}

/************************************************************************************************************/
int verifyMovimento(char *szSequenciaArquivo, int *qtRegistros){
    
    oLog.logDebug("Verificação do Movimento>>>");
    int errorFound = 0;
    
    EXEC SQL BEGIN DECLARE SECTION;
        
        short i_SequenciaMovimento = -1;
        VARCHAR szSequenciaMovimento[7];
        
        char szDSErro[255 + 1];
        
        int qtMov = 0;
        int i = 1;

    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL WHENEVER SQLERROR GOTO errMovimento;
    
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    
    /****************************** Movimento existe? ****************************************/          
    /****************************** Quantidade de Registros correto? ****************************************/
    EXEC SQL
    SELECT COUNT(1)
    INTO :qtMov
    FROM LOAD.TMP_MOVIMENTO;

    sprintf(szAux, "Quantidade de registros do Movimento [%d]", qtMov); oLog.logDebug(szAux);
    
    if(*qtRegistros != qtMov){
        oLog.logDebug("Quantidade de Registros do Movimento errada\n");
        strcpy(szDSErro, "Quantidade de Registros do Movimento errada.");

        char epath[256]={0};
        strcat(epath, tParamConf.szPath);
        strcat(epath, nomeArquivoRegistros);

        registraErro(epath, 1003, szDSErro, szSequenciaArquivo);
        return -1;
    }
    /****************************** Movimento com data valida? ****************************************/ 
    
    for(i = 1; i <= *qtRegistros; i++)
    {
    	memset(&szSequenciaMovimento, 0, sizeof(szSequenciaMovimento));
    	i_SequenciaMovimento = -1;
            
        EXEC SQL
        SELECT SQMOVIMENTO
        INTO :szSequenciaMovimento:i_SequenciaMovimento
        FROM (
            SELECT MOV.*, ROWNUM RN 
            FROM LOAD.TMP_MOVIMENTO MOV
            WHERE TO_NUMBER(TO_CHAR(DTARQUIVO, 'YYYYMMDD')) >  TO_NUMBER(TO_CHAR(SYSDATE, 'YYYYMMDD'))
            OR    TO_NUMBER(TO_CHAR(DTARQUIVO, 'YYYYMMDD')) <= TO_NUMBER('20120901')
            )
        WHERE RN = :i;
        
        endOraStr(szSequenciaMovimento);

        //sprintf(szAux, "Sequencia Movimento [%d] [%s]", i, (char *) szSequenciaMovimento.arr); oLog.logDebug(szAux);

        if(szSequenciaMovimento.len > 0)
        {
            sprintf(szAux, "Sequencia Movimento [%07s] possui data mal formatada.", (char *) szSequenciaMovimento.arr); oLog.logInformation(szAux);
            oLog.logDebug("Data no Movimento invalida.\n");
            sprintf(szDSErro, "Data no movimento invalida (sequencia numero %06s) e invalida.", (char *) szSequenciaMovimento.arr);

            char epath[256]={0};
            strcat(epath, tParamConf.szPath);
            strcat(epath, nomeArquivoRegistros);

            registraErro(epath, 1006, szDSErro, szSequenciaArquivo);
            errorFound = -1;
        }
    }
    
    oLog.logDebug("<<<Verificação do Movimento");
    return errorFound;
    
    errMovimento:
    
        oLog.logDebug("Excecao ao salvar dados em banco!");
        sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
        oLog.logDebug("<<<Verificação do Movimento");
        return -1;
}

/************************************************************************************************************/
void ArmaSinal(int iSignal)
{
    sprintf(szAux, "Armando tratamento para Signal(%d)", iSignal); oLog.logInformation(szAux);

    if(signal((iSignal), ProcessaSinal) == SIG_ERR)
    {
        fprintf(stderr, "ERRO ARMANDO SINAL!!!");
        exit(-1);
    }
}

/************************************************************************************************************/
void ProcessaSinal(int iSig)
{
    sprintf(szAux, "iSig(%d)", iSig); oLog.logInformation(szAux);
    
    EXEC SQL BEGIN DECLARE SECTION;
        
        int iCtrl = 0;

    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL WHENEVER SQLERROR GOTO errSig;
    
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    
    iCtrl = iSig;
    
    EXEC SQL
    UPDATE APOIO.PARAMETRO
    SET DSVALORPARAMETRO = :iCtrl
    WHERE CDPARAMETRO = 'INPROCESSACARGABANCOSPR';

    EXEC SQL COMMIT;

    // rearma o mesmo sinal lan?ado
    ArmaSinal(iSig);

    if(iSig == SIGTERM)
    {
        oLog.logInformation("Finalizando processamento via sinal....");
        iSignalProcessa = 0;
    }
    
    errSig:
        
        oLog.logDebug("Excecao ao salvar dados do Sinal!");
        sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
        
}

/************************************************************************************************************/
int ObtemParamConf(TParamConf *ptParamConf)
{
    MFile mfConfig;
    SplitLine NewLinha;
    char szLinha[101];
    char szDivArq[256];
    char szDivPre[21];

    oLog.logDebug("Obtendo parametros de configuracao...");

    // Zera vari?veis
    memset(ptParamConf, 0, sizeof(TParamConf));
    memset(szLinha, 0, sizeof(szLinha));
    memset(szDivArq, 0, sizeof(szDivArq));
    memset(szDivPre, 0, sizeof(szDivPre));

    // Define o arquivo de configura??o
    mfConfig.setPath("cargaBancosPR.cfg");

    // Verificar se conseguiu abrir o arquivo
    if(!mfConfig.abrir())
    {
        oLog.logError("Erro abrindo arquivo de configuracao!");
        return -1;
    }

    // Capturando usuario, senha, path e instance de banco do arquivo
    NewLinha.SetDiv('=');
    while(mfConfig.getLine(szLinha) != 0)
    {
        NewLinha.SetLine(szLinha);
        NewLinha.GetBeforeDiv(szDivPre);
        NewLinha.GetAfterDiv(szDivArq);

        // Verifica qual par?metro foi encontrado.
        if (!strcmp(szDivPre, "pwd_db"))
        {
            strncpy(ptParamConf->szPws, szDivArq, TAM_BD_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_db"))
        {
            strncpy(ptParamConf->szUsr, szDivArq, TAM_BD_USRNAME);
        }
        else if (!strcmp(szDivPre, "inst_db"))
        {
            strncpy(ptParamConf->szInst, szDivArq, TAM_BD_INST);
        }
        else if (!strcmp(szDivPre, "pwd_tux"))
        {
            strncpy(ptParamConf->szPwsTux, szDivArq, TAM_TX_PASSWD);
        }
        else if (!strcmp(szDivPre, "usr_tux"))
        {
            strncpy(ptParamConf->szUsrTux, szDivArq, TAM_TX_USRNAME);
        }
        else if (!strcmp(szDivPre, "pwd_tux_gen"))
        {
            strncpy(ptParamConf->szPwsTuxGen, szDivArq, TAM_TX_GEN);
        }
        else if (strcmp(szDivPre, "clt_tux")==0)
        {
            strncpy(ptParamConf->szCltTux, szDivArq, TAM_TX_CLT);
        }
        else if (strcmp(szDivPre, "QueueName")==0)
        {
            strncpy(ptParamConf->szQueueName, szDivArq, TAM_SZ_QUEUE_NAME);
        }
        else if (strcmp(szDivPre, "ServerUrl")==0)
        {
            strncpy(ptParamConf->szServerUrl, szDivArq, TAM_SZ_SERVER_URL);
        }
        else if (strcmp(szDivPre, "UserName")==0)
        {
            strncpy(ptParamConf->szUserName, szDivArq, TAM_SZ_USERNAME);
        }
        else if (strcmp(szDivPre, "Password")==0)
        {
            strncpy(ptParamConf->szPassword, szDivArq, TAM_SZ_PASSWORD);
        }
        else if (strcmp(szDivPre, "Pk_password")==0)
        {
            strncpy(ptParamConf->szPk_password, szDivArq, TAM_SZ_PKPASSWD);
        }
        else if(strcmp(szDivPre, "path")==0)
        {
            strncpy(ptParamConf->szPath, szDivArq, TAM_SZ_PATH);
        }

        memset(szLinha,  0, sizeof(szLinha));
        memset(szDivPre, 0, sizeof(szDivPre));
        memset(szDivArq, 0, sizeof(szDivArq));
    }

    // Fechando o arquivo de configuracao aberto
    mfConfig.fechar();

    //sprintf(szAux, "ptParamConf->szPws[%s]", ptParamConf->szPws); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szUsr[%s]", ptParamConf->szUsr); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szInst[%s]", ptParamConf->szInst); oLog.logDebug(szAux);
    //sprintf(szAux, "ptParamConf->szPwsTux[%s]", ptParamConf->szPwsTux); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szUsrTux[%s]", ptParamConf->szUsrTux); oLog.logDebug(szAux);
    //sprintf(szAux, "ptParamConf->szPwsTuxGen[%s]", ptParamConf->szPwsTuxGen); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szCltTux[%s]", ptParamConf->szCltTux); oLog.logDebug(szAux);

    sprintf(szAux, "ptParamConf->szQueueName[%s]", ptParamConf->szQueueName); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szServerUrl[%s]", ptParamConf->szServerUrl); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szUserName[%s]", ptParamConf->szUserName); oLog.logDebug(szAux);
    //sprintf(szAux, "ptParamConf->szPassword[%s]", ptParamConf->szPassword); oLog.logDebug(szAux);
    //sprintf(szAux, "ptParamConf->szPk_password[%s]", ptParamConf->szPk_password); oLog.logDebug(szAux);
    sprintf(szAux, "ptParamConf->szPath[%s]", ptParamConf->szPath); oLog.logDebug(szAux);

    // Verifica se todos os dados foram recuperados do arquivo de configura??o.
    if (strlen(ptParamConf->szInst) == 0 ||
        strlen(ptParamConf->szPwsTux) == 0 ||
        strlen(ptParamConf->szUsrTux) == 0 ||
        strlen(ptParamConf->szPwsTuxGen) == 0 ||
        strlen(ptParamConf->szCltTux) == 0 ||
        strlen(ptParamConf->szQueueName) == 0 ||
        strlen(ptParamConf->szServerUrl) == 0 ||
        strlen(ptParamConf->szUserName) == 0 ||
        strlen(ptParamConf->szPassword) == 0 ||
        strlen(ptParamConf->szPath) == 0)
    {
        oLog.logError("Dados incompletos!");
        return -1;
    }

    oLog.logDebug("Parametros de configuracao obtidos com sucesso...");
    return 0;
}

/************************************************************************************************************/
int DBConnect(char *pUsr, char *pPwd, char *pInst)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[256];
    EXEC SQL END DECLARE SECTION;

    // String de conexao
    sprintf(connString, "%s/%s@%s", pUsr, pPwd, pInst);

    // Marca ponto de erro
    EXEC SQL WHENEVER SQLERROR GOTO errConn;
    
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    // Conecta
    EXEC SQL CONNECT :connString;

    return (sqlca.sqlcode);

	errConn:
		oLog.logInformation("<<<DBConnect [ERROR]");
		return -1;
}

/************************************************************************************************************/
void DBDisconnect(void)
{
    EXEC SQL WHENEVER SQLERROR GOTO Error;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL COMMIT WORK RELEASE;
    return;

	Error:
		sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
		return;
}

/************************************************************************************************************/
void UnLockSemaphore(int semid)
{
    struct sembuf sb;

    sb.sem_num = 0;
    sb.sem_op = 1; // free resource
    sb.sem_flg = SEM_UNDO;

    if (semop(semid, &sb, 1) == -1)
    {
        perror("semop");
        exit(1);
    }
}

/********************************************************************************************/
void LockSemaphore(int semid)
{
    struct sembuf sb;

    sb.sem_num = 0;
    sb.sem_op = -1;  // set to allocate resource
    sb.sem_flg = SEM_UNDO;

    if (semop(semid, &sb, 1) == -1)
    {
        perror("semop");
        exit(1);
    }
}

/********************************************************************************************/
/*
** InitSemaphore() -- more-than-inspired by W. Richard Stevens' UNIX Network
** Programming 2nd edition, volume 2, lockvsem.c, page 295.
*/
int InitSemaphore(key_t key, int nsems)
{
    union semun
    {
        int val;
        struct semid_ds *buf;
        ushort *array;
    } arg;

    struct semid_ds buf;
    struct sembuf sb;
    int semid;

    semid = semget(key, nsems, IPC_CREAT | IPC_EXCL | 0666);
    if (semid >= 0)
    { // we got it first
        sb.sem_op = 1;
        sb.sem_flg = 0;
        arg.val = 1;

        for(sb.sem_num = 0; sb.sem_num < nsems; sb.sem_num++)
        {
            // do a semop() to "free" the semaphores.
            // this sets the sem_otime field, as needed below.
            if (semop(semid, &sb, 1) == -1)
            {
                int e = errno;
                semctl(semid, 0, IPC_RMID); // clean up
                errno = e;
                return -1; // error, check errno
            }
        }
    }
    else if (errno == EEXIST)
    {
        int ready = 0;

        semid = semget(key, nsems, 0); // get the id
        if (semid < 0)
            return semid; // error, check errno

        // wait for other process to initialize the semaphore:
        arg.buf = &buf;

        for(int i = 0; i < MAX_RETRIES && !ready; i++)
        {
            semctl(semid, nsems-1, IPC_STAT, arg);

            if (arg.buf->sem_otime != 0)
            {
                ready = 1;
            }
            else
            {
                sleep(1);
            }
        }
        if(!ready)
        {
            errno = ETIME;
            return -1;
        }
    }
    else
    {
        return semid; // error, check errno
    }

    return semid;
}

int OpenDir(char *pszDiretorio, char*pfile)
{
    static DIR *pDir;
    static struct dirent *pDirent;
    static char szArq[512 + 1];
    static int iFlag=1;
    
    EXEC SQL BEGIN DECLARE SECTION;
            
        VARCHAR szFileName[255];

        short i_Suf = -1;
        VARCHAR szSuf[255];

        short i_Date = -1;
        VARCHAR szDate[255];
        
        short i_SiglaBanco = -1;
        VARCHAR szSiglaBanco[255];
        
        int i_Length = 0;

    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL WHENEVER SQLERROR GOTO errFile;
    
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    
    iFlagErrorFile = 0;

    char szAux[1024];

    oLog.logDebug(">>> OpenDir");
    sprintf(szAux, "pszDiretorio[%s]", pszDiretorio); oLog.logDebug(szAux);

    if(iFlag == 1)
    {
        /* Abre diretorio e verifica sucesso */
        pDir = opendir(pszDiretorio);
        if(pDir == NULL)
        {
            sprintf(szAux, "Erro abrindo diretorio [%s]. errno(%d) strerror[%s]", pszDiretorio, errno, strerror(errno)); oLog.logError(szAux);
            iFlagErrorFile = -1;
            exit(-1);
        }

        iFlag=0;
    }

    /* Efetua a leitura dos nomes dos arquivos do diretorio */
    while((pDirent = readdir(pDir)) != NULL )
    {
        sprintf(szAux, "Arquivo obtido[%s]", pDirent->d_name); oLog.logDebug(szAux);

        /* valida arquivo */
        if((!memcmp(pDirent->d_name+strlen(pDirent->d_name)-4, ".txt", 4)))
        {   
            
            strcpy(pfile, pDirent->d_name);
            strToOra(szFileName, pfile);

            /*Iniciando Processo*/
            sprintf(szAux, "Iniciando Processo... [%s]", (char *) szFileName.arr); oLog.logDebug(szAux);
            EXEC SQL
            INSERT INTO CUSTOMER.CONTROLECARGASPR (NMARQUIVO, DTINICIO) 
                VALUES (:szFileName, SYSDATE);
            EXEC SQL COMMIT;
            /*Iniciando Processo*/
            
            sprintf(szAux, "Nome Arquivo [%s]", (char *) szFileName.arr); oLog.logDebug(szAux);
            
            EXEC SQL
            SELECT  
                SUBSTR(:szFileName, 0, 7), 
                UPPER(SUBSTR(:szFileName, 8, 4)),
                TO_DATE(
                    SUBSTR(:szFileName, LENGTH(:szFileName) - 18, 8) 
                    || ' ' ||
                    SUBSTR(:szFileName, LENGTH(:szFileName) - 9, 6)
                    , 'YYYYMMDD HH24MISS'
                ),
                LENGTH(:szFileName)
            INTO :szSuf:i_Suf,
                 :szSiglaBanco:i_SiglaBanco,
                 :szDate:i_Date,
                 :i_Length
            FROM DUAL;
            
            endOraStr(szSuf);
            endOraStr(szSiglaBanco);
            endOraStr(szDate);
            
            sprintf(szAux, "Arquivo valido? SUF = [%s], DATE = [%s] e LENGTH [%d]", (char *) szSuf.arr, (char *) szDate.arr, i_Length); oLog.logDebug(szAux);
            
            if(strcmp((char *) szSuf.arr, "vv_vivo") == 0 && i_Date >= 0 && i_Length <= 36){
            
                sprintf(siglaBanco, "%s", (char *) szSiglaBanco.arr);
                
                /* Monta path + nome do arquivo a ser processado */
                strcpy(szArq, pDirent->d_name);
                sprintf(szAux, "Arquivo validado [%s]", szArq); oLog.logDebug(szAux);

                oLog.logDebug("<<< OpenDir <NOT NULL>");
                strcpy(pfile,szArq);
                return 1;
            }
            else
            {
                /*Finalizando Processo*/
                oLog.logDebug("Finalizando Processo...");
                EXEC SQL
                UPDATE CUSTOMER.CONTROLECARGASPR
                SET    DTFIM      = SYSDATE,
                       ARQUIVOERR = 'Nomenclatura de arquivo inválida.'
                WHERE NMARQUIVO = :szFileName;
                EXEC SQL COMMIT;
                /*Finalizando Processo*/
                
                sprintf(szAux, "Nome Arquivo = [%s]", (char *) szFileName.arr); oLog.logDebug(szAux);
                oLog.logDebug("Nomenclatura do arquivo Invalido.");
                closedir(pDir);
                oLog.logDebug("<<< OpenDir <NULL>");
                return 2;
            }
        }
    }

    closedir(pDir);
    iFlag = 0;
    oLog.logDebug("<<< OpenDir <NULL>");
    return 0;
    
    errFile:
    
        oLog.logDebug("Excecao ao salvar dados em banco!");
        sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s",sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
        closedir(pDir);
        oLog.logDebug("<<< OpenDir <NULL>");
        return 0;
}

int checkBadError(char *pszDiretorio)
{
    static DIR *pDir;
    static struct dirent *pDirent;
    static char szArq[512 + 1];
    static int iFlag=1;

    char szAux[1024];

    oLog.logDebug(">>> Open Error Dir");
    sprintf(szAux, "pszDiretorio[%s]", pszDiretorio); oLog.logDebug(szAux);

    if(iFlag == 1)
    {
        /* Abre diretorio e verifica sucesso */
        pDir = opendir(pszDiretorio);
        if(pDir == NULL)
        {
            sprintf(szAux, "Erro abrindo diretorio [%s]. errno(%d) strerror[%s]", pszDiretorio, errno, strerror(errno)); oLog.logError(szAux);
            return -1;
        }

        iFlag=0;
    }

    /* Efetua a leitura dos nomes dos arquivos do diretorio */
    while((pDirent = readdir(pDir)) != NULL )
    {
        sprintf(szAux, "Arquivo Erro obtido[%s]", pDirent->d_name); oLog.logDebug(szAux);

        /* valida arquivo */
        if((!memcmp(pDirent->d_name+strlen(pDirent->d_name)-4, ".bad", 4)))
        {
            /* Monta path + nome do arquivo a ser processado */
            strcpy(szArq, pDirent->d_name);
            sprintf(szAux, "Arquivo validado [%s]", szArq); oLog.logDebug(szAux);

            char path[255] = "";
            strcpy(path, pszDiretorio);
            strcat(path, szArq);
            
            remove(path);
            oLog.logDebug("<<< Open Error Dir <NOT NULL>");
            return -1;
        }
    }

    closedir(pDir);
    iFlag = 1;
    oLog.logDebug("<<< Open Error Dir <NULL>");
    return 0;
}

int registraErro(char *szPathArquivo, int cdErro, char *dsErro, char *szSequenciaArquivo)
{
    
    oLog.logDebug("RegistraErro>>>");
    
    //sprintf(szAux, "szPathArquivo:[%s], cdErro:[%d], dsErro:[%s], szSequenciaArquivo:[%s]", szPathArquivo, cdErro, dsErro, szSequenciaArquivo); oLog.logDebug(szAux);

    EXEC SQL BEGIN DECLARE SECTION;

        int szCdErro = cdErro;
        VARCHAR szDSErro[101];
	int iSequenciaArquivo;
        
        VARCHAR nmArquivo[255];
        VARCHAR nmArquivoErro[255];
        VARCHAR dtRejeicao[255];

    EXEC SQL END DECLARE SECTION;
    
    FILE *pFile;
    char errorMsg[255] = "";
    
    strToOra(szDSErro, dsErro);
    iSequenciaArquivo = atoi(szSequenciaArquivo);

    sprintf(szAux, "Variaveis p/ inserir [%07d, %d, %s, SYSDATE]", iSequenciaArquivo, szCdErro, (char*)szDSErro.arr); oLog.logDebug(szAux);
    
    EXEC SQL WHENEVER SQLERROR GOTO RegErr;
    
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    
    EXEC SQL
    SELECT TO_CHAR(SYSDATE, 'YYYYMMDD-HH24MISS')
    INTO :dtRejeicao
    FROM DUAL;
    
    endOraStr(dtRejeicao);
    
    EXEC SQL
    INSERT INTO LOAD.TMP_ERRO (SQSEQUENCIA, CDERRO, DSERRO, DTREJEICAO)
        VALUES (:iSequenciaArquivo, :szCdErro, :szDSErro, TO_DATE(:dtRejeicao, 'YYYYMMDD-HH24MISS'));
    EXEC SQL COMMIT;
    
    /**********************************************************************************/
    
    char path[255];
    memset(path, 0x0, sizeof(path));
    sprintf(szAux, "Local do arquivo antes = [%s]", szPathArquivo); oLog.logDebug(szAux);
    sprintf(szAux, "Local do arquivo depois = [%s]", path); oLog.logDebug(szAux);
    strcpy(path, "../error/");
    strcat(path, nomeArquivoRegistros);
    sprintf(szAux, "mv %s %s", szPathArquivo, path); oLog.logDebug(szAux);
    system(szAux);
    
    /***********************************************************************************/
    
    memset(path, 0x0, sizeof(path));
    strcpy(path, "../error/");
    strncat(path, nomeArquivoRegistros, strlen(nomeArquivoRegistros) - 4);
    strcat(path, "-log.txt");
    
    strToOra(nmArquivo, nomeArquivoRegistros);
    strToOra(nmArquivoErro, path);
    
    EXEC SQL
    UPDATE CUSTOMER.CONTROLECARGASPR
    SET    SQARQUIVO  = :iSequenciaArquivo,
           DTFIM      = TO_DATE(:dtRejeicao, 'YYYYMMDD-HH24MISS'),
           ARQUIVOERR = :nmArquivoErro
    WHERE NMARQUIVO = :nmArquivo;
    EXEC SQL COMMIT;

    pFile = fopen(path, "a");
    sprintf(szAux, "Caminho do arquivo de Erro = %s", path); oLog.logDebug(szAux);

    if (pFile != NULL){

        sprintf(errorMsg, "%d%100s%s%07d\r\n", cdErro, dsErro, (char *) dtRejeicao.arr, iSequenciaArquivo);
        sprintf(szAux, "Mensagem de Erro = %s", errorMsg); oLog.logDebug(szAux);

        fputs (errorMsg,pFile);
        fclose (pFile);
    }
    
    oLog.logDebug("<<<RegistraErro");
    return 0;
    
    RegErr:
        sprintf(szAux, "ERRO ORACLE -> sqlcode=%d,sqlerrmc=%.70s", sqlca.sqlcode, sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);
        
        return -1;
}

int finalizaArquivo(char *szPathArquivo, int qtRegistros)
{ 
    oLog.logDebug("finalizaArquivo>>>");
    
    char newNomeArquivo[255] = "";
    memset(newNomeArquivo, 0x0, sizeof(newNomeArquivo));
    strcat(newNomeArquivo, "../temp/");
    strcat(newNomeArquivo, nomeArquivoRegistros);
    
    char szPog[1000];

    EXEC SQL BEGIN DECLARE SECTION;
        int fd;
    
        int i = 1;
        VARCHAR detail[1000];
        VARCHAR szSiglaBanco[5];
        char szProcedure[10000];
        char O_CDERRO[256];
        char O_DSERRO[1024];
        
        VARCHAR nmArquivo[255];
    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL WHENEVER SQLERROR GOTO Error;
    
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    
    FILE *pFile;
    
    pFile = fopen(newNomeArquivo, "w");

    sprintf(szAux, "Caminho do Arquivo = %s", szPathArquivo); oLog.logDebug(szAux);
    sprintf(szAux, "Caminho do Novo Arquivo = %s", newNomeArquivo); oLog.logDebug(szAux);
    
    if (pFile != NULL)
    {
        EXEC SQL
        SELECT RPAD('00' || LPAD(TO_CHAR(SQARQUIVO), 7, '0') || TO_CHAR(DTMOVIMENTO, 'YYYYMMDD'), 149, ' ')
        INTO :detail
        FROM LOAD.TMP_HEADER;
        
            endOraStr(detail);
	    sprintf(szAux, "Header do Arquivo = %s", (char*)detail.arr); oLog.logDebug(szAux);
		
            sprintf( szPog, "%.*s\r\n", detail.len, (char*)detail.arr );

            fputs(szPog,pFile);
       

        sprintf(szAux, "Linha Header [%s]", szPog); oLog.logDebug(szAux);
        
        EXEC SQL WHENEVER NOT FOUND DO BREAK;
        
        EXEC SQL
        DECLARE mov2 CURSOR FOR
        SELECT RPAD(substr( 
                '01' 
                || LPAD(TO_CHAR(SQMOVIMENTO), 6, '0')
                || NVL(LPAD(NRLINHA, 11, ' '), '           ') 
                || LPAD(NRDOCUMENTO, 11, 0) 
                || LPAD(TO_CHAR(QTPONTOS), 9, '0') 
                || TO_CHAR(DTARQUIVO, 'YYYYMMDD')
                || NVL(LPAD(IDBANCO, 20, '0'), '00000000000000000000') 
                || NVL(CTRLBANCO, '                    ') 
                || DTINCLUSAO
                || RETORNO,1,97), 149, ' ')
        FROM LOAD.TMP_MOVIMENTO
        ORDER BY SEQUENCE_MOV;
        
        EXEC SQL OPEN mov2;
        
        for(;;)
        {
            EXEC SQL FETCH mov2 INTO :detail;
            
            endOraStr(detail);
            sprintf( szPog, "%.*s\r\n", detail.len, (char*)detail.arr );

            sprintf(szAux, "Linha Movimento [%d] [%s]", i, szPog); oLog.logDebug(szAux);

            fputs(szPog, pFile);  
        }
        
        EXEC SQL CLOSE mov2;
        
        EXEC SQL WHENEVER NOT FOUND CONTINUE;
        
        EXEC SQL
        SELECT RPAD('99' || LPAD(TO_CHAR(QTREGISTRO), 9, '0'), 149, ' ')
        INTO :detail
        FROM LOAD.TMP_TRAILLER;
        
        endOraStr(detail);
        sprintf( szPog, "%.*s\r\n", detail.len, (char*)detail.arr );

        fputs(szPog,pFile);

        sprintf(szAux, "Linha Trailler [%s]", szPog); oLog.logDebug(szAux);
        
        fclose(pFile);
        
        /**********************************************************************/
        char path[255];
        memset(path, 0x0, sizeof(path));
        sprintf(szAux, "Arquivo Original = [%s]", szPathArquivo); oLog.logDebug(szAux);
        strncat(path, szPathArquivo, strlen(szPathArquivo) - 4);
        strcat(path, ".prc");
        sprintf(szAux, "Arquivo Modificado = [%s]", path); oLog.logDebug(szAux);
        sprintf(szAux, "mv %s %s", szPathArquivo, path); oLog.logDebug(szAux);
        system(szAux);
        /**********************************************************************/
        
        strToOra(szSiglaBanco, siglaBanco);
            
        /*
         *EXEC SQL 
         *CALL LOAD.PRC_LIMPACAMPOSCARGABANCOSPR(:szSiglaBanco, :O_CDERRO, :O_DSERRO);
         *sprintf(szAux, "Resultado da execução da Proc[CDERRO, DSERRO] = [%s, %s]", O_CDERRO, O_DSERRO); oLog.logDebug(szAux);
         */
       
        EXEC SQL 
        INSERT INTO CUSTOMER.ARQUIVOSCARGABANCOSPR (SQARQUIVO, SG_BANCO, DTMOVIMENTO) 
        (
            SELECT SQARQUIVO, :szSiglaBanco, DTMOVIMENTO
            FROM LOAD.TMP_HEADER
        );
        EXEC SQL COMMIT;
        
        /*Finaliza Processo*/
        strToOra(nmArquivo, nomeArquivoRegistros);
        sprintf(szAux, "Finalizando Processo... [%s]", (char *) nmArquivo.arr); oLog.logDebug(szAux);
        EXEC SQL
        UPDATE CUSTOMER.CONTROLECARGASPR
        SET    DTFIM     = SYSDATE
        WHERE  NMARQUIVO = :nmArquivo;
        EXEC SQL COMMIT;
        /*Finaliza Processo*/
    }
    else{
        oLog.logDebug("Falha na criação do Arquivo de Resposta.");
    }
    
    oLog.logDebug("<<<finalizaArquivo");
    
    return 0;
    
    Error:
        sprintf(szAux, "Erro na montagem de arquivo de resposta."); oLog.logDebug(szAux);
        sprintf(szAux, "Finalizando processo com erro ORACLE (%d-%.256s)\n", sqlca.sqlcode,sqlca.sqlerrm.sqlerrmc); oLog.logDebug(szAux);

        EXEC SQL ROLLBACK;
        
        return -1;
}
