/**
 * @modulo  Batch
 * @usecase Batch
 * @author
 * @version $Revision: 1.1.6.2 $
 * @CVS     $Author: jones $ - $Date: 2013/07/10 21:39:27 $
 **/

#include <iostream>
#include <vector>
#include <map>
#include <string>
#include <sstream>
#include <fstream>

#include "../include/expurgoRegistrosPreAtivacao.h"
#include "../../commons/Log/include/Log.h"

/*Old Libs from C*/
#include <stdlib.h>
#include <sys/sem.h>
#include <unistd.h>

using namespace std;

EXEC SQL INCLUDE SQLCA;

#define MAX_RETRIES 			10

#define endOraStr(varstr)      	varstr.arr[varstr.len]= '\0'
#define oraToStr(bstr,vchar)   	if(!bstr) strncpy(bstr,vchar.arr,vchar.len)
#define strToOra(vchar,bstr)   	vchar.len = strlen(bstr);strncpy((char *)vchar.arr,bstr,vchar.len);vchar.arr[vchar.len] = 0
#define strconv(buffer,fonte)  	sprintf(buffer,"%d",fonte)

void UnLockSemaphore(int semid);
void LockSemaphore(int semid);
int InitSemaphore(key_t key, int nsems);
char* convertStringToCharPointer(string str);
int obterParameters();
int DBConnect();
int DBDisconnect();

//Globais
Log oLog;
//TParamConf tParamConf;
map<string,string> tParamConf;
stringstream strAux;

int main(int argc, char* argv[])
{
	EXEC SQL BEGIN DECLARE SECTION;

		int qtdDias = 0;

		short i_DSVALORPARAMETRO;
		VARCHAR szDSVALORPARAMETRO[255];

	EXEC SQL END DECLARE SECTION;

    oLog.setNivel(2); //Nivel 2 = Debug

    oLog.logDebug(">>>expurgoRegistrosPreAtivacao");

    oLog.logDebug("Obtendo Parametros...");
	if(obterParameters() == -1)
	{
		oLog.logError("Erro obtendo parametros de configuracao!");
		return -1;
	}
	oLog.logDebug("Parametros Obtidos...");

	oLog.logDebug("Conectando na BD...");
	if (DBConnect() == -1)
	{
		oLog.logError("Erro conectando no banco de dados!");
		return -1;
	}
	oLog.logDebug("Conectado na BD com sucesso...");

	oLog.logDebug(">>>Processamento dos Dados");

	memset(&szDSVALORPARAMETRO, 0x0, sizeof(szDSVALORPARAMETRO));
	i_DSVALORPARAMETRO = -1;

	EXEC SQL
	SELECT  DSVALORPARAMETRO
	INTO	:szDSVALORPARAMETRO:i_DSVALORPARAMETRO
	FROM    APOIO.PARAMETRO
	WHERE   CDPARAMETRO = 'QTD_DIAS_EXPURGO_REGISTROS_PREATIVACAO';

	if(i_DSVALORPARAMETRO < 0)
	{
		oLog.logDebug("Parametro QTD_DIAS_EXPURGO_REGISTROS_PREATIVACAO não existente!");
	}
	else
	{
		qtdDias = atoi((char *) szDSVALORPARAMETRO.arr);

		EXEC SQL
		DELETE FROM CUSTOMER.PREATIVACAODESCONTO WHERE DTULTIMAALTERACAO < SYSDATE - :qtdDias;

		oLog.logDebug("Dados antigos removidos com Sucesso!");
	}

	oLog.logDebug("<<<Processamento dos Dados");

	oLog.logDebug("Desconectando da BD...");
	DBDisconnect();

	oLog.logDebug("Processamento encerrado");
    oLog.logDebug("<<<expurgoRegistrosPreAtivacao");

    return 0;

    sqlError:
		strAux.str("");strAux << "MAIN > Finalizando processo com erro ORACLE (" << sqlca.sqlcode << "-" << sqlca.sqlerrm.sqlerrmc; oLog.logDebug(convertStringToCharPointer(strAux.str()));
        return -1;
}

/********************************************************************************************/
int obterParameters()
{
	string data;

	ifstream infile("expurgoRegistrosPreAtivacao.cfg");
	if(infile)
	{
		while(true)
		{
			if(infile.eof()) break;

			infile >> data;
			string key = data.substr(0, data.find("="));
			string val = data.substr(data.find("=") + 1, data.size());
			tParamConf.insert(pair<string,string>(key,val));
		}
	}
	else
	{
		oLog.logDebug("Erro na verificação de Arquivos!");
		return -1;
	}
	infile.close();

	map<string,string>::iterator it = tParamConf.begin();
	for(it = tParamConf.begin(); it != tParamConf.end(); ++it)
	{
		strAux.str("");strAux << "tParamConf[" << it->first << "] = " << it->second; oLog.logDebug(convertStringToCharPointer(strAux.str()));
	}

	return 0;
}

/********************************************************************************************/
int DBConnect()
{
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[256];
    EXEC SQL END DECLARE SECTION;

    // String de conexao
    stringstream conn;
    conn.str("");conn << tParamConf["usr_db"] << "/" << tParamConf["pwd_db"] << "@" << tParamConf["inst_db"];
    strcpy(connString, convertStringToCharPointer(conn.str()));

    // Marca ponto de erro
    EXEC SQL WHENEVER SQLERROR GOTO errConn;

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    // Conecta
    EXEC SQL CONNECT :connString;

    return (sqlca.sqlcode);

	errConn:
		oLog.logInformation("<<<DBConnect [ERROR]");
		return -1;
}

/************************************************************************************************************/
int DBDisconnect()
{
    EXEC SQL WHENEVER SQLERROR GOTO Error;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL COMMIT WORK RELEASE;

    return 0;

	Error:
		strAux.str("");strAux << "ERRO ORACLE -> sqlcode = " << sqlca.sqlcode << ", sqlerrmc = " << sqlca.sqlerrm.sqlerrmc; oLog.logDebug(convertStringToCharPointer(strAux.str()));
		return -1;
}

/************************************************************************************************************/
void UnLockSemaphore(int semid)
{
    struct sembuf sb;

    sb.sem_num = 0;
    sb.sem_op = 1; // free resource
    sb.sem_flg = SEM_UNDO;

    if (semop(semid, &sb, 1) == -1)
    {
        perror("semop");
        exit(1);
    }
}

/********************************************************************************************/
void LockSemaphore(int semid)
{
    struct sembuf sb;

    sb.sem_num = 0;
    sb.sem_op = -1;  // set to allocate resource
    sb.sem_flg = SEM_UNDO;

    if (semop(semid, &sb, 1) == -1)
    {
        perror("semop");
        exit(1);
    }
}

/********************************************************************************************/
int InitSemaphore(key_t key, int nsems)
{
    union semun
    {
        int val;
        struct semid_ds *buf;
        ushort *array;
    } arg;

    struct semid_ds buf;
    struct sembuf sb;
    int semid;

    semid = semget(key, nsems, IPC_CREAT | IPC_EXCL | 0666);
    if (semid >= 0)
    { // we got it first
        sb.sem_op = 1;
        sb.sem_flg = 0;
        arg.val = 1;

        for(sb.sem_num = 0; sb.sem_num < nsems; sb.sem_num++)
        {
            // do a semop() to "free" the semaphores.
            // this sets the sem_otime field, as needed below.
            if (semop(semid, &sb, 1) == -1)
            {
                int e = errno;
                semctl(semid, 0, IPC_RMID); // clean up
                errno = e;
                return -1; // error, check errno
            }
        }
    }
    else if (errno == EEXIST)
    {
        int ready = 0;

        semid = semget(key, nsems, 0); // get the id
        if (semid < 0)
            return semid; // error, check errno

        // wait for other process to initialize the semaphore:
        arg.buf = &buf;

        for(int i = 0; i < MAX_RETRIES && !ready; i++)
        {
            semctl(semid, nsems-1, IPC_STAT, arg);

            if (arg.buf->sem_otime != 0)
            {
                ready = 1;
            }
            else
            {
                sleep(1);
            }
        }
        if(!ready)
        {
            errno = ETIME;
            return -1;
        }
    }
    else
    {
        return semid; // error, check errno
    }

    return semid;
}

/********************************************************************************************/
char* convertStringToCharPointer(string str)
{
	/* leak & not needed
	char *c = new char[str.length() + 1];
	strcpy(c, str.c_str());
	return c;
	*/

	return const_cast<char*>(str.c_str());
}
