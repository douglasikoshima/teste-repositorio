#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
#include<ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "../include/MailingServico.h"

MailingServico::MailingServico()
{
	memset(&m_erroOracle,0,4097);
	m_log.setNivel(2);
	m_servicoAtivo = 0;
	m_log.logInformation("MailingServico::MailingServico()");
}

MailingServico::~MailingServico()
{
	m_log.logInformation("MailingServico::~MailingServico()");
}

void MailingServico::excluirMailing(char*idMailingBanner)
{
	m_log.logInformation("MailingServico::excluirMailing()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidMailingBanner = idMailingBanner;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL
		delete from vol.mailinglinha where idmailingbanner = :cidMailingBanner;		
	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL
		delete from vol.mailingbanner where idmailingbanner = :cidMailingBanner;
	m_log.logInformation("ok");	
	EXEC SQL COMMIT;
	return;

sqlError:
		sprintf(m_erroOracle, "Finalizando com erro sqlca.sqlcode(%d)\n", sqlca.sqlcode); 
		m_log.logDebug(m_erroOracle);
}

void MailingServico::insereLinha(char*ddd,char*linha,char*idMailingBanner)
{
	m_log.logInformation("MailingServico::insereLinha()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* cdAreaRegistro = ddd;
		char* nrLinha = linha;
		char* cidMailingBanner = idMailingBanner;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL
		INSERT INTO VOL.MAILINGLINHA (IDMAILINGBANNER,CDAREAREGISTRO,NRLINHA)
		VALUES (:cidMailingBanner,:cdAreaRegistro,:nrLinha);
	m_log.logInformation("ok");	
	EXEC SQL COMMIT;
	return;

sqlError:
		sprintf(m_erroOracle, "Finalizando com erro sqlca.sqlcode(%d)\n", sqlca.sqlcode); 
		m_log.logDebug(m_erroOracle);
}

void MailingServico::removeParametro(char*cdParametro)
{
	m_log.logInformation("MailingServico::removeParametro()");
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
		char* pcdParametro = cdParametro;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR GOTO sqlError;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;
	EXEC SQL
		DELETE FROM APOIO.PARAMETRO WHERE CDPARAMETRO = :pcdParametro;
	m_log.logInformation("ok");	
	EXEC SQL COMMIT;
	return;

sqlError:
		sprintf(m_erroOracle, "Finalizando com erro sqlca.sqlcode(%d)\n", sqlca.sqlcode); 
		m_log.logDebug(m_erroOracle);
}

void MailingServico::processaMailing()
{
    m_log.logInformation("MailingServico::processaMailing()");
    struct sqlca sqlca;
        
    list< MailingServico > listaParametros;
    MailingServico mailingServico;
    listaParametros.clear();
    char arquivo[756];
    memset( arquivo, 0x0,sizeof(arquivo));	

    EXEC SQL BEGIN DECLARE SECTION;
        struct param{
            VARCHAR cdParametro[256];
            VARCHAR dsValorParametro[256];
        }m_param;
        struct iparam{
            short cdParametro;
            short dsValorParametro;
        }m_iparam;	
    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL WHENEVER SQLERROR goto erro;	
    EXEC SQL DECLARE PARAMETRO CURSOR FOR
        SELECT  CDPARAMETRO,
            TRIM(DSVALORPARAMETRO)
        FROM APOIO.PARAMETRO
        WHERE CDPARAMETRO LIKE 'MAILINGBANNER%';
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    EXEC SQL OPEN PARAMETRO;
    for(;;)
    {
        memset(&m_param,0,sizeof(m_param));
        memset(&m_iparam,0,sizeof(m_iparam));
        EXEC SQL FETCH PARAMETRO INTO :m_param:m_iparam;		
        mailingServico.setNomeArquivo((char*)m_param.cdParametro.arr);
        mailingServico.setIdMailingBanner((char*)m_param.dsValorParametro.arr);
        listaParametros.push_back(mailingServico);
    }
    EXEC SQL CLOSE PARAMETRO;
    // percorre lista de arquivos para processar do mailing
    if(listaParametros.size() > 0){
        while( 0 < listaParametros.size() ) {			
            MailingServico mailing = listaParametros.front();
            m_log.logInformation("Achou um arquivo de mailingbanner, vai abrir o arquivo e processar...");
            m_log.logInformation(mailing.getNomeArquivo());
            sprintf(arquivo,"%s%s",this->getPathArquivo(),mailing.getNomeArquivo());
            MFile file;
            file.setPath(arquivo);
            if(!file.abrir())
            {
                m_log.logInformation("Erro ao abrir arquivo");
                break;
            }
            char linha[500];
            memset(&linha,0,sizeof(linha));
            while(file.getLine(linha) == 1)
            {
                char ddd[3];
                char nrLinha[16];
                memset(&ddd,0,sizeof(ddd));
                memset(&nrLinha,0,sizeof(nrLinha));
                

                if(strlen(linha) > 11)
                {
                    /*
                    ddd[0] = linha[0];
                    ddd[1] = linha[1];
                    ddd[2] = '\0';
                    nrLinha[0] = linha[2];
                    nrLinha[1] = linha[3];
                    nrLinha[2] = linha[4];
                    nrLinha[3] = linha[5];
                    nrLinha[4] = linha[6];
                    nrLinha[5] = linha[7];
                    nrLinha[6] = linha[8];
                    nrLinha[7] = linha[9];
                    nrLinha[8] = '\0';
                    */
                    sprintf( ddd    , "%.2s", linha );
                    sprintf( nrLinha, "%s", (char*)&linha[2] );
                    m_log.logInformation(linha);
                    this->insereLinha(ddd,nrLinha,mailing.getIdMailingBanner());
                }
                memset(&linha,0,sizeof(linha));
			}
			file.removeFile();
			file.fechar();
			m_log.logInformation("finalizou leitura de arquivo");	
			this->removeParametro(mailing.getNomeArquivo());
			listaParametros.pop_front();
		}
	}else
	{
		m_log.logInformation("Não existe nenhum arquivo para ser processado.");
	}

	return;

    erro:
        sprintf(m_erroOracle, "Finalizando com erro sqlca.sqlcode(%d)\n", sqlca.sqlcode); 
	m_log.logDebug(m_erroOracle);
}

char*MailingServico::getNomeArquivo()
{
	return this->m_nomeArquivo;
}
void MailingServico::setNomeArquivo(char*nomeArquivo)
{
	if(nomeArquivo != NULL)
		strcpy(this->m_nomeArquivo,nomeArquivo);
}
char*MailingServico::getIdMailingBanner()
{
	return this->m_idMailingBanner;
}
void MailingServico::setIdMailingBanner(char*idMailingBanner)
{
	if(idMailingBanner != NULL)
		strcpy(this->m_idMailingBanner,idMailingBanner);
}
void MailingServico::setPathArquivo(char*pathArquivo)
{
	if(pathArquivo != NULL)
		strcpy(this->m_pathArquivo,pathArquivo);
}
char* MailingServico::getPathArquivo()
{
	return this->m_pathArquivo;
}


char* MailingServico::getParametro(char*nome,char*param)
{
	
	struct sqlca sqlca;
	char valor[256];
    EXEC SQL BEGIN DECLARE SECTION;
        VARCHAR parametroValor[256];
		char* parametro = nome;
    EXEC SQL END DECLARE SECTION;	

	memset(&parametroValor,0,sizeof(parametroValor));
	memset(&valor,0,256);
	memset(param,0,sizeof(param));

    EXEC SQL WHENEVER SQLERROR goto erro;
	EXEC SQL WHENEVER NOT FOUND goto erro;

	EXEC SQL
		SELECT DSVALORPARAMETRO 
		INTO :parametroValor
		FROM APOIO.PARAMETRO
		WHERE CDPARAMETRO = :parametro;

	if(((char*)parametroValor.arr)!=NULL)
		strcpy(param,(char*)parametroValor.arr);

	return param;

    erro:
        sprintf(m_erroOracle, "Finalizando com erro sqlca.sqlcode(%d)\n", sqlca.sqlcode); 
		m_log.logDebug(m_erroOracle);
        return NULL;
}

int MailingServico::connect(char *sid)
{

	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        char *connString = sid;
    EXEC SQL END DECLARE SECTION;

    m_log.logInformation("connect\n");

   // sprintf(connString, "%s/%s@%s", pUsr, pPwd, pInst);


	m_log.logInformation(connString);

    EXEC SQL WHENEVER SQLERROR GOTO errConn;

    EXEC SQL CONNECT :connString;

    //m_log.logInformation("connect.\n");

    return (sqlca.sqlcode);
    
errConn:
	sprintf(m_erroOracle, "Erro! sqlca.sqlcode = %i\n", sqlca.sqlcode); 
    m_log.logInformation("connect [ERROR]\n");
    m_log.logError(m_erroOracle);
    return -1;
}

void MailingServico::disconnect()
{
	struct sqlca sqlca;
    m_log.logInformation("disconnect\n");

    EXEC SQL WHENEVER SQLERROR GOTO Error;
    // EXEC SQL COMMIT WORK RELEASE;

    m_log.logInformation("disconnect.\n");
    return;

Error:
    //sprintf(m_erroOracle, "Erro! sqlca.sqlcode = %i\n", sqlca.sqlcode); 
	m_log.logError(m_erroOracle);
}


int MailingServico::removeRegistro(char*registro)
{
	m_log.logInformation("MailingServico::removeRegistro");
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        char *cregistro = registro;
    EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR GOTO error;
	EXEC SQL WHENEVER NOT FOUND goto error;
	EXEC SQL
		DELETE FROM INFRA.COMPSERVICODESATIVADO
		WHERE IDCOMPSERVICODESATIVADO = :cregistro;

	m_log.logInformation("registro removido com sucesso");

	return 1;

error:
	sprintf(m_erroOracle, "Erro! sqlca.sqlcode = %i\n", sqlca.sqlcode); 
	m_log.logError(m_erroOracle);
	return 0;
}



/**
  * Não está sendo usado o xercer para fazer parse do XML de entrada
  */
char *MailingServico::getTag(char *pXml, char *pTag)
{
    static char szValue[255 + 1];
    char szXmlAux[6096 + 1];
    char *pTok;
    int iFlag=0;

    /* copia string a ser analisada para buffer local (strtok altera o ponteiro de entrada) */
    strcpy(szXmlAux, pXml);

    for(pTok = strtok(szXmlAux, "<>"); pTok != NULL; pTok = strtok(NULL, "<>")) {
        if(iFlag) {
            strcpy(szValue, pTok);
            iFlag=0;

            return szValue;
        }

        if(!strcmp(pTag, pTok)) {
            iFlag=1;
        }
    }

    return NULL;
}

void MailingServico::setQttentativas(int qtTentativas)
{
	this->m_qtTentativas = qtTentativas;
}
void MailingServico::setRegistros(int registros)
{
	this->m_registros = registros;
}
void MailingServico::setTempo(int tempo)
{
	this->m_tempo = tempo;
}
void MailingServico::setTempoSemFila(int tempoSemFila)
{
	this->m_tempoSemFila = tempoSemFila;
}
int MailingServico::getQttentativas()
{
	return this->m_qtTentativas;
}
int MailingServico::getRegistros()
{
	return this->m_registros;
}
int MailingServico::getTempo()
{
	return this->m_tempo;
}
int MailingServico::getTempoSemFila()
{
	return this->m_tempoSemFila;
}
void MailingServico::setTempoReprocessar(int tempoReprocessar)
{
	this->m_tempoReprocessar = tempoReprocessar;
}
int MailingServico::getTempoReprocessar()
{
	return this->m_tempoReprocessar;
}
void MailingServico::setSignalProcessa(int *signal)
{
	this->m_piSignalProcessa = signal;
}

int MailingServico::getSignalProcessa()
{
	return *this->m_piSignalProcessa;
}


bool MailingServico::continuaProcessamento()
{
	m_log.logInformation("MailingServico::continuaProcessamento()");
    char *pPointer=NULL;
    static int iCtrl=1;
	char szAux[4096 + 1];
	char servicoAtivo[20];

    pPointer = getParametro("DEAMMON_COMPROVANTE_ATIVO",servicoAtivo);
    sprintf(szAux, "DEAMMON_COMPROVANTE_ATIVO[%s]\n", pPointer?pPointer:"...NULL..."); m_log.logDebug(szAux);
    if(pPointer == NULL)
    {
        m_log.logDebug("Parametro de configuracao nao encontrado DEAMMON_COMPROVANTE_ATIVO\n");
        exit(-1);
    }
    m_servicoAtivo = atoi(pPointer);

    if(m_servicoAtivo == 0) {
        iCtrl=1;
        m_log.logDebug("inativo");
        return false;
    }
    else { 
		getParametrosBase();
        m_log.logDebug("ativo");
        return true;
    }
}

int MailingServico::getParametrosBase()
{
	m_log.logInformation("Recuperar parametros da base");
	// ler parametros 
	char qtTentativas[256];
	char registros[256];
	char tempoReprocessar[256];
		
	this->getParametro("DEAMMON_COMPROVANTE_QTTENTATIVAS",qtTentativas);
	this->getParametro("DEAMMON_COMPROVANTE_REGISTROS_POR_VEZ",registros);
	this->getParametro("DEAMMON_COMPROVANTE_TEMPO_REPROCESSAR",tempoReprocessar);

	if( strlen(qtTentativas) == 0 || strlen(registros) == 0 ||
		strlen(tempoReprocessar) == 0)
	{
		 m_log.logError("Parametros de base incompletos!\n");
		 return 0;
	}
	m_log.logInformation("DEAMMON_COMPROVANTE_QTTENTATIVAS");
	m_log.logInformation(qtTentativas);
	m_log.logInformation("DEAMMON_COMPROVANTE_REGISTROS_POR_VEZ");
	m_log.logInformation(registros);
	m_log.logInformation("DEAMMON_COMPROVANTE_TEMPO_REPROCESSAR");
	m_log.logInformation(tempoReprocessar);

	try
	{
		this->setQttentativas(atoi(qtTentativas));
		this->setRegistros(atoi(registros));
		this->setTempoReprocessar(atoi(tempoReprocessar));
		return 1;
	}catch(...)
	{
		m_log.logError("Erro ao converter parametros para número");
		return 0;
	}
}

int MailingServico::getTempoSemFilaDB()
{
	// ler parametros 
	char tempoSemFila[256];
		
	this->getParametro("DEAMMON_COMPROVANTE_TEMPO_SEM_FILA",tempoSemFila);
	sprintf(szAux, "DEAMMON_COMPROVANTE_TEMPO_SEM_FILA[%s]\n", tempoSemFila); m_log.logDebug(szAux);

	if(strlen(tempoSemFila) == 0)
	{
		 m_log.logError("Parametros de base incompletos!\n");
		 exit(-1);
		 return 0;
	}

	try
	{
		this->setTempoSemFila(atoi(tempoSemFila));
		return getTempoSemFila();
	}catch(...)
	{
		m_log.logError("Erro ao converter parametros para número");
		exit(-1);
		return 0;
	}
}

int MailingServico::getTempoDB()
{
	// ler parametros 
	char tempo[256];
		
	this->getParametro("DEAMMON_COMPROVANTE_TEMPO_ENTRE_EXECUCAO",tempo);
	sprintf(szAux, "DEAMMON_COMPROVANTE_TEMPO_ENTRE_EXECUCAO[%s]\n", tempo); m_log.logDebug(szAux);

	if(strlen(tempo) == 0)
	{
		 m_log.logError("Parametros de base incompletos!\n");
		 exit(-1);
		 return 0;
	}

	try
	{
		this->setTempo(atoi(tempo));
		return getTempo();
	}catch(...)
	{
		m_log.logError("Erro ao converter parametros para número");
		exit(-1);
		return 0;
	}
}

int MailingServico::permiteReprocessar(int data,int segundos)
{
	m_log.logInformation("MailingServico::permiteReprocessar");
	struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
		int dataAtual = 0;
		int segundosAtual = 0;
    EXEC SQL END DECLARE SECTION;

	int dataDiferenca = 0;
	int segundosDiferenca = 0;
	int intervalo = this->getTempoReprocessar()*3600; // intervalo em hora passado para segundo

	EXEC SQL WHENEVER SQLERROR GOTO error;
	EXEC SQL WHENEVER NOT FOUND goto error;

	EXEC SQL 
	SELECT TO_NUMBER(TO_CHAR(SYSDATE,'YYYYMMDD')) AS DATA,
		   TO_NUMBER(TO_CHAR(SYSDATE,'HH24')*3600 + TO_CHAR(SYSDATE,'MI')*60 + TO_CHAR(SYSDATE,'SS')) AS SEGUNDOS
	INTO :dataAtual,:segundosAtual
	FROM DUAL;

	sprintf(szAux, "Data atual YYYYMMDD=[%d], Hora atual em segundos=[%d]\n", dataAtual,segundosAtual); m_log.logDebug(szAux);
	sprintf(szAux, "Data registro YYYYMMDD=[%d], Hora do regitro em segundos=[%d]\n", data,segundos); m_log.logDebug(szAux);

	dataDiferenca = dataAtual - data;
	segundosDiferenca = segundosAtual - segundos;

	if(dataDiferenca <= 1 && dataDiferenca >= 0 && segundosDiferenca >= intervalo )
	{	
		m_log.logDebug("Intervalo de tempo OK");
		return 1;
	}

	return 0;
error:
	sprintf(m_erroOracle, "Erro! sqlca.sqlcode = %i\n", sqlca.sqlcode); 
	m_log.logError(m_erroOracle);
	return 0;
}

