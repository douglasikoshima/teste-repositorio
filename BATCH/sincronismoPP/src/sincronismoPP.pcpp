/**
 * Autor: Andrei Kurak 
 * Data de Criação: 18/08/2015
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iostream.h>
#include <ctype.h>
#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <unistd.h>

#include <tuxfw.h>
#include <sys/shm.h>

#include <sincronismoPP.h>
#include <node.h>

#include "../../commons/Propriedade/include/MFile.h"
#include "../../commons/Log/include/Log.h"
#include "../../commons/SplitLine.h"
#include "../../commons/Defines.h"

extern errno;

EXEC SQL INCLUDE SQLCA;

#define MAX_RETRIES     10
#define LOCK            1
#define UNLOCK          0
#define KILL            2
#define SAFE_STRNCPY(dst,src) strncpy(dst,src?src:"",sizeof(dst)-1);dst[sizeof(dst)-1]=0;

#define CONVIND(O,I) \
{\
    if (I == -1) { \
        ##O.arr[0]=0; \
    } else { \
        ##O.arr[##O.len]=0; \
    } \
}

bool semaphoreExists;
int sleep_processar = 0;
int sleep_interno = 0;
int registrosEnviados = 0;
int registrosIntervalo = 0;
char *argvGlobal;
char szAux[4096 + 1];
char szDataHoraGlobal[30 + 1];
char szDataHoraGlobalFormatada[30 + 1];
int iDeclaraCursor=1;
Log oLog;
long iErrorNumber=0;
int shmid;
key_t key;
char *shm=0;
int iQtdEnviosNOK = 0; 
int iQtdEnviosOK = 0;
int objetoAlocado = 0;
int objetoDesalocado = 0;
int debug=0;

char * replacechar(char * a);
void corrige( char * buffer );
void enviarRegistro(Node*cliente, Node*linha);
void desalocandoObjetos(Node*plista);
Node* getLinhaPendente(Node *node, int *itens);
bool getStatusByLinhaTelefonica(char*idCliente, char*idLinhaTelefonica);
bool getStatusByLinha(char*idCliente, char*nrLinha);
void reprocessar(Node *node, int sizeElements);
void log(char*str);

/**
 * Rotina principal responsável por recuperar todos os registros de linha com status pendente de um cliente.
 * O Programa de Pontos deve receber apenas 1 cliente/CPF por vez.
 * Para que não ocorra cadastros simultâneos para o mesmo cliente/CPF
 * Esse batch envia apenas uma linha de um cliente por vez
 * e apenas envia as próximas linhas, se não existir linhas com status pendente de processamento
 * Exemplo:
 * Cliente 1 tem linhas 10, 11 e 12
 * A linha 10 será enviada uma vez, e o batch vai verificar o status da linha
 * 3 vezes apenas. Se o status continuar a ser pendente, as demais linhas não podem ser processadas
 * Esse sincronismo ocorre para não haver registros concorrentes e como não temos o retorno
 * do tuxedo, a única forma de controlar e verificar o status
 */
int main(int argc, char* argv[])
{    	 
	Node *lista = NULL;
	Node *plista = NULL;
    TParamConf tParamConf;    
    char buf[256];

    EXEC SQL BEGIN DECLARE SECTION;        
        int  rows_proc=0;
        short   i_rows_proc = -1;	

        int  rows_cursor=0;
        short   i_rows_cursor = -1;			

        int  sleep_time=0;
        short   i_sleep_time = -1;		
		
        int  sleep_intervalo=0;
        short   i_sleep_intervalo = -1;			

		int executar=0;
		short i_executar = -1;
		
		int gDebug=0;
		short i_gDebug=-1;
		
		VARCHAR I_IDCLIENTE[255+1];
		VARCHAR I_IDLINHATELEFONICA[255+1];
		VARCHAR I_NRTELEFONE[20+1];
		
		short IND_IDCLIENTE = -1;
		short IND_IDLINHATELEFONICA = -1;				
		short IND_NRTELEFONE = -1;	
		
    EXEC SQL END DECLARE SECTION;

    argvGlobal = argv[0];
	
	
    // Acertando o nivel de logs
    oLog.setNivel(2);
    oLog.logDebug(">>>sincronismoPP\n");

    if(ObtemParamConf(&tParamConf)) {
        oLog.logError("Erro obtendo parametros de configuracao\n");
        exit(1);
    }

    //==========================================================================
    // Conecta
    oLog.logDebug("Conectando na BD...");
    /* Conecta no banco de dados */
    if (DBConnect(tParamConf.szUsr, tParamConf.szPws, tParamConf.szInst)) {
        oLog.logError("Erro conectando no banco de dados\n");
        exit(1);
    }
    oLog.logDebug("Conectado na BD com sucesso...\n");

    oLog.logDebug("Inicializando TUXEDO...\n");
    /* Inicializa o TUXEDO */
    if(TUXinit(&tParamConf)) {
        oLog.logError("Erro inicializando TUXEDO\n");
        exit(1);
    }
    oLog.logDebug("Inicializado com sucesso...\n");

    /**
	 * Caso ocorra algum erro encerra batch
	 * Desconecta do banco e encerra conexão tuxedo
	 */
    EXEC SQL WHENEVER SQLERROR GOTO sqlError;
    
    EXEC SQL 
    SELECT dsvalorparametro
      INTO :rows_proc:i_rows_proc
      FROM apoio.parametro
     WHERE cdparametro = 'REGISTROS_PROC_ENVIAPP';	
	 
	 EXEC SQL
    SELECT dsvalorparametro
      INTO :rows_cursor:i_rows_cursor
      FROM apoio.parametro
     WHERE cdparametro = 'REGISTROS_CURSOR_ENVIAPP';		 
	 
    EXEC SQL 
    SELECT dsvalorparametro
      INTO :sleep_time:i_sleep_time
      FROM apoio.parametro
     WHERE cdparametro = 'INTERVALO_SINCRONISMO_PP';	
	 
    EXEC SQL 
    SELECT dsvalorparametro
      INTO :sleep_intervalo:i_sleep_intervalo
      FROM apoio.parametro
     WHERE cdparametro = 'INTERVALO_SINCRONISMO_INTERNO';		 

    EXEC SQL 
    SELECT dsvalorparametro
      INTO :executar:i_executar
      FROM apoio.parametro
     WHERE cdparametro = 'SincVVPP';	
	 
    EXEC SQL 
    SELECT dsvalorparametro
      INTO :gDebug:i_gDebug
      FROM apoio.parametro
     WHERE cdparametro = 'SINCRONISMOPP_DEBUG';		 

	/**
	 * Verifica se o batch pode ser executado
	 * Se o valor do parâmetro SincVVPP for 1, permite executar
	 * se for 0 não permite executar
	 */
	 
	 if (executar == 0) {
		oLog.logDebug("Parâmetro de SincVVPP não configurado para executar...\n");
		oLog.logDebug("desconectar do banco\n");
        DBDisconnect();
        oLog.logDebug("Finalizando conexao TUXEDO...\n");
        tpterm(); 
        exit(0);		
	 }
	 
	 /**
	  * Verifica o valor do parâmetro DSVALORPARAMETRO da tabela APOIO.PARAMETRO
	  * O CDPARAMETRO SINCRONISMOPP_DEBUG  
	  * 1 = habilitar debug 
	  * 0 = desabilitar debug
	  * Parametro verifica se é para gravar log ou não
	  **/
	  
	 if (gDebug == 1) {
		debug = 1;
	 } else {
		oLog.logDebug("Parâmetro de SINCRONISMOPP_DEBUG não configurado para gravar log...\n");		
	 }

	/**
	 * Define a quantidade de segundos para aguardar o próximo envio
	 * dos clientes que possuem mais do que uma linha
	 */
	sleep_processar = sleep_time;
	/**
	 * Define a quantidade de segundos para aguardar o envio de REGISTROS_PROC_ENVIAPP registros
	 */	
	sleep_interno = sleep_intervalo;	
	/**
	 * Define a quantidade de registros a ser enviados com intervalo de n segundos
	 */	
	registrosIntervalo = rows_proc;

	 /**
	  * Só pode trazer clientes com status P = pendente
	  * ordenado pelo cliente. Se alerar essa ordem
	  * precisa mudar a lógica do batch
	  */
    EXEC SQL DECLARE CRTEMPLINHA CURSOR FOR	  
	 SELECT L.IDCLIENTEVV, L.IDLINHATELEFONICA, L.NRTELEFONE
	   FROM VIVOVALORIZA.LINHAVV L
      WHERE UPPER(L.INSINCRONIZA) = 'P'
	    AND ROWNUM <= :rows_cursor
	  ORDER BY L.IDCLIENTEVV;

	sprintf(szAux, "Quantidade de registros a processar [%d] intervalo de processamento[%d] permite executar[%d] registros do cursor[%d] sleep do intervalo[%d]\n", rows_proc, sleep_processar, executar, rows_cursor, sleep_interno); oLog.logDebug(szAux);
				
	oLog.logDebug("INICIA CURSOR CRTEMPLINHA");	
	try {
		Node *anterior = lista;
		EXEC SQL OPEN CRTEMPLINHA;		
		for ( ;; )
		{
			memset(&I_IDCLIENTE, 0, sizeof(I_IDCLIENTE));
			memset(&I_IDLINHATELEFONICA, 0, sizeof(I_IDLINHATELEFONICA));	
			memset(&I_NRTELEFONE, 0, sizeof(I_NRTELEFONE));	
			
			CONVIND(I_IDCLIENTE, IND_IDCLIENTE);
			CONVIND(I_IDLINHATELEFONICA, IND_IDLINHATELEFONICA);			
			CONVIND(I_NRTELEFONE, IND_NRTELEFONE);	
			
			EXEC SQL FETCH CRTEMPLINHA INTO 
			:I_IDCLIENTE:IND_IDCLIENTE,
			:I_IDLINHATELEFONICA:IND_IDLINHATELEFONICA,
			:I_NRTELEFONE:IND_NRTELEFONE;						
			
			if( sqlca.sqlcode == 1403 )
				break;    					
							
			/**
			 * Ao percorrer o cursor, cria a lista com todos os elementos
			 * O cliente é único na lista e todas as linhas são adicionadas
			 * à lista do cliente
			 */
			if (anterior != NULL && !strcmp(anterior->getId(),(char*)I_IDCLIENTE.arr)) {		
				/**
				 * Adiciona uma nova linhatelefonica ou nrtelefone à lista do cliente já criado anteriormente
				 **/			
				Node *linha = NULL;
				if (strlen((char*)I_IDLINHATELEFONICA.arr) == 0) {
					linha = new Node((char*)I_NRTELEFONE.arr,&oLog,&objetoAlocado, &objetoDesalocado, debug);
					linha->setTipo(1);
				} else {
					linha = new Node((char*)I_IDLINHATELEFONICA.arr,&oLog,&objetoAlocado, &objetoDesalocado, debug);
				}
				anterior->addItem(linha);				 				
				sprintf(szAux, "IDLINHATELEFONICA [%s] NRTELEFONE[%s]\n", (char*)I_IDLINHATELEFONICA.arr, (char*)I_NRTELEFONE.arr); log(szAux);
			} else {
				sprintf(szAux, "IDCLIENTE [%s]\n", (char*)I_IDCLIENTE.arr); log(szAux);
				sprintf(szAux, "IDLINHATELEFONICA [%s]\n", (char*)I_IDLINHATELEFONICA.arr); log(szAux);
				/**
				 * Cria um novo cliente na lista
				 **/
				lista = (Node*)new Node((char*)I_IDCLIENTE.arr,&oLog,&objetoAlocado, &objetoDesalocado, debug); 	
				/**
				 * Adiciona uma nova linhatelefonica à lista do cliente
				 * Nova regra adicionada, posterior ao desenvolvimento da demanda
				 * Quando um cliente troca o número, não tem mais a linhabase e portanto
				 * a linha telefonica será nula.
				 * A linha será identificada pelo número do telefone DDD + NRLINHA
				 **/				
				Node *linha = NULL;
				if (strlen((char*)I_IDLINHATELEFONICA.arr) == 0) {
					linha = new Node((char*)I_NRTELEFONE.arr,&oLog,&objetoAlocado, &objetoDesalocado, debug);
					linha->setTipo(1);
				} else {
					linha = new Node((char*)I_IDLINHATELEFONICA.arr,&oLog,&objetoAlocado, &objetoDesalocado, debug);
				}
				lista->addItem(linha);
				/**
				 * Já existe elementos na lista
				 */
				if (anterior != NULL) {				
					lista->setPrev(anterior);
					anterior->setNext(lista);
				} else {
					/**
					 * Primeiro item da lista registra o ponteiro para o primeiro item
					 */
					plista = lista;
				}
				/**
				 * O anterior sempre  armazena o endereço do cliente alocado				 
				 */
				anterior = lista;
			}					
		}// for(;;)
	
	} catch(...) {
		oLog.logDebug("erro ao percorrer cursor");
		/**
		 * Caso ocorra algum erro desaloca todos objetos da memória
		 */
		desalocandoObjetos(plista);
	}
	/**
	 * Rotina principal de envio de registros para o Progama de Pontos
	 *
	 * Primeiro vamos enviar todos os registros independente se o cliente tem muitas linhas ou não.
	 * Segundo vamos enviar os cliente que tem muitas linhas, vamos controlar o processamento
	 * das linhas já enviadas.
	 *
	 * O Fluxo de envio de linhas de um cliente com muitas linhas funciona assim:
	 * Enviamos a linha da lista do cliente e incrementamos a tentativa
	 * A quantidade de tentativa limite é de 3 vezes.
	 * A rotina percorre toda a lista com intervalo de 30 segundos de espera
	 * Somente os clientes que tiverem uma linha com status P = pendente e sem nenhuma tentativa de envio
	 * que poderá ser enviado. Linhas com status S = sincronizado e E = erro, já foram processadas.
	 *
	 * Caso alguma linha esgotou o limite de tentativa de espera de processamento
	 * Temos que desconsiderar esse cliente [processadoc=true] para que o programa
	 * possa ser encerrado.
	 * 
	 * Caso alguma linha seja atualizada para status P = pendente durante o processamento
	 * desse batch, a quantidade de tentativas é mandatório para processar.
	 *
	 */
	try	{
		oLog.logDebug("Inicio do Envio do XML para SINCPP");
		/**
		 * guardamos o ponteiro do primeiro item da lista
		 * para percorer a lista
		 */
		Node*item = plista;
		int sizeElements = 0;		
		while(item != NULL) {
			sprintf(szAux, "ENVIAR INICIAL IDCLIENTE [%s] IDLINHATELEFONICA[%s]\n", item->getId(), item->getFirstElement()->getId()); log(szAux);			
			/**
			 * Rotina envia o registro para SINCVIVONETPP e incrementa a quantidade
			 * de tentativas
			 */
			enviarRegistro(item, item->getFirstElement());			
			/**
			 * Clientes que tem muitas linhas 
			 * Vamos contar quantos clientes tem mais do que uma linha
			 * Essa quantidade é importante para saber até
			 * quando a rotina precisa processar esses clientes
			 */
			if (item->getSize() > 1) {
				sizeElements++; 
			}
			item = item->getNext();
		}		
		/**
		 * Só deve processar se tiver registros
		 */
		 if (plista != NULL) {
			reprocessar(plista, sizeElements);
		 }
		
	} catch(...) {
		oLog.logDebug("Erro no envio do XML na rotina de tentativas de envio\n");
	}
	/**
	 * deve desalocar toda a lista de clientes
	 */
	desalocandoObjetos(plista);

	sprintf(szAux, "Foram executadas (%d) envios com ERRO.\n", iQtdEnviosNOK); oLog.logDebug(szAux);
	sprintf(szAux, "Foram executadas (%d) envios com SUCESSO.\n", iQtdEnviosOK); oLog.logDebug(szAux);
	
	sprintf(szAux, "Foram alocados (%d) objetos.\n", objetoAlocado); oLog.logDebug(szAux);
	sprintf(szAux, "Foram desalocados (%d) objetos.\n", objetoDesalocado); oLog.logDebug(szAux);
	
    //oLog.logDebug("Fechando cursor...");
    EXEC SQL CLOSE CRTEMPLINHA;


    oLog.logDebug("Desconectando da BD...\n");
    DBDisconnect();

    oLog.logDebug("Finalizando conexao TUXEDO...\n");
    tpterm(); 

    oLog.logDebug("Processamento encerrado com sucesso...\n");
    oLog.logDebug("<<<sincronismoPP\n");

    exit(0);


	

    sqlError:
        sprintf(szAux, "Finalizando processo com erro ORACLE (%d)\n", sqlca.sqlcode); oLog.logDebug(szAux);
		oLog.logDebug("Desconectando da BD...\n");
        DBDisconnect();
        oLog.logDebug("Finalizando conexao TUXEDO...\n");
        tpterm(); 
        exit(1);

    /* Tratamento de erro de processamento */
    finalizaProcess:
        oLog.logDebug("Finalizando processo...\n");
        oLog.logDebug("Fechando cursor...\n");
        EXEC SQL CLOSE CRTEMPLINHA;

        oLog.logDebug("Desconectando da BD...\n");
        DBDisconnect();
        oLog.logDebug("Finalizando conexao TUXEDO...\n");
        tpterm(); 

        oLog.logDebug("<<<sincronismoPP\n");
        exit(1);
}

/**		
 * Rotina onde aguarda o processamento das linhas
 * intervalo de espera entre uma execução e outra é de 30 segundos.
 * Será encarrado quando todos os clientes tiverem processados
 * ou quando antingir 3 tentativas de envio. 	
 */
void reprocessar(Node *node, int sizeElements) {
	int processados = 0;
	do {		
		sprintf(szAux, "total de registros processados[%d], quantidade de clientes [%d]\n", processados, sizeElements); oLog.logDebug(szAux);
		/**
		 * Precisamos marcar o primeiro ponteiro da lista
		 * toda vez que executar a rotina 
		 */
		Node *item = node;
		oLog.logDebug("Aguarda 30 segundos para processar o restante\n");
		/**
		 * Vamos aguardar 30 segundos para esperar a linha ser atualizada
		 * na tabela vivovaloriza.linhavv
		 */
		sleep(sleep_processar);	
		oLog.logDebug("Inicio do envio do restante das linhas para cliente que possui mais do que uma linha, enviar uma por vez");
		/**
		 * vamos percorrer a lista de cliente com muitas linhas
		 * Se o cliente ainda não tiver sido processado
		 * vamos procurar a próxima linha disponível para enviar			 
		 */
		while(item != NULL) {
			/**
			 * Se tiver mais linhas para o mesmo cliente
			 * e o cliente ainda não tiver sido processado			 
			 */
			if (item->getSize() > 1 && !item->isProcessado()) {
				/**
				 * Vamos escolher a linha pendente do cliente.
				 * Nessa rotina precisamos da próxima linha
				 * disponível do cliente.
				 */
				Node *linha = getLinhaPendente(item, &processados);
				/**
				 * Só envia a linha se existir alguma disponível
				 * depois vai para a próxima
				 */
				if(linha != NULL) {
					sprintf(szAux, "PROCESSAR IDCLIENTE [%s] IDLINHATELEFONICA[%s]\n", item->getId(), linha->getId()); log(szAux);
					/**
					 * envia a linha para o tuxedo
					 */
					enviarRegistro(item, linha);					
				}
			}	
			item = item->getNext();				
		}
	} while(processados < sizeElements);
}

/**
 *	Desaloca todos os objetos de uma lista
 */
void desalocandoObjetos(Node*plista) {

	/**
	 * Nessa rotina vamos gravar no log todos os registros antes de desalocar
	 */	 
	Node *item = plista;	
	/*
	int alocados = 0;
	while(item != NULL) {
		sprintf(szAux, "alocados[%d] item[%s]\n", alocados++, item->getId()); oLog.logDebug(szAux);		
		Node *itens = item->getFirstElement();
		while(itens != NULL) {	
			sprintf(szAux, "alocados[%d] item[%s]\n", alocados++, itens->getId()); oLog.logDebug(szAux);				
			itens = itens->getNext();			
		}		
		item = item->getNext();			
	}*/
	/**
	 * Nessa rotina vamos desalocar todos os objetos alocados
	 */	
	item = plista;	
	int desalocados = 0;
	while(item != NULL) {
		sprintf(szAux, "desalocados[%d] item[%s]\n", desalocados++, item->getId()); log(szAux);		
		Node *itens = item->getFirstElement();
		while(itens != NULL) {	
			sprintf(szAux, "desalocados[%d] item[%s]\n", desalocados++, itens->getId()); log(szAux);				
			Node *aux = itens;
			itens = itens->getNext();			
			delete aux;
		}		
		Node *aux = item;
		item = item->getNext();			
		delete aux;
	}	
}

/**
 * Recupera as linhas do cliente e verifica o status.
 * Se o status da linha for P = pendente e a quantidade de tentativas
 * de espera for igual a 3, não vai tentar enviar mais linhas desse cliente
 * O cliente será marcado como processado.
 * Se o cliente não for processado em até 3 vezes (cada vez tem intervalo de 30 seg)
 * Signigica que o servidor do PP ou o TUXEDO está fora e nenhum cliente será atualizado
 * com status E = erro ou S = sincronizado
 *
 * Node *node = é o cliente
 * int *itens é o ponteiro para incrementar os clientes já processados
 */
Node* getLinhaPendente(Node *node, int *itens) {   
	log("Recupera a próxima linha do cliente para enviar\n");
	/**
	 * Recupero o ponteiro da lista de linhas desse cliente
	 */
	Node *item = node->getFirstElement();
	/**
	 * vamos percorrer toda lista do cliente
	 * Se tiver alguma linha pendente com tentativa 0
	 * vamos retornar a linha
	 */
	while(item != NULL) {			
		/**
		 * Primeiro recuperamos o status de processamento dessa linha
		 * será enviado o idcliente e a idlinhatelefonica para consulta
		 * node é o cliente, item é a linha
		 */
		bool pendente = false;
		
		if (item->getTipo() == 0) {
			pendente = getStatusByLinhaTelefonica(node->getId(), item->getId());			
		} else {
			pendente = getStatusByLinha(node->getId(), item->getId());			
		}
		/**
		 * Se a linha estiver pendente, não deve enviar nenhuma linha desse cliente
		 */
		if(pendente == true) {
			/**
			 * Se a quantidade de tentativas para essa linha ultrapassar 3, 
			 * não deve tentar processar nenhuma linha do cliente
			 **/
			if (item->getQtTentativas() >= 3) {
				/**
				 * Marca o cliente como processado e incrementa os clientes processados
				 */
				node->setProcessado(true);
				(*itens)++;
				return NULL;
			} else if (item->getQtTentativas() == 0) {	
				/**
				 * Retorna o item somente se ainda não tiver sido enviado			 
				 */
				return item;
			} else {
				/**
				 * incrementa a quantidade de tentativas e retorna NULO			 
				 */
				item->incrementaTentativa();
				return NULL;
			}
		} 
		/**
		 * Se for a última linha da lista do cliente
		 * vamos marcar o cliente como processado
		 * e incrementar a quantidade de clientes processados
		 */
		if (item->getNext() == NULL) {
			node->setProcessado(true);
			(*itens)++;
		}
		item = item->getNext();
	}   	
	return NULL;
}

/**
 * Recupera o status de uma linha de um cliente
 * O Status pode ser P = pendente, S = sincronizado ou E = erro
 * Se o status for P, retorna true
 **/
bool getStatusByLinhaTelefonica(char*idCliente, char*idLinhaTelefonica) {
	sprintf(szAux, "CONSULTANDO STATUS IDCLIENTE [%s] IDLINHATELEFONICA[%s]\n", idCliente, idLinhaTelefonica); log(szAux);
    EXEC SQL BEGIN DECLARE SECTION;
        int status = 0;
        char *cidCliente = idCliente;
		char *cidLinhaTelefonica = idLinhaTelefonica;        
    EXEC SQL END DECLARE SECTION;    
    struct sqlca sqlca;
    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;	
    EXEC SQL 
		SELECT COUNT(1)
		  INTO :status
		  FROM VIVOVALORIZA.LINHAVV
		 WHERE IDLINHATELEFONICA = :cidLinhaTelefonica
		   AND IDCLIENTEVV = :cidCliente
		   AND UPPER(INSINCRONIZA) = 'P';	
	sprintf(szAux, "IDCLIENTE [%s] IDLINHATELEFONICA [%s] STATUS [%d]\n", idCliente, idLinhaTelefonica, status); log(szAux);
	if (status == 1)
		return true;
	else 
		return false;
    erro:
        sprintf(szAux, "Erro ao consultar status de linha sqlca.sqlcode(%d)\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return false;
    naoexiste:
        sprintf(szAux, "Erro ao consultar status IDCLIENTE [%s] IDLINHATELEFONICA [%s]\n", idCliente, idLinhaTelefonica); oLog.logDebug(szAux);
        return false;
}


/**
 * Recupera o status de uma linha de um cliente
 * O Status pode ser P = pendente, S = sincronizado ou E = erro
 * Se o status for P, retorna true
 **/
bool getStatusByLinha(char*idCliente, char*nrLinha) {
	sprintf(szAux, "CONSULTANDO STATUS IDCLIENTE [%s] NRLINHA [%s]\n", idCliente, nrLinha); log(szAux);
    EXEC SQL BEGIN DECLARE SECTION;
        int status = 0;
        char *cidCliente = idCliente;
		char *cnrLinha = nrLinha;        
    EXEC SQL END DECLARE SECTION;    
    struct sqlca sqlca;
    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;	
    EXEC SQL 
		SELECT COUNT(1)
		  INTO :status
		  FROM VIVOVALORIZA.LINHAVV
		 WHERE NRTELEFONE = :cnrLinha
		   AND IDCLIENTEVV = :cidCliente
		   AND UPPER(INSINCRONIZA) = 'P';	
	sprintf(szAux, "IDCLIENTE [%s] NRTELEFONE [%s] STATUS [%d]\n", idCliente, nrLinha, status); log(szAux);
	if (status == 1)
		return true;
	else 
		return false;
    erro:
        sprintf(szAux, "Erro ao consultar status de linha sqlca.sqlcode(%d)\n", sqlca.sqlcode); oLog.logDebug(szAux);
        return false;
    naoexiste:
        sprintf(szAux, "Erro ao consultar status IDCLIENTE [%s] NRTELEFONE [%s]\n", idCliente, nrLinha); oLog.logDebug(szAux);
        return false;
}

/**
 * Rotina envia um registro para o serviço SINCVIVONETPP
 * Essa chamada é asícrona, ou seja, não esperamos pelo resultado.
 * O controle do retorno será feito por esse batch
 */
void enviarRegistro(Node*cliente, Node*linha) {
	char szXml[4000 + 1];
	char szXmlTmp[4000 + 1];
    char szRetMsg[2000 + 1];    
	int iRetSendXML;		
	linha->incrementaTentativa();
	try {	
	oLog.logDebug("enviarRegistro");	
	// formata o XML para envio 
	memset(szXml, 0x00, sizeof(szXml));
	memset(szXmlTmp, 0x00, sizeof(szXmlTmp));
	strcpy(szXml, "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>");
	strcat(szXml, "<msg><msgHdr><user>1</user><service>SINCVIVONETPP</service></msgHdr><msgBody>");		
	sprintf( szXmlTmp,"<IDCLIENTE>%s</IDCLIENTE>", cliente->getId());
	strcat(szXml, szXmlTmp);
	if (linha->getTipo() == 0) {
	sprintf( szXmlTmp,"<IDLINHATELEFONICA>%s</IDLINHATELEFONICA>", linha->getId());
	} else {
		sprintf( szXmlTmp,"<NRLINHA>%s</NRLINHA>", linha->getId());
	}
	strcat(szXml, szXmlTmp);				
	strcat(szXml, "</msgBody></msg>");
	replacechar(szXml);
	
	sprintf(szAux, "szXml[%s]", szXml); oLog.logDebug(szAux);
	memset(szRetMsg, 0x00, sizeof(szRetMsg));
	iRetSendXML = sendXML( szXml,szRetMsg );
	if ( iErrorNumber != 0 )
	{
		sprintf(szAux, "iRetSendXML(%d)iErrorNumber(%d)szRetMsg[%s]\n", iRetSendXML, iErrorNumber, szRetMsg); oLog.logDebug(szAux);
		iQtdEnviosNOK++;
	}
	else
	{
		iQtdEnviosOK++;
	}		
	} catch(...) {
		oLog.logDebug("ocorreu erro ao enviar registro");	
	}	
	/**
	 * Incrementar todo envio de XML 
	 */
	registrosEnviados++;
	/**
	 * Se a quantidade de envio chegar no valor da parametrização	 
	 * vamos fazer um sleep de N segundos
	 */
	if (registrosEnviados == registrosIntervalo) {
		sleep(sleep_interno);
		registrosEnviados = 0;
	}

}



/************************************************************************************************************/
void ObtemParamBase( int *piSleep )
{
    sprintf(szAux, "Antes->*piSleep(%d)\n", *piSleep); oLog.logDebug(szAux);

    *piSleep=ObtemTempoSleep();

    sprintf(szAux, "Depois->*piSleep(%d)\n", *piSleep); oLog.logDebug(szAux);
}



/************************************************************************************************************/
int ObtemParamQtRetriesMax(void)
{
    char *pPointer= ObtemParametro("FILASETCLIENTINFO_QTRETRYMAX");
    if(pPointer == NULL) {
        oLog.logDebug("Parametro de configuracao 'FILASETCLIENTINFO_QTRETRYMAX' nao encontrado\n");
        pPointer = "10"; // qtde máxima de retries
    }

    sprintf(szAux, "Retries Max=%s\n", pPointer);oLog.logDebug(szAux);

    return (atoi(pPointer));
}





/************************************************************************************************************/
int ObtemTempoSleep(void)
{
    char *pPointer = ObtemParametro("ENVIA_CAD_PREPAGO_SLEEP_EOF");
    if(pPointer == NULL) {
        oLog.logDebug("Parametro de configuracao 'ENVIA_CAD_PREPAGO_SLEEP_EOF' nao encontrado\n");

        exit(-1);
    }

    return (atoi(pPointer));
}



/************************************************************************************************************/
char *ObtemDataHora(void)
{
    struct tm *ptTime;
    time_t tTimeNow;
    static char szDataHora[14 + 1];

    time(&tTimeNow);
    ptTime=localtime(&tTimeNow);
    sprintf(szDataHora, "%04d%02d%02d%02d%02d%02d", 
                        ptTime->tm_year + 1900, 
                        ptTime->tm_mon + 1, 
                        ptTime->tm_mday, 
                        ptTime->tm_hour, 
                        ptTime->tm_min, 
                        ptTime->tm_sec );

    return szDataHora;
}



/************************************************************************************************************/
char *ObtemValorTag(char *pXml, char *pTag)
{
    static char szValue[255 + 1];

    szValue[0] = 0;
    if ( pXml )
    {
        if ( *pXml )
        {
            char *p0 = strstr(pXml,pTag) + strlen(pTag) + 1;
            if ( p0 )
            {
                char *p1 = strstr(p0,pTag) - 2;
                if ( p1 )
                {
                    if ( p1 > p0 )
                    {
                        int tam = p1-p0;
                        if (tam > 255) tam = 255;
                        strncpy(szValue,p0,tam);
                        szValue[tam]=0;
                    }
                }
            }
        }
    }

    return szValue;
}



/************************************************************************************************************/
int TUXinit(TParamConf *ptParamConf)
{
    TPINIT *tpInitInfo;
    int i;

    oLog.logInformation(">>>TUXinit\n");

    if((tpInitInfo = (TPINIT *)tpalloc("TPINIT", (char *)NULL, TPINITNEED(strlen(VIVO_GENERIC_PASSWORD) - 1) )) == (TPINIT *)NULL)
    return tperrno;
	
	oLog.logInformation(ptParamConf->szUsrTux);
	oLog.logInformation(ptParamConf->szCltTux);
	oLog.logInformation(ptParamConf->szPwsTux);

    strcpy(tpInitInfo->usrname, ptParamConf->szUsrTux);
    strcpy(tpInitInfo->cltname, ptParamConf->szCltTux);
    strcpy(tpInitInfo->passwd, ptParamConf->szPwsTux);
    strcpy((char *)&tpInitInfo->data, ptParamConf->szPwsTuxGen);

    i = tpinit(tpInitInfo);
    sprintf(szAux, "TPINIT: %i, TPERRNO: %i\n", i, tperrno); oLog.logDebug(szAux);

    oLog.logInformation("<<<TUXinit\n");

//    printf("TUX_USRNAME[%s]\n", TUX_USRNAME);
//    printf("TUX_CLTNAME[%s]\n", TUX_CLTNAME);
//    printf("VIVO_APP_PASSWORD[%s]\n", VIVO_APP_PASSWORD);
//    printf("VIVO_GENERIC_PASSWORD[%s]\n", VIVO_GENERIC_PASSWORD);

    if (i == -1)
        return 1;
    else  
        return 0;
}



/************************************************************************************************************/
int sendXML(char *pXmlSaida, char *pRetMsg) 
{
    char *sendbuf, *rcvbuf;
    long sendlen, rcvlen;

    sendlen = strlen(pXmlSaida);

    // sprintf(szAux, "Tamanho da msg = (%d)\n", sendlen); oLog.logInformation(szAux);

    if((sendbuf = (char *) tpalloc("STRING", NULL, sendlen+1)) == NULL) 
	{
        oLog.logError("Error allocating send buffer\n");
        tpterm();

        return -1;
    }

    if((rcvbuf = (char *) tpalloc("STRING", NULL, sendlen+1)) == NULL) 
	{
        oLog.logError("Error allocating receive buffer\n");
        tpfree(sendbuf);
        tpterm();

        return -1;
    }

    strcpy(sendbuf, pXmlSaida);

    if(tpacall("SINCVIVONETPP", (char *)sendbuf, sendlen, TPNOTRAN|TPNOREPLY ) == -1) 
	{
        sprintf(szAux, "Tperrno = %d\n", tperrno); oLog.logError(szAux);
        sprintf(szAux, "rcvbuf [%s]\n", rcvbuf); oLog.logError(szAux);

        iErrorNumber=tperrno;
        strcpy(pRetMsg, rcvbuf);

        tpfree(sendbuf);
        tpfree(rcvbuf);

        return 1;
    }

    iErrorNumber=0;
    strcpy(pRetMsg, rcvbuf);

    tpfree(sendbuf);
    tpfree(rcvbuf);

    return 0;
}




/************************************************************************************************************/
int ObtemParamConf(TParamConf *ptParamConf)
{
    MFile mfConfig;
    SplitLine NewLinha;
    char szLinha[81];
    char szDivArq[256];
    char szDivPre[21];

    oLog.logDebug("Obtendo parametros de configuracao...\n");

    /* Zera variáveis */
    memset(ptParamConf, 0x00, sizeof(TParamConf));
    memset(szLinha, 0x00, sizeof(szLinha));
    memset(szDivArq, 0x00, sizeof(szDivArq));
    memset(szDivPre, 0x00, sizeof(szDivPre));


    /* Define o arquivo de configuração */
    mfConfig.setPath("sincronismoPP.cfg");

    /* Verificar se conseguiu abrir o arquivo */
    if(!mfConfig.abrir()) {
        oLog.logError("Erro abrindo arquivo de configuração!\n");
        return -1;
    }

    /* Capturando usuario, senha, path e instance de banco do arquivo */
    NewLinha.SetDiv('=');
    while(mfConfig.getLine(szLinha) != 0)
    {
        NewLinha.SetLine(szLinha);
        NewLinha.GetBeforeDiv(szDivPre);
        NewLinha.GetAfterDiv(szDivArq);

        /* Verifica qual parâmetro foi encontrado. */
        if (!strcmp(szDivPre, "pwd_db"))
        {
            strncpy(ptParamConf->szPws, szDivArq, 11);
        }
        else if (!strcmp(szDivPre, "usr_db"))
        {
            strncpy(ptParamConf->szUsr, szDivArq, 11);
        }
        else if (!strcmp(szDivPre, "inst_db"))
        {
            strncpy(ptParamConf->szInst, szDivArq, 20);
        }
        else if (!strcmp(szDivPre, "pwd_tux"))
        {
            strncpy(ptParamConf->szPwsTux, szDivArq, 10);
        }
        else if (!strcmp(szDivPre, "usr_tux"))
        {
            strncpy(ptParamConf->szUsrTux, szDivArq, 10);
        }
        else if (!strcmp(szDivPre, "pwd_tux_gen"))
        {
            strncpy(ptParamConf->szPwsTuxGen, szDivArq, 10);
        }
        else if (strcmp(szDivPre, "clt_tux")==0)
        {
            strncpy(ptParamConf->szCltTux, szDivArq, 10);
        }

        memset(szLinha,  0x00, sizeof(szLinha));
        memset(szDivPre, 0x00, sizeof(szDivPre));
        memset(szDivArq, 0x00, sizeof(szDivArq));
    }

    /* Fechando o arquivo de configuracao aberto */
    mfConfig.fechar();

    //sprintf(szAux, "ptParamConf->szPws[%s]\n", ptParamConf->szPws); oLog.logInformation(szAux);
    sprintf(szAux, "ptParamConf->szUsr[%s]\n", ptParamConf->szUsr); oLog.logInformation(szAux);
    sprintf(szAux, "ptParamConf->szInst[%s]\n", ptParamConf->szInst); oLog.logInformation(szAux);
    //sprintf(szAux, "ptParamConf->szPwsTux[%s]\n", ptParamConf->szPwsTux); oLog.logInformation(szAux);
    sprintf(szAux, "ptParamConf->szUsrTux[%s]\n", ptParamConf->szUsrTux); oLog.logInformation(szAux);
    //sprintf(szAux, "ptParamConf->szPwsTuxGen[%s]\n", ptParamConf->szPwsTuxGen); oLog.logInformation(szAux);
    sprintf(szAux, "ptParamConf->szCltTux[%s]\n", ptParamConf->szCltTux); oLog.logInformation(szAux);

    /* Verifica se todos os dados foram recuperados do arquivo de configuração. */
    if (strlen(ptParamConf->szInst) == 0 ||
        strlen(ptParamConf->szPwsTux) == 0 ||
        strlen(ptParamConf->szUsrTux) == 0 ||
        strlen(ptParamConf->szPwsTuxGen) == 0 ||
        strlen(ptParamConf->szCltTux) == 0 )
    {
        oLog.logError("Dados incompletos!\n");
        return -1;
    }


    oLog.logDebug("Parametros de configuracao obtidos com sucesso...\n");
    return 0;
}



/************************************************************************************************************/
int DBConnect(char *pUsr, char *pPwd, char *pInst)
{
    EXEC SQL BEGIN DECLARE SECTION;
        char connString[256];
    EXEC SQL END DECLARE SECTION;

    oLog.logInformation(">>>DBConnect\n");

    /* String de conexao */
    sprintf(connString, "%s/%s@%s", pUsr, pPwd, pInst);	

    /* Marca ponto de erro */
    EXEC SQL WHENEVER SQLERROR GOTO errConn;

    /* Conecta */
    EXEC SQL CONNECT :connString;

    oLog.logInformation("<<<DBConnect\n");	

    return (sqlca.sqlcode);
    
errConn:
    oLog.logInformation("<<<DBConnect [ERROR]\n");
    return -1;
}




/************************************************************************************************************/
void DBDisconnect(void)
{
    oLog.logInformation(">>>DBDisconnect\n");

    EXEC SQL WHENEVER SQLERROR GOTO Error;
    // EXEC SQL COMMIT WORK RELEASE;

    oLog.logInformation("<<<DBDisconnect\n");
    return;

Error:
    sprintf(szAux, "Erro! sqlca.sqlcode = %i\n", sqlca.sqlcode); oLog.logError(szAux);
    return;
}



/************************************************************************************************************/
char *ObtemParametro(char *pCdParametro)
{
    EXEC SQL BEGIN DECLARE SECTION;
        //VARCHAR oszCdParametro[255];
        char *oszCdParametro = pCdParametro;
        VARCHAR oszDsValorParametro[255+1];
    EXEC SQL END DECLARE SECTION;

    static char szDsValorParametro[255 + 1];
    struct sqlca sqlca;


    EXEC SQL WHENEVER SQLERROR goto erro;
    EXEC SQL WHENEVER NOT FOUND goto naoexiste;

    //STRCPY_TO_ORA(oszCdParametro, pCdParametro);

    EXEC SQL 
        SELECT dsvalorparametro
          INTO :oszDsValorParametro
          FROM apoio.parametro
         WHERE parametro.cdparametro = :oszCdParametro;

    STRCPY_FROM_ORA(szDsValorParametro, oszDsValorParametro);

    return szDsValorParametro;

    erro:
        sprintf(szAux, "Finalizando com erro sqlca.sqlcode(%d)\n", sqlca.sqlcode); oLog.logDebug(szAux);
        exit(-1);

    naoexiste:
        sprintf(szAux, "Chave pesquisada nao encontrada[%s]\n", pCdParametro); oLog.logDebug(szAux);
        return NULL;
}

char * replacechar(char * a)
{
	while(*a!='\0')
	{
		if(*a=='&')
		*a=' ';
		a++;
	}
	
	sprintf(szAux, " replacechar() RETORNO (%s) ....\n",  a); oLog.logDebug(szAux);
	
	return a;
}



void corrige( char * buffer )
{
   int i;
   int j;
   char bf[256];
   memset( bf, 0x0, sizeof(bf) );
   j = 0;

   for ( i=0; i < 256; i++ )
   {
      if ( buffer[i] == '<' || buffer[i] == '>' || buffer[i] == ':' )
         continue;

      bf[j++] = buffer[i];
   }
   strcpy( buffer, bf );

}

/**
 * Gravação de logs, verifica o parãmetro SINCRONISMOPP_DEBUG
 * se for 1, grava logs
 */
void log(char*str) {
	if(debug == 1) {
		oLog.logDebug(str);
	}
}