#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>



#define CONVIND(O,I) \
{\
	if (I == -1) { \
		##O.arr[0]=0; \
	} else { \
		##O.arr[##O.len]=0; \
	} \
}

#define endOraStr(varstr)      varstr.arr[varstr.len]= '\0'
#define oraToStr(bstr,vchar)   if(!bstr) strncpy(bstr,vchar.arr,vchar.len)
#define strToOra(vchar,bstr)   vchar.len = strlen(bstr);strncpy((char *)vchar.arr,bstr,vchar.len);vchar.arr[vchar.len] = 0

#include "../include/cRelatArvore.h"



EXEC SQL BEGIN DECLARE SECTION;
	#include "../include/stRelatArvore.h"
EXEC SQL END DECLARE SECTION;


/*-----------------------------------------------------------------*/
// Prototipos
/*-----------------------------------------------------------------*/
void proc_OrganizaTabela( int ttlPrm, cTrace * log );

void proC_CarregaFiltro( char * sLogin,
                         char * dataSolicitacao,
                         int  * idTipoRelatorio,
                         LIST_PK * pTipoCliente,
                         LIST_PK * pTipoLinha,
                         LIST_PK * pSegmentacao,
                         LIST_PK * pTipoCarteira,
                      	 LIST_PK * pCanal,
                         LIST_PK * pNatureza,
                         LIST_PK * pRegional,
                         LIST_PK * pFechamento,
                         LIST_PK * pGrupoTratamento,
                         LIST_PK * pGrupoAbertura,
                         LIST_PK * pGrupoRetorno,
                         int * inDisponibilidade,
                         st_vlRelatorioArvore * status,
                         cTrace * log );

void proC_Conectar( cTrace * log, char * sConnect, int * flgConectado );

void proC_Desconectar( bool FlagCorretos, 
                       LIST_PK * pContato_OK, 
                       LIST_PK * pContato_NOK,
                       LIST_PK * pTipoCliente,
                       LIST_PK * pTipoLinha,
                       LIST_PK * pSegmentacao,
                       LIST_PK * pTipoCarteira,
                       LIST_PK * pRegional,
                       LIST_PK * pFechamento,
                       LIST_PK * pGrupoTratamento,
                       LIST_PK * pGrupoAbertura,
                       LIST_PK * pGrupoRetorno,
                       int inDisponibilidade,
                       st_vlRelatorioArvore * status,
                       cTrace * log );

int procObtemFolhas_Contato( bool FlagCorretos, 
                             LIST_PK * pContato_OK, 
                             LIST_PK * pContato_NOK,
                             LIST_PK * pTipoCliente,
                             LIST_PK * pTipoLinha,
                             LIST_PK * pSegmentacao,
                             LIST_PK * pTipoCarteira,
                             LIST_PK * pRegional,
                             LIST_PK * pFechamento,
                             LIST_PK * pGrupoTratamento,
                             LIST_PK * pGrupoAbertura,
                             LIST_PK * pGrupoRetorno,
                             int inDisponibilidade,
                             st_vlRelatorioArvore * status,
                             cTrace * log 
                           );


int proCDetalheContato( const unsigned long idContatoPrm, 
                        cRelatorioArvore * pRelatorio,
                        cTrace * log );

int procObtemFolhas_Grupo( bool FlagCorretos, 
                             LIST_PK       * pGrupo_OK, 
                             LIST_PK      * pGrupo_NOK,
                             LIST_PK      * pTipoCliente,
                             LIST_PK        * pTipoLinha,
                             LIST_PK      * pSegmentacao,
                             LIST_PK     * pTipoCarteira,
                             LIST_PK         * pRegional,
                             LIST_PK    * pGrupoAbertura,
                        	 LIST_PK			  * pCanal,
		                     LIST_PK      * pProcedencia,
                             LIST_PK         * pNatureza,
                             int inDisponibilidade,
                             st_vlRelatorioArvore * status,
                             string listaGrupo ,
                             cTrace * log
                           );




int proCDetalheRegistrosGrupo( LIST_PK * pGrupo_OK,
                               LIST_PK * pGrupo_NOK, 
                               int inTipo, 
                               cRelatorioArvore * pRelatorio,
                               cTrace * log );



int procObtemGrupoRelacionadosContatos( unsigned long idContato 
                                        ,string * listaGrupo 
                                        ,LIST_PK  *vecGrupoRelContato
                                        , cTrace * log
                                      );

void  proCNomeContato( const unsigned long idContatoPrm,string  *sNMContato, cTrace * log ) ;

void proCNomeGrupo( string * listaGrupo , LIST_PK  *vecGrupo, cTrace * log );

void proCNomeFase( string * lista , LIST_PK  *vecGrupo , unsigned long idContato, cTrace * log );

void SqlError( sqlca * sqlca, cTrace * log );

//------------------------------------------------------------------------





/*----------------------------------------------------------------------*/
// Funcoes
/*----------------------------------------------------------------------*/
int procObtemFolhas_Contato( bool FlagCorretos, 
                             LIST_PK  * pContato_OK, 
                             LIST_PK  * pContato_NOK,
                             LIST_PK  * pTipoCliente,
                             LIST_PK  * pTipoLinha,
                             LIST_PK  * pSegmentacao,
                             LIST_PK  * pTipoCarteira,
                             LIST_PK  * pRegional,
                             LIST_PK  * pFechamento,
                             LIST_PK  * pGrupoTratamento,
                             LIST_PK  * pGrupoAbertura,
                             LIST_PK  * pGrupoRetorno,
                             int inDisponibilidade,
                             st_vlRelatorioArvore * status,
                             cTrace * log 
                           )
{
   //log->Trace( "> procObtemFolhas_Contato" );
   string consulta;
   int i,j;
   i = j = 0;
   int selecoes = 0;
   bool achouContato = false;
   list<unsigned long>::iterator it;
// char msg[2048];

   struct sqlca sqlca;
   EXEC SQL BEGIN DECLARE SECTION;

      char * query;
      unsigned long idContato = 0;

   EXEC SQL END DECLARE SECTION;

   char buffer[30];

   if ( FlagCorretos == false )
   {
        consulta  = "SELECT IDCONTATO FROM CONTATOADM.CONTATOFOLHA "
                    "WHERE IDCONTATO NOT IN ( ";
   }
   else
       consulta = "";


   consulta += "SELECT "
               "   CONTATOFOLHA.IDCONTATO "
               "FROM "
               "   CONTATOADM.CONTATOFOLHA CONTATOFOLHA "
               "WHERE "
               "   CONTATOFOLHA.IDCONTATO > 0 "
               "AND "
               "   CONTATOFOLHA.IDCONTATO ";

   if ( status->idTipoRelacionamento == 1)
   {
      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += "NOT ";

      pTipoCliente->sort();
      pTipoCliente->unique();
      selecoes = pTipoCliente->size();
      consulta += "IN ( SELECT"
                  "       IDCONTATO "
                  "     FROM "
                  "        CONTATOADM.CONTATOTIPORELACIONAMENTO "
                  "     WHERE IDTIPORELACIONAMENTO ";

      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }

      i=0;
      for ( it = pTipoCliente->begin(); it != pTipoCliente->end(); it++ )
      {
         if ( i > 0 )
            consulta += ",";
         sprintf( buffer,"%lu",*it ); 
         consulta += buffer;
         i++;
      }

//      if ( FlagCorretos == false )
//      {
//          consulta += "))";
//      }
//      else
//      {
          if( selecoes > 1 )
          {
              consulta += " )";
              consulta += " GROUP BY IDCONTATO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
              consulta += ")";
          }
          else
             consulta += ")";
//      }
   }

   if ( status->idTipoLinha == 1)
   {
      if ( i > 0)
      {
         consulta += " AND ";
         consulta += "  CONTATOFOLHA.IDCONTATO ";
      }

      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += "NOT ";

      pTipoLinha->sort();
      pTipoLinha->unique();
      selecoes = pTipoLinha->size();
      consulta += "IN ( SELECT"
                  "       IDCONTATO "
                  "     FROM "
                  "        CONTATOADM.CONTATOTIPOLINHA "
                  "     WHERE IDTIPOLINHA ";
      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }

      i=0;
      for ( it = pTipoLinha->begin(); it != pTipoLinha->end(); it++ )
      {
         if ( i > 0 )
            consulta += ",";
         sprintf( buffer,"%lu", *it );
         consulta += buffer;
         i++;
      }
//      if ( FlagCorretos == false )
//      {
//          if ( selecoes > 1 )
//             consulta += "))";
//          else
//             consulta += ")";
//      }
//      else
//      {
          if( selecoes > 1 )
          {
              consulta += " )"
                          " GROUP BY IDCONTATO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
              consulta += ")";
          }
          else
             consulta += ")";
//      }
   }

   if ( status->idSegmentacao == 1)
   {
      if ( i > 0)
      {
         consulta += " AND ";
         consulta += "  CONTATOFOLHA.IDCONTATO ";
      }

      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += "NOT ";

      pSegmentacao->sort();
      pSegmentacao->unique();
      selecoes = pSegmentacao->size();
      consulta += "IN ( SELECT"
                  "       IDCONTATO "
                  "     FROM "
                  "        CONTATOADM.CONTATOSEGMENTACAO "
                  "     WHERE IDSEGMENTACAO ";
      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }

      i = 0;
      for ( it = pSegmentacao->begin(); it != pSegmentacao->end(); it++ )
      {
         if ( i > 0 )
            consulta += ",";
         sprintf( buffer, "%lu", *it );
         consulta += buffer;
         i++;
      }
//      if ( FlagCorretos == false )
//      {
//          if ( selecoes > 1 )
//             consulta += "))";
//          else
//             consulta += ")";
//      }
//      else
//      {
          if( selecoes > 1 )
          {
              consulta += " )"
                          " GROUP BY IDCONTATO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
              consulta += ")";
          }
          else
             consulta += ")";
//      }
   }


   if ( status->idTipoCarteira == 1)
   {
      if ( i > 0)
      {
         consulta += " AND "
                     "  CONTATOFOLHA.IDCONTATO ";
      }

      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += "NOT ";

      pTipoCarteira->sort();
      pTipoCarteira->unique();
      selecoes = pTipoCarteira->size();
      consulta += "IN ( SELECT"
                  "       IDCONTATO "
                  "     FROM "
                  "        CONTATOADM.CONTATOTIPOCARTEIRA "
                  "     WHERE IDTIPOCARTEIRA ";
      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }

      i = 0;
      for ( it = pTipoCarteira->begin(); it != pTipoCarteira->end(); it++ )
      {
         if ( i > 0 )
            consulta += ",";
         sprintf( buffer, "%lu", *it );
         consulta += buffer;
         i++;
      }
//      if ( FlagCorretos == false )
//      {
//          if ( selecoes > 1 )
//             consulta += "))";
//          else
//             consulta += ")";
//      }
//      else
//      {
          if ( selecoes > 1 )
          {
              consulta += " )"
                          " GROUP BY IDCONTATO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
              consulta += ")";
          }
          else
             consulta += ")";
//      }
   }

   if ( status->idUFOperadora == 1)
   {
      if ( i > 0)
      {
         consulta += " AND ";
         consulta += "  CONTATOFOLHA.IDCONTATO ";
      }

      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += "NOT ";

      pRegional->sort();
      pRegional->unique();
      selecoes = pRegional->size();
      consulta += "IN ( SELECT"
                  "       IDCONTATO "
                  "     FROM "
                  "        CONTATOADM.CONTATOUFOPERADORA "
                  "     WHERE IDUFOPERADORA ";
      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }

      i = 0;
      for ( it = pRegional->begin(); it != pRegional->end(); it++ )
      {
         if ( i > 0 )
            consulta += ",";
         sprintf( buffer,"%lu", *it );
         consulta += buffer;
         i++;
      }
//      if ( FlagCorretos == false )
//      {
//          if ( selecoes > 1 )
//             consulta += "))";
//          else
//             consulta += ")";
//      }
//      else
//      {
          if ( selecoes > 1 )
          {
              consulta += " )";
              consulta += " GROUP BY IDCONTATO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
              consulta += " )";
          }
          else
             consulta += ")";
//      }
   }

   if ( status->idGrupoAbertura == 1)
   {
      if ( i > 0)
      {
         consulta += " AND "
                     "  CONTATOFOLHA.IDCONTATO ";
      }

      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += "NOT ";

      pGrupoAbertura->sort();
      pGrupoAbertura->unique();
      selecoes = pGrupoAbertura->size();
      consulta += "IN ( SELECT"
                  "       IDCONTATO "
                  "     FROM "
                  "        CONTATOADM.CONTATOGRUPO CONTATOGRUPO, "
                  "        CONTATOADM.SEQUENCIA    SEQUENCIA "
                  "     WHERE "
                  "        SEQUENCIA.IDTIPOSEQUENCIA = 1 "
                  "     AND "
                  "        SEQUENCIA.IDCONTATOGRUPO = CONTATOGRUPO.IDCONTATOGRUPO "
                  "     AND "
                  "        CONTATOGRUPO.IDGRUPO ";
      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }

      i = 0;
      for ( it = pGrupoAbertura->begin(); it != pGrupoAbertura->end(); it++ )
      {
         if ( i > 0 )
            consulta += ",";
         sprintf( buffer,"%lu",*it );
         consulta += buffer;
         i++;
      }
//      if ( FlagCorretos == false )
//      {
//          if ( selecoes > 1 )
//             consulta += "))";
//          else
//             consulta += ")";
//      }
//      else
//      {
          if ( selecoes > 1 )
          {
              consulta += " )";
              consulta += " GROUP BY IDCONTATO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
              consulta += " )";
          }
          else
             consulta += ")";
//      }
   }

   if ( status->idGrupoTratamento == 1)
   {
      if ( i > 0)
      {
         consulta += " AND ";
         consulta += "  CONTATOFOLHA.IDCONTATO ";
      }

      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += "NOT ";

      pGrupoTratamento->sort();
      pGrupoTratamento->unique();
      selecoes = pGrupoTratamento->size();
      consulta += "IN ( SELECT"
                  "       IDCONTATO "
                  "     FROM "
                  "        CONTATOADM.CONTATOGRUPO CONTATOGRUPO, "
                  "        CONTATOADM.SEQUENCIA    SEQUENCIA "
                  "     WHERE "
                  "        SEQUENCIA.IDTIPOSEQUENCIA = 2 "
                  "     AND "
                  "        SEQUENCIA.IDCONTATOGRUPO = CONTATOGRUPO.IDCONTATOGRUPO "
                  "     AND "
                  "        CONTATOGRUPO.IDGRUPO ";

      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }

      i=0;
      for ( it = pGrupoTratamento->begin(); it != pGrupoTratamento->end(); it++ )
      {
         if ( i > 0 )
            consulta += ",";
         sprintf( buffer,"%lu",*it );
         consulta += buffer;
         i++;
      }
//      if ( FlagCorretos == false )
//      {
//          if ( selecoes > 1 )
//             consulta += "))";
//          else
//             consulta += ")";
//      }
//      else
//      {
          if ( selecoes > 1 )
          {
              consulta += " )"
                          " GROUP BY IDCONTATO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
              consulta += " )";
          }
          else
             consulta += ")";
//      }
   }

   if ( status->idGrupoRetorno == 1)
   {
      if ( i > 0)
      {
         consulta += " AND ";
         consulta += "  CONTATOFOLHA.IDCONTATO ";
      }

      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += "NOT ";

      pGrupoRetorno->sort();
      pGrupoRetorno->unique();
      selecoes = pGrupoRetorno->size();
      consulta += "IN ( SELECT"
                  "       IDCONTATO "
                  "     FROM "
                  "        CONTATOADM.CONTATOGRUPO CONTATOGRUPO, "
                  "        CONTATOADM.SEQUENCIA    SEQUENCIA "
                  "     WHERE "
                  "        SEQUENCIA.IDTIPOSEQUENCIA = 3 "
                  "     AND "
                  "        SEQUENCIA.IDCONTATOGRUPO = CONTATOGRUPO.IDCONTATOGRUPO "
                  "     AND "
                  "        CONTATOGRUPO.IDGRUPO ";
      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }

      i = 0;
      for ( it = pGrupoRetorno->begin(); it != pGrupoRetorno->end(); it++ )
      {
         if ( i > 0 )
            consulta += ",";
         sprintf( buffer,"%lu",*it );
         consulta += buffer;
         i++;
      }
//      if ( FlagCorretos == false )
//      {
//          if ( selecoes > 1 )
//             consulta += "))";
//          else
//             consulta += ")";
//      }
//      else
//      {
          if ( selecoes > 1 )
          {
              consulta += " )"
                          " GROUP BY IDCONTATO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
              consulta += " )";
          }
          else
             consulta += ")";
//      }
   }

   if ( status->idFaseGrupoFechamento == 1)
   {
      if ( i > 0)
      {
         consulta += " AND ";
         consulta += "  CONTATOFOLHA.IDCONTATO ";
      }

      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += "NOT ";

      pFechamento->sort();
      pFechamento->unique();
      selecoes = pFechamento->size();
      consulta += "IN ( SELECT"
                  "       IDCONTATO "
                  "     FROM "
                  "        CONTATOADM.FASEGRUPOFECHAMENTO "
                  "     WHERE IDTIPOFECHAMENTOCONTATO ";
      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }

      i = 0;
      for ( it = pFechamento->begin(); it != pFechamento->end(); it++ )
      {
         if ( i > 0 )
            consulta += ",";
         sprintf( buffer,"%lu",*it );
         consulta += buffer;
         i++;
      }
//      if ( FlagCorretos == false )
//      {
//          if ( selecoes > 1 )
//             consulta += "))";
//          else
//             consulta += ")";
//      }
//      else
//      {
          if ( selecoes > 1 )
          {
              consulta += " )";
              consulta += " GROUP BY IDCONTATO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
              consulta += " )";
          }
          else
             consulta += ")";
//      }
   }


	//
    // inDisponibilidade é obrigatório
    //
    if ( i > 0)
	{
		 consulta += " AND ";
		 consulta += "  CONTATOFOLHA.IDCONTATO ";
	}

	//  Caso a consulta seja para nao corretos
	//      if ( FlagCorretos == false )
	//         consulta += "NOT ";

	if(inDisponibilidade <= 0)
		inDisponibilidade = 0;
	else
		inDisponibilidade = 1;

	char cinDisponibilidade[20]; memset(cinDisponibilidade, 0, 20);
	sprintf(cinDisponibilidade, "%d", inDisponibilidade);

	consulta += "IN ( SELECT"
			  "       IDCONTATO "
			  "     FROM "
			  "        CONTATOADM.CONTATO "
			  "     WHERE INDISPONIBILIDADE = ";
	consulta += cinDisponibilidade;
	consulta += " ) ";

   /*---------------------------------------------*/
   //  Habilitar somente para testes
   /*---------------------------------------------*/
   //consulta += " AND ROWNUM < 3";

   if ( FlagCorretos == false )
        consulta += " )";


    query = (char *)consulta.c_str();

    log->Trace( "Vai executar busca de contatos..." );
    
    log->Trace( query );

    EXEC SQL PREPARE Consulta FROM :query;
    EXEC SQL DECLARE ObterFolha CURSOR FOR Consulta;
 
    EXEC SQL WHENEVER SQLERROR DO SqlError( &sqlca,log );
    EXEC SQL WHENEVER NOT FOUND DO break;

	// Limpa as listas
    if ( FlagCorretos == false )
       pContato_NOK->clear();
    else
       pContato_OK->clear();

    
	EXEC SQL OPEN ObterFolha;
    for( ;; )
    {
        
        EXEC SQL FETCH ObterFolha INTO :idContato;
    
        if ( idContato > 0 )
        {
            achouContato = true;
            if ( FlagCorretos == false )
               pContato_NOK->push_back( idContato );
            else
               pContato_OK->push_back( idContato );

            idContato = 0;
        }

    }

    EXEC SQL CLOSE ObterFolha;

    if ( FlagCorretos == false )
    {
        pContato_NOK->sort();
        pContato_NOK->unique();
    }
    else
    {
        pContato_OK->sort();
        pContato_OK->unique();
    }
        
    //log->Trace( "< procObtemFolhas_Contato" );
    return 0;

}




int proCDetalheContato( const unsigned long idContatoPrm, 
                        cRelatorioArvore * pRelatorio,
                        cTrace * log )
{
    //log->Trace( "> proCDetalheContato" );
    int j,prim;
    string consulta;
    string LinhaGravar;
    char buffer[512];

    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;

        unsigned long idContato = idContatoPrm;
        unsigned long idNomeContato = 0;
        int disponivel;
        char * query;
        char msg[ 2048 ];

        VARCHAR NomeContato[256];

        VARCHAR nmTipoRelacionamento[256];
        VARCHAR dsTipoLinha[256];
        VARCHAR dsSegmentacao[256];
        VARCHAR dsTipoCarteira[256];
        VARCHAR nmUFOperadora[256];
        VARCHAR nmFechamento[256];
        VARCHAR nmGrupo[256];
        VARCHAR nmTipoRetorno[256];

        short i_NomeContato;

        short i_nmTipoRelacionamento;
        short i_dsTipoLinha;
        short i_dsSegmentacao;
        short i_dsTipoCarteira;
        short i_nmUFOperadora;
        short i_nmFechamento;
        short i_nmGrupo;
        short i_nmTipoRetorno;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO SqlError( &sqlca,log );
    EXEC SQL WHENEVER NOT FOUND CONTINUE;


    EXEC SQL
      SELECT 
         INDISPONIBILIDADE,
         IDNOMECONTATO
      INTO
         :disponivel,
         :idNomeContato 
      FROM 
         CONTATOADM.CONTATO 
      WHERE 
         IDCONTATO = :idContato;

    log->Trace( "Retorno da consulta de CONTATOADM.CONTATO..." );
    sprintf( msg, "Valores: inDisponibilidade [%d], idContato [%d]", disponivel, idContato );
    log->Trace( msg );

    EXEC SQL
      SELECT
         NMCONTATO
      INTO
         :NomeContato:i_NomeContato
      FROM
         CONTATOADM.NOMECONTATO
      WHERE
         IDNOMECONTATO = :idNomeContato;

	CONVIND(NomeContato, i_NomeContato);

    if ( i_NomeContato != -1 )
    {
        LinhaGravar  = "\"";
        sprintf( buffer,"%s",(unsigned char *)NomeContato.arr );
        LinhaGravar += buffer;
        LinhaGravar += " \"";
    }

    EXEC SQL WHENEVER NOT FOUND DO break;
 /* 
      if ( disponivel != 0 )
          LinhaGravar  += ",\"Sim\"";
      else
          LinhaGravar  += ",\"Não\"";
 */

     /*------------------------------------*/
     //  Tipo Relacionamento
     /*------------------------------------*/
     consulta  = "SELECT "
                 "    NMTIPORELACIONAMENTO "
                 "FROM"
                 "    CUSTOMER.TIPORELACIONAMENTO "
                 "WHERE"
                 "    IDTIPORELACIONAMENTO > 0 "
                 "AND "
                 "    IDTIPORELACIONAMENTO "
                 "IN ( "
                 "     SELECT "
                 "        IDTIPORELACIONAMENTO"
                 "     FROM "
                 "        CONTATOADM.CONTATOTIPORELACIONAMENTO"
                 "     WHERE "
                 "        IDCONTATO = ";

    sprintf( buffer,"%lu",idContato );
    consulta += buffer;
    consulta += " )";

    query = (char *)consulta.c_str();

    EXEC SQL PREPARE ConsultaRelacionamento FROM :query;
    EXEC SQL DECLARE BuscaTipoRelacionamento CURSOR FOR ConsultaRelacionamento;
    EXEC SQL WHENEVER NOT FOUND DO break;

    log->Trace( "Vai executar busca de Tipo Relacionamento..." );
    log->Trace( query );

    prim  = 1;
    EXEC SQL OPEN BuscaTipoRelacionamento;
    for ( j=0;;j++ )
    {
        EXEC SQL FETCH BuscaTipoRelacionamento INTO :nmTipoRelacionamento:i_nmTipoRelacionamento;

		CONVIND(nmTipoRelacionamento, i_nmTipoRelacionamento);
        
		if( i_nmTipoRelacionamento >= 0 )
        {
           if ( 1 == prim )
           {                          
           	   LinhaGravar += SEPARADOR;
               LinhaGravar += "\"";
               prim  = 0;
           }
           if ( j != 0 )
              LinhaGravar += SEPARADOR;
           sprintf( buffer,"%s",(unsigned char *)nmTipoRelacionamento.arr );
           LinhaGravar += buffer;
        }
     }
     if ( 0 == prim )
        LinhaGravar += "\"";
     else
        LinhaGravar += SEPARADOR;

     EXEC SQL CLOSE BuscaTipoRelacionamento;


     /*------------------------------------*/
     //  Tipo Linha
     /*------------------------------------*/

        consulta  = "SELECT "
                    "    DSTIPOLINHA "
                    "FROM "
                    "    APOIO.TIPOLINHA "
                    "WHERE"
                    "    IDTIPOLINHA > 0 "
                    "AND "
                    "    IDTIPOLINHA "
                    "IN ( "
                    "     SELECT "
                    "        IDTIPOLINHA "
                    "     FROM "
                    "        CONTATOADM.CONTATOTIPOLINHA "
                    "     WHERE "
                    "        IDCONTATO = ";
        sprintf( buffer,"%lu",idContato );
        consulta += buffer;
        consulta += " )";

        query = (char *)consulta.c_str();

        log->Trace( "Vai executar busca de Tipo Linha..." );
        log->Trace( query );

        EXEC SQL PREPARE Consulta1 FROM :query;
        EXEC SQL DECLARE BuscaTipoLinha CURSOR FOR Consulta1;
        EXEC SQL WHENEVER NOT FOUND DO break;

        prim  = 1;
        EXEC SQL OPEN BuscaTipoLinha;
        for ( j=0;;j++ )
        {
            EXEC SQL FETCH BuscaTipoLinha INTO :dsTipoLinha:i_dsTipoLinha;

			CONVIND(dsTipoLinha, i_dsTipoLinha);

            if( i_dsTipoLinha >= 0 )
            {
               if ( 1 == prim )
               {                   
               	   LinhaGravar += SEPARADOR;
                   LinhaGravar += "\"";
                   prim  = 0;
               }
               if ( j != 0 )
                  LinhaGravar += SEPARADOR;
               sprintf( buffer,"%s",(unsigned char *)dsTipoLinha.arr );
               LinhaGravar += buffer;
            }
        }
        if ( 0 == prim )
           LinhaGravar += "\"";
        else
           LinhaGravar += SEPARADOR;

        EXEC SQL CLOSE BuscaTipoLinha;


     /*------------------------------------*/
     //  Segmentacao
     /*------------------------------------*/
         consulta  = "SELECT "
                     "    DSSEGMENTACAO "
                     "FROM"
                     "    APOIO.SEGMENTACAO "
                     "WHERE"
                     "    IDSEGMENTACAO > 0 "
                     "AND "
                     "    IDSEGMENTACAO "
                     "IN ( "
                     "     SELECT "
                     "        IDSEGMENTACAO "
                     "     FROM "
                     "        CONTATOADM.CONTATOSEGMENTACAO "
                     "     WHERE "
                     "        IDCONTATO = ";

         sprintf( buffer,"%lu",idContato );
         consulta += buffer;
         consulta += " )";

         query = (char *)consulta.c_str();

         log->Trace( "Vai executar busca de Segmentacao..." );
         log->Trace( query );

         EXEC SQL PREPARE Consulta2 FROM :query;
         EXEC SQL DECLARE BuscaSegmentacao CURSOR FOR Consulta2;
         EXEC SQL WHENEVER NOT FOUND DO break;

         prim  = 1;
         EXEC SQL OPEN BuscaSegmentacao;
         for ( j=0;;j++ )
         {
            EXEC SQL FETCH BuscaSegmentacao INTO :dsSegmentacao:i_dsSegmentacao;

			CONVIND(dsSegmentacao, i_dsSegmentacao);

            if( i_dsSegmentacao >= 0 )
            {
               if ( 1 == prim )
               {
                   LinhaGravar += SEPARADOR;
                   LinhaGravar += "\"";
                   prim  = 0;
               }
               if ( j != 0 )
                  LinhaGravar += SEPARADOR;
               sprintf( buffer,"%s",(unsigned char *)dsSegmentacao.arr );
               LinhaGravar += buffer;
            }
         }
         if ( 0 == prim )
            LinhaGravar += "\"";
         else
            LinhaGravar += SEPARADOR;

         EXEC SQL CLOSE BuscaSegmentacao;



     /*------------------------------------*/
     //  Tipo Carteira
     /*------------------------------------*/
         consulta  = "SELECT "
                     "    DSTIPOCARTEIRA "
                     "FROM"
                     "    APOIO.TIPOCARTEIRA "
                     "WHERE"
                     "    IDTIPOCARTEIRA > 0 "
                     "AND "
                     "    IDTIPOCARTEIRA "
                     "IN ( "
                     "     SELECT "
                     "       IDTIPOCARTEIRA "
                     "     FROM "
                     "       CONTATOADM.CONTATOTIPOCARTEIRA "
                     "     WHERE "
                     "       IDCONTATO = ";

         sprintf( buffer,"%lu",idContato );
         consulta += buffer;
         consulta += " )";

         query = (char *)consulta.c_str();

         log->Trace( "Vai executar busca de Tipo Carteira..." );
         log->Trace( query );

         EXEC SQL PREPARE Consulta3 FROM :query;
         EXEC SQL DECLARE BuscaTipoCarteira CURSOR FOR Consulta3;
         EXEC SQL WHENEVER NOT FOUND DO break;

         prim  = 1;
         EXEC SQL OPEN BuscaTipoCarteira;
         for ( j=0;;j++ )
         {
            EXEC SQL FETCH BuscaTipoCarteira INTO :dsTipoCarteira:i_dsTipoCarteira;

			CONVIND(dsTipoCarteira, i_dsTipoCarteira);

            if( i_dsSegmentacao >= 0 )
            {
               if ( 1 == prim )
               {
                   LinhaGravar += SEPARADOR;
                   LinhaGravar += "\"";
                   prim  = 0;
               }
               if ( j != 0 )
                  LinhaGravar += SEPARADOR;
               sprintf( buffer,"%s",(unsigned char *)dsTipoCarteira.arr );
               LinhaGravar += buffer;
            }
         }
         if ( 0 == prim )
            LinhaGravar += "\"";
         else
            LinhaGravar += SEPARADOR;

         EXEC SQL CLOSE BuscaTipoCarteira;


     /*------------------------------------*/
     //  Regionais
     /*------------------------------------*/
         consulta  = " SELECT "
                     "    UF.SGUF "
                     " FROM"
                     "    APOIO.UF UF "
                     " WHERE "
                     "    UF.IDUF > 0 "
                     " AND "
                     "    UF.IDUF "
                     " IN ( "
                     "      SELECT IDUF "
                     "      FROM CUSTOMER.UFOPERADORA "
                     "      WHERE IDUFOPERADORA IN "
                     "      ( SELECT IDUFOPERADORA "
                     "           FROM CONTATOADM.CONTATOUFOPERADORA WHERE IDCONTATO = ";
         sprintf( buffer,"%lu",idContato );
         consulta += buffer;
         consulta += " ))";

         query = (char *)consulta.c_str();

         log->Trace( "Vai executar busca de Regionais..." );
         log->Trace( query );

         EXEC SQL PREPARE ConsultaUFOperadora FROM :query;
         EXEC SQL DECLARE BuscaUFOperadora CURSOR FOR ConsultaUFOperadora;
         EXEC SQL WHENEVER NOT FOUND DO break;

         prim  = 1;
         EXEC SQL OPEN BuscaUFOperadora;
         for ( j=0;;j++ )
         {
            EXEC SQL FETCH BuscaUFOperadora INTO :nmUFOperadora:i_nmUFOperadora;

			CONVIND(nmUFOperadora, i_nmUFOperadora);

            if( i_nmUFOperadora >= 0 )
            {
               if ( 1 == prim )
               {
                   LinhaGravar += SEPARADOR;
                   LinhaGravar += "\"";
                   prim  = 0;
               }
               if ( j != 0 )
                  LinhaGravar += SEPARADOR;
               sprintf( buffer,"%s",(unsigned char *)nmUFOperadora.arr );
               LinhaGravar += buffer;
            }
         }
         if ( 0 == prim )
            LinhaGravar += "\"";
         else
            LinhaGravar += SEPARADOR;

         EXEC SQL CLOSE BuscaUFOperadora;



     /*------------------------------------*/
     //  Tipo Fechamento
     /*------------------------------------*/
         consulta  = "SELECT "
                     "    NMTIPOFECHAMENTOCONTATO "
                     "FROM "
                     "    CONTATOADM.TIPOFECHAMENTOCONTATO "
                     "WHERE "
                     "    IDTIPOFECHAMENTOCONTATO > 0 "
                     "AND "
                     "    IDTIPOFECHAMENTOCONTATO "
                     "IN ( "
                     "     SELECT "
                     "        IDTIPOFECHAMENTOCONTATO "
                     "     FROM "
                     "        CONTATOADM.FASEGRUPOFECHAMENTO "
                     "     WHERE "
                     "        IDCONTATO = ";

         sprintf( buffer,"%lu",idContato );
         consulta += buffer;
         consulta += " )";

         query = (char *)consulta.c_str();
         log->Trace( "Vai executar busca de FaseGrupoFechamento..." );
         log->Trace( query );

         EXEC SQL PREPARE ConsultaFechamento FROM :query;
         EXEC SQL DECLARE BuscaFechamento CURSOR FOR ConsultaFechamento;
         EXEC SQL WHENEVER NOT FOUND DO break;

         prim  = 1;
         EXEC SQL OPEN BuscaFechamento;
         for ( j=0;;j++ )
         {
            EXEC SQL FETCH BuscaFechamento INTO :nmFechamento:i_nmFechamento;

			CONVIND(nmFechamento, i_nmFechamento);

            if( i_nmFechamento >= 0 )
            {
               if ( 1 == prim )
               {
               	   LinhaGravar += SEPARADOR;
                   LinhaGravar += "\"";
                   prim  = 0;
               }
               if ( j != 0 )
                  LinhaGravar += SEPARADOR;
               sprintf( buffer,"%s",(unsigned char *)nmFechamento.arr );
               LinhaGravar += buffer;
            }
         }
         if ( 0 == prim )
            LinhaGravar += "\"";
         else
            LinhaGravar += SEPARADOR;

         EXEC SQL CLOSE BuscaFechamento;


     /*------------------------------------*/
     //  Grupo de Abertura
     /*------------------------------------*/
         consulta  = "SELECT "
                     "    NMGRUPO "
                     "FROM"
                     "    ACESSO.GRUPO "
                     "WHERE"
                     "    IDGRUPO > 0 "
                     "AND "
                     "    DTEXCLUSAO IS NULL "
                     "AND "
                     "    IDGRUPO "
                     "IN ( "
                     "    SELECT "
                     "       CONTATOGRUPO.IDGRUPO"
                     "     FROM"
                     "       CONTATOADM.CONTATOGRUPO CONTATOGRUPO,"
                     "       CONTATOADM.SEQUENCIA    SEQUENCIA"
                     "     WHERE"
                     "       SEQUENCIA.IDTIPOSEQUENCIA = 1"
                     "     AND SEQUENCIA.IDCONTATOGRUPO = CONTATOGRUPO.IDCONTATOGRUPO"
                     "     AND CONTATOGRUPO.IDCONTATO = ";

         sprintf( buffer,"%lu",idContato );
         consulta += buffer;
         consulta += " )";

         query = (char *)consulta.c_str();
         log->Trace( "Vai executar busca de Grupos de Abertura..." );
         log->Trace( query );
         EXEC SQL PREPARE ConsultaGrpAbertura FROM :query;
         EXEC SQL DECLARE BuscaGrpAbertura CURSOR FOR ConsultaGrpAbertura;
         EXEC SQL WHENEVER NOT FOUND DO break;

         prim  = 1;
         EXEC SQL OPEN BuscaGrpAbertura;
         for ( j=0;;j++ )
         {
            EXEC SQL FETCH BuscaGrpAbertura INTO :nmGrupo:i_nmGrupo;

			CONVIND(nmGrupo, i_nmGrupo);

            if( i_nmGrupo >= 0 )
            {
               if ( 1 == prim )
               {
               	   LinhaGravar += SEPARADOR;
                   LinhaGravar += "\"";
                   prim  = 0;
               }
               if ( j != 0 )
                  LinhaGravar += SEPARADOR;
               sprintf( buffer,"%s",(unsigned char *)nmGrupo.arr );
               LinhaGravar += buffer;
            }
         }
         if ( 0 == prim )
            LinhaGravar += "\"";
         else
            LinhaGravar += SEPARADOR;

         EXEC SQL CLOSE BuscaGrpAbertura;


     /*------------------------------------*/
     //  Grupo de Tratamento
     /*------------------------------------*/
         consulta  = "SELECT "
                     "    NMGRUPO "
                     "FROM"
                     "    ACESSO.GRUPO "
                     "WHERE"
                     "    IDGRUPO > 0 "
                     "AND "
                     "    DTEXCLUSAO IS NULL "
                     "AND "
                     "    IDGRUPO "
                     "IN ( "
                     "    SELECT "
                     "       CONTATOGRUPO.IDGRUPO"
                     "     FROM"
                     "       CONTATOADM.CONTATOGRUPO CONTATOGRUPO,"
                     "       CONTATOADM.SEQUENCIA    SEQUENCIA"
                     "     WHERE"
                     "       SEQUENCIA.IDTIPOSEQUENCIA = 2"
                     "     AND SEQUENCIA.IDCONTATOGRUPO = CONTATOGRUPO.IDCONTATOGRUPO"
                     "     AND CONTATOGRUPO.IDCONTATO = ";

         sprintf( buffer,"%lu",idContato );
         consulta += buffer;
         consulta += " )";

         query = (char *)consulta.c_str();
         log->Trace( "Vai executar busca de Grupos de Tratamento..." );
         log->Trace( query );
         
		 EXEC SQL PREPARE ConsultaGrpTratamento FROM :query;
         EXEC SQL DECLARE BuscaGrpTratamento CURSOR FOR ConsultaGrpTratamento;
         EXEC SQL WHENEVER NOT FOUND DO break;

         prim  = 1;
         EXEC SQL OPEN BuscaGrpTratamento;
         for ( j=0;;j++ )
         {
            EXEC SQL FETCH BuscaGrpTratamento INTO :nmGrupo:i_nmGrupo;

			CONVIND(nmGrupo, i_nmGrupo);

            if( i_nmGrupo >= 0 )
            {
               if ( 1 == prim )
               {               
               	   LinhaGravar += SEPARADOR;
                   LinhaGravar += "\"";
                   prim  = 0;
               }
               if ( j != 0 )
                  LinhaGravar += SEPARADOR;
               sprintf( buffer,"%s",(unsigned char *)nmGrupo.arr );
               LinhaGravar += buffer;
            }
         }
         if ( 0 == prim )
            LinhaGravar += "\"";
         else
            LinhaGravar += SEPARADOR;

         EXEC SQL CLOSE BuscaGrpTratamento;


     /*------------------------------------*/
     //  Grupo de Retorno
     /*------------------------------------*/

         consulta  = "SELECT "
                     "    NMGRUPO "
                     "FROM"
                     "    ACESSO.GRUPO "
                     "WHERE"
                     "    IDGRUPO > 0 "
                     "AND "
                     "    DTEXCLUSAO IS NULL "
                     "AND "
                     "    IDGRUPO "
                     "IN ( "
                     "     SELECT "
                     "       CONTATOGRUPO.IDGRUPO"
                     "     FROM"
                     "       CONTATOADM.CONTATOGRUPO CONTATOGRUPO,"
                     "       CONTATOADM.SEQUENCIA    SEQUENCIA"
                     "     WHERE"
                     "       SEQUENCIA.IDTIPOSEQUENCIA = 3"
                     "     AND SEQUENCIA.IDCONTATOGRUPO = CONTATOGRUPO.IDCONTATOGRUPO"
                     "     AND CONTATOGRUPO.IDCONTATO = ";
         
		 sprintf( buffer,"%lu",idContato );
         consulta += buffer;
         consulta += " ) ";

         query = (char *)consulta.c_str();

         log->Trace( "Vai executar busca de Grupos de Retorno..." );
         log->Trace( query );

         EXEC SQL PREPARE ConsultaGrpRetorno FROM :query;
         EXEC SQL DECLARE BuscaGrpRetorno CURSOR FOR ConsultaGrpRetorno;
         EXEC SQL WHENEVER NOT FOUND DO break;

         prim  = 1;
         EXEC SQL OPEN BuscaGrpRetorno;
         for ( j=0;;j++ )
         {
            EXEC SQL FETCH BuscaGrpRetorno INTO :nmGrupo:i_nmGrupo;

			CONVIND(nmGrupo, i_nmGrupo);

            if( i_nmGrupo >= 0 )
            {
               if ( 1 == prim )
               {                   
               	   LinhaGravar += SEPARADOR;
                   LinhaGravar += "\"";
                   prim  = 0;
               }
               if ( j != 0 )
                  LinhaGravar += SEPARADOR;
               sprintf( buffer,"%s",(unsigned char *)nmGrupo.arr );
               LinhaGravar += buffer;
            }
         }
         if ( 0 == prim )
            LinhaGravar += "\"";
         else
            LinhaGravar += SEPARADOR;

         EXEC SQL CLOSE BuscaGrpRetorno;



     /*------------------------------------*/
     //  Tipo de Retorno
     /*------------------------------------*/


		EXEC SQL DECLARE ConsultaTipoRet CURSOR FOR 
			SELECT
			   TIPORETORNOCONTATO.NMTIPORETORNOCONTATO
			FROM
			   CONTATOADM.TIPORETORNOCONTATO TIPORETORNOCONTATO,
			   CONTATOADM.CONTATOTIPORETORNO CONTATORETORNO
			WHERE
			   CONTATORETORNO.IDTIPORETORNOCONTATO = TIPORETORNOCONTATO.IDTIPORETORNOCONTATO      
			AND
			   CONTATORETORNO.IDCONTATO = :idContato;

		EXEC SQL OPEN ConsultaTipoRet;
        EXEC SQL WHENEVER NOT FOUND DO break;

        prim  = 1;
		for ( j=0;;j++ )
		{
			EXEC SQL FETCH ConsultaTipoRet INTO :nmTipoRetorno:i_nmTipoRetorno;

			CONVIND(nmTipoRetorno, i_nmTipoRetorno);

			if( i_nmTipoRetorno >= 0 )
			{
			   if ( 1 == prim )
			   {                   
				   LinhaGravar += SEPARADOR;
				   LinhaGravar += "\"";
				   prim  = 0;
			   }
			   if ( j != 0 )
				  LinhaGravar += SEPARADOR;
			   sprintf( buffer,"%s",(unsigned char *)nmTipoRetorno.arr );
			   LinhaGravar += buffer;
			}
		}
		if ( 0 == prim )
			LinhaGravar += "\"";
		else
			LinhaGravar += SEPARADOR;

		EXEC SQL CLOSE ConsultaTipoRet;



      LinhaGravar += "\n";

      /*
       * -----> Grava Linha Detalhe
       */
      pRelatorio->WriteArquivoSaida( LinhaGravar.c_str() );

    //log->Trace( "< proCDetalheContato" );
    return 0;

}




// ------------------------------------------------------------------------------
// Conecta ao Banco
// ------------------------------------------------------------------------------
void proC_Conectar( cTrace * log, char * sConnect, int * flgConectado )
{   
   //log->Trace("> Conectar()");
   if ( *flgConectado == 0 )
   {
      struct sqlca sqlca;

      EXEC SQL BEGIN DECLARE SECTION;
         char *pszConnStr;
      EXEC SQL END DECLARE SECTION;

      pszConnStr = sConnect;
      EXEC SQL WHENEVER SQLERROR DO SqlError( &sqlca,log );
      EXEC SQL CONNECT :pszConnStr;

      *flgConectado = 1;


      //log->Trace("Conectou!");
   }
   //log->Trace("< Conectar()");
}




/*********/
/* grupo */
/*********/    
int procObtemFolhas_Grupo( bool FlagCorretos, 
                            LIST_PK * pGrupo_OK, 
                            LIST_PK * pGrupo_NOK,
                            LIST_PK * pTipoCliente,
                            LIST_PK * pTipoLinha,
                            LIST_PK * pSegmentacao,
                            LIST_PK * pTipoCarteira,
                            LIST_PK * pRegional,
                            LIST_PK * pGrupoAbertura,
                            LIST_PK * pCanal,
                            LIST_PK * pProcedencia,
                            LIST_PK * pNatureza,
                            int inDisponibilidade,
                            st_vlRelatorioArvore * status,
                            string listaGrupo,
                            cTrace * log 
                         )
{
    //log->Trace("> procObtemFolhas_Grupo()");
    string consulta;
    int selecoes;
    int i,j;
    i = j = 0;
    list<unsigned long>::iterator it;

    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;

      char * query;
      unsigned long idGrupo = 0;

    EXEC SQL END DECLARE SECTION;

    char buffer[512];

	if ( FlagCorretos == false )
	{
		consulta  = "SELECT GRUPO.IDGRUPO FROM ACESSO.GRUPO GRUPO "
					"WHERE GRUPO.IDGRUPO NOT IN ( ";
	}
	else
	   consulta = "";

    
	consulta  += "SELECT "
                 "   GRUPO.IDGRUPO "
                 "FROM "
                 "   ACESSO.GRUPO GRUPO "
                 "WHERE "
                 "   GRUPO.IDGRUPO > 0 "
                 "AND "
                 "   GRUPO.DTEXCLUSAO IS NULL "
                 "AND "
                 "   GRUPO.IDGRUPO ";
    
   /*------------------------------------*/
   // Tipo de Cliente 
   /*------------------------------------*/

   if ( status->idTipoRelacionamento == 1)
   {
      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += " NOT ";

      pTipoCliente->sort();
      pTipoCliente->unique();
      selecoes = pTipoCliente->size();
      consulta += " IN ( SELECT"
                  "       IDGRUPO "
                  "     FROM "
                  "        CONTATOADM.TIPORELACIONAMENTOGRUPO "
                  "     WHERE "
                  "        IDTIPORELACIONAMENTO ";

      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }

      j=0;  
      for ( it = pTipoCliente->begin(); it != pTipoCliente->end(); it++ )
      {
         if ( j > 0 )
            consulta += ",";

         sprintf( buffer, "%lu", *it );
         consulta += buffer;
         j++;
      }
      if( selecoes > 1 )
         consulta += " ) ";

//      if ( FlagCorretos == true )
//      {
          if( selecoes > 1 )
          {
              consulta += " GROUP BY IDGRUPO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
          }
//      }
      consulta += " ) ";

   }

   /*------------------------------------*/
   // Tipo de Linha
   /*------------------------------------*/

   if ( status->idTipoLinha == 1)
   {
      if ( j > 0)
      {
         consulta += " AND "
                     "  GRUPO.IDGRUPO ";
      }

      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += " NOT ";

      pTipoLinha->sort();
      pTipoLinha->unique();
      selecoes = pTipoLinha->size();
      consulta += " IN ( SELECT"
                  "       IDGRUPO "
                  "     FROM "
                  "        CONTATOADM.TIPOLINHAGRUPO "
                  "     WHERE "
                  "        IDTIPOLINHA ";

      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }

      j=0;
      for ( it = pTipoLinha->begin(); it != pTipoLinha->end(); it++ )
      {
         if ( j > 0 )
            consulta += ",";
         sprintf( buffer, "%lu", *it );
         consulta += buffer;
         j++;
      }
   
      if( selecoes > 1 )
         consulta += " ) ";
   
//      if ( FlagCorretos == true )
//      {
          if( selecoes > 1 )
          {
              consulta += " GROUP BY IDGRUPO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
          }
//      }
      consulta += ")";

   }
   
   /*------------------------------------*/
   // Segmento 
   /*------------------------------------*/

   if ( status->idSegmentacao == 1)
   {
      if ( j > 0)
      {
         consulta += " AND "
                     "  GRUPO.IDGRUPO ";
      }

      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += " NOT ";

      pSegmentacao->sort();
      pSegmentacao->unique();
      selecoes = pSegmentacao->size() ;
      consulta += " IN ( SELECT"
                  "       IDGRUPO "
                  "     FROM "
                  "        CONTATOADM.SEGMENTACAOGRUPO "
                  "     WHERE "
                  "        IDSEGMENTACAO ";

      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }

      j=0;
      for ( it = pSegmentacao->begin(); it != pSegmentacao->end(); it++ )
      {
         if ( j > 0 )
            consulta += ",";
         sprintf( buffer, "%lu", *it );
         consulta += buffer;
         j++;
      }
      
      if( selecoes > 1 )
         consulta += " ) ";
      
//      if ( FlagCorretos == true )
//      {
          if( selecoes > 1 )
          {
              consulta += " GROUP BY IDGRUPO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
          }
//      }
      consulta += " ) ";
   }

   /*------------------------------------*/
   // Carteira
   /*------------------------------------*/

   if ( status->idTipoCarteira == 1)
   {
      if ( j > 0)
      {
         consulta += " AND "
                     "  GRUPO.IDGRUPO ";
      }

      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += " NOT ";

      pTipoCarteira->sort();
      pTipoCarteira->unique();
      selecoes = pTipoCarteira->size() ;
      consulta += " IN ( SELECT"
                  "       IDGRUPO "
                  "     FROM "
                  "        CONTATOADM.TIPOCARTEIRAGRUPO "
                  "     WHERE "
                  "        IDTIPOCARTEIRA ";
      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }

      j=0;
      for ( it = pTipoCarteira->begin(); it != pTipoCarteira->end(); it++ )
      {
         if ( j > 0 )
            consulta += ",";
         sprintf( buffer, "%lu", *it );
         consulta += buffer;
         j++;
      }
      if( selecoes > 1 )
         consulta += " )";

//      if ( FlagCorretos == true )
//      {
          if( selecoes > 1 )
          {
              consulta += " GROUP BY IDGRUPO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
          }
//      }
      consulta += " ) ";
   }

   /*------------------------------------*/
   // Regional
   /*------------------------------------*/

   if ( status->idUFOperadora == 1)
   {
      if ( j > 0)
      {
         consulta += " AND ";
         consulta += "  GRUPO.IDGRUPO ";
      }

      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += " NOT ";

      pRegional->sort();
      pRegional->unique();
      selecoes = pRegional->size() ;
      consulta +=  " IN ( SELECT"
                   "       IDGRUPO "
                   "     FROM "
                   "        CONTATOADM.UFOPERADORAGRUPO "
                   "     WHERE "
                   "        IDUFOPERADORA ";
      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }
                   
      j=0;
      for ( it = pRegional->begin(); it != pRegional->end(); it++ )
      {
         if ( j > 0 )
            consulta += ",";
         sprintf( buffer, "%lu", *it );
         consulta += buffer;
         j++;
      }
      if ( selecoes > 1 )
         consulta += " )";

//      if ( FlagCorretos == true )
//      {
          if ( selecoes > 1 )
          {
              consulta += " GROUP BY IDGRUPO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
          }
//      }
      consulta += " ) ";
   }

   /*------------------------------------*/
   // Grupo de Abertura 
   /*------------------------------------*/

   if ( status->idGrupoAbertura == 1)
   {
      if ( j > 0)
      {
         consulta += " AND ";
         consulta += "  GRUPO.IDGRUPO ";
      }

      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += " NOT ";

      consulta +=   " IN ( SELECT"
                    "       IDGRUPO "
                    "     FROM "
                    "        CONTATOADM.GRUPOABERTURAGRUPO "
                    "     WHERE "
                    "        IDGRUPOPAI ";

      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }

      pGrupoAbertura->sort();
      pGrupoAbertura->unique();
      selecoes = pGrupoAbertura->size();

      j=0;
      for ( it = pGrupoAbertura->begin(); it != pGrupoAbertura->end(); it++ )
      {
         if ( j > 0 )
            consulta += ",";
         sprintf( buffer, "%lu", *it );
         consulta += buffer;
         j++;
      }
      if ( selecoes > 1 )
            consulta += " )";

//      if ( FlagCorretos == true )
//      {
          if ( selecoes > 1 )
          {
              consulta += " GROUP BY IDGRUPO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
          }
//      }
      consulta += ")";
   }

   /*------------------------------------*/
   // Canal
   /*------------------------------------*/

   if ( status->idCanal == 1)
   {
      if ( j > 0)
      {
         consulta += " AND ";
         consulta += "  GRUPO.IDGRUPO ";
      }

      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += " NOT ";

      pCanal->sort();
      pCanal->unique();
      selecoes = pCanal->size() ;
      consulta += " IN ( SELECT"
                  "       IDGRUPO "
                  "     FROM "
                  "        CONTATOADM.CANALGRUPO "
                  "     WHERE "
                  "        IDCANAL ";
      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }

      j=0;
      for ( it = pCanal->begin(); it != pCanal->end(); it++ )
      {
         if ( j > 0 )
            consulta += ",";
         sprintf( buffer, "%lu", *it );
         consulta += buffer;
         j++;
      }
      if ( selecoes > 1 )
         consulta += " ) ";

//      if ( FlagCorretos == true )
//      {
          if ( selecoes > 1 )
          {
              consulta += " GROUP BY IDGRUPO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
          }
//      }
      consulta += " ) ";
   }
   /*------------------------------------*/
   // Procedencia
   /*------------------------------------*/

   if ( status->idProcedencia == 1)
   {
      if ( j > 0)
      {
         consulta += " AND ";
         consulta += "  GRUPO.IDGRUPO ";
      }

      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += " NOT ";

      pProcedencia->sort();
      pProcedencia->unique();
      selecoes = pProcedencia->size() ;
      consulta += " IN ( SELECT"
                  "       IDGRUPO "
                  "     FROM "
                  "        CONTATOADM.PROCEDENCIAGRUPO "
                  "     WHERE "
                  "        IDPROCEDENCIA ";
      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }

      j=0;
      for ( it = pProcedencia->begin(); it != pProcedencia->end(); it++ )
      {
         if ( j > 0 )
            consulta += ",";
         sprintf( buffer, "%lu", *it );
         consulta += buffer;
         j++;
      }
      if ( selecoes > 1 )
         consulta += " ) ";

//      if ( FlagCorretos == true )
//      {
          if ( selecoes > 1 )
          {
              consulta += " GROUP BY IDGRUPO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
          }
//      }
      consulta += " ) ";
   }
   
   /*------------------------------------*/
   // Natureza
   /*------------------------------------*/

   if ( status->idNatureza == 1)
   {
      if ( j > 0)
      {
         consulta += " AND ";
         consulta += "  GRUPO.IDGRUPO ";
      }

      //  Caso a consulta seja para nao corretos
//      if ( FlagCorretos == false )
//         consulta += " NOT ";

      pNatureza->sort();
      pNatureza->unique();
      selecoes = pNatureza->size() ;
      consulta += " IN ( SELECT"
                  "       IDGRUPO "
                  "     FROM "
                  "        CONTATOADM.TIPOPESSOAGRUPO "
                  "     WHERE "
                  "        IDTIPOPESSOA ";
      if( selecoes > 1 )
      {
          consulta += "IN ( ";
      }
      else
      {
          consulta += "= ";
      }

      j=0;
      for ( it = pNatureza->begin(); it != pNatureza->end(); it++ )
      {
         if ( j > 0 )
            consulta += ",";
         sprintf( buffer, "%lu", *it );
         consulta += buffer;
         j++;
      }
      if ( selecoes > 1 )
         consulta += " )";

//      if ( FlagCorretos == true )
//      {
          if ( selecoes > 1 )
          {
              consulta += " GROUP BY IDGRUPO HAVING COUNT(1) = ";
              sprintf( buffer, "%d", selecoes );
              consulta += buffer;
          }
//      }
      consulta += " ) ";
   }

/*    consulta += " AND ROWNUM<6   "; */

   /*----------0-----------------------------*/
   // lista de gupos relacionados aos contatos
   /*----------------------------------------*/

   if ( listaGrupo.size() > 0 )
   {
         consulta += " AND   GRUPO.IDGRUPO  IN (";
         consulta += listaGrupo ;
         consulta += "  )";
   }

//    consulta += " AND ROWNUM<10   "; 

    if ( FlagCorretos == false )
	    consulta += " ) ";

    query = (char *)consulta.c_str();

    log->Trace( "Vai executar busca de Grupos..." );
	log->Trace(query);

    EXEC SQL PREPARE Consulta FROM :query;
    EXEC SQL DECLARE ObterGrupo CURSOR FOR Consulta;
 
    EXEC SQL WHENEVER SQLERROR DO SqlError( &sqlca,log );
    EXEC SQL WHENEVER NOT FOUND DO break;

	// Limpa as listas
    if ( FlagCorretos == false )
       pGrupo_NOK->clear();
    else
       pGrupo_OK->clear();


    EXEC SQL OPEN ObterGrupo;
    for( ;; )
    {
        
        EXEC SQL FETCH ObterGrupo INTO 
            :idGrupo;
    
        if ( idGrupo > 0 )
        {
            if ( FlagCorretos == false )
               pGrupo_NOK->push_back( idGrupo );
            else
               pGrupo_OK->push_back( idGrupo );

            idGrupo = 0;
        }

    }

    EXEC SQL CLOSE ObterGrupo;

    if ( FlagCorretos == false )
    {
        pGrupo_NOK->sort();
        pGrupo_NOK->unique();
    }
    else
    {
        pGrupo_OK->sort();
        pGrupo_OK->unique();
    }

    //log->Trace("< procObtemFolhas_Grupo()");

    return 0;
}





int proCDetalheRegistrosGrupo( LIST_PK * pGrupo, 
                               cRelatorioArvore * pRelatorio,
                               cTrace * log )
{
    //log->Trace("> proCDetalheRegistrosGrupo()");

    string consulta;
    string LinhaGravar;
    string LinhaTemp;
    char buffer[512];
    bool l_virg=false ;
    int ii=0 ;
    list<unsigned long>::iterator it;


	struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;

      unsigned long idGrupo = 0;
      char * query;

      VARCHAR NomeGrupo[256];

      VARCHAR nmTipoRelacionamento[256];
      VARCHAR dsTipoLinha[256];
      VARCHAR dsSegmentacao[256];
      VARCHAR dsTipoCarteira[256];
      VARCHAR nmUFOperadora[256];
      VARCHAR nmGrupo[256];
      VARCHAR dsCanal[256];
      VARCHAR dsProcedencia[256];
      VARCHAR dsNatureza[256];

      short i_NomeGrupo;

      short i_nmTipoRelacionamento;
      short i_dsTipoLinha;
      short i_dsSegmentacao;
      short i_dsTipoCarteira;
      short i_nmUFOperadora;
      short i_nmGrupo;
      short i_dsCanal;
      short i_dsProcedencia;
      short i_dsNatureza;

   EXEC SQL END DECLARE SECTION;

   EXEC SQL WHENEVER SQLERROR DO SqlError( &sqlca,log );
   EXEC SQL WHENEVER NOT FOUND CONTINUE;
 
/*
   if(inTipo == OK )
      tamanho = pGrupo_OK->size() ;
   else 
      tamanho = pGrupo_NOK->size() ;
*/

   for ( it = pGrupo->begin(); it != pGrupo->end() ; it++ )
   {

      idGrupo = *it;

      EXEC SQL
      SELECT
         NMGRUPO
      INTO
         :NomeGrupo:i_NomeGrupo
      FROM
          ACESSO.GRUPO
      WHERE
         GRUPO.IDGRUPO  = :idGrupo ;


      if ( i_NomeGrupo != -1 )
      {
         NomeGrupo.arr[ NomeGrupo.len ] = 0x0;
         sprintf( buffer,"%s",(unsigned char *)NomeGrupo.arr );
         LinhaGravar = buffer;
      }

      EXEC SQL WHENEVER NOT FOUND DO break;

      /*------------------------------------*/
      // Tipo de Cliente   
      /*------------------------------------*/
      {

         LinhaGravar += SEPARADOR;

         consulta = " SELECT "
                    "    NMTIPORELACIONAMENTO "
                    " FROM "
                    "    CUSTOMER.TIPORELACIONAMENTO "
                    " WHERE "
                    "    IDTIPORELACIONAMENTO > 0 "
                    " AND "
                    "    IDTIPORELACIONAMENTO IN ( SELECT IDTIPORELACIONAMENTO FROM CONTATOADM.TIPORELACIONAMENTOGRUPO WHERE IDGRUPO = ";

         sprintf( buffer,"%lu",idGrupo );
         consulta += buffer;
         consulta += ")";

         query = (char *)consulta.c_str();

         log->Trace( "Vai executar busca de Tipo Relacionamento..." );
         log->Trace( query );

         EXEC SQL PREPARE ConsultaRelacionamentoGrupo FROM :query;
         EXEC SQL DECLARE BuscaTipoRelacionamentoGrupo CURSOR FOR ConsultaRelacionamentoGrupo;
         EXEC SQL WHENEVER NOT FOUND DO break;

         EXEC SQL OPEN BuscaTipoRelacionamentoGrupo;

         l_virg=false ;
         ii=0 ;
         for (;; )
         {
            EXEC SQL FETCH BuscaTipoRelacionamentoGrupo INTO :nmTipoRelacionamento:i_nmTipoRelacionamento;

            if ( l_virg== true )
            {
                 LinhaTemp += SEPARADOR;
                 l_virg=false ;
            }

            if( i_nmTipoRelacionamento != -1 )
            {
               nmTipoRelacionamento.arr[ nmTipoRelacionamento.len ] = 0x0;
               sprintf( buffer,"%s",(unsigned char *)nmTipoRelacionamento.arr );
               LinhaTemp += buffer;
               l_virg= true ;
               ii++;
            }
         }

         EXEC SQL CLOSE BuscaTipoRelacionamentoGrupo;

         if ( ii > 0)
             LinhaGravar += "\""+LinhaTemp+"\"";
         else
             LinhaGravar += LinhaTemp;
         LinhaTemp ="";

      }

      /*------------------------------------*/
      // Tipo de Linha
      /*------------------------------------*/
      {

         LinhaGravar += SEPARADOR;

         consulta  =" SELECT "
                    "    DSTIPOLINHA "
                    " FROM "
                    "    APOIO.TIPOLINHA "
                    " WHERE "
                    "    IDTIPOLINHA > 0 "
                    " AND "
                    "    IDTIPOLINHA IN ( SELECT IDTIPOLINHA FROM CONTATOADM.TIPOLINHAGRUPO WHERE IDGRUPO = ";
         sprintf( buffer,"%lu",idGrupo );
         consulta += buffer;
         consulta += " ) ";

         query = (char *)consulta.c_str();
         log->Trace( "Vai executar busca de Tipo Linha..." );
         log->Trace( query );

         EXEC SQL PREPARE Consulta1Grupo FROM :query;
         EXEC SQL DECLARE BuscaTipoLinhaGrupo CURSOR FOR Consulta1Grupo;
         EXEC SQL WHENEVER NOT FOUND DO break;


         EXEC SQL OPEN BuscaTipoLinhaGrupo;

         l_virg=false ;
         ii=0 ;
         for ( ;; )
         {
            EXEC SQL FETCH BuscaTipoLinhaGrupo INTO :dsTipoLinha:i_dsTipoLinha;

            if ( l_virg== true )
            {
                 LinhaTemp += SEPARADOR;
                 l_virg=false ;
            }

            if( i_dsTipoLinha != -1 )
            {
               dsTipoLinha.arr[ dsTipoLinha.len ] = 0x0;
               sprintf( buffer,"%s",(unsigned char *)dsTipoLinha.arr );
               LinhaTemp += buffer;
               l_virg= true ;
               ii++;

            }
         }
         EXEC SQL CLOSE BuscaTipoLinhaGrupo;

         if ( ii > 0)
             LinhaGravar += "\""+LinhaTemp+"\"";
         else
             LinhaGravar += LinhaTemp;

         LinhaTemp ="";

      }
      /*------------------------------------*/
      // Segmento 
      /*------------------------------------*/
      {

         LinhaGravar += SEPARADOR;

         consulta = "SELECT "
                    "    DSSEGMENTACAO "
                    "FROM"
                    "    APOIO.SEGMENTACAO "
                    " WHERE "
                    "    IDSEGMENTACAO > 0 "
                    " AND "
                    "    IDSEGMENTACAO IN ( SELECT IDSEGMENTACAO FROM CONTATOADM.SEGMENTACAOGRUPO WHERE IDGRUPO = ";
         sprintf( buffer,"%lu",idGrupo );
         consulta += buffer;
         consulta += " ) ";

         query = (char *)consulta.c_str();

         log->Trace( "Vai executar busca de Segmentacao..." );
         log->Trace( query );

         EXEC SQL PREPARE Consulta2Grupo FROM :query;
         EXEC SQL DECLARE BuscaSegmentacaoGrupo CURSOR FOR Consulta2Grupo;
         EXEC SQL WHENEVER NOT FOUND DO break;

         l_virg=false ;
         ii=0 ;

         EXEC SQL OPEN BuscaSegmentacaoGrupo;
         for ( ;; )
         {
            EXEC SQL FETCH BuscaSegmentacaoGrupo INTO :dsSegmentacao:i_dsSegmentacao;

            if ( l_virg== true )
            {
                 LinhaTemp += SEPARADOR;
                 l_virg=false ;
            }

            if( i_dsSegmentacao != -1 )
            {
               dsSegmentacao.arr[ dsSegmentacao.len ] = 0x0;
               sprintf( buffer,"%s",(unsigned char *)dsSegmentacao.arr );
               LinhaTemp += buffer;
               l_virg= true ;
               ii++;
            }
         }

         EXEC SQL CLOSE BuscaSegmentacaoGrupo;

         if ( ii > 0)
             LinhaGravar += "\""+LinhaTemp+"\"";
         else
             LinhaGravar += LinhaTemp;

         LinhaTemp ="";


      }

      /*------------------------------------*/  
      // Carteira
      /*------------------------------------*/
      {

         LinhaGravar += SEPARADOR;

         consulta = " SELECT "
                    "    DSTIPOCARTEIRA "
                    " FROM "
                    "    APOIO.TIPOCARTEIRA "
                    " WHERE "
                    "    IDTIPOCARTEIRA > 0 "
                    " AND "
                    "    IDTIPOCARTEIRA IN ( SELECT IDTIPOCARTEIRA FROM CONTATOADM.TIPOCARTEIRAGRUPO WHERE IDGRUPO = ";
         sprintf( buffer,"%lu",idGrupo);
         consulta += buffer;
         consulta += " ) ";

         query = (char *)consulta.c_str();

         log->Trace( "Vai executar busca de Tipo Carteira..." );
         log->Trace( query );

         EXEC SQL PREPARE Consulta3Grupo FROM :query;
         EXEC SQL DECLARE BuscaTipoCarteiraGrupo CURSOR FOR Consulta3Grupo;
         EXEC SQL WHENEVER NOT FOUND DO break;

         l_virg=false ;
         ii=0 ;

         EXEC SQL OPEN BuscaTipoCarteiraGrupo;
         for ( ;; )
         {
            EXEC SQL FETCH BuscaTipoCarteiraGrupo INTO :dsTipoCarteira:i_dsTipoCarteira;

            if ( l_virg == true )
            {
                 LinhaTemp += SEPARADOR;
                 l_virg=false ;
            }

            if( i_dsSegmentacao != -1 )
            {
               dsTipoCarteira.arr[ dsTipoCarteira.len ] = 0x0;
               sprintf( buffer,"%s",(unsigned char *)dsTipoCarteira.arr );
               LinhaTemp += buffer;
               l_virg= true ;
               ii++;
            }
         }

         EXEC SQL CLOSE BuscaTipoCarteiraGrupo;

         if ( ii > 0)
             LinhaGravar += "\""+LinhaTemp+"\"";
         else
             LinhaGravar += LinhaTemp;
         LinhaTemp ="";

      }

      /*------------------------------------*/
      // Regional
      /*------------------------------------*/
      
      {
         LinhaGravar += SEPARADOR;
         consulta  = " SELECT "
                     "    UF.SGUF "
                     " FROM"
                     "    APOIO.UF UF "
                     " WHERE "
                     "    UF.IDUF > 0 "
                     " AND "
                     "    UF.IDUF "
                     " IN ( "
                     "      SELECT IDUF "
                     "      FROM CUSTOMER.UFOPERADORA "
                     "      WHERE IDUFOPERADORA IN "
                     "      ( SELECT IDUFOPERADORA "
                     "           FROM CONTATOADM.UFOPERADORAGRUPO WHERE IDGRUPO = ";
         sprintf( buffer,"%lu",idGrupo );
         consulta += buffer;
         consulta += " )) ";


         query = (char *)consulta.c_str();

         log->Trace( "Vai executar busca de Regional..." );
         log->Trace( query );

         EXEC SQL PREPARE ConsultaUFOperadoraGrupo FROM :query;
         EXEC SQL DECLARE BuscaUFOperadoraGrupo CURSOR FOR ConsultaUFOperadoraGrupo;
         EXEC SQL WHENEVER NOT FOUND DO break;

         l_virg=false ;
         ii=0 ;

         EXEC SQL OPEN BuscaUFOperadoraGrupo;
         for ( ;; )
         {
            EXEC SQL FETCH BuscaUFOperadoraGrupo INTO :nmUFOperadora:i_nmUFOperadora;

            if ( l_virg== true )
            {
                 LinhaTemp += SEPARADOR;
                 l_virg=false ;
            }

            if( i_nmUFOperadora != -1 )
            {
               nmUFOperadora.arr[ nmUFOperadora.len ] = 0x0;
               sprintf( buffer,"%s",(unsigned char *)nmUFOperadora.arr );
               LinhaTemp += buffer;
               l_virg= true ;
               ii++;
            }
         }

         EXEC SQL CLOSE BuscaUFOperadoraGrupo;

         if ( ii > 0)
             LinhaGravar += "\""+LinhaTemp+"\"";
         else
             LinhaGravar += LinhaTemp;
         LinhaTemp ="";

      }

     /*------------------------------------*/
     // Grupo de Abertura 
     /*------------------------------------*/
      {
         LinhaGravar += SEPARADOR;
         consulta  = "SELECT "
                     "    NMGRUPO "
                     " FROM"
                     "    ACESSO.GRUPO "
                     " WHERE "
                     "    IDGRUPO > 0 "
                     " AND "
                     "    IDGRUPO "
                     " IN ( SELECT "
                     "       GRUPOABERTURAGRUPO.IDGRUPO"
                     "     FROM "
                     "       CONTATOADM.GRUPOABERTURAGRUPO "
                     "     WHERE"
                     "       GRUPOABERTURAGRUPO.IDGRUPO = ";
         sprintf( buffer,"%lu",idGrupo );
         consulta += buffer;
         consulta += " ) ";

         query = (char *)consulta.c_str();

         log->Trace( "Vai executar busca de Grupo de Abertura..." );
         log->Trace( query );

         EXEC SQL PREPARE ConsultaGrpAberturaGrupo FROM :query;
         EXEC SQL DECLARE BuscaGrpAberturaGrupo CURSOR FOR ConsultaGrpAberturaGrupo;
         EXEC SQL WHENEVER NOT FOUND DO break;

         l_virg=false ;
         ii=0 ;

         EXEC SQL OPEN BuscaGrpAberturaGrupo;
         for ( ;; )
         {
            EXEC SQL FETCH BuscaGrpAberturaGrupo INTO :nmGrupo:i_nmGrupo;


            if ( l_virg== true )
            {
                 LinhaTemp += SEPARADOR;
                 l_virg=false ;
            }

            if( i_nmGrupo != -1 )
            {
               nmGrupo.arr[ nmGrupo.len ] = 0x0;
               sprintf( buffer,"%s",(unsigned char *)nmGrupo.arr );
               LinhaTemp += buffer;
               l_virg= true ;
               ii++;

            }
         }

         EXEC SQL CLOSE BuscaGrpAberturaGrupo;

         if ( ii > 0)
             LinhaGravar += "\""+LinhaTemp+"\"";
         else
             LinhaGravar += LinhaTemp;
         LinhaTemp ="";

      }


      /*------------------------------------*/
      // Canal
      /*------------------------------------*/
      {
         LinhaGravar += SEPARADOR;
         consulta = " SELECT "
                    "    NMCANAL "
                    " FROM "
                    "    APOIO.CANAL "
                    " WHERE "
                    "    IDCANAL > 0 "
                    " AND "
                    "    IDCANAL IN ( SELECT IDCANAL FROM CONTATOADM.CANALGRUPO WHERE IDGRUPO = ";
         sprintf( buffer,"%lu",idGrupo );
         consulta += buffer;
         consulta += " ) ";

         query = (char *)consulta.c_str();
         log->Trace( "Vai executar busca de Canal..." );
         log->Trace( query );

         EXEC SQL PREPARE ConsultaCanal FROM :query;
         EXEC SQL DECLARE BuscaCanalGrupo CURSOR FOR ConsultaCanal;
         EXEC SQL WHENEVER NOT FOUND DO break;

         l_virg=false ;
         ii=0 ;

         EXEC SQL OPEN BuscaCanalGrupo;
         for ( ;; )
         {
            EXEC SQL FETCH BuscaCanalGrupo INTO :dsCanal:i_dsCanal;


            if ( l_virg== true )
            {
                 LinhaTemp += SEPARADOR;
                 l_virg=false ;
            }
            
            if( i_dsCanal != -1 )
            {
               dsCanal.arr[ dsCanal.len ] = 0x0;
               sprintf( buffer,"%s",(unsigned char *)dsCanal.arr );
               LinhaTemp += buffer;
               l_virg= true ;
               ii++;

            }
         }

         EXEC SQL CLOSE BuscaCanalGrupo;

         if ( ii > 0)
             LinhaGravar += "\""+LinhaTemp+"\"";
         else
             LinhaGravar += LinhaTemp;
         LinhaTemp ="";

      }
   
      /*------------------------------------*/
      // Procedencia
      /*------------------------------------*/
      {
         LinhaGravar += SEPARADOR;
         consulta  =" SELECT "
                    "    DSPROCEDENCIA "
                    " FROM "
                    "    APOIO.PROCEDENCIA"
                    " WHERE "
                    "    IDPROCEDENCIA > 0 "
                    " AND "
                    "    IDPROCEDENCIA IN ( SELECT IDPROCEDENCIA FROM CONTATOADM.PROCEDENCIAGRUPO WHERE IDGRUPO = ";

         sprintf( buffer,"%lu",idGrupo );
         consulta += buffer;
         consulta += " ) ";

         query = (char *)consulta.c_str();

         log->Trace( "Vai executar busca de Tipo Procedencia..." );
         log->Trace( query );

         EXEC SQL PREPARE ConsultaProcedencia FROM :query;
         EXEC SQL DECLARE BuscaProcedenciaGrupo CURSOR FOR ConsultaProcedencia;
         EXEC SQL WHENEVER NOT FOUND DO break;

         l_virg=false ;
         ii=0 ;

         EXEC SQL OPEN BuscaProcedenciaGrupo;
         for ( ;; )
         {
            EXEC SQL FETCH BuscaProcedenciaGrupo INTO :dsProcedencia:i_dsProcedencia;

            if ( l_virg== true )
            {
                 LinhaTemp += SEPARADOR;
                 l_virg=false ;
            }

            if( i_dsProcedencia != -1 )
            {
               dsProcedencia.arr[ dsProcedencia.len ] = 0x0;
               sprintf( buffer,"%s",(unsigned char *)dsProcedencia.arr );
               LinhaTemp += buffer;
               l_virg= true ;
               ii++;
           }
         }

         EXEC SQL CLOSE BuscaProcedenciaGrupo;

         if ( ii > 0)
             LinhaGravar += "\""+LinhaTemp+"\"";
         else
             LinhaGravar += LinhaTemp;
         LinhaTemp ="";

      }


      /*------------------------------------*/
      // Natureza
      /*------------------------------------*/


      {

         LinhaGravar += SEPARADOR;

         consulta  =" SELECT "
                    "    DSTIPOPESSOA "
                    " FROM "
                    "    APOIO.TIPOPESSOA "
                    " WHERE "
                    "    IDTIPOPESSOA > 0 "
                    " AND "
                    "    IDTIPOPESSOA IN ( SELECT IDTIPOPESSOA FROM CONTATOADM.TIPOPESSOAGRUPO WHERE IDGRUPO = ";

         sprintf( buffer,"%lu",idGrupo );
         consulta += buffer;
         consulta += " ) ";

         query = (char *)consulta.c_str();

         log->Trace( "Vai executar busca de Natureza..." );
         log->Trace( query );

         EXEC SQL PREPARE ConsultaNatureza FROM :query;
         EXEC SQL DECLARE BuscaNaturezaGrupo CURSOR FOR ConsultaNatureza;
         EXEC SQL WHENEVER NOT FOUND DO break;

         l_virg=false ;
         ii=0 ;

         EXEC SQL OPEN BuscaNaturezaGrupo;
         for ( ;; )
         {
            EXEC SQL FETCH BuscaNaturezaGrupo INTO :dsNatureza:i_dsNatureza;

            if ( l_virg== true )
            {
                 LinhaTemp += SEPARADOR;
                 l_virg=false ;
            }

            if( i_dsNatureza != -1 )
            {
               dsNatureza.arr[ dsNatureza.len ] = 0x0;
               sprintf( buffer,"%s",(unsigned char *)dsNatureza.arr );
               LinhaTemp += buffer;
               l_virg= true ;
               ii++;

            }
         }

         EXEC SQL CLOSE BuscaNaturezaGrupo;

         if ( ii > 0)
             LinhaGravar += "\""+LinhaTemp+"\"";
         else
             LinhaGravar += LinhaTemp;
         LinhaTemp ="";

      }
      /*------------------------------------*/
      // Nova Linha
      /*------------------------------------*/

      LinhaGravar += "\n ";
      

      /*
       * -----> Grava Linha Detalhe
       */
      pRelatorio->WriteArquivoSaida( LinhaGravar.c_str() );

   }

   //log->Trace("< proCDetalheRegistrosGrupo()");

   return 0;

}



/************************************/
/* grupos relacionados aos contatos */
/************************************/

int procObtemGrupoRelacionadosContatos( unsigned long idContato 
                                        ,string * listaGrupo 
                                        ,LIST_PK  *vecGrupoRelContato
                                        ,cTrace * log
                                      )
{

    log->Trace("> procObtemGrupoRelacionadosContatos()");
    string consulta;
    int i,j;
    i = j = 0;

    struct sqlca sqlca;
    EXEC SQL BEGIN DECLARE SECTION;

      char * query;
      unsigned long idGrupo = 0;

    EXEC SQL END DECLARE SECTION;

    char buffer[30];

    consulta  = " SELECT IDGRUPO FROM CONTATOADM.CONTATOGRUPO WHERE IDCONTATO = " ;

    sprintf( buffer, "%lu", idContato );

    consulta += buffer ;

    query = (char *)consulta.c_str();

    log->Trace( query );

    EXEC SQL PREPARE Consulta FROM :query;
    EXEC SQL DECLARE ObterGrupoRelacionadosContatos CURSOR FOR Consulta;
 
    EXEC SQL WHENEVER SQLERROR DO SqlError( &sqlca,log );
    EXEC SQL WHENEVER NOT FOUND DO break;

    EXEC SQL OPEN ObterGrupoRelacionadosContatos;

    bool virg ;
    virg = false ;

    for( ;; )
    {
        
        EXEC SQL FETCH ObterGrupoRelacionadosContatos INTO :idGrupo;
    
        if ( idGrupo > 0 )
        {
            if ( virg == true )
            {
                listaGrupo->append(SEPARADOR_IN);
                virg = false ;
            }
               
            vecGrupoRelContato->push_back( idGrupo );
            sprintf( buffer, "%lu", idGrupo );
            listaGrupo->append(buffer);
            virg = true ;


        }

    }
    vecGrupoRelContato->sort();
    vecGrupoRelContato->unique();

    EXEC SQL CLOSE ObterGrupoRelacionadosContatos;
    log->Trace("< procObtemGrupoRelacionadosContatos()");

    return 0;
}



/************************************/
/* Retorna o nome dos grupos relacionados */
/************************************/

void proCNomeGrupo( string * listaGrupo , LIST_PK  *vecGrupo, cTrace * log )
{

    log->Trace("> proCNomeGrupo()");

    string consulta;
    string tmp;
    int i,j;
    i = j = 0;
    list<unsigned long>::iterator it;

    if ( vecGrupo->size() > 0 )
    {
        struct sqlca sqlca;
        
        EXEC SQL BEGIN DECLARE SECTION;

            char * query;
            VARCHAR NomeGrupo[ 256 ];
            short i_NomeGrupo;

        EXEC SQL END DECLARE SECTION;

        char buffer[ 512 ];

        i_NomeGrupo = -1;
    
        consulta  = " SELECT NMGRUPO   FROM ACESSO.GRUPO  WHERE  GRUPO.IDGRUPO  IN( " ;

/*
        sprintf( buffer, "%lu", vecGrupo->at(i) );
        log->Trace( buffer );
*/     
        bool exit_in = false ;

        i=0;
        for ( it = vecGrupo->begin(); it != vecGrupo->end(); it++ )
        {   
            if ( *it > 0 )
            {
                if (i > 0 )
                  consulta += SEPARADOR_IN;
                sprintf( buffer, "%lu", *it );
                consulta += buffer ;
              //  log->Trace( buffer );
                exit_in = true ;
                i++;
            }
        }
        
        consulta += " ) ORDER BY NMGRUPO "  ;

        query = (char *)consulta.c_str();
        
        log->Trace( query );
        if ( exit_in == true )
        {

        EXEC SQL PREPARE Consulta FROM :query;
        EXEC SQL DECLARE ObterNomeGrupo CURSOR FOR Consulta;
 
        EXEC SQL WHENEVER SQLERROR DO SqlError( &sqlca,log );
        EXEC SQL WHENEVER NOT FOUND DO break;
        EXEC SQL OPEN ObterNomeGrupo;

        for( i=0 ; ;i++)
        {
            EXEC SQL FETCH ObterNomeGrupo INTO :NomeGrupo:i_NomeGrupo;
    
            if ( i_NomeGrupo !=  -1 )
            {
                if ( i > 0 )
                    tmp +=SEPARADOR;
                NomeGrupo.arr[ NomeGrupo.len ] = 0x0;
                sprintf( buffer,"%s",(unsigned char *)NomeGrupo.arr );
                tmp += buffer;
            }
        }

        EXEC SQL CLOSE ObterNomeGrupo;

        if (i > 0 )
        {
            listaGrupo->append("\"");
            listaGrupo->append(tmp);
            listaGrupo->append("\"");
        }
        else
            listaGrupo->append(tmp);
        }
        else
          listaGrupo->append(" ");
           
    }
    else
      listaGrupo->append(" ");

    log->Trace("< proCNomeGrupo()");
}

/*****************************/
/* Retorna o nome do contato */
/*****************************/
void  proCNomeContato( const unsigned long idContatoPrm,string  *sNMContato, cTrace * log )
{
   
   //log->Trace("> proCNomeContato()");

   struct sqlca sqlca;
   char buffer[512];
   EXEC SQL BEGIN DECLARE SECTION;

      unsigned long idContato = idContatoPrm;
      VARCHAR NomeContato[256];
      short i_NomeContato;

   EXEC SQL END DECLARE SECTION;

   EXEC SQL WHENEVER SQLERROR DO SqlError( &sqlca, log );
   EXEC SQL WHENEVER NOT FOUND CONTINUE;


   EXEC SQL
      SELECT
         NMCONTATO
      INTO
         :NomeContato:i_NomeContato
      FROM
         CONTATOADM.NOMECONTATO,
         CONTATOADM.CONTATO
      WHERE
          NOMECONTATO.IDNOMECONTATO = CONTATO.IDNOMECONTATO
    	AND
		  CONTATO.IDCONTATO = :idContato ;



      if ( i_NomeContato != -1 )
      {
         NomeContato.arr[ NomeContato.len ] = 0x0;
         sprintf( buffer,"%s",(unsigned char *)NomeContato.arr );
         sNMContato->append(buffer);
      }

      EXEC SQL WHENEVER NOT FOUND DO break;

    //log->Trace("< proCNomeContato()");
}

/****************************************************/
/* Retorna o nome da Fase dos grupos esato alocados */
/****************************************************/

void proCNomeFase( string * lista , LIST_PK  *vecGrupo , unsigned long idContato, cTrace * log )
{

    //log->Trace("> proCNomeFase()");
    string consulta;
    int i,j;
    string tmp;
    list<unsigned long>::iterator it;

    i = j = 0;

    if (vecGrupo->size() > 0 )
    {
        struct sqlca sqlca;
        EXEC SQL BEGIN DECLARE SECTION;

          char * query;
          VARCHAR NomeFase[256];
          short i_NomeFase;

        EXEC SQL END DECLARE SECTION;

        char buffer[512];

        i_NomeFase = -1;

        consulta = " SELECT DISTINCT "
                   "       NMTIPOSEQUENCIA    "
                   "  FROM  "
                   "      CONTATOADM.CONTATOGRUPO CONTATOGRUPO,CONTATOADM.SEQUENCIA SEQUENCIA,CONTATOADM.TIPOSEQUENCIA   TIPOSEQUENCIA"
                   " WHERE "
                   "      SEQUENCIA.IDTIPOSEQUENCIA =  TIPOSEQUENCIA.IDTIPOSEQUENCIA "
                   "  AND SEQUENCIA.IDCONTATOGRUPO = CONTATOGRUPO.IDCONTATOGRUPO "
                   "   AND CONTATOGRUPO.IDCONTATO = " ;

        sprintf( buffer, "%lu", idContato );
        consulta += buffer ;
        consulta += "   AND CONTATOGRUPO.IDGRUPO IN( ";

        bool exit_in = false ;

        i=0;
        for ( it = vecGrupo->begin(); it != vecGrupo->end(); it++ )
        {   
              if ( *it > 0 )
              {
                  if (i > 0 )
                      consulta += "," ;
                  sprintf( buffer, "%lu", *it );
                  consulta += buffer ;
                  exit_in = true ;
                  i++;
              }

        }

        consulta += "	) ORDER BY NMTIPOSEQUENCIA " ;

        query = (char *)consulta.c_str();

        log->Trace( query );
        if ( exit_in == true )
        {

        EXEC SQL PREPARE ConsultaFase FROM :query;
        EXEC SQL DECLARE ObterNomeFase CURSOR FOR ConsultaFase;
 
        EXEC SQL WHENEVER SQLERROR DO SqlError( &sqlca,log );
        EXEC SQL WHENEVER NOT FOUND DO break;

        EXEC SQL OPEN ObterNomeFase;

        for( i=0 ; ;i++)
        {
            EXEC SQL FETCH ObterNomeFase INTO :NomeFase:i_NomeFase;
    
            if ( i_NomeFase !=  -1 )
            {
                if ( i > 0 )
                    tmp +=SEPARADOR;

                NomeFase.arr[ NomeFase.len ] = 0x0;
                sprintf( buffer,"%s",(unsigned char *)NomeFase.arr );
                tmp +=buffer;
            }
        }

        EXEC SQL CLOSE ObterNomeFase;

        if (i > 0 )
        {
            lista->append("\"");
            lista->append(tmp);
            lista->append("\"");
        }
        else
            lista->append(tmp);
    }
    else
      lista->append(" ");
    }
    else
      lista->append(" ");

    //log->Trace("< proCNomeFase()");
}



bool proC_SelRelatorios
( 
    char *sNomeArquivoGerar,
    int * idTipoRelatorioPrm,
    char * LoginUsuario,
    LIST_PK * pTipoCliente,
    LIST_PK * pTipoLinha,
    LIST_PK * pSegmentacao,
    LIST_PK * pTipoCarteira,
    LIST_PK * pCanal,
    LIST_PK * pNatureza,
    LIST_PK * pRegional,
    LIST_PK * pFechamento,
    LIST_PK * pGrupoTratamento,
    LIST_PK * pGrupoAbertura,
    LIST_PK * pGrupoRetorno,
    int * inDisponibilidade,
    st_vlRelatorioArvore * status,
    cTrace * log
)
{
    log->Trace( "> proC_SelRelatorios()" );
    struct sqlca sqlca;
    int idTipoRelatorioCmp;
    bool fimRegistros = true;

    struct tm * ptr;
    time_t tm;
    char sDataHora[21];
    tm = time( NULL );
    ptr = localtime( &tm );
    strftime( sDataHora,20,"%d%m%Y_%H%M%S",ptr );


    EXEC SQL BEGIN DECLARE SECTION;

      VARCHAR dtSolicitacao[256];
      VARCHAR nmLogin[256];
      VARCHAR ArquivoSaida[256];
      short   i_nmLogin = -1;
      short   i_dtSolicitacao = -1;

    EXEC SQL END DECLARE SECTION;

    memset( &nmLogin      , 0x0, sizeof(nmLogin) );
    memset( &dtSolicitacao, 0x0, sizeof(dtSolicitacao) );
    memset( &ArquivoSaida , 0x0, sizeof(ArquivoSaida) );

    EXEC SQL DECLARE Consulta CURSOR FOR 
        SELECT 
           NMLOGINUSUARIO,
           TO_CHAR(DTSOLICITACAO,'DD/MM/YYYY HH24:MI:SS') DTSOLICITACAO
	    FROM
	       CONTATOADM.FILTRORELATORIOCONTATO
        WHERE
           DTGERACAO IS NULL
        ORDER BY DTSOLICITACAO;

    EXEC SQL OPEN Consulta;
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    for( ;; )
    {
        
        EXEC SQL FETCH Consulta INTO :nmLogin:i_nmLogin,
                                     :dtSolicitacao:i_dtSolicitacao;

        ( i_nmLogin == -1 ) ? fimRegistros = true : fimRegistros = false;

        CONVIND( nmLogin,i_nmLogin );
        CONVIND( dtSolicitacao,i_dtSolicitacao );

        log->Trace( "Selecionando Usuario [%s], Data de Solicitacao [%s]",(char *)nmLogin.arr,(char *)dtSolicitacao.arr );

        proC_CarregaFiltro
        (
             (char *)nmLogin.arr,
             (char *)dtSolicitacao.arr,
             &idTipoRelatorioCmp,
             pTipoCliente,
             pTipoLinha,
             pSegmentacao,
             pTipoCarteira,
             pCanal,
             pNatureza,
             pRegional,
             pFechamento,
             pGrupoTratamento,
             pGrupoAbertura,
             pGrupoRetorno,
             inDisponibilidade,
             status,
             log
        );   
        
        char sTipoConsulta[256];
	    if ( idTipoRelatorioCmp == 1 )
	    {
	        strcpy( sTipoConsulta,"Contato" );
	    }
	    
	    if ( idTipoRelatorioCmp == 2 )
	    {
	        strcpy( sTipoConsulta,"Grupo" );
	    }
	
        // Max: O nome do arquivo de saída estava sendo gerado com espaços
        // foi trocado para _
	    if ( idTipoRelatorioCmp == 3 )
	    {
	        strcpy( sTipoConsulta,"Contato_X_Grupo" );
	    }
	    char sLogin[64];
	    strcpy( sLogin,(char *)nmLogin.arr );

        sprintf( sNomeArquivoGerar,"%s_%s_%s.csv", sTipoConsulta, sLogin, sDataHora );
	    strToOra( ArquivoSaida,sNomeArquivoGerar );

        
        EXEC SQL WHENEVER NOT FOUND DO CONTINUE;
        EXEC SQL
        UPDATE 
            CONTATOADM.FILTRORELATORIOCONTATO
        SET
            DTGERACAO = SYSDATE,
            URLDOWNLOAD = :ArquivoSaida
        WHERE
            UPPER (NMLOGINUSUARIO) = UPPER (:nmLogin)
        AND 
            DTSOLICITACAO = TO_DATE(:dtSolicitacao,'DD/MM/YYYY HH24:MI:SS');

        break;

    }        

    EXEC SQL CLOSE Consulta;

    if( i_nmLogin != -1 )
    {
        *idTipoRelatorioPrm = idTipoRelatorioCmp;
        strcpy( LoginUsuario,(char *)nmLogin.arr );
    }
            
    log->Trace( "< proC_SelRelatorios()" );
    
    return fimRegistros;
}



void proC_CarregaFiltro
( 
    char *sLogin,
    char *dataSolicitacao,
    int * idTipoRelatorioPrm,
    LIST_PK * pTipoCliente,
    LIST_PK * pTipoLinha,
    LIST_PK * pSegmentacao,
    LIST_PK * pTipoCarteira,
    LIST_PK * pCanal,
    LIST_PK * pNatureza,
    LIST_PK * pRegional,
    LIST_PK * pFechamento,
    LIST_PK * pGrupoTratamento,
    LIST_PK * pGrupoAbertura,
    LIST_PK * pGrupoRetorno,
    int *inDisponibilidade,
    st_vlRelatorioArvore * status,
    cTrace * log 
)
{
    log->Trace( "> proC_CarregaFiltro()" );
    struct sqlca sqlca;

//    char sLogin[256];
    char buffer[3];
    char sTipoConsulta[33];

    EXEC SQL BEGIN DECLARE SECTION;

      unsigned long idTipoRelatorio;
      unsigned long idSegmentacao;
      unsigned long idTipoLinha;
      unsigned long idTipoPessoa;
      unsigned long idTipoCarteira;
      unsigned long idUFOperadora;
      unsigned long idTipoRelacionamento;
      unsigned long idGrupoAbertura;
      unsigned long idGrupoTratamento;
      unsigned long idGrupoRetorno;
      unsigned long idProcedencia;
      unsigned long idTipoFechamento;

      VARCHAR inDisponivel[2];
      VARCHAR nmLoginCmp[256];
      VARCHAR dtSolicitacao[65];
      
      short i_idTipoRelatorio = -1;
      short i_idSegmentacao = -1;
      short i_idTipoLinha = -1;
      short i_idTipoPessoa = -1;
      short i_idTipoCarteira = -1;
      short i_idUFOperadora = -1;
      short i_idTipoRelacionamento = -1;
      short i_idGrupoAbertura = -1;
      short i_idGrupoTratamento = -1;
      short i_idGrupoRetorno = -1;
      short i_idProcedencia = -1;
      short i_idTipoFechamento = -1;
      short i_inDisponivel = -1;

    EXEC SQL END DECLARE SECTION;

    memset( sTipoConsulta , 0x0, sizeof(sTipoConsulta) );
    memset( &inDisponivel , 0x0, sizeof(inDisponivel) );
    memset( &nmLoginCmp   , 0x0, sizeof(nmLoginCmp) );
    memset( &dtSolicitacao, 0x0, sizeof(dtSolicitacao) );

	// Precisamos limpar as listas de filtros
    pTipoCliente->clear();
    pTipoLinha->clear();
    pSegmentacao->clear();
    pTipoCarteira->clear();
    pCanal->clear();
    pNatureza->clear();
    pRegional->clear();
    pFechamento->clear();
    pGrupoTratamento->clear();
    pGrupoAbertura->clear();
    pGrupoRetorno->clear();


    strToOra( nmLoginCmp,sLogin );
    strToOra( dtSolicitacao,dataSolicitacao );

    EXEC SQL DECLARE Filtros CURSOR FOR
        SELECT 
            TPRELATORIO
           ,IDSEGMENTACAO
           ,IDTIPOLINHA
           ,IDTIPOPESSOA
           ,IDTIPOCARTEIRA
           ,IDUFOPERADORA
           ,IDTIPORELACIONAMENTO
           ,IDGRUPOABERTURA
           ,IDGRUPOTRATAMENTO
           ,IDGRUPORETORNO
           ,INDISPONIVEL
           ,IDPROCEDENCIA
           ,IDTIPOFECHAMENTOCONTATO
        FROM
           CONTATOADM.FILTRORELATORIOCONTATO
        WHERE
           DTSOLICITACAO = TO_DATE(:dtSolicitacao,'DD/MM/YYYY HH24:MI:SS')
        AND
           UPPER(NMLOGINUSUARIO) = UPPER(:nmLoginCmp);

    EXEC SQL WHENEVER SQLERROR DO SqlError( &sqlca,log );
    EXEC SQL WHENEVER NOT FOUND DO break;

    EXEC SQL OPEN Filtros;

    // Por default Disponível = False, este é um filtro obrigatório
    (*inDisponibilidade) = 0;
    status->i_inDisponibilidade = 1;

    for( ;; )
    {
        EXEC SQL FETCH Filtros 
             INTO   :idTipoRelatorio:i_idTipoRelatorio
                   ,:idSegmentacao:i_idSegmentacao
                   ,:idTipoLinha:i_idTipoLinha
                   ,:idTipoPessoa:i_idTipoPessoa
                   ,:idTipoCarteira:i_idTipoCarteira
                   ,:idUFOperadora:i_idUFOperadora
                   ,:idTipoRelacionamento:i_idTipoRelacionamento
                   ,:idGrupoAbertura:i_idGrupoAbertura
                   ,:idGrupoTratamento:i_idGrupoTratamento
                   ,:idGrupoRetorno:i_idGrupoRetorno
                   ,:inDisponivel:i_inDisponivel
                   ,:idProcedencia:i_idProcedencia
                   ,:idTipoFechamento:i_idTipoFechamento;


        /*------------------------------------------------*/
        // Atribui Disponível
        /*------------------------------------------------*/
        if ( i_inDisponivel != -1 )   // Disponível
        {
            CONVIND( inDisponivel, i_inDisponivel );
//            sprintf( buffer, "%.*s", inDisponivel.len, (char *)inDisponivel.arr );
            strcpy( buffer, (char *)inDisponivel.arr );

			
            //if(buffer[0] == '1')
			if( atoi(buffer) > 0 )
                (*inDisponibilidade) = 1;
			else
                (*inDisponibilidade) = 0;

        }

        

        /*------------------------------------------------*/
        // Atribui Segmento
        /*------------------------------------------------*/
        if ( i_idSegmentacao != -1 )   // Segmentacao
        {
            pSegmentacao->push_back(idSegmentacao);
            status->idSegmentacao = 1;
        }

        /*------------------------------------------------*/
        // Atribui Tipo de Linha
        /*------------------------------------------------*/
        if ( i_idTipoLinha != -1 )   // Tipo de Linha - Pos - Pre
        {
            pTipoLinha->push_back(idTipoLinha);
            status->idTipoLinha = 1;
        }

        /*------------------------------------------------*/
        // Atribui Tipo Cliente - Tipo de Relacionamento
        /*------------------------------------------------*/
        if ( i_idTipoRelacionamento != -1 )
        {
            pTipoCliente->push_back(idTipoRelacionamento);
            status->idTipoRelacionamento = 1;
        }

        /*------------------------------------------------*/
        // Atribui Tipo de Carteira
        /*------------------------------------------------*/
        if ( i_idTipoCarteira != -1 )
        {
            pTipoCarteira->push_back(idTipoCarteira);
            status->idTipoCarteira = 1;
        }

        /*------------------------------------------------*/
        // Atribui Regional
        /*------------------------------------------------*/
        if ( i_idUFOperadora != -1 )
        {
            pRegional->push_back(idUFOperadora);
            status->idUFOperadora = 1;
        }

        /*------------------------------------------------*/
        // Atribui Natureza
        /*------------------------------------------------*/
        if ( i_idTipoPessoa != -1 )
        {
            pNatureza->push_back(idTipoPessoa);
            status->idNatureza = 1;
        }

        /*------------------------------------------------*/
        // Atribui Grupo de Abertura
        /*------------------------------------------------*/
        if ( i_idGrupoAbertura != -1 )
        {
            pGrupoAbertura->push_back(idGrupoAbertura);
            status->idGrupoAbertura = 1;
        }

        /*------------------------------------------------*/
        // Atribui Grupo de Tratamento
        /*------------------------------------------------*/
        if ( i_idGrupoTratamento != -1 )
        {
            pGrupoTratamento->push_back(idGrupoTratamento);
            status->idGrupoTratamento = 1;
        }

        /*------------------------------------------------*/
        // Atribui Grupo de Retorno
        /*------------------------------------------------*/
        if ( i_idGrupoRetorno != -1 )
        {
                pGrupoRetorno->push_back(idGrupoRetorno);
                status->idGrupoRetorno = 1;
        }

/*
        if ( i_inDisponivel != -1 )
        {
            pTipoLinha.push_back(idTipoLinha);
            status.idTipoLinha = 1;
        }
*/

        
        /*------------------------------------------------*/
        // Atribui Canal
        /*------------------------------------------------*/
        if ( i_idProcedencia != -1 )
        {
                pCanal->push_back(idProcedencia);
                status->Canal = 1;
        }

        /*------------------------------------------------*/
        // Atribui Tipo de Fechamento
        /*------------------------------------------------*/
        if ( i_idTipoFechamento != -1 )
        {
            pFechamento->push_back(idTipoFechamento);
            status->idFaseGrupoFechamento = 1;
        }

    }

    if ( status->idSegmentacao == 1 )
    {
        pSegmentacao->sort();
        pSegmentacao->unique();
        log->Trace( "Filtrando por Segmentacao" );
    }

    if ( status->idTipoLinha == 1 )
    {
        pTipoLinha->sort();
        pTipoLinha->unique();
        log->Trace( "Filtrando por Tipo de Linha" );
    }

    if ( status->idTipoRelacionamento == 1 )
    {
        pTipoCliente->sort();
        pTipoCliente->unique();
        log->Trace( "Filtrando por Tipo de Cliente / Pessoa" );
    }

    if ( status->idTipoCarteira == 1 )
    {
        pTipoCarteira->sort();
        pTipoCarteira->unique();
        log->Trace( "Filtrando por Tipo de Carteira" );
    }

    if ( status->idUFOperadora == 1 )
    {
        pRegional->sort();
        pRegional->unique();
        log->Trace( "Filtrando por Regional" );
    }

    if ( status->idNatureza == 1 )
    {
        pNatureza->sort();
        pNatureza->unique();
        log->Trace( "Filtrando por Natureza" );
    }

    if ( status->idGrupoAbertura == 1 )
    {
        pGrupoAbertura->sort();
        pGrupoAbertura->unique();
        log->Trace( "Filtrando por Grupo de Abertura" );
    }

    if ( status->idGrupoTratamento == 1 )
    {
        pGrupoTratamento->sort();
        pGrupoTratamento->unique();
        log->Trace( "Filtrando por Grupo de Tratamento" );
    }

    if ( status->idGrupoRetorno == 1 )
    {
        pGrupoRetorno->sort();
        pGrupoRetorno->unique();
        log->Trace( "Filtrando por Grupo de Retorno" );
    }

    if ( status->Canal == 1 )
    {
        pCanal->sort();
        pCanal->unique();
        log->Trace( "Filtrando por Canal" );
    }

    if ( status->idFaseGrupoFechamento == 1 )
    {
        pFechamento->sort();
        pFechamento->unique();
        log->Trace( "Filtrando por FaseGrupoFechamento" );
    }


    EXEC SQL CLOSE Filtros;


/*
    if ( idTipoRelatorio == 1 ) strcpy( sTipoConsulta,"Contato" );
    
    if ( idTipoRelatorio == 2 ) strcpy( sTipoConsulta,"Grupo" );

    if ( idTipoRelatorio == 3 ) strcpy( sTipoConsulta,"Contato_X_Grupo" );
*/
    
    (*idTipoRelatorioPrm) = idTipoRelatorio;

    log->Trace( "Tipo de Relatorio [%d]", idTipoRelatorio );
    log->Trace( "Selecionou Consulta por [%s]",sTipoConsulta );

    log->Trace( "< proC_CarregaFiltro()" );

}




void proC_Desconectar( cTrace * log )
{
    struct sqlca sqlca;

    EXEC SQL WHENEVER SQLERROR DO SqlError( &sqlca,log );
    EXEC SQL COMMIT WORK RELEASE;

}




void proc_OrganizaTabela( int ttlPrm, cTrace * log )
{

    log->Trace( "> proc_OrganizaTabela()" );

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int ttl = ttlPrm;
        VARCHAR dtLimite[65];
        short i_dtLimite = -1;

    EXEC SQL END DECLARE SECTION;

    memset( &dtLimite,0x0,sizeof(dtLimite) );

    EXEC SQL WHENEVER SQLERROR DO SqlError( &sqlca,log );
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL
        SELECT TO_CHAR(TRUNC(SYSDATE-:ttl),'DD/MM/YYYY') INTO :dtLimite:i_dtLimite FROM DUAL;
    CONVIND( dtLimite,i_dtLimite );

    EXEC SQL
    DELETE FROM 
       CONTATOADM.FILTRORELATORIOCONTATO
    WHERE
       IDFILTRORELATORIOCONTATO 
    IN
    (
	    SELECT
	       IDFILTRORELATORIOCONTATO
	    FROM 
	       CONTATOADM.FILTRORELATORIOCONTATO
	    WHERE
	       TRUNC(DTGERACAO) < TO_DATE(:dtLimite,'DD/MM/YYYY')
    );   		

    log->Trace( "< proc_OrganizaTabela()" );

}
    
    
    
void SqlError( sqlca * sqlca, cTrace * log )
{
    char Msg[2048];


    sprintf( Msg, "%.*s", sqlca->sqlerrm.sqlerrml-1, sqlca->sqlerrm.sqlerrmc );
    
    printf( "SqlError [%s]\n",Msg );

    throw Msg;
}
