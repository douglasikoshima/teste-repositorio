// Venda.pcpp: implementation of the CVenda class.
//
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw/tuxfw.h>
#include <Defines/Defines.h>
#include <Util/Util.hpp>
#include <PessoaAbstract/PessoaAbstract.hpp>
#include <Lojista/Lojista.hpp>
#include <Venda/Venda.hpp>

EXEC SQL INCLUDE SQLCA;

void CVenda::iniciaValores()
{
	this->setIdVenda(-1);
	this->setDataInicial("");
	this->setDataFinal("");
	this->setDataVenda("");
	this->setBandeira("");
	this->setNrNsu("");
	this->setNrCartao("");
	this->setValor("");
	this->setNrSAP("");
	this->setSitefNumDoc(0);
	this->setDsTipoServico("");
	this->setDsLoja("");
	this->setInEstadoVenda(0);
	this->setDsMsgErroVenda("");
	this->setNrOrdem("");
	this->setDtProcVenda("");
	this->setNsuAutorizador(0);
	this->setNsuHostAutorizador("");
}

CVenda::CVenda()
{
	this->iniciaValores();
}

CVenda::CVenda(CPessoaAbstract *p)
{
	this->iniciaValores();

	if(NULL != p)
		m_pPessoaAbstract = p;
}

CVenda::~CVenda()
{

}

// Operação de Negocio (Interface)
void CVenda::inserir()
{
	this->inserirDB();
}

void CVenda::consultarVendas(list<CVenda> &listaVendas)
{
	this->carregarDadosVendasDB(listaVendas);
}

void CVenda::consultarSitefNumDoc()
{
	this->carregarSitefNumDoc();
}

void CVenda::consultarFinanceiro(list<CVenda> &listaVendas, int idPessoaDePara, int idTipoLinha, int idTipoRecarga, int idUFOperadora, int idGrupoOperadora, int idStatusVenda, int iIdTerminal)
{
	this->carregarDadosFinanceiroDB(listaVendas, idPessoaDePara, idTipoLinha, idTipoRecarga, idUFOperadora, idGrupoOperadora, idStatusVenda, iIdTerminal);
}

void CVenda::alteraEstadoVenda()
{
	this->alteraEstadoVendaDB();
}

// Getters
int CVenda::getIdVenda()
{
	return m_iIdVenda;
}

char *CVenda::getDataInicial(char *cDataInicial)
{
	strcpy(cDataInicial, this->m_cDataInicial);
	return cDataInicial;
}

char *CVenda::getDataFinal(char *cDataFinal)
{
	strcpy(cDataFinal, this->m_cDataFinal);
	return cDataFinal;
}

char *CVenda::getDataVenda(char *cDataVenda)
{
	strcpy(cDataVenda, this->m_cDataVenda);
	return cDataVenda;
}

char *CVenda::getBandeira(char *cBandeira)
{
	strcpy(cBandeira, this->m_cBandeira);
	return cBandeira;
}

char *CVenda::getNrNsu(char *cNrNsu)
{
	strcpy(cNrNsu, this->m_cNrNsu);
	return cNrNsu;
}

char *CVenda::getNrCartao(char *cNrCartao)
{
	strcpy(cNrCartao, this->m_cNrCartao);
	return cNrCartao;
}

char *CVenda::getValor(char *cValor)
{
	strcpy(cValor, this->m_cValor);
	return cValor;
}

char *CVenda::getNrSAP(char *cNrSAP)
{
	strcpy(cNrSAP, this->m_cNrSAP);
	return cNrSAP;
}

int CVenda::getIdTipo()
{	
	return this->m_iIdTipo;
}

char *CVenda::getTipo(char *cTipo)
{
	strcpy(cTipo, this->m_cTipo);
	return cTipo;
}

unsigned int CVenda::getSitefNumDoc()
{
	return this->m_iNumDoc;
}

char *CVenda::getDsTipoServico(char *cDsTipoServico)
{
	strcpy(cDsTipoServico, this->m_cDsTipoServico);
	return cDsTipoServico;
}

char *CVenda::getDsLoja(char *cDsLoja)
{
	strcpy(cDsLoja, this->m_cDsLoja);
	return cDsLoja;
}


char *CVenda::getNrTerminal(char *cNrTerminal)
{
	strcpy(cNrTerminal, this->m_cNrTerminal);
	return cNrTerminal;
}

char *CVenda::getDtProcVenda(char *cDtProcVenda)
{

	strcpy(cDtProcVenda, this-> m_dtProcVenda);
	return cDtProcVenda;

}

int CVenda::getNsuAutorizador()
{

	return this->m_nsuAutorizador;

}
	
void CVenda::setNsuAutorizador(int value)
{

	this->m_nsuAutorizador = value;

}

int CVenda::getCdAreaRegistro()
{
		return this->m_iCdAreaRegistro;
}
int CVenda::getNrLinha()
{
		return this->m_iNrLinha;
}

int CVenda::getInEstadoVenda()
{
	return this->m_iInEstadoVenda;
}

char *CVenda::getDsMsgErroVenda(char *cDsMsgErroVenda)
{
	strcpy(cDsMsgErroVenda, this->m_cDsMsgErroVenda);
	return cDsMsgErroVenda;
}

char *CVenda::getNrOrdem(char *cNrOrdem)
{
	strcpy(cNrOrdem, this->m_cNrOrdem);
	return cNrOrdem;
}

char* CVenda::getNsuHost()
{
	return this->m_cNsuHost;
}


// Setters
void CVenda::setIdVenda(int value)
{
	m_iIdVenda = value;
}

void CVenda::setDataInicial(char *value)
{
	strcpy(this->m_cDataInicial, value);
}

void CVenda::setDataFinal(char *value)
{
	strcpy(this->m_cDataFinal, value);
}

void CVenda::setDataVenda(char *value)
{
	strcpy(this->m_cDataVenda, value);
}

void CVenda::setBandeira(char *value)
{
	strcpy(this->m_cBandeira, value);
}

void CVenda::setNrNsu(char *value)
{
	strcpy(this->m_cNrNsu, value);
}

void CVenda::setNsuHost(char *value)
{
	strcpy(this->m_cNsuHost, value);
}



void CVenda::setNrCartao(char *value)
{
	strcpy(this->m_cNrCartao, value);
}

void CVenda::setValor(char *value)
{
	strcpy(this->m_cValor, value);
}

void CVenda::setNrSAP(char *value)
{
	strcpy(this->m_cNrSAP, value);
}

void CVenda::setIdTipo(int value)
{
	this->m_iIdTipo = value;
}

void CVenda::setTipo(char *value)
{
	strcpy(this->m_cTipo, value);
}

void CVenda::setSitefNumDoc(unsigned int value)
{
	this->m_iNumDoc = value;
}

void CVenda::setDsTipoServico(char *value)
{
	strcpy(this->m_cDsTipoServico, value);
}

void CVenda::setDsLoja(char *value)
{
	strcpy(this->m_cDsLoja, value);
}

void CVenda::setNrTerminal(char *value)
{
	strcpy(this->m_cNrTerminal, value);
}
void CVenda::setCdAreaRegistro(int value)
{
	this->m_iCdAreaRegistro = value;
}
void CVenda::setNrLinha(int value)
{
	this->m_iNrLinha = value;
}

void CVenda::setInEstadoVenda(int value)
{
	this->m_iInEstadoVenda = value;
}

void CVenda::setDsMsgErroVenda(char *value)
{
	if(strlen(value) >= sizeof(this->m_cDsMsgErroVenda))
	{
		strncpy(this->m_cDsMsgErroVenda, value, sizeof(this->m_cDsMsgErroVenda) - 1);
		this->m_cDsMsgErroVenda[sizeof(this->m_cDsMsgErroVenda) - 1] = '\0';
	}
	else
		strcpy(this->m_cDsMsgErroVenda, value);
}

void CVenda::setNrOrdem(char *value)
{
	strcpy(this->m_cNrOrdem, value);
}




void CVenda::setDtProcVenda(char *value)
{
	strcpy(this->m_dtProcVenda, value);

}


void CVenda::setNsuHostAutorizador(char* host){
	strcpy(this->m_nsuHostAutorizador,host);
}

char* CVenda::getNsuHostAutorizador(){
	return this->m_nsuHostAutorizador;
}

// Métodos de acesso a banco de dados
void CVenda::carregarSitefNumDoc()
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	unsigned int iSitefNumDoc;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL

		SELECT 
			vol.sitefnumdocsq.nextval
		INTO 
			:iSitefNumDoc
		FROM 
			dual;

	if(sqlca.sqlcode)
		throw TuxBasicOraException(sqlca.sqlcode);

	this->setSitefNumDoc(iSitefNumDoc);
	
	return;

	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CVenda::inserirDB()
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;
	int   iIdTerminal;
	int   iIdPessoaDePara;
	char  cDataVenda[32];
	char  cBandeira[16];
	char  cNrNsuCartao[7];
	char  cNrCartao[21];
	char  cVlCartao[32];
	char  cNrSAP[11];
	int   iIdTipoLinha;
	int	  iCdAreaRegistro;
	int	  iNrLinha;
	int   iInEstadoVenda;
	char  cDsMsgErroVenda[500];
	int	  iIdSitefVenda;
	char  cNrOrdem[21];
	EXEC SQL END DECLARE SECTION;

	iIdTerminal  = m_pPessoaAbstract->AsLojista()->getIdTerminal();
	iIdPessoaDePara = m_pPessoaAbstract->getIdPessoaDePara();

	this->getDataVenda(cDataVenda);
	this->getBandeira(cBandeira);
	this->getNrNsu(cNrNsuCartao);
	this->getNrCartao(cNrCartao);
	this->getValor(cVlCartao);
	this->getNrSAP(cNrSAP);
	this->getDsMsgErroVenda(cDsMsgErroVenda);
	this->getNrOrdem(cNrOrdem);

	iIdTipoLinha = this->getIdTipo();
	iCdAreaRegistro = this->getCdAreaRegistro();
	iNrLinha = this->getNrLinha();
	iInEstadoVenda = this->getInEstadoVenda();

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL 
		
		INSERT INTO
			vol.SiteFVenda
			(
				idSiteFVenda,
				idTerminal,
				idPessoaDePara,
				dtVenda,
				dsBandeiraCartao,
				nrNsuCARTAO,
				nrCartao,
				vlCartao,
				nrSAP,
				idTipoLinha,
				cdAreaRegistro,
				nrLinha,
				inEstadoVenda,
				dsMsgErroVenda,
				nrOrdem,
				idstatussitefvenda
			)
			VALUES
			(
				vol.SiteFVendaSQ.NextVal,
				:iIdTerminal,
				:iIdPessoaDePara,
//				TO_DATE(cDataVenda, 'yyyy-mm-dd hh24:mi:ss'),
				sysdate,
				:cBandeira,
				:cNrNsuCartao,
				:cNrCartao,
				TO_NUMBER(:cVlCartao, '9999999999999.00'),
				:cNrSAP,
				:iIdTipoLinha,
				:iCdAreaRegistro,
				:iNrLinha,
				:iInEstadoVenda,
				:cDsMsgErroVenda,
				:cNrOrdem,
				0
			)
			RETURNING
				idSiteFVenda
			INTO
				:iIdSitefVenda;

	if(sqlca.sqlcode)
		throw TuxBasicOraException(sqlca.sqlcode);


	this->setIdVenda(iIdSitefVenda);

    return;

	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);

}

void CVenda::registrarProcessoSitef(char*idSitefVenda,char*operacao)
{
	tuxfw_getlogger()->debug("CVenda::registrarProcessoSitef");
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidSitefVenda = idSitefVenda;
		char* coperacao = operacao;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
	EXEC SQL
		INSERT INTO VOL.PROCESSOSITEFVENDAOPERACAO
		(
		IDPROCESSOSITEFVENDAOPERACAO,
		IDSITEFVENDA,
		IDSITEFVENDAOPERACAO,
		DTOPERACAO)
		VALUES
		(
		VOL.PROCESSOSITEFVENDAOPERACAOSQ.NEXTVAL,
		:cidSitefVenda,
		:coperacao,
		SYSDATE);	

	if(sqlca.sqlcode)
	{
		tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	return;

sqlErrorConstrutor:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode); 
}

void CVenda::alterarStatusVenda(char*idSitefVenda,char*mensagemErro,char*idStatusVenda)
{
	tuxfw_getlogger()->debug("CVenda::alterarStatusVenda");
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;
		char* cidSitefVenda = idSitefVenda;
		char* cmensagemErro = mensagemErro;
		char* cidStatusVenda = idStatusVenda;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
	if(mensagemErro != NULL && !strcmp(mensagemErro," "))
	{
		EXEC SQL
			UPDATE VOL.SITEFVENDA
			SET IDSTATUSSITEFVENDA = :cidStatusVenda
			WHERE
			IDSITEFVENDA = :cidSitefVenda;
	}
	else
	{
		EXEC SQL
			UPDATE VOL.SITEFVENDA
			SET IDSTATUSSITEFVENDA = :cidStatusVenda,
			DSMSGERROVENDA = :cmensagemErro
			WHERE
			IDSITEFVENDA = :cidSitefVenda;
	}

	if(sqlca.sqlcode)
	{
		tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	return;

sqlErrorConstrutor:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode); 
}


void CVenda::alteraEstadoVendaDB()
{
	tuxfw_getlogger()->debug("CVenda::alteraEstadoVendaDB()");
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	
	char  cNrSAP[11]="";
	int	  iIdSitefVenda=0;
	int   iInEstadoVenda;
	char  cDsMsgErroVenda[500];

	char   cBandeira[16]="";
	char   cNsu[7]="";
	char   cNrcart[21]="";
	char   cValor[32]="";
	char   cNrOrdem[21]="";
	char   cDtProcVenda[30]="";
	int    iNsuAutorizador;
	char   *iNsuHostAutorizador = this->getNsuHostAutorizador();
	EXEC SQL END DECLARE SECTION;

	this->getNrSAP(cNrSAP);
	
	iInEstadoVenda = this->getInEstadoVenda();
	this->getDsMsgErroVenda(cDsMsgErroVenda);
	iIdSitefVenda = this->getIdVenda();

	this->getBandeira(cBandeira);
	this->getNrNsu(cNsu);
	this->getNrCartao(cNrcart);
	this->getValor(cValor);
	this->getNrOrdem(cNrOrdem);
	this->getDtProcVenda(cDtProcVenda);	
	iNsuAutorizador = this->getNsuAutorizador();

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	if (iIdSitefVenda == 0){
		EXEC SQL 
			UPDATE
				vol.SiteFVenda
			SET
				inEstadoVenda	= :iInEstadoVenda,
				dsMsgErroVenda	= :cDsMsgErroVenda,
				dsBandeiraCartao= DECODE(:cBandeira, '', dsBandeiraCartao, :cBandeira),
				nrNsuCartao		= DECODE(:cNsu, '', nrNsuCartao, :cNsu),
				nrCartao		= DECODE(:cNrcart, '', nrCartao, :cNrcart),
				vlCartao		= DECODE(:cValor, '', vlCartao, TO_NUMBER(:cValor, '9999999999999.00')),
				nrSAP			= :cNrSAP,
				nrOrdem			= :cNrOrdem,
				dtProcVenda		 = TO_DATE(:cDtProcVenda, 'dd/mm/yyyy hh24:mi:ss'),
				nrNsuAutorizador = :iNsuAutorizador,
				NSUHOST = :iNsuHostAutorizador

			WHERE
				nrSAP = :cNrSAP;
	}else{
		EXEC SQL 
			UPDATE
				vol.SiteFVenda
			SET
				inEstadoVenda  = :iInEstadoVenda,
				dsMsgErroVenda = :cDsMsgErroVenda,
				dsBandeiraCartao= DECODE(:cBandeira, '', dsBandeiraCartao, :cBandeira),
				nrNsuCartao		= DECODE(:cNsu, '', nrNsuCartao, :cNsu),
				nrCartao		= DECODE(:cNrcart, '', nrCartao, :cNrcart),
				vlCartao		= DECODE(:cValor, '', vlCartao, TO_NUMBER(:cValor, '9999999999999.00')),
				nrSAP			= :cNrSAP,
				nrOrdem			= :cNrOrdem,
				dtProcVenda		 = TO_DATE(:cDtProcVenda, 'dd/mm/yyyy hh24:mi:ss'),
				nrNsuAutorizador = :iNsuAutorizador,
				NSUHOST = :iNsuHostAutorizador
			WHERE
				idSitefVenda = :iIdSitefVenda;

	}
	
	//		nrSAP = :cNrSAP;
	
	if(sqlca.sqlcode)
		throw TuxBasicOraException(sqlca.sqlcode);

    return;

	sqlErrorConstrutor:
		tuxfw_getlogger()->debug("sqlca.sqlcode = %d",sqlca.sqlcode);
		throw TuxBasicOraException(sqlca.sqlcode);

}

void CVenda::carregarDadosFinanceiroDB(list<CVenda> &listaVendas, int idPessoaDePara, int idTipoLinha, int idTipoRecarga, int idUFOperadora, int idGrupoOperadora, int idStatusVenda, int iIdTerminal)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		char cDtInicial[10+1];
		char cDtFinal[10+1];
		int iIdTipoLinhaSQL=0;
		int iIdPessoaDeParaSQL=0;
		int iIdTipoRecargaSQL=0;
		int iIdUFOperadoraSQL=0;
		int iIdGrupoOperadoraSQL=0;
		int iInEstadoVendaSQL=0;
		int iIdTerminalSQL = 0;

		char cDtVenda[10+1];
		char cDsTipoServico[20];
		char cBandeira[16];
		char cDsLoja[256];
		char cVlCartao[32];
		double dDsTipoRecarga=0;

		char cNrTerminal[8+1];
		int  iCdAreaRegistro=0;
		int	 iNrLinha=0;
		int  iInEstadoVenda=0;
	EXEC SQL END DECLARE SECTION;

	CVenda oVenda;

	this->getDataInicial(cDtInicial);
	this->getDataFinal(cDtFinal);

	iIdTipoLinhaSQL = idTipoLinha < 0 ? 0 : idTipoLinha;
	iIdPessoaDeParaSQL = idPessoaDePara < 0 ? 0 : idPessoaDePara;
	iIdTipoRecargaSQL = idTipoRecarga < 0 ? 0 : idTipoRecarga;
	iIdUFOperadoraSQL = idUFOperadora < 0 ? 0 : idUFOperadora;
	iIdGrupoOperadoraSQL = idGrupoOperadora < 0 ? 0 : idGrupoOperadora;
	iIdTerminalSQL = iIdTerminal < 0 ? 0 : iIdTerminal;

	iInEstadoVendaSQL = idStatusVenda < -1 ? -1 : idStatusVenda;

	// garante que a lista esta vazia
	listaVendas.clear();

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL SELECT
			NVL(VLTIPORECARGA,0)
		INTO	
			:dDsTipoRecarga
		FROM
			apoio.tipoRecarga
		WHERE
			idTipoRecarga = :iIdTipoRecargaSQL;

    
	EXEC SQL DECLARE LSTFINANCEIRO CURSOR FOR

		SELECT 
			to_char(venda.DTVENDA,'dd/mm/yyyy'),
			DECODE(tipo.idTipoLinha,1,'PAGAMENTO DE CONTA','RECARGA') AS dsTipoServico,
			NVL(venda.DSBANDEIRACARTAO, ' '),			
			pessoa.nmPessoa,
			NVL(TO_CHAR(venda.vlCartao, '9999999999990.00'), ' '),
			NVL(terminal.nrTerminal, ' '),
			NVL(venda.cdAreaRegistro, 0 ),
			NVL(venda.nrLinha, 0 ),
			NVL(venda.inEstadoVenda, 0)
		FROM
			vol.SiteFVenda  		 venda,
			apoio.tipolinha    	 tipo,
			customer.pessoaDePara pdp,
			customer.Pessoa	  	 pessoa,
			vol.SitefTerminal	 terminal,
			customer.UFOperadora	 ufoperadora,
			customer.Operadora		 operadora 
		WHERE
			venda.idtipolinha 		 		  	= tipo.idtipolinha
		AND	venda.idPessoaDePara			  	= pdp.idPessoaDePara
		AND	pdp.IDPESSOA					  	= pessoa.idPessoa
		AND	venda.idTerminal				  	= terminal.idTerminal
		AND	terminal.idUFOperadora				= ufoperadora.idUFOperadora
		AND	ufoperadora.IDPESSOADEPARAOPERADORA = operadora.IDPESSOADEPARAOPERADORA
			
		AND (venda.idPessoaDePara				= :iIdPessoaDeParaSQL	OR :iIdPessoaDeParaSQL = 0)
		AND (venda.idTipoLinha					= :iIdTipoLinhaSQL		OR :iIdTipoLinhaSQL = 0)
		AND (venda.vlCartao						= :dDsTipoRecarga		OR :dDsTipoRecarga = 0)

		AND	(terminal.idUFOperadora				= :iIdUFOperadoraSQL	OR :iIdUFOperadoraSQL = 0)
		AND (terminal.idTerminal				= :iIdTerminalSQL		OR :iIdTerminalSQL = 0)
		AND (operadora.IDGRUPOOPERADORA			= :iIdGrupoOperadoraSQL	OR :iIdGrupoOperadoraSQL = 0)

		AND (venda.inEstadoVenda				= :iInEstadoVendaSQL OR :iInEstadoVendaSQL = -1)

		AND venda.dtVenda						>= TO_DATE(:cDtInicial  || ' 00:00:00', 'dd/mm/yyyy hh24:mi:ss') 
		AND venda.dtVenda						<= TO_DATE(:cDtFinal || ' 23:59:59', 'dd/mm/yyyy hh24:mi:ss') 
		ORDER BY	
			venda.DTVENDA,
			pessoa.nmPessoa;

	EXEC SQL WHENEVER NOT FOUND DO break;

	EXEC SQL OPEN LSTFINANCEIRO;


	for( ;; ) {
		// varre todos os registros para criar a lista com os Relacionamentos
		EXEC SQL FETCH LSTFINANCEIRO INTO 
			:cDtVenda,
			:cDsTipoServico,
			:cBandeira,
			:cDsLoja,
			:cVlCartao,
			:cNrTerminal,
			:iCdAreaRegistro,
			:iNrLinha,
			:iInEstadoVenda;


			oVenda.setDataVenda(cDtVenda);
			oVenda.setDsTipoServico(CUtil::trim(cDsTipoServico));
			oVenda.setBandeira(CUtil::trim(cBandeira));
			oVenda.setDsLoja(CUtil::trim(cDsLoja));
			oVenda.setValor(CUtil::trim(cVlCartao));

			oVenda.setNrTerminal(cNrTerminal);
			oVenda.setCdAreaRegistro(iCdAreaRegistro);
			oVenda.setNrLinha(iNrLinha);
			oVenda.setInEstadoVenda(iInEstadoVenda);

			listaVendas.push_back( oVenda );
		}

	EXEC SQL CLOSE LSTFINANCEIRO;

	return;

	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 

}

void CVenda::carregarDadosVendasDB(list<CVenda> &listaVendas)
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	
	int   iIdTerminal;
	int   iIdVenda;
	int   iIdPessoaDePara;
	char  cDataInicial[32];
	char  cDataFinal[32];
	char  cDataVenda[32];
	char  cBandeira[16];
	char  cNsuHost[17];
	char  cNrCartao[21];
	char  cVlCartao[32];
	char  cNrSAP[11];
	int   iIdTipo;
	char  cTipo[12];
	int   iInEstadoVenda;
	char  cNrOrdem[21];
	EXEC SQL END DECLARE SECTION;	

	CVenda	oVenda;

	// valores das chaves da consulta SQL
	iIdTerminal = m_pPessoaAbstract->AsLojista()->getIdTerminal();
	iIdPessoaDePara = m_pPessoaAbstract->getIdPessoaDePara();
	
	this->getDataInicial(cDataInicial);
	this->getDataFinal(cDataFinal);

	strcat(cDataInicial, " 00:00:00");
	strcat(cDataFinal, " 23:59:59");

	// garante que a lista esta vazia
	listaVendas.clear();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
	EXEC SQL DECLARE LSTVENDAS CURSOR FOR

		SELECT
			venda.idSiteFVenda,
			TO_CHAR(venda.dtVenda, 'yyyy-mm-dd hh24:mi:ss'),
			NVL(venda.dsBandeiraCartao, ' '),
			decode(tipo.idtipolinha,1,nvl(to_char(venda.NRNSUAUTORIZADOR),' '),5,nvl(to_char(venda.NRNSUAUTORIZADOR),' '),2,NVL(venda.NsuHost, ' '),6,NVL(venda.NsuHost, ' '),NVL(venda.NsuHost, ' ')) as nsuhost,
			NVL(venda.nrCartao, ' '),
			NVL(TO_CHAR(venda.vlCartao, '9999999999990.00'), ' '),
			NVL(venda.nrSAP, ' '),
			tipo.idTipoLinha,
			tipo.sgTipoLinha,
			NVL(inEstadoVenda, 0),
			NVL(nrOrdem, ' ' )
		FROM
			vol.SiteFVenda venda,
			apoio.tipolinha   tipo
		WHERE
			venda.idTerminal = :iIdTerminal
		AND
			venda.idtipolinha = tipo.idtipolinha
		--AND
		--	venda.inEstadoVenda = 0
		AND 
			dtVenda >= TO_DATE(:cDataInicial, 'yyyy-mm-dd hh24:mi:ss')
		AND
			dtVenda <= TO_DATE(:cDataFinal, 'yyyy-mm-dd hh24:mi:ss')
		ORDER BY dtVenda;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	EXEC SQL OPEN LSTVENDAS;

	for( ;; ) 
	{

		// varre todos os registros para criar a lista com os servicos

		EXEC SQL FETCH LSTVENDAS INTO
			iIdVenda,
			cDataVenda,
			cBandeira,
			cNsuHost,
			cNrCartao,
			cVlCartao,
			cNrSAP,
			iIdTipo,
			cTipo,
			iInEstadoVenda,
			cNrOrdem;

		oVenda.setIdVenda(iIdVenda);
		oVenda.setDataVenda(CUtil::trim(cDataVenda));
		oVenda.setBandeira(CUtil::trim(cBandeira));
		oVenda.setNsuHost(CUtil::trim(cNsuHost));
		oVenda.setNrCartao(CUtil::trim(cNrCartao));
		oVenda.setValor(CUtil::trim(cVlCartao));
		oVenda.setNrSAP(CUtil::trim(cNrSAP));
		oVenda.setIdTipo(iIdTipo);
		oVenda.setTipo(CUtil::trim(cTipo));
		oVenda.setInEstadoVenda(iInEstadoVenda);
		oVenda.setNrOrdem(cNrOrdem);

		listaVendas.push_back(oVenda);
	}

	EXEC SQL CLOSE LSTVENDAS;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode); 
	
}

