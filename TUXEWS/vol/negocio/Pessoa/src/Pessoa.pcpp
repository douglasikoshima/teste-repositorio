// Pessoa.cpp: implementation of the CPessoa class.
//
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw/tuxfw.h>
#include <Defines/Defines.h>
#include <Pessoa/Pessoa.hpp>
#include <Util/Util.hpp>
#include <cstring>

using namespace std;


EXEC SQL INCLUDE SQLCA;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPessoa::CPessoa()
{  	
	m_oEndereco = NULL;
	m_oRelac = NULL;
	m_oEmail = NULL;
    m_iIdPessoa = -1; 
	m_iIdPessoaLinha = -1;
	m_iIdUsuarioAlteracao = -1;
	m_iIdTipoRelacionamento = -1;
	m_iTipoComunicacao = -1;
	strcpy( this->m_cNmPessoa, "" );
	strcpy( this->m_cDsContato, "" );
	strcpy( this->m_cDtUltimaAlteracao, "" );
}


CPessoa::~CPessoa() {
	if(NULL != this->m_oEndereco){
       delete this->m_oEndereco;
    }
	if(NULL != this->m_oRelac){
		delete this->m_oRelac;
	}
	if(NULL != this->m_oEmail){
		delete this->m_oEmail;
	}
}

CPessoa* CPessoa::createInstance(){
       return new CPessoa();
}


/*

  GETs

*/

int CPessoa::getIdPessoa() {
	return this->m_iIdPessoa;
}

int CPessoa::getIdPessoaDePara() {
	return this->m_iIdPessoaDePara;
}

int CPessoa::getIdConta(){
	return this->m_iIdConta;
}

char * CPessoa::getIdLinhaSistemaOrigem(){
	return this->m_cIdLinhaSistemaOrigem;
}

char * CPessoa::getIdContaSistemaOrigem(){
	return this->m_cIdContaSistemaOrigem;
}


char * CPessoa::getNmPessoa() {
	return this->m_cNmPessoa;
}

char * CPessoa::getNomeUsuario() {
	return this->m_cNomeUsuario;
}

char * CPessoa::getNomeCliente() {
	return this->m_cNomeCliente;
}
char * CPessoa::getDsContato() {
	return this->m_cDsContato;
}

int CPessoa::getIdUsuarioAlteracao() {
	return this->m_iIdUsuarioAlteracao;
}

char * CPessoa::getDtUltimaAlteracao() {
	return this->m_cDtUltimaAlteracao;
}

CEndereco * CPessoa::getEndereco() {
	if(this->m_oEndereco == NULL)
		this->m_oEndereco = new CEndereco();
	return this->m_oEndereco;
}

CRelacionamento * CPessoa::getRel() {
	if(this->m_oRelac == NULL)
		this->m_oRelac = new CRelacionamento();
	return this->m_oRelac;
}

CEmail * CPessoa::getEmail(){
	if (this->m_oEmail == NULL)
		this->m_oEmail = new CEmail();
	return this->m_oEmail;
}


int CPessoa::getIdTipoRelacionamento(){
	return m_iIdTipoRelacionamento;
}


char* CPessoa::getSgTipoRelacionamento(){
	return m_cSgTipoRelacionamento;
}



char* CPessoa::getCpf(){
	return m_cCpf;
}

int CPessoa::getIdPessoaLinha(){
	return this->m_iIdPessoaLinha;
}

int CPessoa::getIdTipoPessoa(){
	return m_iIdTipoPessoa;
}

int CPessoa::getIdTipoCarteira(){
	return m_iIdTipoCarteira;
}

int CPessoa::getIdPessoaCliente(){
	return this->m_iIdPessoaCliente;
}

CSenha& CPessoa::getSenha()
{
	return this->m_oSenha;
}

int CPessoa::getTipoComunicacao()
{
	return m_iTipoComunicacao;
}

int CPessoa::getIdTipoCliente()
{
	return m_iIdTipoCliente;	
	
}

int CPessoa::getIdTipoUsuario ()
{
	return m_iIdTipoUsuario;
}



list <CEndereco> &CPessoa::getListaEnderecos()
{
	return this->listaEnderecos;
}
list <CEmail> &CPessoa::getListaEmails()
{
	return this->listaEmails;
}
/*
 
   SETs

*/

void CPessoa::setIdPessoa(int value) {
	this->m_iIdPessoa = value;
}

void CPessoa::setIdPessoaDePara(int value) {
	this->m_iIdPessoaDePara = value;
}

void CPessoa::setNmPessoa(char *value) {
	strcpy( this->m_cNmPessoa, value );
}

void CPessoa::setNomeUsuario(char *value) {
	strcpy( this->m_cNomeUsuario, value );
//	memcpy(this->m_cNomeUsuario, value, strlen(value));
}

void CPessoa::setIdConta(int value){
	this->m_iIdConta = value;
}

void CPessoa::setIdLinhaSistemaOrigem(char *value){
	strcpy(this->m_cIdLinhaSistemaOrigem, value);
}


void CPessoa::setIdContaSistemaOrigem(char *value){
	strcpy(this->m_cIdContaSistemaOrigem, value);
}


void CPessoa::setNomeCliente(char *value) {
	strcpy( this->m_cNomeCliente, value );
//	memcpy(this->m_cNomeCliente, value, strlen(value));
}
void CPessoa::setDsContato(char *value) {
	strcpy( this->m_cDsContato, value );
}


void CPessoa::setIdUsuarioAlteracao(int value) {
	this->m_iIdUsuarioAlteracao = value;
}

void CPessoa::setDtUltimaAlteracao(char *value) {
	strcpy( this->m_cDtUltimaAlteracao, value );
}

void CPessoa::setEndereco( const CEndereco & value ) {
	if( NULL != this->m_oEndereco )
		delete this->m_oEndereco;

	this->m_oEndereco = new CEndereco( value );
}

void CPessoa::setIdTipoRelacionamento(int value){
	this->m_iIdTipoRelacionamento = value ;

	 }
void CPessoa::setCpf(char *value){
		strcpy( this->m_cCpf, value );
}

void CPessoa::setSgTipoRelacionamento(char *value){
		strcpy( this->m_cSgTipoRelacionamento, value );
}

void CPessoa::setIdPessoaLinha(int value){
		this->m_iIdPessoaLinha = value;
}

void CPessoa::setIdTipoPessoa(int value){
	this->m_iIdTipoPessoa = value;
}

void CPessoa::setIdTipoCarteira(int value){
	this->m_iIdTipoCarteira = value;
}

void CPessoa::setIdPessoaCliente(int value){
	this->m_iIdPessoaCliente = value;

}

void CPessoa::setTipoComunicacao(int value)
{
	m_iTipoComunicacao = value;
}

void CPessoa::setIdTipoCliente(int value)
{
	m_iIdTipoCliente = value;
}

void CPessoa:: setIdTipoUsuario (int value)
{
	m_iIdTipoUsuario = value;
}

//Metodos de Negocio da Interface da Classe CPessoa:

void CPessoa::consultarNome() {
	 this->consultarNmPessoaDB();
}

void CPessoa::consultarNomeUsuario(int iArea, int iNro){
	this->consultarNomeUsuarioDB(iArea, iNro);
}

void CPessoa::consultarNomeCliente(int iArea, int iNro){
	this->consultarNomeClienteDB(iArea, iNro);
}

void CPessoa::consultarEMail(void) {
	 this->consultarDsContatoDB();
}

void CPessoa::alterarEMail(void) {
 	this->alterarDsContatoDB();
}

void CPessoa::inserirEMail(void) {
 	this->inserirDsContatoDB();
}

void CPessoa::obterDadosPessoaSessao(int area, int nro, char* senha){


	this->consultarDadosSessaoDB(area, nro, senha);
}

void CPessoa::obterIdPessoa(int codArea, int nroLinha){
	this->consultarIdPessoaDB(codArea, nroLinha);
}

void CPessoa::obterIdPessoaLinha(int cdAreaRegistro, int nrLinha)
{
	this->consultarIdPessoaLinhaDB(cdAreaRegistro, nrLinha);
}

//Metodos que acionanam CRelacionamento

void CPessoa::consultarHistQtdRelac(  list< CRelacionamento > & listaRelac,
												char * cQtRelac,
												char * cIdCanal){

	this->getRel()->setCanalPesquisa(cIdCanal);
	this->getRel()->setQtdRelac(atoi(cQtRelac));
	this->getRel()->consultarUltimosRelacionamentos( (this->getIdPessoa()) , listaRelac );
}

void CPessoa::consultarHistQtdRelacCanal(  list< CRelacionamento > & listaRelac,
 												int  iQtRelac,
 												int  iIdCanal){
 
 	this->getRel()->setIdCanal(iIdCanal);
 	this->getRel()->setQtdRelac(iQtRelac);
 	this->getRel()->consultarUltimosRelacionamentosCanal( (this->getIdPessoa()) , listaRelac );
}

void CPessoa::consultarHistRangeDate(	list< CRelacionamento > & listaRelac,  
												char * cDtInicio,
												char * cDtFinal,
												char * cIdCanal){

	this->getRel()->setDtRelacionamentoInicio(cDtInicio);
	this->getRel()->setDtRelacionamentoFinal(cDtFinal);
	if (cIdCanal != NULL) 
		this->getRel()->setCanalPesquisa(cIdCanal);
	this->getRel()->consultarRelacionamentosPeriodo( (this->getIdPessoa()) , listaRelac );
}
	
// Metodos que acionam a interface de m_oProcesso (CProcesso)

void CPessoa::consultarRangeDateProcessos(  list< CProcesso > & lstOProc,
 												char *  cDataInicio,
 												char * cDataFinal){
 
 	this->m_oProc.setDtProcessoFinal(cDataFinal);
 	this->m_oProc.setDtProcessoInicio(cDataInicio);
 	this->m_oProc.consultarRangeDateProcessos( this->getIdPessoa() , lstOProc );
}

void CPessoa::consultarUltimosProcessos( list< CProcesso > & listaOProc,  char * cQtProc ){

	this->m_oProc.setQtdProcessos( atoi(cQtProc) );
	this->m_oProc.consultarUltimosProcessos( (this->getIdPessoa()) , listaOProc );
}

// Metodos que acionam a interface de m_oSenha (CSenha)
/*
char* CPessoa::consultarLembreteFraseSecreta(void){

    // Delega para CSenha a Execução da Consulta.
    return this->m_oSenha.consultarLembreteFraseSecreta(this->m_iIdPessoaLinha);
};


char* CPessoa::consultarFraseSecreta(void){
    
    // Delega para CSenha a Execução da Consulta.
   return this->m_oSenha.consultarFraseSecreta(this->m_iIdPessoaLinha);
};



void CPessoa::inserirFraseSecreta(char * dsFraseSecreta, char * dsLembreteFraseSecreta){
	 // Delega para CSenha a Execução da Consulta.
  this->m_oSenha.setIdPessoa(this->getIdPessoa());
  this->m_oSenha.inserirFraseSecreta(this->getIdPessoaLinha(), dsFraseSecreta, dsLembreteFraseSecreta);
}
*/

char * CPessoa::getSenhaData( ){
	return this->m_oSenha.getDsLembreteSenha();
}

/*
void CPessoa::alterarFraseSecreta(char* dsFraseSecreta, char* dsLembreteFraseSecreta)
{
    
	// Delega para CSenha a Execução da Alteração.	
	this->m_oSenha.setDsFraseSecreta(dsFraseSecreta);
	this->m_oSenha.setDsLembreteFraseSecreta(dsLembreteFraseSecreta);
    this->m_oSenha.alterarFraseSecreta(this->getIdPessoa(), this->getIdPessoaLinha(), this->getIdTipoRelacionamento());
};          
*/

// Metodos que acionam a interface de m_oEndereco (CEndereco)

void CPessoa::alterarEndereco() {
	if( NULL == this->m_oEndereco )
		return; // deveria lancar uma excecao (na verdade, uma assertiva) ???

	this->m_oEndereco->alterarEndereco( this->m_iIdPessoa );
}

void CPessoa::inserirEndereco() {
	if( NULL == this->m_oEndereco )
		return; // deveria lancar uma excecao (na verdade, uma assertiva) ???

	this->m_oEndereco->inserirEndereco( this->m_iIdPessoa );
}

void CPessoa::consultarEnderecos() {

	this->consultarEnderecosDB();

	/*
	if( NULL == this->m_oEndereco )
		return; 

	this->m_oEndereco->consultarEndereco( this->m_iIdPessoa ); */
}

void CPessoa::consultarEnderecoCobranca() {
	if( NULL == this->m_oEndereco )
		return; 

	this->m_oEndereco->consultarEnderecoCobranca( this->m_iIdPessoa );
}

int CPessoa::getIdPessoaByCpf(void){
	return (this->getIdPessoaByCpfDB());

}

void CPessoa::consultarDispComunicacao()
{
	this->consultarDispComunicacaoDB();
}

void CPessoa::consultarEmails(){
	this->consultarEmailsDB();
}


// METODOS PRIVATE

// Métodos de acesso a banco de dados

int CPessoa::getIdPessoaByCpfDB(void){
	/*select
	  a.idPessoa, 
	  a.nmPessoa, 
	  c.cdCpfCnpjControle
	  from
	  customer.Pessoa a,
	  customer.PessoaDocumento b,
	  customer.Documento c
where a.idpessoa (+) = b.IDPESSOA and
b.IDDOCUMENTO = c.IDDOCUMENTO
and  a.NMPESSOA = 'Pessoa Desenvolvimento 11'
and c.CDCPFCNPJCONTROLE = '78'*/

	
    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	char cCpf[11+1];
	char cNmPessoa[256];
	int idPessoa;
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    strcpy(cCpf, this->getCpf());
	strcpy(cNmPessoa, this->getNomeCliente());

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL SELECT
		a.idPessoa
	INTO
		:idPessoa
	FROM
	  customer.Pessoa a,
	  customer.PessoaDocumento b,
	  customer.Documento c
	WHERE 
		a.idpessoa = b.IDPESSOA and
		b.IDDOCUMENTO = c.IDDOCUMENTO
		and  a.NMPESSOA = :cNmPessoa
		and c.NRDOCUMENTO = :cCpf
		and rownum = 1;
 
	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		return 0;
	}
 
    this->setIdPessoa(idPessoa);
    
	return 1;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
		return -1;
}
void CPessoa::consultarNmPessoaDB(void) {

    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	int  iIdPessoa;
	char cNmPessoa[256];
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iIdPessoa = this->getIdPessoa();

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL SELECT
		nmPessoa
	INTO
		:cNmPessoa
	FROM
		customer.Pessoa
	WHERE
		idPessoa = :iIdPessoa; 
 
	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw TuxBasicOraException(sqlca.sqlcode);
	}
 
    this->setNmPessoa(CUtil::trim(cNmPessoa));
    
	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}


void CPessoa::consultarNomeUsuarioDB(int area, int nro) {
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	char cNmPessoa[256];
	int iArea;
	int iNro;
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iArea = area;
	iNro = nro;

	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     /*select * from customer.pessoaLINHAB01 
	where   idtiporelacionamento = 2 and sgtiporelacionamento = 'U'
	and nrlinha = 12345678 and cdarearegistro = 11*/
	EXEC SQL 
	SELECT
			NVL(G.nmPessoa, ' ')
	INTO
			:cNmPessoa
	FROM
			LINHA.LINHATELEFONICA A,
			LINHA.LINHABASE B,
			APOIO.AREAREGISTRO B1,
			CUSTOMER.PESSOALINHA C, 
			CUSTOMER.PESSOADEPARA D,
			CUSTOMER.TIPORELACIONAMENTO E,
			CUSTOMER.PESSOA G
	WHERE 	A.IDLINHABASE             = B.IDLINHABASE AND
			B.IDAREAREGISTRO          = B1.IDAREAREGISTRO AND
			C.IDLINHATELEFONICA       = A.IDLINHATELEFONICA AND
			C.IDPESSOADEPARA          = D.IDPESSOADEPARA AND
			C.IDTIPORELACIONAMENTO    = E.IDTIPORELACIONAMENTO AND    
			D.idPessoa                = G.idPessoa AND			
			E.SGTIPORELACIONAMENTO	  ='U'		AND	
			B1.CdAreaRegistro		  = :iArea  AND
			B.NRLINHA				  = :iNro   AND
			C.idTipoRelacionamento    = 1;
	

 
	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw TuxBasicOraException(sqlca.sqlcode);
	}
 
    this->setNomeUsuario(CUtil::trim(cNmPessoa));
    
	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}


void CPessoa::consultarNomeClienteDB(int area, int nro) {

    struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	char cNmPessoa[256];
	int iArea;
	int iNro;
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iArea = area;
	iNro = nro;

	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     /*select * from customer.pessoaLINHAB01 
	where   idtiporelacionamento = 2 and sgtiporelacionamento = 'U'
	and nrlinha = 12345678 and cdarearegistro = 11*/
	EXEC SQL
	 	SELECT
			NVL(G.nmPessoa, ' ')
		INTO
			:cNmPessoa
		FROM
			LINHA.LINHATELEFONICA A,
			LINHA.LINHABASE B,
			APOIO.AREAREGISTRO B1,
			CUSTOMER.PESSOALINHA C, 
			CUSTOMER.PESSOADEPARA D,
			CUSTOMER.TIPORELACIONAMENTO E,
			CUSTOMER.PESSOA G
		WHERE 	
			A.IDLINHABASE             = B.IDLINHABASE AND
			B.IDAREAREGISTRO          = B1.IDAREAREGISTRO AND
			C.IDLINHATELEFONICA       = A.IDLINHATELEFONICA AND
			C.IDPESSOADEPARA          = D.IDPESSOADEPARA AND
			C.IDTIPORELACIONAMENTO    = E.IDTIPORELACIONAMENTO AND    
			D.idPessoa                = G.idPessoa AND			
			E.SGTIPORELACIONAMENTO	  = 'C'		   AND	
			B1.CdAreaRegistro		  = :iArea	   AND
			B.NRLINHA				  = :iNro      AND
			C.idTipoRelacionamento    =  2;
	
 
	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw TuxBasicOraException(sqlca.sqlcode);
	}
 
    this->setNomeCliente(CUtil::trim(cNmPessoa));
    
	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}


void CPessoa::consultarDsContatoDB(void) {

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	int  iIdPessoa;
	char cDsContato[256];
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iIdPessoa = this->getIdPessoa();
/*o rownum foi colocado devido haver mais de um registro na base
depois de garantida a integridade dos dados deve-se retirar
	*/
	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL
	SELECT
		 NVL(dsContato, ' ')
	INTO
		:cDsContato	
	FROM 	
		CUSTOMER.PESSOACOMUNICACAO a,
		APOIO.TIPOCOMUNICACAO	   b
		WHERE a.idPessoa	=:iIdPessoa AND
	  	a.idtipocomunicacao = b.idtipocomunicacao AND
		b.SGTIPOCOMUNICACAO = 'EM PART'
		AND dtExpiracao IS NULL
		AND ROWNUM = 1;

	// ID não existe. Seta o Contato para ""
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw TuxBasicOraException(sqlca.sqlcode);
	}
    
    this->setDsContato(CUtil::trim(cDsContato));

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}


void CPessoa::consultarIdPessoaDB(int codArea, int nroLinha){

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	int  iIdPessoa;
	int iCodArea;
	int iNroLinha;
	int iIdPessoaLinha;
	int iIdPessoaDePara;
	int iIdTipoRelacionamento;
 	EXEC SQL END DECLARE SECTION;

	iCodArea = codArea;
	iNroLinha = nroLinha;
	iIdTipoRelacionamento = this->getIdTipoRelacionamento();

	//REVER TODAS AS CHAMADAS PARA ESTE MÉTODO, DEVERÁ SEMPRE INVOCAR O getIdTipoRelacionamento(), antes não estava sendo setado este atribudo, por isto ainda possui a condição baixo!!.
	if (iIdTipoRelacionamento <= 0){
		iIdTipoRelacionamento = PESSOA_USUARIO;
	}
	//----------------------------------------------------------

    // Seta a Chave da Consulta:
	//iCodArea = codArea;
	//iNroLinha = nroLinha;
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL
		 SELECT
		  g.idPessoa, c.IDPESSOALINHA,d. idPessoaDePara	
		INTO
			:iIdPessoa, :iIdPessoaLinha, :iIdPessoaDePara
		FROM
			LINHA.LINHATELEFONICA A,
			LINHA.LINHABASE B,
			APOIO.AREAREGISTRO B1,
			CUSTOMER.PESSOALINHA C, 
			CUSTOMER.PESSOADEPARA D,
			CUSTOMER.TIPORELACIONAMENTO E,
			CUSTOMER.PESSOA G
		WHERE 	
			A.IDLINHABASE             = B.IDLINHABASE AND
			B.IDAREAREGISTRO          = B1.IDAREAREGISTRO AND
			C.IDLINHATELEFONICA       = A.IDLINHATELEFONICA AND
			C.IDPESSOADEPARA          = D.IDPESSOADEPARA AND
			C.IDTIPORELACIONAMENTO    = E.IDTIPORELACIONAMENTO AND    
			D.idPessoa                = G.idPessoa AND		
			B1.CdAreaRegistro		  =  :iCodArea 	   AND
			B.NRLINHA				  =  :iNroLinha     AND
			C.idTipoRelacionamento    =  :iIdTipoRelacionamento;
	
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		
		EXEC SQL
		SELECT
			  g.idPessoa, c.IDPESSOALINHA,d. idPessoaDePara	
		INTO
			:iIdPessoa, :iIdPessoaLinha, :iIdPessoaDePara
		FROM
			LINHA.LINHATELEFONICA A,
			LINHA.LINHABASE B,
			APOIO.AREAREGISTRO B1,
			CUSTOMER.PESSOALINHA C, 
			CUSTOMER.PESSOADEPARA D,
			CUSTOMER.TIPORELACIONAMENTO E,
			CUSTOMER.PESSOA G
		WHERE 	
			A.IDLINHABASE             = B.IDLINHABASE AND
			B.IDAREAREGISTRO          = B1.IDAREAREGISTRO AND
			C.IDLINHATELEFONICA       = A.IDLINHATELEFONICA AND
			C.IDPESSOADEPARA          = D.IDPESSOADEPARA AND
			C.IDTIPORELACIONAMENTO    = E.IDTIPORELACIONAMENTO AND    
			D.idPessoa                = G.idPessoa  AND		
			B1.CdAreaRegistro		  = :iCodArea   AND
			B.NRLINHA				  = :iNroLinha  AND
			E.sgtiporelacionamento    = 'C';
	
    }

	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw TuxBasicOraException(sqlca.sqlcode);
	}

	this->setIdPessoa(iIdPessoa);
	this->setIdPessoaLinha(iIdPessoaLinha);
	this->setIdPessoaDePara(iIdPessoaDePara);

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CPessoa::consultarIdPessoaLinhaDB(int cdAreaRegistro, int nrLinha)
{

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
 	int iIdPessoaLinha;
	int iCdAreaRegistro;
	int iNrLinha;
	int iIdTipoRelacionamento;
 	EXEC SQL END DECLARE SECTION;

	// Seta a Chave da Consulta
	iCdAreaRegistro = cdAreaRegistro;
	iNrLinha = nrLinha;
	iIdTipoRelacionamento = this->getIdTipoRelacionamento();
		
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL 
		
	SELECT
		idPessoaLinha
	INTO
		:iIdPessoaLinha
	FROM
			customer.PessoaLinha  PessoaLinha ,
			LINHA.LINHATELEFONICA LINHATELEFONICA ,
			LINHA.LINHABASE       LINHABASE ,
			APOIO.AREAREGISTRO    AREAREGISTRO
	WHERE
	                PessoaLinha.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
	           AND
	                LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
			   AND
			        LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
			   AND
			AREAREGISTRO.cdAreaRegistro		 = :iCdAreaRegistro 
		AND 
			LINHABASE.nrLinha				 = :iNrLinha 
		AND 
			PessoaLinha.idTipoRelacionamento = :iIdTipoRelacionamento;
			
			
	if(sqlca.sqlcode)
		throw TuxBasicOraException(sqlca.sqlcode);

	this->setIdPessoaLinha(iIdPessoaLinha);

	return;

	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);

}

void CPessoa::consultarDadosSessaoDB(int iArea, int iMobNro, char* senha){

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int iIdPessoa;
 	int  iIdTipoRelacionamento;
	int iCodArea;
	int iNroLinha;
	int iIdTpCart;
	int iIdConta;
	int iIdContaAnterior;
	int iIdTpPessoa;
	int idPessoaCliente;
	int iInPagadora;
	char cIdLinhaSistemaOrigem [255+1];
	char cIdContaSistemaOrigem [255+1];
	char cSgTipoRelacionamento[2];
	char cCdSenha[256];
	char cLembSenha[256];
 	EXEC SQL END DECLARE SECTION;

	memset(cIdLinhaSistemaOrigem,' ' , sizeof(cIdLinhaSistemaOrigem));
	memset(cIdContaSistemaOrigem,' ' , sizeof(cIdContaSistemaOrigem));
	memset(cLembSenha,' ' , sizeof(cLembSenha));
	iInPagadora = 0;

	iCodArea = iArea;
	iNroLinha = iMobNro;
	iIdTipoRelacionamento = this->getIdTipoRelacionamento();

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
	if(iIdTipoRelacionamento <= 0)
	{
		if(senha != NULL)
			strcpy(cCdSenha, senha);
		else
			strcpy(cCdSenha, "");

		// primeiro vamos tentar validar o cliente
		iIdTipoRelacionamento = PESSOA_CLIENTE;

		EXEC SQL 
			
			SELECT
				NVL(F.DSLEMBRETESENHA, ' ')
			INTO
				:cLembSenha
			FROM
				LINHA.LINHATELEFONICA A,
				LINHA.LINHABASE B,
				APOIO.AREAREGISTRO B1,
				CUSTOMER.PESSOALINHA C, 
				CUSTOMER.PESSOADEPARA D,
				CUSTOMER.TIPORELACIONAMENTO E,
				CUSTOMER.SENHA F,
				CUSTOMER.PESSOA G
			WHERE
				A.IDLINHABASE			= B.IDLINHABASE AND
				B.IDAREAREGISTRO		= B1.IDAREAREGISTRO AND
				C.IDLINHATELEFONICA		= A.IDLINHATELEFONICA AND
				C.IDPESSOADEPARA		= D.IDPESSOADEPARA AND
				C.IDTIPORELACIONAMENTO	= E.IDTIPORELACIONAMENTO AND    
				D.idPessoa				= F.idPessoa and
				D.idPessoa				= G.idPessoa AND
				B1.CdAreaRegistro		= :iCodArea AND
				B.NRLINHA				= :iNroLinha AND
				F.CdSenha				= :cCdSenha AND
				C.idTipoRelacionamento  = :iIdTipoRelacionamento AND
				D.idPessoa				= D.idPessoaOrigem AND
				rownum					= 1;

		if(sqlca.sqlcode == NO_DATA_FOUND)
		{ 
			// vamos tentar com o usuario
			iIdTipoRelacionamento = PESSOA_USUARIO;

			EXEC SQL 
				
				SELECT
					NVL(F.DSLEMBRETESENHA, ' ')
				INTO
					:cLembSenha
				FROM
					LINHA.LINHATELEFONICA A,
					LINHA.LINHABASE B,
					APOIO.AREAREGISTRO B1,
					CUSTOMER.PESSOALINHA C, 
					CUSTOMER.PESSOADEPARA D,
					CUSTOMER.TIPORELACIONAMENTO E,
					CUSTOMER.SENHA F,
					CUSTOMER.PESSOA G
				WHERE
					A.IDLINHABASE             = B.IDLINHABASE AND
					B.IDAREAREGISTRO          = B1.IDAREAREGISTRO AND
					C.IDLINHATELEFONICA       = A.IDLINHATELEFONICA AND
					C.IDPESSOADEPARA          = D.IDPESSOADEPARA AND
					C.IDTIPORELACIONAMENTO    = E.IDTIPORELACIONAMENTO AND    
					C.idPessoaLinha           = F.idPessoaLinha and
					D.idPessoa                = G.idPessoa AND				
					B1.CdAreaRegistro		  = :iCodArea AND
					B.NRLINHA				  = :iNroLinha AND
					F.CdSenha				  = :cCdSenha AND
					C.idTipoRelacionamento    = :iIdTipoRelacionamento AND
					D.idPessoa				  = D.idPessoaOrigem AND
					rownum					  = 1;
				
			if(sqlca.sqlcode)
			{
				throw TuxBasicOraException(sqlca.sqlcode);
			}

		}
		else if(sqlca.sqlcode)
		{
			throw TuxBasicOraException(sqlca.sqlcode);
		}
	}

	EXEC SQL SELECT
	    D.IDPESSOA, E.SGTIPORELACIONAMENTO, G.idTipoCarteira, G.idTipoPessoa
	INTO
		:iIdPessoa, :cSgTipoRelacionamento, :iIdTpCart, :iIdTpPessoa
	FROM
		LINHA.LINHATELEFONICA A,
		LINHA.LINHABASE B,
		APOIO.AREAREGISTRO B1,
		CUSTOMER.PESSOALINHA C, 
		CUSTOMER.PESSOADEPARA D,
		CUSTOMER.TIPORELACIONAMENTO E,
		CUSTOMER.PESSOA G
    WHERE
		A.IDLINHABASE			= B.IDLINHABASE AND
		B.IDAREAREGISTRO		= B1.IDAREAREGISTRO AND
		C.IDLINHATELEFONICA		= A.IDLINHATELEFONICA AND
		C.IDPESSOADEPARA		= D.IDPESSOADEPARA AND
		C.IDTIPORELACIONAMENTO	= E.IDTIPORELACIONAMENTO AND
		D.idPessoa				= G.idPessoa AND
		B1.CdAreaRegistro		= :iCodArea AND
		B.NRLINHA				= :iNroLinha AND
		C.idTipoRelacionamento  = :iIdTipoRelacionamento AND
		D.idPessoa				= D.idPessoaOrigem;

	if(sqlca.sqlcode)
	{ 
		throw TuxBasicOraException(sqlca.sqlcode);
	}


	//O idContaSistemaOrigem poderá vir a não ter, nesse caso as demais colunas devem retornar valor!.
	EXEC SQL 
		Select 
			   NVL(idContaSistemaOrigem, ' '),NVL(c.idlinhasistemaorigem,' '), NVL(d.idConta,0), NVL(e.INPAGADORA,0) AS INPAGADORA
		Into
			   :cIdContaSistemaOrigem, :cIdLinhaSistemaOrigem, :iIdConta,:iInPagadora
		From
			   apoio.AreaRegistro	a,
			   linha.LinhaBase		b,
			   linha.LinhaTelefonica c,
			   customer.LinhaConta	d,
			   customer.Conta		e
		Where	  
			   a.idAreaRegistro 		= b.idAreaRegistro
		And	   b.idLinhaBase			= c.idLinhaBase
		And	   c.idLinhaTelefonica		= d.idLinhaTelefonica
		And	   d.idConta				= e.idConta
		And	   a.cdAreaRegistro			= :iCodArea
		And	   b.nrLinha				= :iNroLinha
		And	   d.idTipoRelacionamento	= 2
		And	   rownum 					= 1;



	if (sqlca.sqlcode == NO_DATA_FOUND)
	{ 
		strcpy(cIdLinhaSistemaOrigem, " ");
		iIdConta = 0;
	}
	else
	{
		while(iInPagadora == 0)
		{
			memset(&cIdLinhaSistemaOrigem,0,sizeof(cIdLinhaSistemaOrigem));
			iInPagadora = 0;
			iIdContaAnterior = iIdConta;
			iIdConta = 0;
			EXEC SQL
			SELECT 
				NVL(CONTA.IDCONTA,0),
				NVL(CONTA.IDCONTASISTEMAORIGEM,' '),
				NVL(CONTA.INPAGADORA,0) AS INPAGADORA
			INTO	:iIdConta,:cIdContaSistemaOrigem,:iInPagadora
			FROM
				CUSTOMER.CONTA CONTA,
				CUSTOMER.CONTAHIERARQUIA CONTAHIERARQUIA
			WHERE
				CONTA.IDCONTA = CONTAHIERARQUIA.IDCONTAPAI
				AND CONTAHIERARQUIA.IDCONTA = :iIdContaAnterior;
			
			if(sqlca.sqlcode == NO_DATA_FOUND)
			{
				strcpy(cIdContaSistemaOrigem, " ");
				iIdConta = 0;
				break;
			}
		}
	}

	EXEC SQL 
	SELECT 
		p.idpessoa
	into
		:idPessoaCliente
	FROM
		linha.linhabase lb,
		linha.linhatelefonica lt,
		customer.pessoalinha pl,
		customer.pessoadepara pdp,
		customer.pessoa p,
		apoio.arearegistro a
	WHERE a.cdarearegistro =:iCodArea
		AND lb.nrlinha =	:iNroLinha
		AND pl.idtiporelacionamento = 2
		AND lb.idarearegistro = a.idarearegistro
		AND lb.idlinhabase = lt.idlinhabase
		AND pl.idlinhatelefonica = lt.idlinhatelefonica
		AND pdp.idpessoadepara = pl.idpessoadepara
		AND p.idpessoa = pdp.idpessoa;
	

	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		idPessoaCliente = 0;
	}

    this->setIdPessoa(iIdPessoa);
	this->setIdTipoRelacionamento(iIdTipoRelacionamento);
	this->setSgTipoRelacionamento(cSgTipoRelacionamento);
	this->m_oSenha.setDsLembreteSenha(CUtil::trim(cLembSenha));
	this->setIdLinhaSistemaOrigem(CUtil::trim(cIdLinhaSistemaOrigem));
	this->setIdContaSistemaOrigem(CUtil::trim(cIdContaSistemaOrigem));


	this->setIdTipoCarteira(iIdTpCart);
	this->setIdTipoPessoa(iIdTpPessoa);
	this->setIdConta(iIdConta);
	this->setIdPessoaCliente(idPessoaCliente);
	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}
void CPessoa::alterarDsContatoDB(void) {

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int  iIdPessoa;
	char cDsContato[ 256 ];
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iIdPessoa = this->getIdPessoa();
	strcpy(cDsContato , this->getDsContato());

	// verifica se ja tem e-mail cadastrado se nao tiver inseri
	try {
		this->consultarDsContatoDB();
	}
	catch ( ... ) {
		try {
			this->inserirEMail();
		}
		catch ( ... ) {
			throw TuxBasicOraException(1403);
		}
		return;
	}

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	EXEC SQL UPDATE
		customer.PessoaComunicacao
	SET
		dsContato = :cDsContato
		, dtUltimaAlteracao = SYSDATE
	WHERE
		idPessoa = :iIdPessoa
		AND idTipoComunicacao = 6
		AND dtExpiracao is NULL;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CPessoa::inserirDsContatoDB(void) {

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int  iIdPessoa;
	char cDsContato[ 256 ];
	char cDataAtual[ 19+1 ];
	char cDataExp[ 19+1 ];
	int  iIdUsuarioAlteracao;
	int iIdAux;
 	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iIdPessoa = this->getIdPessoa();
	strcpy(cDsContato , this->getDsContato());
	iIdUsuarioAlteracao = this->getIdUsuarioAlteracao();

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL SELECT customer.PessoaComunicacaoSQ.NEXTVAL INTO :iIdAux FROM DUAL;

	EXEC SQL SELECT 
				to_char(SYSDATE, 'dd/mm/YYYY hh24:mi:ss'), 
				to_char(add_months(SYSDATE, 24), 'dd/mm/YYYY hh24:mi:ss') 
				INTO: 
					cDataAtual, cDataExp 
				FROM DUAL;
     
	EXEC SQL INSERT INTO
		customer.PessoaComunicacao 
		(
		IDPESSOACOMUNICACAO, 
		IDPESSOA, 
		IDTIPOCOMUNICACAO, 
		NRSEQUENCIA, 
		DSCONTATO, 
		TSSINCRONISMO, 
		SQSINCRONISMO, 
		DTCADASTRO, 
		IDCOMUNICACAOSISTEMAORIGEM, 
		IDSISTEMAORIGEM, 
		INCOMUNICACAOPREFERENCIAL, 
		IDUSUARIOALTERACAO, 
		DTULTIMAALTERACAO )
		VALUES ( 
			:iIdAux,
			:iIdPessoa,
			'6',
			'0',
			:cDsContato,
			'0',
			'0',
			to_date( :cDataAtual , 'dd/mm/YYYY hh24:mi:ss'),
			'0',
			'9',
			'1',
			:iIdUsuarioAlteracao,
			to_date( :cDataAtual , 'dd/mm/YYYY hh24:mi:ss') );
	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);

}

void CPessoa::consultarDispComunicacaoDB()
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int  iIdPessoa;
	int  iEnvioSMS;
	int  iEnvioEmail;
	EXEC SQL END DECLARE SECTION;

	iIdPessoa = this->getIdPessoa();
	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL WHENEVER NOT FOUND GOTO sqlErrorConstrutor;

	if(this->getTipoComunicacao() == ID_TP_COM_SMS)
	{

		EXEC SQL 
			
			SELECT 
				NVL(inEnvioSMS, 0)
			INTO
				:iEnvioSMS
			FROM
				customer.pessoaComunicacao   a,
				apoio.TipoComunicacao        b,
				contatoADM.FormaRetorno      c  
			WHERE
			    a.idTipoComunicacao = b.idTipoComunicacao 
			AND
				b.idFormaRetorno = c.idFormaRetorno  
			AND
				b.sgTipoComunicacao   = 'CELULAR'   
			AND
				a.idPessoa = :iIdPessoa
			AND
				ROWNUM = 1;

		if(!iEnvioSMS)
			throw TuxBasicSvcException("11E0001","ENVIO POR SMS NAO CADASTRADO");
			
	}
	else
	{
		EXEC SQL 
			
			SELECT 
				NVL(inEnvioEMAIL, 0)
			INTO
				:iEnvioEmail
			FROm
				customer.pessoaComunicacao   a,
				apoio.TipoComunicacao        b, 
				contatoADM.FormaRetorno      c  
			WHERE
				a.idTipoComunicacao = b.idTipoComunicacao
			AND
				b.idFormaRetorno = c.idFormaRetorno  
			AND
				b.sgTipoComunicacao   = 'EM PART'
			AND
				a.idPessoa = :iIdPessoa
			AND
				ROWNUM = 1;

			if(!iEnvioEmail)
				throw TuxBasicSvcException("11E0001","ENVIO POR EMAIL NAO CADASTRADO");
	}

	return;
 
	sqlErrorConstrutor:	
		throw TuxBasicOraException(sqlca.sqlcode);

}

void CPessoa::consultarEnderecosDB()
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int  iIdPessoa;
	int  iIdPessoaEndereco;
	int  iIdTipoEndereco;
	char cDsTipoEndereco[256];
	int  iIdTipoEnderecoCobranca;
	char cNmTipoLogradouro[256];
	char cNmTituloLogradouro[256];
	char cNmLogradouro[256];
	char cNrEndereco[256];
	char cDsEnderecoComplemento[256];
	char cNmBairro[256];
	char cNrCep[256];
	char cNmMunicipio[256];
	int  iIdUf;
	int  iIdSistemaOrigemEndereco;
	int  iIdConta;
	int  iIdTipoConta;
	char cCdConta[101];
	int  iIdSistemaOrigemConta;
	int  iIdSistemaOrigemLinha;
	int  iNrLinha;
	int  iCdAreaRegistro;
	EXEC SQL END DECLARE SECTION;

	char        cLinha[12];
	char        cLinhaAnterior[12];
	
	CConta      oConta;
	CEndereco   oEndereco;

	bool bSQL_OK = false;
	int  iIdPessoaEndAnterior    = -1;
	int  iIdContaAnterior        = -1;

	memset(cLinhaAnterior, 0, sizeof(cLinhaAnterior));	
	
	iIdPessoa = this->getIdPessoa();
	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL DECLARE CONSULTARENDCONTALINHAV01 CURSOR FOR
	
	SELECT 
		*
	FROM 
	(
		SELECT
			idPessoaEndereco,
			idTipoEndereco,
			dsTipoEndereco,
			idTipoEnderecoCobranca,
			nmTipoLogradouro,
			nmTituloLogradouro,
			nmLogradouro,
			nrEndereco,
			dsEnderecoComplemento,
			nmBairro,
			nrCep,
			nmMunicipio,
			idUF,
			idSistemaOrigemEndereco,
			idConta,
			idTipoConta,
			cdConta,
			idSistemaOrigemConta,
			idSistemaOrigemLinha,
			nrLinha,
			cdAreaRegistro
		FROM 
			customer.consultarEndContaLinhaV01
		WHERE
			idPessoa = :iIdPessoa
		UNION
		SELECT
			idPessoaEndereco,
			idTipoEndereco,
			dsTipoEndereco,
			idTipoEnderecoCobranca,
			nmTipoLogradouro,
			nmTituloLogradouro,
			nmLogradouro,
			nrEndereco,
			dsEnderecoComplemento,
			nmBairro,
			nrCep,
			nmMunicipio,
			idUF,
			idSistemaOrigemEndereco,
			idConta,
			idTipoConta,
			cdConta,
			idSistemaOrigemConta,
			idSistemaOrigemLinha,
			nrLinha,
			cdAreaRegistro
		FROM 
			customer.consultarEndContaLinhaV02
		WHERE
			idPessoa = :iIdPessoa
	)
	ORDER BY
		idTipoEndereco, idTipoEnderecoCobranca, idPessoaEndereco;


	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	EXEC SQL OPEN CONSULTARENDCONTALINHAV01;

	for(;;) 
	{
		bSQL_OK = true;

		// varre todos os registros para criar a lista com os servicos
		EXEC SQL FETCH CONSULTARENDCONTALINHAV01 INTO
			:iIdPessoaEndereco,
			:iIdTipoEndereco,
			:cDsTipoEndereco,
			:iIdTipoEnderecoCobranca,
			:cNmTipoLogradouro,
			:cNmTituloLogradouro,
			:cNmLogradouro,
			:cNrEndereco, 
			:cDsEnderecoComplemento, 
			:cNmBairro, 
			:cNrCep, 
			:cNmMunicipio,
			:iIdUf,
			:iIdSistemaOrigemEndereco,
			:iIdConta,
			:iIdTipoConta,
			:cCdConta,
			:iIdSistemaOrigemConta,
			:iIdSistemaOrigemLinha,
			:iNrLinha,
			:iCdAreaRegistro;	

		sprintf(cLinha, "%0.2d%0.8d", iCdAreaRegistro, iNrLinha);
		CStr linha(cLinha);
 
		if(iIdContaAnterior != iIdConta)
		{
			if(iIdContaAnterior >= 0)
			{
				if(oConta.getIdConta() > 0)
					oEndereco.getListaContas().push_back(oConta);

				//apagando as listas existentes
				oConta.getListaLinhas().clear();
			}

			iIdContaAnterior = iIdConta;

			oConta.setIdConta(iIdConta);
			oConta.setIdTipoConta(iIdTipoConta);
			oConta.setIdSistemaOrigem(iIdSistemaOrigemConta);
			oConta.setIdTipoEnderecoCobranca(iIdTipoEnderecoCobranca);
			oConta.setCdConta(CUtil::trim(cCdConta));
						
		}

		if(!strcmp(cLinha, cLinhaAnterior) && 
			iIdPessoaEndAnterior == iIdPessoaEndereco &&
			strlen(cLinha) == 10 &&
			strlen(cLinhaAnterior) == 10)
			tuxfw_getlogger()->debug("CPessoa: linha %s com tipo cobrança repetido!", cLinha);
		else
			oConta.getListaLinhas().push_back(linha);
				
		strcpy(cLinhaAnterior, cLinha);

		if(iIdPessoaEndAnterior != iIdPessoaEndereco)
		{
			if(iIdPessoaEndAnterior >= 0)
			{
				this->getListaEnderecos().push_back(oEndereco);
			
				//apagando as listas existentes
				oEndereco.getListaContas().clear();
			}

			iIdPessoaEndAnterior = iIdPessoaEndereco;

			oEndereco.setIdPessoaEndereco(iIdPessoaEndAnterior);
			oEndereco.setIdSistemaOrigem(iIdSistemaOrigemEndereco);
			oEndereco.setIdTipoEndereco(iIdTipoEndereco);
			this->getEndereco()->incQuantTipo(iIdTipoEndereco);
			oEndereco.setDsTipoEndereco(CUtil::trim(cDsTipoEndereco));
			oEndereco.setIdTipoEnderecoCobranca(iIdTipoEnderecoCobranca);
			oEndereco.setNmTipoLogradouro(CUtil::trim(cNmTipoLogradouro));
			oEndereco.setNmTituloLogradouro(CUtil::trim(cNmTituloLogradouro));
			oEndereco.setNmLogradouro(CUtil::trim(cNmLogradouro));
			oEndereco.setNrEndereco(CUtil::trim(cNrEndereco));
			oEndereco.setDsEnderecoComplemento(CUtil::trim(cDsEnderecoComplemento));
			oEndereco.setNmBairro(CUtil::trim(cNmBairro));
			oEndereco.setNrCep(CUtil::trim(cNrCep));
			oEndereco.setNmMunicipio(CUtil::trim(cNmMunicipio));
			oEndereco.setIdUf(iIdUf);
			
		}

	}

	if(bSQL_OK)
	{
		if(oConta.getIdConta() > 0)
			oEndereco.getListaContas().push_back(oConta);

		this->getListaEnderecos().push_back(oEndereco);
	}

	EXEC SQL CLOSE CONSULTARENDCONTALINHAV01;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}


void CPessoa::consultarEmailsDB()
{
	
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int  iIdPessoaDB;

	int  iIdEmailDB;
	int  iIdTipoEmailDB;
	char cDsTipoEmailDB[256];
	char cDsEmailDB[256];
	char cSgClassificacaoEmail[256]="";
	EXEC SQL END DECLARE SECTION;

	strcpy(cSgClassificacaoEmail, SGCLASSIFICACAO_EMAIL);

	CEmail   oEmail;

	// garante que a lista esta vazia
	this->getListaEnderecos().clear();

	iIdPessoaDB = this->getIdPessoa();
	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL DECLARE CONSULTAREMAILS CURSOR FOR
		SELECT 
			   a.idPessoaComunicacao, a.idTipoComunicacao, b.dsTipoComunicacao, a.dsContato
		FROM 
			   customer.PessoaComunicacao a,
			   apoio.TipoComunicacao		 b
		WHERE
			   a.idTipoComunicacao = b.idTipoComunicacao
		AND	   b.sgClassificacao   = :cSgClassificacaoEmail
		AND	   a.idPessoa 		   = :iIdPessoaDB;

	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	EXEC SQL OPEN CONSULTAREMAILS;

	for(;;) 
	{

		// varre todos os registros para criar a lista com os servicos
		EXEC SQL FETCH CONSULTAREMAILS INTO
			:iIdEmailDB,
			:iIdTipoEmailDB,
			:cDsTipoEmailDB,
			:cDsEmailDB;
			
		oEmail.setIdEmail(iIdEmailDB);
		oEmail.setIdTipoEmail(iIdTipoEmailDB);
		oEmail.setDsTipoEmail(CUtil::trim(cDsTipoEmailDB));
		oEmail.setDsEmail(CUtil::trim(cDsEmailDB));

		this->getListaEmails().push_back(oEmail);			

	}

	EXEC SQL CLOSE CONSULTAREMAILS;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);

}
void CPessoa::consultaTbDocumento(char *chrCpf, int *intIdDocumento)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int  iIdPessoaSQL;
	char   chrCpfSQL[256];
	int	 iIdDocumentoSQL;
	EXEC SQL END DECLARE SECTION;

	strcpy(chrCpfSQL,"");
	iIdDocumentoSQL = -1;
	iIdPessoaSQL = this->getIdPessoa();

	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	EXEC SQL
	SELECT
		d.nrdocumento, 
		d.iddocumento
	INTO
		:chrCpfSQL,
		:iIdDocumentoSQL
	FROM
		customer.PessoaDocumento pd,
		customer.Documento d
	WHERE 
		pd.idpessoa = :iIdPessoaSQL and
		pd.IDDOCUMENTO = d.IDDOCUMENTO and
		d.idtipodocumento = 1;		
	
	strcpy(chrCpfSQL, CUtil::trim(chrCpfSQL));	
	strcpy(chrCpf, chrCpfSQL);			
	*intIdDocumento = iIdDocumentoSQL;

	return;

	OraNoDataFound:
	OraException:	
		throw TuxBasicOraException(sqlca.sqlcode);	

}

void CPessoa::consultarTipoPessoa(int nrLinha, int cdAreaRegistro, int intTipoRelacionamento)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int iTipoRelacionamento;
	int iCdAreaRegistro;
	int iNrLinha;
	int idTipoPessoa;
	EXEC SQL END DECLARE SECTION;

	idTipoPessoa = -1;
	iCdAreaRegistro = cdAreaRegistro;
	iNrLinha = nrLinha;
	iTipoRelacionamento = intTipoRelacionamento;


	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	EXEC SQL 
	SELECT
		 atp.IDTIPOPESSOA
	INTO 
		:idTipoPessoa
	FROM
			LINHA.LINHATELEFONICA LINHATELEFONICA ,
			LINHA.LINHABASE       LINHABASE ,
			APOIO.AREAREGISTRO    AREAREGISTRO ,
		apoio.EstadoLinha		b,
		customer.pessoalinha		cpl,
		customer.pessoadepara		pdp,
		customer.pessoa				cp,
		apoio.tipopessoa			atp
	WHERE
               CPL.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
          AND
               LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
	   AND
	        LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
	   AND
		LINHABASE.idEstadoLinha = b.idEstadoLinha
		AND	cdAreaRegistro = :iCdAreaRegistro
		AND nrLinha = :iNrLinha
		AND LINHATELEFONICA.IDLINHATELEFONICA = cpl.IDLINHATELEFONICA
		AND pdp.IDPESSOADEPARA = cpl.IDPESSOADEPARA
		AND pdp.IDPESSOA = cp.IDPESSOA
		AND cp.IDTIPOPESSOA = atp.idtipopessoa
		AND cpl.IDTIPORELACIONAMENTO = :iTipoRelacionamento;
		
		
	if (iTipoRelacionamento == 1)
		this->setIdTipoUsuario(idTipoPessoa);	
	else if (iTipoRelacionamento = 2)
		this->setIdTipoCliente(idTipoPessoa);
	
	return;
	OraNoDataFound:
	OraException:	
		throw TuxBasicOraException(sqlca.sqlcode);	

} 