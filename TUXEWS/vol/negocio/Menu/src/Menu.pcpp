#undef SQLCA
#define SQLCA_NONE


#include <Menu/Menu.hpp>
#include <Util/Util.hpp>
#include <Defines/Defines.h>


/*EXEC SQL INCLUDE SQLCA;*/

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CMenu::CMenu(){
	
	m_iIdItemMenu = -1;
	m_iIdItemMenuPai = -1;
	strcpy( this->cNmItem, "" );
	strcpy( this->cNmAction, "" );
	m_iIdContato = -1;

}


CMenu::~CMenu() {
}


int CMenu::getIdItemMenu(){
	return m_iIdItemMenu;
}
	
int	CMenu::getIdItemMenuPai() {
	return m_iIdItemMenuPai;
}
char *	CMenu::getNmItem(){
	return cNmItem;
}
char *	CMenu::getNmAction(){
	return cNmAction;
}
int	CMenu::getInPermitido() {
	return m_iInPermitido;
}
int	CMenu::getIdContato() {
	return m_iIdContato;
}

int CMenu::getIdCanal() {
	return m_iIdCanal;
}

int CMenu::getIdTipoLinha() {

	return m_iIdTipoLinha;
}

int CMenu::getIdGrupo(){

	return m_iIdTipoGrupo;
}

char * CMenu::getSgUF()
{
	return cSgUF;
}

int CMenu::getIdUF()
{
	return m_idUF;
}


char * CMenu::getNmItemPai()
{
	return cNmItemMenuPai;

}


char * CMenu::getDsTipoLinha()
{
	return cDsTipoLinha;
}


char * CMenu::getDsGrupo()
{
	return cDsGrupo;
}



int CMenu::getSqApresentacao()
{

	return this->m_iSqApresentacao;

}



void CMenu::setIdItemMenu(int idMenu){
	this->m_iIdItemMenu = idMenu;
}

void CMenu::setIdItemMenuPai(int idMenuPai){
	this->m_iIdItemMenuPai = idMenuPai;
}
void CMenu::setNmItem( char * NmItem){
	strcpy(this->cNmItem, NmItem);
}
void CMenu::setNmAction( char * NmAction){
	strcpy(this->cNmAction, NmAction);
}
void CMenu::setInPermitido(int inPermitido){
	this->m_iInPermitido = inPermitido;
}
void CMenu::setIdContato(int idContato){
	this->m_iIdContato = idContato;
}

void CMenu::setIdCanal(int iIdCanal){

	this->m_iIdCanal = iIdCanal;

}

void CMenu::setNmItemPai (char *cNmItemMenuPai)
{

	strcpy(this->cNmItemMenuPai, cNmItemMenuPai);

}


void CMenu::setIdTipoLinha( int iIdTipoLinha )
{
	m_iIdTipoLinha = iIdTipoLinha;

}


void CMenu::setIdGrupo ( int iIdGrupo )
{

	m_iIdTipoGrupo = iIdGrupo;
}

void CMenu::setSgUF(char *SgUF)
{
	strcpy(cSgUF, SgUF);

}

void CMenu::setIdUF(int iIdUF)
{
	m_idUF = iIdUF;
}

void CMenu::setDsTipoLinha (char *cDsTipoLinha)
{
	strcpy(this->cDsTipoLinha, cDsTipoLinha);

}

void CMenu::setDsGrupo(char *cDsGrupo)
{

	strcpy (this->cDsGrupo, cDsGrupo);
}

void CMenu::setSqApresentacao(int iSqApresentacao)
{

	this->m_iSqApresentacao = iSqApresentacao;

}



char *CMenu::itoa(int i,char *dest,int /*radix*/)
{
    sprintf(dest,"%d",i);
    return dest;
}




void CMenu::obterDadosMenu(int iCanal, int iCdAreaRegistro, int iNrLinha, int iIdTipoRelacionamento, list <CMenu> & lstMenu, bool blMenuRestrito, int iIdGrupo){
	this->obterDadosMenuDB(iCanal, iCdAreaRegistro, iNrLinha, iIdTipoRelacionamento, lstMenu, blMenuRestrito, iIdGrupo);
}



void CMenu::consultarMenu(list <CMenu> & lstFiltros, list <CMenu> & lstMenu)
{
	this->consultarMenuDB(lstFiltros, lstMenu);
}


void CMenu::consultarListagemMenu(int iNrPaginas, list <CMenu> & lstFiltros, list <CMenu> & lstMenu)
{
	this->consultarListagemMenuDB(iNrPaginas, lstFiltros, lstMenu);
}



int CMenu::alterarMenu(int iIdItemMenu, int iIdCanal, int iIdUF, int iIdTipoLinha, int iIdGrupo, int iAtivo,char*login,char*ip,char*nmItemMenu)
{
	int intRC = this->alterarMenuDB(iIdItemMenu, iIdCanal, iIdUF, iIdTipoLinha, iIdGrupo, iAtivo,login,ip,nmItemMenu);

	return intRC;
}


void CMenu::consultarUFDisp( list <CMenu> & lstMenu )
{

	this->consultarUFDispDB( lstMenu );

}

void CMenu::obterDadosMenuDB(int iCanal, int iCdAreaRegistro, int iNrLinha, int iIdTipoRelacionamento, list <CMenu> & lstMenu, bool blMenuRestrito, int iIdGrupo)
{

	struct sqlca sqlca;


	EXEC SQL BEGIN DECLARE SECTION;
		int  iIdItemMenu;
		int idItemMenuPai;
		int idCanal;
		char cNmItem  [ 255 ];
		char cNmAction [ 255 ];
		int iCdAreaRegistroSQL;
		int iNrLinhaSQL;
		int idTipoLinhaSQL;
		int idUFSQL;
		int iInPermitidoSQL;
		int iIdTipoRelacionamentoSQL;
		int iIdContato;
		char cSgUF[256];
		int iIdSistemaOrigem=0;
		int iIdGrupoSQL = 1;
		int iConfiguradorMenuAtivo = 0;
		char chrPesquisa[2000]="";
		char chrVariavel[10]="";
		int iIdGrupoConfigurador = 0;

	EXEC SQL END DECLARE SECTION;


	// valores das chaves da consulta SQL

	memset(&cNmItem,				' ', sizeof(cNmItem));
	memset(&cNmAction,					' ', sizeof(cNmAction));

    idCanal = iCanal;
	iCdAreaRegistroSQL = iCdAreaRegistro;
	iNrLinhaSQL = iNrLinha;
	iIdTipoRelacionamentoSQL = iIdTipoRelacionamento;
	iIdGrupoConfigurador = iIdGrupo;

	if (blMenuRestrito == true)
		iIdGrupoSQL = 2;

	// garante que a lista esta vazia
	lstMenu.clear();
	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;


	EXEC SQL SELECT
		A.idTipoLinha, D.idUF, A.idSistemaOrigem
	INTO:
		idTipoLinhaSQL ,idUFSQL ,iIdSistemaOrigem
	FROM
	  linha.LinhaTelefonica 	A,
	  linha.LinhaBase		B,
	  apoio.AreaRegistro		C,
	  customer.UfOperadora	D
	WHERE
		A.idLinhaBase			= B.idLinhaBase
	And	B.idAreaRegistro		= C.idAreaRegistro
	And	C.idUfOperadora			= D.idUfOperadora
	And	C.cdAreaRegistro		= :iCdAreaRegistroSQL
	And B.nrLinha				= :iNrLinhaSQL;

    
	
	EXEC SQL SELECT 
		TO_NUMBER(DSVALORPARAMETRO)
	INTO
		:iConfiguradorMenuAtivo 
	FROM
		APOIO.PARAMETRO
	WHERE 
		CDPARAMETRO = 'ConfiguradorMenu';




	if (iConfiguradorMenuAtivo){


		strcpy (chrPesquisa, 			
		"SELECT "
			  "A.IDITEMMENU,								"
			  "NVL(c.IDITEMMENUPAI, '0') AS IDITEMMENUPAI,  "
			  "NVL(B.nmItem, ' ') AS NMITEM ,				"
			  "NVL(D.dsURL, ' ') AS DSSHINT,				"
			  "DECODE (NVL(D.IDITEMMENU,0),0,0,1) AS inPermitido, "
			  "'0' AS IDCONTATO, "
			  "NVL(E.sgUF,' ') AS SGUF "
		"FROM	"
			"acesso.PermissaoItemMenu		A, "
			"acesso.ItemMenu 		   		B, "
			"acesso.ItemMenuHierarquia	C, "	
			"vol.ItemMenuCanal			D, "
			"APOIO.UF					E  "	  
		"WHERE "
			"A.IDITEMMENU		= B.IDITEMMENU		AND "
			"B.IDITEMMENU 		= C.IDITEMMENU (+)  AND "
			"B.IDITEMMENU 	    = D.IDITEMMENU	    AND "
			"A.IDCANAL			= ");

			itoa(idCanal, chrVariavel, 10);			
			strcat (chrPesquisa, chrVariavel);	

			strcat (chrPesquisa, " AND "
			" D.IDCANAL 			= ");
			strcat (chrPesquisa, chrVariavel);

			strcat (chrPesquisa, " AND "			
			" A.IDGRUPO 			= ");

			itoa(iIdGrupoConfigurador, chrVariavel, 10);			
			strcat (chrPesquisa, chrVariavel);	
			
			strcat (chrPesquisa, " AND "			
			" A.IDTIPOLINHA 		= ");

			itoa(idTipoLinhaSQL, chrVariavel, 10);			
			strcat (chrPesquisa, chrVariavel);	
			
			strcat (chrPesquisa,  " AND "		 
			" A.IDUF 		= ");
			
			itoa(idUFSQL, chrVariavel, 10);			
			strcat (chrPesquisa, chrVariavel);	
				
			strcat (chrPesquisa, " AND "
			"A.INATIVO			= 1	AND "
			"A.IDUF				= E.IDUF   "
		"ORDER BY "
			"B.sqApresentacao "
			" DESC ");
		
	}else{

		strcpy (chrPesquisa,
		"SELECT "
			  "b.IDITEMMENU,  "
			  "NVL(c.IDITEMMENUPAI, '0') AS IDITEMMENUPAI,  "
			  "NVL(B.nmItem, ' ') AS NMITEM , "
			  "NVL(A.dsURL, ' ') AS DSSHINT,  "
			  "DECODE (NVL(F.IDITEMMENU,0),0,0,1) AS inPermitido, "
			  "NVL(G.idContato, '0') AS IDCONTATO, "
			  "NVL(H.sgUF,' ') AS SGUF "
		"FROM	 "
			"vol.ItemMenuCanal 			 A, "
			"acesso.ItemMenu 		     B, "
			"acesso.ItemMenuHierarquia 	 C, "
			"vol.MenuTipoLinha		 	 D, "
			"vol.ItemMenuUF				 E, "
			"vol.itemMenuTPRelacionamento F, "
			"vol.ItemMenuContato			 G, "
			"apoio.UF					 H  "
		"WHERE "
			"A.iditemmenu				= B.IDITEMMENU		AND "
			"B.IDITEMMENU				= C.IDITEMMENU (+)	AND "
			"B.idItemMenu 				= D.idItemMenu		AND "
			"B.idItemMenu				= E.idItemMenu		AND "
			"B.idItemMenu				= F.idItemMenu (+)	AND "
			"B.idItemMenu				= G.idItemMenu (+)	AND "
			"E.idUF						= H.idUF	   		AND "
			"A.IDCANAL					= ");

			itoa(idCanal, chrVariavel, 10);			
			strcat (chrPesquisa, chrVariavel);	
			
			strcat (chrPesquisa, " AND "			
			" D.IDTIPOLINHA 		= ");

			itoa(idTipoLinhaSQL, chrVariavel, 10);			
			strcat (chrPesquisa, chrVariavel);	
			
			strcat (chrPesquisa, " AND "			
			" E.IDUF 		= ");
			
			itoa(idUFSQL, chrVariavel, 10);			
			strcat (chrPesquisa, chrVariavel);	

			strcat(chrPesquisa,	" AND "	
			" F.idTipoRelacionamento (+)	= ");
			
			itoa(iIdTipoRelacionamentoSQL, chrVariavel, 10);			
			strcat (chrPesquisa, chrVariavel);	

			strcat(chrPesquisa, " AND  "
			" B.IDITEMMENU			IN (SELECT IDITEMMENU FROM VOL.ITEMMENUGRUPO WHERE IDGRUPO = ");
			
			itoa(iIdGrupoSQL, chrVariavel, 10);			
			strcat (chrPesquisa, chrVariavel);	

			strcat(chrPesquisa, " ) "
			" ORDER BY "
				" B.sqApresentacao "
				" DESC ");
			
	}		



	tuxfw_getlogger()->debug("Pesquisa = %s\r\n", chrPesquisa);
	
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	EXEC SQL PREPARE qPesquisa FROM :chrPesquisa;

	EXEC SQL DECLARE LSTMENU CURSOR FOR qPesquisa;
	
	EXEC SQL OPEN LSTMENU;
	
	for( ;; ) {
		// varre todos os registros para criar a lista com os Relacionamentos

		EXEC SQL FETCH LSTMENU INTO
			:iIdItemMenu,
			:idItemMenuPai,
			:cNmItem,
			:cNmAction,
			:iInPermitidoSQL,
			:iIdContato,
			:cSgUF;
	
			this->setIdItemMenu( iIdItemMenu );
			this->setIdItemMenuPai( idItemMenuPai );
			this->setNmItem( CUtil::trim(cNmItem) );
			this->setNmAction( CUtil::trim(cNmAction) ); 
			this->setInPermitido( iInPermitidoSQL );
			this->setIdContato( iIdContato );

			memset(&cNmItem,				' ', sizeof(cNmItem));
			memset(&cNmAction,					' ', sizeof(cNmAction));			

			lstMenu.push_back( *this );
		
	}

	EXEC SQL CLOSE LSTMENU;

	return;

	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 

}


int CMenu::alterarMenuDB(int iIdItemMenu, int iIdCanal, int iIdUF, int iIdTipoLinha, int iIdGrupo, int iAtivo,char*login,char*ip,char*nmItemMenu)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		int iIdCanalSQL = 0;
		int iIdUFSQL = 0;
		int iIdTipoLinhaSQL = 0;
		int iIdItemMenuSQL = 0;
		int iIdGrupoSQL = 0;	
		int	 iAtivoSQL = 0;
		int iIdItemMenuPaiSQL = 0;
		short iIdItemPai = -1;
		char*clogin=login;
		char*cip=ip;
		char* cnmItemMenu = nmItemMenu;

		VARCHAR cIdCanalSQL[256];
		VARCHAR cIdUFSQL[256];
		VARCHAR cIdTipoLinhaSQL[256];
		VARCHAR cIdItemMenuSQL[256];
		VARCHAR cIdGrupoSQL[256];

	EXEC SQL END DECLARE SECTION;

	iIdCanalSQL = iIdCanal;	
	iIdUFSQL = iIdUF;
	iIdTipoLinhaSQL = iIdTipoLinha;
	iIdGrupoSQL = iIdGrupo;
	iAtivoSQL = iAtivo;
	iIdItemMenuSQL = iIdItemMenu;

	memset(&cIdCanalSQL,0,sizeof(cIdCanalSQL));
	memset(&cIdUFSQL,0,sizeof(cIdUFSQL));
	memset(&cIdTipoLinhaSQL,0,sizeof(cIdTipoLinhaSQL));
	memset(&cIdItemMenuSQL,0,sizeof(cIdItemMenuSQL));
	memset(&cIdGrupoSQL,0,sizeof(cIdGrupoSQL));


	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	
	EXEC SQL WHENEVER NOT FOUND CONTINUE;


	if ((iIdCanalSQL == 15) && (iAtivoSQL == 0)){

		EXEC SQL
		SELECT
			idItemMenuPai
		INTO
			:iIdItemMenuPaiSQL:iIdItemPai

		FROM
			acesso.itemmenuhierarquia
			WHERE iditemmenupai = :iIdItemMenuSQL
			AND ROWNUM = 1;

		if (iIdItemMenuPaiSQL != 0)
			return -1;  //nao pode alterar MenuPai no VOL

	}

	EXEC SQL WHENEVER NOT FOUND GOTO sqlErrorConstrutor;

	EXEC SQL 
	UPDATE
		ACESSO.PERMISSAOITEMMENU
	SET
		INATIVO = :iAtivoSQL
	WHERE
		IDITEMMENU  =  :iIdItemMenuSQL AND
		IDUF		=  :iIdUFSQL	   AND
		IDTIPOLINHA =  :iIdTipoLinhaSQL AND
		IDGRUPO		=  :iIdGrupoSQL AND	
		IDCANAL		=  :iIdCanalSQL;

	tuxfw_getlogger()->debug("preparar gravação de log");

	EXEC SQL
	SELECT NMCANAL INTO :cIdCanalSQL FROM APOIO.CANAL WHERE IDCANAL = :iIdCanalSQL;

	EXEC SQL
	SELECT NMITEM INTO :cIdItemMenuSQL FROM ACESSO.ITEMMENU WHERE IDITEMMENU = :iIdItemMenuSQL;

	EXEC SQL
	SELECT SGUF INTO :cIdUFSQL FROM APOIO.UF WHERE IDUF = :iIdUFSQL;

	EXEC SQL
	SELECT DSTIPOLINHA INTO :cIdTipoLinhaSQL FROM APOIO.TIPOLINHA WHERE IDTIPOLINHA = :iIdTipoLinhaSQL;

	EXEC SQL
	SELECT NMGRUPO INTO :cIdGrupoSQL FROM ACESSO.GRUPO WHERE IDGRUPO = :iIdGrupoSQL;

	tuxfw_getlogger()->debug("inserir log");
	
	EXEC SQL
	INSERT INTO VOL.MENUCANAISLOG
	(IDMENUCANAISLOG,LOGIN,IP,DTALTERACAO,DSCANAL,NMMENU,DSUF,DSTIPOLINHA,DSGRUPO,DSOPCAO,DSACAO)
	VALUES
	(VOL.MENUCANAISLOGSQ.NEXTVAL,:clogin,:cip,SYSDATE,
	 :cIdCanalSQL,
	 :cnmItemMenu,
	 :cIdUFSQL,
	 :cIdTipoLinhaSQL,
	 :cIdGrupoSQL,
	 :cIdItemMenuSQL,
	 :iAtivoSQL
	);

	return 0;

	sqlErrorConstrutor:		
		tuxfw_getlogger()->debug("erro alterar ou gravar log %d\r\n", sqlca.sqlcode);
		throw TuxBasicOraException(sqlca.sqlcode);	

}



void CMenu::MontaPesquisaLiteral(char *chrPesquisa, list <CMenu> & lstFiltros )
{


	int iIdItemMenuSQL = 0;
	int iIdCanalSQL = 0;
	int iIdTipoLinhaSQL = 0;
	int iIdGrupoSQL = 0;
	int iIdUFSQL = 0;
	char chrFiltroItemMenu[768] = "";
	char chrFiltroCanal[50] = "";
	char chrFiltroGrupo[50] = "";
	char chrFiltroTipoLinha[50] = "";	
	char chrFiltroUF[512] = "";
	char chrVariavel[10]="";
	
	CMenu oFiltros;

	while( 0 < lstFiltros.size() ) {
				
		oFiltros = lstFiltros.front();

		iIdItemMenuSQL = oFiltros.getIdItemMenu(); 
				
		if (iIdItemMenuSQL && strlen(chrFiltroItemMenu) == 0)						
			strcpy (chrFiltroItemMenu, " AND a.idItemMenu IN ( ");
					
							
		else if (iIdItemMenuSQL)
			strcat (chrFiltroItemMenu," ,");
				
		if (iIdItemMenuSQL){
				
			itoa(iIdItemMenuSQL, chrVariavel, 10);			
			strcat (chrFiltroItemMenu, chrVariavel);
		}

		iIdCanalSQL = oFiltros.getIdCanal(); 
				
		if (iIdCanalSQL && strlen(chrFiltroCanal) == 0)						
			strcpy (chrFiltroCanal, " AND a.idCanal IN ( ");
							
		else if (iIdCanalSQL)
			strcat (chrFiltroCanal," ,");
					
		if (iIdCanalSQL){

			itoa(iIdCanalSQL, chrVariavel, 10);
			strcat (chrFiltroCanal, chrVariavel);
		}
			
		iIdTipoLinhaSQL = oFiltros.getIdTipoLinha(); 
				
		if (iIdTipoLinhaSQL && strlen(chrFiltroTipoLinha) == 0)						
			strcpy (chrFiltroTipoLinha, " AND a.idTipoLinha IN ( ");					
							
		else if (iIdTipoLinhaSQL)
			strcat (chrFiltroTipoLinha," ,");
				
		if (iIdTipoLinhaSQL){
			itoa(iIdTipoLinhaSQL, chrVariavel, 10);
			strcat (chrFiltroTipoLinha, chrVariavel);
		}

			
		iIdUFSQL = oFiltros.getIdUF(); 
				
		if (iIdUFSQL  && strlen(chrFiltroUF) == 0)						
			strcpy (chrFiltroUF, " AND a.idUF IN ( ");

		else if (iIdUFSQL )
			strcat (chrFiltroUF," ,");
				
		if (iIdUFSQL){
			itoa(iIdUFSQL, chrVariavel, 10);
			strcat (chrFiltroUF, chrVariavel);
		}

		iIdGrupoSQL = oFiltros.getIdGrupo(); 
				
		if (iIdGrupoSQL  && strlen(chrFiltroGrupo) == 0)						
			strcpy (chrFiltroGrupo, " AND a.idGrupo IN ( ");

		else if (iIdGrupoSQL )
			strcat (chrFiltroGrupo," ,");
					
		if (iIdGrupoSQL){
			itoa(iIdGrupoSQL, chrVariavel, 10);
			strcat (chrFiltroGrupo, chrVariavel);
		}

		lstFiltros.pop_front();
		
	}			


	if (strlen(chrFiltroItemMenu) !=0){
		strcat (chrFiltroItemMenu, " ) ");			
		strcat (chrPesquisa, chrFiltroItemMenu);
	}

	if (strlen(chrFiltroCanal) !=0) {
		strcat (chrFiltroCanal, " ) ");			
		strcat (chrPesquisa, chrFiltroCanal);
	}

	if (strlen(chrFiltroGrupo) !=0){
		strcat (chrFiltroGrupo, " ) ");			
		strcat (chrPesquisa, chrFiltroGrupo);

	}
	if (strlen(chrFiltroTipoLinha) !=0){
		strcat (chrFiltroTipoLinha, " ) ");			
		strcat (chrPesquisa, chrFiltroTipoLinha);
	}
	
	if (strlen(chrFiltroUF) !=0){
		strcat (chrFiltroUF, " ) ");			
		strcat (chrPesquisa, chrFiltroUF);
	}


}

void CMenu::consultarMenuDB(list <CMenu> & lstFiltros, list <CMenu> & lstMenu)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		int iIdCanalSQL = 0;		
		int iIdCanal	= 0;
		int iIdTipoLinhaSQL = 0;		
		char cNmItem[256]="";
		int  iIdItemMenu = 0;
		char chrPesquisa[2000]="";
		char chrFiltroTipoLinha[50]="";
		char chrVariavel[10]="";

			
	EXEC SQL END DECLARE SECTION;


	int count = 0;
	CMenu oFiltros;
	lstMenu.clear();

	while( 0 < lstFiltros.size() ) {

		oFiltros = lstFiltros.front();

		iIdTipoLinhaSQL = oFiltros.getIdTipoLinha(); 
					
		if (iIdTipoLinhaSQL && strlen(chrFiltroTipoLinha) == 0)						
			strcpy (chrFiltroTipoLinha, " AND idTipoLinha IN ( ");					
							
		else if (iIdTipoLinhaSQL)
			strcat (chrFiltroTipoLinha," ,");
					
		if (iIdTipoLinhaSQL)
		{
			itoa(iIdTipoLinhaSQL, chrVariavel, 10);
			strcat (chrFiltroTipoLinha, chrVariavel);
		}

		iIdCanal = oFiltros.getIdCanal();
		
		if (count++ != 0)
		{		
			if (iIdCanal!= 0)
				iIdCanalSQL = 0; //todos
		}
		else
			iIdCanalSQL = iIdCanal;


		lstFiltros.pop_front();
	}

	if (strlen (chrFiltroTipoLinha) != 0 )
		strcat (chrFiltroTipoLinha, ") ");

	strcpy (chrPesquisa, 	
	"SELECT "
		" IDITEMMENU, "
		" TO_CHAR(NMITEM) || ' (VOL/TAV) ' AS NMITEM "
	"FROM(	 "
		"SELECT DISTINCT "
			"A.iditemmenu, " 
			"nmitem, "
			"idcanal "	   	   
		"FROM "
			"ACESSO.ITEMMENU A, "
			"ACESSO.PERMISSAOITEMMENU B "
		"WHERE  "
			"A.IDITEMMENU = B.IDITEMMENU ");
		
			strcat (chrPesquisa, chrFiltroTipoLinha);

		strcat (chrPesquisa, 				
		"GROUP BY "
			"IDCANAL, "
			"A.IDITEMMENU, "
		 	"NMITEM "
	")GROUP BY "
		"IDITEMMENU, "
		"NMITEM "
	"HAVING "
		"COUNT(IDITEMMENU) > 1	");
	

	if ((iIdCanalSQL == 15) || (iIdCanalSQL == 0)) //todos
	{
		
		strcat (chrPesquisa, 
		"UNION "
		"SELECT DISTINCT "
			"A.iditemmenu,  "
		   " TO_CHAR(nmitem) || ' (VOL) ' AS NMITEM "
		 "FROM "
 	 		  "ACESSO.ITEMMENU A, "
	 		  "ACESSO.PERMISSAOITEMMENU B "
		"WHERE  "
			"A.IDITEMMENU = B.IDITEMMENU AND "
			"B.IDCANAL =15 AND "
			"A.IDITEMMENU NOT IN (SELECT IDITEMMENU FROM VOL.ITEMMENUCANAL WHERE IDCANAL = 13) ");
			
			
			if (iIdTipoLinhaSQL )
				strcat (chrPesquisa, chrFiltroTipoLinha);

	}
	
	
	if ((iIdCanalSQL == 13) || (iIdCanalSQL == 0)) //todos
	{

		strcat (chrPesquisa, 
		"UNION "
		"SELECT DISTINCT "
			"A.iditemmenu,  "
		    "TO_CHAR(nmitem) || ' (TAV) ' AS NMITEM "
		 "FROM "
 	 		  "ACESSO.ITEMMENU A,		  "
	 		  "ACESSO.PERMISSAOITEMMENU B "
		"WHERE  "
			"A.IDITEMMENU = B.IDITEMMENU AND "
			"B.IDCANAL =13 AND "
			"A.IDITEMMENU NOT IN (SELECT IDITEMMENU FROM VOL.ITEMMENUCANAL WHERE IDCANAL = 15) ");
			
			
			if (iIdTipoLinhaSQL )
				strcat (chrPesquisa, chrFiltroTipoLinha);

	}
	
	strcat (chrPesquisa, 
	"ORDER BY "
		"NMITEM ");

	printf("Pesquisa = %s\r\n", chrPesquisa);

	tuxfw_getlogger()->debug("Pesquisa = %s\r\n", chrPesquisa);
	
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	EXEC SQL PREPARE qPesquisa FROM :chrPesquisa;

	EXEC SQL DECLARE LSTMENUDISP CURSOR FOR qPesquisa;

	
	EXEC SQL OPEN LSTMENUDISP;

	for( ;; ) {
		// varre todos os registros para criar a lista com os Relacionamentos

		EXEC SQL FETCH LSTMENUDISP INTO
			:iIdItemMenu,
			:cNmItem;

			this->setIdItemMenu( iIdItemMenu );
			this->setNmItem( CUtil::trim(cNmItem) );

				
			lstMenu.push_back( *this );

	}



	EXEC SQL CLOSE LSTMENUDISP;

	return;

	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 

}


int CMenu::consultarNrPaginas(list <CMenu> & lstFiltros)
{

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	
		int  iNrLinhas = 0;	
		int iNrPaginas = 0;
		char chrPesquisa [2000]="";
	
		
	EXEC SQL END DECLARE SECTION;



	strcpy(chrPesquisa,
	"SELECT "
		"COUNT(1) "				
	"FROM "
		"ACESSO.PERMISSAOITEMMENU A ");				

	 		 
	
	strcat (chrPesquisa, " WHERE iduf NOT IN (0) ");


	MontaPesquisaLiteral(chrPesquisa, lstFiltros);

	tuxfw_getlogger()->debug("Pesquisa = %s\r\n", chrPesquisa);

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	EXEC SQL PREPARE qPesquisa FROM :chrPesquisa;

	EXEC SQL DECLARE NRLINHAS CURSOR FOR qPesquisa;

	EXEC SQL OPEN NRLINHAS;


	for( ;; ) {

		// varre todos os registros para criar a lista com os Relacionamentos
		EXEC SQL FETCH NRLINHAS INTO 
			:iNrLinhas;

	}
	EXEC SQL CLOSE  NRLINHAS;


	iNrPaginas = iNrLinhas /100;

	if (iNrLinhas % 100 != 0)
		iNrPaginas += 1;

	
	return  iNrPaginas;

	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 

}

void CMenu::consultarListagemMenuDB(int iNrPaginas,list <CMenu> & lstFiltros, list <CMenu> & lstMenu)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
		
		int iIdItemMenuSQL = 0;
		int iIdCanalSQL = 0;
		char cSgUF[256] = "";
		int iIdTipoLinhaSQL = 0;
		int iIdGrupoSQL = 0;
		char cNmItem[256]="";	
		int  iInicioRange  = 0;
		int  iNrLinhas = 0;	
		char cNmItemPai[256]="";
		char chrPesquisa [2000]="";
		int  iInAtivo;
		char chrVariavel[10]="";
		int iIdUFSQL = 0;
		char cDsTipoLinha[30]="";		
		char chrFiltroItemMenu[256] = "";
		char chrFiltroCanal[50] = "";
		char chrFiltroGrupo[50] = "";
		char chrFiltroTipoLinha[50] = "";	
		char chrFiltroUF[70] = "";
		char cDsTipoRelacionamentoPessoa[255] = "";
	
		
	EXEC SQL END DECLARE SECTION;


	CMenu oFiltros;	


	iNrLinhas = iNrPaginas*100;

	iInicioRange = iNrLinhas - 100;
	
	lstMenu.clear();

	strcpy (chrPesquisa, 	
	"SELECT "
	 	"idcanal,    " 
		"nmitempai,  " 
		"sguf,		 "
		"iduf,		 "
		"idtipolinha,"
		"DSTIPOLINHA,"  
		"idgrupo,	 "
		"iditemmenu, "
		"nmitem,	 "		
		"inativo,    "
		"dsrelacionamentopessoa "
	"FROM ("
		"SELECT "
	 			"idcanal,    " 
				"nmitempai,  " 
				"sguf,		 "
				"iduf,		 "
				"idtipolinha,"
				"DSTIPOLINHA,"  
				"idgrupo,	 "
				"iditemmenu, "
				"nmitem,	 "
				"inativo,    "
				"dsrelacionamentopessoa, "
				"ROWNUM AS LINHA "
		"FROM(	"
			"SELECT "
				"A.idcanal, "
				"DECODE(C.nmitempai,'', NMITEM, c.nmitempai) as nmitempai, "
				"A.IDUF, " 
				"d.sguf, "
				"A.idtipolinha, "
				"E.DSTIPOLINHA, "
				"A.idgrupo, "
				"A.iditemmenu, "
				"DECODE (c.nmitempai, '', ' ', B.nmitem) AS nmitem, "
				"A.INATIVO, "
				"F.DSRELACIONAMENTOPESSOA "			
			"FROM "
				"ACESSO.PERMISSAOITEMMENU A, "
				"acesso.itemmenu B, "
				"(SELECT  DISTINCT menuhierarquia.iditemmenu AS IDITEMMENU,  itemmenu.nmitem  AS NMITEMPAI FROM	acesso.itemmenuhierarquia menuhierarquia,  acesso.itemmenu itemmenu	WHERE  itemmenu.iditemmenu  = menuhierarquia.iditemmenupai AND itemmenu.idsubsistema = 508)C, "
				"APOIO.UF D ,"
				"APOIO.TIPOLINHA E, "
				"APOIO.TIPORELACIONAMENTOPESSOA F "
			"WHERE "
		 		 "A.IDITEMMENU  = B.IDITEMMENU    AND "
				 "B.IDITEMMENU  = C.IDITEMMENU(+) AND "
				 "A.IDUF	    = D.IDUF	AND		  "
				 "A.IDTIPOLINHA = E.IDTIPOLINHA AND   "
				 "A.IDGRUPO     = F.IDTIPORELACIONAMENTOPESSOA "); 
				 
			MontaPesquisaLiteral(chrPesquisa, lstFiltros);
	

		strcat (chrPesquisa, " ORDER BY IDCANAL, NMITEMPAI, IDUF, IDTIPOLINHA, IDGRUPO, NMITEM )");


		strcat (chrPesquisa, " WHERE ");
		strcat (chrPesquisa, " ROWNUM <= ");
		itoa(iNrLinhas, chrVariavel, 10);
		strcat(chrPesquisa, chrVariavel);

	strcat (chrPesquisa, ") WHERE LINHA > ");
	itoa(iInicioRange  , chrVariavel, 10);
	strcat (chrPesquisa, chrVariavel);


	
	tuxfw_getlogger()->debug("Pesquisa = %s\r\n", chrPesquisa);

	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	
	EXEC SQL PREPARE qPesquisa FROM :chrPesquisa;

	EXEC SQL DECLARE LSTMENUTOTAL CURSOR FOR qPesquisa;

	EXEC SQL OPEN LSTMENUTOTAL;


	for( ;; ) {

		// varre todos os registros para criar a lista com os Relacionamentos
		EXEC SQL FETCH LSTMENUTOTAL INTO 			 				 							
			:iIdCanalSQL,
			:cNmItemPai,
			:cSgUF,
			:iIdUFSQL,
			:iIdTipoLinhaSQL,
			:cDsTipoLinha,
			:iIdGrupoSQL, 
			:iIdItemMenuSQL, 
			:cNmItem, 
			:iInAtivo,
			:cDsTipoRelacionamentoPessoa;
		

			this->setIdCanal (iIdCanalSQL);
			this->setNmItemPai ( CUtil::trim(cNmItemPai));
			this->setSgUF (CUtil::trim(cSgUF));
			this->setIdUF (iIdUFSQL);
			this->setIdTipoLinha (iIdTipoLinhaSQL);
			this->setDsTipoLinha (CUtil::trim(cDsTipoLinha));
			this->setIdGrupo (iIdGrupoSQL);
			this->setIdItemMenu( iIdItemMenuSQL );								
			this->setNmItem( CUtil::trim(cNmItem) );		 
			this->setInPermitido( iInAtivo );
			this->setDsGrupo( CUtil::trim(cDsTipoRelacionamentoPessoa) );				
			lstMenu.push_back( *this );

	}


	EXEC SQL CLOSE  LSTMENUTOTAL;

	return;

	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 


}


void CMenu::consultarUFDispDB( list <CMenu> & lstMenu )
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	char cSGUF[256]="";
	int  iIdUF = 0;
 	EXEC SQL END DECLARE SECTION;
	
	CMenu	oMenu;
	
	// valores das chaves da consulta SQL
   
	// garante que a lista esta vazia
	lstMenu.clear();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
	EXEC SQL DECLARE LSTSGUF CURSOR FOR

	SELECT 
		 IDUF, 
		 SGUF 
	FROM		
		APOIO.UF
	WHERE 
		IDUF BETWEEN 1 AND 30
	ORDER BY IDUF;			  
			
	EXEC SQL WHENEVER NOT FOUND DO break;
	
	EXEC SQL OPEN LSTSGUF;

	for( ;; ) 
	{
		// varre todos os registros para criar a lista com as linhas		
		EXEC SQL FETCH  LSTSGUF INTO
			:iIdUF,
			:cSGUF;	
		
		oMenu.setIdUF( iIdUF ); 		
		oMenu.setSgUF( CUtil::trim(cSGUF) );
		
		lstMenu.push_back( oMenu );
	}


	EXEC SQL CLOSE LSTSGUF;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 


}


void CMenu::consultarTipoLinhaDisp(list <CMenu> &lstMenu)
{

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	char cDsTipoLinha[256]="";
	int  iIdTipoLinha = 0;
 	EXEC SQL END DECLARE SECTION;
	
	CMenu	oMenu;
	
	// valores das chaves da consulta SQL
   
	// garante que a lista esta vazia
	lstMenu.clear();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
	EXEC SQL DECLARE LSTTIPOLINHA CURSOR FOR
	
	SELECT 
		 A.IDTIPOLINHA,
		 A.DSTIPOLINHA
	FROM		
		APOIO.TIPOLINHA A
	WHERE 
		SGTIPOLINHA <> 'NC'
	ORDER BY 
		IDTIPOLINHA;		  
			
	EXEC SQL WHENEVER NOT FOUND DO break;
	
	EXEC SQL OPEN LSTTIPOLINHA;

	for( ;; ) 
	{
		// varre todos os registros para criar a lista com as linhas		
		EXEC SQL FETCH  LSTTIPOLINHA INTO
			:iIdTipoLinha,
			:cDsTipoLinha;	
		
		oMenu.setIdTipoLinha( iIdTipoLinha ); 		
		oMenu.setDsTipoLinha( CUtil::trim(cDsTipoLinha) );
		
		lstMenu.push_back( oMenu );
	}


	EXEC SQL CLOSE  LSTTIPOLINHA;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 



}


void CMenu::consultarTipoRelacionamentoPessoa(list <CMenu> &lstMenu)
{

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	char cDsTipoRelacionamentoPessoa[256]="";
	int  iIdTipoRelacionamentoPessoa = 0;
 	EXEC SQL END DECLARE SECTION;
	
	CMenu	oMenu;

	lstMenu.clear();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
	EXEC SQL DECLARE LSTTIPORELACPESSOA CURSOR FOR
	
	SELECT 
	   IDTIPORELACIONAMENTOPESSOA,
	   DSRELACIONAMENTOPESSOA
	FROM 
		APOIO.TIPORELACIONAMENTOPESSOA;
	

	EXEC SQL WHENEVER NOT FOUND DO break;
	
	EXEC SQL OPEN LSTTIPORELACPESSOA;
	
	for( ;; ) 
	{
		// varre todos os registros para criar a lista com as linhas		
		EXEC SQL FETCH   LSTTIPORELACPESSOA INTO
			:iIdTipoRelacionamentoPessoa,
			:cDsTipoRelacionamentoPessoa;	
		
		oMenu.setIdGrupo( iIdTipoRelacionamentoPessoa ); 		
		oMenu.setDsGrupo( CUtil::trim(cDsTipoRelacionamentoPessoa) );
		
		lstMenu.push_back( oMenu );
	}


	EXEC SQL CLOSE  LSTTIPORELACPESSOA;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 

}

void CMenu::consultarIdGrupo (int iIdPessoa, int iNrLinha, int iCdAreaRegistro)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	
	int iIdTipoRelacionamento;
	int iCdAreaRegistroSQL = 0;
	int iNrLinhaSQL = 0;
	int iIdPessoaSQL = 0;
	
	EXEC SQL END DECLARE SECTION;


	iCdAreaRegistroSQL = iCdAreaRegistro;
	iNrLinhaSQL = iNrLinha;
	iIdPessoaSQL =  iIdPessoa;

	EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

	EXEC SQL WHENEVER SQLERROR GOTO OraException;

	EXEC SQL

	SELECT 
		PESSOALINHA.IDTIPORELACIONAMENTO
	INTO
		:iIdTipoRelacionamento
	FROM
		LINHA.LINHABASE LINHABASE,
		LINHA.LINHATELEFONICA LINHATELEFONICA,
		APOIO.AREAREGISTRO AREAREGISTRO,
		CUSTOMER.PESSOALINHA PESSOALINHA,
		CUSTOMER.PESSOADEPARA PESSOADEPARA
	WHERE
		LINHABASE.NRLINHA = :iNrLinhaSQL AND
		LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO AND
		AREAREGISTRO.CDAREAREGISTRO = :iCdAreaRegistroSQL AND
		LINHABASE.IDLINHABASE = LINHATELEFONICA.IDLINHABASE AND
		LINHATELEFONICA.IDLINHATELEFONICA = PESSOALINHA.IDLINHATELEFONICA AND
		PESSOALINHA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA AND
		PESSOADEPARA.IDPESSOA = :iIdPessoaSQL AND
		PESSOALINHA.IDTIPORELACIONAMENTO = 1;


	this->setIdGrupo(1); //usuario
	return;

	OraNoDataFound:	
		this->setIdGrupo(2); //nao achou usuario --- é cliente
		return;

	OraException:
		throw TuxBasicOraException(sqlca.sqlcode);								


}


void CMenu::consultarMenuPai (int iIdCanal, list <CMenu> &lstMenu)
{

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int iIdItemMenuPaiSQL;
	char cNmItemSQL[256] ="";
	int  iIdCanalSQL = 0;
	int  iSqApresentacaoSQL = 0;

 	EXEC SQL END DECLARE SECTION;
	
	CMenu	oMenu;
	iIdCanalSQL = iIdCanal;

	lstMenu.clear();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
	EXEC SQL DECLARE LSTMENUPAI CURSOR FOR
	SELECT 
		DISTINCT
		ITEMMENU.IDITEMMENU,
		NMITEM,
		SQAPRESENTACAO		
	FROM 
		ACESSO.ITEMMENU ITEMMENU,
		ACESSO.ITEMMENUHIERARQUIA ITEMMENUHIERARQUIA,
		VOL.ITEMMENUCANAL ITEMMENUCANAL		
	WHERE
		ITEMMENU.IDITEMMENU = ITEMMENUHIERARQUIA.IDITEMMENUPAI(+) AND
		ITEMMENU.IDITEMMENU = ITEMMENUCANAL.IDITEMMENU AND
		ITEMMENU.IDSUBSISTEMA =  508			       AND
		ITEMMENUCANAL.IDCANAL = :iIdCanalSQL	AND
		ITEMMENU.IDITEMMENU NOT IN (SELECT IDITEMMENU FROM ACESSO.ITEMMENUHIERARQUIA) 
	ORDER BY SQAPRESENTACAO
	DESC;
	

	EXEC SQL WHENEVER NOT FOUND DO break;
	
	EXEC SQL OPEN  LSTMENUPAI;
	
	for( ;; ) 
	{
		// varre todos os registros para criar a lista com as linhas		
		EXEC SQL FETCH  LSTMENUPAI INTO
			:iIdItemMenuPaiSQL,	
			:cNmItemSQL,
			:iSqApresentacaoSQL;
		
		
		oMenu.setIdItemMenuPai(iIdItemMenuPaiSQL);
		oMenu.setNmItemPai( CUtil::trim(cNmItemSQL) );
		oMenu.setSqApresentacao(iSqApresentacaoSQL);
		
		lstMenu.push_back( oMenu );
	}


	EXEC SQL CLOSE  LSTMENUPAI;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 

}





void CMenu::consultarMenuFilho (int iIdItemMenuPai, int iIdCanal, list <CMenu> &lstMenu)
{

	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int iIdItemMenuPaiSQL = 0;
	char cNmItemSQL[256] ="";
	int iIdItemMenuSQL =  0;
	int iSqApresentacaoSQL = 0;
	int iIdCanalSQL = 0;
	

 	EXEC SQL END DECLARE SECTION;

	iIdItemMenuPaiSQL = iIdItemMenuPai;
	iIdCanalSQL = iIdCanal;
	CMenu	oMenu;

	lstMenu.clear();

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
	EXEC SQL DECLARE LSTMENUFILHO CURSOR FOR
	
	SELECT  DISTINCT
		ITEMMENU.IDITEMMENU,
		NMITEM,
		DECODE(SQAPRESENTACAO, NULL, 0, SQAPRESENTACAO) AS SQAPRESENTACAO					
	FROM 
		ACESSO.ITEMMENU ITEMMENU,
		ACESSO.ITEMMENUHIERARQUIA ITEMMENUHIERARQUIA,
		VOL.ITEMMENUCANAL ITEMMENUCANAL		
	WHERE
		ITEMMENU.IDITEMMENU = ITEMMENUHIERARQUIA.IDITEMMENU AND
		ITEMMENUHIERARQUIA.IDITEMMENUPAI = :iIdItemMenuPaiSQL AND		
		ITEMMENU.IDITEMMENU = ITEMMENUCANAL.IDITEMMENU AND
		ITEMMENU.IDSUBSISTEMA = 508   AND
		ITEMMENUCANAL.IDCANAL = :iIdCanalSQL
	ORDER BY
		SQAPRESENTACAO
	DESC; 
	

	EXEC SQL WHENEVER NOT FOUND DO break;
	
	EXEC SQL OPEN  LSTMENUFILHO;
	
	for( ;; ) 
	{
		// varre todos os registros para criar a lista com as linhas		
		EXEC SQL FETCH  LSTMENUFILHO INTO
			:iIdItemMenuSQL,	
			:cNmItemSQL,
			:iSqApresentacaoSQL;
		
		
		oMenu.setIdItemMenu( iIdItemMenuSQL );
		oMenu.setNmItem( CUtil::trim(cNmItemSQL) );
		oMenu.setSqApresentacao( iSqApresentacaoSQL );
		
		lstMenu.push_back( oMenu );
	}


	EXEC SQL CLOSE  LSTMENUFILHO;

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 

}


void  CMenu::alterarOrdemMenu(int iIdItemMenu, int iSqApresentacao)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;

	int iIdItemMenuSQL =  0;
	int iSqApresentacaoSQL = 0;


 	EXEC SQL END DECLARE SECTION;

	iIdItemMenuSQL = iIdItemMenu;
	iSqApresentacaoSQL  = iSqApresentacao;

	// marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL WHENEVER NOT FOUND CONTINUE;

    
	EXEC SQL 
	
	UPDATE
		ACESSO.ITEMMENU
	SET
		SQAPRESENTACAO = :iSqApresentacaoSQL
	WHERE
		IDITEMMENU = :iIdItemMenuSQL;

	

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException( sqlca.sqlcode ); 


}