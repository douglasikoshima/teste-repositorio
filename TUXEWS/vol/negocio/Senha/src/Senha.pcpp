// Senha.cpp: implementation of the CSenha class.
//
//////////////////////////////////////////////////////////////////////

#undef SQLCA
#define SQLCA_NONE

#include <sqlca.h>
#include <tuxfw/tuxfw.h>
#include <Defines/Defines.h>
//#include "../Defines/include/Defines/Defines.h"
#include <Util/Util.hpp>
#include <PessoaAbstract/PessoaAbstract.hpp>
#include <Lojista/Lojista.hpp>
#include <Senha/Senha.hpp>


EXEC SQL INCLUDE SQLCA;


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSenha::CSenha()
{
    // Inicializacao da Instancia
	m_pPessoaAbstract = NULL;

	this->setIdSenha(-1);
	this->setIdTipoSenha(-1);
	this->setSenha("");
	this->setDsFraseSecreta("");
	this->setDsLembreteFraseSecreta("");
	this->setDsLembreteSenha("");
	this->setQtTentFraseSecreta(-1);
	this->setStatusFraseSecreta(FRASE_SECRETA_BLOQUEADA);
	this->setCdSenha("");
	this->setNmNomeCompleto(" ");
	this->setDtNascimento(" ");
	this->setSgSexo(" ");
	this->setNmPessoa(" ");
	this->setEmail(" ");
	
}

CSenha::CSenha(CPessoaAbstract *p)
{
	CSenha();

	if(p != NULL)
		m_pPessoaAbstract = p;
}

CSenha::~CSenha()
{
}


//Interface da Classe CSenha:

// Operações da classe

void CSenha::consultarLembreteFraseSecreta(int idPessoa, int idPessoaLinha, int idTipoRelacionamento)
{	 
	// Executa a Query no DB
	this->carregarDadosSenhaDB(idPessoa, idPessoaLinha, idTipoRelacionamento);
}

void CSenha::excluirFraseSecreta(int idPessoa, int idPessoaLinha, int idTipoRelacionamento, int idCanal, int idPessoaUsuario) 
{    	
	this->excluirFraseSecretaDB(idPessoa, idPessoaLinha, idTipoRelacionamento, idCanal, idPessoaUsuario);
}

void CSenha::alterarQtTentFraseSecreta(int idPessoa, int idPessoaLinha, int idTipoRelacionamento)
{
	this->alterarQtTentFraseSecretaDB(idPessoa, idPessoaLinha, idTipoRelacionamento);
}

void CSenha::bloquearFraseSecreta(int idPessoa, int idPessoaLinha, int idTipoRelacionamento, int idCanal, int idPessoaUsuario, int inRegistrarHistorico)
{
	this->bloquearFraseSecretaDB(idPessoa, idPessoaLinha, idTipoRelacionamento, idCanal, idPessoaUsuario, inRegistrarHistorico);
}

void CSenha::validarSenha()
{
	if(NULL == m_pPessoaAbstract)
	{
		//versões anteriores
		throw TuxBasicSvcException("11E0001","USAR NOVO CONTRUTOR DE CSENHA");
	}
	else
	{
		if(CPessoaAbstract::TP_LOJISTA == m_pPessoaAbstract->getTipoPessoa())
		{
			this->validarSenhaLojistaDB();
		}
		else
		{
			throw TuxBasicSvcException("11E0002","IMPOSSIVEL DETERMINAR TIPO PESSOA");
		}
	}
}

void CSenha::alterarSenha()
{
	if(NULL == m_pPessoaAbstract)
	{
		//versões anteriores
		throw TuxBasicSvcException("11E0001","USAR NOVO CONTRUTOR DE CSENHA");
	}
	else
	{
		if(CPessoaAbstract::TP_LOJISTA == m_pPessoaAbstract->getTipoPessoa())
		{
			this->alterarSenhaLojistaDB();
		}
		else
		{
			throw TuxBasicSvcException("11E0002","IMPOSSIVEL DETERMINAR TIPO PESSOA");
		}
	}
}

void CSenha::alterarFraseSecreta(int idPessoa, 
								 int idPessoaLinha, 
								 int idTipoRelacionamento,
								 int idCanal,
								 int idPessoaUsuario)
{
    // Executa a Query no DB
    this->alterarDadosSenhaDB(idPessoa, 
		                      idPessoaLinha, 
							  idTipoRelacionamento,
							  idCanal,
							  idPessoaUsuario);

}

void CSenha::registrarPrimeiroAcesso(int idCanal, int idPessoaUsuario, int idPessoaLinha, int iIdTerminal){
	CSenha::registrarPrimeiroAcessoDB(idCanal, idPessoaUsuario, idPessoaLinha, iIdTerminal);
}

/*
void CSenha::inserirFraseSecreta(int idPessoaLinha, char* dsFraseSecreta, char* dsLembreteFraseSecreta){
 // Verifica de o idPessoa é Valido
	 if(idPessoaLinha != -1){

	    // Armazena a Chave da Alteracao:
	    this->setIdPessoaLinha(idPessoaLinha);

	    // Armazena os demais dados		
		this->setDsFraseSecreta(dsFraseSecreta);
        this->setDsLembreteFraseSecreta(dsLembreteFraseSecreta);

        // Executa a Query no DB
        this->inserirDadosSenhaDB();

	 }
	 else{
	      throw TuxBasicSvcException("20E0001","CSenha Valor de idPessoa INVALIDO");
	 }
}
*/

/*
  GETs
*/

int CSenha::getIdSenha()
{
	return this->m_iIdSenha;
}

int CSenha::getIdTipoSenha()
{
	return this->m_iIdTipoSenha;
}

char* CSenha::getSenha()
{
	return m_cSenha;
}

char * CSenha::getDsFraseSecreta()
{
	return m_cDsFraseSecreta;
}

char * CSenha::getDsLembreteFraseSecreta()
{
	return m_cDsLembreteFraseSecreta;
}

char * CSenha::getDsLembreteSenha()
{
	return m_cDsLembreteSenha;
}

char * CSenha::getNmPessoa()
{
	return m_nmPessoa;
}

int CSenha::getIdTipoLinha()
{
	return m_idTipoLinha;
}



int CSenha::getQtTentFraseSecreta()
{
	return m_iQtTentFraseSecreta;
}

int CSenha::getStatusFraseSecreta()
{
	return m_StatusFraseSecreta;
}

char *CSenha::getCdSenha()
{
	return m_cdSenha;
}

/*
   SETs
 */

void CSenha::setIdSenha(int value)
{
	this->m_iIdSenha = value;
}

void CSenha::setIdTipoSenha(int value)
{
	this->m_iIdTipoSenha = value;
}

void CSenha::setDsFraseSecreta(char *value)
{
	strcpy(m_cDsFraseSecreta,value); 
	//CUtil::upper(m_cDsFraseSecreta);
}

void CSenha::setDsLembreteFraseSecreta(char *value)
{
    strcpy(m_cDsLembreteFraseSecreta,value); 
}

void CSenha::setDsLembreteSenha(char *value)
{
    strcpy(m_cDsLembreteSenha,value); 
}

void CSenha::setSenha(char *value)
{
    strcpy(m_cSenha,value); 
	//CUtil::upper(m_cSenha);
}

void CSenha::setCdSenha(char *value)
{
    strcpy(m_cdSenha,value); 
}

void CSenha::setNmPessoa(char *value)
{
    strcpy(m_nmPessoa,value); 
}


void CSenha::setQtTentFraseSecreta(int value)
{
	m_iQtTentFraseSecreta = value;
}

void CSenha::setStatusFraseSecreta(int value)
{
	m_StatusFraseSecreta = value;
}

void CSenha::setIdTipoLinha(int value)
{
	m_idTipoLinha = value;
}

// PRIVATE


// Métodos de acesso a banco de dados

// Carrega nos atributos da instancia da classe senha
// o registro com dados da Senha da Pessoa em questão (Id)
void CSenha::carregarDadosSenhaDB(int idPessoa, int idPessoaLinha, int idTipoRelacionamento)
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	
	int  iIdPessoa;
	int  iIdPessoaLinha;
	int  iIdSenha;
	int  iIdTipoSenha;
	int  iIdTipoRelacionamento;
	char cDsLembreteFraseSecreta[256];
	char cDsFraseSecreta[256];
	char cDsLembreteSenha[256];
	char cCdSenha[256];
	int  iQtTentFraseSecreta;
	int  iIdStatusFraseSecreta;
	EXEC SQL END DECLARE SECTION;

    // Seta a Chave da Consulta:
    iIdPessoa = idPessoa;
	iIdPessoaLinha = idPessoaLinha;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	if (idPessoaLinha <= 0 && idTipoRelacionamento <= 0) 
	{
		// estamos trabalhando com usuario
		idTipoRelacionamento = PESSOA_USUARIO;

		iIdTipoRelacionamento = idTipoRelacionamento;

		EXEC SQL

			SELECT
				   a.idPessoaLinha
			INTO
				   :iIdPessoaLinha
			FROM
				   customer.PessoaLinha	a,
				   customer.PessoaDePara b
			WHERE
				   a.idPessoaDePara 		 = b.idPessoaDePara
			AND	   b.idPessoa 				 = :iIdPessoa
			AND	   a.idTipoRelacionamento	 = :iIdTipoRelacionamento
			AND    Rownum 					 = 1;
	}
    
	if(idTipoRelacionamento == PESSOA_USUARIO)
	{
		EXEC SQL 

			SELECT
				idSenha,
				idTipoSenha,
				NVL(dsLembreteFraseSecreta, ' ') as dsLembreteFraseSecreta,
				NVL(dsFraseSecreta, ' ') as dsFraseSecreta,
				NVL(dsLembreteSenha, ' ') as dsLembreteSenha,
				NVL(QtTentativaFraseSecreta, '0') as QtTentativaFraseSecreta,
				NVL(idStatusSenhaFraseSecreta, 0 ) as idStatusSenhaFraseSecreta,
				NVL(cdsenha,' ') as cdsenha
			INTO
				:iIdSenha,
				:iIdTipoSenha,
				:cDsLembreteFraseSecreta, 
				:cDsFraseSecreta, 
				:cDsLembreteSenha,
				:iQtTentFraseSecreta,
				:iIdStatusFraseSecreta,
				:cCdSenha
			FROM
				customer.Senha
			WHERE
				idPessoaLinha = :iIdPessoaLinha; 
	}
	else
	{
		EXEC SQL 

			SELECT
				idSenha,
				idTipoSenha,
				NVL(dsLembreteFraseSecreta, ' ') as dsLembreteFraseSecreta,
				NVL(dsFraseSecreta, ' ') as dsFraseSecreta,
				NVL(dsLembreteSenha, ' ') as dsLembreteSenha,
				NVL(QtTentativaFraseSecreta, '0') as QtTentativaFraseSecreta,
				NVL(idStatusSenhaFraseSecreta, 0 ) as idStatusSenhaFraseSecreta,
				NVL(cdsenha,' ') as cdsenha
			INTO
				:iIdSenha,
				:iIdTipoSenha,
				:cDsLembreteFraseSecreta, 
				:cDsFraseSecreta, 
				:cDsLembreteSenha,
				:iQtTentFraseSecreta,
				:iIdStatusFraseSecreta,
				:cCdSenha
			FROM
				customer.Senha
			WHERE
				idPessoa = :iIdPessoa;
	}
	
	if (sqlca.sqlcode)
		throw TuxBasicOraException(sqlca.sqlcode);

	this->setIdSenha(iIdSenha);
	this->setIdTipoSenha(iIdTipoSenha);
	this->setDsFraseSecreta(CUtil::trim(cDsFraseSecreta));
 	this->setDsLembreteFraseSecreta(CUtil::trim(cDsLembreteFraseSecreta));	
	this->setDsLembreteSenha(CUtil::trim(cDsLembreteSenha));
	this->setQtTentFraseSecreta(iQtTentFraseSecreta);
	this->setStatusFraseSecreta(iIdStatusFraseSecreta);
	this->setCdSenha(CUtil::trim(cCdSenha));

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}

void CSenha::excluirFraseSecretaDB(int idPessoa, int idPessoaLinha, int idTipoRelacionamento, int idCanal, int idPessoaUsuario)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;
	int  iIdPessoa;
 	int  iIdPessoaLinha;
	int  iIdStatusFraseSecreta;

	int  iIdSenha;
	int  iIdTipoSenha;
	int  iIdCanal;
	int  iIdPessoaUsuario;
	int  iIdTipoHistorico;
	int  iIdTipoSistema;
 	EXEC SQL END DECLARE SECTION;

	iIdPessoa = idPessoa;
	iIdPessoaLinha = idPessoaLinha;
	iIdStatusFraseSecreta = FRASE_SECRETA_ATIVADA;

	// carregarDadosSenhaDB tem de vir sempre depois dos valores a serem alterados
	this->carregarDadosSenhaDB(idPessoa, idPessoaLinha, idTipoRelacionamento);
	
	iIdSenha              = this->getIdSenha();
	iIdTipoSenha          = this->getIdTipoSenha();
	iIdCanal              = idCanal;
	iIdPessoaUsuario      = idPessoaUsuario;
	iIdStatusFraseSecreta = this->getStatusFraseSecreta();
	iIdTipoHistorico      = ID_REINIC_FRASE_SECRETA;
	iIdTipoSistema        = ID_TP_SISTEMA_FO;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
	if(idTipoRelacionamento == PESSOA_USUARIO)
	{
		EXEC SQL 

			UPDATE
				customer.Senha 
			SET
				dsFraseSecreta = '',
				DSLEMBRETEFRASESECRETA = '',
				QtTentativaFraseSecreta = 0,
				idStatusSenhaFraseSecreta = :iIdStatusFraseSecreta,
				DtBloqueioFraseSecreta = ''
			WHERE
				idPessoaLinha = :iIdPessoaLinha;
	}
	else
	{
		EXEC SQL 

			UPDATE
				customer.Senha 
			SET
				dsFraseSecreta = '',
				DSLEMBRETEFRASESECRETA = '',
				QtTentativaFraseSecreta = 0,
				idStatusSenhaFraseSecreta = :iIdStatusFraseSecreta,
				DtBloqueioFraseSecreta = ''
			WHERE
				idPessoa = :iIdPessoa;		
	}

	if(sqlca.sqlcode)
		throw TuxBasicOraException(sqlca.sqlcode);

	if(iIdCanal > 0)
	{

		EXEC SQL

			INSERT INTO CUSTOMER.HISTORICOSENHA
			(
				idHistoricoSenha,
				idSenha,
				idTipoSenha, 
				idTipoStatusSenha, 
				idTipoHistoricoSenha,
				idTipoSistema, 
				idCanal,
				idPessoaUsuario,
				dtRegistroHistorico,
				idPessoaLinha
			)  
			VALUES
			(
				customer.HistoricoSenhaSQ.nextval,
				:iIdSenha,
				:iIdTipoSenha,
				:iIdStatusFraseSecreta, 
				:iIdTipoHistorico, 
				:iIdTipoSistema,  
				:iIdCanal, 
				:iIdPessoaUsuario,
				sysdate,
				:iIdPessoaLinha
			);
	}

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);

}

void CSenha::alterarQtTentFraseSecretaDB(int idPessoa, int idPessoaLinha, int idTipoRelacionamento)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;	
	int  iIdPessoa;
	int  iIdPessoaLinha;
	int  iQtTentFraseSecreta;
	EXEC SQL END DECLARE SECTION;

	iIdPessoa = idPessoa;
	iIdPessoaLinha = idPessoaLinha;
	iQtTentFraseSecreta = this->getQtTentFraseSecreta();

	if(idTipoRelacionamento == PESSOA_USUARIO)
	{
		EXEC SQL 

			UPDATE
				customer.Senha
			SET
				QtTentativaFraseSecreta = :iQtTentFraseSecreta
			WHERE
				idPessoaLinha = :iIdPessoaLinha; 
	}
	else
	{
		EXEC SQL 

			UPDATE
				customer.Senha
			SET
				QtTentativaFraseSecreta = :iQtTentFraseSecreta
			WHERE
				idPessoa = :iIdPessoa;
	}
	
	if (sqlca.sqlcode)
		throw TuxBasicOraException(sqlca.sqlcode);

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);

}

void CSenha::bloquearFraseSecretaDB(int idPessoa, 
									int idPessoaLinha, 
									int idTipoRelacionamento,
									int idCanal,
									int idPessoaUsuario, 
									int inRegistrarHistorico)
{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;	
	int  iIdPessoa;
	int  iIdPessoaLinha;
	int  iIdStatusFraseSecreta;
	int  iIdSenha;
	int  iIdTipoSenha;
	int  iIdCanal;
	int  iIdPessoaUsuario;
	int  iIdTipoHistorico;
	int  iIdTipoSistema;
	EXEC SQL END DECLARE SECTION;

	iIdPessoa             = idPessoa;
	iIdPessoaLinha        = idPessoaLinha;
	iIdStatusFraseSecreta = FRASE_SECRETA_BLOQUEADA;
	iIdSenha              = this->getIdSenha();
	iIdTipoSenha          = this->getIdTipoSenha();
	iIdCanal              = idCanal;
	iIdPessoaUsuario      = idPessoaUsuario;
	iIdTipoHistorico      = ID_BLOQ_FRASE_SECRETA;
	iIdTipoSistema        = ID_TP_SISTEMA_FO;

	if(idTipoRelacionamento == PESSOA_USUARIO)
	{
		EXEC SQL 

			UPDATE
				customer.Senha
			SET
				idStatusSenhaFraseSecreta = :iIdStatusFraseSecreta,
				DtBloqueioFraseSecreta = (SELECT sysdate FROM dual)
			WHERE
				idPessoaLinha = :iIdPessoaLinha; 
	}
	else
	{
		EXEC SQL 

			UPDATE
				customer.Senha
			SET
				idStatusSenhaFraseSecreta = :iIdStatusFraseSecreta,
				DtBloqueioFraseSecreta = (SELECT sysdate FROM dual)
			WHERE
				idPessoa = :iIdPessoa;
	}
	
	if (sqlca.sqlcode)
		throw TuxBasicOraException(sqlca.sqlcode);

	this->setStatusFraseSecreta(iIdStatusFraseSecreta);

	if ( inRegistrarHistorico == 1 )
	{
		EXEC SQL
			INSERT INTO CUSTOMER.HISTORICOSENHA
			(
				idHistoricoSenha,
				idSenha,
				idTipoSenha, 
				idTipoStatusSenha, 
				idTipoHistoricoSenha,
				idTipoSistema, 
				idCanal,
				idPessoaUsuario,
				dtRegistroHistorico
			)  
			VALUES
			(
				customer.HistoricoSenhaSQ.nextval,
				:iIdSenha,
				:iIdTipoSenha,
				:iIdStatusFraseSecreta, 
				:iIdTipoHistorico, 
				:iIdTipoSistema,  
				:iIdCanal, 
				:iIdPessoaUsuario,
				sysdate
			);
	}

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);

}

void CSenha::validarSenhaLojistaDB()
{
	char cSenha[32];

	// pegando a senha atual a ser comparada
	strcpy(cSenha, this->getSenha());

	m_pPessoaAbstract->AsLojista()->consultarDados();

	if(strlen(CUtil::trim(this->getSenha())) <= 0 || (strcmp(CUtil::trim(cSenha), this->getSenha())))
	{
		//voltando senha original
		this->setSenha(cSenha);

		throw TuxBasicSvcException("13E0000","SENHAS DIFERENTES");
	}
	else
	{
		if(!strcmp(this->getSenha(), "0000"))
		{
			// primeira conexão - alterar senha
			throw TuxBasicSvcException("13E0001");		
		}
	}

}

void CSenha::alterarSenhaLojistaDB()
{
	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	
	int  iIdTerminal;
	char cSenha[256];
	EXEC SQL END DECLARE SECTION;

	iIdTerminal = m_pPessoaAbstract->AsLojista()->getIdTerminal();
	
	strcpy(cSenha, this->getSenha());

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
    
	EXEC SQL 
		
		UPDATE		   
		   vol.SiteFTerminal
		SET
			cdSiteFSenha = :cSenha
		WHERE
			idTerminal = :iIdTerminal;

	if(sqlca.sqlcode)
		throw TuxBasicOraException(sqlca.sqlcode);

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);

}

/*
void CSenha::inserirDadosSenhaDB(void){

	struct sqlca sqlca;

 	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	
	int  iIdPessoa;
	int iIdPessoaLinha;
	int iIdAux;
	char cDataAtual[19+1];
	char cDataExp[19+1];
	char cNmPessoa[256];
	char cDsFraseSecreta[256];
	char cDsLembreteFraseSecreta[256];
	EXEC SQL END DECLARE SECTION;

    // Seta os dados a Alteraao
	iIdPessoa = this->getIdPessoa();
	iIdPessoaLinha = this->getIdPessoaLinha();
	strcpy(cDsFraseSecreta, this->getDsFraseSecreta());
	strcpy(cDsLembreteFraseSecreta, this->getDsLembreteFraseSecreta() );

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL SELECT customer.SenhaSQ.NEXTVAL INTO :iIdAux FROM DUAL;
	EXEC SQL SELECT to_char(SYSDATE, 'dd/mm/YYYY hh24:mi:ss'), to_char(add_months(SYSDATE, 24), 'dd/mm/YYYY hh24:mi:ss') INTO: cDataAtual, :cDataExp FROM DUAL;
     
	EXEC SQL 
		
		SELECT 
			a1.nmpessoa
		INTO
			:cNmPessoa
		FROM
			customer.pessoa a1, 
			customer.pessoalinha a, 
			customer.pessoadepara b
		WHERE 
			A.IDPESSOADEPARA = B.IDPESSOADEPARA AND
			A1.IDPESSOA = B.IDPESSOA AND
			B.IDPESSOA = :iIdPessoa ;
     
	EXEC SQL 
		INSERT INTO
			customer.Senha
			(	
				CDSENHA, 
				DTPRIMEIROACESSO, 
				DTULTIMOACESSO, 
				DTULTIMAATUALIZACAO, 
				QTTENTATIVAERRO, 
				IDTIPOSTATUSSENHA, 
				IDTIPOSENHA, 
				IDPESSOALINHA, 
				DTEXPIRACAO, 
				NMREPRESENTANTE, 
				IDPESSOA, 
				IDSENHA, 
				INTROCASENHA, 
				DTBLOQUEIO,		
				IDUSUARIOALTERACAO, 
				DTULTIMAALTERACAO, 
				DSFRASESECRETA, 
				DSLEMBRETEFRASESECRETA, 
				DSLEMBRETESENHA
			)
			VALUES	
			( 
				' ',
				to_date(:cDataAtual, 'dd/mm/yyyy hh24:mi:ss'),
				to_date(:cDataAtual, 'dd/mm/yyyy hh24:mi:ss'),
				to_date(:cDataAtual, 'dd/mm/yyyy hh24:mi:ss'),
				'0',
				'0',
				'1',
				:iIdPessoaLinha,
				to_date(:cDataExp, 'dd/mm/yyyy hh24:mi:ss'),
				:cNmPessoa,
				:iIdPessoa,
				:iIdAux,
				'0',
				NULL,
				'1',
				to_date(:cDataAtual, 'dd/mm/yyyy hh24:mi:ss'),
				:cDsFraseSecreta,
				:cDsLembreteFraseSecreta,
				' '
			);
	
	if(sqlca.sqlcode)
		throw TuxBasicOraException(sqlca.sqlcode);

	return;
 
	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}
*/

void CSenha::alterarDadosSenhaDB(int idPessoa, 
								 int idPessoaLinha, 
								 int idTipoRelacionamento,
								 int idCanal,
								 int idPessoaUsuario)

{
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;	
	int  iIdPessoa;
	int  iIdPessoaLinha;
	char cDsFraseSecreta[256];
	char cDsLembreteFraseSecreta[256];

	int  iIdStatusFraseSecreta;
	int  iIdSenha;
	int  iIdTipoSenha;
	int  iIdCanal;
	int  iIdPessoaUsuario;
	int  iIdTipoHistorico;
	int  iIdTipoSistema;

	EXEC SQL END DECLARE SECTION;

    // Seta os dados a Alteraao
	iIdPessoa = idPessoa;	
	iIdPessoaLinha = idPessoaLinha;	

	strcpy(cDsFraseSecreta, this->getDsFraseSecreta());
	strcpy(cDsLembreteFraseSecreta, this->getDsLembreteFraseSecreta() );
	
	// carregarDadosSenhaDB tem de vir sempre depois dos valores a serem alterados
	this->carregarDadosSenhaDB(idPessoa, idPessoaLinha, idTipoRelacionamento);
	
	iIdSenha              = this->getIdSenha();
	iIdTipoSenha          = this->getIdTipoSenha();
	iIdCanal              = idCanal;
	iIdPessoaUsuario      = idPessoaUsuario;
	iIdStatusFraseSecreta = this->getStatusFraseSecreta();
	iIdTipoHistorico      = ID_ALTER_FRASE_SECRETA;
	iIdTipoSistema        = ID_TP_SISTEMA_FO;

	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     
	if(idTipoRelacionamento == PESSOA_USUARIO)
	{
		EXEC SQL 

			UPDATE
				customer.Senha
			SET
				dsFraseSecreta = :cDsFraseSecreta ,
				dsLembreteFraseSecreta = :cDsLembreteFraseSecreta ,
				dtUltimaAlteracao = SYSDATE
			WHERE
				idPessoaLinha = :iIdPessoaLinha; 
	}
	else
	{
		EXEC SQL

			UPDATE
				customer.Senha
			SET
				dsFraseSecreta = :cDsFraseSecreta ,
				dsLembreteFraseSecreta = :cDsLembreteFraseSecreta ,
				dtUltimaAlteracao = SYSDATE
			WHERE
				idPessoa = :iIdPessoa; 
	}

	if (sqlca.sqlcode)
		throw TuxBasicOraException(sqlca.sqlcode);

	if(iIdCanal > 0)
	{

		EXEC SQL

			INSERT INTO CUSTOMER.HISTORICOSENHA
			(
				idHistoricoSenha,
				idSenha,
				idTipoSenha, 
				idTipoStatusSenha, 
				idTipoHistoricoSenha,
				idTipoSistema, 
				idCanal,
				idPessoaUsuario,
				dtRegistroHistorico,
				IDPESSOALINHA
			)  
			VALUES
			(
				customer.HistoricoSenhaSQ.nextval,
				:iIdSenha,
				:iIdTipoSenha,
				:iIdStatusFraseSecreta, 
				:iIdTipoHistorico, 
				:iIdTipoSistema,  
				:iIdCanal, 
				:iIdPessoaUsuario,
				sysdate,
				:iIdPessoaLinha
			);
	}

    return;

	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);

}

void CSenha::registrarPrimeiroAcessoDB(int idCanal, int idPessoaUsuario, int idPessoaLinha, int iIdTerminal){
	struct sqlca sqlca;

	EXEC SQL BEGIN DECLARE SECTION;	
	int iIdTipoHistoricoSenhaDB;
	int iIdCanalDB;
	int iIdPessoaUsuarioDB;
	int iIdSenhaDB;
	int	iIdTipoSenhaDB;
	int	iIdStatusFraseSecretaDB;
	int	iIdTipoSistemaDB;
	int iIdHistoricoSenha=0;
	int iIdPessoaLinhaDB=0;
	int iIdTerminalDB = 0;
	EXEC SQL END DECLARE SECTION;

	iIdTipoHistoricoSenhaDB = ID_TIPO_HISTORICO_SENHA_PRIACESSO;
	iIdCanalDB				= idCanal;
	iIdPessoaUsuarioDB      = idPessoaUsuario;

	iIdSenhaDB              = this->getIdSenha();
	iIdTipoSenhaDB          = this->getIdTipoSenha();
	iIdStatusFraseSecretaDB = this->getStatusFraseSecreta();
	iIdTipoSistemaDB		= ID_TP_SISTEMA_FO;

	iIdPessoaLinhaDB		= idPessoaLinha;
	iIdTerminalDB			= iIdTerminal < 0 ? 0 : iIdTerminal;


	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;

	EXEC SQL
		SELECT
			NVL(idHistoricoSenha,0)
		INTO	
			:iIdHistoricoSenha
		FROM
			customer.HistoricoSenha
		WHERE
			idSenha				= :iIdSenhaDB
		AND	idCanal				= :iIdCanalDB
		AND	idTipoHistoricoSenha= :iIdTipoHistoricoSenhaDB
		AND	rownum	= 1;

	//Registra o primeiro acesso, somente se não existir.
	//Caso a frase secreta seja reiniciada, passará pela tela do primeiro acesso novamente, mas não poderá registrar o histórico
	//Nao Verifica se a frase secreta e nula, pois a linha pode ja ter sido logado em um dos canais e nao ser mais nula. Entao a regra e´ se existe o primeiro acesso para o canal em questao no historico.
	if (iIdHistoricoSenha <= 0)
	{
		EXEC SQL
			INSERT INTO CUSTOMER.HISTORICOSENHA
			(
				idHistoricoSenha,
				idSenha,
				idTipoSenha, 
				idTipoStatusSenha, 
				idTipoHistoricoSenha,
				idTipoSistema, 
				idCanal,
				idPessoaUsuario,
				dtRegistroHistorico,
				idPessoaLinha,
				idTerminal
			)	
			VALUES
			(	
				customer.HistoricoSenhaSQ.nextval,
				:iIdSenhaDB,
				:iIdTipoSenhaDB,
				:iIdStatusFraseSecretaDB, 
				:iIdTipoHistoricoSenhaDB, 
				:iIdTipoSistemaDB,  
				:iIdCanalDB, 
				:iIdPessoaUsuarioDB,
				sysdate,
				DECODE(:iIdPessoaLinhaDB, 0, NULL, :iIdPessoaLinhaDB),
				DECODE(:iIdTerminalDB, 0, NULL, :iIdTerminalDB)
			);
	}

    return;

	sqlErrorConstrutor:
		throw TuxBasicOraException(sqlca.sqlcode);
}

int CSenha::validarSenhaWS(char*ddd,char*linha,char*senha)
{
	tuxfw_getlogger()->debug("CSenha::validarSenhaWS");
	tuxfw_getlogger()->debug("linha=%s",linha);
	tuxfw_getlogger()->debug("ddd=%s",ddd);
	tuxfw_getlogger()->debug("senha=%s",senha);
	struct sqlca sqlca;
	EXEC SQL BEGIN DECLARE SECTION;
        int iIdTipoSenha;
		char*clinha = linha;
		char*cddd = ddd;
		char*csenha = senha;
		int validarSenha = 0;
		struct param{
			VARCHAR idLinhaTelefonica[22];
			VARCHAR inTrocaSenha[22];
			VARCHAR sgTipoStatusSenha[255];
		}m_param;
		struct iparam{
			short idLinhaTelefonica;
			short inTrocaSenha;
			short sgTipoStatusSenha;
		}m_iparam;
		
		
		int   idsenha         = 0;
        short indidsenha      = -1;
		int   idQtdTentativaC  = 0;
        short indQtdTentativaC = -1;
		int   idQtdTentativaU  = 0;
        short indQtdTentativaU = -1;
		
		int   idtipoStatusSenha  = 0;
        short indtipoStatusSenha = -1;
		
		
		
		//INICIO demanda 23357 - SAPO

		int   ctSenha         = 0;
		
		long idpessoalinha = 0;
		short indidpessoalinha = -1;
		
		//FIM demanda 23357 - SAPO	
		
		// INICIO OS 1476
		int   UsuarioTipoPessoa;
        short i_UsuarioTipoPessoa = -1;
        int   ClienteTipoPessoa;
        short i_ClienteTipoPessoa = -1;
		// FIM    OS 1476
		
		long idpessoa = 0;
		short indidpessoa = -1;
		
	EXEC SQL END DECLARE SECTION;
	sqlca.sqlcode = 0;

	memset(&m_param,0,sizeof(m_param));
	memset(&m_iparam,0,sizeof(m_iparam));

	// validar linha
	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;	
	EXEC SQL
		SELECT 
			LINHATELEFONICA.IDLINHATELEFONICA
		INTO
			:m_param.idLinhaTelefonica:m_iparam.idLinhaTelefonica
		FROM
			LINHA.LINHABASE LINHABASE,
			LINHA.LINHATELEFONICA LINHATELEFONICA,
			APOIO.AREAREGISTRO AREAREGISTRO
		WHERE
			LINHABASE.IDLINHABASE = LINHATELEFONICA.IDLINHABASE AND
			LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO AND
			LINHABASE.NRLINHA = :clinha AND
			AREAREGISTRO.CDAREAREGISTRO = :cddd;

	tuxfw_getlogger()->debug("idlinhatelefonica = %s",(char*)m_param.idLinhaTelefonica.arr); 

	if(sqlca.sqlcode == 1403)
	{
		tuxfw_getlogger()->debug("Linha inexistente!");
		return -1;
	}
	
	
    EXEC SQL 
        SELECT
            idPessoaLinha, idPessoa
        INTO
            :idpessoalinha:indidpessoalinha, :idpessoa:indidpessoa
        FROM
            CUSTOMER.TelefoneUsuarioV09
        WHERE
                cdAreaRegistro = :cddd
                AND nrLinha    = :clinha
                AND idTipoRelacionamento = 1;
				
	tuxfw_getlogger()->debug("validarSenhaWS --> idpessoalinha = %ld",idpessoalinha);
	
	
	// INICIO --- OS 1476
	
    EXEC SQL
    SELECT
        atp.IDTIPOPESSOA
    into
        :UsuarioTipoPessoa:i_UsuarioTipoPessoa
    FROM
        LINHA.LINHATELEFONICA LINHATELEFONICA ,
        LINHA.LINHABASE       LINHABASE ,
        APOIO.AREAREGISTRO    AREAREGISTRO ,
        apoio.EstadoLinha		b,
        customer.pessoalinha		cpl,
        customer.pessoadepara		pdp,
        customer.pessoa				cp,
        apoio.tipopessoa			atp
    WHERE
        CPL.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
    AND
        LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
    AND
        LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
    AND
        LINHABASE.idEstadoLinha = b.idEstadoLinha
    AND cdAreaRegistro = :cddd
    AND nrLinha = :clinha
    AND LINHATELEFONICA.IDLINHATELEFONICA = cpl.IDLINHATELEFONICA
    AND pdp.IDPESSOADEPARA = cpl.IDPESSOADEPARA
    AND pdp.IDPESSOA = cp.IDPESSOA
    AND cp.IDTIPOPESSOA = atp.idtipopessoa
    AND cpl.IDTIPORELACIONAMENTO = 1;   // Usuario

    EXEC SQL
    SELECT
        atp.IDTIPOPESSOA
    into
        :ClienteTipoPessoa:i_ClienteTipoPessoa
    FROM
        LINHA.LINHATELEFONICA LINHATELEFONICA ,
        LINHA.LINHABASE       LINHABASE ,
        APOIO.AREAREGISTRO    AREAREGISTRO ,
        apoio.EstadoLinha		b,
        customer.pessoalinha		cpl,
        customer.pessoadepara		pdp,
        customer.pessoa				cp,
        apoio.tipopessoa			atp
    WHERE
        CPL.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
    AND
        LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
    AND
        LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
    AND
        LINHABASE.idEstadoLinha = b.idEstadoLinha
    AND cdAreaRegistro = :cddd
    AND nrLinha = :clinha
    AND LINHATELEFONICA.IDLINHATELEFONICA = cpl.IDLINHATELEFONICA
    AND pdp.IDPESSOADEPARA = cpl.IDPESSOADEPARA
    AND pdp.IDPESSOA = cp.IDPESSOA
    AND cp.IDTIPOPESSOA = atp.idtipopessoa
    AND cpl.IDTIPORELACIONAMENTO = 2;   // Cliente

    // Pessoa Juridica Usuario e Cliente
    if ( i_ClienteTipoPessoa != -1 && i_UsuarioTipoPessoa != -1 )
    {
        if ( ClienteTipoPessoa == 2 && UsuarioTipoPessoa == 2 )
        {
			tuxfw_getlogger()->debug(">>> Acesso nao Autorizado para Cliente PJ -> Usuario PJ");
            return -7;
        }
    }
	// FIM    --- OS 1476
	
    EXEC SQL 	
        SELECT
			count(1)
        INTO
            :ctSenha
        FROM
            customer.Senha
        WHERE
            idPessoaLinha = :idpessoalinha or idPessoa = :idpessoa;
			
	tuxfw_getlogger()->debug("validarSenhaWS --> ctSenha = %d",ctSenha);
			
		if(ctSenha < 1)
		{
			return -6;
		}
	
	EXEC SQL 
		SELECT IDTIPOSTATUSSENHA 
		INTO 
			:idtipoStatusSenha:indtipoStatusSenha
		FROM 
			APOIO.TIPOSTATUSSENHA TSS 
		WHERE 
			TSS.SGTIPOSTATUSSENHA = 'B' AND ROWNUM < 2;
			
		tuxfw_getlogger()->debug("Executando atualização em CUSTOMER.SENHA IDTIPOSTATUSSENHA");
		if (indtipoStatusSenha == -1 )
		{
			tuxfw_getlogger()->debug("Erro obtendo o IDSTATUSSENHA Bloqueado de APOIO.TIPOSTATUSSENHA. Considerando o IDTIPOSTATUSSENHA = 2.");
			idtipoStatusSenha = 2;
		}
		tuxfw_getlogger()->debug( "IDTIPOSTATUSSENHA [%d]\n",idtipoStatusSenha );
	
	// validar senha de cliente
	sqlca.sqlcode = 0;
	EXEC SQL WHENEVER SQLERROR GOTO Error;
	EXEC SQL WHENEVER NOT FOUND CONTINUE;	
	// compara senha de cliente
	EXEC SQL
		SELECT 
			NVL(SENHA.INTROCASENHA,'0'),
			NVL(TIPOSTATUSSENHA.SGTIPOSTATUSSENHA,' ')
		INTO
			:m_param.inTrocaSenha:m_iparam.inTrocaSenha,
			:m_param.sgTipoStatusSenha:m_iparam.sgTipoStatusSenha
		FROM
			CUSTOMER.PESSOALINHA PESSOALINHA,
			CUSTOMER.PESSOADEPARA PESSOADEPARA,
			CUSTOMER.SENHA SENHA,
			APOIO.TIPOSTATUSSENHA TIPOSTATUSSENHA
		WHERE
			PESSOALINHA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA AND
			SENHA.IDPESSOA = PESSOADEPARA.IDPESSOA AND
			SENHA.IDTIPOSTATUSSENHA = TIPOSTATUSSENHA.IDTIPOSTATUSSENHA AND
			SENHA.CDSENHA = :csenha AND
			PESSOALINHA.IDLINHATELEFONICA = :m_param.idLinhaTelefonica AND
			ROWNUM <= 1;

	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	// se achou a senha retorna
	if(sqlca.sqlcode != 1403 )
	{
        char bf[2];
        sprintf( bf,"%.1s", (char*)m_param.inTrocaSenha.arr );
        
        tuxfw_getlogger()->debug( "=== Passou 1...\n" );
        tuxfw_getlogger()->debug( "=== bf [%s]\n", bf );
        tuxfw_getlogger()->debug( "=== inTrocaSenha [%.1s]\n", (char*)m_param.inTrocaSenha.arr );
		// if(!strcmp((char*)m_param.inTrocaSenha.arr,"1"))
        
        //if(!strcmp(bf,"1"))
        if( bf[0] == '1' )
        {
            tuxfw_getlogger()->debug( "Retornando -2\n" );
			return -2; // retorna erro em caso de flag de troca de senha
        }
		else
		if(strcmp((char*)m_param.sgTipoStatusSenha.arr,"A") != 0)
			return -3; // retorna erro se a senha estiver bloqueada com com qualquer status diferente de A

			/*
        if(idTipoRelacionamento == PESSOA_USUARIO)
        {
            EXEC SQL 
                SELECT
                    idTipoSenha
                INTO
                    :iIdTipoSenha
                FROM
                    customer.Senha
                WHERE
                    idPessoaLinha = :idpessoalinha; 
        }
        else
        {
            EXEC SQL 
                SELECT
                    idTipoSenha
                INTO
                    :iIdTipoSenha
                FROM
                    customer.Senha
                WHERE
                    idPessoa = :iIdPessoa;
        }
        */
		
		tuxfw_getlogger()->debug( "Zerando Quantidade de Tentativas Erradas da Senha\n" );
		
		// ZERA A QUANTIDADE DE TENTATIVAS ERRADAS.
		if ( zerarQtdTentativaSenha( atoi((const char *)m_param.idLinhaTelefonica.arr), idtipoStatusSenha ) != 1)
		{
			tuxfw_getlogger()->debug( "Erro ao tentar zerar a QtdTentativaErro de CUSTOMER.SENHA\n" );
		}
		else
		{
			tuxfw_getlogger()->debug( "QtdTentativaErro zerada com sucesso\n" );
		}

        EXEC SQL 
            SELECT
                idTipoSenha
            INTO
                :iIdTipoSenha
            FROM
                customer.Senha
            WHERE
                idPessoaLinha = :idpessoalinha; 

        if ( iIdTipoSenha == 2 )
        {
            tuxfw_getlogger()->debug( "Retornando -2\n" );
            return -2;
        }
        else
        {
            tuxfw_getlogger()->debug( "Retornando 1\n" );
            return 1;
        }
	}

	sqlca.sqlcode = 0;
	memset(&m_param.inTrocaSenha,0,sizeof(m_param.inTrocaSenha));
	memset(&m_iparam.sgTipoStatusSenha,0,sizeof(m_iparam.sgTipoStatusSenha));

	
    tuxfw_getlogger()->debug( "=== Passou 2...\n" );
	// valida senha de usuario
	EXEC SQL
		SELECT 
			NVL(SENHA.INTROCASENHA,'0'),
			NVL(TIPOSTATUSSENHA.SGTIPOSTATUSSENHA,' ')
		INTO
			:m_param.inTrocaSenha:m_iparam.inTrocaSenha,
			:m_param.sgTipoStatusSenha:m_iparam.sgTipoStatusSenha
		FROM
			CUSTOMER.PESSOALINHA PESSOALINHA,
			CUSTOMER.SENHA SENHA,
			APOIO.TIPOSTATUSSENHA TIPOSTATUSSENHA
		WHERE
			SENHA.IDPESSOALINHA = PESSOALINHA.IDPESSOALINHA AND
			SENHA.IDTIPOSTATUSSENHA = TIPOSTATUSSENHA.IDTIPOSTATUSSENHA AND
			SENHA.CDSENHA = :csenha AND
			PESSOALINHA.IDLINHATELEFONICA =  :m_param.idLinhaTelefonica AND
			ROWNUM <= 1;	

	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);

	idQtdTentativaC  = 0;
	indQtdTentativaC = -1;
	idQtdTentativaU  = 0;
	indQtdTentativaU = -1;
	
	// retorna erro caso não localize a senha para a linha
	if(sqlca.sqlcode == 1403)
	{
		tuxfw_getlogger()->debug("Executando atualização em CUSTOMER.SENHA QTTENTATIVAERRO");
		
		// ATUALIZAR A QUANTIDADE DE TENTATIVAS.  (CLIENTE USUARIO)
	  EXEC SQL 
      UPDATE CUSTOMER.SENHA S2
            SET S2.QTTENTATIVAERRO = NVL(S2.QTTENTATIVAERRO,0) +1 
			WHERE 
      S2.IDSENHA IN ( 
      
         SELECT UNIQUE IDSENHA FROM 
         (     SELECT S.IDSENHA
    					FROM 
    						CUSTOMER.SENHA S,
    						CUSTOMER.PESSOALINHA PESSOALINHA,
    						CUSTOMER.PESSOADEPARA PESSOADEPARA,
    						APOIO.TIPOSTATUSSENHA TIPOSTATUSSENHA
    					WHERE
    						PESSOALINHA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA AND
    						S.IDPESSOA = PESSOADEPARA.IDPESSOA AND
    						S.IDTIPOSTATUSSENHA = TIPOSTATUSSENHA.IDTIPOSTATUSSENHA AND
    						PESSOALINHA.IDLINHATELEFONICA = :m_param.idLinhaTelefonica
          UNION
    			SELECT S.IDSENHA 
    				FROM
              CUSTOMER.SENHA S,
    					CUSTOMER.PESSOALINHA PESSOALINHA,
    					APOIO.TIPOSTATUSSENHA TIPOSTATUSSENHA
    				WHERE
    					S.IDPESSOALINHA = PESSOALINHA.IDPESSOALINHA AND
    					S.IDTIPOSTATUSSENHA = TIPOSTATUSSENHA.IDTIPOSTATUSSENHA AND
    					PESSOALINHA.IDLINHATELEFONICA =  :m_param.idLinhaTelefonica) )      
		AND NVL(S2.QTTENTATIVAERRO,0) < 3;			
			
			
			
		// ATUALIZAR O STATUS PARA BLOQUEADO SE PRECISAR (CLIENTE USUARIO)
		tuxfw_getlogger()->debug("Executando atualização em CUSTOMER.SENHA IDTIPOSTATUSSENHA");
			
		
		EXEC SQL 
			UPDATE CUSTOMER.SENHA S2
				SET S2.IDTIPOSTATUSSENHA = :idtipoStatusSenha             
			WHERE 
				S2.IDSENHA IN ( 
							 SELECT UNIQUE IDSENHA FROM 
							 (     SELECT S.IDSENHA
											FROM 
												CUSTOMER.SENHA S,
												CUSTOMER.PESSOALINHA PESSOALINHA,
												CUSTOMER.PESSOADEPARA PESSOADEPARA,
												APOIO.TIPOSTATUSSENHA TIPOSTATUSSENHA
											WHERE
												PESSOALINHA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA AND
												S.IDPESSOA = PESSOADEPARA.IDPESSOA AND
												S.IDTIPOSTATUSSENHA = TIPOSTATUSSENHA.IDTIPOSTATUSSENHA AND
												PESSOALINHA.IDLINHATELEFONICA = :m_param.idLinhaTelefonica
							  UNION
									SELECT S.IDSENHA 
										FROM
								  CUSTOMER.SENHA S,
											CUSTOMER.PESSOALINHA PESSOALINHA,
											APOIO.TIPOSTATUSSENHA TIPOSTATUSSENHA
										WHERE
											S.IDPESSOALINHA = PESSOALINHA.IDPESSOALINHA AND
											S.IDTIPOSTATUSSENHA = TIPOSTATUSSENHA.IDTIPOSTATUSSENHA AND
											PESSOALINHA.IDLINHATELEFONICA =  :m_param.idLinhaTelefonica) )      
				AND NVL(S2.QTTENTATIVAERRO,0) = 3; 

		EXEC SQL
			SELECT 
				NVL(RET1.QTTENTATIVAERRO,0)
			INTO 
				:idQtdTentativaC:indQtdTentativaC
			FROM 
				(SELECT 
					SENHA.QTTENTATIVAERRO AS QTTENTATIVAERRO
				FROM
					CUSTOMER.PESSOALINHA PESSOALINHA,
					CUSTOMER.PESSOADEPARA PESSOADEPARA,
					CUSTOMER.SENHA SENHA,
					APOIO.TIPOSTATUSSENHA TIPOSTATUSSENHA
				WHERE
					PESSOALINHA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA AND
					SENHA.IDPESSOA = PESSOADEPARA.IDPESSOA AND
					SENHA.IDTIPOSTATUSSENHA = TIPOSTATUSSENHA.IDTIPOSTATUSSENHA AND
					PESSOALINHA.IDLINHATELEFONICA = :m_param.idLinhaTelefonica 
				ORDER BY NVL(QTTENTATIVAERRO,0) DESC
				)RET1
			WHERE ROWNUM < 2;

		if( indQtdTentativaC != -1 )
		{
			tuxfw_getlogger()->debug("Cliente tem idQtdTentativaC = %d",idQtdTentativaC);
		}
		else
		{
			tuxfw_getlogger()->debug("Cliente não encontrado para obter o idQtdTentativaC ");
		}
			
		EXEC SQL
			SELECT 
				NVL(RET2.QTTENTATIVAERRO,0)
			INTO 
				:idQtdTentativaU:indQtdTentativaU
			FROM 
				(SELECT 
					SENHA.QTTENTATIVAERRO AS QTTENTATIVAERRO
				FROM
					CUSTOMER.PESSOALINHA PESSOALINHA,
					CUSTOMER.SENHA SENHA,
					APOIO.TIPOSTATUSSENHA TIPOSTATUSSENHA
				WHERE
					SENHA.IDPESSOALINHA = PESSOALINHA.IDPESSOALINHA AND
					SENHA.IDTIPOSTATUSSENHA = TIPOSTATUSSENHA.IDTIPOSTATUSSENHA AND
					PESSOALINHA.IDLINHATELEFONICA =  :m_param.idLinhaTelefonica
				ORDER BY NVL(QTTENTATIVAERRO,0) DESC
				)RET2
			WHERE ROWNUM < 2;
			
		if( indQtdTentativaU != -1 )
		{
			tuxfw_getlogger()->debug("Usuário tem idQtdTentativaU = %d",idQtdTentativaU);
		}
		else
		{
			tuxfw_getlogger()->debug("Usuário não encontrado para obter o idQtdTentativaU ");
		}

			
		if( idQtdTentativaU > 2 || idQtdTentativaU > 2 )
		{
			tuxfw_getlogger()->debug("Situação de Senha Bloqueada.");
			return -10;
		}
		
		if( idQtdTentativaU > 1 || idQtdTentativaU > 1 )
		{
			tuxfw_getlogger()->debug("Situação de 2º Tentativa de senha errada.");
			return -9;
		}
		
		if( idQtdTentativaU >= 0 || idQtdTentativaU >= 0 )
		{
			tuxfw_getlogger()->debug("Situação de 1º Tentativa de senha errada.");
			return -8;
		}
		
		tuxfw_getlogger()->debug("Senha não confere para idlinhatelefonica = %s",(char*)m_param.idLinhaTelefonica.arr);
		return -4;
	}
	else
	{
		// tratamento de erro para senha
		if(!strcmp((char*)m_param.inTrocaSenha.arr,"1"))
		{
			tuxfw_getlogger()->debug( "=== Retornando -2...\n" );
			return -2; // retorna erro em caso de flag de troca de senha
		}
		else
		if(strcmp((char*)m_param.sgTipoStatusSenha.arr,"A") != 0)
		{
			tuxfw_getlogger()->debug( "=== Retornando -3...\n" );
			return -3; // retorna erro se a senha estiver bloqueada com com qualquer status diferente de A
		}
		
		tuxfw_getlogger()->debug( "Zerando Quantidade de Tentativas Erradas da Senha\n" );
		// ZERA A QUANTIDADE DE TENTATIVAS ERRADAS.
		if ( zerarQtdTentativaSenha( atoi((const char *)m_param.idLinhaTelefonica.arr), idtipoStatusSenha ) != 1)
		{
			tuxfw_getlogger()->debug( "Erro ao tentar zerar a QtdTentativaErro de CUSTOMER.SENHA\n" );
		}
		else
		{
			tuxfw_getlogger()->debug( "QtdTentativaErro zerada com sucesso\n" );
		}
		return 1;
	}

Error:
	tuxfw_getlogger()->debug("ERRO: sqlca.sqlcode = %d",sqlca.sqlcode);
	throw TuxBasicOraException(sqlca.sqlcode);

}


void CSenha::consultarDadosCliente(char*ddd,char*linha)
 {
    struct sqlca sqlca;
	
	EXEC SQL BEGIN DECLARE SECTION;
 	char cNmPessoa[256];
	char*clinha = linha;
	char*cddd = ddd;
	int idTipoLinha;
	
	// INICIO - demanda 23357 - SAPO 
	char cNmNomeCompleto[256];
	char cDtNascimento[256];
	char cSgSexo[256];	
	// FIM - demanda 23357 - SAPO 
	
	// INICIO OS 1476 
	char cEmail[256];
	short inEmail;
	// FIM OS 1476
	
	
	short inNmPessoa;
	short inidTipoLinha;
	short inNmNomeCompleto;
	short inDtNascimento;
	short inSgSexo;
	
	
	int ClienteTipoPessoa;
	short i_ClienteTipoPessoa;
	
 	EXEC SQL END DECLARE SECTION;

    
	idTipoLinha = 0;
	
	// Marca ponto de controle de erro
	EXEC SQL WHENEVER SQLERROR GOTO sqlErrorConstrutor;
     /*select * from customer.pessoaLINHAB01 
	where   idtiporelacionamento = 2 and sgtiporelacionamento = 'U'
	and nrlinha = 12345678 and cdarearegistro = 11*/
	//TO_CHAR(DECODE(F.DTNASCIMENTO,NULL,' ',TO_CHAR(F.DTNASCIMENTO,'DD/MM/YYYY'))), --DATA NASCIMENTO
	
    memset( cNmPessoa, 0x0, sizeof(cNmPessoa) );
    memset( cNmNomeCompleto, 0x0, sizeof(cNmNomeCompleto) );
    memset( cDtNascimento, 0x0, sizeof(cDtNascimento) );
    memset( cSgSexo, 0x0, sizeof(cSgSexo) );
	
	
    
    inNmPessoa = -1;
    inidTipoLinha = -1;
    inNmNomeCompleto = -1;
    inDtNascimento = -1;
    inSgSexo = -1;
	i_ClienteTipoPessoa = -1;
	
	memset( cEmail, 0x0, sizeof(cEmail) );
	inEmail = -1;
	

	tuxfw_getlogger()->debug("Valores de entrada ddd[%s], ddd[%s]", ddd, linha);
    
    EXEC SQL
    SELECT
        atp.IDTIPOPESSOA
    into
        :ClienteTipoPessoa:i_ClienteTipoPessoa
    FROM
        LINHA.LINHATELEFONICA LINHATELEFONICA ,
        LINHA.LINHABASE       LINHABASE ,
        APOIO.AREAREGISTRO    AREAREGISTRO ,
        apoio.EstadoLinha		b,
        customer.pessoalinha		cpl,
        customer.pessoadepara		pdp,
        customer.pessoa				cp,
        apoio.tipopessoa			atp
    WHERE
        CPL.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
    AND
        LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
    AND
        LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
    AND
        LINHABASE.idEstadoLinha = b.idEstadoLinha
    AND cdAreaRegistro = :cddd
    AND nrLinha = :clinha
    AND LINHATELEFONICA.IDLINHATELEFONICA = cpl.IDLINHATELEFONICA
    AND pdp.IDPESSOADEPARA = cpl.IDPESSOADEPARA
    AND pdp.IDPESSOA = cp.IDPESSOA
    AND cp.IDTIPOPESSOA = atp.idtipopessoa
    AND cpl.IDTIPORELACIONAMENTO = 2;   // Cliente


	
	if ( i_ClienteTipoPessoa != -1 )
    {
        if ( ClienteTipoPessoa == 1 ) // PessoaFisica
		{
		tuxfw_getlogger()->debug("Tipo pessoa PF.");
		EXEC SQL
			SELECT
				NVL(G.nmNome, ' '), 
				A.IDTIPOLINHA,
				NVL(G.nmPessoa, ' '),
				NVL(TO_CHAR(F.DTNASCIMENTO,'DD/MM/YYYY'), ' '),
				H.SGSEXO
			INTO
				:cNmPessoa:inNmPessoa, 
				:idTipoLinha:inidTipoLinha, 
				:cNmNomeCompleto:inNmNomeCompleto, 
				:cDtNascimento:inDtNascimento, 
				:cSgSexo:inSgSexo
			FROM
				LINHA.LINHATELEFONICA A,
				LINHA.LINHABASE  B,
				APOIO.AREAREGISTRO B1,
				CUSTOMER.PESSOALINHA C, 
				CUSTOMER.PESSOADEPARA D,
				CUSTOMER.TIPORELACIONAMENTO E,
				CUSTOMER.PESSOA G,
				CUSTOMER.PESSOAFISICA F,
				APOIO.SEXO H
			WHERE 	
				A.IDLINHABASE             = B.IDLINHABASE AND
				B.IDAREAREGISTRO          = B1.IDAREAREGISTRO AND
				C.IDLINHATELEFONICA       = A.IDLINHATELEFONICA AND
				C.IDPESSOADEPARA          = D.IDPESSOADEPARA AND
				C.IDTIPORELACIONAMENTO    = E.IDTIPORELACIONAMENTO AND    
				D.idPessoa                = G.idPessoa AND
				E.SGTIPORELACIONAMENTO	  = 'C'		   AND
				B1.CdAreaRegistro		  = :cddd	   AND
				B.NRLINHA				  = :clinha    AND
				F.IDPESSOA(+) 			  = G.IDPESSOA AND
				F.IDSEXO		          = H.IDSEXO   AND
				C.idTipoRelacionamento    =  2;
			
		EXEC SQL
			SELECT
				NVL(pc.dscontato, ' ')
			INTO 
				:cEmail:inEmail
			FROM
				LINHA.LINHATELEFONICA A,
				LINHA.LINHABASE  B,
				APOIO.AREAREGISTRO B1,
				CUSTOMER.PESSOALINHA C, 
				CUSTOMER.PESSOADEPARA D,
				CUSTOMER.TIPORELACIONAMENTO E,
				CUSTOMER.PESSOA G,
				CUSTOMER.PESSOACOMUNICACAO PC 
			WHERE 	
				A.IDLINHABASE             = B.IDLINHABASE AND
				B.IDAREAREGISTRO          = B1.IDAREAREGISTRO AND
				C.IDLINHATELEFONICA       = A.IDLINHATELEFONICA AND
				C.IDPESSOADEPARA          = D.IDPESSOADEPARA AND
				C.IDTIPORELACIONAMENTO    = E.IDTIPORELACIONAMENTO AND    
				D.idPessoa                = G.idPessoa AND
				B1.CdAreaRegistro		  = :cddd	   AND
				B.NRLINHA				  = :clinha    AND
				C.idTipoRelacionamento    = 2 AND
				PC.IDTIPOCOMUNICACAO = 6 AND
				PC.IDPESSOA = G.IDPESSOA AND
				ROWNUM < 2;
		
		}
		else if ( ClienteTipoPessoa == 2 ) // Pessoa Juridica
		{
		tuxfw_getlogger()->debug("Tipo pessoa PJ.");
		
/*		
		EXEC SQL	
			SELECT
				NVL(G.nmNome, ' '), 
				A.IDTIPOLINHA,
				NVL(G.nmPessoa, ' '),
				' ' AS DTNASCIMENTO,
				'NC' AS SGSEXO
			--	NVL(TO_CHAR(F.DTNASCIMENTO,'DD/MM/YYYY'), ' '),
			--	H.SGSEXO
			INTO
				:cNmPessoa:inNmPessoa, 
				:idTipoLinha:inidTipoLinha, 
				:cNmNomeCompleto:inNmNomeCompleto, 
				:cDtNascimento:inDtNascimento, 
				:cSgSexo:inSgSexo
			FROM
				LINHA.LINHATELEFONICA A,
				LINHA.LINHABASE  B,
				APOIO.AREAREGISTRO B1,
				CUSTOMER.PESSOALINHA C, 
				CUSTOMER.PESSOADEPARA D,
				CUSTOMER.TIPORELACIONAMENTO E ,
				CUSTOMER.PESSOA G ,
				APOIO.SEXO H
			WHERE 	
				A.IDLINHABASE             = B.IDLINHABASE AND
				B.IDAREAREGISTRO          = B1.IDAREAREGISTRO AND
				C.IDLINHATELEFONICA       = A.IDLINHATELEFONICA AND
				C.IDPESSOADEPARA          = D.IDPESSOADEPARA AND
				C.IDTIPORELACIONAMENTO    = E.IDTIPORELACIONAMENTO AND    
				D.idPessoa                = G.idPessoa AND 
				E.SGTIPORELACIONAMENTO	  = 'C'		   AND
				B1.CdAreaRegistro		  = :cddd	   AND
				B.NRLINHA				  = :clinha AND
		  ROWNUM < 2;   
*/
		EXEC SQL
			SELECT
				NVL(G.nmNome, ' '), 
				A.IDTIPOLINHA,
				NVL(G.nmPessoa, ' '),
				NVL(TO_CHAR(F.DTNASCIMENTO,'DD/MM/YYYY'), ' '),
				H.SGSEXO
			INTO
				:cNmPessoa:inNmPessoa, 
				:idTipoLinha:inidTipoLinha, 
				:cNmNomeCompleto:inNmNomeCompleto, 
				:cDtNascimento:inDtNascimento, 
				:cSgSexo:inSgSexo
			FROM
				LINHA.LINHATELEFONICA A,
				LINHA.LINHABASE  B,
				APOIO.AREAREGISTRO B1,
				CUSTOMER.PESSOALINHA C, 
				CUSTOMER.PESSOADEPARA D,
				CUSTOMER.TIPORELACIONAMENTO E,
				CUSTOMER.PESSOA G,
				CUSTOMER.PESSOAFISICA F,
				APOIO.SEXO H
			WHERE 	
				A.IDLINHABASE             = B.IDLINHABASE AND
				B.IDAREAREGISTRO          = B1.IDAREAREGISTRO AND
				C.IDLINHATELEFONICA       = A.IDLINHATELEFONICA AND
				C.IDPESSOADEPARA          = D.IDPESSOADEPARA AND
				C.IDTIPORELACIONAMENTO    = E.IDTIPORELACIONAMENTO AND    
				D.idPessoa                = G.idPessoa AND
				E.SGTIPORELACIONAMENTO	  = 'U'		   AND
				B1.CdAreaRegistro		  = :cddd	   AND
				B.NRLINHA				  = :clinha    AND
				F.IDPESSOA(+) 			  = G.IDPESSOA AND
				F.IDSEXO		          = H.IDSEXO   AND
				C.idTipoRelacionamento    =  1 AND
        ROWNUM < 2;		

		EXEC SQL
			SELECT
				NVL(pc.dscontato, ' ')
			INTO 
				:cEmail:inEmail
			FROM
				LINHA.LINHATELEFONICA A,
				LINHA.LINHABASE  B,
				APOIO.AREAREGISTRO B1,
				CUSTOMER.PESSOALINHA C, 
				CUSTOMER.PESSOADEPARA D,
				CUSTOMER.TIPORELACIONAMENTO E,
				CUSTOMER.PESSOA G,
				CUSTOMER.PESSOACOMUNICACAO PC 
			WHERE 	
				A.IDLINHABASE             = B.IDLINHABASE AND
				B.IDAREAREGISTRO          = B1.IDAREAREGISTRO AND
				C.IDLINHATELEFONICA       = A.IDLINHATELEFONICA AND
				C.IDPESSOADEPARA          = D.IDPESSOADEPARA AND
				C.IDTIPORELACIONAMENTO    = E.IDTIPORELACIONAMENTO AND    
				D.idPessoa                = G.idPessoa AND
				B1.CdAreaRegistro		  = :cddd	   AND
				B.NRLINHA				  = :clinha    AND
				C.idTipoRelacionamento    = 1 AND
				PC.IDTIPOCOMUNICACAO = 6 AND
				PC.IDPESSOA = G.IDPESSOA AND
				ROWNUM < 2;
		}
		else
		{
			tuxfw_getlogger()->debug("Tipo pessoa nao identificado. Diferente de PJ e PF.");
		}
    }

	tuxfw_getlogger()->debug("Retorno da query nmNome[%s], IDTIPOLINHA[%d], nmPessoa[%s], DTNASCIMENTO[%s], SGSEXO[%s]", cNmPessoa, idTipoLinha, cNmNomeCompleto, cDtNascimento, cSgSexo);
	
	tuxfw_getlogger()->debug("validarSenhaWS --> Conteudo de variaveis:");
	
	if ( inidTipoLinha != -1 )
    {
        tuxfw_getlogger()->debug("validarSenhaWS --> idTipoLinha = %d",idTipoLinha);
        this->setIdTipoLinha(idTipoLinha);
    }
    else
    {
        tuxfw_getlogger()->debug("validarSenhaWS --> idTipoLinha []" );
        this->setIdTipoLinha( 0x0 );
    }
	
	tuxfw_getlogger()->debug("validarSenhaWS --> cNmPessoa = %s",cNmPessoa);
	this->setNmPessoa(CUtil::trim(cNmPessoa));
	
    this->setNmNomeCompleto(CUtil::trim(cNmNomeCompleto));
	if ( cDtNascimento == NULL)
		sprintf(cDtNascimento, "%s", " ");
	else if ( strlen(cDtNascimento) == 0 )
		sprintf(cDtNascimento, "%s", " ");
		
	tuxfw_getlogger()->debug("validarSenhaWS --> cNmNomeCompleto = %s",cNmNomeCompleto);
	this->setDtNascimento(CUtil::trim(cDtNascimento));

	tuxfw_getlogger()->debug("validarSenhaWS --> cSgSexo = %s",cSgSexo);
	this->setSgSexo(CUtil::trim(cSgSexo));	
	
	
	if ( cEmail == NULL)
		sprintf(cEmail, "%s", " ");
	else if ( strlen(cEmail) == 0 )
		sprintf(cEmail, "%s", " ");
    this->setEmail(CUtil::trim(cEmail));
	
	
/*
	// ID não existe. Seta o ID para -1.
	if (sqlca.sqlcode == NO_DATA_FOUND){ 
		throw TuxBasicOraException(sqlca.sqlcode);
	}
*/  
	return;

	sqlErrorConstrutor:
		tuxfw_getlogger()->debug("ERRO: [CSenha::consultarDadosCliente] sqlca.sqlcode = %d",sqlca.sqlcode);
		throw TuxBasicOraException(sqlca.sqlcode);

}

void CSenha::setNmNomeCompleto(char *value) {
	strcpy( this->m_cNmNomeCompleto, value );
}

void CSenha::setSgSexo(char *value) {
	strcpy( this->m_cSgSexo, value );
}

void CSenha::setDtNascimento(char *value) {
	strcpy( this->m_cDtNascimento, value );
}

char * CSenha::getNmNomeCompleto() {
	return this->m_cNmNomeCompleto;
}

char * CSenha::getSgSexo() {
	return this->m_cSgSexo;
}

char * CSenha::getDtNascimento() {
	return this->m_cDtNascimento;
}

void CSenha::setEmail(char *value) {
	strcpy( this->m_e_mail, value );
}

char * CSenha::getEmail() {
	return this->m_e_mail;
}

int CSenha::zerarQtdTentativaSenha( int idLinhaTelefonica, int idtipoStatusSenha )
{

	struct sqlca sqlca;
	
	// Variáveis de paramentro para o  ProC
	EXEC SQL BEGIN DECLARE SECTION;	
	int   iIdLinhaTelefonica;
	int   iIdtipoStatusSenha;
	int   iIdSenha;
	short indIdSenha;
	EXEC SQL END DECLARE SECTION;
	
	iIdLinhaTelefonica = idLinhaTelefonica;
	iIdtipoStatusSenha = idtipoStatusSenha;
	iIdSenha = 0;
	indIdSenha = -1;
	int iQtdRegistros = 0;
	
	
    EXEC SQL WHENEVER SQLERROR GOTO sqlError;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;


    EXEC SQL DECLARE Cursor CURSOR FOR 
			 SELECT UNIQUE IDSENHA FROM 
			 (     
				SELECT S.IDSENHA
						FROM 
							CUSTOMER.SENHA S,
							CUSTOMER.PESSOALINHA PESSOALINHA,
							CUSTOMER.PESSOADEPARA PESSOADEPARA,
							APOIO.TIPOSTATUSSENHA TIPOSTATUSSENHA
						WHERE
							PESSOALINHA.IDPESSOADEPARA = PESSOADEPARA.IDPESSOADEPARA AND
							S.IDPESSOA = PESSOADEPARA.IDPESSOA AND
							S.IDTIPOSTATUSSENHA = TIPOSTATUSSENHA.IDTIPOSTATUSSENHA AND
							PESSOALINHA.IDLINHATELEFONICA = :iIdLinhaTelefonica
				UNION
				SELECT S.IDSENHA 
					FROM
						CUSTOMER.SENHA S,
						CUSTOMER.PESSOALINHA PESSOALINHA,
						APOIO.TIPOSTATUSSENHA TIPOSTATUSSENHA
					WHERE
						S.IDPESSOALINHA = PESSOALINHA.IDPESSOALINHA AND
						S.IDTIPOSTATUSSENHA = TIPOSTATUSSENHA.IDTIPOSTATUSSENHA AND
						PESSOALINHA.IDLINHATELEFONICA =  :iIdLinhaTelefonica
			 );

    tuxfw_getlogger()->debug("Abrindo o cursor...");
    EXEC SQL OPEN Cursor;
    tuxfw_getlogger()->debug("Cursor aberto.");

    for ( ;; )
    {
        EXEC SQL
            FETCH
                Cursor
            INTO
                :iIdSenha:indIdSenha;

        if ( sqlca.sqlcode ) 
		{ 
			break; 
		}

        iQtdRegistros++;
		
		// ZERA A QUANTIDADE DE TENTATIVAS ERRADAS.
		  EXEC SQL 
			 UPDATE CUSTOMER.SENHA S2
					SET S2.QTTENTATIVAERRO = 0
					WHERE 
			 S2.IDTIPOSTATUSSENHA <> :iIdtipoStatusSenha AND
			 S2.IDSENHA = :iIdSenha;

    }// while (1)

    tuxfw_getlogger()->debug("Zerou %d registro(s) de CUSTOMER.SENHA",iQtdRegistros);

    // finaliza
	tuxfw_getlogger()->debug("Fechando cursor...");
    EXEC SQL CLOSE Cursor;

	return 1;

sqlError:
		tuxfw_getlogger()->debug("Finalizando CSenha::zerarQtdTentativaSenha() com erro ORACLE (%d)", sqlca.sqlcode);
		tuxfw_getlogger()->debug("ERRO: [CSenha::zerarQtdTentativaSenha] sqlca.sqlcode = %d",sqlca.sqlcode);
		return -1;

}
