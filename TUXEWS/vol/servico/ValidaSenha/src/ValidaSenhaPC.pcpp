/* $Id: ValidaSenhaPC.pcpp,v 1.1.4.4 2010/12/22 19:32:52 a5114878 Exp $ */

#undef SQLCA
#define SQLCA_NONE
#include<sqlca.h>
#include<sqlda.h>
#include <ctype.h>

#include <tuxfw.h>
#include "../../RegistraContato/include/stRegistraContato.h"

void sql_error_validasenha(sqlca*);

extern bool proCRegistraContatoAlteracao(int, stRegistraContato*);

int validaCliente(int idPessoa, char* senha, int idCanal, int idPessoaUsuario, int *idSenhaCli, int idPessoaLinha, int iIdTerminal);
int validaSenhaCliente(int idConta, int idPessoa, char* senha, int idCanal, int idPessoaUsuario, int *idSenhaCli, int idPessoaLinha, int iIdTerminal);
int registraValidacao(int tipoPessoa, int idSenha, int chave, int status, int idCanal, int idPessoaUsuario, int idPessoaLinha, int idPessoaLinhaCliente, int iIdTerminal);
void bloqueiaUsuario(int idCanal, int idPessoaUsuario, int iIdTerminal);
void bloqueiaCliente(int idPessoa, int idCanal, int idPessoaUsuario, int idPessoaLinha, int iIdTerminal);
void bloqueiaNiveisSuperiores( int idConta, int idCanal, int idPessoaUsuario, int _idSenha, int numIteracao, int idPessoaLinha, int iIdTerminal);
char* trim(char *pStr);


// Usado no bloqueio comandado pelo cliente.
int idUsuario = 0;

/**
* Valida a senha do telefone, buscando primeiro os níveis superioes.
*/
void validaSenha(char* telefone, char* senha, int* resultado, char* titularidade, int idCanal, int idPessoaUsuario, int iIdTerminal)
{
   ULOG_START("validaSenha()");

    struct sqlca sqlca;

    int prefixo = 0;
    int numero  = 0;
    char cConv[3];
    char senhaOriginal[256];

    int idSenhaCli = 0;

    strcpy(senhaOriginal, senha);

    if ( telefone[0]=='0' ) 
    {
        strncpy(cConv,telefone+1,2);cConv[2]=0;
        prefixo = atoi(cConv);
        numero  = atoi(telefone+3);
    }
    else
    {
        strncpy(cConv,telefone,2);cConv[2]=0;
        prefixo = atoi(cConv);
        numero  = atoi(telefone+2);
    }

    EXEC SQL BEGIN DECLARE SECTION;
        int   oprefixo         = prefixo;
        int   otelefone        = numero;
        char  osenha[256];

        int   idpessoalinha    = 0;
        short indidpessoalinha = 0;

        int   idpessoalinhacliente    = 0;
        short indidpessoalinhacliente = 0;

        char  senhabanco[256];
//      short indsenhabanco    = 0;
        int   statussenha      = 0;
        short indstatussenha   = 0;
        int   idpessoa         = 0;
        short indidpessoa      = 0;

        int   idsenha         = 0;
        short indidsenha      = 0;

        int   diaatual        = 0;

        int   diabloqueio     = 0;
        short inddiabloqueio  = 0;

        int   introcasenha    = 0;
        short indintrocasenha = 0;

    EXEC SQL END DECLARE SECTION;


    strcpy(osenha, senha);


    EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL 
        SELECT
            idPessoaLinha
        INTO
            :idpessoalinha:indidpessoalinha
        FROM
            CUSTOMER.TelefoneUsuarioV09
        WHERE
                cdAreaRegistro = :oprefixo
                AND nrLinha    = :otelefone
                AND idTipoRelacionamento = 1;

    // Pessoa linha não encontrado.
    if (indidpessoalinha == -1 || idpessoalinha <= 0)
    {
        *resultado = -1;
        ULOG_END("validaSenha()");
        return;
    }

    idUsuario = idpessoalinha;

    EXEC SQL 
        SELECT
            idPessoa, idPessoaLinha
        INTO
            :idpessoa:indidpessoa,
            :idpessoalinhacliente:indidpessoalinhacliente
        FROM
            CUSTOMER.TelefoneUsuarioV09
        WHERE
                cdAreaRegistro = :oprefixo
                AND nrLinha    = :otelefone
                AND idTipoRelacionamento = 2;

    // Testa primeiro os níveis superiores para verificar se 
    // a senha é de um cliente.
    ULOG("Antes de recorrer os niveles superiores\n");
    int resNivelSup = validaCliente(idpessoa, osenha, idCanal, idPessoaUsuario, &idSenhaCli, idpessoalinhacliente, iIdTerminal);
    ULOG("Recorridos os niveles superiores y no encontrada senha: %d\n", resNivelSup);
    EXEC SQL
        SELECT
            NVL(cdSenha, ' '),
            idTipoStatusSenha,
            TO_CHAR(dtBloqueio,'DD') AS diaBloqueio,
            TO_CHAR(sysdate,'DD') AS diaAtual,
            idSenha,
            inTrocaSenha
        INTO
            :senhabanco,
            :statussenha:indstatussenha,
            :diabloqueio:inddiabloqueio,
            :diaatual,
            :idsenha:indidsenha,
            :introcasenha:indintrocasenha
        FROM
            customer.Senha
        WHERE
            idPessoaLinha = :idpessoalinha;

    if ((resNivelSup != -3) && (resNivelSup <= 0)) 
    {
        ULOG("Reuperando senha: %d\n", idpessoalinha);
        if (inddiabloqueio == -1)
            diabloqueio = 0;

        if (sqlca.sqlcode == 0 ) //&& indsenhabanco != -1
        {
            
            if ( strcmp(trim(senhabanco), "") != 0 && strcmp(trim(senhabanco), senhaOriginal) == 0 && introcasenha == 0 )// Senha maior que 0 E senhabanco igual a senhaOriginal.
            {
                if (
                        indstatussenha != -1 
                        && (statussenha == 1 || 
                        (
                            statussenha == 2 && 
                            diaatual > diabloqueio)
                        )
                    )
                {
                    int status = 1;
                                                 
                    if (indintrocasenha != -1 && introcasenha == 1)
                        status = 2;
                    *resultado = registraValidacao(1, idsenha, idpessoa, status, idCanal, idPessoaUsuario, idpessoalinha,  idpessoalinhacliente, iIdTerminal);
                }
                else
                    *resultado = registraValidacao(1, idsenha, idpessoa, -2, idCanal, idPessoaUsuario, idpessoalinha, idpessoalinhacliente, iIdTerminal);

            }
            else
            {
                if(resNivelSup == -2 && idSenhaCli > 0)
                {
                    *resultado = registraValidacao(1, idsenha, idpessoa, -2, idCanal, idPessoaUsuario, idpessoalinha, idpessoalinhacliente,  iIdTerminal);
                }
                else
                {
                    if(idsenha == 0 && indidsenha == -1)
                        *resultado = -100;
                    else if(introcasenha == 1)
                        *resultado = -101;
                    else
                        *resultado = registraValidacao(1, idsenha, idpessoa, -2, idCanal, idPessoaUsuario, idpessoalinha, idpessoalinhacliente, iIdTerminal);
                }
            }
        }
        else
        {           
            if(resNivelSup == -2 && idSenhaCli > 0)
                *resultado = registraValidacao(2, idSenhaCli, idpessoa, -2, idCanal, idPessoaUsuario, idpessoalinha, idpessoalinhacliente, iIdTerminal);
            else
                *resultado = resNivelSup;
        }

        
        strcpy( titularidade, "U" );
        ULOG( "Usuario logado..." );
    }
    else
    {
        if (resNivelSup > 0) 
        {
            ULOG("Recuperando senha validada la del cliente: %d\n", idpessoalinha);

            if (sqlca.sqlcode == 0) //&& indsenhabanco != -1
            {
                EXEC SQL
                UPDATE
                    customer.Senha
                SET
                    qtTentativaErro = null
                WHERE   
                    idSenha = :idsenha
                    AND idTipoStatusSenha = 1;
            }
        }
        strcpy( titularidade, "C" );
        *resultado = resNivelSup;
        ULOG( "Cliente logado..." );
    }
   ULOG_END("validaSenha()");
}


int validaCliente(int idPessoa, char* senha, int idCanal, int idPessoaUsuario, int *idSenhaCli, int idPessoaLinha, int iIdTerminal)
{
   ULOG_START("validaCliente()");
    int resultado = 0;

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
        int oidpessoa = idPessoa;
        
        int   idconta    = 0;
        short indidconta = 0;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);

        // Declara o cursor a ser executado.
        EXEC SQL DECLARE clienteConta CURSOR FOR
        SELECT
            idConta
        FROM
            customer.UsuarioContaV11
        WHERE
            idPessoaOrigem = :oidpessoa;

        // Executa o cursor.
        EXEC SQL OPEN clienteConta;

        // Buscará os níveis superiores até encontar uma senha incompatível ou acabar o loop.
        while (resultado == 0) 
        {

                EXEC SQL FETCH clienteConta INTO :idconta:indidconta;

        ULOG("Recuperando Conta: %d\n", idconta);
        ULOG("Recuperando Conta: %d\n", indidconta);

        if (indidconta == -1 || idconta > 0)
        {
            resultado = validaSenhaCliente(idconta, idPessoa, senha, idCanal, idPessoaUsuario, idSenhaCli, idPessoaLinha, iIdTerminal);
        }
        else
        {
            if (idconta == 0)
                resultado = -2;
            else
                resultado = 0;
        }
        ULOG("Resultado: %d\n", resultado);
        }

        EXEC SQL CLOSE clienteConta;
        
   ULOG_END("validaCliente()");
    return resultado;
}

int validaSenhaCliente(int idConta, int idPessoa, char* senha, int idCanal, int idPessoaUsuario, int *idSenhaCli, int idPessoaLinha, int iIdTerminal)
{
   ULOG_START("validaSenhaCliente()");
    struct sqlca sqlca;

    int    resultado = 0;

    EXEC SQL BEGIN DECLARE SECTION;
        int   idcontapai      = 0;
        short indidcontapai   = 0;
        int   oidconta        = idConta;
        
        char  senhacliente[256];
        short indsenhacliente = 0;

        int   idpessoa        = 0;
        short indidpessoa     = 0;

        int   idtipostatus    = 0;
        short indidtipostatus = 0;

        int   idsenha         = 0;
        short indidsenha      = 0;

        int   diaatual        = 0;

        int   diabloqueio     = 0;
        short inddiabloqueio  = 0;

        int   introcasenha    = 0;
        short indintrocasenha = 0;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);

    EXEC SQL
        SELECT
            idContaPai
        INTO
            :idcontapai:indidcontapai
        FROM    
            customer.ContaHierarquia
        WHERE   
            idConta = :oidconta;


        ULOG("Recuperando Conta Cliente\n");

    if (indidcontapai != -1 && idcontapai > 0 && sqlca.sqlcode == 0)
        resultado = validaSenhaCliente(idcontapai, idPessoa, senha, idCanal, idPessoaUsuario, idSenhaCli, idPessoaLinha, iIdTerminal);
    
    if (resultado == 0) {

        ULOG("Tratando Resultado\n");
        EXEC SQL 
            SELECT
                senha,
                idPessoa,
                idTipoStatusSenha,
                TO_CHAR(dtBloqueio,'DD') AS diaBloqueio,
                TO_CHAR(sysdate,'DD') AS diaAtual,
                idSenha,
                inTrocaSenha
            INTO
                :senhacliente:indsenhacliente,
                :idpessoa:indidpessoa,
                :idtipostatus:indidtipostatus,
                :diabloqueio:inddiabloqueio,
                :diaatual,
                :idsenha:indidsenha,
                :introcasenha:indintrocasenha
            FROM
                customer.ContaSenhaClienteV06
            WHERE
                idConta = :oidconta;

            if (inddiabloqueio == -1)
                diabloqueio = 0;

            if (indsenhacliente != -1 && senhacliente > 0 && strcmp(trim(senhacliente), senha)==0 && introcasenha == 0)
            {
                int status = 1;
                if (
                        indidtipostatus != -1 
                        && (idtipostatus == 1 || 
                        (
                            idtipostatus == 2 && 
                            diaatual > diabloqueio)
                        )
                    )
                {
                                                 
                    if (indintrocasenha != -1 && introcasenha == 1)
                        status = 2;
                        
                    resultado = registraValidacao(2, idsenha, idpessoa, status, idCanal, idPessoaUsuario, idPessoaLinha, idPessoaLinha, iIdTerminal);
                }
                else
                {
                    status = 3;
                    resultado = registraValidacao(2, idsenha, idpessoa, status, idCanal, idPessoaUsuario, idPessoaLinha, idPessoaLinha, iIdTerminal);
                }

            }
            else
            {
                if(idsenha == 0 && indidsenha == -1)
                    resultado = -100;
                else if(introcasenha == 1)
                    resultado = -101;
                else
                {
                    *idSenhaCli = idsenha;
                    resultado = -2;
                }
            }
    }
    
    ULOG_END("validaSenhaCliente()");
    
    return resultado;
}


/**
* Executa os processos registro de histórico da validação.
*/
int registraValidacao(int tipoPessoa, int idSenha, int chave, int status, int idCanal, int idPessoaUsuario, int idPessoaLinha, int idPessoaLinhaCliente, int iIdTerminal)
{
   ULOG_START("registraValidacao()");
   
    struct stRegistraContato m_stDados;

    memset(&m_stDados,0,sizeof(m_stDados));

    struct sqlca sqlca;

    int resultado = status;

    m_stDados.idCanal              = idCanal;
    m_stDados.idPessoaUsuario      = idPessoaUsuario;
    m_stDados.idSenha              = idSenha;
    m_stDados.idTipoHistoricoSenha = 2;
    m_stDados.idTipoSistema        = 1;
    m_stDados.idTipoSenha          = 1;
    m_stDados.idTipoStatusSenha    = 1;
    m_stDados.idPessoaLinha        = idPessoaLinha;
    m_stDados.iIdTerminal          = iIdTerminal;

    EXEC SQL BEGIN DECLARE SECTION;

        int   idsenha            = idSenha;

        int   idpessoasenha      = chave;

        int   diaultimoacesso    = 0;
        short inddiaultimoacesso = 0;

        int   nrtentativas       = 0;
        short indnrtentativas    = 0;

        int   idstatussenha      = 0;
        short indstatussenha     = 0;

        char  dtUltimosAcesso[11]="";
        char  dtHoje[11]="";

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);

    ULOG("Tratando Validacao: %d para status: %d\n", idsenha, status);
    // Bem Sucedido
    if (status == 1)    
    {

        // Verifica se o usuário ja acessou o sistema uma vez.
        EXEC SQL
            SELECT
                TO_CHAR(dtPrimeiroAcesso,'DD')
            INTO
                :diaultimoacesso:inddiaultimoacesso
            FROM
                customer.Senha
            WHERE   
                idSenha = :idsenha;

        // Caso não tenha acessado ainda indica o dia do primeiro
        // acesso.
        if (inddiaultimoacesso == -1 || diaultimoacesso <= 0)
        {
            EXEC SQL 
                UPDATE 
                    customer.Senha
                SET
                    dtPrimeiroAcesso = SYSDATE
                WHERE
                idSenha = :idsenha;
        }

        EXEC SQL
            UPDATE
                customer.Senha
            SET
                dtUltimoAcesso = SYSDATE,
                dtBloqueio     = null,
                qtTentativaErro= null,
                idTipoStatusSenha = 1
            WHERE   
                idSenha = :idsenha;
            
        if (tipoPessoa == 1)
        {   
            EXEC SQL
            UPDATE
                customer.Senha
            SET
                qtTentativaErro= null
            WHERE   
                idPessoa = :idpessoasenha
                AND idTipoStatusSenha = 1;
        }
    }
    else if (status == -2)
    {
            
        EXEC SQL
            SELECT
                idTipoStatusSenha,
                qtTentativaErro,
                NVL(TO_CHAR(dtUltimoAcesso, 'dd/mm/yyyy'), ' '),
                TO_CHAR(sysdate, 'dd/mm/yyyy')
            INTO
                :idstatussenha:indstatussenha,
                :nrtentativas:indnrtentativas,
                :dtUltimosAcesso,
                :dtHoje
            FROM
                customer.Senha
            WHERE
                idSenha = :idsenha;

        if (indstatussenha != -1 && idstatussenha == 1)
        {
            //Caso o número de tentativas incorretas seja <= 2 E a última validação não tenha sido hoje, então reinicia a qtTentativaErro.
            if (nrtentativas <= 2 && strcmp(dtUltimosAcesso, dtHoje) != 0)
                nrtentativas = 0;

            if (indnrtentativas != -1 && nrtentativas < 3)
            {

                if (++nrtentativas == 3)
                {
                    EXEC SQL
                        UPDATE
                            customer.Senha
                        SET
                            idTipoStatusSenha = 2,
                            dtBloqueio = SYSDATE,
                            qtTentativaErro = :nrtentativas,
                            dtUltimoAcesso = sysdate
                        WHERE
                            idSenha = :idsenha;

                        if (tipoPessoa == 1)
                        {   
                            EXEC SQL
                            UPDATE
                                customer.Senha
                            SET
                                idTipoStatusSenha = 2,
                                dtBloqueio = SYSDATE,
                                qtTentativaErro = :nrtentativas,
                                dtUltimoAcesso = sysdate
                            WHERE   
                                idPessoa = :idpessoasenha;
                        }

                    // Resultado -3 indica o bloqueio da conta.

					if (m_stDados.idCanal == 9)
						resultado = -2;
					else
						resultado = -3;

                    m_stDados.idTipoHistoricoSenha = 8;
                    m_stDados.idTipoStatusSenha    = 2;
                    
                    bloqueiaCliente( chave, idCanal, idPessoaUsuario, idPessoaLinhaCliente, iIdTerminal);

                } 
                else
                {
                    EXEC SQL
                        UPDATE
                            customer.Senha
                        SET
                            qtTentativaErro = :nrtentativas,
                            dtUltimoAcesso = sysdate
                        WHERE
                        idSenha = :idsenha;

                    if (tipoPessoa == 1)
                    {   
                        EXEC SQL
                        UPDATE
                            customer.Senha
                        SET
                            qtTentativaErro = :nrtentativas,
                            dtUltimoAcesso = sysdate
                        WHERE   
                            idPessoa = :idpessoasenha
                            AND idTipoStatusSenha = 1;
                    }

                    m_stDados.idTipoHistoricoSenha = 10;

                }
            }
            else if (indnrtentativas == -1)
            {
                    EXEC SQL
                        UPDATE
                            customer.Senha
                        SET
                            qtTentativaErro = 1,
                            dtUltimoAcesso = sysdate
                        WHERE
                        idSenha = :idsenha;

                    if (tipoPessoa == 1)
                    {   
                        EXEC SQL
                        UPDATE
                            customer.Senha
                        SET
                            qtTentativaErro = 1,
                            dtUltimoAcesso = sysdate
                        WHERE   
                            idPessoa = :idpessoasenha
                            AND idTipoStatusSenha = 1;
                    }

                    m_stDados.idTipoHistoricoSenha = 10;
            }
        }
        else if (idstatussenha == 2)
            resultado = -3;
    }
    else if (status == 3)
    {
        resultado = -3;
    }
    proCRegistraContatoAlteracao(idSenha, &m_stDados);              
    
    ULOG_END("registraValidacao()");
    
    return resultado;
}

void bloqueiaUsuario(int idCanal, int idPessoaUsuario, int iIdTerminal) 
{
   ULOG_START("bloqueiaUsuario()");
   
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int idpessoalinha = idUsuario;

        int   idsenha       = 0;
        short indidsenha    = 0;

    EXEC SQL END DECLARE SECTION;

    ULOG ("Bloquea: idPessoaLinha: %ld\n", idpessoalinha);
        
    EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);

    EXEC SQL 
        SELECT 
            idSenha 
        INTO    
            :idsenha:indidsenha
        FROM 
            customer.Senha 
        WHERE 
            idPessoaLinha = :idpessoalinha;

    if (sqlca.sqlcode == 0 && indidsenha != -1 && idsenha > 0) {

        EXEC SQL
            UPDATE
                customer.Senha
            SET
                idTipoStatusSenha = 2,
                dtBloqueio = SYSDATE
            WHERE
                idPessoaLinha = :idpessoalinha;
            
        struct stRegistraContato m_stDados;

        memset(&m_stDados,0,sizeof(m_stDados));

        m_stDados.idCanal              = idCanal;
        m_stDados.idPessoaUsuario      = idPessoaUsuario;
        m_stDados.idTipoHistoricoSenha = 8;
        m_stDados.idTipoSistema        = 1;
        m_stDados.idTipoSenha          = 1;
        m_stDados.idTipoStatusSenha    = 1;
        m_stDados.iIdTerminal		   = iIdTerminal;

		ULOG ("bloqueiaUsuario %d\n", iIdTerminal);

        proCRegistraContatoAlteracao(idsenha, &m_stDados);              

    }

   ULOG_END("bloqueiaUsuario()");
}


void bloqueiaNiveisSuperiores( int idConta, int idCanal, int idPessoaUsuario, int _idSenha, int numIteracao, int idPessoaLinha, int iIdTerminal )
{
   ULOG_START("bloqueiaNiveisSuperiores()");

    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;

        int   oidconta      = idConta;
        
        int   idcontapai    = 0;
        short indidcontapai = 0;

        int   idsenha       = 0;
        short indidsenha    = 0;

    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);


    ULOG ("Bloquea: idConta: %d\n", oidconta);
    EXEC SQL
        SELECT
            idContaPai
        INTO
            :idcontapai:indidcontapai
        FROM    
            customer.ContaHierarquia
        WHERE   
            idConta = :oidconta;


    if (indidcontapai != -1 && idcontapai > 0 && sqlca.sqlcode == 0)
        bloqueiaNiveisSuperiores(idcontapai, idCanal, idPessoaUsuario, _idSenha, 1, idPessoaLinha, iIdTerminal);

    EXEC SQL
        SELECT
            idSenha
        INTO
            :idsenha:indidsenha
        FROM
            customer.ContaSenhaClienteV06
        WHERE
            idConta = :oidconta;

    if (sqlca.sqlcode == 0 && indidsenha != -1 && idsenha > 0 && (idsenha != _idSenha || numIteracao == 0))
    {
    ULOG ("Bloquea: idSenha: %d\n", idsenha);
        EXEC SQL
            UPDATE
                customer.Senha
            SET
                idTipoStatusSenha = 2,
                dtBloqueio = SYSDATE
            WHERE
                idSenha = :idsenha;
            
            struct stRegistraContato m_stDados;

            memset(&m_stDados,0,sizeof(m_stDados));

            m_stDados.idCanal              = idCanal;
            m_stDados.idPessoaUsuario      = idPessoaUsuario;
            m_stDados.idTipoHistoricoSenha = 8;
            m_stDados.idTipoSistema        = 1;
            m_stDados.idTipoSenha          = 1;
            m_stDados.idTipoStatusSenha    = 1;
            m_stDados.idPessoaLinha        = idPessoaLinha;
			m_stDados.iIdTerminal		   = iIdTerminal;

			ULOG ("bloqueiaNiveisSuperiores %d\n", iIdTerminal);

            proCRegistraContatoAlteracao(idsenha, &m_stDados);              
    }
    
    ULOG_END("bloqueiaNiveisSuperiores()");
}

int verificarQuatidadeTentativa(char* telefone, char* senha)
{
   
   ULOG_START("verificarQuatidadeTentativa()");
    struct sqlca sqlca;

    int prefixo = 0;
    int numero  = 0;
    char cConv[3];

    char senhaOriginal[256];
        
    strcpy(senhaOriginal, senha);

    if ( telefone[0]=='0' ) 
    {
        strncpy(cConv,telefone+1,2);cConv[2]=0;
        prefixo = atoi(cConv);
        numero  = atoi(telefone+3);
    }
    else
    {
        strncpy(cConv,telefone,2);cConv[2]=0;
        prefixo = atoi(cConv);
        numero  = atoi(telefone+2);
    }


    EXEC SQL BEGIN DECLARE SECTION;
        int   oprefixo         = prefixo;
        int   otelefone        = numero;
        char  osenha[256];

        int   idpessoalinha    = 0;
        short indidpessoalinha = 0;
        //char  senhabanco[256];
        //short indsenhabanco    = 0;

        int   idpessoa         = 0;

        int   qtTentativaErroC = 0;
        int   qtTentativaErroU = 0;


    EXEC SQL END DECLARE SECTION;


    strcpy(osenha, senha);


    EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);


    //Identifica idPessoaLinha para Usuario
    EXEC SQL 
        SELECT
            idPessoaLinha
        INTO
            :idpessoalinha:indidpessoalinha
        FROM
            CUSTOMER.TelefoneUsuarioV09
        WHERE
            cdAreaRegistro       = :oprefixo
        AND nrLinha              = :otelefone
        AND idTipoRelacionamento = 1;

    // Pessoa linha não encontrado.
    if (indidpessoalinha == -1 || idpessoalinha <= 0)
    {
       ULOG_END("verificarQuatidadeTentativa()");
        return 0;
    }

    //Identifica idPessoa para Cliente
    EXEC SQL 
        SELECT
            idPessoa
        INTO
            :idpessoa
        FROM
            CUSTOMER.TelefoneUsuarioV09
        WHERE
                cdAreaRegistro = :oprefixo
                AND nrLinha    = :otelefone
                AND idTipoRelacionamento = 2;

    //Busca a Senha do Cliente
    EXEC SQL
        SELECT
            //cdSenha,
            NVL(qtTentativaErro, 0)
        INTO
            //:senhabanco, //:indsenhabanco
            :qtTentativaErroC
        FROM
            CUSTOMER.Senha
        WHERE
            idPessoa = :idpessoa;

    //Busca a Senha do Usuario
    EXEC SQL
        SELECT
            //cdSenha,
            NVL(qtTentativaErro,0)
        INTO
            //:senhabanco, //:indsenhabanco
            :qtTentativaErroU
        FROM
            CUSTOMER.Senha
        WHERE
            idPessoaLinha = :idpessoalinha;
   ULOG_END("verificarQuatidadeTentativa()");
    if(qtTentativaErroC)
        return qtTentativaErroC;
    else
        return qtTentativaErroU;

}

void bloqueiaCliente(int idPessoa, int idCanal, int idPessoaUsuario, int idPessoaLinha, int iIdTerminal)
{
   ULOG_START("bloqueiaCliente()");
   
    struct sqlca sqlca;

    int numIteracao = 0;
    EXEC SQL BEGIN DECLARE SECTION;
        int oidpessoa = idPessoa;

        int idSenha;
        short i_idSenha = -1;

        int   idconta    = 0;
        short indidconta = 0;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR  DO sql_error_validasenha(&sqlca);

        EXEC SQL
        SELECT
            idSenha
        INTO
            :idSenha:i_idSenha
        FROM
            customer.Senha
        WHERE
            idPessoa = :oidpessoa;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    ULOG ("Bloquea: idPessoa: %d\n", oidpessoa);
    // Declara o cursor a ser executado.
        EXEC SQL DECLARE clienteSenha CURSOR FOR
        SELECT
            idConta
        FROM
            customer.UsuarioContaV11
        WHERE
            idPessoaOrigem = :oidpessoa;

        // Executa o cursor.
        EXEC SQL OPEN clienteSenha;

        // Buscará os níveis superiores até encontar uma senha incompatível ou acabar o loop.
        while (true) 
        {

                EXEC SQL FETCH clienteSenha INTO :idconta:indidconta;

            ULOG("Recuperando Conta: %d\n", idconta);
            ULOG("Recuperando Conta: %d\n", indidconta);

            if (indidconta == -1 || idconta > 0)
            {
                bloqueiaNiveisSuperiores(idconta, idCanal, idPessoaUsuario, idSenha, numIteracao , idPessoaLinha, iIdTerminal);
                numIteracao++;
            }
        }

        EXEC SQL CLOSE clienteSenha;
    ULOG_END("bloqueiaCliente()");
}



void sql_error_validasenha(sqlca*sqlca)
{
    throw TuxBasicOraException(sqlca->sqlcode);
}




char* rtrim(char *pStr)
{
    int rInd;

    if (pStr == NULL)
            return NULL;

    rInd = strlen(pStr) - 1;
    while ( isspace(pStr[rInd]) && rInd >= 0)
    {
      rInd--;
    }

    pStr[rInd + 1] = '\0';
   
    return pStr;
}

char* ltrim(char *pStr)
{
    int lInd = 0;

    if (pStr == NULL)
            return NULL;

    //rInd = strlen(pStr) - 1;

    while (isspace(pStr[lInd])){
        lInd++;
    }

    pStr = pStr + lInd;
     
    return pStr;
}

char* trim(char *pStr){
    return ltrim(rtrim(pStr));      
}

int consultarTipoPessoaDB(int intNrLinha, int intCdAreaRegistro, int intTipoRelacionamento)
{
   
    ULOG_START("consultarTipoPessoaDB()");
   
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
    int iTipoRelacionamento;
    int iCdAreaRegistro;
    int iNrLinha;
    int idTipoPessoa;
    EXEC SQL END DECLARE SECTION;

    idTipoPessoa = -1;
    iCdAreaRegistro = intCdAreaRegistro;
    iNrLinha = intNrLinha;
    iTipoRelacionamento = intTipoRelacionamento;


    EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

    EXEC SQL WHENEVER SQLERROR GOTO OraException;
     
    EXEC SQL 
    SELECT
         atp.IDTIPOPESSOA
    INTO 
        :idTipoPessoa
	FROM
		LINHA.LINHATELEFONICA LINHATELEFONICA ,
		LINHA.LINHABASE       LINHABASE ,
		APOIO.AREAREGISTRO    AREAREGISTRO ,
		apoio.EstadoLinha		b,
		customer.pessoalinha		cpl,
		customer.pessoadepara		pdp,
		customer.pessoa				cp,
		apoio.tipopessoa			atp
	WHERE
	       CPL.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
	  AND
	       LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
	   AND
	        LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
	   AND
		LINHABASE.idEstadoLinha = b.idEstadoLinha
		AND	cdAreaRegistro = :iCdAreaRegistro
		AND nrLinha = :iNrLinha
		AND LINHATELEFONICA.IDLINHATELEFONICA = cpl.IDLINHATELEFONICA
		AND pdp.IDPESSOADEPARA = cpl.IDPESSOADEPARA
		AND pdp.IDPESSOA = cp.IDPESSOA
		AND cp.IDTIPOPESSOA = atp.idtipopessoa
		AND cpl.IDTIPORELACIONAMENTO = :iTipoRelacionamento;        

    ULOG_END("consultarTipoPessoaDB()");
   
    return idTipoPessoa;

    OraNoDataFound:
    OraException:   
        throw TuxBasicOraException(sqlca.sqlcode);  

}


int consultarTipoLinhaDB(int intNrLinha, int intCdAreaRegistro) 
{
    ULOG_START("consultarTipoLinhaDB()");
   
    struct sqlca sqlca;

    EXEC SQL BEGIN DECLARE SECTION;
    int  iCdAreaRegistro;
    int  iNrLinha;
    int  iIdTipoLinha;
    EXEC SQL END DECLARE SECTION;
    
    iCdAreaRegistro = intCdAreaRegistro;
    iNrLinha = intNrLinha;
    iIdTipoLinha = -1;

    // Marca ponto de controle de erro
    EXEC SQL WHENEVER NOT FOUND GOTO OraNoDataFound;

    EXEC SQL WHENEVER SQLERROR GOTO OraException;
     
    EXEC SQL 
    SELECT
        LINHATELEFONICA.idTipoLinha
    INTO
        :iIdTipoLinha
	FROM
		LINHA.LINHATELEFONICA LINHATELEFONICA ,
		LINHA.LINHABASE       LINHABASE ,
		APOIO.AREAREGISTRO    AREAREGISTRO ,
		apoio.EstadoLinha		b,
		customer.pessoalinha		cpl,
		customer.pessoadepara		pdp,
		customer.pessoa				cp,
		apoio.tipopessoa			atp
	WHERE
	       CPL.IDLINHATELEFONICA = LINHATELEFONICA.IDLINHATELEFONICA
	  AND
	       LINHATELEFONICA.IDLINHABASE = LINHABASE.IDLINHABASE
	   AND
	        LINHABASE.IDAREAREGISTRO = AREAREGISTRO.IDAREAREGISTRO
	   AND
		LINHABASE.idEstadoLinha = b.idEstadoLinha
		AND	AREAREGISTRO.cdAreaRegistro = :iCdAreaRegistro
		AND LINHABASE.nrLinha = :iNrLinha
		AND LINHATELEFONICA.IDLINHATELEFONICA = cpl.IDLINHATELEFONICA
		AND pdp.IDPESSOADEPARA = cpl.IDPESSOADEPARA
		AND pdp.IDPESSOA = cp.IDPESSOA
		AND cp.IDTIPOPESSOA = atp.idtipopessoa
		AND cpl.IDTIPORELACIONAMENTO = 1;        
    

    ULOG_END("consultarTipoLinhaDB()");
   
    return iIdTipoLinha;
    
    
    OraNoDataFound:
    OraException:
        throw TuxBasicOraException(sqlca.sqlcode);  

}